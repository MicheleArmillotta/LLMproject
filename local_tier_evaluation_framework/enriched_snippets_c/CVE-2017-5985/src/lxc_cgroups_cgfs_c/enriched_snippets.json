[
  {
    "function_name": "cgfs_chown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "2649-2686",
    "snippet": "static bool cgfs_chown(void *hdata, struct lxc_conf *conf)\n{\n\tstruct cgfs_data *d = hdata;\n\tstruct cgroup_process_info *info_ptr;\n\tchar *cgpath;\n\tbool r = true;\n\n\tif (!d)\n\t\treturn false;\n\n\tfor (info_ptr = d->info; info_ptr; info_ptr = info_ptr->next) {\n\t\tif (!info_ptr->hierarchy)\n\t\t\tcontinue;\n\n\t\tif (!info_ptr->designated_mount_point) {\n\t\t\tinfo_ptr->designated_mount_point = lxc_cgroup_find_mount_point(info_ptr->hierarchy, info_ptr->cgroup_path, true);\n\t\t\tif (!info_ptr->designated_mount_point) {\n\t\t\t\tSYSERROR(\"Could not chown cgroup %s: internal error (couldn't find any writable mountpoint to cgroup filesystem)\", info_ptr->cgroup_path);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tcgpath = cgroup_to_absolute_path(info_ptr->designated_mount_point, info_ptr->cgroup_path, NULL);\n\t\tif (!cgpath) {\n\t\t\tSYSERROR(\"Could not chown cgroup %s: internal error\", info_ptr->cgroup_path);\n\t\t\tcontinue;\n\t\t}\n\t\tr = do_cgfs_chown(cgpath, conf);\n\t\tif (!r && is_crucial_hierarchy(info_ptr->hierarchy)) {\n\t\t\tERROR(\"Failed chowning %s\\n\", cgpath);\n\t\t\tfree(cgpath);\n\t\t\treturn false;\n\t\t}\n\t\tfree(cgpath);\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int remove_cgroup(struct cgroup_mount_point *mp, const char *path, bool recurse,\n\t\t\t\tstruct lxc_conf *conf);",
      "static int cgroup_recursive_task_count(const char *cgroup_path);",
      "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);",
      "static void lxc_cgroup_process_info_free(struct cgroup_process_info *info);",
      "static void lxc_cgroup_process_info_free_and_remove(struct cgroup_process_info *info,\n\t\t\t\tstruct lxc_conf *conf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cgpath"
          ],
          "line": 2682
        },
        "resolved": true,
        "details": {
          "function_name": "cgfs_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2501-2518",
          "snippet": "static bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed chowning %s\\n\"",
            "cgpath"
          ],
          "line": 2678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_crucial_hierarchy",
          "args": [
            "info_ptr->hierarchy"
          ],
          "line": 2677
        },
        "resolved": true,
        "details": {
          "function_name": "is_crucial_hierarchy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "836-845",
          "snippet": "static bool is_crucial_hierarchy(struct cgroup_hierarchy *h)\n{\n\tchar **p;\n\n\tfor (p = h->subsystems; *p; p++) {\n\t\tif (is_crucial_cgroup_subsystem(*p))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);\n\nstatic bool is_crucial_hierarchy(struct cgroup_hierarchy *h)\n{\n\tchar **p;\n\n\tfor (p = h->subsystems; *p; p++) {\n\t\tif (is_crucial_cgroup_subsystem(*p))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_cgfs_chown",
          "args": [
            "cgpath",
            "conf"
          ],
          "line": 2676
        },
        "resolved": true,
        "details": {
          "function_name": "do_cgfs_chown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2601-2647",
          "snippet": "static bool do_cgfs_chown(char *cgroup_path, struct lxc_conf *conf)\n{\n\tstruct chown_data data;\n\tchar *fpath;\n\n\tif (!dir_exists(cgroup_path))\n\t\treturn true;\n\n\tif (lxc_list_empty(&conf->id_map))\n\t\t/* If there's no mapping then we don't need to chown */\n\t\treturn true;\n\n\tdata.cgroup_path = cgroup_path;\n\tdata.origuid = geteuid();\n\n\t/* Unpriv users can't chown it themselves, so chown from\n\t * a child namespace mapping both our own and the target uid\n\t */\n\tif (userns_exec_1(conf, chown_cgroup_wrapper, &data) < 0) {\n\t\tERROR(\"Error requesting cgroup chown in new namespace\");\n\t\treturn false;\n\t}\n\n\t/*\n\t * Now chmod 775 the directory else the container cannot create cgroups.\n\t * This can't be done in the child namespace because it only group-owns\n\t * the cgroup\n\t */\n\tif (chmod(cgroup_path, 0775) < 0) {\n\t\tSYSERROR(\"Error chmoding %s\\n\", cgroup_path);\n\t\treturn false;\n\t}\n\tfpath = lxc_append_paths(cgroup_path, \"tasks\");\n\tif (!fpath)\n\t\treturn false;\n\tif (chmod(fpath, 0664) < 0)\n\t\tSYSERROR(\"Error chmoding %s\\n\", fpath);\n\tfree(fpath);\n\tfpath = lxc_append_paths(cgroup_path, \"cgroup.procs\");\n\tif (!fpath)\n\t\treturn false;\n\tif (chmod(fpath, 0664) < 0)\n\t\tSYSERROR(\"Error chmoding %s\\n\", fpath);\n\tfree(fpath);\n\n\treturn true;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int remove_cgroup(struct cgroup_mount_point *mp, const char *path, bool recurse,\n\t\t\t\tstruct lxc_conf *conf);",
            "static int cgroup_recursive_task_count(const char *cgroup_path);",
            "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);",
            "static void lxc_cgroup_process_info_free_and_remove(struct cgroup_process_info *info,\n\t\t\t\tstruct lxc_conf *conf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int remove_cgroup(struct cgroup_mount_point *mp, const char *path, bool recurse,\n\t\t\t\tstruct lxc_conf *conf);\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\nstatic void lxc_cgroup_process_info_free_and_remove(struct cgroup_process_info *info,\n\t\t\t\tstruct lxc_conf *conf);\n\nstatic bool do_cgfs_chown(char *cgroup_path, struct lxc_conf *conf)\n{\n\tstruct chown_data data;\n\tchar *fpath;\n\n\tif (!dir_exists(cgroup_path))\n\t\treturn true;\n\n\tif (lxc_list_empty(&conf->id_map))\n\t\t/* If there's no mapping then we don't need to chown */\n\t\treturn true;\n\n\tdata.cgroup_path = cgroup_path;\n\tdata.origuid = geteuid();\n\n\t/* Unpriv users can't chown it themselves, so chown from\n\t * a child namespace mapping both our own and the target uid\n\t */\n\tif (userns_exec_1(conf, chown_cgroup_wrapper, &data) < 0) {\n\t\tERROR(\"Error requesting cgroup chown in new namespace\");\n\t\treturn false;\n\t}\n\n\t/*\n\t * Now chmod 775 the directory else the container cannot create cgroups.\n\t * This can't be done in the child namespace because it only group-owns\n\t * the cgroup\n\t */\n\tif (chmod(cgroup_path, 0775) < 0) {\n\t\tSYSERROR(\"Error chmoding %s\\n\", cgroup_path);\n\t\treturn false;\n\t}\n\tfpath = lxc_append_paths(cgroup_path, \"tasks\");\n\tif (!fpath)\n\t\treturn false;\n\tif (chmod(fpath, 0664) < 0)\n\t\tSYSERROR(\"Error chmoding %s\\n\", fpath);\n\tfree(fpath);\n\tfpath = lxc_append_paths(cgroup_path, \"cgroup.procs\");\n\tif (!fpath)\n\t\treturn false;\n\tif (chmod(fpath, 0664) < 0)\n\t\tSYSERROR(\"Error chmoding %s\\n\", fpath);\n\tfree(fpath);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Could not chown cgroup %s: internal error\"",
            "info_ptr->cgroup_path"
          ],
          "line": 2673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_to_absolute_path",
          "args": [
            "info_ptr->designated_mount_point",
            "info_ptr->cgroup_path",
            "NULL"
          ],
          "line": 2671
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_to_absolute_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1901-1944",
          "snippet": "static char *cgroup_to_absolute_path(struct cgroup_mount_point *mp,\n\t\t\t\t     const char *path, const char *suffix)\n{\n\t/* first we have to make sure we subtract the mount point's prefix */\n\tchar *prefix = mp->mount_prefix;\n\tchar *buf;\n\tssize_t len, rv;\n\n\t/* we want to make sure only absolute paths to cgroups are passed to us */\n\tif (path[0] != '/') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (prefix && !strcmp(prefix, \"/\"))\n\t\tprefix = NULL;\n\n\t/* prefix doesn't match */\n\tif (prefix && strncmp(prefix, path, strlen(prefix)) != 0) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\t/* if prefix is /foo and path is /foobar */\n\tif (prefix && path[strlen(prefix)] != '/' && path[strlen(prefix)] != '\\0') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\t/* remove prefix from path */\n\tpath += prefix ? strlen(prefix) : 0;\n\n\tlen = strlen(mp->mount_point) + strlen(path) + (suffix ? strlen(suffix) : 0);\n\tbuf = calloc(len + 1, 1);\n\tif (!buf)\n\t\treturn NULL;\n\trv = snprintf(buf, len + 1, \"%s%s%s\", mp->mount_point, path, suffix ? suffix : \"\");\n\tif (rv > len) {\n\t\tfree(buf);\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\treturn buf;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
            "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
            "static char *cgroup_to_absolute_path(struct cgroup_mount_point *mp, const char *path, const char *suffix);",
            "static int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);",
            "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic char *cgroup_to_absolute_path(struct cgroup_mount_point *mp, const char *path, const char *suffix);\nstatic int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\n\nstatic char *cgroup_to_absolute_path(struct cgroup_mount_point *mp,\n\t\t\t\t     const char *path, const char *suffix)\n{\n\t/* first we have to make sure we subtract the mount point's prefix */\n\tchar *prefix = mp->mount_prefix;\n\tchar *buf;\n\tssize_t len, rv;\n\n\t/* we want to make sure only absolute paths to cgroups are passed to us */\n\tif (path[0] != '/') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (prefix && !strcmp(prefix, \"/\"))\n\t\tprefix = NULL;\n\n\t/* prefix doesn't match */\n\tif (prefix && strncmp(prefix, path, strlen(prefix)) != 0) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\t/* if prefix is /foo and path is /foobar */\n\tif (prefix && path[strlen(prefix)] != '/' && path[strlen(prefix)] != '\\0') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\t/* remove prefix from path */\n\tpath += prefix ? strlen(prefix) : 0;\n\n\tlen = strlen(mp->mount_point) + strlen(path) + (suffix ? strlen(suffix) : 0);\n\tbuf = calloc(len + 1, 1);\n\tif (!buf)\n\t\treturn NULL;\n\trv = snprintf(buf, len + 1, \"%s%s%s\", mp->mount_point, path, suffix ? suffix : \"\");\n\tif (rv > len) {\n\t\tfree(buf);\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Could not chown cgroup %s: internal error (couldn't find any writable mountpoint to cgroup filesystem)\"",
            "info_ptr->cgroup_path"
          ],
          "line": 2666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_find_mount_point",
          "args": [
            "info_ptr->hierarchy",
            "info_ptr->cgroup_path",
            "true"
          ],
          "line": 2664
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_find_mount_point",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "670-711",
          "snippet": "static struct cgroup_mount_point *lxc_cgroup_find_mount_point(struct cgroup_hierarchy *hierarchy, const char *group, bool should_be_writable)\n{\n\tstruct cgroup_mount_point **mps;\n\tstruct cgroup_mount_point *current_result = NULL;\n\tssize_t quality = -1;\n\n\t/* trivial case */\n\tif (mountpoint_is_accessible(hierarchy->rw_absolute_mount_point))\n\t\treturn hierarchy->rw_absolute_mount_point;\n\tif (!should_be_writable && mountpoint_is_accessible(hierarchy->ro_absolute_mount_point))\n\t\treturn hierarchy->ro_absolute_mount_point;\n\n\tfor (mps = hierarchy->all_mount_points; mps && *mps; mps++) {\n\t\tstruct cgroup_mount_point *mp = *mps;\n\t\tsize_t prefix_len = mp->mount_prefix ? strlen(mp->mount_prefix) : 0;\n\n\t\tif (prefix_len == 1 && mp->mount_prefix[0] == '/')\n\t\t\tprefix_len = 0;\n\n\t\tif (!mountpoint_is_accessible(mp))\n\t\t\tcontinue;\n\n\t\tif (should_be_writable && mp->read_only)\n\t\t\tcontinue;\n\n\t\tif (!prefix_len ||\n\t\t    (strncmp(group, mp->mount_prefix, prefix_len) == 0 &&\n\t\t     (group[prefix_len] == '\\0' || group[prefix_len] == '/'))) {\n\t\t\t/* search for the best quality match, i.e. the match with the\n\t\t\t * shortest prefix where this group is still contained\n\t\t\t */\n\t\t\tif (quality == -1 || prefix_len < quality) {\n\t\t\t\tcurrent_result = mp;\n\t\t\t\tquality = prefix_len;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!current_result)\n\t\terrno = ENOENT;\n\treturn current_result;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\n\nstatic struct cgroup_mount_point *lxc_cgroup_find_mount_point(struct cgroup_hierarchy *hierarchy, const char *group, bool should_be_writable)\n{\n\tstruct cgroup_mount_point **mps;\n\tstruct cgroup_mount_point *current_result = NULL;\n\tssize_t quality = -1;\n\n\t/* trivial case */\n\tif (mountpoint_is_accessible(hierarchy->rw_absolute_mount_point))\n\t\treturn hierarchy->rw_absolute_mount_point;\n\tif (!should_be_writable && mountpoint_is_accessible(hierarchy->ro_absolute_mount_point))\n\t\treturn hierarchy->ro_absolute_mount_point;\n\n\tfor (mps = hierarchy->all_mount_points; mps && *mps; mps++) {\n\t\tstruct cgroup_mount_point *mp = *mps;\n\t\tsize_t prefix_len = mp->mount_prefix ? strlen(mp->mount_prefix) : 0;\n\n\t\tif (prefix_len == 1 && mp->mount_prefix[0] == '/')\n\t\t\tprefix_len = 0;\n\n\t\tif (!mountpoint_is_accessible(mp))\n\t\t\tcontinue;\n\n\t\tif (should_be_writable && mp->read_only)\n\t\t\tcontinue;\n\n\t\tif (!prefix_len ||\n\t\t    (strncmp(group, mp->mount_prefix, prefix_len) == 0 &&\n\t\t     (group[prefix_len] == '\\0' || group[prefix_len] == '/'))) {\n\t\t\t/* search for the best quality match, i.e. the match with the\n\t\t\t * shortest prefix where this group is still contained\n\t\t\t */\n\t\t\tif (quality == -1 || prefix_len < quality) {\n\t\t\t\tcurrent_result = mp;\n\t\t\t\tquality = prefix_len;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!current_result)\n\t\terrno = ENOENT;\n\treturn current_result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int remove_cgroup(struct cgroup_mount_point *mp, const char *path, bool recurse,\n\t\t\t\tstruct lxc_conf *conf);\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\nstatic void lxc_cgroup_process_info_free(struct cgroup_process_info *info);\nstatic void lxc_cgroup_process_info_free_and_remove(struct cgroup_process_info *info,\n\t\t\t\tstruct lxc_conf *conf);\n\nstatic bool cgfs_chown(void *hdata, struct lxc_conf *conf)\n{\n\tstruct cgfs_data *d = hdata;\n\tstruct cgroup_process_info *info_ptr;\n\tchar *cgpath;\n\tbool r = true;\n\n\tif (!d)\n\t\treturn false;\n\n\tfor (info_ptr = d->info; info_ptr; info_ptr = info_ptr->next) {\n\t\tif (!info_ptr->hierarchy)\n\t\t\tcontinue;\n\n\t\tif (!info_ptr->designated_mount_point) {\n\t\t\tinfo_ptr->designated_mount_point = lxc_cgroup_find_mount_point(info_ptr->hierarchy, info_ptr->cgroup_path, true);\n\t\t\tif (!info_ptr->designated_mount_point) {\n\t\t\t\tSYSERROR(\"Could not chown cgroup %s: internal error (couldn't find any writable mountpoint to cgroup filesystem)\", info_ptr->cgroup_path);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tcgpath = cgroup_to_absolute_path(info_ptr->designated_mount_point, info_ptr->cgroup_path, NULL);\n\t\tif (!cgpath) {\n\t\t\tSYSERROR(\"Could not chown cgroup %s: internal error\", info_ptr->cgroup_path);\n\t\t\tcontinue;\n\t\t}\n\t\tr = do_cgfs_chown(cgpath, conf);\n\t\tif (!r && is_crucial_hierarchy(info_ptr->hierarchy)) {\n\t\t\tERROR(\"Failed chowning %s\\n\", cgpath);\n\t\t\tfree(cgpath);\n\t\t\treturn false;\n\t\t}\n\t\tfree(cgpath);\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "do_cgfs_chown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "2601-2647",
    "snippet": "static bool do_cgfs_chown(char *cgroup_path, struct lxc_conf *conf)\n{\n\tstruct chown_data data;\n\tchar *fpath;\n\n\tif (!dir_exists(cgroup_path))\n\t\treturn true;\n\n\tif (lxc_list_empty(&conf->id_map))\n\t\t/* If there's no mapping then we don't need to chown */\n\t\treturn true;\n\n\tdata.cgroup_path = cgroup_path;\n\tdata.origuid = geteuid();\n\n\t/* Unpriv users can't chown it themselves, so chown from\n\t * a child namespace mapping both our own and the target uid\n\t */\n\tif (userns_exec_1(conf, chown_cgroup_wrapper, &data) < 0) {\n\t\tERROR(\"Error requesting cgroup chown in new namespace\");\n\t\treturn false;\n\t}\n\n\t/*\n\t * Now chmod 775 the directory else the container cannot create cgroups.\n\t * This can't be done in the child namespace because it only group-owns\n\t * the cgroup\n\t */\n\tif (chmod(cgroup_path, 0775) < 0) {\n\t\tSYSERROR(\"Error chmoding %s\\n\", cgroup_path);\n\t\treturn false;\n\t}\n\tfpath = lxc_append_paths(cgroup_path, \"tasks\");\n\tif (!fpath)\n\t\treturn false;\n\tif (chmod(fpath, 0664) < 0)\n\t\tSYSERROR(\"Error chmoding %s\\n\", fpath);\n\tfree(fpath);\n\tfpath = lxc_append_paths(cgroup_path, \"cgroup.procs\");\n\tif (!fpath)\n\t\treturn false;\n\tif (chmod(fpath, 0664) < 0)\n\t\tSYSERROR(\"Error chmoding %s\\n\", fpath);\n\tfree(fpath);\n\n\treturn true;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int remove_cgroup(struct cgroup_mount_point *mp, const char *path, bool recurse,\n\t\t\t\tstruct lxc_conf *conf);",
      "static int cgroup_recursive_task_count(const char *cgroup_path);",
      "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);",
      "static void lxc_cgroup_process_info_free_and_remove(struct cgroup_process_info *info,\n\t\t\t\tstruct lxc_conf *conf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fpath"
          ],
          "line": 2644
        },
        "resolved": true,
        "details": {
          "function_name": "cgfs_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2501-2518",
          "snippet": "static bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error chmoding %s\\n\"",
            "fpath"
          ],
          "line": 2643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "fpath",
            "0664"
          ],
          "line": 2642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_append_paths",
          "args": [
            "cgroup_path",
            "\"cgroup.procs\""
          ],
          "line": 2639
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_append_paths",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "768-785",
          "snippet": "char *lxc_append_paths(const char *first, const char *second)\n{\n\tsize_t len = strlen(first) + strlen(second) + 1;\n\tconst char *pattern = \"%s%s\";\n\tchar *result = NULL;\n\n\tif (second[0] != '/') {\n\t\tlen += 1;\n\t\tpattern = \"%s/%s\";\n\t}\n\n\tresult = calloc(1, len);\n\tif (!result)\n\t\treturn NULL;\n\n\tsnprintf(result, len, pattern, first, second);\n\treturn result;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *lxc_append_paths(const char *first, const char *second)\n{\n\tsize_t len = strlen(first) + strlen(second) + 1;\n\tconst char *pattern = \"%s%s\";\n\tchar *result = NULL;\n\n\tif (second[0] != '/') {\n\t\tlen += 1;\n\t\tpattern = \"%s/%s\";\n\t}\n\n\tresult = calloc(1, len);\n\tif (!result)\n\t\treturn NULL;\n\n\tsnprintf(result, len, pattern, first, second);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error chmoding %s\\n\"",
            "fpath"
          ],
          "line": 2637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "fpath",
            "0664"
          ],
          "line": 2636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error chmoding %s\\n\"",
            "cgroup_path"
          ],
          "line": 2630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "cgroup_path",
            "0775"
          ],
          "line": 2629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error requesting cgroup chown in new namespace\""
          ],
          "line": 2620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userns_exec_1",
          "args": [
            "conf",
            "chown_cgroup_wrapper",
            "&data"
          ],
          "line": 2619
        },
        "resolved": true,
        "details": {
          "function_name": "userns_exec_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4435-4487",
          "snippet": "int userns_exec_1(struct lxc_conf *conf, int (*fn)(void *), void *data)\n{\n\tint ret, pid;\n\tstruct userns_fn_data d;\n\tchar c = '1';\n\tint p[2];\n\tstruct lxc_list *idmap;\n\n\tret = pipe(p);\n\tif (ret < 0) {\n\t\tSYSERROR(\"opening pipe\");\n\t\treturn -1;\n\t}\n\td.fn = fn;\n\td.arg = data;\n\td.p[0] = p[0];\n\td.p[1] = p[1];\n\tpid = lxc_clone(run_userns_fn, &d, CLONE_NEWUSER);\n\tif (pid < 0)\n\t\tgoto err;\n\tclose(p[0]);\n\tp[0] = -1;\n\n\tif ((idmap = idmap_add_id(conf, geteuid(), getegid())) == NULL) {\n\t\tERROR(\"Error adding self to container uid/gid map\");\n\t\tgoto err;\n\t}\n\n\tret = lxc_map_ids(idmap, pid);\n\tlxc_free_idmap(idmap);\n\tfree(idmap);\n\tif (ret) {\n\t\tERROR(\"Error setting up child mappings\");\n\t\tgoto err;\n\t}\n\n\t// kick the child\n\tif (write(p[1], &c, 1) != 1) {\n\t\tSYSERROR(\"writing to pipe to child\");\n\t\tgoto err;\n\t}\n\n\tret = wait_for_pid(pid);\n\n\tclose(p[1]);\n\treturn ret;\n\nerr:\n\tif (p[0] != -1)\n\t\tclose(p[0]);\n\tclose(p[1]);\n\treturn -1;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint userns_exec_1(struct lxc_conf *conf, int (*fn)(void *), void *data)\n{\n\tint ret, pid;\n\tstruct userns_fn_data d;\n\tchar c = '1';\n\tint p[2];\n\tstruct lxc_list *idmap;\n\n\tret = pipe(p);\n\tif (ret < 0) {\n\t\tSYSERROR(\"opening pipe\");\n\t\treturn -1;\n\t}\n\td.fn = fn;\n\td.arg = data;\n\td.p[0] = p[0];\n\td.p[1] = p[1];\n\tpid = lxc_clone(run_userns_fn, &d, CLONE_NEWUSER);\n\tif (pid < 0)\n\t\tgoto err;\n\tclose(p[0]);\n\tp[0] = -1;\n\n\tif ((idmap = idmap_add_id(conf, geteuid(), getegid())) == NULL) {\n\t\tERROR(\"Error adding self to container uid/gid map\");\n\t\tgoto err;\n\t}\n\n\tret = lxc_map_ids(idmap, pid);\n\tlxc_free_idmap(idmap);\n\tfree(idmap);\n\tif (ret) {\n\t\tERROR(\"Error setting up child mappings\");\n\t\tgoto err;\n\t}\n\n\t// kick the child\n\tif (write(p[1], &c, 1) != 1) {\n\t\tSYSERROR(\"writing to pipe to child\");\n\t\tgoto err;\n\t}\n\n\tret = wait_for_pid(pid);\n\n\tclose(p[1]);\n\treturn ret;\n\nerr:\n\tif (p[0] != -1)\n\t\tclose(p[0]);\n\tclose(p[1]);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 2614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_empty",
          "args": [
            "&conf->id_map"
          ],
          "line": 2609
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "94-97",
          "snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_exists",
          "args": [
            "cgroup_path"
          ],
          "line": 2606
        },
        "resolved": true,
        "details": {
          "function_name": "dir_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1059-1069",
          "snippet": "bool dir_exists(const char *path)\n{\n\tstruct stat sb;\n\tint ret;\n\n\tret = stat(path, &sb);\n\tif (ret < 0)\n\t\t// could be something other than eexist, just say no\n\t\treturn false;\n\treturn S_ISDIR(sb.st_mode);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool btrfs_try_remove_subvol(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nbool dir_exists(const char *path)\n{\n\tstruct stat sb;\n\tint ret;\n\n\tret = stat(path, &sb);\n\tif (ret < 0)\n\t\t// could be something other than eexist, just say no\n\t\treturn false;\n\treturn S_ISDIR(sb.st_mode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int remove_cgroup(struct cgroup_mount_point *mp, const char *path, bool recurse,\n\t\t\t\tstruct lxc_conf *conf);\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\nstatic void lxc_cgroup_process_info_free_and_remove(struct cgroup_process_info *info,\n\t\t\t\tstruct lxc_conf *conf);\n\nstatic bool do_cgfs_chown(char *cgroup_path, struct lxc_conf *conf)\n{\n\tstruct chown_data data;\n\tchar *fpath;\n\n\tif (!dir_exists(cgroup_path))\n\t\treturn true;\n\n\tif (lxc_list_empty(&conf->id_map))\n\t\t/* If there's no mapping then we don't need to chown */\n\t\treturn true;\n\n\tdata.cgroup_path = cgroup_path;\n\tdata.origuid = geteuid();\n\n\t/* Unpriv users can't chown it themselves, so chown from\n\t * a child namespace mapping both our own and the target uid\n\t */\n\tif (userns_exec_1(conf, chown_cgroup_wrapper, &data) < 0) {\n\t\tERROR(\"Error requesting cgroup chown in new namespace\");\n\t\treturn false;\n\t}\n\n\t/*\n\t * Now chmod 775 the directory else the container cannot create cgroups.\n\t * This can't be done in the child namespace because it only group-owns\n\t * the cgroup\n\t */\n\tif (chmod(cgroup_path, 0775) < 0) {\n\t\tSYSERROR(\"Error chmoding %s\\n\", cgroup_path);\n\t\treturn false;\n\t}\n\tfpath = lxc_append_paths(cgroup_path, \"tasks\");\n\tif (!fpath)\n\t\treturn false;\n\tif (chmod(fpath, 0664) < 0)\n\t\tSYSERROR(\"Error chmoding %s\\n\", fpath);\n\tfree(fpath);\n\tfpath = lxc_append_paths(cgroup_path, \"cgroup.procs\");\n\tif (!fpath)\n\t\treturn false;\n\tif (chmod(fpath, 0664) < 0)\n\t\tSYSERROR(\"Error chmoding %s\\n\", fpath);\n\tfree(fpath);\n\n\treturn true;\n}"
  },
  {
    "function_name": "chown_cgroup_wrapper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "2567-2599",
    "snippet": "static int chown_cgroup_wrapper(void *data)\n{\n\tstruct chown_data *arg = data;\n\tuid_t destuid;\n\tchar *fpath;\n\n\tif (setresgid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setgid to 0\");\n\tif (setresuid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setuid to 0\");\n\tif (setgroups(0, NULL) < 0)\n\t\tSYSERROR(\"Failed to clear groups\");\n\tdestuid = get_ns_uid(arg->origuid);\n\n\tif (chown(arg->cgroup_path, destuid, 0) < 0)\n\t\tSYSERROR(\"Failed chowning %s to %d\", arg->cgroup_path, (int)destuid);\n\n\tfpath = lxc_append_paths(arg->cgroup_path, \"tasks\");\n\tif (!fpath)\n\t\treturn -1;\n\tif (chown(fpath, destuid, 0) < 0)\n\t\tSYSERROR(\"Error chowning %s\\n\", fpath);\n\tfree(fpath);\n\n\tfpath = lxc_append_paths(arg->cgroup_path, \"cgroup.procs\");\n\tif (!fpath)\n\t\treturn -1;\n\tif (chown(fpath, destuid, 0) < 0)\n\t\tSYSERROR(\"Error chowning %s\", fpath);\n\tfree(fpath);\n\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_recursive_task_count(const char *cgroup_path);",
      "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fpath"
          ],
          "line": 2596
        },
        "resolved": true,
        "details": {
          "function_name": "cgfs_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2501-2518",
          "snippet": "static bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error chowning %s\"",
            "fpath"
          ],
          "line": 2595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chown",
          "args": [
            "fpath",
            "destuid",
            "0"
          ],
          "line": 2594
        },
        "resolved": true,
        "details": {
          "function_name": "do_chown_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "357-430",
          "snippet": "static int do_chown_cgroup(const char *controller, const char *cgroup_path,\n\t\tuid_t newuid)\n{\n\tint sv[2] = {-1, -1}, optval = 1, ret = -1;\n\tchar buf[1];\n\tstruct pollfd fds;\n\n\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, sv) < 0) {\n\t\tSYSERROR(\"Error creating socketpair\");\n\t\tgoto out;\n\t}\n\tif (setsockopt(sv[1], SOL_SOCKET, SO_PASSCRED, &optval, sizeof(optval)) == -1) {\n\t\tSYSERROR(\"setsockopt failed\");\n\t\tgoto out;\n\t}\n\tif (setsockopt(sv[0], SOL_SOCKET, SO_PASSCRED, &optval, sizeof(optval)) == -1) {\n\t\tSYSERROR(\"setsockopt failed\");\n\t\tgoto out;\n\t}\n\tif ( cgmanager_chown_scm_sync(NULL, cgroup_manager, controller,\n\t\t\t\t       cgroup_path, sv[1]) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_chown_scm_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tgoto out;\n\t}\n\t/* now send credentials */\n\n\tfds.fd = sv[0];\n\tfds.events = POLLIN;\n\tfds.revents = 0;\n\tif (poll(&fds, 1, -1) <= 0) {\n\t\tERROR(\"Error getting go-ahead from server: %s\", strerror(errno));\n\t\tgoto out;\n\t}\n\tif (read(sv[0], &buf, 1) != 1) {\n\t\tERROR(\"Error getting reply from server over socketpair\");\n\t\tgoto out;\n\t}\n\tif (send_creds(sv[0], getpid(), getuid(), getgid())) {\n\t\tSYSERROR(\"%s: Error sending pid over SCM_CREDENTIAL\", __func__);\n\t\tgoto out;\n\t}\n\tfds.fd = sv[0];\n\tfds.events = POLLIN;\n\tfds.revents = 0;\n\tif (poll(&fds, 1, -1) <= 0) {\n\t\tERROR(\"Error getting go-ahead from server: %s\", strerror(errno));\n\t\tgoto out;\n\t}\n\tif (read(sv[0], &buf, 1) != 1) {\n\t\tERROR(\"Error getting reply from server over socketpair\");\n\t\tgoto out;\n\t}\n\tif (send_creds(sv[0], getpid(), newuid, 0)) {\n\t\tSYSERROR(\"%s: Error sending pid over SCM_CREDENTIAL\", __func__);\n\t\tgoto out;\n\t}\n\tfds.fd = sv[0];\n\tfds.events = POLLIN;\n\tfds.revents = 0;\n\tif (poll(&fds, 1, -1) <= 0) {\n\t\tERROR(\"Error getting go-ahead from server: %s\", strerror(errno));\n\t\tgoto out;\n\t}\n\tret = read(sv[0], buf, 1);\nout:\n\tclose(sv[0]);\n\tclose(sv[1]);\n\tif (ret == 1 && *buf == '1')\n\t\treturn 0;\n\treturn -1;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int do_chown_cgroup(const char *controller, const char *cgroup_path,\n\t\tuid_t newuid)\n{\n\tint sv[2] = {-1, -1}, optval = 1, ret = -1;\n\tchar buf[1];\n\tstruct pollfd fds;\n\n\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, sv) < 0) {\n\t\tSYSERROR(\"Error creating socketpair\");\n\t\tgoto out;\n\t}\n\tif (setsockopt(sv[1], SOL_SOCKET, SO_PASSCRED, &optval, sizeof(optval)) == -1) {\n\t\tSYSERROR(\"setsockopt failed\");\n\t\tgoto out;\n\t}\n\tif (setsockopt(sv[0], SOL_SOCKET, SO_PASSCRED, &optval, sizeof(optval)) == -1) {\n\t\tSYSERROR(\"setsockopt failed\");\n\t\tgoto out;\n\t}\n\tif ( cgmanager_chown_scm_sync(NULL, cgroup_manager, controller,\n\t\t\t\t       cgroup_path, sv[1]) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_chown_scm_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tgoto out;\n\t}\n\t/* now send credentials */\n\n\tfds.fd = sv[0];\n\tfds.events = POLLIN;\n\tfds.revents = 0;\n\tif (poll(&fds, 1, -1) <= 0) {\n\t\tERROR(\"Error getting go-ahead from server: %s\", strerror(errno));\n\t\tgoto out;\n\t}\n\tif (read(sv[0], &buf, 1) != 1) {\n\t\tERROR(\"Error getting reply from server over socketpair\");\n\t\tgoto out;\n\t}\n\tif (send_creds(sv[0], getpid(), getuid(), getgid())) {\n\t\tSYSERROR(\"%s: Error sending pid over SCM_CREDENTIAL\", __func__);\n\t\tgoto out;\n\t}\n\tfds.fd = sv[0];\n\tfds.events = POLLIN;\n\tfds.revents = 0;\n\tif (poll(&fds, 1, -1) <= 0) {\n\t\tERROR(\"Error getting go-ahead from server: %s\", strerror(errno));\n\t\tgoto out;\n\t}\n\tif (read(sv[0], &buf, 1) != 1) {\n\t\tERROR(\"Error getting reply from server over socketpair\");\n\t\tgoto out;\n\t}\n\tif (send_creds(sv[0], getpid(), newuid, 0)) {\n\t\tSYSERROR(\"%s: Error sending pid over SCM_CREDENTIAL\", __func__);\n\t\tgoto out;\n\t}\n\tfds.fd = sv[0];\n\tfds.events = POLLIN;\n\tfds.revents = 0;\n\tif (poll(&fds, 1, -1) <= 0) {\n\t\tERROR(\"Error getting go-ahead from server: %s\", strerror(errno));\n\t\tgoto out;\n\t}\n\tret = read(sv[0], buf, 1);\nout:\n\tclose(sv[0]);\n\tclose(sv[1]);\n\tif (ret == 1 && *buf == '1')\n\t\treturn 0;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_append_paths",
          "args": [
            "arg->cgroup_path",
            "\"cgroup.procs\""
          ],
          "line": 2591
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_append_paths",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "768-785",
          "snippet": "char *lxc_append_paths(const char *first, const char *second)\n{\n\tsize_t len = strlen(first) + strlen(second) + 1;\n\tconst char *pattern = \"%s%s\";\n\tchar *result = NULL;\n\n\tif (second[0] != '/') {\n\t\tlen += 1;\n\t\tpattern = \"%s/%s\";\n\t}\n\n\tresult = calloc(1, len);\n\tif (!result)\n\t\treturn NULL;\n\n\tsnprintf(result, len, pattern, first, second);\n\treturn result;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *lxc_append_paths(const char *first, const char *second)\n{\n\tsize_t len = strlen(first) + strlen(second) + 1;\n\tconst char *pattern = \"%s%s\";\n\tchar *result = NULL;\n\n\tif (second[0] != '/') {\n\t\tlen += 1;\n\t\tpattern = \"%s/%s\";\n\t}\n\n\tresult = calloc(1, len);\n\tif (!result)\n\t\treturn NULL;\n\n\tsnprintf(result, len, pattern, first, second);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error chowning %s\\n\"",
            "fpath"
          ],
          "line": 2588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed chowning %s to %d\"",
            "arg->cgroup_path",
            "(int)destuid"
          ],
          "line": 2582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ns_uid",
          "args": [
            "arg->origuid"
          ],
          "line": 2579
        },
        "resolved": true,
        "details": {
          "function_name": "get_ns_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1034-1057",
          "snippet": "uid_t get_ns_uid(uid_t orig)\n{\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tuid_t nsid, hostid, range;\n\tFILE *f = fopen(\"/proc/self/uid_map\", \"r\");\n\tif (!f)\n\t\treturn 0;\n\n\twhile (getline(&line, &sz, f) != -1) {\n\t\tif (sscanf(line, \"%u %u %u\", &nsid, &hostid, &range) != 3)\n\t\t\tcontinue;\n\t\tif (hostid <= orig && hostid + range > orig) {\n\t\t\tnsid += orig - hostid;\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\tnsid = 0;\nfound:\n\tfclose(f);\n\tfree(line);\n\treturn nsid;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nuid_t get_ns_uid(uid_t orig)\n{\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tuid_t nsid, hostid, range;\n\tFILE *f = fopen(\"/proc/self/uid_map\", \"r\");\n\tif (!f)\n\t\treturn 0;\n\n\twhile (getline(&line, &sz, f) != -1) {\n\t\tif (sscanf(line, \"%u %u %u\", &nsid, &hostid, &range) != 3)\n\t\t\tcontinue;\n\t\tif (hostid <= orig && hostid + range > orig) {\n\t\t\tnsid += orig - hostid;\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\tnsid = 0;\nfound:\n\tfclose(f);\n\tfree(line);\n\treturn nsid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to clear groups\""
          ],
          "line": 2578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setgroups",
          "args": [
            "0",
            "NULL"
          ],
          "line": 2577
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_setgroups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "2063-2072",
          "snippet": "int lxc_setgroups(int size, gid_t list[])\n{\n\tif (setgroups(size, list) < 0) {\n\t\tSYSERROR(\"Failed to setgroups().\");\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Dropped additional groups.\");\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_setgroups(int size, gid_t list[])\n{\n\tif (setgroups(size, list) < 0) {\n\t\tSYSERROR(\"Failed to setgroups().\");\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Dropped additional groups.\");\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to setuid to 0\""
          ],
          "line": 2576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setresuid",
          "args": [
            "0",
            "0",
            "0"
          ],
          "line": 2575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to setgid to 0\""
          ],
          "line": 2574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setresgid",
          "args": [
            "0",
            "0",
            "0"
          ],
          "line": 2573
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\n\nstatic int chown_cgroup_wrapper(void *data)\n{\n\tstruct chown_data *arg = data;\n\tuid_t destuid;\n\tchar *fpath;\n\n\tif (setresgid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setgid to 0\");\n\tif (setresuid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setuid to 0\");\n\tif (setgroups(0, NULL) < 0)\n\t\tSYSERROR(\"Failed to clear groups\");\n\tdestuid = get_ns_uid(arg->origuid);\n\n\tif (chown(arg->cgroup_path, destuid, 0) < 0)\n\t\tSYSERROR(\"Failed chowning %s to %d\", arg->cgroup_path, (int)destuid);\n\n\tfpath = lxc_append_paths(arg->cgroup_path, \"tasks\");\n\tif (!fpath)\n\t\treturn -1;\n\tif (chown(fpath, destuid, 0) < 0)\n\t\tSYSERROR(\"Error chowning %s\\n\", fpath);\n\tfree(fpath);\n\n\tfpath = lxc_append_paths(arg->cgroup_path, \"cgroup.procs\");\n\tif (!fpath)\n\t\treturn -1;\n\tif (chown(fpath, destuid, 0) < 0)\n\t\tSYSERROR(\"Error chowning %s\", fpath);\n\tfree(fpath);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_cgroupfs_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "2530-2556",
    "snippet": "static bool lxc_cgroupfs_attach(const char *name, const char *lxcpath, pid_t pid)\n{\n\tstruct cgroup_meta_data *meta_data;\n\tstruct cgroup_process_info *container_info;\n\tint ret;\n\n\tmeta_data = lxc_cgroup_load_meta();\n\tif (!meta_data) {\n\t\tERROR(\"could not move attached process %d to cgroup of container\", pid);\n\t\treturn false;\n\t}\n\n\tcontainer_info = lxc_cgroup_get_container_info(name, lxcpath, meta_data);\n\tlxc_cgroup_put_meta(meta_data);\n\tif (!container_info) {\n\t\tERROR(\"could not move attached process %d to cgroup of container\", pid);\n\t\treturn false;\n\t}\n\n\tret = lxc_cgroupfs_enter(container_info, pid, false);\n\tlxc_cgroup_process_info_free(container_info);\n\tif (ret < 0) {\n\t\tERROR(\"could not move attached process %d to cgroup of container\", pid);\n\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_valid_cgroup(const char *name);",
      "static struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);",
      "static struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"could not move attached process %d to cgroup of container\"",
            "pid"
          ],
          "line": 2552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_process_info_free",
          "args": [
            "container_info"
          ],
          "line": 2550
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_process_info_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1248-1260",
          "snippet": "void lxc_cgroup_process_info_free(struct cgroup_process_info *info)\n{\n\tstruct cgroup_process_info *next;\n\tif (!info)\n\t\treturn;\n\tnext = info->next;\n\tlxc_cgroup_put_meta(info->meta_ref);\n\tfree(info->cgroup_path);\n\tfree(info->cgroup_path_sub);\n\tlxc_free_array((void **)info->created_paths, free);\n\tfree(info);\n\tlxc_cgroup_process_info_free(next);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_recursive_task_count(const char *cgroup_path);",
            "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);",
            "static void lxc_cgroup_process_info_free(struct cgroup_process_info *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\nstatic void lxc_cgroup_process_info_free(struct cgroup_process_info *info);\n\nvoid lxc_cgroup_process_info_free(struct cgroup_process_info *info)\n{\n\tstruct cgroup_process_info *next;\n\tif (!info)\n\t\treturn;\n\tnext = info->next;\n\tlxc_cgroup_put_meta(info->meta_ref);\n\tfree(info->cgroup_path);\n\tfree(info->cgroup_path_sub);\n\tlxc_free_array((void **)info->created_paths, free);\n\tfree(info);\n\tlxc_cgroup_process_info_free(next);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cgroupfs_enter",
          "args": [
            "container_info",
            "pid",
            "false"
          ],
          "line": 2549
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroupfs_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1206-1245",
          "snippet": "static int lxc_cgroupfs_enter(struct cgroup_process_info *info, pid_t pid, bool enter_sub)\n{\n\tchar pid_buf[32];\n\tchar *cgroup_tasks_fn;\n\tint r;\n\tstruct cgroup_process_info *info_ptr;\n\n\tsnprintf(pid_buf, 32, \"%lu\", (unsigned long)pid);\n\tfor (info_ptr = info; info_ptr; info_ptr = info_ptr->next) {\n\t\tif (!info_ptr->hierarchy)\n\t\t\tcontinue;\n\n\t\tchar *cgroup_path = (enter_sub && info_ptr->cgroup_path_sub) ?\n\t\t\tinfo_ptr->cgroup_path_sub :\n\t\t\tinfo_ptr->cgroup_path;\n\n\t\tif (!info_ptr->designated_mount_point) {\n\t\t\tinfo_ptr->designated_mount_point = lxc_cgroup_find_mount_point(info_ptr->hierarchy, cgroup_path, true);\n\t\t\tif (!info_ptr->designated_mount_point) {\n\t\t\t\tSYSERROR(\"Could not add pid %lu to cgroup %s: internal error (couldn't find any writable mountpoint to cgroup filesystem)\", (unsigned long)pid, cgroup_path);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tcgroup_tasks_fn = cgroup_to_absolute_path(info_ptr->designated_mount_point, cgroup_path, \"/tasks\");\n\t\tif (!cgroup_tasks_fn) {\n\t\t\tSYSERROR(\"Could not add pid %lu to cgroup %s: internal error\", (unsigned long)pid, cgroup_path);\n\t\t\treturn -1;\n\t\t}\n\n\t\tr = lxc_write_to_file(cgroup_tasks_fn, pid_buf, strlen(pid_buf), false);\n\t\tfree(cgroup_tasks_fn);\n\t\tif (r < 0 && is_crucial_hierarchy(info_ptr->hierarchy)) {\n\t\t\tSYSERROR(\"Could not add pid %lu to cgroup %s: internal error\", (unsigned long)pid, cgroup_path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_recursive_task_count(const char *cgroup_path);",
            "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);",
            "static void lxc_cgroup_process_info_free(struct cgroup_process_info *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\nstatic void lxc_cgroup_process_info_free(struct cgroup_process_info *info);\n\nstatic int lxc_cgroupfs_enter(struct cgroup_process_info *info, pid_t pid, bool enter_sub)\n{\n\tchar pid_buf[32];\n\tchar *cgroup_tasks_fn;\n\tint r;\n\tstruct cgroup_process_info *info_ptr;\n\n\tsnprintf(pid_buf, 32, \"%lu\", (unsigned long)pid);\n\tfor (info_ptr = info; info_ptr; info_ptr = info_ptr->next) {\n\t\tif (!info_ptr->hierarchy)\n\t\t\tcontinue;\n\n\t\tchar *cgroup_path = (enter_sub && info_ptr->cgroup_path_sub) ?\n\t\t\tinfo_ptr->cgroup_path_sub :\n\t\t\tinfo_ptr->cgroup_path;\n\n\t\tif (!info_ptr->designated_mount_point) {\n\t\t\tinfo_ptr->designated_mount_point = lxc_cgroup_find_mount_point(info_ptr->hierarchy, cgroup_path, true);\n\t\t\tif (!info_ptr->designated_mount_point) {\n\t\t\t\tSYSERROR(\"Could not add pid %lu to cgroup %s: internal error (couldn't find any writable mountpoint to cgroup filesystem)\", (unsigned long)pid, cgroup_path);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tcgroup_tasks_fn = cgroup_to_absolute_path(info_ptr->designated_mount_point, cgroup_path, \"/tasks\");\n\t\tif (!cgroup_tasks_fn) {\n\t\t\tSYSERROR(\"Could not add pid %lu to cgroup %s: internal error\", (unsigned long)pid, cgroup_path);\n\t\t\treturn -1;\n\t\t}\n\n\t\tr = lxc_write_to_file(cgroup_tasks_fn, pid_buf, strlen(pid_buf), false);\n\t\tfree(cgroup_tasks_fn);\n\t\tif (r < 0 && is_crucial_hierarchy(info_ptr->hierarchy)) {\n\t\t\tSYSERROR(\"Could not add pid %lu to cgroup %s: internal error\", (unsigned long)pid, cgroup_path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"could not move attached process %d to cgroup of container\"",
            "pid"
          ],
          "line": 2545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_put_meta",
          "args": [
            "meta_data"
          ],
          "line": 2543
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_put_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "635-650",
          "snippet": "static struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data)\n{\n\tsize_t i;\n\tif (!meta_data)\n\t\treturn NULL;\n\tif (--meta_data->ref > 0)\n\t\treturn meta_data;\n\tlxc_free_array((void **)meta_data->mount_points, (lxc_free_fn)lxc_cgroup_mount_point_free);\n\tif (meta_data->hierarchies)\n\t\tfor (i = 0; i <= meta_data->maximum_hierarchy; i++)\n\t\t\tif (meta_data->hierarchies[i])\n\t\t\t\tlxc_cgroup_hierarchy_free(meta_data->hierarchies[i]);\n\tfree(meta_data->hierarchies);\n\tfree(meta_data);\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);",
            "static struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);\nstatic struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);\n\nstatic struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data)\n{\n\tsize_t i;\n\tif (!meta_data)\n\t\treturn NULL;\n\tif (--meta_data->ref > 0)\n\t\treturn meta_data;\n\tlxc_free_array((void **)meta_data->mount_points, (lxc_free_fn)lxc_cgroup_mount_point_free);\n\tif (meta_data->hierarchies)\n\t\tfor (i = 0; i <= meta_data->maximum_hierarchy; i++)\n\t\t\tif (meta_data->hierarchies[i])\n\t\t\t\tlxc_cgroup_hierarchy_free(meta_data->hierarchies[i]);\n\tfree(meta_data->hierarchies);\n\tfree(meta_data);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_get_container_info",
          "args": [
            "name",
            "lxcpath",
            "meta_data"
          ],
          "line": 2542
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_get_container_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1156-1203",
          "snippet": "static struct cgroup_process_info *lxc_cgroup_get_container_info(const char *name, const char *lxcpath, struct cgroup_meta_data *meta_data)\n{\n\tstruct cgroup_process_info *result = NULL;\n\tint saved_errno = 0;\n\tsize_t i;\n\tstruct cgroup_process_info **cptr = &result;\n\tstruct cgroup_process_info *entry = NULL;\n\tchar *path = NULL;\n\n\tfor (i = 0; i <= meta_data->maximum_hierarchy; i++) {\n\t\tstruct cgroup_hierarchy *h = meta_data->hierarchies[i];\n\t\tif (!h || !h->used)\n\t\t\tcontinue;\n\n\t\t/* use the command interface to look for the cgroup */\n\t\tpath = lxc_cmd_get_cgroup_path(name, lxcpath, h->subsystems[0]);\n\t\tif (!path) {\n\t\t\th->used = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tentry = calloc(1, sizeof(struct cgroup_process_info));\n\t\tif (!entry)\n\t\t\tgoto out_error;\n\t\tentry->meta_ref = lxc_cgroup_get_meta(meta_data);\n\t\tentry->hierarchy = h;\n\t\tentry->cgroup_path = path;\n\t\tpath = NULL;\n\n\t\t/* it is not an error if we don't find anything here,\n\t\t * it is up to the caller to decide what to do in that\n\t\t * case */\n\t\tentry->designated_mount_point = lxc_cgroup_find_mount_point(h, entry->cgroup_path, true);\n\n\t\t*cptr = entry;\n\t\tcptr = &entry->next;\n\t\tentry = NULL;\n\t}\n\n\treturn result;\nout_error:\n\tsaved_errno = errno;\n\tfree(path);\n\tlxc_cgroup_process_info_free(result);\n\tlxc_cgroup_process_info_free(entry);\n\terrno = saved_errno;\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);",
            "static bool is_valid_cgroup(const char *name);",
            "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
            "static int cgroup_recursive_task_count(const char *cgroup_path);",
            "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);",
            "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);",
            "static struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);",
            "static struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);\nstatic bool is_valid_cgroup(const char *name);\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\nstatic struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);\nstatic struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);\n\nstatic struct cgroup_process_info *lxc_cgroup_get_container_info(const char *name, const char *lxcpath, struct cgroup_meta_data *meta_data)\n{\n\tstruct cgroup_process_info *result = NULL;\n\tint saved_errno = 0;\n\tsize_t i;\n\tstruct cgroup_process_info **cptr = &result;\n\tstruct cgroup_process_info *entry = NULL;\n\tchar *path = NULL;\n\n\tfor (i = 0; i <= meta_data->maximum_hierarchy; i++) {\n\t\tstruct cgroup_hierarchy *h = meta_data->hierarchies[i];\n\t\tif (!h || !h->used)\n\t\t\tcontinue;\n\n\t\t/* use the command interface to look for the cgroup */\n\t\tpath = lxc_cmd_get_cgroup_path(name, lxcpath, h->subsystems[0]);\n\t\tif (!path) {\n\t\t\th->used = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tentry = calloc(1, sizeof(struct cgroup_process_info));\n\t\tif (!entry)\n\t\t\tgoto out_error;\n\t\tentry->meta_ref = lxc_cgroup_get_meta(meta_data);\n\t\tentry->hierarchy = h;\n\t\tentry->cgroup_path = path;\n\t\tpath = NULL;\n\n\t\t/* it is not an error if we don't find anything here,\n\t\t * it is up to the caller to decide what to do in that\n\t\t * case */\n\t\tentry->designated_mount_point = lxc_cgroup_find_mount_point(h, entry->cgroup_path, true);\n\n\t\t*cptr = entry;\n\t\tcptr = &entry->next;\n\t\tentry = NULL;\n\t}\n\n\treturn result;\nout_error:\n\tsaved_errno = errno;\n\tfree(path);\n\tlxc_cgroup_process_info_free(result);\n\tlxc_cgroup_process_info_free(entry);\n\terrno = saved_errno;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"could not move attached process %d to cgroup of container\"",
            "pid"
          ],
          "line": 2538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_load_meta",
          "args": [],
          "line": 2536
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_load_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "241-263",
          "snippet": "static struct cgroup_meta_data *lxc_cgroup_load_meta()\n{\n\tconst char *cgroup_use = NULL;\n\tchar **cgroup_use_list = NULL;\n\tstruct cgroup_meta_data *md = NULL;\n\tint saved_errno;\n\n\terrno = 0;\n\tcgroup_use = lxc_global_config_value(\"lxc.cgroup.use\");\n\tif (!cgroup_use && errno != 0)\n\t\treturn NULL;\n\tif (cgroup_use) {\n\t\tcgroup_use_list = lxc_string_split_and_trim(cgroup_use, ',');\n\t\tif (!cgroup_use_list)\n\t\t\treturn NULL;\n\t}\n\n\tmd = lxc_cgroup_load_meta2((const char **)cgroup_use_list);\n\tsaved_errno = errno;\n\tlxc_free_array((void **)cgroup_use_list, free);\n\terrno = saved_errno;\n\treturn md;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_meta_data *lxc_cgroup_load_meta()\n{\n\tconst char *cgroup_use = NULL;\n\tchar **cgroup_use_list = NULL;\n\tstruct cgroup_meta_data *md = NULL;\n\tint saved_errno;\n\n\terrno = 0;\n\tcgroup_use = lxc_global_config_value(\"lxc.cgroup.use\");\n\tif (!cgroup_use && errno != 0)\n\t\treturn NULL;\n\tif (cgroup_use) {\n\t\tcgroup_use_list = lxc_string_split_and_trim(cgroup_use, ',');\n\t\tif (!cgroup_use_list)\n\t\t\treturn NULL;\n\t}\n\n\tmd = lxc_cgroup_load_meta2((const char **)cgroup_use_list);\n\tsaved_errno = errno;\n\tlxc_free_array((void **)cgroup_use_list, free);\n\terrno = saved_errno;\n\treturn md;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool is_valid_cgroup(const char *name);\nstatic struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);\nstatic struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);\n\nstatic bool lxc_cgroupfs_attach(const char *name, const char *lxcpath, pid_t pid)\n{\n\tstruct cgroup_meta_data *meta_data;\n\tstruct cgroup_process_info *container_info;\n\tint ret;\n\n\tmeta_data = lxc_cgroup_load_meta();\n\tif (!meta_data) {\n\t\tERROR(\"could not move attached process %d to cgroup of container\", pid);\n\t\treturn false;\n\t}\n\n\tcontainer_info = lxc_cgroup_get_container_info(name, lxcpath, meta_data);\n\tlxc_cgroup_put_meta(meta_data);\n\tif (!container_info) {\n\t\tERROR(\"could not move attached process %d to cgroup of container\", pid);\n\t\treturn false;\n\t}\n\n\tret = lxc_cgroupfs_enter(container_info, pid, false);\n\tlxc_cgroup_process_info_free(container_info);\n\tif (ret < 0) {\n\t\tERROR(\"could not move attached process %d to cgroup of container\", pid);\n\t\treturn false;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "cgroupfs_setup_limits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "2520-2528",
    "snippet": "static bool cgroupfs_setup_limits(void *hdata, struct lxc_list *cgroup_conf,\n\t\t\t\t  bool with_devices)\n{\n\tstruct cgfs_data *d = hdata;\n\n\tif (!d)\n\t\treturn false;\n\treturn do_setup_cgroup_limits(d, cgroup_conf, with_devices) == 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_setup_cgroup_limits",
          "args": [
            "d",
            "cgroup_conf",
            "with_devices"
          ],
          "line": 2527
        },
        "resolved": true,
        "details": {
          "function_name": "do_setup_cgroup_limits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2005-2054",
          "snippet": "static int do_setup_cgroup_limits(struct cgfs_data *d,\n\t\t\t   struct lxc_list *cgroup_settings, bool do_devices)\n{\n\tstruct lxc_list *iterator, *sorted_cgroup_settings, *next;\n\tstruct lxc_cgroup *cg;\n\tint ret = -1;\n\n\tif (lxc_list_empty(cgroup_settings))\n\t\treturn 0;\n\n\tsorted_cgroup_settings = sort_cgroup_settings(cgroup_settings);\n\tif (!sorted_cgroup_settings) {\n\t\treturn -1;\n\t}\n\n\tlxc_list_for_each(iterator, sorted_cgroup_settings) {\n\t\tcg = iterator->elem;\n\n\t\tif (do_devices == !strncmp(\"devices\", cg->subsystem, 7)) {\n\t\t\tif (strcmp(cg->subsystem, \"devices.deny\") == 0 &&\n\t\t\t\t\tcgroup_devices_has_allow_or_deny(d, cg->value, false))\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(cg->subsystem, \"devices.allow\") == 0 &&\n\t\t\t\t\tcgroup_devices_has_allow_or_deny(d, cg->value, true))\n\t\t\t\tcontinue;\n\t\t\tif (lxc_cgroup_set_data(cg->subsystem, cg->value, d)) {\n\t\t\t\tif (do_devices && (errno == EACCES || errno == EPERM)) {\n\t\t\t\t\tWARN(\"Error setting %s to %s for %s\",\n\t\t\t\t\t      cg->subsystem, cg->value, d->name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tSYSERROR(\"Error setting %s to %s for %s\",\n\t\t\t\t      cg->subsystem, cg->value, d->name);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tDEBUG(\"cgroup '%s' set to '%s'\", cg->subsystem, cg->value);\n\t}\n\n\tret = 0;\n\tINFO(\"cgroup has been setup\");\nout:\n\tlxc_list_for_each_safe(iterator, sorted_cgroup_settings, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(sorted_cgroup_settings);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_valid_cgroup(const char *name);",
            "static struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);",
            "static int do_cgroup_set(const char *cgroup_path, const char *sub_filename, const char *value);",
            "static int do_setup_cgroup_limits(struct cgfs_data *d, struct lxc_list *cgroup_settings, bool do_devices);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool is_valid_cgroup(const char *name);\nstatic struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);\nstatic int do_cgroup_set(const char *cgroup_path, const char *sub_filename, const char *value);\nstatic int do_setup_cgroup_limits(struct cgfs_data *d, struct lxc_list *cgroup_settings, bool do_devices);\n\nstatic int do_setup_cgroup_limits(struct cgfs_data *d,\n\t\t\t   struct lxc_list *cgroup_settings, bool do_devices)\n{\n\tstruct lxc_list *iterator, *sorted_cgroup_settings, *next;\n\tstruct lxc_cgroup *cg;\n\tint ret = -1;\n\n\tif (lxc_list_empty(cgroup_settings))\n\t\treturn 0;\n\n\tsorted_cgroup_settings = sort_cgroup_settings(cgroup_settings);\n\tif (!sorted_cgroup_settings) {\n\t\treturn -1;\n\t}\n\n\tlxc_list_for_each(iterator, sorted_cgroup_settings) {\n\t\tcg = iterator->elem;\n\n\t\tif (do_devices == !strncmp(\"devices\", cg->subsystem, 7)) {\n\t\t\tif (strcmp(cg->subsystem, \"devices.deny\") == 0 &&\n\t\t\t\t\tcgroup_devices_has_allow_or_deny(d, cg->value, false))\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(cg->subsystem, \"devices.allow\") == 0 &&\n\t\t\t\t\tcgroup_devices_has_allow_or_deny(d, cg->value, true))\n\t\t\t\tcontinue;\n\t\t\tif (lxc_cgroup_set_data(cg->subsystem, cg->value, d)) {\n\t\t\t\tif (do_devices && (errno == EACCES || errno == EPERM)) {\n\t\t\t\t\tWARN(\"Error setting %s to %s for %s\",\n\t\t\t\t\t      cg->subsystem, cg->value, d->name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tSYSERROR(\"Error setting %s to %s for %s\",\n\t\t\t\t      cg->subsystem, cg->value, d->name);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tDEBUG(\"cgroup '%s' set to '%s'\", cg->subsystem, cg->value);\n\t}\n\n\tret = 0;\n\tINFO(\"cgroup has been setup\");\nout:\n\tlxc_list_for_each_safe(iterator, sorted_cgroup_settings, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(sorted_cgroup_settings);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgroupfs_setup_limits(void *hdata, struct lxc_list *cgroup_conf,\n\t\t\t\t  bool with_devices)\n{\n\tstruct cgfs_data *d = hdata;\n\n\tif (!d)\n\t\treturn false;\n\treturn do_setup_cgroup_limits(d, cgroup_conf, with_devices) == 0;\n}"
  },
  {
    "function_name": "cgfs_unfreeze",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "2501-2518",
    "snippet": "static bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cgabspath"
          ],
          "line": 2516
        },
        "resolved": true,
        "details": {
          "function_name": "cgfs_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2501-2518",
          "snippet": "static bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "do_cgroup_set",
          "args": [
            "cgabspath",
            "\"freezer.state\"",
            "\"THAWED\""
          ],
          "line": 2515
        },
        "resolved": true,
        "details": {
          "function_name": "do_cgroup_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1983-2003",
          "snippet": "static int do_cgroup_set(const char *cgroup_path, const char *sub_filename,\n\t\t\t const char *value)\n{\n\tconst char *parts[3] = {\n\t\tcgroup_path,\n\t\tsub_filename,\n\t\tNULL\n\t};\n\tchar *filename;\n\tint ret, saved_errno;\n\n\tfilename = lxc_string_join(\"/\", parts, false);\n\tif (!filename)\n\t\treturn -1;\n\n\tret = lxc_write_to_file(filename, value, strlen(value), false);\n\tsaved_errno = errno;\n\tfree(filename);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int do_cgroup_set(const char *cgroup_path, const char *sub_filename, const char *value);",
            "static int cgroup_recursive_task_count(const char *cgroup_path);",
            "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int do_cgroup_set(const char *cgroup_path, const char *sub_filename, const char *value);\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\n\nstatic int do_cgroup_set(const char *cgroup_path, const char *sub_filename,\n\t\t\t const char *value)\n{\n\tconst char *parts[3] = {\n\t\tcgroup_path,\n\t\tsub_filename,\n\t\tNULL\n\t};\n\tchar *filename;\n\tint ret, saved_errno;\n\n\tfilename = lxc_string_join(\"/\", parts, false);\n\tif (!filename)\n\t\treturn -1;\n\n\tret = lxc_write_to_file(filename, value, strlen(value), false);\n\tsaved_errno = errno;\n\tfree(filename);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_find_abs_path",
          "args": [
            "\"freezer\"",
            "cgrelpath",
            "true",
            "NULL"
          ],
          "line": 2511
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_find_abs_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "713-745",
          "snippet": "static char *lxc_cgroup_find_abs_path(const char *subsystem, const char *group, bool should_be_writable, const char *suffix)\n{\n\tstruct cgroup_meta_data *meta_data;\n\tstruct cgroup_hierarchy *h;\n\tstruct cgroup_mount_point *mp;\n\tchar *result;\n\tint saved_errno;\n\n\tmeta_data = lxc_cgroup_load_meta();\n\tif (!meta_data)\n\t\treturn NULL;\n\n\th = lxc_cgroup_find_hierarchy(meta_data, subsystem);\n\tif (!h)\n\t\tgoto out_error;\n\n\tmp = lxc_cgroup_find_mount_point(h, group, should_be_writable);\n\tif (!mp)\n\t\tgoto out_error;\n\n\tresult = cgroup_to_absolute_path(mp, group, suffix);\n\tif (!result)\n\t\tgoto out_error;\n\n\tlxc_cgroup_put_meta(meta_data);\n\treturn result;\n\nout_error:\n\tsaved_errno = errno;\n\tlxc_cgroup_put_meta(meta_data);\n\terrno = saved_errno;\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
            "static void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);",
            "static char *cgroup_to_absolute_path(struct cgroup_mount_point *mp, const char *path, const char *suffix);",
            "static struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);",
            "static struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);",
            "static struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);\nstatic char *cgroup_to_absolute_path(struct cgroup_mount_point *mp, const char *path, const char *suffix);\nstatic struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);\nstatic struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);\nstatic struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);\n\nstatic char *lxc_cgroup_find_abs_path(const char *subsystem, const char *group, bool should_be_writable, const char *suffix)\n{\n\tstruct cgroup_meta_data *meta_data;\n\tstruct cgroup_hierarchy *h;\n\tstruct cgroup_mount_point *mp;\n\tchar *result;\n\tint saved_errno;\n\n\tmeta_data = lxc_cgroup_load_meta();\n\tif (!meta_data)\n\t\treturn NULL;\n\n\th = lxc_cgroup_find_hierarchy(meta_data, subsystem);\n\tif (!h)\n\t\tgoto out_error;\n\n\tmp = lxc_cgroup_find_mount_point(h, group, should_be_writable);\n\tif (!mp)\n\t\tgoto out_error;\n\n\tresult = cgroup_to_absolute_path(mp, group, suffix);\n\tif (!result)\n\t\tgoto out_error;\n\n\tlxc_cgroup_put_meta(meta_data);\n\treturn result;\n\nout_error:\n\tsaved_errno = errno;\n\tlxc_cgroup_put_meta(meta_data);\n\terrno = saved_errno;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_get_hierarchy_path_data",
          "args": [
            "\"freezer\"",
            "d"
          ],
          "line": 2510
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_get_hierarchy_path_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1293-1301",
          "snippet": "static char *lxc_cgroup_get_hierarchy_path_data(const char *subsystem, struct cgfs_data *d)\n{\n\tstruct cgroup_process_info *info = d->info;\n\tinfo = find_info_for_subsystem(info, subsystem);\n\tif (!info)\n\t\treturn NULL;\n\tprune_init_scope(info->cgroup_path);\n\treturn info->cgroup_path;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);",
            "static int cgroup_recursive_task_count(const char *cgroup_path);",
            "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);",
            "static void lxc_cgroup_process_info_free(struct cgroup_process_info *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\nstatic void lxc_cgroup_process_info_free(struct cgroup_process_info *info);\n\nstatic char *lxc_cgroup_get_hierarchy_path_data(const char *subsystem, struct cgfs_data *d)\n{\n\tstruct cgroup_process_info *info = d->info;\n\tinfo = find_info_for_subsystem(info, subsystem);\n\tif (!info)\n\t\treturn NULL;\n\tprune_init_scope(info->cgroup_path);\n\treturn info->cgroup_path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}"
  },
  {
    "function_name": "cgfs_get_hierarchies",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "2495-2499",
    "snippet": "static bool cgfs_get_hierarchies(int i, char ***out)\n{\n\t/* not implemented */\n\treturn false;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgfs_get_hierarchies(int i, char ***out)\n{\n\t/* not implemented */\n\treturn false;\n}"
  },
  {
    "function_name": "cgfs_num_hierarchies",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "2489-2493",
    "snippet": "static int cgfs_num_hierarchies(void)\n{\n\t/* not implemented */\n\treturn -1;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int cgfs_num_hierarchies(void)\n{\n\t/* not implemented */\n\treturn -1;\n}"
  },
  {
    "function_name": "cgfs_escape",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "2440-2487",
    "snippet": "static bool cgfs_escape(void *hdata)\n{\n\tstruct cgroup_meta_data *md;\n\tint i;\n\tbool ret = false;\n\n\tmd = lxc_cgroup_load_meta();\n\tif (!md)\n\t\treturn false;\n\n\tfor (i = 0; i <= md->maximum_hierarchy; i++) {\n\t\tstruct cgroup_hierarchy *h = md->hierarchies[i];\n\t\tstruct cgroup_mount_point *mp;\n\t\tchar *tasks;\n\t\tFILE *f;\n\t\tint written;\n\n\t\tif (!h) {\n\t\t\tWARN(\"not escaping hierarchy %d\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmp = lxc_cgroup_find_mount_point(h, \"/\", true);\n\t\tif (!mp)\n\t\t\tgoto out;\n\n\t\ttasks = cgroup_to_absolute_path(mp, \"/\", \"tasks\");\n\t\tif (!tasks)\n\t\t\tgoto out;\n\n\t\tf = fopen(tasks, \"a\");\n\t\tfree(tasks);\n\t\tif (!f)\n\t\t\tgoto out;\n\n\t\twritten = fprintf(f, \"%d\\n\", getpid());\n\t\tfclose(f);\n\t\tif (written < 0) {\n\t\t\tSYSERROR(\"writing tasks failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = true;\nout:\n\tlxc_cgroup_put_meta(md);\n\treturn ret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
      "static void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_cgroup_put_meta",
          "args": [
            "md"
          ],
          "line": 2485
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_put_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "635-650",
          "snippet": "static struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data)\n{\n\tsize_t i;\n\tif (!meta_data)\n\t\treturn NULL;\n\tif (--meta_data->ref > 0)\n\t\treturn meta_data;\n\tlxc_free_array((void **)meta_data->mount_points, (lxc_free_fn)lxc_cgroup_mount_point_free);\n\tif (meta_data->hierarchies)\n\t\tfor (i = 0; i <= meta_data->maximum_hierarchy; i++)\n\t\t\tif (meta_data->hierarchies[i])\n\t\t\t\tlxc_cgroup_hierarchy_free(meta_data->hierarchies[i]);\n\tfree(meta_data->hierarchies);\n\tfree(meta_data);\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);",
            "static struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);\nstatic struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);\n\nstatic struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data)\n{\n\tsize_t i;\n\tif (!meta_data)\n\t\treturn NULL;\n\tif (--meta_data->ref > 0)\n\t\treturn meta_data;\n\tlxc_free_array((void **)meta_data->mount_points, (lxc_free_fn)lxc_cgroup_mount_point_free);\n\tif (meta_data->hierarchies)\n\t\tfor (i = 0; i <= meta_data->maximum_hierarchy; i++)\n\t\t\tif (meta_data->hierarchies[i])\n\t\t\t\tlxc_cgroup_hierarchy_free(meta_data->hierarchies[i]);\n\tfree(meta_data->hierarchies);\n\tfree(meta_data);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"writing tasks failed\\n\""
          ],
          "line": 2478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 2476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"%d\\n\"",
            "getpid()"
          ],
          "line": 2475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 2475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tasks"
          ],
          "line": 2471
        },
        "resolved": true,
        "details": {
          "function_name": "cgfs_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2501-2518",
          "snippet": "static bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "tasks",
            "\"a\""
          ],
          "line": 2470
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_to_absolute_path",
          "args": [
            "mp",
            "\"/\"",
            "\"tasks\""
          ],
          "line": 2466
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_to_absolute_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1901-1944",
          "snippet": "static char *cgroup_to_absolute_path(struct cgroup_mount_point *mp,\n\t\t\t\t     const char *path, const char *suffix)\n{\n\t/* first we have to make sure we subtract the mount point's prefix */\n\tchar *prefix = mp->mount_prefix;\n\tchar *buf;\n\tssize_t len, rv;\n\n\t/* we want to make sure only absolute paths to cgroups are passed to us */\n\tif (path[0] != '/') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (prefix && !strcmp(prefix, \"/\"))\n\t\tprefix = NULL;\n\n\t/* prefix doesn't match */\n\tif (prefix && strncmp(prefix, path, strlen(prefix)) != 0) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\t/* if prefix is /foo and path is /foobar */\n\tif (prefix && path[strlen(prefix)] != '/' && path[strlen(prefix)] != '\\0') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\t/* remove prefix from path */\n\tpath += prefix ? strlen(prefix) : 0;\n\n\tlen = strlen(mp->mount_point) + strlen(path) + (suffix ? strlen(suffix) : 0);\n\tbuf = calloc(len + 1, 1);\n\tif (!buf)\n\t\treturn NULL;\n\trv = snprintf(buf, len + 1, \"%s%s%s\", mp->mount_point, path, suffix ? suffix : \"\");\n\tif (rv > len) {\n\t\tfree(buf);\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\treturn buf;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
            "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
            "static char *cgroup_to_absolute_path(struct cgroup_mount_point *mp, const char *path, const char *suffix);",
            "static int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);",
            "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic char *cgroup_to_absolute_path(struct cgroup_mount_point *mp, const char *path, const char *suffix);\nstatic int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\n\nstatic char *cgroup_to_absolute_path(struct cgroup_mount_point *mp,\n\t\t\t\t     const char *path, const char *suffix)\n{\n\t/* first we have to make sure we subtract the mount point's prefix */\n\tchar *prefix = mp->mount_prefix;\n\tchar *buf;\n\tssize_t len, rv;\n\n\t/* we want to make sure only absolute paths to cgroups are passed to us */\n\tif (path[0] != '/') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (prefix && !strcmp(prefix, \"/\"))\n\t\tprefix = NULL;\n\n\t/* prefix doesn't match */\n\tif (prefix && strncmp(prefix, path, strlen(prefix)) != 0) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\t/* if prefix is /foo and path is /foobar */\n\tif (prefix && path[strlen(prefix)] != '/' && path[strlen(prefix)] != '\\0') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\t/* remove prefix from path */\n\tpath += prefix ? strlen(prefix) : 0;\n\n\tlen = strlen(mp->mount_point) + strlen(path) + (suffix ? strlen(suffix) : 0);\n\tbuf = calloc(len + 1, 1);\n\tif (!buf)\n\t\treturn NULL;\n\trv = snprintf(buf, len + 1, \"%s%s%s\", mp->mount_point, path, suffix ? suffix : \"\");\n\tif (rv > len) {\n\t\tfree(buf);\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_find_mount_point",
          "args": [
            "h",
            "\"/\"",
            "true"
          ],
          "line": 2462
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_find_mount_point",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "670-711",
          "snippet": "static struct cgroup_mount_point *lxc_cgroup_find_mount_point(struct cgroup_hierarchy *hierarchy, const char *group, bool should_be_writable)\n{\n\tstruct cgroup_mount_point **mps;\n\tstruct cgroup_mount_point *current_result = NULL;\n\tssize_t quality = -1;\n\n\t/* trivial case */\n\tif (mountpoint_is_accessible(hierarchy->rw_absolute_mount_point))\n\t\treturn hierarchy->rw_absolute_mount_point;\n\tif (!should_be_writable && mountpoint_is_accessible(hierarchy->ro_absolute_mount_point))\n\t\treturn hierarchy->ro_absolute_mount_point;\n\n\tfor (mps = hierarchy->all_mount_points; mps && *mps; mps++) {\n\t\tstruct cgroup_mount_point *mp = *mps;\n\t\tsize_t prefix_len = mp->mount_prefix ? strlen(mp->mount_prefix) : 0;\n\n\t\tif (prefix_len == 1 && mp->mount_prefix[0] == '/')\n\t\t\tprefix_len = 0;\n\n\t\tif (!mountpoint_is_accessible(mp))\n\t\t\tcontinue;\n\n\t\tif (should_be_writable && mp->read_only)\n\t\t\tcontinue;\n\n\t\tif (!prefix_len ||\n\t\t    (strncmp(group, mp->mount_prefix, prefix_len) == 0 &&\n\t\t     (group[prefix_len] == '\\0' || group[prefix_len] == '/'))) {\n\t\t\t/* search for the best quality match, i.e. the match with the\n\t\t\t * shortest prefix where this group is still contained\n\t\t\t */\n\t\t\tif (quality == -1 || prefix_len < quality) {\n\t\t\t\tcurrent_result = mp;\n\t\t\t\tquality = prefix_len;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!current_result)\n\t\terrno = ENOENT;\n\treturn current_result;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\n\nstatic struct cgroup_mount_point *lxc_cgroup_find_mount_point(struct cgroup_hierarchy *hierarchy, const char *group, bool should_be_writable)\n{\n\tstruct cgroup_mount_point **mps;\n\tstruct cgroup_mount_point *current_result = NULL;\n\tssize_t quality = -1;\n\n\t/* trivial case */\n\tif (mountpoint_is_accessible(hierarchy->rw_absolute_mount_point))\n\t\treturn hierarchy->rw_absolute_mount_point;\n\tif (!should_be_writable && mountpoint_is_accessible(hierarchy->ro_absolute_mount_point))\n\t\treturn hierarchy->ro_absolute_mount_point;\n\n\tfor (mps = hierarchy->all_mount_points; mps && *mps; mps++) {\n\t\tstruct cgroup_mount_point *mp = *mps;\n\t\tsize_t prefix_len = mp->mount_prefix ? strlen(mp->mount_prefix) : 0;\n\n\t\tif (prefix_len == 1 && mp->mount_prefix[0] == '/')\n\t\t\tprefix_len = 0;\n\n\t\tif (!mountpoint_is_accessible(mp))\n\t\t\tcontinue;\n\n\t\tif (should_be_writable && mp->read_only)\n\t\t\tcontinue;\n\n\t\tif (!prefix_len ||\n\t\t    (strncmp(group, mp->mount_prefix, prefix_len) == 0 &&\n\t\t     (group[prefix_len] == '\\0' || group[prefix_len] == '/'))) {\n\t\t\t/* search for the best quality match, i.e. the match with the\n\t\t\t * shortest prefix where this group is still contained\n\t\t\t */\n\t\t\tif (quality == -1 || prefix_len < quality) {\n\t\t\t\tcurrent_result = mp;\n\t\t\t\tquality = prefix_len;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!current_result)\n\t\terrno = ENOENT;\n\treturn current_result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"not escaping hierarchy %d\"",
            "i"
          ],
          "line": 2458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_load_meta",
          "args": [],
          "line": 2446
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_load_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "241-263",
          "snippet": "static struct cgroup_meta_data *lxc_cgroup_load_meta()\n{\n\tconst char *cgroup_use = NULL;\n\tchar **cgroup_use_list = NULL;\n\tstruct cgroup_meta_data *md = NULL;\n\tint saved_errno;\n\n\terrno = 0;\n\tcgroup_use = lxc_global_config_value(\"lxc.cgroup.use\");\n\tif (!cgroup_use && errno != 0)\n\t\treturn NULL;\n\tif (cgroup_use) {\n\t\tcgroup_use_list = lxc_string_split_and_trim(cgroup_use, ',');\n\t\tif (!cgroup_use_list)\n\t\t\treturn NULL;\n\t}\n\n\tmd = lxc_cgroup_load_meta2((const char **)cgroup_use_list);\n\tsaved_errno = errno;\n\tlxc_free_array((void **)cgroup_use_list, free);\n\terrno = saved_errno;\n\treturn md;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_meta_data *lxc_cgroup_load_meta()\n{\n\tconst char *cgroup_use = NULL;\n\tchar **cgroup_use_list = NULL;\n\tstruct cgroup_meta_data *md = NULL;\n\tint saved_errno;\n\n\terrno = 0;\n\tcgroup_use = lxc_global_config_value(\"lxc.cgroup.use\");\n\tif (!cgroup_use && errno != 0)\n\t\treturn NULL;\n\tif (cgroup_use) {\n\t\tcgroup_use_list = lxc_string_split_and_trim(cgroup_use, ',');\n\t\tif (!cgroup_use_list)\n\t\t\treturn NULL;\n\t}\n\n\tmd = lxc_cgroup_load_meta2((const char **)cgroup_use_list);\n\tsaved_errno = errno;\n\tlxc_free_array((void **)cgroup_use_list, free);\n\terrno = saved_errno;\n\treturn md;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);\n\nstatic bool cgfs_escape(void *hdata)\n{\n\tstruct cgroup_meta_data *md;\n\tint i;\n\tbool ret = false;\n\n\tmd = lxc_cgroup_load_meta();\n\tif (!md)\n\t\treturn false;\n\n\tfor (i = 0; i <= md->maximum_hierarchy; i++) {\n\t\tstruct cgroup_hierarchy *h = md->hierarchies[i];\n\t\tstruct cgroup_mount_point *mp;\n\t\tchar *tasks;\n\t\tFILE *f;\n\t\tint written;\n\n\t\tif (!h) {\n\t\t\tWARN(\"not escaping hierarchy %d\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmp = lxc_cgroup_find_mount_point(h, \"/\", true);\n\t\tif (!mp)\n\t\t\tgoto out;\n\n\t\ttasks = cgroup_to_absolute_path(mp, \"/\", \"tasks\");\n\t\tif (!tasks)\n\t\t\tgoto out;\n\n\t\tf = fopen(tasks, \"a\");\n\t\tfree(tasks);\n\t\tif (!f)\n\t\t\tgoto out;\n\n\t\twritten = fprintf(f, \"%d\\n\", getpid());\n\t\tfclose(f);\n\t\tif (written < 0) {\n\t\t\tSYSERROR(\"writing tasks failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = true;\nout:\n\tlxc_cgroup_put_meta(md);\n\treturn ret;\n}"
  },
  {
    "function_name": "cgfs_get_cgroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "2431-2438",
    "snippet": "static const char *cgfs_get_cgroup(void *hdata, const char *subsystem)\n{\n\tstruct cgfs_data *d = hdata;\n\n\tif (!d)\n\t\treturn NULL;\n\treturn lxc_cgroup_get_hierarchy_path_data(subsystem, d);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_cgroup_get_hierarchy_path_data",
          "args": [
            "subsystem",
            "d"
          ],
          "line": 2437
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_get_hierarchy_path_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1293-1301",
          "snippet": "static char *lxc_cgroup_get_hierarchy_path_data(const char *subsystem, struct cgfs_data *d)\n{\n\tstruct cgroup_process_info *info = d->info;\n\tinfo = find_info_for_subsystem(info, subsystem);\n\tif (!info)\n\t\treturn NULL;\n\tprune_init_scope(info->cgroup_path);\n\treturn info->cgroup_path;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);",
            "static int cgroup_recursive_task_count(const char *cgroup_path);",
            "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);",
            "static void lxc_cgroup_process_info_free(struct cgroup_process_info *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\nstatic void lxc_cgroup_process_info_free(struct cgroup_process_info *info);\n\nstatic char *lxc_cgroup_get_hierarchy_path_data(const char *subsystem, struct cgfs_data *d)\n{\n\tstruct cgroup_process_info *info = d->info;\n\tinfo = find_info_for_subsystem(info, subsystem);\n\tif (!info)\n\t\treturn NULL;\n\tprune_init_scope(info->cgroup_path);\n\treturn info->cgroup_path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);\n\nstatic const char *cgfs_get_cgroup(void *hdata, const char *subsystem)\n{\n\tstruct cgfs_data *d = hdata;\n\n\tif (!d)\n\t\treturn NULL;\n\treturn lxc_cgroup_get_hierarchy_path_data(subsystem, d);\n}"
  },
  {
    "function_name": "cgfs_create_legacy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "2416-2429",
    "snippet": "static inline bool cgfs_create_legacy(void *hdata, pid_t pid)\n{\n\tstruct cgfs_data *d = hdata;\n\tstruct cgroup_process_info *i;\n\n\tif (!d)\n\t\treturn false;\n\ti = d->info;\n\tif (lxc_cgroup_create_legacy(i, d->name, pid) < 0) {\n\t\tERROR(\"failed to create legacy ns cgroups for '%s'\", d->name);\n\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_valid_cgroup(const char *name);",
      "static void lxc_cgroup_process_info_free(struct cgroup_process_info *info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to create legacy ns cgroups for '%s'\"",
            "d->name"
          ],
          "line": 2425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_create_legacy",
          "args": [
            "i",
            "d->name",
            "pid"
          ],
          "line": 2424
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_create_legacy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1122-1153",
          "snippet": "static int lxc_cgroup_create_legacy(struct cgroup_process_info *base_info, const char *name, pid_t pid)\n{\n\tstruct cgroup_process_info *info_ptr;\n\tint r;\n\n\tfor (info_ptr = base_info; info_ptr; info_ptr = info_ptr->next) {\n\t\tif (!info_ptr->hierarchy)\n\t\t\tcontinue;\n\n\t\tif (!lxc_string_in_array(\"ns\", (const char **)info_ptr->hierarchy->subsystems))\n\t\t\tcontinue;\n\t\t/*\n\t\t * For any path which has ns cgroup mounted, handler->pid is already\n\t\t * moved into a container called '%d % (handler->pid)'.  Rename it to\n\t\t * the cgroup name and record that.\n\t\t */\n\t\tchar *tmp = cgroup_rename_nsgroup((const char *)info_ptr->designated_mount_point->mount_point,\n\t\t\t\tinfo_ptr->cgroup_path, pid, name);\n\t\tif (!tmp)\n\t\t\treturn -1;\n\t\tfree(info_ptr->cgroup_path);\n\t\tinfo_ptr->cgroup_path = tmp;\n\t\tr = lxc_grow_array((void ***)&info_ptr->created_paths, &info_ptr->created_paths_capacity, info_ptr->created_paths_count + 1, 8);\n\t\tif (r < 0)\n\t\t\treturn -1;\n\t\ttmp = strdup(tmp);\n\t\tif (!tmp)\n\t\t\treturn -1;\n\t\tinfo_ptr->created_paths[info_ptr->created_paths_count++] = tmp;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_valid_cgroup(const char *name);",
            "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
            "static int cgroup_recursive_task_count(const char *cgroup_path);",
            "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);",
            "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool is_valid_cgroup(const char *name);\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\n\nstatic int lxc_cgroup_create_legacy(struct cgroup_process_info *base_info, const char *name, pid_t pid)\n{\n\tstruct cgroup_process_info *info_ptr;\n\tint r;\n\n\tfor (info_ptr = base_info; info_ptr; info_ptr = info_ptr->next) {\n\t\tif (!info_ptr->hierarchy)\n\t\t\tcontinue;\n\n\t\tif (!lxc_string_in_array(\"ns\", (const char **)info_ptr->hierarchy->subsystems))\n\t\t\tcontinue;\n\t\t/*\n\t\t * For any path which has ns cgroup mounted, handler->pid is already\n\t\t * moved into a container called '%d % (handler->pid)'.  Rename it to\n\t\t * the cgroup name and record that.\n\t\t */\n\t\tchar *tmp = cgroup_rename_nsgroup((const char *)info_ptr->designated_mount_point->mount_point,\n\t\t\t\tinfo_ptr->cgroup_path, pid, name);\n\t\tif (!tmp)\n\t\t\treturn -1;\n\t\tfree(info_ptr->cgroup_path);\n\t\tinfo_ptr->cgroup_path = tmp;\n\t\tr = lxc_grow_array((void ***)&info_ptr->created_paths, &info_ptr->created_paths_capacity, info_ptr->created_paths_count + 1, 8);\n\t\tif (r < 0)\n\t\t\treturn -1;\n\t\ttmp = strdup(tmp);\n\t\tif (!tmp)\n\t\t\treturn -1;\n\t\tinfo_ptr->created_paths[info_ptr->created_paths_count++] = tmp;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool is_valid_cgroup(const char *name);\nstatic void lxc_cgroup_process_info_free(struct cgroup_process_info *info);\n\nstatic inline bool cgfs_create_legacy(void *hdata, pid_t pid)\n{\n\tstruct cgfs_data *d = hdata;\n\tstruct cgroup_process_info *i;\n\n\tif (!d)\n\t\treturn false;\n\ti = d->info;\n\tif (lxc_cgroup_create_legacy(i, d->name, pid) < 0) {\n\t\tERROR(\"failed to create legacy ns cgroups for '%s'\", d->name);\n\t\treturn false;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "cgfs_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "2402-2414",
    "snippet": "static inline bool cgfs_enter(void *hdata, pid_t pid)\n{\n\tstruct cgfs_data *d = hdata;\n\tstruct cgroup_process_info *i;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\ti = d->info;\n\tret = lxc_cgroupfs_enter(i, pid, false);\n\n\treturn ret == 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void lxc_cgroup_process_info_free(struct cgroup_process_info *info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_cgroupfs_enter",
          "args": [
            "i",
            "pid",
            "false"
          ],
          "line": 2411
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroupfs_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1206-1245",
          "snippet": "static int lxc_cgroupfs_enter(struct cgroup_process_info *info, pid_t pid, bool enter_sub)\n{\n\tchar pid_buf[32];\n\tchar *cgroup_tasks_fn;\n\tint r;\n\tstruct cgroup_process_info *info_ptr;\n\n\tsnprintf(pid_buf, 32, \"%lu\", (unsigned long)pid);\n\tfor (info_ptr = info; info_ptr; info_ptr = info_ptr->next) {\n\t\tif (!info_ptr->hierarchy)\n\t\t\tcontinue;\n\n\t\tchar *cgroup_path = (enter_sub && info_ptr->cgroup_path_sub) ?\n\t\t\tinfo_ptr->cgroup_path_sub :\n\t\t\tinfo_ptr->cgroup_path;\n\n\t\tif (!info_ptr->designated_mount_point) {\n\t\t\tinfo_ptr->designated_mount_point = lxc_cgroup_find_mount_point(info_ptr->hierarchy, cgroup_path, true);\n\t\t\tif (!info_ptr->designated_mount_point) {\n\t\t\t\tSYSERROR(\"Could not add pid %lu to cgroup %s: internal error (couldn't find any writable mountpoint to cgroup filesystem)\", (unsigned long)pid, cgroup_path);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tcgroup_tasks_fn = cgroup_to_absolute_path(info_ptr->designated_mount_point, cgroup_path, \"/tasks\");\n\t\tif (!cgroup_tasks_fn) {\n\t\t\tSYSERROR(\"Could not add pid %lu to cgroup %s: internal error\", (unsigned long)pid, cgroup_path);\n\t\t\treturn -1;\n\t\t}\n\n\t\tr = lxc_write_to_file(cgroup_tasks_fn, pid_buf, strlen(pid_buf), false);\n\t\tfree(cgroup_tasks_fn);\n\t\tif (r < 0 && is_crucial_hierarchy(info_ptr->hierarchy)) {\n\t\t\tSYSERROR(\"Could not add pid %lu to cgroup %s: internal error\", (unsigned long)pid, cgroup_path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_recursive_task_count(const char *cgroup_path);",
            "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);",
            "static void lxc_cgroup_process_info_free(struct cgroup_process_info *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\nstatic void lxc_cgroup_process_info_free(struct cgroup_process_info *info);\n\nstatic int lxc_cgroupfs_enter(struct cgroup_process_info *info, pid_t pid, bool enter_sub)\n{\n\tchar pid_buf[32];\n\tchar *cgroup_tasks_fn;\n\tint r;\n\tstruct cgroup_process_info *info_ptr;\n\n\tsnprintf(pid_buf, 32, \"%lu\", (unsigned long)pid);\n\tfor (info_ptr = info; info_ptr; info_ptr = info_ptr->next) {\n\t\tif (!info_ptr->hierarchy)\n\t\t\tcontinue;\n\n\t\tchar *cgroup_path = (enter_sub && info_ptr->cgroup_path_sub) ?\n\t\t\tinfo_ptr->cgroup_path_sub :\n\t\t\tinfo_ptr->cgroup_path;\n\n\t\tif (!info_ptr->designated_mount_point) {\n\t\t\tinfo_ptr->designated_mount_point = lxc_cgroup_find_mount_point(info_ptr->hierarchy, cgroup_path, true);\n\t\t\tif (!info_ptr->designated_mount_point) {\n\t\t\t\tSYSERROR(\"Could not add pid %lu to cgroup %s: internal error (couldn't find any writable mountpoint to cgroup filesystem)\", (unsigned long)pid, cgroup_path);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tcgroup_tasks_fn = cgroup_to_absolute_path(info_ptr->designated_mount_point, cgroup_path, \"/tasks\");\n\t\tif (!cgroup_tasks_fn) {\n\t\t\tSYSERROR(\"Could not add pid %lu to cgroup %s: internal error\", (unsigned long)pid, cgroup_path);\n\t\t\treturn -1;\n\t\t}\n\n\t\tr = lxc_write_to_file(cgroup_tasks_fn, pid_buf, strlen(pid_buf), false);\n\t\tfree(cgroup_tasks_fn);\n\t\tif (r < 0 && is_crucial_hierarchy(info_ptr->hierarchy)) {\n\t\t\tSYSERROR(\"Could not add pid %lu to cgroup %s: internal error\", (unsigned long)pid, cgroup_path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_process_info_free(struct cgroup_process_info *info);\n\nstatic inline bool cgfs_enter(void *hdata, pid_t pid)\n{\n\tstruct cgfs_data *d = hdata;\n\tstruct cgroup_process_info *i;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\ti = d->info;\n\tret = lxc_cgroupfs_enter(i, pid, false);\n\n\treturn ret == 0;\n}"
  },
  {
    "function_name": "cgfs_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "2386-2400",
    "snippet": "static inline bool cgfs_create(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tstruct cgroup_process_info *i;\n\tstruct cgroup_meta_data *md;\n\n\tif (!d)\n\t\treturn false;\n\tmd = d->meta;\n\ti = lxc_cgroupfs_create(d->name, d->cgroup_pattern, md, NULL);\n\tif (!i)\n\t\treturn false;\n\td->info = i;\n\treturn true;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cgroup_process_info *lxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str, struct cgroup_meta_data *meta);",
      "static bool is_valid_cgroup(const char *name);",
      "static void lxc_cgroup_process_info_free(struct cgroup_process_info *info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_cgroupfs_create",
          "args": [
            "d->name",
            "d->cgroup_pattern",
            "md",
            "NULL"
          ],
          "line": 2395
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroupfs_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "848-1120",
          "snippet": "static struct cgroup_process_info *lxc_cgroupfs_create(const char *name, const char *path_pattern, struct cgroup_meta_data *meta_data, const char *sub_pattern)\n{\n\tchar **cgroup_path_components = NULL;\n\tchar **p = NULL;\n\tchar *path_so_far = NULL;\n\tchar **new_cgroup_paths = NULL;\n\tchar **new_cgroup_paths_sub = NULL;\n\tstruct cgroup_mount_point *mp;\n\tstruct cgroup_hierarchy *h;\n\tstruct cgroup_process_info *base_info = NULL;\n\tstruct cgroup_process_info *info_ptr;\n\tint saved_errno;\n\tint r;\n\tunsigned suffix = 0;\n\tbool had_sub_pattern = false;\n\tsize_t i;\n\n\tif (!is_valid_cgroup(name)) {\n\t\tERROR(\"Invalid cgroup name: '%s'\", name);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (!strstr(path_pattern, \"%n\")) {\n\t\tERROR(\"Invalid cgroup path pattern: '%s'; contains no %%n for specifying container name\", path_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\t/* we will modify the result of this operation directly,\n\t * so we don't have to copy the data structure\n\t */\n\tbase_info = (path_pattern[0] == '/') ?\n\t\tlxc_cgroup_process_info_get_init(meta_data) :\n\t\tlxc_cgroup_process_info_get_self(meta_data);\n\tif (!base_info)\n\t\treturn NULL;\n\n\tnew_cgroup_paths = calloc(meta_data->maximum_hierarchy + 1, sizeof(char *));\n\tif (!new_cgroup_paths)\n\t\tgoto out_initial_error;\n\n\tnew_cgroup_paths_sub = calloc(meta_data->maximum_hierarchy + 1, sizeof(char *));\n\tif (!new_cgroup_paths_sub)\n\t\tgoto out_initial_error;\n\n\t/* find mount points we can use */\n\tfor (info_ptr = base_info; info_ptr; info_ptr = info_ptr->next) {\n\t\th = info_ptr->hierarchy;\n\t\tif (!h)\n\t\t\tcontinue;\n\t\tmp = lxc_cgroup_find_mount_point(h, info_ptr->cgroup_path, true);\n\t\tif (!mp) {\n\t\t\tERROR(\"Could not find writable mount point for cgroup hierarchy %d while trying to create cgroup.\", h->index);\n\t\t\tgoto out_initial_error;\n\t\t}\n\t\tinfo_ptr->designated_mount_point = mp;\n\n\t\tif (lxc_string_in_array(\"ns\", (const char **)h->subsystems))\n\t\t\tcontinue;\n\t\tif (handle_cgroup_settings(mp, info_ptr->cgroup_path) < 0) {\n\t\t\tERROR(\"Could not set clone_children to 1 for cpuset hierarchy in parent cgroup.\");\n\t\t\tgoto out_initial_error;\n\t\t}\n\t}\n\n\t/* normalize the path */\n\tcgroup_path_components = lxc_normalize_path(path_pattern);\n\tif (!cgroup_path_components)\n\t\tgoto out_initial_error;\n\n\t/* go through the path components to see if we can create them */\n\tfor (p = cgroup_path_components; *p || (sub_pattern && !had_sub_pattern); p++) {\n\t\t/* we only want to create the same component with -1, -2, etc.\n\t\t * if the component contains the container name itself, otherwise\n\t\t * it's not an error if it already exists\n\t\t */\n\t\tchar *p_eff = *p ? *p : (char *)sub_pattern;\n\t\tbool contains_name = strstr(p_eff, \"%n\");\n\t\tchar *current_component = NULL;\n\t\tchar *current_subpath = NULL;\n\t\tchar *current_entire_path = NULL;\n\t\tchar *parts[3];\n\t\tsize_t j = 0;\n\t\ti = 0;\n\n\t\t/* if we are processing the subpattern, we want to make sure\n\t\t * loop is ended the next time around\n\t\t */\n\t\tif (!*p) {\n\t\t\thad_sub_pattern = true;\n\t\t\tp--;\n\t\t}\n\n\t\tgoto find_name_on_this_level;\n\n\tcleanup_name_on_this_level:\n\t\t/* This is reached if we found a name clash.\n\t\t * In that case, remove the cgroup from all previous hierarchies\n\t\t */\n\t\tfor (j = 0, info_ptr = base_info; j < i && info_ptr; info_ptr = info_ptr->next, j++) {\n\t\t\tif (info_ptr->created_paths_count < 1)\n\t\t\t\tcontinue;\n\t\t\tr = remove_cgroup(info_ptr->designated_mount_point, info_ptr->created_paths[info_ptr->created_paths_count - 1], false, NULL);\n\t\t\tif (r < 0)\n\t\t\t\tWARN(\"could not clean up cgroup we created when trying to create container\");\n\t\t\tfree(info_ptr->created_paths[info_ptr->created_paths_count - 1]);\n\t\t\tinfo_ptr->created_paths[--info_ptr->created_paths_count] = NULL;\n\t\t}\n\t\tif (current_component != current_subpath)\n\t\t\tfree(current_subpath);\n\t\tif (current_component != p_eff)\n\t\t\tfree(current_component);\n\t\tcurrent_component = current_subpath = NULL;\n\t\t/* try again with another suffix */\n\t\t++suffix;\n\n\tfind_name_on_this_level:\n\t\t/* determine name of the path component we should create */\n\t\tif (contains_name && suffix > 0) {\n\t\t\tchar *buf = calloc(strlen(name) + 32, 1);\n\t\t\tif (!buf)\n\t\t\t\tgoto out_initial_error;\n\t\t\tsnprintf(buf, strlen(name) + 32, \"%s-%u\", name, suffix);\n\t\t\tcurrent_component = lxc_string_replace(\"%n\", buf, p_eff);\n\t\t\tfree(buf);\n\t\t} else {\n\t\t\tcurrent_component = contains_name ? lxc_string_replace(\"%n\", name, p_eff) : p_eff;\n\t\t}\n\t\tparts[0] = path_so_far;\n\t\tparts[1] = current_component;\n\t\tparts[2] = NULL;\n\t\tcurrent_subpath = path_so_far ? lxc_string_join(\"/\", (const char **)parts, false) : current_component;\n\n\t\t/* Now go through each hierarchy and try to create the\n\t\t * corresponding cgroup\n\t\t */\n\t\tfor (i = 0, info_ptr = base_info; info_ptr; info_ptr = info_ptr->next, i++) {\n\t\t\tchar *parts2[3];\n\n\t\t\tif (!info_ptr->hierarchy)\n\t\t\t\tcontinue;\n\n\t\t\tif (lxc_string_in_array(\"ns\", (const char **)info_ptr->hierarchy->subsystems))\n\t\t\t\tcontinue;\n\t\t\tcurrent_entire_path = NULL;\n\n\t\t\tparts2[0] = !strcmp(info_ptr->cgroup_path, \"/\") ? \"\" : info_ptr->cgroup_path;\n\t\t\tparts2[1] = current_subpath;\n\t\t\tparts2[2] = NULL;\n\t\t\tcurrent_entire_path = lxc_string_join(\"/\", (const char **)parts2, false);\n\n\t\t\tif (!*p) {\n\t\t\t\t/* we are processing the subpath, so only update that one */\n\t\t\t\tfree(new_cgroup_paths_sub[i]);\n\t\t\t\tnew_cgroup_paths_sub[i] = strdup(current_entire_path);\n\t\t\t\tif (!new_cgroup_paths_sub[i])\n\t\t\t\t\tgoto cleanup_from_error;\n\t\t\t} else {\n\t\t\t\t/* remember which path was used on this controller */\n\t\t\t\tfree(new_cgroup_paths[i]);\n\t\t\t\tnew_cgroup_paths[i] = strdup(current_entire_path);\n\t\t\t\tif (!new_cgroup_paths[i])\n\t\t\t\t\tgoto cleanup_from_error;\n\t\t\t}\n\n\t\t\tr = create_cgroup(info_ptr->designated_mount_point, current_entire_path);\n\t\t\tif (r < 0 && errno == EEXIST && contains_name) {\n\t\t\t\t/* name clash => try new name with new suffix */\n\t\t\t\tfree(current_entire_path);\n\t\t\t\tcurrent_entire_path = NULL;\n\t\t\t\tgoto cleanup_name_on_this_level;\n\t\t\t} else if (r < 0 && errno != EEXIST) {\n\t\t\t\tif (is_crucial_hierarchy(info_ptr->hierarchy)) {\n\t\t\t\t\tSYSERROR(\"Could not create cgroup '%s' in '%s'.\", current_entire_path, info_ptr->designated_mount_point->mount_point);\n\t\t\t\t\tgoto cleanup_from_error;\n\t\t\t\t}\n\t\t\t\tgoto skip;\n\t\t\t} else if (r == 0) {\n\t\t\t\t/* successfully created */\n\t\t\t\tr = lxc_grow_array((void ***)&info_ptr->created_paths, &info_ptr->created_paths_capacity, info_ptr->created_paths_count + 1, 8);\n\t\t\t\tif (r < 0)\n\t\t\t\t\tgoto cleanup_from_error;\n\t\t\t\tif (!init_cpuset_if_needed(info_ptr->designated_mount_point, current_entire_path)) {\n\t\t\t\t\tERROR(\"Failed to initialize cpuset for '%s' in '%s'.\", current_entire_path, info_ptr->designated_mount_point->mount_point);\n\t\t\t\t\tgoto cleanup_from_error;\n\t\t\t\t}\n\t\t\t\tinfo_ptr->created_paths[info_ptr->created_paths_count++] = current_entire_path;\n\t\t\t} else {\n\t\t\t\t/* if we didn't create the cgroup, then we have to make sure that\n\t\t\t\t * further cgroups will be created properly\n\t\t\t\t */\n\t\t\t\tif (handle_cgroup_settings(info_ptr->designated_mount_point, info_ptr->cgroup_path) < 0) {\n\t\t\t\t\tERROR(\"Could not set clone_children to 1 for cpuset hierarchy in pre-existing cgroup.\");\n\t\t\t\t\tgoto cleanup_from_error;\n\t\t\t\t}\n\t\t\t\tif (!init_cpuset_if_needed(info_ptr->designated_mount_point, info_ptr->cgroup_path)) {\n\t\t\t\t\tERROR(\"Failed to initialize cpuset in pre-existing '%s'.\", info_ptr->cgroup_path);\n\t\t\t\t\tgoto cleanup_from_error;\n\t\t\t\t}\n\nskip:\n\t\t\t\t/* already existed but path component of pattern didn't contain '%n',\n\t\t\t\t * so this is not an error; but then we don't need current_entire_path\n\t\t\t\t * anymore...\n\t\t\t\t */\n\t\t\t\tfree(current_entire_path);\n\t\t\t\tcurrent_entire_path = NULL;\n\t\t\t}\n\t\t}\n\n\t\t/* save path so far */\n\t\tfree(path_so_far);\n\t\tpath_so_far = strdup(current_subpath);\n\t\tif (!path_so_far)\n\t\t\tgoto cleanup_from_error;\n\n\t\t/* cleanup */\n\t\tif (current_component != current_subpath)\n\t\t\tfree(current_subpath);\n\t\tif (current_component != p_eff)\n\t\t\tfree(current_component);\n\t\tcurrent_component = current_subpath = NULL;\n\t\tcontinue;\n\n\tcleanup_from_error:\n\t\t/* called if an error occurred in the loop, so we\n\t\t * do some additional cleanup here\n\t\t */\n\t\tsaved_errno = errno;\n\t\tif (current_component != current_subpath)\n\t\t\tfree(current_subpath);\n\t\tif (current_component != p_eff)\n\t\t\tfree(current_component);\n\t\tfree(current_entire_path);\n\t\terrno = saved_errno;\n\t\tgoto out_initial_error;\n\t}\n\n\t/* we're done, now update the paths */\n\tfor (i = 0, info_ptr = base_info; info_ptr; info_ptr = info_ptr->next, i++) {\n\t\tif (!info_ptr->hierarchy)\n\t\t\tcontinue;\n\t\t/* ignore legacy 'ns' subsystem here, lxc_cgroup_create_legacy\n\t\t * will take care of it\n\t\t * Since we do a continue in above loop, new_cgroup_paths[i] is\n\t\t * unset anyway, as is new_cgroup_paths_sub[i]\n\t\t */\n\t\tif (lxc_string_in_array(\"ns\", (const char **)info_ptr->hierarchy->subsystems))\n\t\t\tcontinue;\n\t\tfree(info_ptr->cgroup_path);\n\t\tinfo_ptr->cgroup_path = new_cgroup_paths[i];\n\t\tinfo_ptr->cgroup_path_sub = new_cgroup_paths_sub[i];\n\t}\n\t/* don't use lxc_free_array since we used the array members\n\t * to store them in our result...\n\t */\n\tfree(new_cgroup_paths);\n\tfree(new_cgroup_paths_sub);\n\tfree(path_so_far);\n\tlxc_free_array((void **)cgroup_path_components, free);\n\treturn base_info;\n\nout_initial_error:\n\tsaved_errno = errno;\n\tfree(path_so_far);\n\tlxc_cgroup_process_info_free_and_remove(base_info, NULL);\n\tlxc_free_array((void **)new_cgroup_paths, free);\n\tlxc_free_array((void **)new_cgroup_paths_sub, free);\n\tlxc_free_array((void **)cgroup_path_components, free);\n\terrno = saved_errno;\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
            "static void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);",
            "static bool is_valid_cgroup(const char *name);",
            "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
            "static char *cgroup_to_absolute_path(struct cgroup_mount_point *mp, const char *path, const char *suffix);",
            "static struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);",
            "static int cgroup_recursive_task_count(const char *cgroup_path);",
            "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);",
            "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);",
            "static struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);",
            "static struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);\nstatic bool is_valid_cgroup(const char *name);\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic char *cgroup_to_absolute_path(struct cgroup_mount_point *mp, const char *path, const char *suffix);\nstatic struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\nstatic struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);\nstatic struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);\n\nstatic struct cgroup_process_info *lxc_cgroupfs_create(const char *name, const char *path_pattern, struct cgroup_meta_data *meta_data, const char *sub_pattern)\n{\n\tchar **cgroup_path_components = NULL;\n\tchar **p = NULL;\n\tchar *path_so_far = NULL;\n\tchar **new_cgroup_paths = NULL;\n\tchar **new_cgroup_paths_sub = NULL;\n\tstruct cgroup_mount_point *mp;\n\tstruct cgroup_hierarchy *h;\n\tstruct cgroup_process_info *base_info = NULL;\n\tstruct cgroup_process_info *info_ptr;\n\tint saved_errno;\n\tint r;\n\tunsigned suffix = 0;\n\tbool had_sub_pattern = false;\n\tsize_t i;\n\n\tif (!is_valid_cgroup(name)) {\n\t\tERROR(\"Invalid cgroup name: '%s'\", name);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (!strstr(path_pattern, \"%n\")) {\n\t\tERROR(\"Invalid cgroup path pattern: '%s'; contains no %%n for specifying container name\", path_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\t/* we will modify the result of this operation directly,\n\t * so we don't have to copy the data structure\n\t */\n\tbase_info = (path_pattern[0] == '/') ?\n\t\tlxc_cgroup_process_info_get_init(meta_data) :\n\t\tlxc_cgroup_process_info_get_self(meta_data);\n\tif (!base_info)\n\t\treturn NULL;\n\n\tnew_cgroup_paths = calloc(meta_data->maximum_hierarchy + 1, sizeof(char *));\n\tif (!new_cgroup_paths)\n\t\tgoto out_initial_error;\n\n\tnew_cgroup_paths_sub = calloc(meta_data->maximum_hierarchy + 1, sizeof(char *));\n\tif (!new_cgroup_paths_sub)\n\t\tgoto out_initial_error;\n\n\t/* find mount points we can use */\n\tfor (info_ptr = base_info; info_ptr; info_ptr = info_ptr->next) {\n\t\th = info_ptr->hierarchy;\n\t\tif (!h)\n\t\t\tcontinue;\n\t\tmp = lxc_cgroup_find_mount_point(h, info_ptr->cgroup_path, true);\n\t\tif (!mp) {\n\t\t\tERROR(\"Could not find writable mount point for cgroup hierarchy %d while trying to create cgroup.\", h->index);\n\t\t\tgoto out_initial_error;\n\t\t}\n\t\tinfo_ptr->designated_mount_point = mp;\n\n\t\tif (lxc_string_in_array(\"ns\", (const char **)h->subsystems))\n\t\t\tcontinue;\n\t\tif (handle_cgroup_settings(mp, info_ptr->cgroup_path) < 0) {\n\t\t\tERROR(\"Could not set clone_children to 1 for cpuset hierarchy in parent cgroup.\");\n\t\t\tgoto out_initial_error;\n\t\t}\n\t}\n\n\t/* normalize the path */\n\tcgroup_path_components = lxc_normalize_path(path_pattern);\n\tif (!cgroup_path_components)\n\t\tgoto out_initial_error;\n\n\t/* go through the path components to see if we can create them */\n\tfor (p = cgroup_path_components; *p || (sub_pattern && !had_sub_pattern); p++) {\n\t\t/* we only want to create the same component with -1, -2, etc.\n\t\t * if the component contains the container name itself, otherwise\n\t\t * it's not an error if it already exists\n\t\t */\n\t\tchar *p_eff = *p ? *p : (char *)sub_pattern;\n\t\tbool contains_name = strstr(p_eff, \"%n\");\n\t\tchar *current_component = NULL;\n\t\tchar *current_subpath = NULL;\n\t\tchar *current_entire_path = NULL;\n\t\tchar *parts[3];\n\t\tsize_t j = 0;\n\t\ti = 0;\n\n\t\t/* if we are processing the subpattern, we want to make sure\n\t\t * loop is ended the next time around\n\t\t */\n\t\tif (!*p) {\n\t\t\thad_sub_pattern = true;\n\t\t\tp--;\n\t\t}\n\n\t\tgoto find_name_on_this_level;\n\n\tcleanup_name_on_this_level:\n\t\t/* This is reached if we found a name clash.\n\t\t * In that case, remove the cgroup from all previous hierarchies\n\t\t */\n\t\tfor (j = 0, info_ptr = base_info; j < i && info_ptr; info_ptr = info_ptr->next, j++) {\n\t\t\tif (info_ptr->created_paths_count < 1)\n\t\t\t\tcontinue;\n\t\t\tr = remove_cgroup(info_ptr->designated_mount_point, info_ptr->created_paths[info_ptr->created_paths_count - 1], false, NULL);\n\t\t\tif (r < 0)\n\t\t\t\tWARN(\"could not clean up cgroup we created when trying to create container\");\n\t\t\tfree(info_ptr->created_paths[info_ptr->created_paths_count - 1]);\n\t\t\tinfo_ptr->created_paths[--info_ptr->created_paths_count] = NULL;\n\t\t}\n\t\tif (current_component != current_subpath)\n\t\t\tfree(current_subpath);\n\t\tif (current_component != p_eff)\n\t\t\tfree(current_component);\n\t\tcurrent_component = current_subpath = NULL;\n\t\t/* try again with another suffix */\n\t\t++suffix;\n\n\tfind_name_on_this_level:\n\t\t/* determine name of the path component we should create */\n\t\tif (contains_name && suffix > 0) {\n\t\t\tchar *buf = calloc(strlen(name) + 32, 1);\n\t\t\tif (!buf)\n\t\t\t\tgoto out_initial_error;\n\t\t\tsnprintf(buf, strlen(name) + 32, \"%s-%u\", name, suffix);\n\t\t\tcurrent_component = lxc_string_replace(\"%n\", buf, p_eff);\n\t\t\tfree(buf);\n\t\t} else {\n\t\t\tcurrent_component = contains_name ? lxc_string_replace(\"%n\", name, p_eff) : p_eff;\n\t\t}\n\t\tparts[0] = path_so_far;\n\t\tparts[1] = current_component;\n\t\tparts[2] = NULL;\n\t\tcurrent_subpath = path_so_far ? lxc_string_join(\"/\", (const char **)parts, false) : current_component;\n\n\t\t/* Now go through each hierarchy and try to create the\n\t\t * corresponding cgroup\n\t\t */\n\t\tfor (i = 0, info_ptr = base_info; info_ptr; info_ptr = info_ptr->next, i++) {\n\t\t\tchar *parts2[3];\n\n\t\t\tif (!info_ptr->hierarchy)\n\t\t\t\tcontinue;\n\n\t\t\tif (lxc_string_in_array(\"ns\", (const char **)info_ptr->hierarchy->subsystems))\n\t\t\t\tcontinue;\n\t\t\tcurrent_entire_path = NULL;\n\n\t\t\tparts2[0] = !strcmp(info_ptr->cgroup_path, \"/\") ? \"\" : info_ptr->cgroup_path;\n\t\t\tparts2[1] = current_subpath;\n\t\t\tparts2[2] = NULL;\n\t\t\tcurrent_entire_path = lxc_string_join(\"/\", (const char **)parts2, false);\n\n\t\t\tif (!*p) {\n\t\t\t\t/* we are processing the subpath, so only update that one */\n\t\t\t\tfree(new_cgroup_paths_sub[i]);\n\t\t\t\tnew_cgroup_paths_sub[i] = strdup(current_entire_path);\n\t\t\t\tif (!new_cgroup_paths_sub[i])\n\t\t\t\t\tgoto cleanup_from_error;\n\t\t\t} else {\n\t\t\t\t/* remember which path was used on this controller */\n\t\t\t\tfree(new_cgroup_paths[i]);\n\t\t\t\tnew_cgroup_paths[i] = strdup(current_entire_path);\n\t\t\t\tif (!new_cgroup_paths[i])\n\t\t\t\t\tgoto cleanup_from_error;\n\t\t\t}\n\n\t\t\tr = create_cgroup(info_ptr->designated_mount_point, current_entire_path);\n\t\t\tif (r < 0 && errno == EEXIST && contains_name) {\n\t\t\t\t/* name clash => try new name with new suffix */\n\t\t\t\tfree(current_entire_path);\n\t\t\t\tcurrent_entire_path = NULL;\n\t\t\t\tgoto cleanup_name_on_this_level;\n\t\t\t} else if (r < 0 && errno != EEXIST) {\n\t\t\t\tif (is_crucial_hierarchy(info_ptr->hierarchy)) {\n\t\t\t\t\tSYSERROR(\"Could not create cgroup '%s' in '%s'.\", current_entire_path, info_ptr->designated_mount_point->mount_point);\n\t\t\t\t\tgoto cleanup_from_error;\n\t\t\t\t}\n\t\t\t\tgoto skip;\n\t\t\t} else if (r == 0) {\n\t\t\t\t/* successfully created */\n\t\t\t\tr = lxc_grow_array((void ***)&info_ptr->created_paths, &info_ptr->created_paths_capacity, info_ptr->created_paths_count + 1, 8);\n\t\t\t\tif (r < 0)\n\t\t\t\t\tgoto cleanup_from_error;\n\t\t\t\tif (!init_cpuset_if_needed(info_ptr->designated_mount_point, current_entire_path)) {\n\t\t\t\t\tERROR(\"Failed to initialize cpuset for '%s' in '%s'.\", current_entire_path, info_ptr->designated_mount_point->mount_point);\n\t\t\t\t\tgoto cleanup_from_error;\n\t\t\t\t}\n\t\t\t\tinfo_ptr->created_paths[info_ptr->created_paths_count++] = current_entire_path;\n\t\t\t} else {\n\t\t\t\t/* if we didn't create the cgroup, then we have to make sure that\n\t\t\t\t * further cgroups will be created properly\n\t\t\t\t */\n\t\t\t\tif (handle_cgroup_settings(info_ptr->designated_mount_point, info_ptr->cgroup_path) < 0) {\n\t\t\t\t\tERROR(\"Could not set clone_children to 1 for cpuset hierarchy in pre-existing cgroup.\");\n\t\t\t\t\tgoto cleanup_from_error;\n\t\t\t\t}\n\t\t\t\tif (!init_cpuset_if_needed(info_ptr->designated_mount_point, info_ptr->cgroup_path)) {\n\t\t\t\t\tERROR(\"Failed to initialize cpuset in pre-existing '%s'.\", info_ptr->cgroup_path);\n\t\t\t\t\tgoto cleanup_from_error;\n\t\t\t\t}\n\nskip:\n\t\t\t\t/* already existed but path component of pattern didn't contain '%n',\n\t\t\t\t * so this is not an error; but then we don't need current_entire_path\n\t\t\t\t * anymore...\n\t\t\t\t */\n\t\t\t\tfree(current_entire_path);\n\t\t\t\tcurrent_entire_path = NULL;\n\t\t\t}\n\t\t}\n\n\t\t/* save path so far */\n\t\tfree(path_so_far);\n\t\tpath_so_far = strdup(current_subpath);\n\t\tif (!path_so_far)\n\t\t\tgoto cleanup_from_error;\n\n\t\t/* cleanup */\n\t\tif (current_component != current_subpath)\n\t\t\tfree(current_subpath);\n\t\tif (current_component != p_eff)\n\t\t\tfree(current_component);\n\t\tcurrent_component = current_subpath = NULL;\n\t\tcontinue;\n\n\tcleanup_from_error:\n\t\t/* called if an error occurred in the loop, so we\n\t\t * do some additional cleanup here\n\t\t */\n\t\tsaved_errno = errno;\n\t\tif (current_component != current_subpath)\n\t\t\tfree(current_subpath);\n\t\tif (current_component != p_eff)\n\t\t\tfree(current_component);\n\t\tfree(current_entire_path);\n\t\terrno = saved_errno;\n\t\tgoto out_initial_error;\n\t}\n\n\t/* we're done, now update the paths */\n\tfor (i = 0, info_ptr = base_info; info_ptr; info_ptr = info_ptr->next, i++) {\n\t\tif (!info_ptr->hierarchy)\n\t\t\tcontinue;\n\t\t/* ignore legacy 'ns' subsystem here, lxc_cgroup_create_legacy\n\t\t * will take care of it\n\t\t * Since we do a continue in above loop, new_cgroup_paths[i] is\n\t\t * unset anyway, as is new_cgroup_paths_sub[i]\n\t\t */\n\t\tif (lxc_string_in_array(\"ns\", (const char **)info_ptr->hierarchy->subsystems))\n\t\t\tcontinue;\n\t\tfree(info_ptr->cgroup_path);\n\t\tinfo_ptr->cgroup_path = new_cgroup_paths[i];\n\t\tinfo_ptr->cgroup_path_sub = new_cgroup_paths_sub[i];\n\t}\n\t/* don't use lxc_free_array since we used the array members\n\t * to store them in our result...\n\t */\n\tfree(new_cgroup_paths);\n\tfree(new_cgroup_paths_sub);\n\tfree(path_so_far);\n\tlxc_free_array((void **)cgroup_path_components, free);\n\treturn base_info;\n\nout_initial_error:\n\tsaved_errno = errno;\n\tfree(path_so_far);\n\tlxc_cgroup_process_info_free_and_remove(base_info, NULL);\n\tlxc_free_array((void **)new_cgroup_paths, free);\n\tlxc_free_array((void **)new_cgroup_paths_sub, free);\n\tlxc_free_array((void **)cgroup_path_components, free);\n\terrno = saved_errno;\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_process_info *lxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str, struct cgroup_meta_data *meta);\nstatic bool is_valid_cgroup(const char *name);\nstatic void lxc_cgroup_process_info_free(struct cgroup_process_info *info);\n\nstatic inline bool cgfs_create(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tstruct cgroup_process_info *i;\n\tstruct cgroup_meta_data *md;\n\n\tif (!d)\n\t\treturn false;\n\tmd = d->meta;\n\ti = lxc_cgroupfs_create(d->name, d->cgroup_pattern, md, NULL);\n\tif (!i)\n\t\treturn false;\n\td->info = i;\n\treturn true;\n}"
  },
  {
    "function_name": "cgfs_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "2374-2384",
    "snippet": "static void cgfs_destroy(void *hdata, struct lxc_conf *conf)\n{\n\tstruct cgfs_data *d = hdata;\n\n\tif (!d)\n\t\treturn;\n\tfree(d->name);\n\tlxc_cgroup_process_info_free_and_remove(d->info, conf);\n\tlxc_cgroup_put_meta(d->meta);\n\tfree(d);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cgroup_process_info *lxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str, struct cgroup_meta_data *meta);",
      "static bool is_valid_cgroup(const char *name);",
      "static int remove_cgroup(struct cgroup_mount_point *mp, const char *path, bool recurse,\n\t\t\t\tstruct lxc_conf *conf);",
      "static void lxc_cgroup_process_info_free(struct cgroup_process_info *info);",
      "static void lxc_cgroup_process_info_free_and_remove(struct cgroup_process_info *info,\n\t\t\t\tstruct lxc_conf *conf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "d"
          ],
          "line": 2383
        },
        "resolved": true,
        "details": {
          "function_name": "cgfs_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2501-2518",
          "snippet": "static bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_put_meta",
          "args": [
            "d->meta"
          ],
          "line": 2382
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_put_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "635-650",
          "snippet": "static struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data)\n{\n\tsize_t i;\n\tif (!meta_data)\n\t\treturn NULL;\n\tif (--meta_data->ref > 0)\n\t\treturn meta_data;\n\tlxc_free_array((void **)meta_data->mount_points, (lxc_free_fn)lxc_cgroup_mount_point_free);\n\tif (meta_data->hierarchies)\n\t\tfor (i = 0; i <= meta_data->maximum_hierarchy; i++)\n\t\t\tif (meta_data->hierarchies[i])\n\t\t\t\tlxc_cgroup_hierarchy_free(meta_data->hierarchies[i]);\n\tfree(meta_data->hierarchies);\n\tfree(meta_data);\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);",
            "static struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);\nstatic struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);\n\nstatic struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data)\n{\n\tsize_t i;\n\tif (!meta_data)\n\t\treturn NULL;\n\tif (--meta_data->ref > 0)\n\t\treturn meta_data;\n\tlxc_free_array((void **)meta_data->mount_points, (lxc_free_fn)lxc_cgroup_mount_point_free);\n\tif (meta_data->hierarchies)\n\t\tfor (i = 0; i <= meta_data->maximum_hierarchy; i++)\n\t\t\tif (meta_data->hierarchies[i])\n\t\t\t\tlxc_cgroup_hierarchy_free(meta_data->hierarchies[i]);\n\tfree(meta_data->hierarchies);\n\tfree(meta_data);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_process_info_free_and_remove",
          "args": [
            "d->info",
            "conf"
          ],
          "line": 2381
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_process_info_free_and_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1263-1291",
          "snippet": "void lxc_cgroup_process_info_free_and_remove(struct cgroup_process_info *info, struct lxc_conf *conf)\n{\n\tstruct cgroup_process_info *next;\n\tchar **pp;\n\tif (!info)\n\t\treturn;\n\tnext = info->next;\n\t{\n\t\tstruct cgroup_mount_point *mp = info->designated_mount_point;\n\t\tif (!mp)\n\t\t\tmp = lxc_cgroup_find_mount_point(info->hierarchy, info->cgroup_path, true);\n\t\tif (mp)\n\t\t\t/* ignore return value here, perhaps we created the\n\t\t\t * '/lxc' cgroup in this container but another container\n\t\t\t * is still running (for example)\n\t\t\t */\n\t\t\t(void)remove_cgroup(mp, info->cgroup_path, true, conf);\n\t}\n\tfor (pp = info->created_paths; pp && *pp; pp++);\n\tfor ((void)(pp && --pp); info->created_paths && pp >= info->created_paths; --pp) {\n\t\tfree(*pp);\n\t}\n\tfree(info->created_paths);\n\tlxc_cgroup_put_meta(info->meta_ref);\n\tfree(info->cgroup_path);\n\tfree(info->cgroup_path_sub);\n\tfree(info);\n\tlxc_cgroup_process_info_free_and_remove(next, conf);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
            "static int remove_cgroup(struct cgroup_mount_point *mp, const char *path, bool recurse,\n\t\t\t\tstruct lxc_conf *conf);",
            "static int do_cgroup_set(const char *cgroup_path, const char *sub_filename, const char *value);",
            "static int cgroup_recursive_task_count(const char *cgroup_path);",
            "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);",
            "static void lxc_cgroup_process_info_free(struct cgroup_process_info *info);",
            "static void lxc_cgroup_process_info_free_and_remove(struct cgroup_process_info *info,\n\t\t\t\tstruct lxc_conf *conf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic int remove_cgroup(struct cgroup_mount_point *mp, const char *path, bool recurse,\n\t\t\t\tstruct lxc_conf *conf);\nstatic int do_cgroup_set(const char *cgroup_path, const char *sub_filename, const char *value);\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\nstatic void lxc_cgroup_process_info_free(struct cgroup_process_info *info);\nstatic void lxc_cgroup_process_info_free_and_remove(struct cgroup_process_info *info,\n\t\t\t\tstruct lxc_conf *conf);\n\nvoid lxc_cgroup_process_info_free_and_remove(struct cgroup_process_info *info, struct lxc_conf *conf)\n{\n\tstruct cgroup_process_info *next;\n\tchar **pp;\n\tif (!info)\n\t\treturn;\n\tnext = info->next;\n\t{\n\t\tstruct cgroup_mount_point *mp = info->designated_mount_point;\n\t\tif (!mp)\n\t\t\tmp = lxc_cgroup_find_mount_point(info->hierarchy, info->cgroup_path, true);\n\t\tif (mp)\n\t\t\t/* ignore return value here, perhaps we created the\n\t\t\t * '/lxc' cgroup in this container but another container\n\t\t\t * is still running (for example)\n\t\t\t */\n\t\t\t(void)remove_cgroup(mp, info->cgroup_path, true, conf);\n\t}\n\tfor (pp = info->created_paths; pp && *pp; pp++);\n\tfor ((void)(pp && --pp); info->created_paths && pp >= info->created_paths; --pp) {\n\t\tfree(*pp);\n\t}\n\tfree(info->created_paths);\n\tlxc_cgroup_put_meta(info->meta_ref);\n\tfree(info->cgroup_path);\n\tfree(info->cgroup_path_sub);\n\tfree(info);\n\tlxc_cgroup_process_info_free_and_remove(next, conf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_process_info *lxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str, struct cgroup_meta_data *meta);\nstatic bool is_valid_cgroup(const char *name);\nstatic int remove_cgroup(struct cgroup_mount_point *mp, const char *path, bool recurse,\n\t\t\t\tstruct lxc_conf *conf);\nstatic void lxc_cgroup_process_info_free(struct cgroup_process_info *info);\nstatic void lxc_cgroup_process_info_free_and_remove(struct cgroup_process_info *info,\n\t\t\t\tstruct lxc_conf *conf);\n\nstatic void cgfs_destroy(void *hdata, struct lxc_conf *conf)\n{\n\tstruct cgfs_data *d = hdata;\n\n\tif (!d)\n\t\treturn;\n\tfree(d->name);\n\tlxc_cgroup_process_info_free_and_remove(d->info, conf);\n\tlxc_cgroup_put_meta(d->meta);\n\tfree(d);\n}"
  },
  {
    "function_name": "cgfs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "2342-2372",
    "snippet": "static void *cgfs_init(const char *name)\n{\n\tstruct cgfs_data *d;\n\n\td = malloc(sizeof(*d));\n\tif (!d)\n\t\treturn NULL;\n\n\tmemset(d, 0, sizeof(*d));\n\td->name = strdup(name);\n\tif (!d->name)\n\t\tgoto err1;\n\n\td->cgroup_pattern = lxc_global_config_value(\"lxc.cgroup.pattern\");\n\n\td->meta = lxc_cgroup_load_meta();\n\tif (!d->meta) {\n\t\tERROR(\"cgroupfs failed to detect cgroup metadata\");\n\t\tgoto err2;\n\t}\n\n\tprint_cgfs_init_debuginfo(d);\n\n\treturn d;\n\nerr2:\n\tfree(d->name);\nerr1:\n\tfree(d);\n\treturn NULL;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cgroup_process_info *lxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str, struct cgroup_meta_data *meta);",
      "static bool is_valid_cgroup(const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "d"
          ],
          "line": 2370
        },
        "resolved": true,
        "details": {
          "function_name": "cgfs_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2501-2518",
          "snippet": "static bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_cgfs_init_debuginfo",
          "args": [
            "d"
          ],
          "line": 2363
        },
        "resolved": true,
        "details": {
          "function_name": "print_cgfs_init_debuginfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2310-2335",
          "snippet": "static void print_cgfs_init_debuginfo(struct cgfs_data *d)\n{\n\tint i;\n\n\tif (!getenv(\"LXC_DEBUG_CGFS\"))\n\t\treturn;\n\n\tDEBUG(\"Cgroup information:\");\n\tDEBUG(\"  container name: %s\", d->name);\n\tif (!d->meta || !d->meta->hierarchies) {\n\t\tDEBUG(\"  No hierarchies found.\");\n\t\treturn;\n\t}\n\tDEBUG(\"  Controllers:\");\n\tfor (i = 0; i <= d->meta->maximum_hierarchy; i++) {\n\t\tchar **p;\n\t\tstruct cgroup_hierarchy *h = d->meta->hierarchies[i];\n\t\tif (!h) {\n\t\t\tDEBUG(\"     Empty hierarchy number %d.\", i);\n\t\t\tcontinue;\n\t\t}\n\t\tfor (p = h->subsystems; p && *p; p++) {\n\t\t\tDEBUG(\"     %2d: %s\", i, *p);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_process_info *lxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str, struct cgroup_meta_data *meta);",
            "static void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);",
            "static bool is_valid_cgroup(const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_process_info *lxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str, struct cgroup_meta_data *meta);\nstatic void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);\nstatic bool is_valid_cgroup(const char *name);\n\nstatic void print_cgfs_init_debuginfo(struct cgfs_data *d)\n{\n\tint i;\n\n\tif (!getenv(\"LXC_DEBUG_CGFS\"))\n\t\treturn;\n\n\tDEBUG(\"Cgroup information:\");\n\tDEBUG(\"  container name: %s\", d->name);\n\tif (!d->meta || !d->meta->hierarchies) {\n\t\tDEBUG(\"  No hierarchies found.\");\n\t\treturn;\n\t}\n\tDEBUG(\"  Controllers:\");\n\tfor (i = 0; i <= d->meta->maximum_hierarchy; i++) {\n\t\tchar **p;\n\t\tstruct cgroup_hierarchy *h = d->meta->hierarchies[i];\n\t\tif (!h) {\n\t\t\tDEBUG(\"     Empty hierarchy number %d.\", i);\n\t\t\tcontinue;\n\t\t}\n\t\tfor (p = h->subsystems; p && *p; p++) {\n\t\t\tDEBUG(\"     %2d: %s\", i, *p);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"cgroupfs failed to detect cgroup metadata\""
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_load_meta",
          "args": [],
          "line": 2357
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_load_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "241-263",
          "snippet": "static struct cgroup_meta_data *lxc_cgroup_load_meta()\n{\n\tconst char *cgroup_use = NULL;\n\tchar **cgroup_use_list = NULL;\n\tstruct cgroup_meta_data *md = NULL;\n\tint saved_errno;\n\n\terrno = 0;\n\tcgroup_use = lxc_global_config_value(\"lxc.cgroup.use\");\n\tif (!cgroup_use && errno != 0)\n\t\treturn NULL;\n\tif (cgroup_use) {\n\t\tcgroup_use_list = lxc_string_split_and_trim(cgroup_use, ',');\n\t\tif (!cgroup_use_list)\n\t\t\treturn NULL;\n\t}\n\n\tmd = lxc_cgroup_load_meta2((const char **)cgroup_use_list);\n\tsaved_errno = errno;\n\tlxc_free_array((void **)cgroup_use_list, free);\n\terrno = saved_errno;\n\treturn md;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_meta_data *lxc_cgroup_load_meta()\n{\n\tconst char *cgroup_use = NULL;\n\tchar **cgroup_use_list = NULL;\n\tstruct cgroup_meta_data *md = NULL;\n\tint saved_errno;\n\n\terrno = 0;\n\tcgroup_use = lxc_global_config_value(\"lxc.cgroup.use\");\n\tif (!cgroup_use && errno != 0)\n\t\treturn NULL;\n\tif (cgroup_use) {\n\t\tcgroup_use_list = lxc_string_split_and_trim(cgroup_use, ',');\n\t\tif (!cgroup_use_list)\n\t\t\treturn NULL;\n\t}\n\n\tmd = lxc_cgroup_load_meta2((const char **)cgroup_use_list);\n\tsaved_errno = errno;\n\tlxc_free_array((void **)cgroup_use_list, free);\n\terrno = saved_errno;\n\treturn md;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_global_config_value",
          "args": [
            "\"lxc.cgroup.pattern\""
          ],
          "line": 2355
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_global_config_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "88-247",
          "snippet": "const char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nconst char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "name"
          ],
          "line": 2351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "d",
            "0",
            "sizeof(*d)"
          ],
          "line": 2350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*d)"
          ],
          "line": 2346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_process_info *lxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str, struct cgroup_meta_data *meta);\nstatic bool is_valid_cgroup(const char *name);\n\nstatic void *cgfs_init(const char *name)\n{\n\tstruct cgfs_data *d;\n\n\td = malloc(sizeof(*d));\n\tif (!d)\n\t\treturn NULL;\n\n\tmemset(d, 0, sizeof(*d));\n\td->name = strdup(name);\n\tif (!d->name)\n\t\tgoto err1;\n\n\td->cgroup_pattern = lxc_global_config_value(\"lxc.cgroup.pattern\");\n\n\td->meta = lxc_cgroup_load_meta();\n\tif (!d->meta) {\n\t\tERROR(\"cgroupfs failed to detect cgroup metadata\");\n\t\tgoto err2;\n\t}\n\n\tprint_cgfs_init_debuginfo(d);\n\n\treturn d;\n\nerr2:\n\tfree(d->name);\nerr1:\n\tfree(d);\n\treturn NULL;\n}"
  },
  {
    "function_name": "cgfs_ops_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "2337-2340",
    "snippet": "struct cgroup_ops *cgfs_ops_init(void)\n{\n\treturn &cgfs_ops;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cgroup_ops cgfs_ops;",
      "static struct cgroup_ops cgfs_ops = {\n\t.init = cgfs_init,\n\t.destroy = cgfs_destroy,\n\t.create = cgfs_create,\n\t.enter = cgfs_enter,\n\t.create_legacy = cgfs_create_legacy,\n\t.get_cgroup = cgfs_get_cgroup,\n\t.escape = cgfs_escape,\n\t.num_hierarchies = cgfs_num_hierarchies,\n\t.get_hierarchies = cgfs_get_hierarchies,\n\t.get = lxc_cgroupfs_get,\n\t.set = lxc_cgroupfs_set,\n\t.unfreeze = cgfs_unfreeze,\n\t.setup_limits = cgroupfs_setup_limits,\n\t.name = \"cgroupfs\",\n\t.attach = lxc_cgroupfs_attach,\n\t.chown = cgfs_chown,\n\t.mount_cgroup = cgroupfs_mount_cgroup,\n\t.nrtasks = cgfs_nrtasks,\n\t.driver = CGFS,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_ops cgfs_ops;\nstatic struct cgroup_ops cgfs_ops = {\n\t.init = cgfs_init,\n\t.destroy = cgfs_destroy,\n\t.create = cgfs_create,\n\t.enter = cgfs_enter,\n\t.create_legacy = cgfs_create_legacy,\n\t.get_cgroup = cgfs_get_cgroup,\n\t.escape = cgfs_escape,\n\t.num_hierarchies = cgfs_num_hierarchies,\n\t.get_hierarchies = cgfs_get_hierarchies,\n\t.get = lxc_cgroupfs_get,\n\t.set = lxc_cgroupfs_set,\n\t.unfreeze = cgfs_unfreeze,\n\t.setup_limits = cgroupfs_setup_limits,\n\t.name = \"cgroupfs\",\n\t.attach = lxc_cgroupfs_attach,\n\t.chown = cgfs_chown,\n\t.mount_cgroup = cgroupfs_mount_cgroup,\n\t.nrtasks = cgfs_nrtasks,\n\t.driver = CGFS,\n};\n\nstruct cgroup_ops *cgfs_ops_init(void)\n{\n\treturn &cgfs_ops;\n}"
  },
  {
    "function_name": "print_cgfs_init_debuginfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "2310-2335",
    "snippet": "static void print_cgfs_init_debuginfo(struct cgfs_data *d)\n{\n\tint i;\n\n\tif (!getenv(\"LXC_DEBUG_CGFS\"))\n\t\treturn;\n\n\tDEBUG(\"Cgroup information:\");\n\tDEBUG(\"  container name: %s\", d->name);\n\tif (!d->meta || !d->meta->hierarchies) {\n\t\tDEBUG(\"  No hierarchies found.\");\n\t\treturn;\n\t}\n\tDEBUG(\"  Controllers:\");\n\tfor (i = 0; i <= d->meta->maximum_hierarchy; i++) {\n\t\tchar **p;\n\t\tstruct cgroup_hierarchy *h = d->meta->hierarchies[i];\n\t\tif (!h) {\n\t\t\tDEBUG(\"     Empty hierarchy number %d.\", i);\n\t\t\tcontinue;\n\t\t}\n\t\tfor (p = h->subsystems; p && *p; p++) {\n\t\t\tDEBUG(\"     %2d: %s\", i, *p);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cgroup_process_info *lxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str, struct cgroup_meta_data *meta);",
      "static void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);",
      "static bool is_valid_cgroup(const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"     %2d: %s\"",
            "i",
            "*p"
          ],
          "line": 2332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"     Empty hierarchy number %d.\"",
            "i"
          ],
          "line": 2328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"  Controllers:\""
          ],
          "line": 2323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"  No hierarchies found.\""
          ],
          "line": 2320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"  container name: %s\"",
            "d->name"
          ],
          "line": 2318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Cgroup information:\""
          ],
          "line": 2317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"LXC_DEBUG_CGFS\""
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_process_info *lxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str, struct cgroup_meta_data *meta);\nstatic void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);\nstatic bool is_valid_cgroup(const char *name);\n\nstatic void print_cgfs_init_debuginfo(struct cgfs_data *d)\n{\n\tint i;\n\n\tif (!getenv(\"LXC_DEBUG_CGFS\"))\n\t\treturn;\n\n\tDEBUG(\"Cgroup information:\");\n\tDEBUG(\"  container name: %s\", d->name);\n\tif (!d->meta || !d->meta->hierarchies) {\n\t\tDEBUG(\"  No hierarchies found.\");\n\t\treturn;\n\t}\n\tDEBUG(\"  Controllers:\");\n\tfor (i = 0; i <= d->meta->maximum_hierarchy; i++) {\n\t\tchar **p;\n\t\tstruct cgroup_hierarchy *h = d->meta->hierarchies[i];\n\t\tif (!h) {\n\t\t\tDEBUG(\"     Empty hierarchy number %d.\", i);\n\t\t\tcontinue;\n\t\t}\n\t\tfor (p = h->subsystems; p && *p; p++) {\n\t\t\tDEBUG(\"     %2d: %s\", i, *p);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "init_cpuset_if_needed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "2295-2308",
    "snippet": "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp,\n\t\t\t\t  const char *path)\n{\n\t/* the files we have to handle here are only in cpuset hierarchies */\n\tif (!lxc_string_in_array(\"cpuset\",\n\t\t\t\t (const char **)mp->hierarchy->subsystems))\n\t\treturn true;\n\n\tif (!mp->need_cpuset_init)\n\t\treturn true;\n\n\treturn (do_init_cpuset_file(mp, path, \"/cpuset.cpus\") &&\n\t\tdo_init_cpuset_file(mp, path, \"/cpuset.mems\") );\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
      "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
      "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_init_cpuset_file",
          "args": [
            "mp",
            "path",
            "\"/cpuset.mems\""
          ],
          "line": 2307
        },
        "resolved": true,
        "details": {
          "function_name": "do_init_cpuset_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2238-2293",
          "snippet": "static bool do_init_cpuset_file(struct cgroup_mount_point *mp,\n\t\t\t\tconst char *path, const char *name)\n{\n\tchar value[1024];\n\tchar *childfile, *parentfile = NULL, *tmp;\n\tint ret;\n\tbool ok = false;\n\n\tchildfile = cgroup_to_absolute_path(mp, path, name);\n\tif (!childfile)\n\t\treturn false;\n\n\t/* don't overwrite a non-empty value in the file */\n\tret = cgroup_read_from_file(childfile, value, sizeof(value));\n\tif (ret < 0)\n\t\tgoto out;\n\tif (value[0] != '\\0' && value[0] != '\\n') {\n\t\tok = true;\n\t\tgoto out;\n\t}\n\n\t/* path to the same name in the parent cgroup */\n\tparentfile = strdup(path);\n\tif (!parentfile)\n\t\tgoto out;\n\n\ttmp = strrchr(parentfile, '/');\n\tif (!tmp)\n\t\tgoto out;\n\tif (tmp == parentfile)\n\t\ttmp++; /* keep the '/' at the start */\n\t*tmp = '\\0';\n\ttmp = parentfile;\n\tparentfile = cgroup_to_absolute_path(mp, tmp, name);\n\tfree(tmp);\n\tif (!parentfile)\n\t\tgoto out;\n\n\t/* copy from parent to child cgroup */\n\tret = cgroup_read_from_file(parentfile, value, sizeof(value));\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret == sizeof(value)) {\n\t\t/* If anyone actually sees this error, we can address it */\n\t\tERROR(\"parent cpuset value too long\");\n\t\tgoto out;\n\t}\n\tok = (lxc_write_to_file(childfile, value, strlen(value), false) >= 0);\n\tif (!ok)\n\t\tSYSERROR(\"failed writing %s\", childfile);\n\nout:\n\tfree(parentfile);\n\tfree(childfile);\n\treturn ok;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
            "static bool is_valid_cgroup(const char *name);",
            "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
            "static int do_cgroup_set(const char *cgroup_path, const char *sub_filename, const char *value);",
            "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic bool is_valid_cgroup(const char *name);\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic int do_cgroup_set(const char *cgroup_path, const char *sub_filename, const char *value);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\n\nstatic bool do_init_cpuset_file(struct cgroup_mount_point *mp,\n\t\t\t\tconst char *path, const char *name)\n{\n\tchar value[1024];\n\tchar *childfile, *parentfile = NULL, *tmp;\n\tint ret;\n\tbool ok = false;\n\n\tchildfile = cgroup_to_absolute_path(mp, path, name);\n\tif (!childfile)\n\t\treturn false;\n\n\t/* don't overwrite a non-empty value in the file */\n\tret = cgroup_read_from_file(childfile, value, sizeof(value));\n\tif (ret < 0)\n\t\tgoto out;\n\tif (value[0] != '\\0' && value[0] != '\\n') {\n\t\tok = true;\n\t\tgoto out;\n\t}\n\n\t/* path to the same name in the parent cgroup */\n\tparentfile = strdup(path);\n\tif (!parentfile)\n\t\tgoto out;\n\n\ttmp = strrchr(parentfile, '/');\n\tif (!tmp)\n\t\tgoto out;\n\tif (tmp == parentfile)\n\t\ttmp++; /* keep the '/' at the start */\n\t*tmp = '\\0';\n\ttmp = parentfile;\n\tparentfile = cgroup_to_absolute_path(mp, tmp, name);\n\tfree(tmp);\n\tif (!parentfile)\n\t\tgoto out;\n\n\t/* copy from parent to child cgroup */\n\tret = cgroup_read_from_file(parentfile, value, sizeof(value));\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret == sizeof(value)) {\n\t\t/* If anyone actually sees this error, we can address it */\n\t\tERROR(\"parent cpuset value too long\");\n\t\tgoto out;\n\t}\n\tok = (lxc_write_to_file(childfile, value, strlen(value), false) >= 0);\n\tif (!ok)\n\t\tSYSERROR(\"failed writing %s\", childfile);\n\nout:\n\tfree(parentfile);\n\tfree(childfile);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_string_in_array",
          "args": [
            "\"cpuset\"",
            "(const char **)mp->hierarchy->subsystems"
          ],
          "line": 2299
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_in_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "656-662",
          "snippet": "bool lxc_string_in_array(const char *needle, const char **haystack)\n{\n\tfor (; haystack && *haystack; haystack++)\n\t\tif (!strcmp(needle, *haystack))\n\t\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool lxc_string_in_array(const char *needle, const char **haystack)\n{\n\tfor (; haystack && *haystack; haystack++)\n\t\tif (!strcmp(needle, *haystack))\n\t\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\n\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp,\n\t\t\t\t  const char *path)\n{\n\t/* the files we have to handle here are only in cpuset hierarchies */\n\tif (!lxc_string_in_array(\"cpuset\",\n\t\t\t\t (const char **)mp->hierarchy->subsystems))\n\t\treturn true;\n\n\tif (!mp->need_cpuset_init)\n\t\treturn true;\n\n\treturn (do_init_cpuset_file(mp, path, \"/cpuset.cpus\") &&\n\t\tdo_init_cpuset_file(mp, path, \"/cpuset.mems\") );\n}"
  },
  {
    "function_name": "do_init_cpuset_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "2238-2293",
    "snippet": "static bool do_init_cpuset_file(struct cgroup_mount_point *mp,\n\t\t\t\tconst char *path, const char *name)\n{\n\tchar value[1024];\n\tchar *childfile, *parentfile = NULL, *tmp;\n\tint ret;\n\tbool ok = false;\n\n\tchildfile = cgroup_to_absolute_path(mp, path, name);\n\tif (!childfile)\n\t\treturn false;\n\n\t/* don't overwrite a non-empty value in the file */\n\tret = cgroup_read_from_file(childfile, value, sizeof(value));\n\tif (ret < 0)\n\t\tgoto out;\n\tif (value[0] != '\\0' && value[0] != '\\n') {\n\t\tok = true;\n\t\tgoto out;\n\t}\n\n\t/* path to the same name in the parent cgroup */\n\tparentfile = strdup(path);\n\tif (!parentfile)\n\t\tgoto out;\n\n\ttmp = strrchr(parentfile, '/');\n\tif (!tmp)\n\t\tgoto out;\n\tif (tmp == parentfile)\n\t\ttmp++; /* keep the '/' at the start */\n\t*tmp = '\\0';\n\ttmp = parentfile;\n\tparentfile = cgroup_to_absolute_path(mp, tmp, name);\n\tfree(tmp);\n\tif (!parentfile)\n\t\tgoto out;\n\n\t/* copy from parent to child cgroup */\n\tret = cgroup_read_from_file(parentfile, value, sizeof(value));\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret == sizeof(value)) {\n\t\t/* If anyone actually sees this error, we can address it */\n\t\tERROR(\"parent cpuset value too long\");\n\t\tgoto out;\n\t}\n\tok = (lxc_write_to_file(childfile, value, strlen(value), false) >= 0);\n\tif (!ok)\n\t\tSYSERROR(\"failed writing %s\", childfile);\n\nout:\n\tfree(parentfile);\n\tfree(childfile);\n\treturn ok;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
      "static bool is_valid_cgroup(const char *name);",
      "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
      "static int do_cgroup_set(const char *cgroup_path, const char *sub_filename, const char *value);",
      "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "childfile"
          ],
          "line": 2291
        },
        "resolved": true,
        "details": {
          "function_name": "cgfs_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2501-2518",
          "snippet": "static bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed writing %s\"",
            "childfile"
          ],
          "line": 2287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_write_to_file",
          "args": [
            "childfile",
            "value",
            "strlen(value)",
            "false"
          ],
          "line": 2285
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_to_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "934-960",
          "snippet": "int lxc_write_to_file(const char *filename, const void* buf, size_t count, bool add_newline)\n{\n\tint fd, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_WRONLY | O_TRUNC | O_CREAT | O_CLOEXEC, 0666);\n\tif (fd < 0)\n\t\treturn -1;\n\tret = lxc_write_nointr(fd, buf, count);\n\tif (ret < 0)\n\t\tgoto out_error;\n\tif ((size_t)ret != count)\n\t\tgoto out_error;\n\tif (add_newline) {\n\t\tret = lxc_write_nointr(fd, \"\\n\", 1);\n\t\tif (ret != 1)\n\t\t\tgoto out_error;\n\t}\n\tclose(fd);\n\treturn 0;\n\nout_error:\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn -1;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_write_to_file(const char *filename, const void* buf, size_t count, bool add_newline)\n{\n\tint fd, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_WRONLY | O_TRUNC | O_CREAT | O_CLOEXEC, 0666);\n\tif (fd < 0)\n\t\treturn -1;\n\tret = lxc_write_nointr(fd, buf, count);\n\tif (ret < 0)\n\t\tgoto out_error;\n\tif ((size_t)ret != count)\n\t\tgoto out_error;\n\tif (add_newline) {\n\t\tret = lxc_write_nointr(fd, \"\\n\", 1);\n\t\tif (ret != 1)\n\t\t\tgoto out_error;\n\t}\n\tclose(fd);\n\treturn 0;\n\nout_error:\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "value"
          ],
          "line": 2285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"parent cpuset value too long\""
          ],
          "line": 2282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_read_from_file",
          "args": [
            "parentfile",
            "value",
            "sizeof(value)"
          ],
          "line": 2277
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_read_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2217-2236",
          "snippet": "static int cgroup_read_from_file(const char *fn, char buf[], size_t bufsize)\n{\n\tint ret = lxc_read_from_file(fn, buf, bufsize);\n\tif (ret < 0) {\n\t\tSYSERROR(\"failed to read %s\", fn);\n\t\treturn ret;\n\t}\n\tif (ret == bufsize) {\n\t\tif (bufsize > 0) {\n\t\t\t/* obviously this wasn't empty */\n\t\t\tbuf[bufsize-1] = '\\0';\n\t\t\treturn ret;\n\t\t}\n\t\t/* Callers don't do this, but regression/sanity check */\n\t\tERROR(\"%s: was not expecting 0 bufsize\", __func__);\n\t\treturn -1;\n\t}\n\tbuf[ret] = '\\0';\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int cgroup_read_from_file(const char *fn, char buf[], size_t bufsize)\n{\n\tint ret = lxc_read_from_file(fn, buf, bufsize);\n\tif (ret < 0) {\n\t\tSYSERROR(\"failed to read %s\", fn);\n\t\treturn ret;\n\t}\n\tif (ret == bufsize) {\n\t\tif (bufsize > 0) {\n\t\t\t/* obviously this wasn't empty */\n\t\t\tbuf[bufsize-1] = '\\0';\n\t\t\treturn ret;\n\t\t}\n\t\t/* Callers don't do this, but regression/sanity check */\n\t\tERROR(\"%s: was not expecting 0 bufsize\", __func__);\n\t\treturn -1;\n\t}\n\tbuf[ret] = '\\0';\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_to_absolute_path",
          "args": [
            "mp",
            "tmp",
            "name"
          ],
          "line": 2271
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_to_absolute_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1901-1944",
          "snippet": "static char *cgroup_to_absolute_path(struct cgroup_mount_point *mp,\n\t\t\t\t     const char *path, const char *suffix)\n{\n\t/* first we have to make sure we subtract the mount point's prefix */\n\tchar *prefix = mp->mount_prefix;\n\tchar *buf;\n\tssize_t len, rv;\n\n\t/* we want to make sure only absolute paths to cgroups are passed to us */\n\tif (path[0] != '/') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (prefix && !strcmp(prefix, \"/\"))\n\t\tprefix = NULL;\n\n\t/* prefix doesn't match */\n\tif (prefix && strncmp(prefix, path, strlen(prefix)) != 0) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\t/* if prefix is /foo and path is /foobar */\n\tif (prefix && path[strlen(prefix)] != '/' && path[strlen(prefix)] != '\\0') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\t/* remove prefix from path */\n\tpath += prefix ? strlen(prefix) : 0;\n\n\tlen = strlen(mp->mount_point) + strlen(path) + (suffix ? strlen(suffix) : 0);\n\tbuf = calloc(len + 1, 1);\n\tif (!buf)\n\t\treturn NULL;\n\trv = snprintf(buf, len + 1, \"%s%s%s\", mp->mount_point, path, suffix ? suffix : \"\");\n\tif (rv > len) {\n\t\tfree(buf);\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\treturn buf;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
            "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
            "static char *cgroup_to_absolute_path(struct cgroup_mount_point *mp, const char *path, const char *suffix);",
            "static int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);",
            "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic char *cgroup_to_absolute_path(struct cgroup_mount_point *mp, const char *path, const char *suffix);\nstatic int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\n\nstatic char *cgroup_to_absolute_path(struct cgroup_mount_point *mp,\n\t\t\t\t     const char *path, const char *suffix)\n{\n\t/* first we have to make sure we subtract the mount point's prefix */\n\tchar *prefix = mp->mount_prefix;\n\tchar *buf;\n\tssize_t len, rv;\n\n\t/* we want to make sure only absolute paths to cgroups are passed to us */\n\tif (path[0] != '/') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (prefix && !strcmp(prefix, \"/\"))\n\t\tprefix = NULL;\n\n\t/* prefix doesn't match */\n\tif (prefix && strncmp(prefix, path, strlen(prefix)) != 0) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\t/* if prefix is /foo and path is /foobar */\n\tif (prefix && path[strlen(prefix)] != '/' && path[strlen(prefix)] != '\\0') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\t/* remove prefix from path */\n\tpath += prefix ? strlen(prefix) : 0;\n\n\tlen = strlen(mp->mount_point) + strlen(path) + (suffix ? strlen(suffix) : 0);\n\tbuf = calloc(len + 1, 1);\n\tif (!buf)\n\t\treturn NULL;\n\trv = snprintf(buf, len + 1, \"%s%s%s\", mp->mount_point, path, suffix ? suffix : \"\");\n\tif (rv > len) {\n\t\tfree(buf);\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "parentfile",
            "'/'"
          ],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "path"
          ],
          "line": 2260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic bool is_valid_cgroup(const char *name);\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic int do_cgroup_set(const char *cgroup_path, const char *sub_filename, const char *value);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\n\nstatic bool do_init_cpuset_file(struct cgroup_mount_point *mp,\n\t\t\t\tconst char *path, const char *name)\n{\n\tchar value[1024];\n\tchar *childfile, *parentfile = NULL, *tmp;\n\tint ret;\n\tbool ok = false;\n\n\tchildfile = cgroup_to_absolute_path(mp, path, name);\n\tif (!childfile)\n\t\treturn false;\n\n\t/* don't overwrite a non-empty value in the file */\n\tret = cgroup_read_from_file(childfile, value, sizeof(value));\n\tif (ret < 0)\n\t\tgoto out;\n\tif (value[0] != '\\0' && value[0] != '\\n') {\n\t\tok = true;\n\t\tgoto out;\n\t}\n\n\t/* path to the same name in the parent cgroup */\n\tparentfile = strdup(path);\n\tif (!parentfile)\n\t\tgoto out;\n\n\ttmp = strrchr(parentfile, '/');\n\tif (!tmp)\n\t\tgoto out;\n\tif (tmp == parentfile)\n\t\ttmp++; /* keep the '/' at the start */\n\t*tmp = '\\0';\n\ttmp = parentfile;\n\tparentfile = cgroup_to_absolute_path(mp, tmp, name);\n\tfree(tmp);\n\tif (!parentfile)\n\t\tgoto out;\n\n\t/* copy from parent to child cgroup */\n\tret = cgroup_read_from_file(parentfile, value, sizeof(value));\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret == sizeof(value)) {\n\t\t/* If anyone actually sees this error, we can address it */\n\t\tERROR(\"parent cpuset value too long\");\n\t\tgoto out;\n\t}\n\tok = (lxc_write_to_file(childfile, value, strlen(value), false) >= 0);\n\tif (!ok)\n\t\tSYSERROR(\"failed writing %s\", childfile);\n\nout:\n\tfree(parentfile);\n\tfree(childfile);\n\treturn ok;\n}"
  },
  {
    "function_name": "cgroup_read_from_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "2217-2236",
    "snippet": "static int cgroup_read_from_file(const char *fn, char buf[], size_t bufsize)\n{\n\tint ret = lxc_read_from_file(fn, buf, bufsize);\n\tif (ret < 0) {\n\t\tSYSERROR(\"failed to read %s\", fn);\n\t\treturn ret;\n\t}\n\tif (ret == bufsize) {\n\t\tif (bufsize > 0) {\n\t\t\t/* obviously this wasn't empty */\n\t\t\tbuf[bufsize-1] = '\\0';\n\t\t\treturn ret;\n\t\t}\n\t\t/* Callers don't do this, but regression/sanity check */\n\t\tERROR(\"%s: was not expecting 0 bufsize\", __func__);\n\t\treturn -1;\n\t}\n\tbuf[ret] = '\\0';\n\treturn ret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"%s: was not expecting 0 bufsize\"",
            "__func__"
          ],
          "line": 2231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to read %s\"",
            "fn"
          ],
          "line": 2221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_read_from_file",
          "args": [
            "fn",
            "buf",
            "bufsize"
          ],
          "line": 2219
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "962-990",
          "snippet": "int lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int cgroup_read_from_file(const char *fn, char buf[], size_t bufsize)\n{\n\tint ret = lxc_read_from_file(fn, buf, bufsize);\n\tif (ret < 0) {\n\t\tSYSERROR(\"failed to read %s\", fn);\n\t\treturn ret;\n\t}\n\tif (ret == bufsize) {\n\t\tif (bufsize > 0) {\n\t\t\t/* obviously this wasn't empty */\n\t\t\tbuf[bufsize-1] = '\\0';\n\t\t\treturn ret;\n\t\t}\n\t\t/* Callers don't do this, but regression/sanity check */\n\t\tERROR(\"%s: was not expecting 0 bufsize\", __func__);\n\t\treturn -1;\n\t}\n\tbuf[ret] = '\\0';\n\treturn ret;\n}"
  },
  {
    "function_name": "handle_cgroup_settings",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "2159-2215",
    "snippet": "static int handle_cgroup_settings(struct cgroup_mount_point *mp,\n\t\t\t\t  char *cgroup_path)\n{\n\tint r, saved_errno = 0;\n\tchar buf[2];\n\n\tmp->need_cpuset_init = false;\n\n\t/* If this is the memory cgroup, we want to enforce hierarchy.\n\t * But don't fail if for some reason we can't.\n\t */\n\tif (lxc_string_in_array(\"memory\", (const char **)mp->hierarchy->subsystems)) {\n\t\tchar *cc_path = cgroup_to_absolute_path(mp, cgroup_path, \"/memory.use_hierarchy\");\n\t\tif (cc_path) {\n\t\t\tr = lxc_read_from_file(cc_path, buf, 1);\n\t\t\tif (r < 1 || buf[0] != '1') {\n\t\t\t\tr = lxc_write_to_file(cc_path, \"1\", 1, false);\n\t\t\t\tif (r < 0)\n\t\t\t\t\tSYSERROR(\"failed to set memory.use_hierarchy to 1; continuing\");\n\t\t\t}\n\t\t\tfree(cc_path);\n\t\t}\n\t}\n\n\t/* if this is a cpuset hierarchy, we have to set cgroup.clone_children in\n\t * the base cgroup, otherwise containers will start with an empty cpuset.mems\n\t * and cpuset.cpus and then\n\t */\n\tif (lxc_string_in_array(\"cpuset\", (const char **)mp->hierarchy->subsystems)) {\n\t\tchar *cc_path = cgroup_to_absolute_path(mp, cgroup_path, \"/cgroup.clone_children\");\n\t\tstruct stat sb;\n\n\t\tif (!cc_path)\n\t\t\treturn -1;\n\t\t/* cgroup.clone_children is not available when running under\n\t\t * older kernel versions; in this case, we'll initialize\n\t\t * cpuset.cpus and cpuset.mems later, after the new cgroup\n\t\t * was created\n\t\t */\n\t\tif (stat(cc_path, &sb) != 0 && errno == ENOENT) {\n\t\t\tmp->need_cpuset_init = true;\n\t\t\tfree(cc_path);\n\t\t\treturn 0;\n\t\t}\n\t\tr = lxc_read_from_file(cc_path, buf, 1);\n\t\tif (r == 1 && buf[0] == '1') {\n\t\t\tfree(cc_path);\n\t\t\treturn 0;\n\t\t}\n\t\tr = lxc_write_to_file(cc_path, \"1\", 1, false);\n\t\tsaved_errno = errno;\n\t\tfree(cc_path);\n\t\terrno = saved_errno;\n\t\treturn r < 0 ? -1 : 0;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
      "static int cgroup_recursive_task_count(const char *cgroup_path);",
      "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cc_path"
          ],
          "line": 2210
        },
        "resolved": true,
        "details": {
          "function_name": "cgfs_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2501-2518",
          "snippet": "static bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_write_to_file",
          "args": [
            "cc_path",
            "\"1\"",
            "1",
            "false"
          ],
          "line": 2208
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_to_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "934-960",
          "snippet": "int lxc_write_to_file(const char *filename, const void* buf, size_t count, bool add_newline)\n{\n\tint fd, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_WRONLY | O_TRUNC | O_CREAT | O_CLOEXEC, 0666);\n\tif (fd < 0)\n\t\treturn -1;\n\tret = lxc_write_nointr(fd, buf, count);\n\tif (ret < 0)\n\t\tgoto out_error;\n\tif ((size_t)ret != count)\n\t\tgoto out_error;\n\tif (add_newline) {\n\t\tret = lxc_write_nointr(fd, \"\\n\", 1);\n\t\tif (ret != 1)\n\t\t\tgoto out_error;\n\t}\n\tclose(fd);\n\treturn 0;\n\nout_error:\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn -1;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_write_to_file(const char *filename, const void* buf, size_t count, bool add_newline)\n{\n\tint fd, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_WRONLY | O_TRUNC | O_CREAT | O_CLOEXEC, 0666);\n\tif (fd < 0)\n\t\treturn -1;\n\tret = lxc_write_nointr(fd, buf, count);\n\tif (ret < 0)\n\t\tgoto out_error;\n\tif ((size_t)ret != count)\n\t\tgoto out_error;\n\tif (add_newline) {\n\t\tret = lxc_write_nointr(fd, \"\\n\", 1);\n\t\tif (ret != 1)\n\t\t\tgoto out_error;\n\t}\n\tclose(fd);\n\treturn 0;\n\nout_error:\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_read_from_file",
          "args": [
            "cc_path",
            "buf",
            "1"
          ],
          "line": 2203
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "962-990",
          "snippet": "int lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "cc_path",
            "&sb"
          ],
          "line": 2198
        },
        "resolved": true,
        "details": {
          "function_name": "Container_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "599-603",
          "snippet": "static PyObject *\nContainer_state(Container *self, void *closure)\n{\n    return PyUnicode_FromString(self->container->state(self->container));\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_state(Container *self, void *closure)\n{\n    return PyUnicode_FromString(self->container->state(self->container));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_to_absolute_path",
          "args": [
            "mp",
            "cgroup_path",
            "\"/cgroup.clone_children\""
          ],
          "line": 2188
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_to_absolute_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1901-1944",
          "snippet": "static char *cgroup_to_absolute_path(struct cgroup_mount_point *mp,\n\t\t\t\t     const char *path, const char *suffix)\n{\n\t/* first we have to make sure we subtract the mount point's prefix */\n\tchar *prefix = mp->mount_prefix;\n\tchar *buf;\n\tssize_t len, rv;\n\n\t/* we want to make sure only absolute paths to cgroups are passed to us */\n\tif (path[0] != '/') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (prefix && !strcmp(prefix, \"/\"))\n\t\tprefix = NULL;\n\n\t/* prefix doesn't match */\n\tif (prefix && strncmp(prefix, path, strlen(prefix)) != 0) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\t/* if prefix is /foo and path is /foobar */\n\tif (prefix && path[strlen(prefix)] != '/' && path[strlen(prefix)] != '\\0') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\t/* remove prefix from path */\n\tpath += prefix ? strlen(prefix) : 0;\n\n\tlen = strlen(mp->mount_point) + strlen(path) + (suffix ? strlen(suffix) : 0);\n\tbuf = calloc(len + 1, 1);\n\tif (!buf)\n\t\treturn NULL;\n\trv = snprintf(buf, len + 1, \"%s%s%s\", mp->mount_point, path, suffix ? suffix : \"\");\n\tif (rv > len) {\n\t\tfree(buf);\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\treturn buf;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
            "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
            "static char *cgroup_to_absolute_path(struct cgroup_mount_point *mp, const char *path, const char *suffix);",
            "static int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);",
            "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic char *cgroup_to_absolute_path(struct cgroup_mount_point *mp, const char *path, const char *suffix);\nstatic int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\n\nstatic char *cgroup_to_absolute_path(struct cgroup_mount_point *mp,\n\t\t\t\t     const char *path, const char *suffix)\n{\n\t/* first we have to make sure we subtract the mount point's prefix */\n\tchar *prefix = mp->mount_prefix;\n\tchar *buf;\n\tssize_t len, rv;\n\n\t/* we want to make sure only absolute paths to cgroups are passed to us */\n\tif (path[0] != '/') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (prefix && !strcmp(prefix, \"/\"))\n\t\tprefix = NULL;\n\n\t/* prefix doesn't match */\n\tif (prefix && strncmp(prefix, path, strlen(prefix)) != 0) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\t/* if prefix is /foo and path is /foobar */\n\tif (prefix && path[strlen(prefix)] != '/' && path[strlen(prefix)] != '\\0') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\t/* remove prefix from path */\n\tpath += prefix ? strlen(prefix) : 0;\n\n\tlen = strlen(mp->mount_point) + strlen(path) + (suffix ? strlen(suffix) : 0);\n\tbuf = calloc(len + 1, 1);\n\tif (!buf)\n\t\treturn NULL;\n\trv = snprintf(buf, len + 1, \"%s%s%s\", mp->mount_point, path, suffix ? suffix : \"\");\n\tif (rv > len) {\n\t\tfree(buf);\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_string_in_array",
          "args": [
            "\"cpuset\"",
            "(const char **)mp->hierarchy->subsystems"
          ],
          "line": 2187
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_in_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "656-662",
          "snippet": "bool lxc_string_in_array(const char *needle, const char **haystack)\n{\n\tfor (; haystack && *haystack; haystack++)\n\t\tif (!strcmp(needle, *haystack))\n\t\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool lxc_string_in_array(const char *needle, const char **haystack)\n{\n\tfor (; haystack && *haystack; haystack++)\n\t\tif (!strcmp(needle, *haystack))\n\t\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to set memory.use_hierarchy to 1; continuing\""
          ],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\n\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp,\n\t\t\t\t  char *cgroup_path)\n{\n\tint r, saved_errno = 0;\n\tchar buf[2];\n\n\tmp->need_cpuset_init = false;\n\n\t/* If this is the memory cgroup, we want to enforce hierarchy.\n\t * But don't fail if for some reason we can't.\n\t */\n\tif (lxc_string_in_array(\"memory\", (const char **)mp->hierarchy->subsystems)) {\n\t\tchar *cc_path = cgroup_to_absolute_path(mp, cgroup_path, \"/memory.use_hierarchy\");\n\t\tif (cc_path) {\n\t\t\tr = lxc_read_from_file(cc_path, buf, 1);\n\t\t\tif (r < 1 || buf[0] != '1') {\n\t\t\t\tr = lxc_write_to_file(cc_path, \"1\", 1, false);\n\t\t\t\tif (r < 0)\n\t\t\t\t\tSYSERROR(\"failed to set memory.use_hierarchy to 1; continuing\");\n\t\t\t}\n\t\t\tfree(cc_path);\n\t\t}\n\t}\n\n\t/* if this is a cpuset hierarchy, we have to set cgroup.clone_children in\n\t * the base cgroup, otherwise containers will start with an empty cpuset.mems\n\t * and cpuset.cpus and then\n\t */\n\tif (lxc_string_in_array(\"cpuset\", (const char **)mp->hierarchy->subsystems)) {\n\t\tchar *cc_path = cgroup_to_absolute_path(mp, cgroup_path, \"/cgroup.clone_children\");\n\t\tstruct stat sb;\n\n\t\tif (!cc_path)\n\t\t\treturn -1;\n\t\t/* cgroup.clone_children is not available when running under\n\t\t * older kernel versions; in this case, we'll initialize\n\t\t * cpuset.cpus and cpuset.mems later, after the new cgroup\n\t\t * was created\n\t\t */\n\t\tif (stat(cc_path, &sb) != 0 && errno == ENOENT) {\n\t\t\tmp->need_cpuset_init = true;\n\t\t\tfree(cc_path);\n\t\t\treturn 0;\n\t\t}\n\t\tr = lxc_read_from_file(cc_path, buf, 1);\n\t\tif (r == 1 && buf[0] == '1') {\n\t\t\tfree(cc_path);\n\t\t\treturn 0;\n\t\t}\n\t\tr = lxc_write_to_file(cc_path, \"1\", 1, false);\n\t\tsaved_errno = errno;\n\t\tfree(cc_path);\n\t\terrno = saved_errno;\n\t\treturn r < 0 ? -1 : 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroup_recursive_task_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "2111-2157",
    "snippet": "static int cgroup_recursive_task_count(const char *cgroup_path)\n{\n\tDIR *d;\n\tstruct dirent *dent;\n\tint n = 0, r;\n\n\td = opendir(cgroup_path);\n\tif (!d)\n\t\treturn 0;\n\n\twhile ((dent = readdir(d))) {\n\t\tconst char *parts[3] = {\n\t\t\tcgroup_path,\n\t\t\tdent->d_name,\n\t\t\tNULL\n\t\t};\n\t\tchar *sub_path;\n\t\tstruct stat st;\n\n\t\tif (!strcmp(dent->d_name, \".\") || !strcmp(dent->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tsub_path = lxc_string_join(\"/\", parts, false);\n\t\tif (!sub_path) {\n\t\t\tclosedir(d);\n\t\t\treturn -1;\n\t\t}\n\t\tr = stat(sub_path, &st);\n\t\tif (r < 0) {\n\t\t\tclosedir(d);\n\t\t\tfree(sub_path);\n\t\t\treturn -1;\n\t\t}\n\t\tif (S_ISDIR(st.st_mode)) {\n\t\t\tr = cgroup_recursive_task_count(sub_path);\n\t\t\tif (r >= 0)\n\t\t\t\tn += r;\n\t\t} else if (!strcmp(dent->d_name, \"tasks\")) {\n\t\t\tr = lxc_count_file_lines(sub_path);\n\t\t\tif (r >= 0)\n\t\t\t\tn += r;\n\t\t}\n\t\tfree(sub_path);\n\t}\n\tclosedir(d);\n\n\treturn n;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_recursive_task_count(const char *cgroup_path);",
      "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "d"
          ],
          "line": 2154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "sub_path"
          ],
          "line": 2152
        },
        "resolved": true,
        "details": {
          "function_name": "cgfs_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2501-2518",
          "snippet": "static bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_count_file_lines",
          "args": [
            "sub_path"
          ],
          "line": 2148
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_count_file_lines",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1844-1861",
          "snippet": "int lxc_count_file_lines(const char *fn)\n{\n\tFILE *f;\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tint n = 0;\n\n\tf = fopen_cloexec(fn, \"r\");\n\tif (!f)\n\t\treturn -1;\n\n\twhile (getline(&line, &sz, f) != -1) {\n\t\tn++;\n\t}\n\tfree(line);\n\tfclose(f);\n\treturn n;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_count_file_lines(const char *fn)\n{\n\tFILE *f;\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tint n = 0;\n\n\tf = fopen_cloexec(fn, \"r\");\n\tif (!f)\n\t\treturn -1;\n\n\twhile (getline(&line, &sz, f) != -1) {\n\t\tn++;\n\t}\n\tfree(line);\n\tfclose(f);\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dent->d_name",
            "\"tasks\""
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_recursive_task_count",
          "args": [
            "sub_path"
          ],
          "line": 2144
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_recursive_task_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2111-2157",
          "snippet": "static int cgroup_recursive_task_count(const char *cgroup_path)\n{\n\tDIR *d;\n\tstruct dirent *dent;\n\tint n = 0, r;\n\n\td = opendir(cgroup_path);\n\tif (!d)\n\t\treturn 0;\n\n\twhile ((dent = readdir(d))) {\n\t\tconst char *parts[3] = {\n\t\t\tcgroup_path,\n\t\t\tdent->d_name,\n\t\t\tNULL\n\t\t};\n\t\tchar *sub_path;\n\t\tstruct stat st;\n\n\t\tif (!strcmp(dent->d_name, \".\") || !strcmp(dent->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tsub_path = lxc_string_join(\"/\", parts, false);\n\t\tif (!sub_path) {\n\t\t\tclosedir(d);\n\t\t\treturn -1;\n\t\t}\n\t\tr = stat(sub_path, &st);\n\t\tif (r < 0) {\n\t\t\tclosedir(d);\n\t\t\tfree(sub_path);\n\t\t\treturn -1;\n\t\t}\n\t\tif (S_ISDIR(st.st_mode)) {\n\t\t\tr = cgroup_recursive_task_count(sub_path);\n\t\t\tif (r >= 0)\n\t\t\t\tn += r;\n\t\t} else if (!strcmp(dent->d_name, \"tasks\")) {\n\t\t\tr = lxc_count_file_lines(sub_path);\n\t\t\tif (r >= 0)\n\t\t\t\tn += r;\n\t\t}\n\t\tfree(sub_path);\n\t}\n\tclosedir(d);\n\n\treturn n;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "st.st_mode"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "d"
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "sub_path",
            "&st"
          ],
          "line": 2137
        },
        "resolved": true,
        "details": {
          "function_name": "Container_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "599-603",
          "snippet": "static PyObject *\nContainer_state(Container *self, void *closure)\n{\n    return PyUnicode_FromString(self->container->state(self->container));\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_state(Container *self, void *closure)\n{\n    return PyUnicode_FromString(self->container->state(self->container));\n}"
        }
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "d"
          ],
          "line": 2134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_string_join",
          "args": [
            "\"/\"",
            "parts",
            "false"
          ],
          "line": 2132
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_join",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "664-688",
          "snippet": "char *lxc_string_join(const char *sep, const char **parts, bool use_as_prefix)\n{\n\tchar *result;\n\tchar **p;\n\tsize_t sep_len = strlen(sep);\n\tsize_t result_len = use_as_prefix * sep_len;\n\n\t/* calculate new string length */\n\tfor (p = (char **)parts; *p; p++)\n\t\tresult_len += (p > (char **)parts) * sep_len + strlen(*p);\n\n\tresult = calloc(result_len + 1, 1);\n\tif (!result)\n\t\treturn NULL;\n\n\tif (use_as_prefix)\n\t\tstrcpy(result, sep);\n\tfor (p = (char **)parts; *p; p++) {\n\t\tif (p > (char **)parts)\n\t\t\tstrcat(result, sep);\n\t\tstrcat(result, *p);\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *lxc_string_join(const char *sep, const char **parts, bool use_as_prefix)\n{\n\tchar *result;\n\tchar **p;\n\tsize_t sep_len = strlen(sep);\n\tsize_t result_len = use_as_prefix * sep_len;\n\n\t/* calculate new string length */\n\tfor (p = (char **)parts; *p; p++)\n\t\tresult_len += (p > (char **)parts) * sep_len + strlen(*p);\n\n\tresult = calloc(result_len + 1, 1);\n\tif (!result)\n\t\treturn NULL;\n\n\tif (use_as_prefix)\n\t\tstrcpy(result, sep);\n\tfor (p = (char **)parts; *p; p++) {\n\t\tif (p > (char **)parts)\n\t\t\tstrcat(result, sep);\n\t\tstrcat(result, *p);\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dent->d_name",
            "\"..\""
          ],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dent->d_name",
            "\".\""
          ],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "d"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "cgroup_path"
          ],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\n\nstatic int cgroup_recursive_task_count(const char *cgroup_path)\n{\n\tDIR *d;\n\tstruct dirent *dent;\n\tint n = 0, r;\n\n\td = opendir(cgroup_path);\n\tif (!d)\n\t\treturn 0;\n\n\twhile ((dent = readdir(d))) {\n\t\tconst char *parts[3] = {\n\t\t\tcgroup_path,\n\t\t\tdent->d_name,\n\t\t\tNULL\n\t\t};\n\t\tchar *sub_path;\n\t\tstruct stat st;\n\n\t\tif (!strcmp(dent->d_name, \".\") || !strcmp(dent->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tsub_path = lxc_string_join(\"/\", parts, false);\n\t\tif (!sub_path) {\n\t\t\tclosedir(d);\n\t\t\treturn -1;\n\t\t}\n\t\tr = stat(sub_path, &st);\n\t\tif (r < 0) {\n\t\t\tclosedir(d);\n\t\t\tfree(sub_path);\n\t\t\treturn -1;\n\t\t}\n\t\tif (S_ISDIR(st.st_mode)) {\n\t\t\tr = cgroup_recursive_task_count(sub_path);\n\t\t\tif (r >= 0)\n\t\t\t\tn += r;\n\t\t} else if (!strcmp(dent->d_name, \"tasks\")) {\n\t\t\tr = lxc_count_file_lines(sub_path);\n\t\t\tif (r >= 0)\n\t\t\t\tn += r;\n\t\t}\n\t\tfree(sub_path);\n\t}\n\tclosedir(d);\n\n\treturn n;\n}"
  },
  {
    "function_name": "cgroup_devices_has_allow_or_deny",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "2056-2109",
    "snippet": "static bool cgroup_devices_has_allow_or_deny(struct cgfs_data *d,\n\t\t\t\t\t     char *v, bool for_allow)\n{\n\tchar *path;\n\tFILE *devices_list;\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tbool ret = !for_allow;\n\tconst char *parts[3] = {\n\t\tNULL,\n\t\t\"devices.list\",\n\t\tNULL\n\t};\n\n\t// XXX FIXME if users could use something other than 'lxc.devices.deny = a'.\n\t// not sure they ever do, but they *could*\n\t// right now, I'm assuming they do NOT\n\tif (!for_allow && strcmp(v, \"a\") != 0 && strcmp(v, \"a *:* rwm\") != 0)\n\t\treturn false;\n\n\tparts[0] = (const char *)lxc_cgroup_get_hierarchy_abs_path_data(\"devices\", d);\n\tif (!parts[0])\n\t\treturn false;\n\tpath = lxc_string_join(\"/\", parts, false);\n\tif (!path) {\n\t\tfree((void *)parts[0]);\n\t\treturn false;\n\t}\n\n\tdevices_list = fopen_cloexec(path, \"r\");\n\tif (!devices_list) {\n\t\tfree(path);\n\t\treturn false;\n\t}\n\n\twhile (getline(&line, &sz, devices_list) != -1) {\n\t\tsize_t len = strlen(line);\n\t\tif (len > 0 && line[len-1] == '\\n')\n\t\t\tline[len-1] = '\\0';\n\t\tif (strcmp(line, \"a *:* rwm\") == 0) {\n\t\t\tret = for_allow;\n\t\t\tgoto out;\n\t\t} else if (for_allow && strcmp(line, v) == 0) {\n\t\t\tret = true;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfclose(devices_list);\n\tfree(line);\n\tfree(path);\n\treturn ret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
      "static int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);",
      "static bool cgroup_devices_has_allow_or_deny(struct cgfs_data *d, char *v, bool for_allow);",
      "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "path"
          ],
          "line": 2107
        },
        "resolved": true,
        "details": {
          "function_name": "cgfs_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2501-2518",
          "snippet": "static bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "devices_list"
          ],
          "line": 2105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "line",
            "v"
          ],
          "line": 2098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "line",
            "\"a *:* rwm\""
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "line"
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&line",
            "&sz",
            "devices_list"
          ],
          "line": 2091
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getline.c",
          "lines": "39-60",
          "snippet": "ssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fopen_cloexec",
          "args": [
            "path",
            "\"r\""
          ],
          "line": 2085
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_string_join",
          "args": [
            "\"/\"",
            "parts",
            "false"
          ],
          "line": 2079
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_join",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "664-688",
          "snippet": "char *lxc_string_join(const char *sep, const char **parts, bool use_as_prefix)\n{\n\tchar *result;\n\tchar **p;\n\tsize_t sep_len = strlen(sep);\n\tsize_t result_len = use_as_prefix * sep_len;\n\n\t/* calculate new string length */\n\tfor (p = (char **)parts; *p; p++)\n\t\tresult_len += (p > (char **)parts) * sep_len + strlen(*p);\n\n\tresult = calloc(result_len + 1, 1);\n\tif (!result)\n\t\treturn NULL;\n\n\tif (use_as_prefix)\n\t\tstrcpy(result, sep);\n\tfor (p = (char **)parts; *p; p++) {\n\t\tif (p > (char **)parts)\n\t\t\tstrcat(result, sep);\n\t\tstrcat(result, *p);\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *lxc_string_join(const char *sep, const char **parts, bool use_as_prefix)\n{\n\tchar *result;\n\tchar **p;\n\tsize_t sep_len = strlen(sep);\n\tsize_t result_len = use_as_prefix * sep_len;\n\n\t/* calculate new string length */\n\tfor (p = (char **)parts; *p; p++)\n\t\tresult_len += (p > (char **)parts) * sep_len + strlen(*p);\n\n\tresult = calloc(result_len + 1, 1);\n\tif (!result)\n\t\treturn NULL;\n\n\tif (use_as_prefix)\n\t\tstrcpy(result, sep);\n\tfor (p = (char **)parts; *p; p++) {\n\t\tif (p > (char **)parts)\n\t\t\tstrcat(result, sep);\n\t\tstrcat(result, *p);\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_get_hierarchy_abs_path_data",
          "args": [
            "\"devices\"",
            "d"
          ],
          "line": 2076
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_get_hierarchy_abs_path_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1303-1319",
          "snippet": "static char *lxc_cgroup_get_hierarchy_abs_path_data(const char *subsystem, struct cgfs_data *d)\n{\n\tstruct cgroup_process_info *info = d->info;\n\tstruct cgroup_mount_point *mp = NULL;\n\n\tinfo = find_info_for_subsystem(info, subsystem);\n\tif (!info)\n\t\treturn NULL;\n\tif (info->designated_mount_point) {\n\t\tmp = info->designated_mount_point;\n\t} else {\n\t\tmp = lxc_cgroup_find_mount_point(info->hierarchy, info->cgroup_path, true);\n\t\tif (!mp)\n\t\t\treturn NULL;\n\t}\n\treturn cgroup_to_absolute_path(mp, info->cgroup_path, NULL);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
            "static struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);",
            "static int cgroup_recursive_task_count(const char *cgroup_path);",
            "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);",
            "static void lxc_cgroup_process_info_free(struct cgroup_process_info *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\nstatic void lxc_cgroup_process_info_free(struct cgroup_process_info *info);\n\nstatic char *lxc_cgroup_get_hierarchy_abs_path_data(const char *subsystem, struct cgfs_data *d)\n{\n\tstruct cgroup_process_info *info = d->info;\n\tstruct cgroup_mount_point *mp = NULL;\n\n\tinfo = find_info_for_subsystem(info, subsystem);\n\tif (!info)\n\t\treturn NULL;\n\tif (info->designated_mount_point) {\n\t\tmp = info->designated_mount_point;\n\t} else {\n\t\tmp = lxc_cgroup_find_mount_point(info->hierarchy, info->cgroup_path, true);\n\t\tif (!mp)\n\t\t\treturn NULL;\n\t}\n\treturn cgroup_to_absolute_path(mp, info->cgroup_path, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "v",
            "\"a *:* rwm\""
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "v",
            "\"a\""
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);\nstatic bool cgroup_devices_has_allow_or_deny(struct cgfs_data *d, char *v, bool for_allow);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\n\nstatic bool cgroup_devices_has_allow_or_deny(struct cgfs_data *d,\n\t\t\t\t\t     char *v, bool for_allow)\n{\n\tchar *path;\n\tFILE *devices_list;\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tbool ret = !for_allow;\n\tconst char *parts[3] = {\n\t\tNULL,\n\t\t\"devices.list\",\n\t\tNULL\n\t};\n\n\t// XXX FIXME if users could use something other than 'lxc.devices.deny = a'.\n\t// not sure they ever do, but they *could*\n\t// right now, I'm assuming they do NOT\n\tif (!for_allow && strcmp(v, \"a\") != 0 && strcmp(v, \"a *:* rwm\") != 0)\n\t\treturn false;\n\n\tparts[0] = (const char *)lxc_cgroup_get_hierarchy_abs_path_data(\"devices\", d);\n\tif (!parts[0])\n\t\treturn false;\n\tpath = lxc_string_join(\"/\", parts, false);\n\tif (!path) {\n\t\tfree((void *)parts[0]);\n\t\treturn false;\n\t}\n\n\tdevices_list = fopen_cloexec(path, \"r\");\n\tif (!devices_list) {\n\t\tfree(path);\n\t\treturn false;\n\t}\n\n\twhile (getline(&line, &sz, devices_list) != -1) {\n\t\tsize_t len = strlen(line);\n\t\tif (len > 0 && line[len-1] == '\\n')\n\t\t\tline[len-1] = '\\0';\n\t\tif (strcmp(line, \"a *:* rwm\") == 0) {\n\t\t\tret = for_allow;\n\t\t\tgoto out;\n\t\t} else if (for_allow && strcmp(line, v) == 0) {\n\t\t\tret = true;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfclose(devices_list);\n\tfree(line);\n\tfree(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "do_setup_cgroup_limits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "2005-2054",
    "snippet": "static int do_setup_cgroup_limits(struct cgfs_data *d,\n\t\t\t   struct lxc_list *cgroup_settings, bool do_devices)\n{\n\tstruct lxc_list *iterator, *sorted_cgroup_settings, *next;\n\tstruct lxc_cgroup *cg;\n\tint ret = -1;\n\n\tif (lxc_list_empty(cgroup_settings))\n\t\treturn 0;\n\n\tsorted_cgroup_settings = sort_cgroup_settings(cgroup_settings);\n\tif (!sorted_cgroup_settings) {\n\t\treturn -1;\n\t}\n\n\tlxc_list_for_each(iterator, sorted_cgroup_settings) {\n\t\tcg = iterator->elem;\n\n\t\tif (do_devices == !strncmp(\"devices\", cg->subsystem, 7)) {\n\t\t\tif (strcmp(cg->subsystem, \"devices.deny\") == 0 &&\n\t\t\t\t\tcgroup_devices_has_allow_or_deny(d, cg->value, false))\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(cg->subsystem, \"devices.allow\") == 0 &&\n\t\t\t\t\tcgroup_devices_has_allow_or_deny(d, cg->value, true))\n\t\t\t\tcontinue;\n\t\t\tif (lxc_cgroup_set_data(cg->subsystem, cg->value, d)) {\n\t\t\t\tif (do_devices && (errno == EACCES || errno == EPERM)) {\n\t\t\t\t\tWARN(\"Error setting %s to %s for %s\",\n\t\t\t\t\t      cg->subsystem, cg->value, d->name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tSYSERROR(\"Error setting %s to %s for %s\",\n\t\t\t\t      cg->subsystem, cg->value, d->name);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tDEBUG(\"cgroup '%s' set to '%s'\", cg->subsystem, cg->value);\n\t}\n\n\tret = 0;\n\tINFO(\"cgroup has been setup\");\nout:\n\tlxc_list_for_each_safe(iterator, sorted_cgroup_settings, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(sorted_cgroup_settings);\n\treturn ret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_valid_cgroup(const char *name);",
      "static struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);",
      "static int do_cgroup_set(const char *cgroup_path, const char *sub_filename, const char *value);",
      "static int do_setup_cgroup_limits(struct cgfs_data *d, struct lxc_list *cgroup_settings, bool do_devices);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "sorted_cgroup_settings"
          ],
          "line": 2052
        },
        "resolved": true,
        "details": {
          "function_name": "cgfs_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2501-2518",
          "snippet": "static bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_del",
          "args": [
            "iterator"
          ],
          "line": 2049
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "148-156",
          "snippet": "static inline void lxc_list_del(struct lxc_list *list)\n{\n\tstruct lxc_list *next, *prev;\n\n\tnext = list->next;\n\tprev = list->prev;\n\tnext->prev = prev;\n\tprev->next = next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void lxc_list_del(struct lxc_list *list)\n{\n\tstruct lxc_list *next, *prev;\n\n\tnext = list->next;\n\tprev = list->prev;\n\tnext->prev = prev;\n\tprev->next = next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each_safe",
          "args": [
            "iterator",
            "sorted_cgroup_settings",
            "next"
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"cgroup has been setup\""
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"cgroup '%s' set to '%s'\"",
            "cg->subsystem",
            "cg->value"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error setting %s to %s for %s\"",
            "cg->subsystem",
            "cg->value",
            "d->name"
          ],
          "line": 2036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Error setting %s to %s for %s\"",
            "cg->subsystem",
            "cg->value",
            "d->name"
          ],
          "line": 2032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_set_data",
          "args": [
            "cg->subsystem",
            "cg->value",
            "d"
          ],
          "line": 2030
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_set_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1353-1372",
          "snippet": "static int lxc_cgroup_set_data(const char *filename, const char *value, struct cgfs_data *d)\n{\n\tchar *subsystem = NULL, *p, *path;\n\tint ret = -1;\n\n\tsubsystem = alloca(strlen(filename) + 1);\n\tstrcpy(subsystem, filename);\n\tif ((p = strchr(subsystem, '.')) != NULL)\n\t\t*p = '\\0';\n\n\terrno = ENOENT;\n\tpath = lxc_cgroup_get_hierarchy_abs_path_data(subsystem, d);\n\tif (path) {\n\t\tret = do_cgroup_set(path, filename, value);\n\t\tint saved_errno = errno;\n\t\tfree(path);\n\t\terrno = saved_errno;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
            "static struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);",
            "static int do_cgroup_set(const char *cgroup_path, const char *sub_filename, const char *value);",
            "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);\nstatic int do_cgroup_set(const char *cgroup_path, const char *sub_filename, const char *value);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\n\nstatic int lxc_cgroup_set_data(const char *filename, const char *value, struct cgfs_data *d)\n{\n\tchar *subsystem = NULL, *p, *path;\n\tint ret = -1;\n\n\tsubsystem = alloca(strlen(filename) + 1);\n\tstrcpy(subsystem, filename);\n\tif ((p = strchr(subsystem, '.')) != NULL)\n\t\t*p = '\\0';\n\n\terrno = ENOENT;\n\tpath = lxc_cgroup_get_hierarchy_abs_path_data(subsystem, d);\n\tif (path) {\n\t\tret = do_cgroup_set(path, filename, value);\n\t\tint saved_errno = errno;\n\t\tfree(path);\n\t\terrno = saved_errno;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_devices_has_allow_or_deny",
          "args": [
            "d",
            "cg->value",
            "true"
          ],
          "line": 2028
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_devices_has_allow_or_deny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2056-2109",
          "snippet": "static bool cgroup_devices_has_allow_or_deny(struct cgfs_data *d,\n\t\t\t\t\t     char *v, bool for_allow)\n{\n\tchar *path;\n\tFILE *devices_list;\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tbool ret = !for_allow;\n\tconst char *parts[3] = {\n\t\tNULL,\n\t\t\"devices.list\",\n\t\tNULL\n\t};\n\n\t// XXX FIXME if users could use something other than 'lxc.devices.deny = a'.\n\t// not sure they ever do, but they *could*\n\t// right now, I'm assuming they do NOT\n\tif (!for_allow && strcmp(v, \"a\") != 0 && strcmp(v, \"a *:* rwm\") != 0)\n\t\treturn false;\n\n\tparts[0] = (const char *)lxc_cgroup_get_hierarchy_abs_path_data(\"devices\", d);\n\tif (!parts[0])\n\t\treturn false;\n\tpath = lxc_string_join(\"/\", parts, false);\n\tif (!path) {\n\t\tfree((void *)parts[0]);\n\t\treturn false;\n\t}\n\n\tdevices_list = fopen_cloexec(path, \"r\");\n\tif (!devices_list) {\n\t\tfree(path);\n\t\treturn false;\n\t}\n\n\twhile (getline(&line, &sz, devices_list) != -1) {\n\t\tsize_t len = strlen(line);\n\t\tif (len > 0 && line[len-1] == '\\n')\n\t\t\tline[len-1] = '\\0';\n\t\tif (strcmp(line, \"a *:* rwm\") == 0) {\n\t\t\tret = for_allow;\n\t\t\tgoto out;\n\t\t} else if (for_allow && strcmp(line, v) == 0) {\n\t\t\tret = true;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfclose(devices_list);\n\tfree(line);\n\tfree(path);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
            "static int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);",
            "static bool cgroup_devices_has_allow_or_deny(struct cgfs_data *d, char *v, bool for_allow);",
            "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);\nstatic bool cgroup_devices_has_allow_or_deny(struct cgfs_data *d, char *v, bool for_allow);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\n\nstatic bool cgroup_devices_has_allow_or_deny(struct cgfs_data *d,\n\t\t\t\t\t     char *v, bool for_allow)\n{\n\tchar *path;\n\tFILE *devices_list;\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tbool ret = !for_allow;\n\tconst char *parts[3] = {\n\t\tNULL,\n\t\t\"devices.list\",\n\t\tNULL\n\t};\n\n\t// XXX FIXME if users could use something other than 'lxc.devices.deny = a'.\n\t// not sure they ever do, but they *could*\n\t// right now, I'm assuming they do NOT\n\tif (!for_allow && strcmp(v, \"a\") != 0 && strcmp(v, \"a *:* rwm\") != 0)\n\t\treturn false;\n\n\tparts[0] = (const char *)lxc_cgroup_get_hierarchy_abs_path_data(\"devices\", d);\n\tif (!parts[0])\n\t\treturn false;\n\tpath = lxc_string_join(\"/\", parts, false);\n\tif (!path) {\n\t\tfree((void *)parts[0]);\n\t\treturn false;\n\t}\n\n\tdevices_list = fopen_cloexec(path, \"r\");\n\tif (!devices_list) {\n\t\tfree(path);\n\t\treturn false;\n\t}\n\n\twhile (getline(&line, &sz, devices_list) != -1) {\n\t\tsize_t len = strlen(line);\n\t\tif (len > 0 && line[len-1] == '\\n')\n\t\t\tline[len-1] = '\\0';\n\t\tif (strcmp(line, \"a *:* rwm\") == 0) {\n\t\t\tret = for_allow;\n\t\t\tgoto out;\n\t\t} else if (for_allow && strcmp(line, v) == 0) {\n\t\t\tret = true;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfclose(devices_list);\n\tfree(line);\n\tfree(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cg->subsystem",
            "\"devices.allow\""
          ],
          "line": 2027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cg->subsystem",
            "\"devices.deny\""
          ],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "\"devices\"",
            "cg->subsystem",
            "7"
          ],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "iterator",
            "sorted_cgroup_settings"
          ],
          "line": 2020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sort_cgroup_settings",
          "args": [
            "cgroup_settings"
          ],
          "line": 2015
        },
        "resolved": true,
        "details": {
          "function_name": "sort_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4634-4672",
          "snippet": "struct lxc_list *sort_cgroup_settings(struct lxc_list* cgroup_settings)\n{\n\tstruct lxc_list *result;\n\tstruct lxc_list *memsw_limit = NULL;\n\tstruct lxc_list *it = NULL;\n\tstruct lxc_cgroup *cg = NULL;\n\tstruct lxc_list *item = NULL;\n\n\tresult = malloc(sizeof(*result));\n\tif (!result) {\n\t\tERROR(\"failed to allocate memory to sort cgroup settings\");\n\t\treturn NULL;\n\t}\n\tlxc_list_init(result);\n\n\t/*Iterate over the cgroup settings and copy them to the output list*/\n\tlxc_list_for_each(it, cgroup_settings) {\n\t\titem = malloc(sizeof(*item));\n\t\tif (!item) {\n\t\t\tERROR(\"failed to allocate memory to sort cgroup settings\");\n\t\t\tfree_cgroup_settings(result);\n\t\t\treturn NULL;\n\t\t}\n\t\titem->elem = it->elem;\n\t\tcg = it->elem;\n\t\tif (strcmp(cg->subsystem, \"memory.memsw.limit_in_bytes\") == 0) {\n\t\t\t/* Store the memsw_limit location */\n\t\t\tmemsw_limit = item;\n\t\t} else if (strcmp(cg->subsystem, \"memory.limit_in_bytes\") == 0 && memsw_limit != NULL) {\n\t\t\t/* lxc.cgroup.memory.memsw.limit_in_bytes is found before\n\t\t\t * lxc.cgroup.memory.limit_in_bytes, swap these two items */\n\t\t\titem->elem = memsw_limit->elem;\n\t\t\tmemsw_limit->elem = it->elem;\n\t\t}\n\t\tlxc_list_add_tail(result, item);\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstruct lxc_list *sort_cgroup_settings(struct lxc_list* cgroup_settings)\n{\n\tstruct lxc_list *result;\n\tstruct lxc_list *memsw_limit = NULL;\n\tstruct lxc_list *it = NULL;\n\tstruct lxc_cgroup *cg = NULL;\n\tstruct lxc_list *item = NULL;\n\n\tresult = malloc(sizeof(*result));\n\tif (!result) {\n\t\tERROR(\"failed to allocate memory to sort cgroup settings\");\n\t\treturn NULL;\n\t}\n\tlxc_list_init(result);\n\n\t/*Iterate over the cgroup settings and copy them to the output list*/\n\tlxc_list_for_each(it, cgroup_settings) {\n\t\titem = malloc(sizeof(*item));\n\t\tif (!item) {\n\t\t\tERROR(\"failed to allocate memory to sort cgroup settings\");\n\t\t\tfree_cgroup_settings(result);\n\t\t\treturn NULL;\n\t\t}\n\t\titem->elem = it->elem;\n\t\tcg = it->elem;\n\t\tif (strcmp(cg->subsystem, \"memory.memsw.limit_in_bytes\") == 0) {\n\t\t\t/* Store the memsw_limit location */\n\t\t\tmemsw_limit = item;\n\t\t} else if (strcmp(cg->subsystem, \"memory.limit_in_bytes\") == 0 && memsw_limit != NULL) {\n\t\t\t/* lxc.cgroup.memory.memsw.limit_in_bytes is found before\n\t\t\t * lxc.cgroup.memory.limit_in_bytes, swap these two items */\n\t\t\titem->elem = memsw_limit->elem;\n\t\t\tmemsw_limit->elem = it->elem;\n\t\t}\n\t\tlxc_list_add_tail(result, item);\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_empty",
          "args": [
            "cgroup_settings"
          ],
          "line": 2012
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "94-97",
          "snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool is_valid_cgroup(const char *name);\nstatic struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);\nstatic int do_cgroup_set(const char *cgroup_path, const char *sub_filename, const char *value);\nstatic int do_setup_cgroup_limits(struct cgfs_data *d, struct lxc_list *cgroup_settings, bool do_devices);\n\nstatic int do_setup_cgroup_limits(struct cgfs_data *d,\n\t\t\t   struct lxc_list *cgroup_settings, bool do_devices)\n{\n\tstruct lxc_list *iterator, *sorted_cgroup_settings, *next;\n\tstruct lxc_cgroup *cg;\n\tint ret = -1;\n\n\tif (lxc_list_empty(cgroup_settings))\n\t\treturn 0;\n\n\tsorted_cgroup_settings = sort_cgroup_settings(cgroup_settings);\n\tif (!sorted_cgroup_settings) {\n\t\treturn -1;\n\t}\n\n\tlxc_list_for_each(iterator, sorted_cgroup_settings) {\n\t\tcg = iterator->elem;\n\n\t\tif (do_devices == !strncmp(\"devices\", cg->subsystem, 7)) {\n\t\t\tif (strcmp(cg->subsystem, \"devices.deny\") == 0 &&\n\t\t\t\t\tcgroup_devices_has_allow_or_deny(d, cg->value, false))\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(cg->subsystem, \"devices.allow\") == 0 &&\n\t\t\t\t\tcgroup_devices_has_allow_or_deny(d, cg->value, true))\n\t\t\t\tcontinue;\n\t\t\tif (lxc_cgroup_set_data(cg->subsystem, cg->value, d)) {\n\t\t\t\tif (do_devices && (errno == EACCES || errno == EPERM)) {\n\t\t\t\t\tWARN(\"Error setting %s to %s for %s\",\n\t\t\t\t\t      cg->subsystem, cg->value, d->name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tSYSERROR(\"Error setting %s to %s for %s\",\n\t\t\t\t      cg->subsystem, cg->value, d->name);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tDEBUG(\"cgroup '%s' set to '%s'\", cg->subsystem, cg->value);\n\t}\n\n\tret = 0;\n\tINFO(\"cgroup has been setup\");\nout:\n\tlxc_list_for_each_safe(iterator, sorted_cgroup_settings, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(sorted_cgroup_settings);\n\treturn ret;\n}"
  },
  {
    "function_name": "do_cgroup_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "1983-2003",
    "snippet": "static int do_cgroup_set(const char *cgroup_path, const char *sub_filename,\n\t\t\t const char *value)\n{\n\tconst char *parts[3] = {\n\t\tcgroup_path,\n\t\tsub_filename,\n\t\tNULL\n\t};\n\tchar *filename;\n\tint ret, saved_errno;\n\n\tfilename = lxc_string_join(\"/\", parts, false);\n\tif (!filename)\n\t\treturn -1;\n\n\tret = lxc_write_to_file(filename, value, strlen(value), false);\n\tsaved_errno = errno;\n\tfree(filename);\n\terrno = saved_errno;\n\treturn ret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int do_cgroup_set(const char *cgroup_path, const char *sub_filename, const char *value);",
      "static int cgroup_recursive_task_count(const char *cgroup_path);",
      "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "filename"
          ],
          "line": 2000
        },
        "resolved": true,
        "details": {
          "function_name": "cgfs_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2501-2518",
          "snippet": "static bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_write_to_file",
          "args": [
            "filename",
            "value",
            "strlen(value)",
            "false"
          ],
          "line": 1998
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_to_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "934-960",
          "snippet": "int lxc_write_to_file(const char *filename, const void* buf, size_t count, bool add_newline)\n{\n\tint fd, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_WRONLY | O_TRUNC | O_CREAT | O_CLOEXEC, 0666);\n\tif (fd < 0)\n\t\treturn -1;\n\tret = lxc_write_nointr(fd, buf, count);\n\tif (ret < 0)\n\t\tgoto out_error;\n\tif ((size_t)ret != count)\n\t\tgoto out_error;\n\tif (add_newline) {\n\t\tret = lxc_write_nointr(fd, \"\\n\", 1);\n\t\tif (ret != 1)\n\t\t\tgoto out_error;\n\t}\n\tclose(fd);\n\treturn 0;\n\nout_error:\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn -1;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_write_to_file(const char *filename, const void* buf, size_t count, bool add_newline)\n{\n\tint fd, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_WRONLY | O_TRUNC | O_CREAT | O_CLOEXEC, 0666);\n\tif (fd < 0)\n\t\treturn -1;\n\tret = lxc_write_nointr(fd, buf, count);\n\tif (ret < 0)\n\t\tgoto out_error;\n\tif ((size_t)ret != count)\n\t\tgoto out_error;\n\tif (add_newline) {\n\t\tret = lxc_write_nointr(fd, \"\\n\", 1);\n\t\tif (ret != 1)\n\t\t\tgoto out_error;\n\t}\n\tclose(fd);\n\treturn 0;\n\nout_error:\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "value"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_string_join",
          "args": [
            "\"/\"",
            "parts",
            "false"
          ],
          "line": 1994
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_join",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "664-688",
          "snippet": "char *lxc_string_join(const char *sep, const char **parts, bool use_as_prefix)\n{\n\tchar *result;\n\tchar **p;\n\tsize_t sep_len = strlen(sep);\n\tsize_t result_len = use_as_prefix * sep_len;\n\n\t/* calculate new string length */\n\tfor (p = (char **)parts; *p; p++)\n\t\tresult_len += (p > (char **)parts) * sep_len + strlen(*p);\n\n\tresult = calloc(result_len + 1, 1);\n\tif (!result)\n\t\treturn NULL;\n\n\tif (use_as_prefix)\n\t\tstrcpy(result, sep);\n\tfor (p = (char **)parts; *p; p++) {\n\t\tif (p > (char **)parts)\n\t\t\tstrcat(result, sep);\n\t\tstrcat(result, *p);\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *lxc_string_join(const char *sep, const char **parts, bool use_as_prefix)\n{\n\tchar *result;\n\tchar **p;\n\tsize_t sep_len = strlen(sep);\n\tsize_t result_len = use_as_prefix * sep_len;\n\n\t/* calculate new string length */\n\tfor (p = (char **)parts; *p; p++)\n\t\tresult_len += (p > (char **)parts) * sep_len + strlen(*p);\n\n\tresult = calloc(result_len + 1, 1);\n\tif (!result)\n\t\treturn NULL;\n\n\tif (use_as_prefix)\n\t\tstrcpy(result, sep);\n\tfor (p = (char **)parts; *p; p++) {\n\t\tif (p > (char **)parts)\n\t\t\tstrcat(result, sep);\n\t\tstrcat(result, *p);\n\t}\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int do_cgroup_set(const char *cgroup_path, const char *sub_filename, const char *value);\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\n\nstatic int do_cgroup_set(const char *cgroup_path, const char *sub_filename,\n\t\t\t const char *value)\n{\n\tconst char *parts[3] = {\n\t\tcgroup_path,\n\t\tsub_filename,\n\t\tNULL\n\t};\n\tchar *filename;\n\tint ret, saved_errno;\n\n\tfilename = lxc_string_join(\"/\", parts, false);\n\tif (!filename)\n\t\treturn -1;\n\n\tret = lxc_write_to_file(filename, value, strlen(value), false);\n\tsaved_errno = errno;\n\tfree(filename);\n\terrno = saved_errno;\n\treturn ret;\n}"
  },
  {
    "function_name": "do_cgroup_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "1961-1981",
    "snippet": "static int do_cgroup_get(const char *cgroup_path, const char *sub_filename,\n\t\t\t char *value, size_t len)\n{\n\tconst char *parts[3] = {\n\t\tcgroup_path,\n\t\tsub_filename,\n\t\tNULL\n\t};\n\tchar *filename;\n\tint ret, saved_errno;\n\n\tfilename = lxc_string_join(\"/\", parts, false);\n\tif (!filename)\n\t\treturn -1;\n\n\tret = lxc_read_from_file(filename, value, len);\n\tsaved_errno = errno;\n\tfree(filename);\n\terrno = saved_errno;\n\treturn ret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);",
      "static int do_cgroup_set(const char *cgroup_path, const char *sub_filename, const char *value);",
      "static int cgroup_recursive_task_count(const char *cgroup_path);",
      "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "filename"
          ],
          "line": 1978
        },
        "resolved": true,
        "details": {
          "function_name": "cgfs_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2501-2518",
          "snippet": "static bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_read_from_file",
          "args": [
            "filename",
            "value",
            "len"
          ],
          "line": 1976
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "962-990",
          "snippet": "int lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_string_join",
          "args": [
            "\"/\"",
            "parts",
            "false"
          ],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_join",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "664-688",
          "snippet": "char *lxc_string_join(const char *sep, const char **parts, bool use_as_prefix)\n{\n\tchar *result;\n\tchar **p;\n\tsize_t sep_len = strlen(sep);\n\tsize_t result_len = use_as_prefix * sep_len;\n\n\t/* calculate new string length */\n\tfor (p = (char **)parts; *p; p++)\n\t\tresult_len += (p > (char **)parts) * sep_len + strlen(*p);\n\n\tresult = calloc(result_len + 1, 1);\n\tif (!result)\n\t\treturn NULL;\n\n\tif (use_as_prefix)\n\t\tstrcpy(result, sep);\n\tfor (p = (char **)parts; *p; p++) {\n\t\tif (p > (char **)parts)\n\t\t\tstrcat(result, sep);\n\t\tstrcat(result, *p);\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *lxc_string_join(const char *sep, const char **parts, bool use_as_prefix)\n{\n\tchar *result;\n\tchar **p;\n\tsize_t sep_len = strlen(sep);\n\tsize_t result_len = use_as_prefix * sep_len;\n\n\t/* calculate new string length */\n\tfor (p = (char **)parts; *p; p++)\n\t\tresult_len += (p > (char **)parts) * sep_len + strlen(*p);\n\n\tresult = calloc(result_len + 1, 1);\n\tif (!result)\n\t\treturn NULL;\n\n\tif (use_as_prefix)\n\t\tstrcpy(result, sep);\n\tfor (p = (char **)parts; *p; p++) {\n\t\tif (p > (char **)parts)\n\t\t\tstrcat(result, sep);\n\t\tstrcat(result, *p);\n\t}\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);\nstatic int do_cgroup_set(const char *cgroup_path, const char *sub_filename, const char *value);\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\n\nstatic int do_cgroup_get(const char *cgroup_path, const char *sub_filename,\n\t\t\t char *value, size_t len)\n{\n\tconst char *parts[3] = {\n\t\tcgroup_path,\n\t\tsub_filename,\n\t\tNULL\n\t};\n\tchar *filename;\n\tint ret, saved_errno;\n\n\tfilename = lxc_string_join(\"/\", parts, false);\n\tif (!filename)\n\t\treturn -1;\n\n\tret = lxc_read_from_file(filename, value, len);\n\tsaved_errno = errno;\n\tfree(filename);\n\terrno = saved_errno;\n\treturn ret;\n}"
  },
  {
    "function_name": "find_info_for_subsystem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "1946-1959",
    "snippet": "static struct cgroup_process_info *\nfind_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem)\n{\n\tstruct cgroup_process_info *info_ptr;\n\tfor (info_ptr = info; info_ptr; info_ptr = info_ptr->next) {\n\t\tstruct cgroup_hierarchy *h = info_ptr->hierarchy;\n\t\tif (!h)\n\t\t\tcontinue;\n\t\tif (lxc_string_in_array(subsystem, (const char **)h->subsystems))\n\t\t\treturn info_ptr;\n\t}\n\terrno = ENOENT;\n\treturn NULL;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);",
      "static struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);",
      "static void lxc_cgroup_process_info_free(struct cgroup_process_info *info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_string_in_array",
          "args": [
            "subsystem",
            "(const char **)h->subsystems"
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_in_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "656-662",
          "snippet": "bool lxc_string_in_array(const char *needle, const char **haystack)\n{\n\tfor (; haystack && *haystack; haystack++)\n\t\tif (!strcmp(needle, *haystack))\n\t\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool lxc_string_in_array(const char *needle, const char **haystack)\n{\n\tfor (; haystack && *haystack; haystack++)\n\t\tif (!strcmp(needle, *haystack))\n\t\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);\nstatic struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);\nstatic void lxc_cgroup_process_info_free(struct cgroup_process_info *info);\n\nstatic struct cgroup_process_info *\nfind_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem)\n{\n\tstruct cgroup_process_info *info_ptr;\n\tfor (info_ptr = info; info_ptr; info_ptr = info_ptr->next) {\n\t\tstruct cgroup_hierarchy *h = info_ptr->hierarchy;\n\t\tif (!h)\n\t\t\tcontinue;\n\t\tif (lxc_string_in_array(subsystem, (const char **)h->subsystems))\n\t\t\treturn info_ptr;\n\t}\n\terrno = ENOENT;\n\treturn NULL;\n}"
  },
  {
    "function_name": "cgroup_to_absolute_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "1901-1944",
    "snippet": "static char *cgroup_to_absolute_path(struct cgroup_mount_point *mp,\n\t\t\t\t     const char *path, const char *suffix)\n{\n\t/* first we have to make sure we subtract the mount point's prefix */\n\tchar *prefix = mp->mount_prefix;\n\tchar *buf;\n\tssize_t len, rv;\n\n\t/* we want to make sure only absolute paths to cgroups are passed to us */\n\tif (path[0] != '/') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (prefix && !strcmp(prefix, \"/\"))\n\t\tprefix = NULL;\n\n\t/* prefix doesn't match */\n\tif (prefix && strncmp(prefix, path, strlen(prefix)) != 0) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\t/* if prefix is /foo and path is /foobar */\n\tif (prefix && path[strlen(prefix)] != '/' && path[strlen(prefix)] != '\\0') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\t/* remove prefix from path */\n\tpath += prefix ? strlen(prefix) : 0;\n\n\tlen = strlen(mp->mount_point) + strlen(path) + (suffix ? strlen(suffix) : 0);\n\tbuf = calloc(len + 1, 1);\n\tif (!buf)\n\t\treturn NULL;\n\trv = snprintf(buf, len + 1, \"%s%s%s\", mp->mount_point, path, suffix ? suffix : \"\");\n\tif (rv > len) {\n\t\tfree(buf);\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\treturn buf;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
      "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
      "static char *cgroup_to_absolute_path(struct cgroup_mount_point *mp, const char *path, const char *suffix);",
      "static int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);",
      "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "buf"
          ],
          "line": 1938
        },
        "resolved": true,
        "details": {
          "function_name": "cgfs_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2501-2518",
          "snippet": "static bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "len + 1",
            "\"%s%s%s\"",
            "mp->mount_point",
            "path",
            "suffix ? suffix : \"\""
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "len + 1",
            "1"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "suffix"
          ],
          "line": 1932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 1932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "mp->mount_point"
          ],
          "line": 1932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "prefix"
          ],
          "line": 1930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "prefix"
          ],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "prefix"
          ],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "prefix",
            "path",
            "strlen(prefix)"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "prefix"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "prefix",
            "\"/\""
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic char *cgroup_to_absolute_path(struct cgroup_mount_point *mp, const char *path, const char *suffix);\nstatic int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\n\nstatic char *cgroup_to_absolute_path(struct cgroup_mount_point *mp,\n\t\t\t\t     const char *path, const char *suffix)\n{\n\t/* first we have to make sure we subtract the mount point's prefix */\n\tchar *prefix = mp->mount_prefix;\n\tchar *buf;\n\tssize_t len, rv;\n\n\t/* we want to make sure only absolute paths to cgroups are passed to us */\n\tif (path[0] != '/') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (prefix && !strcmp(prefix, \"/\"))\n\t\tprefix = NULL;\n\n\t/* prefix doesn't match */\n\tif (prefix && strncmp(prefix, path, strlen(prefix)) != 0) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\t/* if prefix is /foo and path is /foobar */\n\tif (prefix && path[strlen(prefix)] != '/' && path[strlen(prefix)] != '\\0') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\t/* remove prefix from path */\n\tpath += prefix ? strlen(prefix) : 0;\n\n\tlen = strlen(mp->mount_point) + strlen(path) + (suffix ? strlen(suffix) : 0);\n\tbuf = calloc(len + 1, 1);\n\tif (!buf)\n\t\treturn NULL;\n\trv = snprintf(buf, len + 1, \"%s%s%s\", mp->mount_point, path, suffix ? suffix : \"\");\n\tif (rv > len) {\n\t\tfree(buf);\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\treturn buf;\n}"
  },
  {
    "function_name": "remove_cgroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "1895-1899",
    "snippet": "static int remove_cgroup(struct cgroup_mount_point *mp,\n\t\t\t const char *path, bool recurse, struct lxc_conf *conf)\n{\n\treturn create_or_remove_cgroup(true, mp, path, recurse, conf);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
      "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
      "static int remove_cgroup(struct cgroup_mount_point *mp, const char *path, bool recurse,\n\t\t\t\tstruct lxc_conf *conf);",
      "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);",
      "static void lxc_cgroup_process_info_free_and_remove(struct cgroup_process_info *info,\n\t\t\t\tstruct lxc_conf *conf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_or_remove_cgroup",
          "args": [
            "true",
            "mp",
            "path",
            "recurse",
            "conf"
          ],
          "line": 1898
        },
        "resolved": true,
        "details": {
          "function_name": "create_or_remove_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1862-1888",
          "snippet": "static int create_or_remove_cgroup(bool do_remove,\n\t\tstruct cgroup_mount_point *mp, const char *path, int recurse,\n\t\tstruct lxc_conf *conf)\n{\n\tint r, saved_errno = 0;\n\tchar *buf = cgroup_to_absolute_path(mp, path, NULL);\n\tif (!buf)\n\t\treturn -1;\n\n\t/* create or remove directory */\n\tif (do_remove) {\n\t\tif (!dir_exists(buf))\n\t\t\treturn 0;\n\t\tif (recurse) {\n\t\t\tif (conf && !lxc_list_empty(&conf->id_map))\n\t\t\t\tr = userns_exec_1(conf, rmdir_wrapper, buf);\n\t\t\telse\n\t\t\t\tr = cgroup_rmdir(buf);\n\t\t} else\n\t\t\tr = rmdir(buf);\n\t} else\n\t\tr = mkdir(buf, 0777);\n\tsaved_errno = errno;\n\tfree(buf);\n\terrno = saved_errno;\n\treturn r;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
            "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
            "static int remove_cgroup(struct cgroup_mount_point *mp, const char *path, bool recurse,\n\t\t\t\tstruct lxc_conf *conf);",
            "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);",
            "static void lxc_cgroup_process_info_free_and_remove(struct cgroup_process_info *info,\n\t\t\t\tstruct lxc_conf *conf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic int remove_cgroup(struct cgroup_mount_point *mp, const char *path, bool recurse,\n\t\t\t\tstruct lxc_conf *conf);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\nstatic void lxc_cgroup_process_info_free_and_remove(struct cgroup_process_info *info,\n\t\t\t\tstruct lxc_conf *conf);\n\nstatic int create_or_remove_cgroup(bool do_remove,\n\t\tstruct cgroup_mount_point *mp, const char *path, int recurse,\n\t\tstruct lxc_conf *conf)\n{\n\tint r, saved_errno = 0;\n\tchar *buf = cgroup_to_absolute_path(mp, path, NULL);\n\tif (!buf)\n\t\treturn -1;\n\n\t/* create or remove directory */\n\tif (do_remove) {\n\t\tif (!dir_exists(buf))\n\t\t\treturn 0;\n\t\tif (recurse) {\n\t\t\tif (conf && !lxc_list_empty(&conf->id_map))\n\t\t\t\tr = userns_exec_1(conf, rmdir_wrapper, buf);\n\t\t\telse\n\t\t\t\tr = cgroup_rmdir(buf);\n\t\t} else\n\t\t\tr = rmdir(buf);\n\t} else\n\t\tr = mkdir(buf, 0777);\n\tsaved_errno = errno;\n\tfree(buf);\n\terrno = saved_errno;\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic int remove_cgroup(struct cgroup_mount_point *mp, const char *path, bool recurse,\n\t\t\t\tstruct lxc_conf *conf);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\nstatic void lxc_cgroup_process_info_free_and_remove(struct cgroup_process_info *info,\n\t\t\t\tstruct lxc_conf *conf);\n\nstatic int remove_cgroup(struct cgroup_mount_point *mp,\n\t\t\t const char *path, bool recurse, struct lxc_conf *conf)\n{\n\treturn create_or_remove_cgroup(true, mp, path, recurse, conf);\n}"
  },
  {
    "function_name": "create_cgroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "1890-1893",
    "snippet": "static int create_cgroup(struct cgroup_mount_point *mp, const char *path)\n{\n\treturn create_or_remove_cgroup(false, mp, path, false, NULL);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
      "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
      "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_or_remove_cgroup",
          "args": [
            "false",
            "mp",
            "path",
            "false",
            "NULL"
          ],
          "line": 1892
        },
        "resolved": true,
        "details": {
          "function_name": "create_or_remove_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1862-1888",
          "snippet": "static int create_or_remove_cgroup(bool do_remove,\n\t\tstruct cgroup_mount_point *mp, const char *path, int recurse,\n\t\tstruct lxc_conf *conf)\n{\n\tint r, saved_errno = 0;\n\tchar *buf = cgroup_to_absolute_path(mp, path, NULL);\n\tif (!buf)\n\t\treturn -1;\n\n\t/* create or remove directory */\n\tif (do_remove) {\n\t\tif (!dir_exists(buf))\n\t\t\treturn 0;\n\t\tif (recurse) {\n\t\t\tif (conf && !lxc_list_empty(&conf->id_map))\n\t\t\t\tr = userns_exec_1(conf, rmdir_wrapper, buf);\n\t\t\telse\n\t\t\t\tr = cgroup_rmdir(buf);\n\t\t} else\n\t\t\tr = rmdir(buf);\n\t} else\n\t\tr = mkdir(buf, 0777);\n\tsaved_errno = errno;\n\tfree(buf);\n\terrno = saved_errno;\n\treturn r;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
            "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
            "static int remove_cgroup(struct cgroup_mount_point *mp, const char *path, bool recurse,\n\t\t\t\tstruct lxc_conf *conf);",
            "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);",
            "static void lxc_cgroup_process_info_free_and_remove(struct cgroup_process_info *info,\n\t\t\t\tstruct lxc_conf *conf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic int remove_cgroup(struct cgroup_mount_point *mp, const char *path, bool recurse,\n\t\t\t\tstruct lxc_conf *conf);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\nstatic void lxc_cgroup_process_info_free_and_remove(struct cgroup_process_info *info,\n\t\t\t\tstruct lxc_conf *conf);\n\nstatic int create_or_remove_cgroup(bool do_remove,\n\t\tstruct cgroup_mount_point *mp, const char *path, int recurse,\n\t\tstruct lxc_conf *conf)\n{\n\tint r, saved_errno = 0;\n\tchar *buf = cgroup_to_absolute_path(mp, path, NULL);\n\tif (!buf)\n\t\treturn -1;\n\n\t/* create or remove directory */\n\tif (do_remove) {\n\t\tif (!dir_exists(buf))\n\t\t\treturn 0;\n\t\tif (recurse) {\n\t\t\tif (conf && !lxc_list_empty(&conf->id_map))\n\t\t\t\tr = userns_exec_1(conf, rmdir_wrapper, buf);\n\t\t\telse\n\t\t\t\tr = cgroup_rmdir(buf);\n\t\t} else\n\t\t\tr = rmdir(buf);\n\t} else\n\t\tr = mkdir(buf, 0777);\n\tsaved_errno = errno;\n\tfree(buf);\n\terrno = saved_errno;\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\n\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path)\n{\n\treturn create_or_remove_cgroup(false, mp, path, false, NULL);\n}"
  },
  {
    "function_name": "create_or_remove_cgroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "1862-1888",
    "snippet": "static int create_or_remove_cgroup(bool do_remove,\n\t\tstruct cgroup_mount_point *mp, const char *path, int recurse,\n\t\tstruct lxc_conf *conf)\n{\n\tint r, saved_errno = 0;\n\tchar *buf = cgroup_to_absolute_path(mp, path, NULL);\n\tif (!buf)\n\t\treturn -1;\n\n\t/* create or remove directory */\n\tif (do_remove) {\n\t\tif (!dir_exists(buf))\n\t\t\treturn 0;\n\t\tif (recurse) {\n\t\t\tif (conf && !lxc_list_empty(&conf->id_map))\n\t\t\t\tr = userns_exec_1(conf, rmdir_wrapper, buf);\n\t\t\telse\n\t\t\t\tr = cgroup_rmdir(buf);\n\t\t} else\n\t\t\tr = rmdir(buf);\n\t} else\n\t\tr = mkdir(buf, 0777);\n\tsaved_errno = errno;\n\tfree(buf);\n\terrno = saved_errno;\n\treturn r;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
      "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
      "static int remove_cgroup(struct cgroup_mount_point *mp, const char *path, bool recurse,\n\t\t\t\tstruct lxc_conf *conf);",
      "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);",
      "static void lxc_cgroup_process_info_free_and_remove(struct cgroup_process_info *info,\n\t\t\t\tstruct lxc_conf *conf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "buf"
          ],
          "line": 1885
        },
        "resolved": true,
        "details": {
          "function_name": "cgfs_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2501-2518",
          "snippet": "static bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "buf",
            "0777"
          ],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "241-262",
          "snippet": "extern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmdir",
          "args": [
            "buf"
          ],
          "line": 1881
        },
        "resolved": true,
        "details": {
          "function_name": "rmdir_wrapper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "227-239",
          "snippet": "static int rmdir_wrapper(void *data)\n{\n\tchar *path = data;\n\n\tif (setresgid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setgid to 0\");\n\tif (setresuid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setuid to 0\");\n\tif (setgroups(0, NULL) < 0)\n\t\tSYSERROR(\"Failed to clear groups\");\n\n\treturn cgroup_rmdir(path);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
            "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\n\nstatic int rmdir_wrapper(void *data)\n{\n\tchar *path = data;\n\n\tif (setresgid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setgid to 0\");\n\tif (setresuid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setuid to 0\");\n\tif (setgroups(0, NULL) < 0)\n\t\tSYSERROR(\"Failed to clear groups\");\n\n\treturn cgroup_rmdir(path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_rmdir",
          "args": [
            "buf"
          ],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "158-225",
          "snippet": "static int cgroup_rmdir(char *dirname)\n{\n\tstruct dirent *direntp;\n\tint saved_errno = 0;\n\tDIR *dir;\n\tint ret, failed=0;\n\tchar pathname[MAXPATHLEN];\n\n\tdir = opendir(dirname);\n\tif (!dir) {\n\t\tERROR(\"%s: failed to open %s\", __func__, dirname);\n\t\treturn -1;\n\t}\n\n\twhile ((direntp = readdir(dir))) {\n\t\tstruct stat mystat;\n\t\tint rc;\n\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\") ||\n\t\t    !strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\trc = snprintf(pathname, MAXPATHLEN, \"%s/%s\", dirname, direntp->d_name);\n\t\tif (rc < 0 || rc >= MAXPATHLEN) {\n\t\t\tERROR(\"pathname too long\");\n\t\t\tfailed=1;\n\t\t\tif (!saved_errno)\n\t\t\t\tsaved_errno = -ENOMEM;\n\t\t\tcontinue;\n\t\t}\n\t\tret = lstat(pathname, &mystat);\n\t\tif (ret) {\n\t\t\tSYSERROR(\"%s: failed to stat %s\", __func__, pathname);\n\t\t\tfailed=1;\n\t\t\tif (!saved_errno)\n\t\t\t\tsaved_errno = errno;\n\t\t\tcontinue;\n\t\t}\n\t\tif (S_ISDIR(mystat.st_mode)) {\n\t\t\tif (cgroup_rmdir(pathname) < 0) {\n\t\t\t\tif (!saved_errno)\n\t\t\t\t\tsaved_errno = errno;\n\t\t\t\tfailed=1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rmdir(dirname) < 0) {\n\t\tSYSERROR(\"%s: failed to delete %s\", __func__, dirname);\n\t\tif (!saved_errno)\n\t\t\tsaved_errno = errno;\n\t\tfailed=1;\n\t}\n\n\tret = closedir(dir);\n\tif (ret) {\n\t\tSYSERROR(\"%s: failed to close directory %s\", __func__, dirname);\n\t\tif (!saved_errno)\n\t\t\tsaved_errno = errno;\n\t\tfailed=1;\n\t}\n\n\terrno = saved_errno;\n\treturn failed ? -1 : 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int cgroup_rmdir(char *dirname)\n{\n\tstruct dirent *direntp;\n\tint saved_errno = 0;\n\tDIR *dir;\n\tint ret, failed=0;\n\tchar pathname[MAXPATHLEN];\n\n\tdir = opendir(dirname);\n\tif (!dir) {\n\t\tERROR(\"%s: failed to open %s\", __func__, dirname);\n\t\treturn -1;\n\t}\n\n\twhile ((direntp = readdir(dir))) {\n\t\tstruct stat mystat;\n\t\tint rc;\n\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\") ||\n\t\t    !strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\trc = snprintf(pathname, MAXPATHLEN, \"%s/%s\", dirname, direntp->d_name);\n\t\tif (rc < 0 || rc >= MAXPATHLEN) {\n\t\t\tERROR(\"pathname too long\");\n\t\t\tfailed=1;\n\t\t\tif (!saved_errno)\n\t\t\t\tsaved_errno = -ENOMEM;\n\t\t\tcontinue;\n\t\t}\n\t\tret = lstat(pathname, &mystat);\n\t\tif (ret) {\n\t\t\tSYSERROR(\"%s: failed to stat %s\", __func__, pathname);\n\t\t\tfailed=1;\n\t\t\tif (!saved_errno)\n\t\t\t\tsaved_errno = errno;\n\t\t\tcontinue;\n\t\t}\n\t\tif (S_ISDIR(mystat.st_mode)) {\n\t\t\tif (cgroup_rmdir(pathname) < 0) {\n\t\t\t\tif (!saved_errno)\n\t\t\t\t\tsaved_errno = errno;\n\t\t\t\tfailed=1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rmdir(dirname) < 0) {\n\t\tSYSERROR(\"%s: failed to delete %s\", __func__, dirname);\n\t\tif (!saved_errno)\n\t\t\tsaved_errno = errno;\n\t\tfailed=1;\n\t}\n\n\tret = closedir(dir);\n\tif (ret) {\n\t\tSYSERROR(\"%s: failed to close directory %s\", __func__, dirname);\n\t\tif (!saved_errno)\n\t\t\tsaved_errno = errno;\n\t\tfailed=1;\n\t}\n\n\terrno = saved_errno;\n\treturn failed ? -1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "userns_exec_1",
          "args": [
            "conf",
            "rmdir_wrapper",
            "buf"
          ],
          "line": 1877
        },
        "resolved": true,
        "details": {
          "function_name": "userns_exec_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4435-4487",
          "snippet": "int userns_exec_1(struct lxc_conf *conf, int (*fn)(void *), void *data)\n{\n\tint ret, pid;\n\tstruct userns_fn_data d;\n\tchar c = '1';\n\tint p[2];\n\tstruct lxc_list *idmap;\n\n\tret = pipe(p);\n\tif (ret < 0) {\n\t\tSYSERROR(\"opening pipe\");\n\t\treturn -1;\n\t}\n\td.fn = fn;\n\td.arg = data;\n\td.p[0] = p[0];\n\td.p[1] = p[1];\n\tpid = lxc_clone(run_userns_fn, &d, CLONE_NEWUSER);\n\tif (pid < 0)\n\t\tgoto err;\n\tclose(p[0]);\n\tp[0] = -1;\n\n\tif ((idmap = idmap_add_id(conf, geteuid(), getegid())) == NULL) {\n\t\tERROR(\"Error adding self to container uid/gid map\");\n\t\tgoto err;\n\t}\n\n\tret = lxc_map_ids(idmap, pid);\n\tlxc_free_idmap(idmap);\n\tfree(idmap);\n\tif (ret) {\n\t\tERROR(\"Error setting up child mappings\");\n\t\tgoto err;\n\t}\n\n\t// kick the child\n\tif (write(p[1], &c, 1) != 1) {\n\t\tSYSERROR(\"writing to pipe to child\");\n\t\tgoto err;\n\t}\n\n\tret = wait_for_pid(pid);\n\n\tclose(p[1]);\n\treturn ret;\n\nerr:\n\tif (p[0] != -1)\n\t\tclose(p[0]);\n\tclose(p[1]);\n\treturn -1;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint userns_exec_1(struct lxc_conf *conf, int (*fn)(void *), void *data)\n{\n\tint ret, pid;\n\tstruct userns_fn_data d;\n\tchar c = '1';\n\tint p[2];\n\tstruct lxc_list *idmap;\n\n\tret = pipe(p);\n\tif (ret < 0) {\n\t\tSYSERROR(\"opening pipe\");\n\t\treturn -1;\n\t}\n\td.fn = fn;\n\td.arg = data;\n\td.p[0] = p[0];\n\td.p[1] = p[1];\n\tpid = lxc_clone(run_userns_fn, &d, CLONE_NEWUSER);\n\tif (pid < 0)\n\t\tgoto err;\n\tclose(p[0]);\n\tp[0] = -1;\n\n\tif ((idmap = idmap_add_id(conf, geteuid(), getegid())) == NULL) {\n\t\tERROR(\"Error adding self to container uid/gid map\");\n\t\tgoto err;\n\t}\n\n\tret = lxc_map_ids(idmap, pid);\n\tlxc_free_idmap(idmap);\n\tfree(idmap);\n\tif (ret) {\n\t\tERROR(\"Error setting up child mappings\");\n\t\tgoto err;\n\t}\n\n\t// kick the child\n\tif (write(p[1], &c, 1) != 1) {\n\t\tSYSERROR(\"writing to pipe to child\");\n\t\tgoto err;\n\t}\n\n\tret = wait_for_pid(pid);\n\n\tclose(p[1]);\n\treturn ret;\n\nerr:\n\tif (p[0] != -1)\n\t\tclose(p[0]);\n\tclose(p[1]);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_empty",
          "args": [
            "&conf->id_map"
          ],
          "line": 1876
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "94-97",
          "snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_exists",
          "args": [
            "buf"
          ],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "dir_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1059-1069",
          "snippet": "bool dir_exists(const char *path)\n{\n\tstruct stat sb;\n\tint ret;\n\n\tret = stat(path, &sb);\n\tif (ret < 0)\n\t\t// could be something other than eexist, just say no\n\t\treturn false;\n\treturn S_ISDIR(sb.st_mode);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool btrfs_try_remove_subvol(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nbool dir_exists(const char *path)\n{\n\tstruct stat sb;\n\tint ret;\n\n\tret = stat(path, &sb);\n\tif (ret < 0)\n\t\t// could be something other than eexist, just say no\n\t\treturn false;\n\treturn S_ISDIR(sb.st_mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_to_absolute_path",
          "args": [
            "mp",
            "path",
            "NULL"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_to_absolute_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1901-1944",
          "snippet": "static char *cgroup_to_absolute_path(struct cgroup_mount_point *mp,\n\t\t\t\t     const char *path, const char *suffix)\n{\n\t/* first we have to make sure we subtract the mount point's prefix */\n\tchar *prefix = mp->mount_prefix;\n\tchar *buf;\n\tssize_t len, rv;\n\n\t/* we want to make sure only absolute paths to cgroups are passed to us */\n\tif (path[0] != '/') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (prefix && !strcmp(prefix, \"/\"))\n\t\tprefix = NULL;\n\n\t/* prefix doesn't match */\n\tif (prefix && strncmp(prefix, path, strlen(prefix)) != 0) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\t/* if prefix is /foo and path is /foobar */\n\tif (prefix && path[strlen(prefix)] != '/' && path[strlen(prefix)] != '\\0') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\t/* remove prefix from path */\n\tpath += prefix ? strlen(prefix) : 0;\n\n\tlen = strlen(mp->mount_point) + strlen(path) + (suffix ? strlen(suffix) : 0);\n\tbuf = calloc(len + 1, 1);\n\tif (!buf)\n\t\treturn NULL;\n\trv = snprintf(buf, len + 1, \"%s%s%s\", mp->mount_point, path, suffix ? suffix : \"\");\n\tif (rv > len) {\n\t\tfree(buf);\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\treturn buf;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
            "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
            "static char *cgroup_to_absolute_path(struct cgroup_mount_point *mp, const char *path, const char *suffix);",
            "static int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);",
            "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic char *cgroup_to_absolute_path(struct cgroup_mount_point *mp, const char *path, const char *suffix);\nstatic int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\n\nstatic char *cgroup_to_absolute_path(struct cgroup_mount_point *mp,\n\t\t\t\t     const char *path, const char *suffix)\n{\n\t/* first we have to make sure we subtract the mount point's prefix */\n\tchar *prefix = mp->mount_prefix;\n\tchar *buf;\n\tssize_t len, rv;\n\n\t/* we want to make sure only absolute paths to cgroups are passed to us */\n\tif (path[0] != '/') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (prefix && !strcmp(prefix, \"/\"))\n\t\tprefix = NULL;\n\n\t/* prefix doesn't match */\n\tif (prefix && strncmp(prefix, path, strlen(prefix)) != 0) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\t/* if prefix is /foo and path is /foobar */\n\tif (prefix && path[strlen(prefix)] != '/' && path[strlen(prefix)] != '\\0') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\t/* remove prefix from path */\n\tpath += prefix ? strlen(prefix) : 0;\n\n\tlen = strlen(mp->mount_point) + strlen(path) + (suffix ? strlen(suffix) : 0);\n\tbuf = calloc(len + 1, 1);\n\tif (!buf)\n\t\treturn NULL;\n\trv = snprintf(buf, len + 1, \"%s%s%s\", mp->mount_point, path, suffix ? suffix : \"\");\n\tif (rv > len) {\n\t\tfree(buf);\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic int remove_cgroup(struct cgroup_mount_point *mp, const char *path, bool recurse,\n\t\t\t\tstruct lxc_conf *conf);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\nstatic void lxc_cgroup_process_info_free_and_remove(struct cgroup_process_info *info,\n\t\t\t\tstruct lxc_conf *conf);\n\nstatic int create_or_remove_cgroup(bool do_remove,\n\t\tstruct cgroup_mount_point *mp, const char *path, int recurse,\n\t\tstruct lxc_conf *conf)\n{\n\tint r, saved_errno = 0;\n\tchar *buf = cgroup_to_absolute_path(mp, path, NULL);\n\tif (!buf)\n\t\treturn -1;\n\n\t/* create or remove directory */\n\tif (do_remove) {\n\t\tif (!dir_exists(buf))\n\t\t\treturn 0;\n\t\tif (recurse) {\n\t\t\tif (conf && !lxc_list_empty(&conf->id_map))\n\t\t\t\tr = userns_exec_1(conf, rmdir_wrapper, buf);\n\t\t\telse\n\t\t\t\tr = cgroup_rmdir(buf);\n\t\t} else\n\t\t\tr = rmdir(buf);\n\t} else\n\t\tr = mkdir(buf, 0777);\n\tsaved_errno = errno;\n\tfree(buf);\n\terrno = saved_errno;\n\treturn r;\n}"
  },
  {
    "function_name": "is_valid_cgroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "1848-1860",
    "snippet": "static bool is_valid_cgroup(const char *name)\n{\n\tconst char *p;\n\tfor (p = name; *p; p++) {\n\t\t/* Use the ASCII printable characters range(32 - 127)\n\t\t * is reasonable, we kick out 32(SPACE) because it'll\n\t\t * break legacy lxc-ls\n\t\t */\n\t\tif (*p <= 32 || *p >= 127 || *p == '/')\n\t\t\treturn false;\n\t}\n\treturn strcmp(name, \".\") != 0 && strcmp(name, \"..\") != 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_valid_cgroup(const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"..\""
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\".\""
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool is_valid_cgroup(const char *name);\n\nstatic bool is_valid_cgroup(const char *name)\n{\n\tconst char *p;\n\tfor (p = name; *p; p++) {\n\t\t/* Use the ASCII printable characters range(32 - 127)\n\t\t * is reasonable, we kick out 32(SPACE) because it'll\n\t\t * break legacy lxc-ls\n\t\t */\n\t\tif (*p <= 32 || *p >= 127 || *p == '/')\n\t\t\treturn false;\n\t}\n\treturn strcmp(name, \".\") != 0 && strcmp(name, \"..\") != 0;\n}"
  },
  {
    "function_name": "lxc_cgroup_hierarchy_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "1832-1846",
    "snippet": "static void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h)\n{\n\tif (!h)\n\t\treturn;\n\tif (h->subsystems) {\n\t\tlxc_free_array((void **)h->subsystems, free);\n\t\th->subsystems = NULL;\n\t}\n\tif (h->all_mount_points) {\n\t\tfree(h->all_mount_points);\n\t\th->all_mount_points = NULL;\n\t}\n\tfree(h);\n\th = NULL;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "h"
          ],
          "line": 1844
        },
        "resolved": true,
        "details": {
          "function_name": "cgfs_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2501-2518",
          "snippet": "static bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_free_array",
          "args": [
            "(void **)h->subsystems",
            "free"
          ],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_free_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "886-892",
          "snippet": "void lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);\n\nstatic void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h)\n{\n\tif (!h)\n\t\treturn;\n\tif (h->subsystems) {\n\t\tlxc_free_array((void **)h->subsystems, free);\n\t\th->subsystems = NULL;\n\t}\n\tif (h->all_mount_points) {\n\t\tfree(h->all_mount_points);\n\t\th->all_mount_points = NULL;\n\t}\n\tfree(h);\n\th = NULL;\n}"
  },
  {
    "function_name": "lxc_cgroup_mount_point_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "1823-1830",
    "snippet": "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp)\n{\n\tif (!mp)\n\t\treturn;\n\tfree(mp->mount_point);\n\tfree(mp->mount_prefix);\n\tfree(mp);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "mp"
          ],
          "line": 1829
        },
        "resolved": true,
        "details": {
          "function_name": "cgfs_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2501-2518",
          "snippet": "static bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp)\n{\n\tif (!mp)\n\t\treturn;\n\tfree(mp->mount_point);\n\tfree(mp->mount_prefix);\n\tfree(mp);\n}"
  },
  {
    "function_name": "subsystems_from_mount_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "1781-1821",
    "snippet": "static char **subsystems_from_mount_options(const char *mount_options,\n\t\t\t\t\t    char **kernel_list)\n{\n\tchar *token, *str, *saveptr = NULL;\n\tchar **result = NULL;\n\tsize_t result_capacity = 0;\n\tsize_t result_count = 0;\n\tint saved_errno;\n\tint r;\n\n\tstr = alloca(strlen(mount_options)+1);\n\tstrcpy(str, mount_options);\n\tfor (; (token = strtok_r(str, \",\", &saveptr)); str = NULL) {\n\t\t/* we have a subsystem if it's either in the list of\n\t\t * subsystems provided by the kernel OR if it starts\n\t\t * with name= for named hierarchies\n\t\t */\n\t\tr = lxc_grow_array((void ***)&result, &result_capacity, result_count + 1, 12);\n\t\tif (r < 0)\n\t\t\tgoto out_free;\n\t\tresult[result_count + 1] = NULL;\n\t\tif (strncmp(token, \"name=\", 5) && !lxc_string_in_array(token, (const char **)kernel_list)) {\n\t\t\t// this is eg 'systemd' but the mount will be 'name=systemd'\n\t\t\tresult[result_count] = malloc(strlen(token) + 6);\n\t\t\tif (result[result_count])\n\t\t\t\tsprintf(result[result_count], \"name=%s\", token);\n\t\t} else\n\t\t\tresult[result_count] = strdup(token);\n\t\tif (!result[result_count])\n\t\t\tgoto out_free;\n\t\tresult_count++;\n\t}\n\n\treturn result;\n\nout_free:\n\tsaved_errno = errno;\n\tlxc_free_array((void**)result, free);\n\terrno = saved_errno;\n\treturn NULL;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char **subsystems_from_mount_options(const char *mount_options, char **kernel_list);",
      "static bool is_valid_cgroup(const char *name);",
      "static struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_free_array",
          "args": [
            "(void**)result",
            "free"
          ],
          "line": 1818
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_free_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "886-892",
          "snippet": "void lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "token"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "result[result_count]",
            "\"name=%s\"",
            "token"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(token) + 6"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "token"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_string_in_array",
          "args": [
            "token",
            "(const char **)kernel_list"
          ],
          "line": 1802
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_in_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "656-662",
          "snippet": "bool lxc_string_in_array(const char *needle, const char **haystack)\n{\n\tfor (; haystack && *haystack; haystack++)\n\t\tif (!strcmp(needle, *haystack))\n\t\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool lxc_string_in_array(const char *needle, const char **haystack)\n{\n\tfor (; haystack && *haystack; haystack++)\n\t\tif (!strcmp(needle, *haystack))\n\t\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "token",
            "\"name=\"",
            "5"
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_grow_array",
          "args": [
            "(void ***)&result",
            "&result_capacity",
            "result_count + 1",
            "12"
          ],
          "line": 1798
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_grow_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "894-921",
          "snippet": "int lxc_grow_array(void ***array, size_t* capacity, size_t new_size, size_t capacity_increment)\n{\n\tsize_t new_capacity;\n\tvoid **new_array;\n\n\t/* first time around, catch some trivial mistakes of the user\n\t * only initializing one of these */\n\tif (!*array || !*capacity) {\n\t\t*array = NULL;\n\t\t*capacity = 0;\n\t}\n\n\tnew_capacity = *capacity;\n\twhile (new_size + 1 > new_capacity)\n\t\tnew_capacity += capacity_increment;\n\tif (new_capacity != *capacity) {\n\t\t/* we have to reallocate */\n\t\tnew_array = realloc(*array, new_capacity * sizeof(void *));\n\t\tif (!new_array)\n\t\t\treturn -1;\n\t\tmemset(&new_array[*capacity], 0, (new_capacity - (*capacity)) * sizeof(void *));\n\t\t*array = new_array;\n\t\t*capacity = new_capacity;\n\t}\n\n\t/* array has sufficient elements */\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_grow_array(void ***array, size_t* capacity, size_t new_size, size_t capacity_increment)\n{\n\tsize_t new_capacity;\n\tvoid **new_array;\n\n\t/* first time around, catch some trivial mistakes of the user\n\t * only initializing one of these */\n\tif (!*array || !*capacity) {\n\t\t*array = NULL;\n\t\t*capacity = 0;\n\t}\n\n\tnew_capacity = *capacity;\n\twhile (new_size + 1 > new_capacity)\n\t\tnew_capacity += capacity_increment;\n\tif (new_capacity != *capacity) {\n\t\t/* we have to reallocate */\n\t\tnew_array = realloc(*array, new_capacity * sizeof(void *));\n\t\tif (!new_array)\n\t\t\treturn -1;\n\t\tmemset(&new_array[*capacity], 0, (new_capacity - (*capacity)) * sizeof(void *));\n\t\t*array = new_array;\n\t\t*capacity = new_capacity;\n\t}\n\n\t/* array has sufficient elements */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "str",
            "\",\"",
            "&saveptr"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "str",
            "mount_options"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "strlen(mount_options)+1"
          ],
          "line": 1791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "mount_options"
          ],
          "line": 1791
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic char **subsystems_from_mount_options(const char *mount_options, char **kernel_list);\nstatic bool is_valid_cgroup(const char *name);\nstatic struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);\n\nstatic char **subsystems_from_mount_options(const char *mount_options,\n\t\t\t\t\t    char **kernel_list)\n{\n\tchar *token, *str, *saveptr = NULL;\n\tchar **result = NULL;\n\tsize_t result_capacity = 0;\n\tsize_t result_count = 0;\n\tint saved_errno;\n\tint r;\n\n\tstr = alloca(strlen(mount_options)+1);\n\tstrcpy(str, mount_options);\n\tfor (; (token = strtok_r(str, \",\", &saveptr)); str = NULL) {\n\t\t/* we have a subsystem if it's either in the list of\n\t\t * subsystems provided by the kernel OR if it starts\n\t\t * with name= for named hierarchies\n\t\t */\n\t\tr = lxc_grow_array((void ***)&result, &result_capacity, result_count + 1, 12);\n\t\tif (r < 0)\n\t\t\tgoto out_free;\n\t\tresult[result_count + 1] = NULL;\n\t\tif (strncmp(token, \"name=\", 5) && !lxc_string_in_array(token, (const char **)kernel_list)) {\n\t\t\t// this is eg 'systemd' but the mount will be 'name=systemd'\n\t\t\tresult[result_count] = malloc(strlen(token) + 6);\n\t\t\tif (result[result_count])\n\t\t\t\tsprintf(result[result_count], \"name=%s\", token);\n\t\t} else\n\t\t\tresult[result_count] = strdup(token);\n\t\tif (!result[result_count])\n\t\t\tgoto out_free;\n\t\tresult_count++;\n\t}\n\n\treturn result;\n\nout_free:\n\tsaved_errno = errno;\n\tlxc_free_array((void**)result, free);\n\terrno = saved_errno;\n\treturn NULL;\n}"
  },
  {
    "function_name": "lxc_cgroup_process_info_getx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "1675-1779",
    "snippet": "static struct cgroup_process_info *\nlxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str,\n\t\t\t     struct cgroup_meta_data *meta)\n{\n\tstruct cgroup_process_info *result = NULL;\n\tFILE *proc_pid_cgroup = NULL;\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tint saved_errno = 0;\n\tstruct cgroup_process_info **cptr = &result;\n\tstruct cgroup_process_info *entry = NULL;\n\n\tproc_pid_cgroup = fopen_cloexec(proc_pid_cgroup_str, \"r\");\n\tif (!proc_pid_cgroup)\n\t\treturn NULL;\n\n\twhile (getline(&line, &sz, proc_pid_cgroup) != -1) {\n\t\t/* file format: hierarchy:subsystems:group */\n\t\tchar *colon1;\n\t\tchar *colon2;\n\t\tchar *endptr;\n\t\tint hierarchy_number;\n\t\tstruct cgroup_hierarchy *h = NULL;\n\n\t\tif (!line[0])\n\t\t\tcontinue;\n\n\t\tif (line[strlen(line) - 1] == '\\n')\n\t\t\tline[strlen(line) - 1] = '\\0';\n\n\t\tcolon1 = strchr(line, ':');\n\t\tif (!colon1)\n\t\t\tcontinue;\n\t\t*colon1++ = '\\0';\n\t\tcolon2 = strchr(colon1, ':');\n\t\tif (!colon2)\n\t\t\tcontinue;\n\t\t*colon2++ = '\\0';\n\n\t\tendptr = NULL;\n\n\t\t/* With cgroupv2 /proc/self/cgroup can contain entries of the\n\t\t * form: 0::/\n\t\t * These entries need to be skipped.\n\t\t */\n\t\tif (!strcmp(colon1, \"\"))\n\t\t\tcontinue;\n\n\t\thierarchy_number = strtoul(line, &endptr, 10);\n\t\tif (!endptr || *endptr)\n\t\t\tcontinue;\n\n\t\tif (hierarchy_number > meta->maximum_hierarchy) {\n\t\t\t/* we encountered a hierarchy we didn't have before,\n\t\t\t * so probably somebody remounted some stuff in the\n\t\t\t * mean time...\n\t\t\t */\n\t\t\terrno = EAGAIN;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\th = meta->hierarchies[hierarchy_number];\n\t\tif (!h) {\n\t\t\t/* we encountered a hierarchy that was thought to be\n\t\t\t * dead before, so probably somebody remounted some\n\t\t\t * stuff in the mean time...\n\t\t\t */\n\t\t\terrno = EAGAIN;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\t/* we are told that we should ignore this hierarchy */\n\t\tif (!h->used)\n\t\t\tcontinue;\n\n\t\tentry = calloc(1, sizeof(struct cgroup_process_info));\n\t\tif (!entry)\n\t\t\tgoto out_error;\n\n\t\tentry->meta_ref = lxc_cgroup_get_meta(meta);\n\t\tentry->hierarchy = h;\n\t\tentry->cgroup_path = strdup(colon2);\n\t\tif (!entry->cgroup_path)\n\t\t\tgoto out_error;\n\t\tprune_init_scope(entry->cgroup_path);\n\n\t\t*cptr = entry;\n\t\tcptr = &entry->next;\n\t\tentry = NULL;\n\t}\n\n\tfclose(proc_pid_cgroup);\n\tfree(line);\n\treturn result;\n\nout_error:\n\tsaved_errno = errno;\n\tif (proc_pid_cgroup)\n\t\tfclose(proc_pid_cgroup);\n\tlxc_cgroup_process_info_free(result);\n\tlxc_cgroup_process_info_free(entry);\n\tfree(line);\n\terrno = saved_errno;\n\treturn NULL;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cgroup_process_info *lxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str, struct cgroup_meta_data *meta);",
      "static void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);",
      "static int cgroup_recursive_task_count(const char *cgroup_path);",
      "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "line"
          ],
          "line": 1776
        },
        "resolved": true,
        "details": {
          "function_name": "cgfs_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2501-2518",
          "snippet": "static bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_process_info_free",
          "args": [
            "entry"
          ],
          "line": 1775
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_process_info_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1248-1260",
          "snippet": "void lxc_cgroup_process_info_free(struct cgroup_process_info *info)\n{\n\tstruct cgroup_process_info *next;\n\tif (!info)\n\t\treturn;\n\tnext = info->next;\n\tlxc_cgroup_put_meta(info->meta_ref);\n\tfree(info->cgroup_path);\n\tfree(info->cgroup_path_sub);\n\tlxc_free_array((void **)info->created_paths, free);\n\tfree(info);\n\tlxc_cgroup_process_info_free(next);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_recursive_task_count(const char *cgroup_path);",
            "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);",
            "static void lxc_cgroup_process_info_free(struct cgroup_process_info *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\nstatic void lxc_cgroup_process_info_free(struct cgroup_process_info *info);\n\nvoid lxc_cgroup_process_info_free(struct cgroup_process_info *info)\n{\n\tstruct cgroup_process_info *next;\n\tif (!info)\n\t\treturn;\n\tnext = info->next;\n\tlxc_cgroup_put_meta(info->meta_ref);\n\tfree(info->cgroup_path);\n\tfree(info->cgroup_path_sub);\n\tlxc_free_array((void **)info->created_paths, free);\n\tfree(info);\n\tlxc_cgroup_process_info_free(next);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "proc_pid_cgroup"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "proc_pid_cgroup"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prune_init_scope",
          "args": [
            "entry->cgroup_path"
          ],
          "line": 1759
        },
        "resolved": true,
        "details": {
          "function_name": "prune_init_scope",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgroup.c",
          "lines": "212-228",
          "snippet": "void prune_init_scope(char *cg)\n{\n\tchar *point;\n\n\tif (!cg)\n\t\treturn;\n\n\tpoint = cg + strlen(cg) - strlen(INIT_SCOPE);\n\tif (point < cg)\n\t\treturn;\n\tif (strcmp(point, INIT_SCOPE) == 0) {\n\t\tif (point == cg)\n\t\t\t*(point+1) = '\\0';\n\t\telse\n\t\t\t*point = '\\0';\n\t}\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"log.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [
            "#define INIT_SCOPE \"/init.scope\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"log.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <unistd.h>\n\n#define INIT_SCOPE \"/init.scope\"\n\nvoid prune_init_scope(char *cg)\n{\n\tchar *point;\n\n\tif (!cg)\n\t\treturn;\n\n\tpoint = cg + strlen(cg) - strlen(INIT_SCOPE);\n\tif (point < cg)\n\t\treturn;\n\tif (strcmp(point, INIT_SCOPE) == 0) {\n\t\tif (point == cg)\n\t\t\t*(point+1) = '\\0';\n\t\telse\n\t\t\t*point = '\\0';\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "colon2"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_get_meta",
          "args": [
            "meta"
          ],
          "line": 1754
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_get_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "629-633",
          "snippet": "static struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data)\n{\n\tmeta_data->ref++;\n\treturn meta_data;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);",
            "static struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);\nstatic struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);\n\nstatic struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data)\n{\n\tmeta_data->ref++;\n\treturn meta_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "sizeof(struct cgroup_process_info)"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "line",
            "&endptr",
            "10"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "colon1",
            "\"\""
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "colon1",
            "':'"
          ],
          "line": 1709
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "line"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "line"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&line",
            "&sz",
            "proc_pid_cgroup"
          ],
          "line": 1691
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getline.c",
          "lines": "39-60",
          "snippet": "ssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fopen_cloexec",
          "args": [
            "proc_pid_cgroup_str",
            "\"r\""
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_process_info *lxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str, struct cgroup_meta_data *meta);\nstatic void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\n\nstatic struct cgroup_process_info *\nlxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str,\n\t\t\t     struct cgroup_meta_data *meta)\n{\n\tstruct cgroup_process_info *result = NULL;\n\tFILE *proc_pid_cgroup = NULL;\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tint saved_errno = 0;\n\tstruct cgroup_process_info **cptr = &result;\n\tstruct cgroup_process_info *entry = NULL;\n\n\tproc_pid_cgroup = fopen_cloexec(proc_pid_cgroup_str, \"r\");\n\tif (!proc_pid_cgroup)\n\t\treturn NULL;\n\n\twhile (getline(&line, &sz, proc_pid_cgroup) != -1) {\n\t\t/* file format: hierarchy:subsystems:group */\n\t\tchar *colon1;\n\t\tchar *colon2;\n\t\tchar *endptr;\n\t\tint hierarchy_number;\n\t\tstruct cgroup_hierarchy *h = NULL;\n\n\t\tif (!line[0])\n\t\t\tcontinue;\n\n\t\tif (line[strlen(line) - 1] == '\\n')\n\t\t\tline[strlen(line) - 1] = '\\0';\n\n\t\tcolon1 = strchr(line, ':');\n\t\tif (!colon1)\n\t\t\tcontinue;\n\t\t*colon1++ = '\\0';\n\t\tcolon2 = strchr(colon1, ':');\n\t\tif (!colon2)\n\t\t\tcontinue;\n\t\t*colon2++ = '\\0';\n\n\t\tendptr = NULL;\n\n\t\t/* With cgroupv2 /proc/self/cgroup can contain entries of the\n\t\t * form: 0::/\n\t\t * These entries need to be skipped.\n\t\t */\n\t\tif (!strcmp(colon1, \"\"))\n\t\t\tcontinue;\n\n\t\thierarchy_number = strtoul(line, &endptr, 10);\n\t\tif (!endptr || *endptr)\n\t\t\tcontinue;\n\n\t\tif (hierarchy_number > meta->maximum_hierarchy) {\n\t\t\t/* we encountered a hierarchy we didn't have before,\n\t\t\t * so probably somebody remounted some stuff in the\n\t\t\t * mean time...\n\t\t\t */\n\t\t\terrno = EAGAIN;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\th = meta->hierarchies[hierarchy_number];\n\t\tif (!h) {\n\t\t\t/* we encountered a hierarchy that was thought to be\n\t\t\t * dead before, so probably somebody remounted some\n\t\t\t * stuff in the mean time...\n\t\t\t */\n\t\t\terrno = EAGAIN;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\t/* we are told that we should ignore this hierarchy */\n\t\tif (!h->used)\n\t\t\tcontinue;\n\n\t\tentry = calloc(1, sizeof(struct cgroup_process_info));\n\t\tif (!entry)\n\t\t\tgoto out_error;\n\n\t\tentry->meta_ref = lxc_cgroup_get_meta(meta);\n\t\tentry->hierarchy = h;\n\t\tentry->cgroup_path = strdup(colon2);\n\t\tif (!entry->cgroup_path)\n\t\t\tgoto out_error;\n\t\tprune_init_scope(entry->cgroup_path);\n\n\t\t*cptr = entry;\n\t\tcptr = &entry->next;\n\t\tentry = NULL;\n\t}\n\n\tfclose(proc_pid_cgroup);\n\tfree(line);\n\treturn result;\n\nout_error:\n\tsaved_errno = errno;\n\tif (proc_pid_cgroup)\n\t\tfclose(proc_pid_cgroup);\n\tlxc_cgroup_process_info_free(result);\n\tlxc_cgroup_process_info_free(entry);\n\tfree(line);\n\terrno = saved_errno;\n\treturn NULL;\n}"
  },
  {
    "function_name": "cgfs_nrtasks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "1639-1673",
    "snippet": "static int cgfs_nrtasks(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tstruct cgroup_process_info *info;\n\tstruct cgroup_mount_point *mp = NULL;\n\tchar *abs_path = NULL;\n\tint ret;\n\n\tif (!d) {\n\t\terrno = ENOENT;\n\t\treturn -1;\n\t}\n\n\tinfo = d->info;\n\tif (!info) {\n\t\terrno = ENOENT;\n\t\treturn -1;\n\t}\n\n\tif (info->designated_mount_point) {\n\t\tmp = info->designated_mount_point;\n\t} else {\n\t\tmp = lxc_cgroup_find_mount_point(info->hierarchy, info->cgroup_path, false);\n\t\tif (!mp)\n\t\t\treturn -1;\n\t}\n\n\tabs_path = cgroup_to_absolute_path(mp, info->cgroup_path, NULL);\n\tif (!abs_path)\n\t\treturn -1;\n\n\tret = cgroup_recursive_task_count(abs_path);\n\tfree(abs_path);\n\treturn ret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
      "static int cgroup_recursive_task_count(const char *cgroup_path);",
      "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);",
      "static void lxc_cgroup_process_info_free(struct cgroup_process_info *info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "abs_path"
          ],
          "line": 1671
        },
        "resolved": true,
        "details": {
          "function_name": "cgfs_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2501-2518",
          "snippet": "static bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_recursive_task_count",
          "args": [
            "abs_path"
          ],
          "line": 1670
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_recursive_task_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2111-2157",
          "snippet": "static int cgroup_recursive_task_count(const char *cgroup_path)\n{\n\tDIR *d;\n\tstruct dirent *dent;\n\tint n = 0, r;\n\n\td = opendir(cgroup_path);\n\tif (!d)\n\t\treturn 0;\n\n\twhile ((dent = readdir(d))) {\n\t\tconst char *parts[3] = {\n\t\t\tcgroup_path,\n\t\t\tdent->d_name,\n\t\t\tNULL\n\t\t};\n\t\tchar *sub_path;\n\t\tstruct stat st;\n\n\t\tif (!strcmp(dent->d_name, \".\") || !strcmp(dent->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tsub_path = lxc_string_join(\"/\", parts, false);\n\t\tif (!sub_path) {\n\t\t\tclosedir(d);\n\t\t\treturn -1;\n\t\t}\n\t\tr = stat(sub_path, &st);\n\t\tif (r < 0) {\n\t\t\tclosedir(d);\n\t\t\tfree(sub_path);\n\t\t\treturn -1;\n\t\t}\n\t\tif (S_ISDIR(st.st_mode)) {\n\t\t\tr = cgroup_recursive_task_count(sub_path);\n\t\t\tif (r >= 0)\n\t\t\t\tn += r;\n\t\t} else if (!strcmp(dent->d_name, \"tasks\")) {\n\t\t\tr = lxc_count_file_lines(sub_path);\n\t\t\tif (r >= 0)\n\t\t\t\tn += r;\n\t\t}\n\t\tfree(sub_path);\n\t}\n\tclosedir(d);\n\n\treturn n;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_recursive_task_count(const char *cgroup_path);",
            "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\n\nstatic int cgroup_recursive_task_count(const char *cgroup_path)\n{\n\tDIR *d;\n\tstruct dirent *dent;\n\tint n = 0, r;\n\n\td = opendir(cgroup_path);\n\tif (!d)\n\t\treturn 0;\n\n\twhile ((dent = readdir(d))) {\n\t\tconst char *parts[3] = {\n\t\t\tcgroup_path,\n\t\t\tdent->d_name,\n\t\t\tNULL\n\t\t};\n\t\tchar *sub_path;\n\t\tstruct stat st;\n\n\t\tif (!strcmp(dent->d_name, \".\") || !strcmp(dent->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tsub_path = lxc_string_join(\"/\", parts, false);\n\t\tif (!sub_path) {\n\t\t\tclosedir(d);\n\t\t\treturn -1;\n\t\t}\n\t\tr = stat(sub_path, &st);\n\t\tif (r < 0) {\n\t\t\tclosedir(d);\n\t\t\tfree(sub_path);\n\t\t\treturn -1;\n\t\t}\n\t\tif (S_ISDIR(st.st_mode)) {\n\t\t\tr = cgroup_recursive_task_count(sub_path);\n\t\t\tif (r >= 0)\n\t\t\t\tn += r;\n\t\t} else if (!strcmp(dent->d_name, \"tasks\")) {\n\t\t\tr = lxc_count_file_lines(sub_path);\n\t\t\tif (r >= 0)\n\t\t\t\tn += r;\n\t\t}\n\t\tfree(sub_path);\n\t}\n\tclosedir(d);\n\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_to_absolute_path",
          "args": [
            "mp",
            "info->cgroup_path",
            "NULL"
          ],
          "line": 1666
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_to_absolute_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1901-1944",
          "snippet": "static char *cgroup_to_absolute_path(struct cgroup_mount_point *mp,\n\t\t\t\t     const char *path, const char *suffix)\n{\n\t/* first we have to make sure we subtract the mount point's prefix */\n\tchar *prefix = mp->mount_prefix;\n\tchar *buf;\n\tssize_t len, rv;\n\n\t/* we want to make sure only absolute paths to cgroups are passed to us */\n\tif (path[0] != '/') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (prefix && !strcmp(prefix, \"/\"))\n\t\tprefix = NULL;\n\n\t/* prefix doesn't match */\n\tif (prefix && strncmp(prefix, path, strlen(prefix)) != 0) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\t/* if prefix is /foo and path is /foobar */\n\tif (prefix && path[strlen(prefix)] != '/' && path[strlen(prefix)] != '\\0') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\t/* remove prefix from path */\n\tpath += prefix ? strlen(prefix) : 0;\n\n\tlen = strlen(mp->mount_point) + strlen(path) + (suffix ? strlen(suffix) : 0);\n\tbuf = calloc(len + 1, 1);\n\tif (!buf)\n\t\treturn NULL;\n\trv = snprintf(buf, len + 1, \"%s%s%s\", mp->mount_point, path, suffix ? suffix : \"\");\n\tif (rv > len) {\n\t\tfree(buf);\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\treturn buf;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
            "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
            "static char *cgroup_to_absolute_path(struct cgroup_mount_point *mp, const char *path, const char *suffix);",
            "static int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);",
            "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic char *cgroup_to_absolute_path(struct cgroup_mount_point *mp, const char *path, const char *suffix);\nstatic int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\n\nstatic char *cgroup_to_absolute_path(struct cgroup_mount_point *mp,\n\t\t\t\t     const char *path, const char *suffix)\n{\n\t/* first we have to make sure we subtract the mount point's prefix */\n\tchar *prefix = mp->mount_prefix;\n\tchar *buf;\n\tssize_t len, rv;\n\n\t/* we want to make sure only absolute paths to cgroups are passed to us */\n\tif (path[0] != '/') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (prefix && !strcmp(prefix, \"/\"))\n\t\tprefix = NULL;\n\n\t/* prefix doesn't match */\n\tif (prefix && strncmp(prefix, path, strlen(prefix)) != 0) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\t/* if prefix is /foo and path is /foobar */\n\tif (prefix && path[strlen(prefix)] != '/' && path[strlen(prefix)] != '\\0') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\t/* remove prefix from path */\n\tpath += prefix ? strlen(prefix) : 0;\n\n\tlen = strlen(mp->mount_point) + strlen(path) + (suffix ? strlen(suffix) : 0);\n\tbuf = calloc(len + 1, 1);\n\tif (!buf)\n\t\treturn NULL;\n\trv = snprintf(buf, len + 1, \"%s%s%s\", mp->mount_point, path, suffix ? suffix : \"\");\n\tif (rv > len) {\n\t\tfree(buf);\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_find_mount_point",
          "args": [
            "info->hierarchy",
            "info->cgroup_path",
            "false"
          ],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_find_mount_point",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "670-711",
          "snippet": "static struct cgroup_mount_point *lxc_cgroup_find_mount_point(struct cgroup_hierarchy *hierarchy, const char *group, bool should_be_writable)\n{\n\tstruct cgroup_mount_point **mps;\n\tstruct cgroup_mount_point *current_result = NULL;\n\tssize_t quality = -1;\n\n\t/* trivial case */\n\tif (mountpoint_is_accessible(hierarchy->rw_absolute_mount_point))\n\t\treturn hierarchy->rw_absolute_mount_point;\n\tif (!should_be_writable && mountpoint_is_accessible(hierarchy->ro_absolute_mount_point))\n\t\treturn hierarchy->ro_absolute_mount_point;\n\n\tfor (mps = hierarchy->all_mount_points; mps && *mps; mps++) {\n\t\tstruct cgroup_mount_point *mp = *mps;\n\t\tsize_t prefix_len = mp->mount_prefix ? strlen(mp->mount_prefix) : 0;\n\n\t\tif (prefix_len == 1 && mp->mount_prefix[0] == '/')\n\t\t\tprefix_len = 0;\n\n\t\tif (!mountpoint_is_accessible(mp))\n\t\t\tcontinue;\n\n\t\tif (should_be_writable && mp->read_only)\n\t\t\tcontinue;\n\n\t\tif (!prefix_len ||\n\t\t    (strncmp(group, mp->mount_prefix, prefix_len) == 0 &&\n\t\t     (group[prefix_len] == '\\0' || group[prefix_len] == '/'))) {\n\t\t\t/* search for the best quality match, i.e. the match with the\n\t\t\t * shortest prefix where this group is still contained\n\t\t\t */\n\t\t\tif (quality == -1 || prefix_len < quality) {\n\t\t\t\tcurrent_result = mp;\n\t\t\t\tquality = prefix_len;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!current_result)\n\t\terrno = ENOENT;\n\treturn current_result;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\n\nstatic struct cgroup_mount_point *lxc_cgroup_find_mount_point(struct cgroup_hierarchy *hierarchy, const char *group, bool should_be_writable)\n{\n\tstruct cgroup_mount_point **mps;\n\tstruct cgroup_mount_point *current_result = NULL;\n\tssize_t quality = -1;\n\n\t/* trivial case */\n\tif (mountpoint_is_accessible(hierarchy->rw_absolute_mount_point))\n\t\treturn hierarchy->rw_absolute_mount_point;\n\tif (!should_be_writable && mountpoint_is_accessible(hierarchy->ro_absolute_mount_point))\n\t\treturn hierarchy->ro_absolute_mount_point;\n\n\tfor (mps = hierarchy->all_mount_points; mps && *mps; mps++) {\n\t\tstruct cgroup_mount_point *mp = *mps;\n\t\tsize_t prefix_len = mp->mount_prefix ? strlen(mp->mount_prefix) : 0;\n\n\t\tif (prefix_len == 1 && mp->mount_prefix[0] == '/')\n\t\t\tprefix_len = 0;\n\n\t\tif (!mountpoint_is_accessible(mp))\n\t\t\tcontinue;\n\n\t\tif (should_be_writable && mp->read_only)\n\t\t\tcontinue;\n\n\t\tif (!prefix_len ||\n\t\t    (strncmp(group, mp->mount_prefix, prefix_len) == 0 &&\n\t\t     (group[prefix_len] == '\\0' || group[prefix_len] == '/'))) {\n\t\t\t/* search for the best quality match, i.e. the match with the\n\t\t\t * shortest prefix where this group is still contained\n\t\t\t */\n\t\t\tif (quality == -1 || prefix_len < quality) {\n\t\t\t\tcurrent_result = mp;\n\t\t\t\tquality = prefix_len;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!current_result)\n\t\terrno = ENOENT;\n\treturn current_result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\nstatic void lxc_cgroup_process_info_free(struct cgroup_process_info *info);\n\nstatic int cgfs_nrtasks(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tstruct cgroup_process_info *info;\n\tstruct cgroup_mount_point *mp = NULL;\n\tchar *abs_path = NULL;\n\tint ret;\n\n\tif (!d) {\n\t\terrno = ENOENT;\n\t\treturn -1;\n\t}\n\n\tinfo = d->info;\n\tif (!info) {\n\t\terrno = ENOENT;\n\t\treturn -1;\n\t}\n\n\tif (info->designated_mount_point) {\n\t\tmp = info->designated_mount_point;\n\t} else {\n\t\tmp = lxc_cgroup_find_mount_point(info->hierarchy, info->cgroup_path, false);\n\t\tif (!mp)\n\t\t\treturn -1;\n\t}\n\n\tabs_path = cgroup_to_absolute_path(mp, info->cgroup_path, NULL);\n\tif (!abs_path)\n\t\treturn -1;\n\n\tret = cgroup_recursive_task_count(abs_path);\n\tfree(abs_path);\n\treturn ret;\n}"
  },
  {
    "function_name": "cgroupfs_mount_cgroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "1410-1637",
    "snippet": "static bool cgroupfs_mount_cgroup(void *hdata, const char *root, int type)\n{\n\tsize_t bufsz = strlen(root) + sizeof(\"/sys/fs/cgroup\");\n\tchar *path = NULL;\n\tchar **parts = NULL;\n\tchar *dirname = NULL;\n\tchar *abs_path = NULL;\n\tchar *abs_path2 = NULL;\n\tstruct cgfs_data *cgfs_d;\n\tstruct cgroup_process_info *info, *base_info;\n\tint r, saved_errno = 0;\n\n\tif (cgns_supported())\n\t\treturn true;\n\n\tcgfs_d = hdata;\n\tif (!cgfs_d)\n\t\treturn false;\n\tbase_info = cgfs_d->info;\n\n\t/* If we get passed the _NOSPEC types, we default to _MIXED, since we don't\n\t * have access to the lxc_conf object at this point. It really should be up\n\t * to the caller to fix this, but this doesn't really hurt.\n\t */\n\tif (type == LXC_AUTO_CGROUP_FULL_NOSPEC)\n\t\ttype = LXC_AUTO_CGROUP_FULL_MIXED;\n\telse if (type == LXC_AUTO_CGROUP_NOSPEC)\n\t\ttype = LXC_AUTO_CGROUP_MIXED;\n\n\tif (type < LXC_AUTO_CGROUP_RO || type > LXC_AUTO_CGROUP_FULL_MIXED) {\n\t\tERROR(\"could not mount cgroups into container: invalid type specified internally\");\n\t\terrno = EINVAL;\n\t\treturn false;\n\t}\n\n\tpath = calloc(1, bufsz);\n\tif (!path)\n\t\treturn false;\n\tsnprintf(path, bufsz, \"%s/sys/fs/cgroup\", root);\n\tr = safe_mount(\"cgroup_root\", path, \"tmpfs\",\n\t\t\tMS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME,\n\t\t\t\"size=10240k,mode=755\",\n\t\t\troot);\n\tif (r < 0) {\n\t\tSYSERROR(\"could not mount tmpfs to /sys/fs/cgroup in the container\");\n\t\treturn false;\n\t}\n\n\t/* now mount all the hierarchies we care about */\n\tfor (info = base_info; info; info = info->next) {\n\t\tsize_t subsystem_count, i;\n\t\tstruct cgroup_mount_point *mp = info->designated_mount_point;\n\n\t\tif (!info->hierarchy)\n\t\t\tcontinue;\n\n\t\tif (!mountpoint_is_accessible(mp))\n\t\t\tmp = lxc_cgroup_find_mount_point(info->hierarchy, info->cgroup_path, true);\n\n\t\tif (!mp) {\n\t\t\tSYSERROR(\"could not find original mount point for cgroup hierarchy while trying to mount cgroup filesystem\");\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tsubsystem_count = lxc_array_len((void **)info->hierarchy->subsystems);\n\t\tparts = calloc(subsystem_count + 1, sizeof(char *));\n\t\tif (!parts)\n\t\t\tgoto out_error;\n\n\t\tfor (i = 0; i < subsystem_count; i++) {\n\t\t\tif (!strncmp(info->hierarchy->subsystems[i], \"name=\", 5))\n\t\t\t\tparts[i] = info->hierarchy->subsystems[i] + 5;\n\t\t\telse\n\t\t\t\tparts[i] = info->hierarchy->subsystems[i];\n\t\t}\n\t\tdirname = lxc_string_join(\",\", (const char **)parts, false);\n\t\tif (!dirname)\n\t\t\tgoto out_error;\n\n\t\t/* create subsystem directory */\n\t\tabs_path = lxc_append_paths(path, dirname);\n\t\tif (!abs_path)\n\t\t\tgoto out_error;\n\t\tr = mkdir_p(abs_path, 0755);\n\t\tif (r < 0 && errno != EEXIST) {\n\t\t\tSYSERROR(\"could not create cgroup subsystem directory /sys/fs/cgroup/%s\", dirname);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tabs_path2 = lxc_append_paths(abs_path, info->cgroup_path);\n\t\tif (!abs_path2)\n\t\t\tgoto out_error;\n\n\t\tif (type == LXC_AUTO_CGROUP_FULL_RO || type == LXC_AUTO_CGROUP_FULL_RW || type == LXC_AUTO_CGROUP_FULL_MIXED) {\n\t\t\t/* bind-mount the cgroup entire filesystem there */\n\t\t\tif (strcmp(mp->mount_prefix, \"/\") != 0) {\n\t\t\t\t/* FIXME: maybe we should just try to remount the entire hierarchy\n\t\t\t\t *        with a regular mount command? may that works? */\n\t\t\t\tERROR(\"could not automatically mount cgroup-full to /sys/fs/cgroup/%s: host has no mount point for this cgroup filesystem that has access to the root cgroup\", dirname);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tr = mount(mp->mount_point, abs_path, \"none\", MS_BIND, 0);\n\t\t\tif (r < 0) {\n\t\t\t\tSYSERROR(\"error bind-mounting %s to %s\", mp->mount_point, abs_path);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\t/* main cgroup path should be read-only */\n\t\t\tif (type == LXC_AUTO_CGROUP_FULL_RO || type == LXC_AUTO_CGROUP_FULL_MIXED) {\n\t\t\t\tr = mount(NULL, abs_path, NULL, MS_REMOUNT|MS_BIND|MS_RDONLY, NULL);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tSYSERROR(\"error re-mounting %s readonly\", abs_path);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* own cgroup should be read-write */\n\t\t\tif (type == LXC_AUTO_CGROUP_FULL_MIXED) {\n\t\t\t\tr = mount(abs_path2, abs_path2, NULL, MS_BIND, NULL);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tSYSERROR(\"error bind-mounting %s onto itself\", abs_path2);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t\tr = mount(NULL, abs_path2, NULL, MS_REMOUNT|MS_BIND, NULL);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tSYSERROR(\"error re-mounting %s readwrite\", abs_path2);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/* create path for container's cgroup */\n\t\t\tr = mkdir_p(abs_path2, 0755);\n\t\t\tif (r < 0 && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"could not create cgroup directory /sys/fs/cgroup/%s%s\", dirname, info->cgroup_path);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\n\t\t\t/* for read-only and mixed cases, we have to bind-mount the tmpfs directory\n\t\t\t * that points to the hierarchy itself (i.e. /sys/fs/cgroup/cpu etc.) onto\n\t\t\t * itself and then bind-mount it read-only, since we keep the tmpfs itself\n\t\t\t * read-write (see comment below)\n\t\t\t */\n\t\t\tif (type == LXC_AUTO_CGROUP_MIXED || type == LXC_AUTO_CGROUP_RO) {\n\t\t\t\tr = mount(abs_path, abs_path, NULL, MS_BIND, NULL);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tSYSERROR(\"error bind-mounting %s onto itself\", abs_path);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t\tr = mount(NULL, abs_path, NULL, MS_REMOUNT|MS_BIND|MS_RDONLY, NULL);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tSYSERROR(\"error re-mounting %s readonly\", abs_path);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfree(abs_path);\n\t\t\tabs_path = NULL;\n\n\t\t\t/* bind-mount container's cgroup to that directory */\n\t\t\tabs_path = cgroup_to_absolute_path(mp, info->cgroup_path, NULL);\n\t\t\tif (!abs_path)\n\t\t\t\tgoto out_error;\n\t\t\tr = mount(abs_path, abs_path2, \"none\", MS_BIND, 0);\n\t\t\tif (r < 0 && is_crucial_hierarchy(info->hierarchy)) {\n\t\t\t\tSYSERROR(\"error bind-mounting %s to %s\", abs_path, abs_path2);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tif (type == LXC_AUTO_CGROUP_RO) {\n\t\t\t\tr = mount(NULL, abs_path2, NULL, MS_REMOUNT|MS_BIND|MS_RDONLY, NULL);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tSYSERROR(\"error re-mounting %s readonly\", abs_path2);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfree(abs_path);\n\t\tfree(abs_path2);\n\t\tabs_path = NULL;\n\t\tabs_path2 = NULL;\n\n\t\t/* add symlinks for every single subsystem */\n\t\tif (subsystem_count > 1) {\n\t\t\tfor (i = 0; i < subsystem_count; i++) {\n\t\t\t\tabs_path = lxc_append_paths(path, parts[i]);\n\t\t\t\tif (!abs_path)\n\t\t\t\t\tgoto out_error;\n\t\t\t\tr = symlink(dirname, abs_path);\n\t\t\t\tif (r < 0)\n\t\t\t\t\tWARN(\"could not create symlink %s -> %s in /sys/fs/cgroup of container\", parts[i], dirname);\n\t\t\t\tfree(abs_path);\n\t\t\t\tabs_path = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(dirname);\n\t\tfree(parts);\n\t\tdirname = NULL;\n\t\tparts = NULL;\n\t}\n\n\t/* We used to remount the entire tmpfs readonly if any :ro or\n\t * :mixed mode was specified. However, Ubuntu's mountall has the\n\t * unfortunate behavior to block bootup if /sys/fs/cgroup is\n\t * mounted read-only and cannot be remounted read-write.\n\t * (mountall reads /lib/init/fstab and tries to (re-)mount all of\n\t * these if they are not already mounted with the right options;\n\t * it contains an entry for /sys/fs/cgroup. In case it can't do\n\t * that, it prompts for the user to either manually fix it or\n\t * boot anyway. But without user input, booting of the container\n\t * hangs.)\n\t *\n\t * Instead of remounting the entire tmpfs readonly, we only\n\t * remount the paths readonly that are part of the cgroup\n\t * hierarchy.\n\t */\n\n\tfree(path);\n\n\treturn true;\n\nout_error:\n\tsaved_errno = errno;\n\tfree(path);\n\tfree(dirname);\n\tfree(parts);\n\tfree(abs_path);\n\tfree(abs_path2);\n\terrno = saved_errno;\n\treturn false;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
      "static bool is_valid_cgroup(const char *name);",
      "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
      "static struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);",
      "static int cgroup_recursive_task_count(const char *cgroup_path);",
      "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);",
      "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);",
      "static void lxc_cgroup_process_info_free(struct cgroup_process_info *info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "abs_path2"
          ],
          "line": 1634
        },
        "resolved": true,
        "details": {
          "function_name": "cgfs_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2501-2518",
          "snippet": "static bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"could not create symlink %s -> %s in /sys/fs/cgroup of container\"",
            "parts[i]",
            "dirname"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "symlink",
          "args": [
            "dirname",
            "abs_path"
          ],
          "line": 1595
        },
        "resolved": true,
        "details": {
          "function_name": "open_without_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1616-1677",
          "snippet": "static int open_without_symlink(const char *target, const char *prefix_skip)\n{\n\tint curlen = 0, dirfd, fulllen, i;\n\tchar *dup = NULL;\n\n\tfulllen = strlen(target);\n\n\t/* make sure prefix-skip makes sense */\n\tif (prefix_skip && strlen(prefix_skip) > 0) {\n\t\tcurlen = strlen(prefix_skip);\n\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n\t\t\tERROR(\"WHOA there - target '%s' didn't start with prefix '%s'\",\n\t\t\t\ttarget, prefix_skip);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/*\n\t\t * get_nextpath() expects the curlen argument to be\n\t\t * on a  (turned into \\0) / or before it, so decrement\n\t\t * curlen to make sure that happens\n\t\t */\n\t\tif (curlen)\n\t\t\tcurlen--;\n\t} else {\n\t\tprefix_skip = \"/\";\n\t\tcurlen = 0;\n\t}\n\n\t/* Make a copy of target which we can hack up, and tokenize it */\n\tif ((dup = strdup(target)) == NULL) {\n\t\tSYSERROR(\"Out of memory checking for symbolic link\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < fulllen; i++) {\n\t\tif (dup[i] == '/')\n\t\t\tdup[i] = '\\0';\n\t}\n\n\tdirfd = open(prefix_skip, O_RDONLY);\n\tif (dirfd < 0)\n\t\tgoto out;\n\twhile (1) {\n\t\tint newfd, saved_errno;\n\t\tchar *nextpath;\n\n\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n\t\t\tgoto out;\n\t\tnewfd = open_if_safe(dirfd, nextpath);\n\t\tsaved_errno = errno;\n\t\tclose(dirfd);\n\t\tdirfd = newfd;\n\t\tif (newfd < 0) {\n\t\t\terrno = saved_errno;\n\t\t\tif (errno == ELOOP)\n\t\t\t\tSYSERROR(\"%s in %s was a symbolic link!\", nextpath, target);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfree(dup);\n\treturn dirfd;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int open_without_symlink(const char *target, const char *prefix_skip)\n{\n\tint curlen = 0, dirfd, fulllen, i;\n\tchar *dup = NULL;\n\n\tfulllen = strlen(target);\n\n\t/* make sure prefix-skip makes sense */\n\tif (prefix_skip && strlen(prefix_skip) > 0) {\n\t\tcurlen = strlen(prefix_skip);\n\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n\t\t\tERROR(\"WHOA there - target '%s' didn't start with prefix '%s'\",\n\t\t\t\ttarget, prefix_skip);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/*\n\t\t * get_nextpath() expects the curlen argument to be\n\t\t * on a  (turned into \\0) / or before it, so decrement\n\t\t * curlen to make sure that happens\n\t\t */\n\t\tif (curlen)\n\t\t\tcurlen--;\n\t} else {\n\t\tprefix_skip = \"/\";\n\t\tcurlen = 0;\n\t}\n\n\t/* Make a copy of target which we can hack up, and tokenize it */\n\tif ((dup = strdup(target)) == NULL) {\n\t\tSYSERROR(\"Out of memory checking for symbolic link\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < fulllen; i++) {\n\t\tif (dup[i] == '/')\n\t\t\tdup[i] = '\\0';\n\t}\n\n\tdirfd = open(prefix_skip, O_RDONLY);\n\tif (dirfd < 0)\n\t\tgoto out;\n\twhile (1) {\n\t\tint newfd, saved_errno;\n\t\tchar *nextpath;\n\n\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n\t\t\tgoto out;\n\t\tnewfd = open_if_safe(dirfd, nextpath);\n\t\tsaved_errno = errno;\n\t\tclose(dirfd);\n\t\tdirfd = newfd;\n\t\tif (newfd < 0) {\n\t\t\terrno = saved_errno;\n\t\t\tif (errno == ELOOP)\n\t\t\t\tSYSERROR(\"%s in %s was a symbolic link!\", nextpath, target);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfree(dup);\n\treturn dirfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_append_paths",
          "args": [
            "path",
            "parts[i]"
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_append_paths",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "768-785",
          "snippet": "char *lxc_append_paths(const char *first, const char *second)\n{\n\tsize_t len = strlen(first) + strlen(second) + 1;\n\tconst char *pattern = \"%s%s\";\n\tchar *result = NULL;\n\n\tif (second[0] != '/') {\n\t\tlen += 1;\n\t\tpattern = \"%s/%s\";\n\t}\n\n\tresult = calloc(1, len);\n\tif (!result)\n\t\treturn NULL;\n\n\tsnprintf(result, len, pattern, first, second);\n\treturn result;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *lxc_append_paths(const char *first, const char *second)\n{\n\tsize_t len = strlen(first) + strlen(second) + 1;\n\tconst char *pattern = \"%s%s\";\n\tchar *result = NULL;\n\n\tif (second[0] != '/') {\n\t\tlen += 1;\n\t\tpattern = \"%s/%s\";\n\t}\n\n\tresult = calloc(1, len);\n\tif (!result)\n\t\treturn NULL;\n\n\tsnprintf(result, len, pattern, first, second);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"error re-mounting %s readonly\"",
            "abs_path2"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "NULL",
            "abs_path2",
            "NULL",
            "MS_REMOUNT|MS_BIND|MS_RDONLY",
            "NULL"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "do_secondstage_mounts_if_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1545-1576",
          "snippet": "static int\ndo_secondstage_mounts_if_needed(int type, struct hierarchy *h,\n\t\t\t\tchar *controllerpath, char *cgpath,\n\t\t\t\tconst char *container_cgroup)\n{\n\tif (type == LXC_AUTO_CGROUP_RO || type == LXC_AUTO_CGROUP_MIXED) {\n\t\tif (mount(controllerpath, controllerpath, \"cgroup\", MS_BIND, NULL) < 0) {\n\t\t\tSYSERROR(\"Error bind-mounting %s\", controllerpath);\n\t\t\treturn -1;\n\t\t}\n\t\tif (mount(controllerpath, controllerpath, \"cgroup\",\n\t\t\t   MS_REMOUNT | MS_BIND | MS_RDONLY, NULL) < 0) {\n\t\t\tSYSERROR(\"Error remounting %s read-only\", controllerpath);\n\t\t\treturn -1;\n\t\t}\n\t\tINFO(\"Remounted %s read-only\", controllerpath);\n\t}\n\tchar *sourcepath = must_make_path(h->mountpoint, h->base_cgroup, container_cgroup, NULL);\n\tint flags = MS_BIND;\n\tif (type == LXC_AUTO_CGROUP_RO)\n\t\tflags |= MS_RDONLY;\n\tINFO(\"Mounting %s onto %s\", sourcepath, cgpath);\n\tif (mount(sourcepath, cgpath, \"cgroup\", flags, NULL) < 0) {\n\t\tfree(sourcepath);\n\t\tSYSERROR(\"Error mounting cgroup %s onto %s\", h->controllers[0],\n\t\t\t\tcgpath);\n\t\treturn -1;\n\t}\n\tfree(sourcepath);\n\tINFO(\"Completed second stage cgroup automounts for %s\", cgpath);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int\ndo_secondstage_mounts_if_needed(int type, struct hierarchy *h,\n\t\t\t\tchar *controllerpath, char *cgpath,\n\t\t\t\tconst char *container_cgroup)\n{\n\tif (type == LXC_AUTO_CGROUP_RO || type == LXC_AUTO_CGROUP_MIXED) {\n\t\tif (mount(controllerpath, controllerpath, \"cgroup\", MS_BIND, NULL) < 0) {\n\t\t\tSYSERROR(\"Error bind-mounting %s\", controllerpath);\n\t\t\treturn -1;\n\t\t}\n\t\tif (mount(controllerpath, controllerpath, \"cgroup\",\n\t\t\t   MS_REMOUNT | MS_BIND | MS_RDONLY, NULL) < 0) {\n\t\t\tSYSERROR(\"Error remounting %s read-only\", controllerpath);\n\t\t\treturn -1;\n\t\t}\n\t\tINFO(\"Remounted %s read-only\", controllerpath);\n\t}\n\tchar *sourcepath = must_make_path(h->mountpoint, h->base_cgroup, container_cgroup, NULL);\n\tint flags = MS_BIND;\n\tif (type == LXC_AUTO_CGROUP_RO)\n\t\tflags |= MS_RDONLY;\n\tINFO(\"Mounting %s onto %s\", sourcepath, cgpath);\n\tif (mount(sourcepath, cgpath, \"cgroup\", flags, NULL) < 0) {\n\t\tfree(sourcepath);\n\t\tSYSERROR(\"Error mounting cgroup %s onto %s\", h->controllers[0],\n\t\t\t\tcgpath);\n\t\treturn -1;\n\t}\n\tfree(sourcepath);\n\tINFO(\"Completed second stage cgroup automounts for %s\", cgpath);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"error bind-mounting %s to %s\"",
            "abs_path",
            "abs_path2"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_crucial_hierarchy",
          "args": [
            "info->hierarchy"
          ],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "is_crucial_hierarchy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "836-845",
          "snippet": "static bool is_crucial_hierarchy(struct cgroup_hierarchy *h)\n{\n\tchar **p;\n\n\tfor (p = h->subsystems; *p; p++) {\n\t\tif (is_crucial_cgroup_subsystem(*p))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);\n\nstatic bool is_crucial_hierarchy(struct cgroup_hierarchy *h)\n{\n\tchar **p;\n\n\tfor (p = h->subsystems; *p; p++) {\n\t\tif (is_crucial_cgroup_subsystem(*p))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_to_absolute_path",
          "args": [
            "mp",
            "info->cgroup_path",
            "NULL"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_to_absolute_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1901-1944",
          "snippet": "static char *cgroup_to_absolute_path(struct cgroup_mount_point *mp,\n\t\t\t\t     const char *path, const char *suffix)\n{\n\t/* first we have to make sure we subtract the mount point's prefix */\n\tchar *prefix = mp->mount_prefix;\n\tchar *buf;\n\tssize_t len, rv;\n\n\t/* we want to make sure only absolute paths to cgroups are passed to us */\n\tif (path[0] != '/') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (prefix && !strcmp(prefix, \"/\"))\n\t\tprefix = NULL;\n\n\t/* prefix doesn't match */\n\tif (prefix && strncmp(prefix, path, strlen(prefix)) != 0) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\t/* if prefix is /foo and path is /foobar */\n\tif (prefix && path[strlen(prefix)] != '/' && path[strlen(prefix)] != '\\0') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\t/* remove prefix from path */\n\tpath += prefix ? strlen(prefix) : 0;\n\n\tlen = strlen(mp->mount_point) + strlen(path) + (suffix ? strlen(suffix) : 0);\n\tbuf = calloc(len + 1, 1);\n\tif (!buf)\n\t\treturn NULL;\n\trv = snprintf(buf, len + 1, \"%s%s%s\", mp->mount_point, path, suffix ? suffix : \"\");\n\tif (rv > len) {\n\t\tfree(buf);\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\treturn buf;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
            "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
            "static char *cgroup_to_absolute_path(struct cgroup_mount_point *mp, const char *path, const char *suffix);",
            "static int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);",
            "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic char *cgroup_to_absolute_path(struct cgroup_mount_point *mp, const char *path, const char *suffix);\nstatic int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\n\nstatic char *cgroup_to_absolute_path(struct cgroup_mount_point *mp,\n\t\t\t\t     const char *path, const char *suffix)\n{\n\t/* first we have to make sure we subtract the mount point's prefix */\n\tchar *prefix = mp->mount_prefix;\n\tchar *buf;\n\tssize_t len, rv;\n\n\t/* we want to make sure only absolute paths to cgroups are passed to us */\n\tif (path[0] != '/') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (prefix && !strcmp(prefix, \"/\"))\n\t\tprefix = NULL;\n\n\t/* prefix doesn't match */\n\tif (prefix && strncmp(prefix, path, strlen(prefix)) != 0) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\t/* if prefix is /foo and path is /foobar */\n\tif (prefix && path[strlen(prefix)] != '/' && path[strlen(prefix)] != '\\0') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\t/* remove prefix from path */\n\tpath += prefix ? strlen(prefix) : 0;\n\n\tlen = strlen(mp->mount_point) + strlen(path) + (suffix ? strlen(suffix) : 0);\n\tbuf = calloc(len + 1, 1);\n\tif (!buf)\n\t\treturn NULL;\n\trv = snprintf(buf, len + 1, \"%s%s%s\", mp->mount_point, path, suffix ? suffix : \"\");\n\tif (rv > len) {\n\t\tfree(buf);\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"error re-mounting %s readonly\"",
            "abs_path"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"error bind-mounting %s onto itself\"",
            "abs_path"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"could not create cgroup directory /sys/fs/cgroup/%s%s\"",
            "dirname",
            "info->cgroup_path"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir_p",
          "args": [
            "abs_path2",
            "0755"
          ],
          "line": 1539
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "241-262",
          "snippet": "extern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"error re-mounting %s readwrite\"",
            "abs_path2"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"error bind-mounting %s onto itself\"",
            "abs_path2"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"error re-mounting %s readonly\"",
            "abs_path"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"error bind-mounting %s to %s\"",
            "mp->mount_point",
            "abs_path"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"could not automatically mount cgroup-full to /sys/fs/cgroup/%s: host has no mount point for this cgroup filesystem that has access to the root cgroup\"",
            "dirname"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mp->mount_prefix",
            "\"/\""
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"could not create cgroup subsystem directory /sys/fs/cgroup/%s\"",
            "dirname"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_string_join",
          "args": [
            "\",\"",
            "(const char **)parts",
            "false"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_join",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "664-688",
          "snippet": "char *lxc_string_join(const char *sep, const char **parts, bool use_as_prefix)\n{\n\tchar *result;\n\tchar **p;\n\tsize_t sep_len = strlen(sep);\n\tsize_t result_len = use_as_prefix * sep_len;\n\n\t/* calculate new string length */\n\tfor (p = (char **)parts; *p; p++)\n\t\tresult_len += (p > (char **)parts) * sep_len + strlen(*p);\n\n\tresult = calloc(result_len + 1, 1);\n\tif (!result)\n\t\treturn NULL;\n\n\tif (use_as_prefix)\n\t\tstrcpy(result, sep);\n\tfor (p = (char **)parts; *p; p++) {\n\t\tif (p > (char **)parts)\n\t\t\tstrcat(result, sep);\n\t\tstrcat(result, *p);\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *lxc_string_join(const char *sep, const char **parts, bool use_as_prefix)\n{\n\tchar *result;\n\tchar **p;\n\tsize_t sep_len = strlen(sep);\n\tsize_t result_len = use_as_prefix * sep_len;\n\n\t/* calculate new string length */\n\tfor (p = (char **)parts; *p; p++)\n\t\tresult_len += (p > (char **)parts) * sep_len + strlen(*p);\n\n\tresult = calloc(result_len + 1, 1);\n\tif (!result)\n\t\treturn NULL;\n\n\tif (use_as_prefix)\n\t\tstrcpy(result, sep);\n\tfor (p = (char **)parts; *p; p++) {\n\t\tif (p > (char **)parts)\n\t\t\tstrcat(result, sep);\n\t\tstrcat(result, *p);\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "info->hierarchy->subsystems[i]",
            "\"name=\"",
            "5"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "subsystem_count + 1",
            "sizeof(char *)"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_array_len",
          "args": [
            "(void **)info->hierarchy->subsystems"
          ],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_array_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "923-932",
          "snippet": "size_t lxc_array_len(void **array)\n{\n\tvoid **p;\n\tsize_t result = 0;\n\n\tfor (p = array; p && *p; p++)\n\t\tresult++;\n\n\treturn result;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nsize_t lxc_array_len(void **array)\n{\n\tvoid **p;\n\tsize_t result = 0;\n\n\tfor (p = array; p && *p; p++)\n\t\tresult++;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"could not find original mount point for cgroup hierarchy while trying to mount cgroup filesystem\""
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_find_mount_point",
          "args": [
            "info->hierarchy",
            "info->cgroup_path",
            "true"
          ],
          "line": 1467
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_find_mount_point",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "670-711",
          "snippet": "static struct cgroup_mount_point *lxc_cgroup_find_mount_point(struct cgroup_hierarchy *hierarchy, const char *group, bool should_be_writable)\n{\n\tstruct cgroup_mount_point **mps;\n\tstruct cgroup_mount_point *current_result = NULL;\n\tssize_t quality = -1;\n\n\t/* trivial case */\n\tif (mountpoint_is_accessible(hierarchy->rw_absolute_mount_point))\n\t\treturn hierarchy->rw_absolute_mount_point;\n\tif (!should_be_writable && mountpoint_is_accessible(hierarchy->ro_absolute_mount_point))\n\t\treturn hierarchy->ro_absolute_mount_point;\n\n\tfor (mps = hierarchy->all_mount_points; mps && *mps; mps++) {\n\t\tstruct cgroup_mount_point *mp = *mps;\n\t\tsize_t prefix_len = mp->mount_prefix ? strlen(mp->mount_prefix) : 0;\n\n\t\tif (prefix_len == 1 && mp->mount_prefix[0] == '/')\n\t\t\tprefix_len = 0;\n\n\t\tif (!mountpoint_is_accessible(mp))\n\t\t\tcontinue;\n\n\t\tif (should_be_writable && mp->read_only)\n\t\t\tcontinue;\n\n\t\tif (!prefix_len ||\n\t\t    (strncmp(group, mp->mount_prefix, prefix_len) == 0 &&\n\t\t     (group[prefix_len] == '\\0' || group[prefix_len] == '/'))) {\n\t\t\t/* search for the best quality match, i.e. the match with the\n\t\t\t * shortest prefix where this group is still contained\n\t\t\t */\n\t\t\tif (quality == -1 || prefix_len < quality) {\n\t\t\t\tcurrent_result = mp;\n\t\t\t\tquality = prefix_len;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!current_result)\n\t\terrno = ENOENT;\n\treturn current_result;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\n\nstatic struct cgroup_mount_point *lxc_cgroup_find_mount_point(struct cgroup_hierarchy *hierarchy, const char *group, bool should_be_writable)\n{\n\tstruct cgroup_mount_point **mps;\n\tstruct cgroup_mount_point *current_result = NULL;\n\tssize_t quality = -1;\n\n\t/* trivial case */\n\tif (mountpoint_is_accessible(hierarchy->rw_absolute_mount_point))\n\t\treturn hierarchy->rw_absolute_mount_point;\n\tif (!should_be_writable && mountpoint_is_accessible(hierarchy->ro_absolute_mount_point))\n\t\treturn hierarchy->ro_absolute_mount_point;\n\n\tfor (mps = hierarchy->all_mount_points; mps && *mps; mps++) {\n\t\tstruct cgroup_mount_point *mp = *mps;\n\t\tsize_t prefix_len = mp->mount_prefix ? strlen(mp->mount_prefix) : 0;\n\n\t\tif (prefix_len == 1 && mp->mount_prefix[0] == '/')\n\t\t\tprefix_len = 0;\n\n\t\tif (!mountpoint_is_accessible(mp))\n\t\t\tcontinue;\n\n\t\tif (should_be_writable && mp->read_only)\n\t\t\tcontinue;\n\n\t\tif (!prefix_len ||\n\t\t    (strncmp(group, mp->mount_prefix, prefix_len) == 0 &&\n\t\t     (group[prefix_len] == '\\0' || group[prefix_len] == '/'))) {\n\t\t\t/* search for the best quality match, i.e. the match with the\n\t\t\t * shortest prefix where this group is still contained\n\t\t\t */\n\t\t\tif (quality == -1 || prefix_len < quality) {\n\t\t\t\tcurrent_result = mp;\n\t\t\t\tquality = prefix_len;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!current_result)\n\t\terrno = ENOENT;\n\treturn current_result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mountpoint_is_accessible",
          "args": [
            "mp"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "mountpoint_is_accessible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "665-668",
          "snippet": "static bool mountpoint_is_accessible(struct cgroup_mount_point *mp)\n{\n\treturn mp && access(mp->mount_point, F_OK) == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\n\nstatic bool mountpoint_is_accessible(struct cgroup_mount_point *mp)\n{\n\treturn mp && access(mp->mount_point, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"could not mount tmpfs to /sys/fs/cgroup in the container\""
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_mount",
          "args": [
            "\"cgroup_root\"",
            "path",
            "\"tmpfs\"",
            "MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME",
            "\"size=10240k,mode=755\"",
            "root"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "safe_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1687-1743",
          "snippet": "int safe_mount(const char *src, const char *dest, const char *fstype,\n\t\tunsigned long flags, const void *data, const char *rootfs)\n{\n\tint srcfd = -1, destfd, ret, saved_errno;\n\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n\tconst char *mntsrc = src;\n\n\tif (!rootfs)\n\t\trootfs = \"\";\n\n\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n\tif (flags & MS_BIND && src && src[0] != '/') {\n\t\tINFO(\"this is a relative bind mount\");\n\t\tsrcfd = open_without_symlink(src, NULL);\n\t\tif (srcfd < 0)\n\t\t\treturn srcfd;\n\t\tret = snprintf(srcbuf, 50, \"/proc/self/fd/%d\", srcfd);\n\t\tif (ret < 0 || ret > 50) {\n\t\t\tclose(srcfd);\n\t\t\tERROR(\"Out of memory\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmntsrc = srcbuf;\n\t}\n\n\tdestfd = open_without_symlink(dest, rootfs);\n\tif (destfd < 0) {\n\t\tif (srcfd != -1) {\n\t\t\tsaved_errno = errno;\n\t\t\tclose(srcfd);\n\t\t\terrno = saved_errno;\n\t\t}\n\t\treturn destfd;\n\t}\n\n\tret = snprintf(destbuf, 50, \"/proc/self/fd/%d\", destfd);\n\tif (ret < 0 || ret > 50) {\n\t\tif (srcfd != -1)\n\t\t\tclose(srcfd);\n\t\tclose(destfd);\n\t\tERROR(\"Out of memory\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = mount(mntsrc, destbuf, fstype, flags, data);\n\tsaved_errno = errno;\n\tif (srcfd != -1)\n\t\tclose(srcfd);\n\tclose(destfd);\n\tif (ret < 0) {\n\t\terrno = saved_errno;\n\t\tSYSERROR(\"Failed to mount %s onto %s\", src, dest);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint safe_mount(const char *src, const char *dest, const char *fstype,\n\t\tunsigned long flags, const void *data, const char *rootfs)\n{\n\tint srcfd = -1, destfd, ret, saved_errno;\n\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n\tconst char *mntsrc = src;\n\n\tif (!rootfs)\n\t\trootfs = \"\";\n\n\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n\tif (flags & MS_BIND && src && src[0] != '/') {\n\t\tINFO(\"this is a relative bind mount\");\n\t\tsrcfd = open_without_symlink(src, NULL);\n\t\tif (srcfd < 0)\n\t\t\treturn srcfd;\n\t\tret = snprintf(srcbuf, 50, \"/proc/self/fd/%d\", srcfd);\n\t\tif (ret < 0 || ret > 50) {\n\t\t\tclose(srcfd);\n\t\t\tERROR(\"Out of memory\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmntsrc = srcbuf;\n\t}\n\n\tdestfd = open_without_symlink(dest, rootfs);\n\tif (destfd < 0) {\n\t\tif (srcfd != -1) {\n\t\t\tsaved_errno = errno;\n\t\t\tclose(srcfd);\n\t\t\terrno = saved_errno;\n\t\t}\n\t\treturn destfd;\n\t}\n\n\tret = snprintf(destbuf, 50, \"/proc/self/fd/%d\", destfd);\n\tif (ret < 0 || ret > 50) {\n\t\tif (srcfd != -1)\n\t\t\tclose(srcfd);\n\t\tclose(destfd);\n\t\tERROR(\"Out of memory\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = mount(mntsrc, destbuf, fstype, flags, data);\n\tsaved_errno = errno;\n\tif (srcfd != -1)\n\t\tclose(srcfd);\n\tclose(destfd);\n\tif (ret < 0) {\n\t\terrno = saved_errno;\n\t\tSYSERROR(\"Failed to mount %s onto %s\", src, dest);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "bufsz",
            "\"%s/sys/fs/cgroup\"",
            "root"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "bufsz"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"could not mount cgroups into container: invalid type specified internally\""
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgns_supported",
          "args": [],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "cgns_supported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1247-1250",
          "snippet": "bool cgns_supported(void)\n{\n\treturn file_exists(\"/proc/self/ns/cgroup\");\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool cgns_supported(void)\n{\n\treturn file_exists(\"/proc/self/ns/cgroup\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "root"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic bool is_valid_cgroup(const char *name);\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\nstatic void lxc_cgroup_process_info_free(struct cgroup_process_info *info);\n\nstatic bool cgroupfs_mount_cgroup(void *hdata, const char *root, int type)\n{\n\tsize_t bufsz = strlen(root) + sizeof(\"/sys/fs/cgroup\");\n\tchar *path = NULL;\n\tchar **parts = NULL;\n\tchar *dirname = NULL;\n\tchar *abs_path = NULL;\n\tchar *abs_path2 = NULL;\n\tstruct cgfs_data *cgfs_d;\n\tstruct cgroup_process_info *info, *base_info;\n\tint r, saved_errno = 0;\n\n\tif (cgns_supported())\n\t\treturn true;\n\n\tcgfs_d = hdata;\n\tif (!cgfs_d)\n\t\treturn false;\n\tbase_info = cgfs_d->info;\n\n\t/* If we get passed the _NOSPEC types, we default to _MIXED, since we don't\n\t * have access to the lxc_conf object at this point. It really should be up\n\t * to the caller to fix this, but this doesn't really hurt.\n\t */\n\tif (type == LXC_AUTO_CGROUP_FULL_NOSPEC)\n\t\ttype = LXC_AUTO_CGROUP_FULL_MIXED;\n\telse if (type == LXC_AUTO_CGROUP_NOSPEC)\n\t\ttype = LXC_AUTO_CGROUP_MIXED;\n\n\tif (type < LXC_AUTO_CGROUP_RO || type > LXC_AUTO_CGROUP_FULL_MIXED) {\n\t\tERROR(\"could not mount cgroups into container: invalid type specified internally\");\n\t\terrno = EINVAL;\n\t\treturn false;\n\t}\n\n\tpath = calloc(1, bufsz);\n\tif (!path)\n\t\treturn false;\n\tsnprintf(path, bufsz, \"%s/sys/fs/cgroup\", root);\n\tr = safe_mount(\"cgroup_root\", path, \"tmpfs\",\n\t\t\tMS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME,\n\t\t\t\"size=10240k,mode=755\",\n\t\t\troot);\n\tif (r < 0) {\n\t\tSYSERROR(\"could not mount tmpfs to /sys/fs/cgroup in the container\");\n\t\treturn false;\n\t}\n\n\t/* now mount all the hierarchies we care about */\n\tfor (info = base_info; info; info = info->next) {\n\t\tsize_t subsystem_count, i;\n\t\tstruct cgroup_mount_point *mp = info->designated_mount_point;\n\n\t\tif (!info->hierarchy)\n\t\t\tcontinue;\n\n\t\tif (!mountpoint_is_accessible(mp))\n\t\t\tmp = lxc_cgroup_find_mount_point(info->hierarchy, info->cgroup_path, true);\n\n\t\tif (!mp) {\n\t\t\tSYSERROR(\"could not find original mount point for cgroup hierarchy while trying to mount cgroup filesystem\");\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tsubsystem_count = lxc_array_len((void **)info->hierarchy->subsystems);\n\t\tparts = calloc(subsystem_count + 1, sizeof(char *));\n\t\tif (!parts)\n\t\t\tgoto out_error;\n\n\t\tfor (i = 0; i < subsystem_count; i++) {\n\t\t\tif (!strncmp(info->hierarchy->subsystems[i], \"name=\", 5))\n\t\t\t\tparts[i] = info->hierarchy->subsystems[i] + 5;\n\t\t\telse\n\t\t\t\tparts[i] = info->hierarchy->subsystems[i];\n\t\t}\n\t\tdirname = lxc_string_join(\",\", (const char **)parts, false);\n\t\tif (!dirname)\n\t\t\tgoto out_error;\n\n\t\t/* create subsystem directory */\n\t\tabs_path = lxc_append_paths(path, dirname);\n\t\tif (!abs_path)\n\t\t\tgoto out_error;\n\t\tr = mkdir_p(abs_path, 0755);\n\t\tif (r < 0 && errno != EEXIST) {\n\t\t\tSYSERROR(\"could not create cgroup subsystem directory /sys/fs/cgroup/%s\", dirname);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tabs_path2 = lxc_append_paths(abs_path, info->cgroup_path);\n\t\tif (!abs_path2)\n\t\t\tgoto out_error;\n\n\t\tif (type == LXC_AUTO_CGROUP_FULL_RO || type == LXC_AUTO_CGROUP_FULL_RW || type == LXC_AUTO_CGROUP_FULL_MIXED) {\n\t\t\t/* bind-mount the cgroup entire filesystem there */\n\t\t\tif (strcmp(mp->mount_prefix, \"/\") != 0) {\n\t\t\t\t/* FIXME: maybe we should just try to remount the entire hierarchy\n\t\t\t\t *        with a regular mount command? may that works? */\n\t\t\t\tERROR(\"could not automatically mount cgroup-full to /sys/fs/cgroup/%s: host has no mount point for this cgroup filesystem that has access to the root cgroup\", dirname);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tr = mount(mp->mount_point, abs_path, \"none\", MS_BIND, 0);\n\t\t\tif (r < 0) {\n\t\t\t\tSYSERROR(\"error bind-mounting %s to %s\", mp->mount_point, abs_path);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\t/* main cgroup path should be read-only */\n\t\t\tif (type == LXC_AUTO_CGROUP_FULL_RO || type == LXC_AUTO_CGROUP_FULL_MIXED) {\n\t\t\t\tr = mount(NULL, abs_path, NULL, MS_REMOUNT|MS_BIND|MS_RDONLY, NULL);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tSYSERROR(\"error re-mounting %s readonly\", abs_path);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* own cgroup should be read-write */\n\t\t\tif (type == LXC_AUTO_CGROUP_FULL_MIXED) {\n\t\t\t\tr = mount(abs_path2, abs_path2, NULL, MS_BIND, NULL);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tSYSERROR(\"error bind-mounting %s onto itself\", abs_path2);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t\tr = mount(NULL, abs_path2, NULL, MS_REMOUNT|MS_BIND, NULL);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tSYSERROR(\"error re-mounting %s readwrite\", abs_path2);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/* create path for container's cgroup */\n\t\t\tr = mkdir_p(abs_path2, 0755);\n\t\t\tif (r < 0 && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"could not create cgroup directory /sys/fs/cgroup/%s%s\", dirname, info->cgroup_path);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\n\t\t\t/* for read-only and mixed cases, we have to bind-mount the tmpfs directory\n\t\t\t * that points to the hierarchy itself (i.e. /sys/fs/cgroup/cpu etc.) onto\n\t\t\t * itself and then bind-mount it read-only, since we keep the tmpfs itself\n\t\t\t * read-write (see comment below)\n\t\t\t */\n\t\t\tif (type == LXC_AUTO_CGROUP_MIXED || type == LXC_AUTO_CGROUP_RO) {\n\t\t\t\tr = mount(abs_path, abs_path, NULL, MS_BIND, NULL);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tSYSERROR(\"error bind-mounting %s onto itself\", abs_path);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t\tr = mount(NULL, abs_path, NULL, MS_REMOUNT|MS_BIND|MS_RDONLY, NULL);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tSYSERROR(\"error re-mounting %s readonly\", abs_path);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfree(abs_path);\n\t\t\tabs_path = NULL;\n\n\t\t\t/* bind-mount container's cgroup to that directory */\n\t\t\tabs_path = cgroup_to_absolute_path(mp, info->cgroup_path, NULL);\n\t\t\tif (!abs_path)\n\t\t\t\tgoto out_error;\n\t\t\tr = mount(abs_path, abs_path2, \"none\", MS_BIND, 0);\n\t\t\tif (r < 0 && is_crucial_hierarchy(info->hierarchy)) {\n\t\t\t\tSYSERROR(\"error bind-mounting %s to %s\", abs_path, abs_path2);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tif (type == LXC_AUTO_CGROUP_RO) {\n\t\t\t\tr = mount(NULL, abs_path2, NULL, MS_REMOUNT|MS_BIND|MS_RDONLY, NULL);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tSYSERROR(\"error re-mounting %s readonly\", abs_path2);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfree(abs_path);\n\t\tfree(abs_path2);\n\t\tabs_path = NULL;\n\t\tabs_path2 = NULL;\n\n\t\t/* add symlinks for every single subsystem */\n\t\tif (subsystem_count > 1) {\n\t\t\tfor (i = 0; i < subsystem_count; i++) {\n\t\t\t\tabs_path = lxc_append_paths(path, parts[i]);\n\t\t\t\tif (!abs_path)\n\t\t\t\t\tgoto out_error;\n\t\t\t\tr = symlink(dirname, abs_path);\n\t\t\t\tif (r < 0)\n\t\t\t\t\tWARN(\"could not create symlink %s -> %s in /sys/fs/cgroup of container\", parts[i], dirname);\n\t\t\t\tfree(abs_path);\n\t\t\t\tabs_path = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(dirname);\n\t\tfree(parts);\n\t\tdirname = NULL;\n\t\tparts = NULL;\n\t}\n\n\t/* We used to remount the entire tmpfs readonly if any :ro or\n\t * :mixed mode was specified. However, Ubuntu's mountall has the\n\t * unfortunate behavior to block bootup if /sys/fs/cgroup is\n\t * mounted read-only and cannot be remounted read-write.\n\t * (mountall reads /lib/init/fstab and tries to (re-)mount all of\n\t * these if they are not already mounted with the right options;\n\t * it contains an entry for /sys/fs/cgroup. In case it can't do\n\t * that, it prompts for the user to either manually fix it or\n\t * boot anyway. But without user input, booting of the container\n\t * hangs.)\n\t *\n\t * Instead of remounting the entire tmpfs readonly, we only\n\t * remount the paths readonly that are part of the cgroup\n\t * hierarchy.\n\t */\n\n\tfree(path);\n\n\treturn true;\n\nout_error:\n\tsaved_errno = errno;\n\tfree(path);\n\tfree(dirname);\n\tfree(parts);\n\tfree(abs_path);\n\tfree(abs_path2);\n\terrno = saved_errno;\n\treturn false;\n}"
  },
  {
    "function_name": "lxc_cgroupfs_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "1392-1408",
    "snippet": "static int lxc_cgroupfs_get(const char *filename, char *value, size_t len, const char *name, const char *lxcpath)\n{\n\tchar *subsystem = NULL, *p, *path;\n\tint ret = -1;\n\n\tsubsystem = alloca(strlen(filename) + 1);\n\tstrcpy(subsystem, filename);\n\tif ((p = strchr(subsystem, '.')) != NULL)\n\t\t*p = '\\0';\n\n\tpath = lxc_cgroup_get_hierarchy_abs_path(subsystem, name, lxcpath);\n\tif (path) {\n\t\tret = do_cgroup_get(path, filename, value, len);\n\t\tfree(path);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_valid_cgroup(const char *name);",
      "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
      "static struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);",
      "static int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);",
      "static int do_cgroup_set(const char *cgroup_path, const char *sub_filename, const char *value);",
      "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "path"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "cgfs_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2501-2518",
          "snippet": "static bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_cgroup_get",
          "args": [
            "path",
            "filename",
            "value",
            "len"
          ],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "do_cgroup_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1961-1981",
          "snippet": "static int do_cgroup_get(const char *cgroup_path, const char *sub_filename,\n\t\t\t char *value, size_t len)\n{\n\tconst char *parts[3] = {\n\t\tcgroup_path,\n\t\tsub_filename,\n\t\tNULL\n\t};\n\tchar *filename;\n\tint ret, saved_errno;\n\n\tfilename = lxc_string_join(\"/\", parts, false);\n\tif (!filename)\n\t\treturn -1;\n\n\tret = lxc_read_from_file(filename, value, len);\n\tsaved_errno = errno;\n\tfree(filename);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);",
            "static int do_cgroup_set(const char *cgroup_path, const char *sub_filename, const char *value);",
            "static int cgroup_recursive_task_count(const char *cgroup_path);",
            "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);\nstatic int do_cgroup_set(const char *cgroup_path, const char *sub_filename, const char *value);\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\n\nstatic int do_cgroup_get(const char *cgroup_path, const char *sub_filename,\n\t\t\t char *value, size_t len)\n{\n\tconst char *parts[3] = {\n\t\tcgroup_path,\n\t\tsub_filename,\n\t\tNULL\n\t};\n\tchar *filename;\n\tint ret, saved_errno;\n\n\tfilename = lxc_string_join(\"/\", parts, false);\n\tif (!filename)\n\t\treturn -1;\n\n\tret = lxc_read_from_file(filename, value, len);\n\tsaved_errno = errno;\n\tfree(filename);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_get_hierarchy_abs_path",
          "args": [
            "subsystem",
            "name",
            "lxcpath"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_get_hierarchy_abs_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1321-1351",
          "snippet": "static char *lxc_cgroup_get_hierarchy_abs_path(const char *subsystem, const char *name, const char *lxcpath)\n{\n\tstruct cgroup_meta_data *meta;\n\tstruct cgroup_process_info *base_info, *info;\n\tstruct cgroup_mount_point *mp;\n\tchar *result = NULL;\n\n\tmeta = lxc_cgroup_load_meta();\n\tif (!meta)\n\t\treturn NULL;\n\tbase_info = lxc_cgroup_get_container_info(name, lxcpath, meta);\n\tif (!base_info)\n\t\tgoto out1;\n\tinfo = find_info_for_subsystem(base_info, subsystem);\n\tif (!info)\n\t\tgoto out2;\n\tif (info->designated_mount_point) {\n\t\tmp = info->designated_mount_point;\n\t} else {\n\t\tmp = lxc_cgroup_find_mount_point(info->hierarchy, info->cgroup_path, true);\n\t\tif (!mp)\n\t\t\tgoto out3;\n\t}\n\tresult = cgroup_to_absolute_path(mp, info->cgroup_path, NULL);\nout3:\nout2:\n\tlxc_cgroup_process_info_free(base_info);\nout1:\n\tlxc_cgroup_put_meta(meta);\n\treturn result;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_process_info *lxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str, struct cgroup_meta_data *meta);",
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
            "static bool is_valid_cgroup(const char *name);",
            "static struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);",
            "static int cgroup_recursive_task_count(const char *cgroup_path);",
            "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);",
            "static void lxc_cgroup_process_info_free(struct cgroup_process_info *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_process_info *lxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str, struct cgroup_meta_data *meta);\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic bool is_valid_cgroup(const char *name);\nstatic struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\nstatic void lxc_cgroup_process_info_free(struct cgroup_process_info *info);\n\nstatic char *lxc_cgroup_get_hierarchy_abs_path(const char *subsystem, const char *name, const char *lxcpath)\n{\n\tstruct cgroup_meta_data *meta;\n\tstruct cgroup_process_info *base_info, *info;\n\tstruct cgroup_mount_point *mp;\n\tchar *result = NULL;\n\n\tmeta = lxc_cgroup_load_meta();\n\tif (!meta)\n\t\treturn NULL;\n\tbase_info = lxc_cgroup_get_container_info(name, lxcpath, meta);\n\tif (!base_info)\n\t\tgoto out1;\n\tinfo = find_info_for_subsystem(base_info, subsystem);\n\tif (!info)\n\t\tgoto out2;\n\tif (info->designated_mount_point) {\n\t\tmp = info->designated_mount_point;\n\t} else {\n\t\tmp = lxc_cgroup_find_mount_point(info->hierarchy, info->cgroup_path, true);\n\t\tif (!mp)\n\t\t\tgoto out3;\n\t}\n\tresult = cgroup_to_absolute_path(mp, info->cgroup_path, NULL);\nout3:\nout2:\n\tlxc_cgroup_process_info_free(base_info);\nout1:\n\tlxc_cgroup_put_meta(meta);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "subsystem",
            "'.'"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "subsystem",
            "filename"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "strlen(filename) + 1"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "filename"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool is_valid_cgroup(const char *name);\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);\nstatic int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);\nstatic int do_cgroup_set(const char *cgroup_path, const char *sub_filename, const char *value);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\n\nstatic int lxc_cgroupfs_get(const char *filename, char *value, size_t len, const char *name, const char *lxcpath)\n{\n\tchar *subsystem = NULL, *p, *path;\n\tint ret = -1;\n\n\tsubsystem = alloca(strlen(filename) + 1);\n\tstrcpy(subsystem, filename);\n\tif ((p = strchr(subsystem, '.')) != NULL)\n\t\t*p = '\\0';\n\n\tpath = lxc_cgroup_get_hierarchy_abs_path(subsystem, name, lxcpath);\n\tif (path) {\n\t\tret = do_cgroup_get(path, filename, value, len);\n\t\tfree(path);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "lxc_cgroupfs_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "1374-1390",
    "snippet": "static int lxc_cgroupfs_set(const char *filename, const char *value, const char *name, const char *lxcpath)\n{\n\tchar *subsystem = NULL, *p, *path;\n\tint ret = -1;\n\n\tsubsystem = alloca(strlen(filename) + 1);\n\tstrcpy(subsystem, filename);\n\tif ((p = strchr(subsystem, '.')) != NULL)\n\t\t*p = '\\0';\n\n\tpath = lxc_cgroup_get_hierarchy_abs_path(subsystem, name, lxcpath);\n\tif (path) {\n\t\tret = do_cgroup_set(path, filename, value);\n\t\tfree(path);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_valid_cgroup(const char *name);",
      "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
      "static struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);",
      "static int do_cgroup_set(const char *cgroup_path, const char *sub_filename, const char *value);",
      "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "path"
          ],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "cgfs_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2501-2518",
          "snippet": "static bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_cgroup_set",
          "args": [
            "path",
            "filename",
            "value"
          ],
          "line": 1386
        },
        "resolved": true,
        "details": {
          "function_name": "do_cgroup_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1983-2003",
          "snippet": "static int do_cgroup_set(const char *cgroup_path, const char *sub_filename,\n\t\t\t const char *value)\n{\n\tconst char *parts[3] = {\n\t\tcgroup_path,\n\t\tsub_filename,\n\t\tNULL\n\t};\n\tchar *filename;\n\tint ret, saved_errno;\n\n\tfilename = lxc_string_join(\"/\", parts, false);\n\tif (!filename)\n\t\treturn -1;\n\n\tret = lxc_write_to_file(filename, value, strlen(value), false);\n\tsaved_errno = errno;\n\tfree(filename);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int do_cgroup_set(const char *cgroup_path, const char *sub_filename, const char *value);",
            "static int cgroup_recursive_task_count(const char *cgroup_path);",
            "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int do_cgroup_set(const char *cgroup_path, const char *sub_filename, const char *value);\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\n\nstatic int do_cgroup_set(const char *cgroup_path, const char *sub_filename,\n\t\t\t const char *value)\n{\n\tconst char *parts[3] = {\n\t\tcgroup_path,\n\t\tsub_filename,\n\t\tNULL\n\t};\n\tchar *filename;\n\tint ret, saved_errno;\n\n\tfilename = lxc_string_join(\"/\", parts, false);\n\tif (!filename)\n\t\treturn -1;\n\n\tret = lxc_write_to_file(filename, value, strlen(value), false);\n\tsaved_errno = errno;\n\tfree(filename);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_get_hierarchy_abs_path",
          "args": [
            "subsystem",
            "name",
            "lxcpath"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_get_hierarchy_abs_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1321-1351",
          "snippet": "static char *lxc_cgroup_get_hierarchy_abs_path(const char *subsystem, const char *name, const char *lxcpath)\n{\n\tstruct cgroup_meta_data *meta;\n\tstruct cgroup_process_info *base_info, *info;\n\tstruct cgroup_mount_point *mp;\n\tchar *result = NULL;\n\n\tmeta = lxc_cgroup_load_meta();\n\tif (!meta)\n\t\treturn NULL;\n\tbase_info = lxc_cgroup_get_container_info(name, lxcpath, meta);\n\tif (!base_info)\n\t\tgoto out1;\n\tinfo = find_info_for_subsystem(base_info, subsystem);\n\tif (!info)\n\t\tgoto out2;\n\tif (info->designated_mount_point) {\n\t\tmp = info->designated_mount_point;\n\t} else {\n\t\tmp = lxc_cgroup_find_mount_point(info->hierarchy, info->cgroup_path, true);\n\t\tif (!mp)\n\t\t\tgoto out3;\n\t}\n\tresult = cgroup_to_absolute_path(mp, info->cgroup_path, NULL);\nout3:\nout2:\n\tlxc_cgroup_process_info_free(base_info);\nout1:\n\tlxc_cgroup_put_meta(meta);\n\treturn result;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_process_info *lxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str, struct cgroup_meta_data *meta);",
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
            "static bool is_valid_cgroup(const char *name);",
            "static struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);",
            "static int cgroup_recursive_task_count(const char *cgroup_path);",
            "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);",
            "static void lxc_cgroup_process_info_free(struct cgroup_process_info *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_process_info *lxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str, struct cgroup_meta_data *meta);\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic bool is_valid_cgroup(const char *name);\nstatic struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\nstatic void lxc_cgroup_process_info_free(struct cgroup_process_info *info);\n\nstatic char *lxc_cgroup_get_hierarchy_abs_path(const char *subsystem, const char *name, const char *lxcpath)\n{\n\tstruct cgroup_meta_data *meta;\n\tstruct cgroup_process_info *base_info, *info;\n\tstruct cgroup_mount_point *mp;\n\tchar *result = NULL;\n\n\tmeta = lxc_cgroup_load_meta();\n\tif (!meta)\n\t\treturn NULL;\n\tbase_info = lxc_cgroup_get_container_info(name, lxcpath, meta);\n\tif (!base_info)\n\t\tgoto out1;\n\tinfo = find_info_for_subsystem(base_info, subsystem);\n\tif (!info)\n\t\tgoto out2;\n\tif (info->designated_mount_point) {\n\t\tmp = info->designated_mount_point;\n\t} else {\n\t\tmp = lxc_cgroup_find_mount_point(info->hierarchy, info->cgroup_path, true);\n\t\tif (!mp)\n\t\t\tgoto out3;\n\t}\n\tresult = cgroup_to_absolute_path(mp, info->cgroup_path, NULL);\nout3:\nout2:\n\tlxc_cgroup_process_info_free(base_info);\nout1:\n\tlxc_cgroup_put_meta(meta);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "subsystem",
            "'.'"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "subsystem",
            "filename"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "strlen(filename) + 1"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "filename"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool is_valid_cgroup(const char *name);\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);\nstatic int do_cgroup_set(const char *cgroup_path, const char *sub_filename, const char *value);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\n\nstatic int lxc_cgroupfs_set(const char *filename, const char *value, const char *name, const char *lxcpath)\n{\n\tchar *subsystem = NULL, *p, *path;\n\tint ret = -1;\n\n\tsubsystem = alloca(strlen(filename) + 1);\n\tstrcpy(subsystem, filename);\n\tif ((p = strchr(subsystem, '.')) != NULL)\n\t\t*p = '\\0';\n\n\tpath = lxc_cgroup_get_hierarchy_abs_path(subsystem, name, lxcpath);\n\tif (path) {\n\t\tret = do_cgroup_set(path, filename, value);\n\t\tfree(path);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "lxc_cgroup_set_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "1353-1372",
    "snippet": "static int lxc_cgroup_set_data(const char *filename, const char *value, struct cgfs_data *d)\n{\n\tchar *subsystem = NULL, *p, *path;\n\tint ret = -1;\n\n\tsubsystem = alloca(strlen(filename) + 1);\n\tstrcpy(subsystem, filename);\n\tif ((p = strchr(subsystem, '.')) != NULL)\n\t\t*p = '\\0';\n\n\terrno = ENOENT;\n\tpath = lxc_cgroup_get_hierarchy_abs_path_data(subsystem, d);\n\tif (path) {\n\t\tret = do_cgroup_set(path, filename, value);\n\t\tint saved_errno = errno;\n\t\tfree(path);\n\t\terrno = saved_errno;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
      "static struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);",
      "static int do_cgroup_set(const char *cgroup_path, const char *sub_filename, const char *value);",
      "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "path"
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "cgfs_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2501-2518",
          "snippet": "static bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_cgroup_set",
          "args": [
            "path",
            "filename",
            "value"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "do_cgroup_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1983-2003",
          "snippet": "static int do_cgroup_set(const char *cgroup_path, const char *sub_filename,\n\t\t\t const char *value)\n{\n\tconst char *parts[3] = {\n\t\tcgroup_path,\n\t\tsub_filename,\n\t\tNULL\n\t};\n\tchar *filename;\n\tint ret, saved_errno;\n\n\tfilename = lxc_string_join(\"/\", parts, false);\n\tif (!filename)\n\t\treturn -1;\n\n\tret = lxc_write_to_file(filename, value, strlen(value), false);\n\tsaved_errno = errno;\n\tfree(filename);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int do_cgroup_set(const char *cgroup_path, const char *sub_filename, const char *value);",
            "static int cgroup_recursive_task_count(const char *cgroup_path);",
            "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int do_cgroup_set(const char *cgroup_path, const char *sub_filename, const char *value);\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\n\nstatic int do_cgroup_set(const char *cgroup_path, const char *sub_filename,\n\t\t\t const char *value)\n{\n\tconst char *parts[3] = {\n\t\tcgroup_path,\n\t\tsub_filename,\n\t\tNULL\n\t};\n\tchar *filename;\n\tint ret, saved_errno;\n\n\tfilename = lxc_string_join(\"/\", parts, false);\n\tif (!filename)\n\t\treturn -1;\n\n\tret = lxc_write_to_file(filename, value, strlen(value), false);\n\tsaved_errno = errno;\n\tfree(filename);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_get_hierarchy_abs_path_data",
          "args": [
            "subsystem",
            "d"
          ],
          "line": 1364
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_get_hierarchy_abs_path_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1303-1319",
          "snippet": "static char *lxc_cgroup_get_hierarchy_abs_path_data(const char *subsystem, struct cgfs_data *d)\n{\n\tstruct cgroup_process_info *info = d->info;\n\tstruct cgroup_mount_point *mp = NULL;\n\n\tinfo = find_info_for_subsystem(info, subsystem);\n\tif (!info)\n\t\treturn NULL;\n\tif (info->designated_mount_point) {\n\t\tmp = info->designated_mount_point;\n\t} else {\n\t\tmp = lxc_cgroup_find_mount_point(info->hierarchy, info->cgroup_path, true);\n\t\tif (!mp)\n\t\t\treturn NULL;\n\t}\n\treturn cgroup_to_absolute_path(mp, info->cgroup_path, NULL);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
            "static struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);",
            "static int cgroup_recursive_task_count(const char *cgroup_path);",
            "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);",
            "static void lxc_cgroup_process_info_free(struct cgroup_process_info *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\nstatic void lxc_cgroup_process_info_free(struct cgroup_process_info *info);\n\nstatic char *lxc_cgroup_get_hierarchy_abs_path_data(const char *subsystem, struct cgfs_data *d)\n{\n\tstruct cgroup_process_info *info = d->info;\n\tstruct cgroup_mount_point *mp = NULL;\n\n\tinfo = find_info_for_subsystem(info, subsystem);\n\tif (!info)\n\t\treturn NULL;\n\tif (info->designated_mount_point) {\n\t\tmp = info->designated_mount_point;\n\t} else {\n\t\tmp = lxc_cgroup_find_mount_point(info->hierarchy, info->cgroup_path, true);\n\t\tif (!mp)\n\t\t\treturn NULL;\n\t}\n\treturn cgroup_to_absolute_path(mp, info->cgroup_path, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "subsystem",
            "'.'"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "subsystem",
            "filename"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "strlen(filename) + 1"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "filename"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);\nstatic int do_cgroup_set(const char *cgroup_path, const char *sub_filename, const char *value);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\n\nstatic int lxc_cgroup_set_data(const char *filename, const char *value, struct cgfs_data *d)\n{\n\tchar *subsystem = NULL, *p, *path;\n\tint ret = -1;\n\n\tsubsystem = alloca(strlen(filename) + 1);\n\tstrcpy(subsystem, filename);\n\tif ((p = strchr(subsystem, '.')) != NULL)\n\t\t*p = '\\0';\n\n\terrno = ENOENT;\n\tpath = lxc_cgroup_get_hierarchy_abs_path_data(subsystem, d);\n\tif (path) {\n\t\tret = do_cgroup_set(path, filename, value);\n\t\tint saved_errno = errno;\n\t\tfree(path);\n\t\terrno = saved_errno;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "lxc_cgroup_get_hierarchy_abs_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "1321-1351",
    "snippet": "static char *lxc_cgroup_get_hierarchy_abs_path(const char *subsystem, const char *name, const char *lxcpath)\n{\n\tstruct cgroup_meta_data *meta;\n\tstruct cgroup_process_info *base_info, *info;\n\tstruct cgroup_mount_point *mp;\n\tchar *result = NULL;\n\n\tmeta = lxc_cgroup_load_meta();\n\tif (!meta)\n\t\treturn NULL;\n\tbase_info = lxc_cgroup_get_container_info(name, lxcpath, meta);\n\tif (!base_info)\n\t\tgoto out1;\n\tinfo = find_info_for_subsystem(base_info, subsystem);\n\tif (!info)\n\t\tgoto out2;\n\tif (info->designated_mount_point) {\n\t\tmp = info->designated_mount_point;\n\t} else {\n\t\tmp = lxc_cgroup_find_mount_point(info->hierarchy, info->cgroup_path, true);\n\t\tif (!mp)\n\t\t\tgoto out3;\n\t}\n\tresult = cgroup_to_absolute_path(mp, info->cgroup_path, NULL);\nout3:\nout2:\n\tlxc_cgroup_process_info_free(base_info);\nout1:\n\tlxc_cgroup_put_meta(meta);\n\treturn result;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cgroup_process_info *lxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str, struct cgroup_meta_data *meta);",
      "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
      "static bool is_valid_cgroup(const char *name);",
      "static struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);",
      "static int cgroup_recursive_task_count(const char *cgroup_path);",
      "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);",
      "static void lxc_cgroup_process_info_free(struct cgroup_process_info *info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_cgroup_put_meta",
          "args": [
            "meta"
          ],
          "line": 1349
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_put_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "635-650",
          "snippet": "static struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data)\n{\n\tsize_t i;\n\tif (!meta_data)\n\t\treturn NULL;\n\tif (--meta_data->ref > 0)\n\t\treturn meta_data;\n\tlxc_free_array((void **)meta_data->mount_points, (lxc_free_fn)lxc_cgroup_mount_point_free);\n\tif (meta_data->hierarchies)\n\t\tfor (i = 0; i <= meta_data->maximum_hierarchy; i++)\n\t\t\tif (meta_data->hierarchies[i])\n\t\t\t\tlxc_cgroup_hierarchy_free(meta_data->hierarchies[i]);\n\tfree(meta_data->hierarchies);\n\tfree(meta_data);\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);",
            "static struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);\nstatic struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);\n\nstatic struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data)\n{\n\tsize_t i;\n\tif (!meta_data)\n\t\treturn NULL;\n\tif (--meta_data->ref > 0)\n\t\treturn meta_data;\n\tlxc_free_array((void **)meta_data->mount_points, (lxc_free_fn)lxc_cgroup_mount_point_free);\n\tif (meta_data->hierarchies)\n\t\tfor (i = 0; i <= meta_data->maximum_hierarchy; i++)\n\t\t\tif (meta_data->hierarchies[i])\n\t\t\t\tlxc_cgroup_hierarchy_free(meta_data->hierarchies[i]);\n\tfree(meta_data->hierarchies);\n\tfree(meta_data);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_process_info_free",
          "args": [
            "base_info"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_process_info_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1248-1260",
          "snippet": "void lxc_cgroup_process_info_free(struct cgroup_process_info *info)\n{\n\tstruct cgroup_process_info *next;\n\tif (!info)\n\t\treturn;\n\tnext = info->next;\n\tlxc_cgroup_put_meta(info->meta_ref);\n\tfree(info->cgroup_path);\n\tfree(info->cgroup_path_sub);\n\tlxc_free_array((void **)info->created_paths, free);\n\tfree(info);\n\tlxc_cgroup_process_info_free(next);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_recursive_task_count(const char *cgroup_path);",
            "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);",
            "static void lxc_cgroup_process_info_free(struct cgroup_process_info *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\nstatic void lxc_cgroup_process_info_free(struct cgroup_process_info *info);\n\nvoid lxc_cgroup_process_info_free(struct cgroup_process_info *info)\n{\n\tstruct cgroup_process_info *next;\n\tif (!info)\n\t\treturn;\n\tnext = info->next;\n\tlxc_cgroup_put_meta(info->meta_ref);\n\tfree(info->cgroup_path);\n\tfree(info->cgroup_path_sub);\n\tlxc_free_array((void **)info->created_paths, free);\n\tfree(info);\n\tlxc_cgroup_process_info_free(next);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_to_absolute_path",
          "args": [
            "mp",
            "info->cgroup_path",
            "NULL"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_to_absolute_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1901-1944",
          "snippet": "static char *cgroup_to_absolute_path(struct cgroup_mount_point *mp,\n\t\t\t\t     const char *path, const char *suffix)\n{\n\t/* first we have to make sure we subtract the mount point's prefix */\n\tchar *prefix = mp->mount_prefix;\n\tchar *buf;\n\tssize_t len, rv;\n\n\t/* we want to make sure only absolute paths to cgroups are passed to us */\n\tif (path[0] != '/') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (prefix && !strcmp(prefix, \"/\"))\n\t\tprefix = NULL;\n\n\t/* prefix doesn't match */\n\tif (prefix && strncmp(prefix, path, strlen(prefix)) != 0) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\t/* if prefix is /foo and path is /foobar */\n\tif (prefix && path[strlen(prefix)] != '/' && path[strlen(prefix)] != '\\0') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\t/* remove prefix from path */\n\tpath += prefix ? strlen(prefix) : 0;\n\n\tlen = strlen(mp->mount_point) + strlen(path) + (suffix ? strlen(suffix) : 0);\n\tbuf = calloc(len + 1, 1);\n\tif (!buf)\n\t\treturn NULL;\n\trv = snprintf(buf, len + 1, \"%s%s%s\", mp->mount_point, path, suffix ? suffix : \"\");\n\tif (rv > len) {\n\t\tfree(buf);\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\treturn buf;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
            "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
            "static char *cgroup_to_absolute_path(struct cgroup_mount_point *mp, const char *path, const char *suffix);",
            "static int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);",
            "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic char *cgroup_to_absolute_path(struct cgroup_mount_point *mp, const char *path, const char *suffix);\nstatic int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\n\nstatic char *cgroup_to_absolute_path(struct cgroup_mount_point *mp,\n\t\t\t\t     const char *path, const char *suffix)\n{\n\t/* first we have to make sure we subtract the mount point's prefix */\n\tchar *prefix = mp->mount_prefix;\n\tchar *buf;\n\tssize_t len, rv;\n\n\t/* we want to make sure only absolute paths to cgroups are passed to us */\n\tif (path[0] != '/') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (prefix && !strcmp(prefix, \"/\"))\n\t\tprefix = NULL;\n\n\t/* prefix doesn't match */\n\tif (prefix && strncmp(prefix, path, strlen(prefix)) != 0) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\t/* if prefix is /foo and path is /foobar */\n\tif (prefix && path[strlen(prefix)] != '/' && path[strlen(prefix)] != '\\0') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\t/* remove prefix from path */\n\tpath += prefix ? strlen(prefix) : 0;\n\n\tlen = strlen(mp->mount_point) + strlen(path) + (suffix ? strlen(suffix) : 0);\n\tbuf = calloc(len + 1, 1);\n\tif (!buf)\n\t\treturn NULL;\n\trv = snprintf(buf, len + 1, \"%s%s%s\", mp->mount_point, path, suffix ? suffix : \"\");\n\tif (rv > len) {\n\t\tfree(buf);\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_find_mount_point",
          "args": [
            "info->hierarchy",
            "info->cgroup_path",
            "true"
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_find_mount_point",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "670-711",
          "snippet": "static struct cgroup_mount_point *lxc_cgroup_find_mount_point(struct cgroup_hierarchy *hierarchy, const char *group, bool should_be_writable)\n{\n\tstruct cgroup_mount_point **mps;\n\tstruct cgroup_mount_point *current_result = NULL;\n\tssize_t quality = -1;\n\n\t/* trivial case */\n\tif (mountpoint_is_accessible(hierarchy->rw_absolute_mount_point))\n\t\treturn hierarchy->rw_absolute_mount_point;\n\tif (!should_be_writable && mountpoint_is_accessible(hierarchy->ro_absolute_mount_point))\n\t\treturn hierarchy->ro_absolute_mount_point;\n\n\tfor (mps = hierarchy->all_mount_points; mps && *mps; mps++) {\n\t\tstruct cgroup_mount_point *mp = *mps;\n\t\tsize_t prefix_len = mp->mount_prefix ? strlen(mp->mount_prefix) : 0;\n\n\t\tif (prefix_len == 1 && mp->mount_prefix[0] == '/')\n\t\t\tprefix_len = 0;\n\n\t\tif (!mountpoint_is_accessible(mp))\n\t\t\tcontinue;\n\n\t\tif (should_be_writable && mp->read_only)\n\t\t\tcontinue;\n\n\t\tif (!prefix_len ||\n\t\t    (strncmp(group, mp->mount_prefix, prefix_len) == 0 &&\n\t\t     (group[prefix_len] == '\\0' || group[prefix_len] == '/'))) {\n\t\t\t/* search for the best quality match, i.e. the match with the\n\t\t\t * shortest prefix where this group is still contained\n\t\t\t */\n\t\t\tif (quality == -1 || prefix_len < quality) {\n\t\t\t\tcurrent_result = mp;\n\t\t\t\tquality = prefix_len;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!current_result)\n\t\terrno = ENOENT;\n\treturn current_result;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\n\nstatic struct cgroup_mount_point *lxc_cgroup_find_mount_point(struct cgroup_hierarchy *hierarchy, const char *group, bool should_be_writable)\n{\n\tstruct cgroup_mount_point **mps;\n\tstruct cgroup_mount_point *current_result = NULL;\n\tssize_t quality = -1;\n\n\t/* trivial case */\n\tif (mountpoint_is_accessible(hierarchy->rw_absolute_mount_point))\n\t\treturn hierarchy->rw_absolute_mount_point;\n\tif (!should_be_writable && mountpoint_is_accessible(hierarchy->ro_absolute_mount_point))\n\t\treturn hierarchy->ro_absolute_mount_point;\n\n\tfor (mps = hierarchy->all_mount_points; mps && *mps; mps++) {\n\t\tstruct cgroup_mount_point *mp = *mps;\n\t\tsize_t prefix_len = mp->mount_prefix ? strlen(mp->mount_prefix) : 0;\n\n\t\tif (prefix_len == 1 && mp->mount_prefix[0] == '/')\n\t\t\tprefix_len = 0;\n\n\t\tif (!mountpoint_is_accessible(mp))\n\t\t\tcontinue;\n\n\t\tif (should_be_writable && mp->read_only)\n\t\t\tcontinue;\n\n\t\tif (!prefix_len ||\n\t\t    (strncmp(group, mp->mount_prefix, prefix_len) == 0 &&\n\t\t     (group[prefix_len] == '\\0' || group[prefix_len] == '/'))) {\n\t\t\t/* search for the best quality match, i.e. the match with the\n\t\t\t * shortest prefix where this group is still contained\n\t\t\t */\n\t\t\tif (quality == -1 || prefix_len < quality) {\n\t\t\t\tcurrent_result = mp;\n\t\t\t\tquality = prefix_len;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!current_result)\n\t\terrno = ENOENT;\n\treturn current_result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_info_for_subsystem",
          "args": [
            "base_info",
            "subsystem"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "find_info_for_subsystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1946-1959",
          "snippet": "static struct cgroup_process_info *\nfind_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem)\n{\n\tstruct cgroup_process_info *info_ptr;\n\tfor (info_ptr = info; info_ptr; info_ptr = info_ptr->next) {\n\t\tstruct cgroup_hierarchy *h = info_ptr->hierarchy;\n\t\tif (!h)\n\t\t\tcontinue;\n\t\tif (lxc_string_in_array(subsystem, (const char **)h->subsystems))\n\t\t\treturn info_ptr;\n\t}\n\terrno = ENOENT;\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);",
            "static struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);",
            "static void lxc_cgroup_process_info_free(struct cgroup_process_info *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);\nstatic struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);\nstatic void lxc_cgroup_process_info_free(struct cgroup_process_info *info);\n\nstatic struct cgroup_process_info *\nfind_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem)\n{\n\tstruct cgroup_process_info *info_ptr;\n\tfor (info_ptr = info; info_ptr; info_ptr = info_ptr->next) {\n\t\tstruct cgroup_hierarchy *h = info_ptr->hierarchy;\n\t\tif (!h)\n\t\t\tcontinue;\n\t\tif (lxc_string_in_array(subsystem, (const char **)h->subsystems))\n\t\t\treturn info_ptr;\n\t}\n\terrno = ENOENT;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_get_container_info",
          "args": [
            "name",
            "lxcpath",
            "meta"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_get_container_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1156-1203",
          "snippet": "static struct cgroup_process_info *lxc_cgroup_get_container_info(const char *name, const char *lxcpath, struct cgroup_meta_data *meta_data)\n{\n\tstruct cgroup_process_info *result = NULL;\n\tint saved_errno = 0;\n\tsize_t i;\n\tstruct cgroup_process_info **cptr = &result;\n\tstruct cgroup_process_info *entry = NULL;\n\tchar *path = NULL;\n\n\tfor (i = 0; i <= meta_data->maximum_hierarchy; i++) {\n\t\tstruct cgroup_hierarchy *h = meta_data->hierarchies[i];\n\t\tif (!h || !h->used)\n\t\t\tcontinue;\n\n\t\t/* use the command interface to look for the cgroup */\n\t\tpath = lxc_cmd_get_cgroup_path(name, lxcpath, h->subsystems[0]);\n\t\tif (!path) {\n\t\t\th->used = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tentry = calloc(1, sizeof(struct cgroup_process_info));\n\t\tif (!entry)\n\t\t\tgoto out_error;\n\t\tentry->meta_ref = lxc_cgroup_get_meta(meta_data);\n\t\tentry->hierarchy = h;\n\t\tentry->cgroup_path = path;\n\t\tpath = NULL;\n\n\t\t/* it is not an error if we don't find anything here,\n\t\t * it is up to the caller to decide what to do in that\n\t\t * case */\n\t\tentry->designated_mount_point = lxc_cgroup_find_mount_point(h, entry->cgroup_path, true);\n\n\t\t*cptr = entry;\n\t\tcptr = &entry->next;\n\t\tentry = NULL;\n\t}\n\n\treturn result;\nout_error:\n\tsaved_errno = errno;\n\tfree(path);\n\tlxc_cgroup_process_info_free(result);\n\tlxc_cgroup_process_info_free(entry);\n\terrno = saved_errno;\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);",
            "static bool is_valid_cgroup(const char *name);",
            "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
            "static int cgroup_recursive_task_count(const char *cgroup_path);",
            "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);",
            "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);",
            "static struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);",
            "static struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);\nstatic bool is_valid_cgroup(const char *name);\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\nstatic struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);\nstatic struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);\n\nstatic struct cgroup_process_info *lxc_cgroup_get_container_info(const char *name, const char *lxcpath, struct cgroup_meta_data *meta_data)\n{\n\tstruct cgroup_process_info *result = NULL;\n\tint saved_errno = 0;\n\tsize_t i;\n\tstruct cgroup_process_info **cptr = &result;\n\tstruct cgroup_process_info *entry = NULL;\n\tchar *path = NULL;\n\n\tfor (i = 0; i <= meta_data->maximum_hierarchy; i++) {\n\t\tstruct cgroup_hierarchy *h = meta_data->hierarchies[i];\n\t\tif (!h || !h->used)\n\t\t\tcontinue;\n\n\t\t/* use the command interface to look for the cgroup */\n\t\tpath = lxc_cmd_get_cgroup_path(name, lxcpath, h->subsystems[0]);\n\t\tif (!path) {\n\t\t\th->used = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tentry = calloc(1, sizeof(struct cgroup_process_info));\n\t\tif (!entry)\n\t\t\tgoto out_error;\n\t\tentry->meta_ref = lxc_cgroup_get_meta(meta_data);\n\t\tentry->hierarchy = h;\n\t\tentry->cgroup_path = path;\n\t\tpath = NULL;\n\n\t\t/* it is not an error if we don't find anything here,\n\t\t * it is up to the caller to decide what to do in that\n\t\t * case */\n\t\tentry->designated_mount_point = lxc_cgroup_find_mount_point(h, entry->cgroup_path, true);\n\n\t\t*cptr = entry;\n\t\tcptr = &entry->next;\n\t\tentry = NULL;\n\t}\n\n\treturn result;\nout_error:\n\tsaved_errno = errno;\n\tfree(path);\n\tlxc_cgroup_process_info_free(result);\n\tlxc_cgroup_process_info_free(entry);\n\terrno = saved_errno;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_load_meta",
          "args": [],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_load_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "241-263",
          "snippet": "static struct cgroup_meta_data *lxc_cgroup_load_meta()\n{\n\tconst char *cgroup_use = NULL;\n\tchar **cgroup_use_list = NULL;\n\tstruct cgroup_meta_data *md = NULL;\n\tint saved_errno;\n\n\terrno = 0;\n\tcgroup_use = lxc_global_config_value(\"lxc.cgroup.use\");\n\tif (!cgroup_use && errno != 0)\n\t\treturn NULL;\n\tif (cgroup_use) {\n\t\tcgroup_use_list = lxc_string_split_and_trim(cgroup_use, ',');\n\t\tif (!cgroup_use_list)\n\t\t\treturn NULL;\n\t}\n\n\tmd = lxc_cgroup_load_meta2((const char **)cgroup_use_list);\n\tsaved_errno = errno;\n\tlxc_free_array((void **)cgroup_use_list, free);\n\terrno = saved_errno;\n\treturn md;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_meta_data *lxc_cgroup_load_meta()\n{\n\tconst char *cgroup_use = NULL;\n\tchar **cgroup_use_list = NULL;\n\tstruct cgroup_meta_data *md = NULL;\n\tint saved_errno;\n\n\terrno = 0;\n\tcgroup_use = lxc_global_config_value(\"lxc.cgroup.use\");\n\tif (!cgroup_use && errno != 0)\n\t\treturn NULL;\n\tif (cgroup_use) {\n\t\tcgroup_use_list = lxc_string_split_and_trim(cgroup_use, ',');\n\t\tif (!cgroup_use_list)\n\t\t\treturn NULL;\n\t}\n\n\tmd = lxc_cgroup_load_meta2((const char **)cgroup_use_list);\n\tsaved_errno = errno;\n\tlxc_free_array((void **)cgroup_use_list, free);\n\terrno = saved_errno;\n\treturn md;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_process_info *lxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str, struct cgroup_meta_data *meta);\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic bool is_valid_cgroup(const char *name);\nstatic struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\nstatic void lxc_cgroup_process_info_free(struct cgroup_process_info *info);\n\nstatic char *lxc_cgroup_get_hierarchy_abs_path(const char *subsystem, const char *name, const char *lxcpath)\n{\n\tstruct cgroup_meta_data *meta;\n\tstruct cgroup_process_info *base_info, *info;\n\tstruct cgroup_mount_point *mp;\n\tchar *result = NULL;\n\n\tmeta = lxc_cgroup_load_meta();\n\tif (!meta)\n\t\treturn NULL;\n\tbase_info = lxc_cgroup_get_container_info(name, lxcpath, meta);\n\tif (!base_info)\n\t\tgoto out1;\n\tinfo = find_info_for_subsystem(base_info, subsystem);\n\tif (!info)\n\t\tgoto out2;\n\tif (info->designated_mount_point) {\n\t\tmp = info->designated_mount_point;\n\t} else {\n\t\tmp = lxc_cgroup_find_mount_point(info->hierarchy, info->cgroup_path, true);\n\t\tif (!mp)\n\t\t\tgoto out3;\n\t}\n\tresult = cgroup_to_absolute_path(mp, info->cgroup_path, NULL);\nout3:\nout2:\n\tlxc_cgroup_process_info_free(base_info);\nout1:\n\tlxc_cgroup_put_meta(meta);\n\treturn result;\n}"
  },
  {
    "function_name": "lxc_cgroup_get_hierarchy_abs_path_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "1303-1319",
    "snippet": "static char *lxc_cgroup_get_hierarchy_abs_path_data(const char *subsystem, struct cgfs_data *d)\n{\n\tstruct cgroup_process_info *info = d->info;\n\tstruct cgroup_mount_point *mp = NULL;\n\n\tinfo = find_info_for_subsystem(info, subsystem);\n\tif (!info)\n\t\treturn NULL;\n\tif (info->designated_mount_point) {\n\t\tmp = info->designated_mount_point;\n\t} else {\n\t\tmp = lxc_cgroup_find_mount_point(info->hierarchy, info->cgroup_path, true);\n\t\tif (!mp)\n\t\t\treturn NULL;\n\t}\n\treturn cgroup_to_absolute_path(mp, info->cgroup_path, NULL);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
      "static struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);",
      "static int cgroup_recursive_task_count(const char *cgroup_path);",
      "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);",
      "static void lxc_cgroup_process_info_free(struct cgroup_process_info *info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_to_absolute_path",
          "args": [
            "mp",
            "info->cgroup_path",
            "NULL"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_to_absolute_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1901-1944",
          "snippet": "static char *cgroup_to_absolute_path(struct cgroup_mount_point *mp,\n\t\t\t\t     const char *path, const char *suffix)\n{\n\t/* first we have to make sure we subtract the mount point's prefix */\n\tchar *prefix = mp->mount_prefix;\n\tchar *buf;\n\tssize_t len, rv;\n\n\t/* we want to make sure only absolute paths to cgroups are passed to us */\n\tif (path[0] != '/') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (prefix && !strcmp(prefix, \"/\"))\n\t\tprefix = NULL;\n\n\t/* prefix doesn't match */\n\tif (prefix && strncmp(prefix, path, strlen(prefix)) != 0) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\t/* if prefix is /foo and path is /foobar */\n\tif (prefix && path[strlen(prefix)] != '/' && path[strlen(prefix)] != '\\0') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\t/* remove prefix from path */\n\tpath += prefix ? strlen(prefix) : 0;\n\n\tlen = strlen(mp->mount_point) + strlen(path) + (suffix ? strlen(suffix) : 0);\n\tbuf = calloc(len + 1, 1);\n\tif (!buf)\n\t\treturn NULL;\n\trv = snprintf(buf, len + 1, \"%s%s%s\", mp->mount_point, path, suffix ? suffix : \"\");\n\tif (rv > len) {\n\t\tfree(buf);\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\treturn buf;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
            "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
            "static char *cgroup_to_absolute_path(struct cgroup_mount_point *mp, const char *path, const char *suffix);",
            "static int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);",
            "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic char *cgroup_to_absolute_path(struct cgroup_mount_point *mp, const char *path, const char *suffix);\nstatic int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\n\nstatic char *cgroup_to_absolute_path(struct cgroup_mount_point *mp,\n\t\t\t\t     const char *path, const char *suffix)\n{\n\t/* first we have to make sure we subtract the mount point's prefix */\n\tchar *prefix = mp->mount_prefix;\n\tchar *buf;\n\tssize_t len, rv;\n\n\t/* we want to make sure only absolute paths to cgroups are passed to us */\n\tif (path[0] != '/') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (prefix && !strcmp(prefix, \"/\"))\n\t\tprefix = NULL;\n\n\t/* prefix doesn't match */\n\tif (prefix && strncmp(prefix, path, strlen(prefix)) != 0) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\t/* if prefix is /foo and path is /foobar */\n\tif (prefix && path[strlen(prefix)] != '/' && path[strlen(prefix)] != '\\0') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\t/* remove prefix from path */\n\tpath += prefix ? strlen(prefix) : 0;\n\n\tlen = strlen(mp->mount_point) + strlen(path) + (suffix ? strlen(suffix) : 0);\n\tbuf = calloc(len + 1, 1);\n\tif (!buf)\n\t\treturn NULL;\n\trv = snprintf(buf, len + 1, \"%s%s%s\", mp->mount_point, path, suffix ? suffix : \"\");\n\tif (rv > len) {\n\t\tfree(buf);\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_find_mount_point",
          "args": [
            "info->hierarchy",
            "info->cgroup_path",
            "true"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_find_mount_point",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "670-711",
          "snippet": "static struct cgroup_mount_point *lxc_cgroup_find_mount_point(struct cgroup_hierarchy *hierarchy, const char *group, bool should_be_writable)\n{\n\tstruct cgroup_mount_point **mps;\n\tstruct cgroup_mount_point *current_result = NULL;\n\tssize_t quality = -1;\n\n\t/* trivial case */\n\tif (mountpoint_is_accessible(hierarchy->rw_absolute_mount_point))\n\t\treturn hierarchy->rw_absolute_mount_point;\n\tif (!should_be_writable && mountpoint_is_accessible(hierarchy->ro_absolute_mount_point))\n\t\treturn hierarchy->ro_absolute_mount_point;\n\n\tfor (mps = hierarchy->all_mount_points; mps && *mps; mps++) {\n\t\tstruct cgroup_mount_point *mp = *mps;\n\t\tsize_t prefix_len = mp->mount_prefix ? strlen(mp->mount_prefix) : 0;\n\n\t\tif (prefix_len == 1 && mp->mount_prefix[0] == '/')\n\t\t\tprefix_len = 0;\n\n\t\tif (!mountpoint_is_accessible(mp))\n\t\t\tcontinue;\n\n\t\tif (should_be_writable && mp->read_only)\n\t\t\tcontinue;\n\n\t\tif (!prefix_len ||\n\t\t    (strncmp(group, mp->mount_prefix, prefix_len) == 0 &&\n\t\t     (group[prefix_len] == '\\0' || group[prefix_len] == '/'))) {\n\t\t\t/* search for the best quality match, i.e. the match with the\n\t\t\t * shortest prefix where this group is still contained\n\t\t\t */\n\t\t\tif (quality == -1 || prefix_len < quality) {\n\t\t\t\tcurrent_result = mp;\n\t\t\t\tquality = prefix_len;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!current_result)\n\t\terrno = ENOENT;\n\treturn current_result;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\n\nstatic struct cgroup_mount_point *lxc_cgroup_find_mount_point(struct cgroup_hierarchy *hierarchy, const char *group, bool should_be_writable)\n{\n\tstruct cgroup_mount_point **mps;\n\tstruct cgroup_mount_point *current_result = NULL;\n\tssize_t quality = -1;\n\n\t/* trivial case */\n\tif (mountpoint_is_accessible(hierarchy->rw_absolute_mount_point))\n\t\treturn hierarchy->rw_absolute_mount_point;\n\tif (!should_be_writable && mountpoint_is_accessible(hierarchy->ro_absolute_mount_point))\n\t\treturn hierarchy->ro_absolute_mount_point;\n\n\tfor (mps = hierarchy->all_mount_points; mps && *mps; mps++) {\n\t\tstruct cgroup_mount_point *mp = *mps;\n\t\tsize_t prefix_len = mp->mount_prefix ? strlen(mp->mount_prefix) : 0;\n\n\t\tif (prefix_len == 1 && mp->mount_prefix[0] == '/')\n\t\t\tprefix_len = 0;\n\n\t\tif (!mountpoint_is_accessible(mp))\n\t\t\tcontinue;\n\n\t\tif (should_be_writable && mp->read_only)\n\t\t\tcontinue;\n\n\t\tif (!prefix_len ||\n\t\t    (strncmp(group, mp->mount_prefix, prefix_len) == 0 &&\n\t\t     (group[prefix_len] == '\\0' || group[prefix_len] == '/'))) {\n\t\t\t/* search for the best quality match, i.e. the match with the\n\t\t\t * shortest prefix where this group is still contained\n\t\t\t */\n\t\t\tif (quality == -1 || prefix_len < quality) {\n\t\t\t\tcurrent_result = mp;\n\t\t\t\tquality = prefix_len;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!current_result)\n\t\terrno = ENOENT;\n\treturn current_result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_info_for_subsystem",
          "args": [
            "info",
            "subsystem"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "find_info_for_subsystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1946-1959",
          "snippet": "static struct cgroup_process_info *\nfind_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem)\n{\n\tstruct cgroup_process_info *info_ptr;\n\tfor (info_ptr = info; info_ptr; info_ptr = info_ptr->next) {\n\t\tstruct cgroup_hierarchy *h = info_ptr->hierarchy;\n\t\tif (!h)\n\t\t\tcontinue;\n\t\tif (lxc_string_in_array(subsystem, (const char **)h->subsystems))\n\t\t\treturn info_ptr;\n\t}\n\terrno = ENOENT;\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);",
            "static struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);",
            "static void lxc_cgroup_process_info_free(struct cgroup_process_info *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);\nstatic struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);\nstatic void lxc_cgroup_process_info_free(struct cgroup_process_info *info);\n\nstatic struct cgroup_process_info *\nfind_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem)\n{\n\tstruct cgroup_process_info *info_ptr;\n\tfor (info_ptr = info; info_ptr; info_ptr = info_ptr->next) {\n\t\tstruct cgroup_hierarchy *h = info_ptr->hierarchy;\n\t\tif (!h)\n\t\t\tcontinue;\n\t\tif (lxc_string_in_array(subsystem, (const char **)h->subsystems))\n\t\t\treturn info_ptr;\n\t}\n\terrno = ENOENT;\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\nstatic void lxc_cgroup_process_info_free(struct cgroup_process_info *info);\n\nstatic char *lxc_cgroup_get_hierarchy_abs_path_data(const char *subsystem, struct cgfs_data *d)\n{\n\tstruct cgroup_process_info *info = d->info;\n\tstruct cgroup_mount_point *mp = NULL;\n\n\tinfo = find_info_for_subsystem(info, subsystem);\n\tif (!info)\n\t\treturn NULL;\n\tif (info->designated_mount_point) {\n\t\tmp = info->designated_mount_point;\n\t} else {\n\t\tmp = lxc_cgroup_find_mount_point(info->hierarchy, info->cgroup_path, true);\n\t\tif (!mp)\n\t\t\treturn NULL;\n\t}\n\treturn cgroup_to_absolute_path(mp, info->cgroup_path, NULL);\n}"
  },
  {
    "function_name": "lxc_cgroup_get_hierarchy_path_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "1293-1301",
    "snippet": "static char *lxc_cgroup_get_hierarchy_path_data(const char *subsystem, struct cgfs_data *d)\n{\n\tstruct cgroup_process_info *info = d->info;\n\tinfo = find_info_for_subsystem(info, subsystem);\n\tif (!info)\n\t\treturn NULL;\n\tprune_init_scope(info->cgroup_path);\n\treturn info->cgroup_path;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);",
      "static int cgroup_recursive_task_count(const char *cgroup_path);",
      "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);",
      "static void lxc_cgroup_process_info_free(struct cgroup_process_info *info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "prune_init_scope",
          "args": [
            "info->cgroup_path"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "prune_init_scope",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgroup.c",
          "lines": "212-228",
          "snippet": "void prune_init_scope(char *cg)\n{\n\tchar *point;\n\n\tif (!cg)\n\t\treturn;\n\n\tpoint = cg + strlen(cg) - strlen(INIT_SCOPE);\n\tif (point < cg)\n\t\treturn;\n\tif (strcmp(point, INIT_SCOPE) == 0) {\n\t\tif (point == cg)\n\t\t\t*(point+1) = '\\0';\n\t\telse\n\t\t\t*point = '\\0';\n\t}\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"log.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [
            "#define INIT_SCOPE \"/init.scope\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"log.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <unistd.h>\n\n#define INIT_SCOPE \"/init.scope\"\n\nvoid prune_init_scope(char *cg)\n{\n\tchar *point;\n\n\tif (!cg)\n\t\treturn;\n\n\tpoint = cg + strlen(cg) - strlen(INIT_SCOPE);\n\tif (point < cg)\n\t\treturn;\n\tif (strcmp(point, INIT_SCOPE) == 0) {\n\t\tif (point == cg)\n\t\t\t*(point+1) = '\\0';\n\t\telse\n\t\t\t*point = '\\0';\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_info_for_subsystem",
          "args": [
            "info",
            "subsystem"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "find_info_for_subsystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1946-1959",
          "snippet": "static struct cgroup_process_info *\nfind_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem)\n{\n\tstruct cgroup_process_info *info_ptr;\n\tfor (info_ptr = info; info_ptr; info_ptr = info_ptr->next) {\n\t\tstruct cgroup_hierarchy *h = info_ptr->hierarchy;\n\t\tif (!h)\n\t\t\tcontinue;\n\t\tif (lxc_string_in_array(subsystem, (const char **)h->subsystems))\n\t\t\treturn info_ptr;\n\t}\n\terrno = ENOENT;\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);",
            "static struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);",
            "static void lxc_cgroup_process_info_free(struct cgroup_process_info *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);\nstatic struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);\nstatic void lxc_cgroup_process_info_free(struct cgroup_process_info *info);\n\nstatic struct cgroup_process_info *\nfind_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem)\n{\n\tstruct cgroup_process_info *info_ptr;\n\tfor (info_ptr = info; info_ptr; info_ptr = info_ptr->next) {\n\t\tstruct cgroup_hierarchy *h = info_ptr->hierarchy;\n\t\tif (!h)\n\t\t\tcontinue;\n\t\tif (lxc_string_in_array(subsystem, (const char **)h->subsystems))\n\t\t\treturn info_ptr;\n\t}\n\terrno = ENOENT;\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\nstatic void lxc_cgroup_process_info_free(struct cgroup_process_info *info);\n\nstatic char *lxc_cgroup_get_hierarchy_path_data(const char *subsystem, struct cgfs_data *d)\n{\n\tstruct cgroup_process_info *info = d->info;\n\tinfo = find_info_for_subsystem(info, subsystem);\n\tif (!info)\n\t\treturn NULL;\n\tprune_init_scope(info->cgroup_path);\n\treturn info->cgroup_path;\n}"
  },
  {
    "function_name": "lxc_cgroup_process_info_free_and_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "1263-1291",
    "snippet": "void lxc_cgroup_process_info_free_and_remove(struct cgroup_process_info *info, struct lxc_conf *conf)\n{\n\tstruct cgroup_process_info *next;\n\tchar **pp;\n\tif (!info)\n\t\treturn;\n\tnext = info->next;\n\t{\n\t\tstruct cgroup_mount_point *mp = info->designated_mount_point;\n\t\tif (!mp)\n\t\t\tmp = lxc_cgroup_find_mount_point(info->hierarchy, info->cgroup_path, true);\n\t\tif (mp)\n\t\t\t/* ignore return value here, perhaps we created the\n\t\t\t * '/lxc' cgroup in this container but another container\n\t\t\t * is still running (for example)\n\t\t\t */\n\t\t\t(void)remove_cgroup(mp, info->cgroup_path, true, conf);\n\t}\n\tfor (pp = info->created_paths; pp && *pp; pp++);\n\tfor ((void)(pp && --pp); info->created_paths && pp >= info->created_paths; --pp) {\n\t\tfree(*pp);\n\t}\n\tfree(info->created_paths);\n\tlxc_cgroup_put_meta(info->meta_ref);\n\tfree(info->cgroup_path);\n\tfree(info->cgroup_path_sub);\n\tfree(info);\n\tlxc_cgroup_process_info_free_and_remove(next, conf);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
      "static int remove_cgroup(struct cgroup_mount_point *mp, const char *path, bool recurse,\n\t\t\t\tstruct lxc_conf *conf);",
      "static int do_cgroup_set(const char *cgroup_path, const char *sub_filename, const char *value);",
      "static int cgroup_recursive_task_count(const char *cgroup_path);",
      "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);",
      "static void lxc_cgroup_process_info_free(struct cgroup_process_info *info);",
      "static void lxc_cgroup_process_info_free_and_remove(struct cgroup_process_info *info,\n\t\t\t\tstruct lxc_conf *conf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_cgroup_process_info_free_and_remove",
          "args": [
            "next",
            "conf"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_process_info_free_and_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1263-1291",
          "snippet": "void lxc_cgroup_process_info_free_and_remove(struct cgroup_process_info *info, struct lxc_conf *conf)\n{\n\tstruct cgroup_process_info *next;\n\tchar **pp;\n\tif (!info)\n\t\treturn;\n\tnext = info->next;\n\t{\n\t\tstruct cgroup_mount_point *mp = info->designated_mount_point;\n\t\tif (!mp)\n\t\t\tmp = lxc_cgroup_find_mount_point(info->hierarchy, info->cgroup_path, true);\n\t\tif (mp)\n\t\t\t/* ignore return value here, perhaps we created the\n\t\t\t * '/lxc' cgroup in this container but another container\n\t\t\t * is still running (for example)\n\t\t\t */\n\t\t\t(void)remove_cgroup(mp, info->cgroup_path, true, conf);\n\t}\n\tfor (pp = info->created_paths; pp && *pp; pp++);\n\tfor ((void)(pp && --pp); info->created_paths && pp >= info->created_paths; --pp) {\n\t\tfree(*pp);\n\t}\n\tfree(info->created_paths);\n\tlxc_cgroup_put_meta(info->meta_ref);\n\tfree(info->cgroup_path);\n\tfree(info->cgroup_path_sub);\n\tfree(info);\n\tlxc_cgroup_process_info_free_and_remove(next, conf);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "info"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "cgfs_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2501-2518",
          "snippet": "static bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_put_meta",
          "args": [
            "info->meta_ref"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_put_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "635-650",
          "snippet": "static struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data)\n{\n\tsize_t i;\n\tif (!meta_data)\n\t\treturn NULL;\n\tif (--meta_data->ref > 0)\n\t\treturn meta_data;\n\tlxc_free_array((void **)meta_data->mount_points, (lxc_free_fn)lxc_cgroup_mount_point_free);\n\tif (meta_data->hierarchies)\n\t\tfor (i = 0; i <= meta_data->maximum_hierarchy; i++)\n\t\t\tif (meta_data->hierarchies[i])\n\t\t\t\tlxc_cgroup_hierarchy_free(meta_data->hierarchies[i]);\n\tfree(meta_data->hierarchies);\n\tfree(meta_data);\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);",
            "static struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);\nstatic struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);\n\nstatic struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data)\n{\n\tsize_t i;\n\tif (!meta_data)\n\t\treturn NULL;\n\tif (--meta_data->ref > 0)\n\t\treturn meta_data;\n\tlxc_free_array((void **)meta_data->mount_points, (lxc_free_fn)lxc_cgroup_mount_point_free);\n\tif (meta_data->hierarchies)\n\t\tfor (i = 0; i <= meta_data->maximum_hierarchy; i++)\n\t\t\tif (meta_data->hierarchies[i])\n\t\t\t\tlxc_cgroup_hierarchy_free(meta_data->hierarchies[i]);\n\tfree(meta_data->hierarchies);\n\tfree(meta_data);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_cgroup",
          "args": [
            "mp",
            "info->cgroup_path",
            "true",
            "conf"
          ],
          "line": 1279
        },
        "resolved": true,
        "details": {
          "function_name": "remove_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1895-1899",
          "snippet": "static int remove_cgroup(struct cgroup_mount_point *mp,\n\t\t\t const char *path, bool recurse, struct lxc_conf *conf)\n{\n\treturn create_or_remove_cgroup(true, mp, path, recurse, conf);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
            "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
            "static int remove_cgroup(struct cgroup_mount_point *mp, const char *path, bool recurse,\n\t\t\t\tstruct lxc_conf *conf);",
            "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);",
            "static void lxc_cgroup_process_info_free_and_remove(struct cgroup_process_info *info,\n\t\t\t\tstruct lxc_conf *conf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic int remove_cgroup(struct cgroup_mount_point *mp, const char *path, bool recurse,\n\t\t\t\tstruct lxc_conf *conf);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\nstatic void lxc_cgroup_process_info_free_and_remove(struct cgroup_process_info *info,\n\t\t\t\tstruct lxc_conf *conf);\n\nstatic int remove_cgroup(struct cgroup_mount_point *mp,\n\t\t\t const char *path, bool recurse, struct lxc_conf *conf)\n{\n\treturn create_or_remove_cgroup(true, mp, path, recurse, conf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_find_mount_point",
          "args": [
            "info->hierarchy",
            "info->cgroup_path",
            "true"
          ],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_find_mount_point",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "670-711",
          "snippet": "static struct cgroup_mount_point *lxc_cgroup_find_mount_point(struct cgroup_hierarchy *hierarchy, const char *group, bool should_be_writable)\n{\n\tstruct cgroup_mount_point **mps;\n\tstruct cgroup_mount_point *current_result = NULL;\n\tssize_t quality = -1;\n\n\t/* trivial case */\n\tif (mountpoint_is_accessible(hierarchy->rw_absolute_mount_point))\n\t\treturn hierarchy->rw_absolute_mount_point;\n\tif (!should_be_writable && mountpoint_is_accessible(hierarchy->ro_absolute_mount_point))\n\t\treturn hierarchy->ro_absolute_mount_point;\n\n\tfor (mps = hierarchy->all_mount_points; mps && *mps; mps++) {\n\t\tstruct cgroup_mount_point *mp = *mps;\n\t\tsize_t prefix_len = mp->mount_prefix ? strlen(mp->mount_prefix) : 0;\n\n\t\tif (prefix_len == 1 && mp->mount_prefix[0] == '/')\n\t\t\tprefix_len = 0;\n\n\t\tif (!mountpoint_is_accessible(mp))\n\t\t\tcontinue;\n\n\t\tif (should_be_writable && mp->read_only)\n\t\t\tcontinue;\n\n\t\tif (!prefix_len ||\n\t\t    (strncmp(group, mp->mount_prefix, prefix_len) == 0 &&\n\t\t     (group[prefix_len] == '\\0' || group[prefix_len] == '/'))) {\n\t\t\t/* search for the best quality match, i.e. the match with the\n\t\t\t * shortest prefix where this group is still contained\n\t\t\t */\n\t\t\tif (quality == -1 || prefix_len < quality) {\n\t\t\t\tcurrent_result = mp;\n\t\t\t\tquality = prefix_len;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!current_result)\n\t\terrno = ENOENT;\n\treturn current_result;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\n\nstatic struct cgroup_mount_point *lxc_cgroup_find_mount_point(struct cgroup_hierarchy *hierarchy, const char *group, bool should_be_writable)\n{\n\tstruct cgroup_mount_point **mps;\n\tstruct cgroup_mount_point *current_result = NULL;\n\tssize_t quality = -1;\n\n\t/* trivial case */\n\tif (mountpoint_is_accessible(hierarchy->rw_absolute_mount_point))\n\t\treturn hierarchy->rw_absolute_mount_point;\n\tif (!should_be_writable && mountpoint_is_accessible(hierarchy->ro_absolute_mount_point))\n\t\treturn hierarchy->ro_absolute_mount_point;\n\n\tfor (mps = hierarchy->all_mount_points; mps && *mps; mps++) {\n\t\tstruct cgroup_mount_point *mp = *mps;\n\t\tsize_t prefix_len = mp->mount_prefix ? strlen(mp->mount_prefix) : 0;\n\n\t\tif (prefix_len == 1 && mp->mount_prefix[0] == '/')\n\t\t\tprefix_len = 0;\n\n\t\tif (!mountpoint_is_accessible(mp))\n\t\t\tcontinue;\n\n\t\tif (should_be_writable && mp->read_only)\n\t\t\tcontinue;\n\n\t\tif (!prefix_len ||\n\t\t    (strncmp(group, mp->mount_prefix, prefix_len) == 0 &&\n\t\t     (group[prefix_len] == '\\0' || group[prefix_len] == '/'))) {\n\t\t\t/* search for the best quality match, i.e. the match with the\n\t\t\t * shortest prefix where this group is still contained\n\t\t\t */\n\t\t\tif (quality == -1 || prefix_len < quality) {\n\t\t\t\tcurrent_result = mp;\n\t\t\t\tquality = prefix_len;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!current_result)\n\t\terrno = ENOENT;\n\treturn current_result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic int remove_cgroup(struct cgroup_mount_point *mp, const char *path, bool recurse,\n\t\t\t\tstruct lxc_conf *conf);\nstatic int do_cgroup_set(const char *cgroup_path, const char *sub_filename, const char *value);\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\nstatic void lxc_cgroup_process_info_free(struct cgroup_process_info *info);\nstatic void lxc_cgroup_process_info_free_and_remove(struct cgroup_process_info *info,\n\t\t\t\tstruct lxc_conf *conf);\n\nvoid lxc_cgroup_process_info_free_and_remove(struct cgroup_process_info *info, struct lxc_conf *conf)\n{\n\tstruct cgroup_process_info *next;\n\tchar **pp;\n\tif (!info)\n\t\treturn;\n\tnext = info->next;\n\t{\n\t\tstruct cgroup_mount_point *mp = info->designated_mount_point;\n\t\tif (!mp)\n\t\t\tmp = lxc_cgroup_find_mount_point(info->hierarchy, info->cgroup_path, true);\n\t\tif (mp)\n\t\t\t/* ignore return value here, perhaps we created the\n\t\t\t * '/lxc' cgroup in this container but another container\n\t\t\t * is still running (for example)\n\t\t\t */\n\t\t\t(void)remove_cgroup(mp, info->cgroup_path, true, conf);\n\t}\n\tfor (pp = info->created_paths; pp && *pp; pp++);\n\tfor ((void)(pp && --pp); info->created_paths && pp >= info->created_paths; --pp) {\n\t\tfree(*pp);\n\t}\n\tfree(info->created_paths);\n\tlxc_cgroup_put_meta(info->meta_ref);\n\tfree(info->cgroup_path);\n\tfree(info->cgroup_path_sub);\n\tfree(info);\n\tlxc_cgroup_process_info_free_and_remove(next, conf);\n}"
  },
  {
    "function_name": "lxc_cgroup_process_info_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "1248-1260",
    "snippet": "void lxc_cgroup_process_info_free(struct cgroup_process_info *info)\n{\n\tstruct cgroup_process_info *next;\n\tif (!info)\n\t\treturn;\n\tnext = info->next;\n\tlxc_cgroup_put_meta(info->meta_ref);\n\tfree(info->cgroup_path);\n\tfree(info->cgroup_path_sub);\n\tlxc_free_array((void **)info->created_paths, free);\n\tfree(info);\n\tlxc_cgroup_process_info_free(next);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_recursive_task_count(const char *cgroup_path);",
      "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);",
      "static void lxc_cgroup_process_info_free(struct cgroup_process_info *info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_cgroup_process_info_free",
          "args": [
            "next"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_process_info_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1248-1260",
          "snippet": "void lxc_cgroup_process_info_free(struct cgroup_process_info *info)\n{\n\tstruct cgroup_process_info *next;\n\tif (!info)\n\t\treturn;\n\tnext = info->next;\n\tlxc_cgroup_put_meta(info->meta_ref);\n\tfree(info->cgroup_path);\n\tfree(info->cgroup_path_sub);\n\tlxc_free_array((void **)info->created_paths, free);\n\tfree(info);\n\tlxc_cgroup_process_info_free(next);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "info"
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "cgfs_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2501-2518",
          "snippet": "static bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_free_array",
          "args": [
            "(void **)info->created_paths",
            "free"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_free_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "886-892",
          "snippet": "void lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_put_meta",
          "args": [
            "info->meta_ref"
          ],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_put_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "635-650",
          "snippet": "static struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data)\n{\n\tsize_t i;\n\tif (!meta_data)\n\t\treturn NULL;\n\tif (--meta_data->ref > 0)\n\t\treturn meta_data;\n\tlxc_free_array((void **)meta_data->mount_points, (lxc_free_fn)lxc_cgroup_mount_point_free);\n\tif (meta_data->hierarchies)\n\t\tfor (i = 0; i <= meta_data->maximum_hierarchy; i++)\n\t\t\tif (meta_data->hierarchies[i])\n\t\t\t\tlxc_cgroup_hierarchy_free(meta_data->hierarchies[i]);\n\tfree(meta_data->hierarchies);\n\tfree(meta_data);\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);",
            "static struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);\nstatic struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);\n\nstatic struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data)\n{\n\tsize_t i;\n\tif (!meta_data)\n\t\treturn NULL;\n\tif (--meta_data->ref > 0)\n\t\treturn meta_data;\n\tlxc_free_array((void **)meta_data->mount_points, (lxc_free_fn)lxc_cgroup_mount_point_free);\n\tif (meta_data->hierarchies)\n\t\tfor (i = 0; i <= meta_data->maximum_hierarchy; i++)\n\t\t\tif (meta_data->hierarchies[i])\n\t\t\t\tlxc_cgroup_hierarchy_free(meta_data->hierarchies[i]);\n\tfree(meta_data->hierarchies);\n\tfree(meta_data);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\nstatic void lxc_cgroup_process_info_free(struct cgroup_process_info *info);\n\nvoid lxc_cgroup_process_info_free(struct cgroup_process_info *info)\n{\n\tstruct cgroup_process_info *next;\n\tif (!info)\n\t\treturn;\n\tnext = info->next;\n\tlxc_cgroup_put_meta(info->meta_ref);\n\tfree(info->cgroup_path);\n\tfree(info->cgroup_path_sub);\n\tlxc_free_array((void **)info->created_paths, free);\n\tfree(info);\n\tlxc_cgroup_process_info_free(next);\n}"
  },
  {
    "function_name": "lxc_cgroupfs_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "1206-1245",
    "snippet": "static int lxc_cgroupfs_enter(struct cgroup_process_info *info, pid_t pid, bool enter_sub)\n{\n\tchar pid_buf[32];\n\tchar *cgroup_tasks_fn;\n\tint r;\n\tstruct cgroup_process_info *info_ptr;\n\n\tsnprintf(pid_buf, 32, \"%lu\", (unsigned long)pid);\n\tfor (info_ptr = info; info_ptr; info_ptr = info_ptr->next) {\n\t\tif (!info_ptr->hierarchy)\n\t\t\tcontinue;\n\n\t\tchar *cgroup_path = (enter_sub && info_ptr->cgroup_path_sub) ?\n\t\t\tinfo_ptr->cgroup_path_sub :\n\t\t\tinfo_ptr->cgroup_path;\n\n\t\tif (!info_ptr->designated_mount_point) {\n\t\t\tinfo_ptr->designated_mount_point = lxc_cgroup_find_mount_point(info_ptr->hierarchy, cgroup_path, true);\n\t\t\tif (!info_ptr->designated_mount_point) {\n\t\t\t\tSYSERROR(\"Could not add pid %lu to cgroup %s: internal error (couldn't find any writable mountpoint to cgroup filesystem)\", (unsigned long)pid, cgroup_path);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tcgroup_tasks_fn = cgroup_to_absolute_path(info_ptr->designated_mount_point, cgroup_path, \"/tasks\");\n\t\tif (!cgroup_tasks_fn) {\n\t\t\tSYSERROR(\"Could not add pid %lu to cgroup %s: internal error\", (unsigned long)pid, cgroup_path);\n\t\t\treturn -1;\n\t\t}\n\n\t\tr = lxc_write_to_file(cgroup_tasks_fn, pid_buf, strlen(pid_buf), false);\n\t\tfree(cgroup_tasks_fn);\n\t\tif (r < 0 && is_crucial_hierarchy(info_ptr->hierarchy)) {\n\t\t\tSYSERROR(\"Could not add pid %lu to cgroup %s: internal error\", (unsigned long)pid, cgroup_path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_recursive_task_count(const char *cgroup_path);",
      "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);",
      "static void lxc_cgroup_process_info_free(struct cgroup_process_info *info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Could not add pid %lu to cgroup %s: internal error\"",
            "(unsigned long)pid",
            "cgroup_path"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_crucial_hierarchy",
          "args": [
            "info_ptr->hierarchy"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "is_crucial_hierarchy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "836-845",
          "snippet": "static bool is_crucial_hierarchy(struct cgroup_hierarchy *h)\n{\n\tchar **p;\n\n\tfor (p = h->subsystems; *p; p++) {\n\t\tif (is_crucial_cgroup_subsystem(*p))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);\n\nstatic bool is_crucial_hierarchy(struct cgroup_hierarchy *h)\n{\n\tchar **p;\n\n\tfor (p = h->subsystems; *p; p++) {\n\t\tif (is_crucial_cgroup_subsystem(*p))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cgroup_tasks_fn"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "cgfs_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2501-2518",
          "snippet": "static bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_write_to_file",
          "args": [
            "cgroup_tasks_fn",
            "pid_buf",
            "strlen(pid_buf)",
            "false"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_to_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "934-960",
          "snippet": "int lxc_write_to_file(const char *filename, const void* buf, size_t count, bool add_newline)\n{\n\tint fd, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_WRONLY | O_TRUNC | O_CREAT | O_CLOEXEC, 0666);\n\tif (fd < 0)\n\t\treturn -1;\n\tret = lxc_write_nointr(fd, buf, count);\n\tif (ret < 0)\n\t\tgoto out_error;\n\tif ((size_t)ret != count)\n\t\tgoto out_error;\n\tif (add_newline) {\n\t\tret = lxc_write_nointr(fd, \"\\n\", 1);\n\t\tif (ret != 1)\n\t\t\tgoto out_error;\n\t}\n\tclose(fd);\n\treturn 0;\n\nout_error:\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn -1;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_write_to_file(const char *filename, const void* buf, size_t count, bool add_newline)\n{\n\tint fd, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_WRONLY | O_TRUNC | O_CREAT | O_CLOEXEC, 0666);\n\tif (fd < 0)\n\t\treturn -1;\n\tret = lxc_write_nointr(fd, buf, count);\n\tif (ret < 0)\n\t\tgoto out_error;\n\tif ((size_t)ret != count)\n\t\tgoto out_error;\n\tif (add_newline) {\n\t\tret = lxc_write_nointr(fd, \"\\n\", 1);\n\t\tif (ret != 1)\n\t\t\tgoto out_error;\n\t}\n\tclose(fd);\n\treturn 0;\n\nout_error:\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pid_buf"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Could not add pid %lu to cgroup %s: internal error\"",
            "(unsigned long)pid",
            "cgroup_path"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_to_absolute_path",
          "args": [
            "info_ptr->designated_mount_point",
            "cgroup_path",
            "\"/tasks\""
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_to_absolute_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1901-1944",
          "snippet": "static char *cgroup_to_absolute_path(struct cgroup_mount_point *mp,\n\t\t\t\t     const char *path, const char *suffix)\n{\n\t/* first we have to make sure we subtract the mount point's prefix */\n\tchar *prefix = mp->mount_prefix;\n\tchar *buf;\n\tssize_t len, rv;\n\n\t/* we want to make sure only absolute paths to cgroups are passed to us */\n\tif (path[0] != '/') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (prefix && !strcmp(prefix, \"/\"))\n\t\tprefix = NULL;\n\n\t/* prefix doesn't match */\n\tif (prefix && strncmp(prefix, path, strlen(prefix)) != 0) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\t/* if prefix is /foo and path is /foobar */\n\tif (prefix && path[strlen(prefix)] != '/' && path[strlen(prefix)] != '\\0') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\t/* remove prefix from path */\n\tpath += prefix ? strlen(prefix) : 0;\n\n\tlen = strlen(mp->mount_point) + strlen(path) + (suffix ? strlen(suffix) : 0);\n\tbuf = calloc(len + 1, 1);\n\tif (!buf)\n\t\treturn NULL;\n\trv = snprintf(buf, len + 1, \"%s%s%s\", mp->mount_point, path, suffix ? suffix : \"\");\n\tif (rv > len) {\n\t\tfree(buf);\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\treturn buf;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
            "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
            "static char *cgroup_to_absolute_path(struct cgroup_mount_point *mp, const char *path, const char *suffix);",
            "static int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);",
            "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic char *cgroup_to_absolute_path(struct cgroup_mount_point *mp, const char *path, const char *suffix);\nstatic int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\n\nstatic char *cgroup_to_absolute_path(struct cgroup_mount_point *mp,\n\t\t\t\t     const char *path, const char *suffix)\n{\n\t/* first we have to make sure we subtract the mount point's prefix */\n\tchar *prefix = mp->mount_prefix;\n\tchar *buf;\n\tssize_t len, rv;\n\n\t/* we want to make sure only absolute paths to cgroups are passed to us */\n\tif (path[0] != '/') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (prefix && !strcmp(prefix, \"/\"))\n\t\tprefix = NULL;\n\n\t/* prefix doesn't match */\n\tif (prefix && strncmp(prefix, path, strlen(prefix)) != 0) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\t/* if prefix is /foo and path is /foobar */\n\tif (prefix && path[strlen(prefix)] != '/' && path[strlen(prefix)] != '\\0') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\t/* remove prefix from path */\n\tpath += prefix ? strlen(prefix) : 0;\n\n\tlen = strlen(mp->mount_point) + strlen(path) + (suffix ? strlen(suffix) : 0);\n\tbuf = calloc(len + 1, 1);\n\tif (!buf)\n\t\treturn NULL;\n\trv = snprintf(buf, len + 1, \"%s%s%s\", mp->mount_point, path, suffix ? suffix : \"\");\n\tif (rv > len) {\n\t\tfree(buf);\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Could not add pid %lu to cgroup %s: internal error (couldn't find any writable mountpoint to cgroup filesystem)\"",
            "(unsigned long)pid",
            "cgroup_path"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_find_mount_point",
          "args": [
            "info_ptr->hierarchy",
            "cgroup_path",
            "true"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_find_mount_point",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "670-711",
          "snippet": "static struct cgroup_mount_point *lxc_cgroup_find_mount_point(struct cgroup_hierarchy *hierarchy, const char *group, bool should_be_writable)\n{\n\tstruct cgroup_mount_point **mps;\n\tstruct cgroup_mount_point *current_result = NULL;\n\tssize_t quality = -1;\n\n\t/* trivial case */\n\tif (mountpoint_is_accessible(hierarchy->rw_absolute_mount_point))\n\t\treturn hierarchy->rw_absolute_mount_point;\n\tif (!should_be_writable && mountpoint_is_accessible(hierarchy->ro_absolute_mount_point))\n\t\treturn hierarchy->ro_absolute_mount_point;\n\n\tfor (mps = hierarchy->all_mount_points; mps && *mps; mps++) {\n\t\tstruct cgroup_mount_point *mp = *mps;\n\t\tsize_t prefix_len = mp->mount_prefix ? strlen(mp->mount_prefix) : 0;\n\n\t\tif (prefix_len == 1 && mp->mount_prefix[0] == '/')\n\t\t\tprefix_len = 0;\n\n\t\tif (!mountpoint_is_accessible(mp))\n\t\t\tcontinue;\n\n\t\tif (should_be_writable && mp->read_only)\n\t\t\tcontinue;\n\n\t\tif (!prefix_len ||\n\t\t    (strncmp(group, mp->mount_prefix, prefix_len) == 0 &&\n\t\t     (group[prefix_len] == '\\0' || group[prefix_len] == '/'))) {\n\t\t\t/* search for the best quality match, i.e. the match with the\n\t\t\t * shortest prefix where this group is still contained\n\t\t\t */\n\t\t\tif (quality == -1 || prefix_len < quality) {\n\t\t\t\tcurrent_result = mp;\n\t\t\t\tquality = prefix_len;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!current_result)\n\t\terrno = ENOENT;\n\treturn current_result;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\n\nstatic struct cgroup_mount_point *lxc_cgroup_find_mount_point(struct cgroup_hierarchy *hierarchy, const char *group, bool should_be_writable)\n{\n\tstruct cgroup_mount_point **mps;\n\tstruct cgroup_mount_point *current_result = NULL;\n\tssize_t quality = -1;\n\n\t/* trivial case */\n\tif (mountpoint_is_accessible(hierarchy->rw_absolute_mount_point))\n\t\treturn hierarchy->rw_absolute_mount_point;\n\tif (!should_be_writable && mountpoint_is_accessible(hierarchy->ro_absolute_mount_point))\n\t\treturn hierarchy->ro_absolute_mount_point;\n\n\tfor (mps = hierarchy->all_mount_points; mps && *mps; mps++) {\n\t\tstruct cgroup_mount_point *mp = *mps;\n\t\tsize_t prefix_len = mp->mount_prefix ? strlen(mp->mount_prefix) : 0;\n\n\t\tif (prefix_len == 1 && mp->mount_prefix[0] == '/')\n\t\t\tprefix_len = 0;\n\n\t\tif (!mountpoint_is_accessible(mp))\n\t\t\tcontinue;\n\n\t\tif (should_be_writable && mp->read_only)\n\t\t\tcontinue;\n\n\t\tif (!prefix_len ||\n\t\t    (strncmp(group, mp->mount_prefix, prefix_len) == 0 &&\n\t\t     (group[prefix_len] == '\\0' || group[prefix_len] == '/'))) {\n\t\t\t/* search for the best quality match, i.e. the match with the\n\t\t\t * shortest prefix where this group is still contained\n\t\t\t */\n\t\t\tif (quality == -1 || prefix_len < quality) {\n\t\t\t\tcurrent_result = mp;\n\t\t\t\tquality = prefix_len;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!current_result)\n\t\terrno = ENOENT;\n\treturn current_result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "pid_buf",
            "32",
            "\"%lu\"",
            "(unsigned long)pid"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\nstatic void lxc_cgroup_process_info_free(struct cgroup_process_info *info);\n\nstatic int lxc_cgroupfs_enter(struct cgroup_process_info *info, pid_t pid, bool enter_sub)\n{\n\tchar pid_buf[32];\n\tchar *cgroup_tasks_fn;\n\tint r;\n\tstruct cgroup_process_info *info_ptr;\n\n\tsnprintf(pid_buf, 32, \"%lu\", (unsigned long)pid);\n\tfor (info_ptr = info; info_ptr; info_ptr = info_ptr->next) {\n\t\tif (!info_ptr->hierarchy)\n\t\t\tcontinue;\n\n\t\tchar *cgroup_path = (enter_sub && info_ptr->cgroup_path_sub) ?\n\t\t\tinfo_ptr->cgroup_path_sub :\n\t\t\tinfo_ptr->cgroup_path;\n\n\t\tif (!info_ptr->designated_mount_point) {\n\t\t\tinfo_ptr->designated_mount_point = lxc_cgroup_find_mount_point(info_ptr->hierarchy, cgroup_path, true);\n\t\t\tif (!info_ptr->designated_mount_point) {\n\t\t\t\tSYSERROR(\"Could not add pid %lu to cgroup %s: internal error (couldn't find any writable mountpoint to cgroup filesystem)\", (unsigned long)pid, cgroup_path);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tcgroup_tasks_fn = cgroup_to_absolute_path(info_ptr->designated_mount_point, cgroup_path, \"/tasks\");\n\t\tif (!cgroup_tasks_fn) {\n\t\t\tSYSERROR(\"Could not add pid %lu to cgroup %s: internal error\", (unsigned long)pid, cgroup_path);\n\t\t\treturn -1;\n\t\t}\n\n\t\tr = lxc_write_to_file(cgroup_tasks_fn, pid_buf, strlen(pid_buf), false);\n\t\tfree(cgroup_tasks_fn);\n\t\tif (r < 0 && is_crucial_hierarchy(info_ptr->hierarchy)) {\n\t\t\tSYSERROR(\"Could not add pid %lu to cgroup %s: internal error\", (unsigned long)pid, cgroup_path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_cgroup_get_container_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "1156-1203",
    "snippet": "static struct cgroup_process_info *lxc_cgroup_get_container_info(const char *name, const char *lxcpath, struct cgroup_meta_data *meta_data)\n{\n\tstruct cgroup_process_info *result = NULL;\n\tint saved_errno = 0;\n\tsize_t i;\n\tstruct cgroup_process_info **cptr = &result;\n\tstruct cgroup_process_info *entry = NULL;\n\tchar *path = NULL;\n\n\tfor (i = 0; i <= meta_data->maximum_hierarchy; i++) {\n\t\tstruct cgroup_hierarchy *h = meta_data->hierarchies[i];\n\t\tif (!h || !h->used)\n\t\t\tcontinue;\n\n\t\t/* use the command interface to look for the cgroup */\n\t\tpath = lxc_cmd_get_cgroup_path(name, lxcpath, h->subsystems[0]);\n\t\tif (!path) {\n\t\t\th->used = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tentry = calloc(1, sizeof(struct cgroup_process_info));\n\t\tif (!entry)\n\t\t\tgoto out_error;\n\t\tentry->meta_ref = lxc_cgroup_get_meta(meta_data);\n\t\tentry->hierarchy = h;\n\t\tentry->cgroup_path = path;\n\t\tpath = NULL;\n\n\t\t/* it is not an error if we don't find anything here,\n\t\t * it is up to the caller to decide what to do in that\n\t\t * case */\n\t\tentry->designated_mount_point = lxc_cgroup_find_mount_point(h, entry->cgroup_path, true);\n\n\t\t*cptr = entry;\n\t\tcptr = &entry->next;\n\t\tentry = NULL;\n\t}\n\n\treturn result;\nout_error:\n\tsaved_errno = errno;\n\tfree(path);\n\tlxc_cgroup_process_info_free(result);\n\tlxc_cgroup_process_info_free(entry);\n\terrno = saved_errno;\n\treturn NULL;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);",
      "static bool is_valid_cgroup(const char *name);",
      "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
      "static int cgroup_recursive_task_count(const char *cgroup_path);",
      "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);",
      "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);",
      "static struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);",
      "static struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_cgroup_process_info_free",
          "args": [
            "entry"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_process_info_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1248-1260",
          "snippet": "void lxc_cgroup_process_info_free(struct cgroup_process_info *info)\n{\n\tstruct cgroup_process_info *next;\n\tif (!info)\n\t\treturn;\n\tnext = info->next;\n\tlxc_cgroup_put_meta(info->meta_ref);\n\tfree(info->cgroup_path);\n\tfree(info->cgroup_path_sub);\n\tlxc_free_array((void **)info->created_paths, free);\n\tfree(info);\n\tlxc_cgroup_process_info_free(next);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_recursive_task_count(const char *cgroup_path);",
            "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);",
            "static void lxc_cgroup_process_info_free(struct cgroup_process_info *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\nstatic void lxc_cgroup_process_info_free(struct cgroup_process_info *info);\n\nvoid lxc_cgroup_process_info_free(struct cgroup_process_info *info)\n{\n\tstruct cgroup_process_info *next;\n\tif (!info)\n\t\treturn;\n\tnext = info->next;\n\tlxc_cgroup_put_meta(info->meta_ref);\n\tfree(info->cgroup_path);\n\tfree(info->cgroup_path_sub);\n\tlxc_free_array((void **)info->created_paths, free);\n\tfree(info);\n\tlxc_cgroup_process_info_free(next);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "path"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "cgfs_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2501-2518",
          "snippet": "static bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_find_mount_point",
          "args": [
            "h",
            "entry->cgroup_path",
            "true"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_find_mount_point",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "670-711",
          "snippet": "static struct cgroup_mount_point *lxc_cgroup_find_mount_point(struct cgroup_hierarchy *hierarchy, const char *group, bool should_be_writable)\n{\n\tstruct cgroup_mount_point **mps;\n\tstruct cgroup_mount_point *current_result = NULL;\n\tssize_t quality = -1;\n\n\t/* trivial case */\n\tif (mountpoint_is_accessible(hierarchy->rw_absolute_mount_point))\n\t\treturn hierarchy->rw_absolute_mount_point;\n\tif (!should_be_writable && mountpoint_is_accessible(hierarchy->ro_absolute_mount_point))\n\t\treturn hierarchy->ro_absolute_mount_point;\n\n\tfor (mps = hierarchy->all_mount_points; mps && *mps; mps++) {\n\t\tstruct cgroup_mount_point *mp = *mps;\n\t\tsize_t prefix_len = mp->mount_prefix ? strlen(mp->mount_prefix) : 0;\n\n\t\tif (prefix_len == 1 && mp->mount_prefix[0] == '/')\n\t\t\tprefix_len = 0;\n\n\t\tif (!mountpoint_is_accessible(mp))\n\t\t\tcontinue;\n\n\t\tif (should_be_writable && mp->read_only)\n\t\t\tcontinue;\n\n\t\tif (!prefix_len ||\n\t\t    (strncmp(group, mp->mount_prefix, prefix_len) == 0 &&\n\t\t     (group[prefix_len] == '\\0' || group[prefix_len] == '/'))) {\n\t\t\t/* search for the best quality match, i.e. the match with the\n\t\t\t * shortest prefix where this group is still contained\n\t\t\t */\n\t\t\tif (quality == -1 || prefix_len < quality) {\n\t\t\t\tcurrent_result = mp;\n\t\t\t\tquality = prefix_len;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!current_result)\n\t\terrno = ENOENT;\n\treturn current_result;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\n\nstatic struct cgroup_mount_point *lxc_cgroup_find_mount_point(struct cgroup_hierarchy *hierarchy, const char *group, bool should_be_writable)\n{\n\tstruct cgroup_mount_point **mps;\n\tstruct cgroup_mount_point *current_result = NULL;\n\tssize_t quality = -1;\n\n\t/* trivial case */\n\tif (mountpoint_is_accessible(hierarchy->rw_absolute_mount_point))\n\t\treturn hierarchy->rw_absolute_mount_point;\n\tif (!should_be_writable && mountpoint_is_accessible(hierarchy->ro_absolute_mount_point))\n\t\treturn hierarchy->ro_absolute_mount_point;\n\n\tfor (mps = hierarchy->all_mount_points; mps && *mps; mps++) {\n\t\tstruct cgroup_mount_point *mp = *mps;\n\t\tsize_t prefix_len = mp->mount_prefix ? strlen(mp->mount_prefix) : 0;\n\n\t\tif (prefix_len == 1 && mp->mount_prefix[0] == '/')\n\t\t\tprefix_len = 0;\n\n\t\tif (!mountpoint_is_accessible(mp))\n\t\t\tcontinue;\n\n\t\tif (should_be_writable && mp->read_only)\n\t\t\tcontinue;\n\n\t\tif (!prefix_len ||\n\t\t    (strncmp(group, mp->mount_prefix, prefix_len) == 0 &&\n\t\t     (group[prefix_len] == '\\0' || group[prefix_len] == '/'))) {\n\t\t\t/* search for the best quality match, i.e. the match with the\n\t\t\t * shortest prefix where this group is still contained\n\t\t\t */\n\t\t\tif (quality == -1 || prefix_len < quality) {\n\t\t\t\tcurrent_result = mp;\n\t\t\t\tquality = prefix_len;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!current_result)\n\t\terrno = ENOENT;\n\treturn current_result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_get_meta",
          "args": [
            "meta_data"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_get_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "629-633",
          "snippet": "static struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data)\n{\n\tmeta_data->ref++;\n\treturn meta_data;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);",
            "static struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);\nstatic struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);\n\nstatic struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data)\n{\n\tmeta_data->ref++;\n\treturn meta_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "sizeof(struct cgroup_process_info)"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cmd_get_cgroup_path",
          "args": [
            "name",
            "lxcpath",
            "h->subsystems[0]"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_get_cgroup_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "444-472",
          "snippet": "char *lxc_cmd_get_cgroup_path(const char *name, const char *lxcpath,\n\tconst char *subsystem)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = {\n\t\t\t.cmd = LXC_CMD_GET_CGROUP,\n\t\t\t.datalen = strlen(subsystem)+1,\n\t\t\t.data = subsystem,\n\t\t},\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn NULL;\n\n\tif (!ret) {\n\t\tWARN(\"Container \\\"%s\\\" has stopped before sending its state.\", name);\n\t\treturn NULL;\n\t}\n\n\tif (cmd.rsp.ret < 0 || cmd.rsp.datalen < 0) {\n\t\tERROR(\"Command %s failed for container \\\"%s\\\": %s.\",\n\t\t      lxc_cmd_str(cmd.req.cmd), name, strerror(-cmd.rsp.ret));\n\t\treturn NULL;\n\t}\n\n\treturn cmd.rsp.data;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nchar *lxc_cmd_get_cgroup_path(const char *name, const char *lxcpath,\n\tconst char *subsystem)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = {\n\t\t\t.cmd = LXC_CMD_GET_CGROUP,\n\t\t\t.datalen = strlen(subsystem)+1,\n\t\t\t.data = subsystem,\n\t\t},\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn NULL;\n\n\tif (!ret) {\n\t\tWARN(\"Container \\\"%s\\\" has stopped before sending its state.\", name);\n\t\treturn NULL;\n\t}\n\n\tif (cmd.rsp.ret < 0 || cmd.rsp.datalen < 0) {\n\t\tERROR(\"Command %s failed for container \\\"%s\\\": %s.\",\n\t\t      lxc_cmd_str(cmd.req.cmd), name, strerror(-cmd.rsp.ret));\n\t\treturn NULL;\n\t}\n\n\treturn cmd.rsp.data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);\nstatic bool is_valid_cgroup(const char *name);\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\nstatic struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);\nstatic struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);\n\nstatic struct cgroup_process_info *lxc_cgroup_get_container_info(const char *name, const char *lxcpath, struct cgroup_meta_data *meta_data)\n{\n\tstruct cgroup_process_info *result = NULL;\n\tint saved_errno = 0;\n\tsize_t i;\n\tstruct cgroup_process_info **cptr = &result;\n\tstruct cgroup_process_info *entry = NULL;\n\tchar *path = NULL;\n\n\tfor (i = 0; i <= meta_data->maximum_hierarchy; i++) {\n\t\tstruct cgroup_hierarchy *h = meta_data->hierarchies[i];\n\t\tif (!h || !h->used)\n\t\t\tcontinue;\n\n\t\t/* use the command interface to look for the cgroup */\n\t\tpath = lxc_cmd_get_cgroup_path(name, lxcpath, h->subsystems[0]);\n\t\tif (!path) {\n\t\t\th->used = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tentry = calloc(1, sizeof(struct cgroup_process_info));\n\t\tif (!entry)\n\t\t\tgoto out_error;\n\t\tentry->meta_ref = lxc_cgroup_get_meta(meta_data);\n\t\tentry->hierarchy = h;\n\t\tentry->cgroup_path = path;\n\t\tpath = NULL;\n\n\t\t/* it is not an error if we don't find anything here,\n\t\t * it is up to the caller to decide what to do in that\n\t\t * case */\n\t\tentry->designated_mount_point = lxc_cgroup_find_mount_point(h, entry->cgroup_path, true);\n\n\t\t*cptr = entry;\n\t\tcptr = &entry->next;\n\t\tentry = NULL;\n\t}\n\n\treturn result;\nout_error:\n\tsaved_errno = errno;\n\tfree(path);\n\tlxc_cgroup_process_info_free(result);\n\tlxc_cgroup_process_info_free(entry);\n\terrno = saved_errno;\n\treturn NULL;\n}"
  },
  {
    "function_name": "lxc_cgroup_create_legacy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "1122-1153",
    "snippet": "static int lxc_cgroup_create_legacy(struct cgroup_process_info *base_info, const char *name, pid_t pid)\n{\n\tstruct cgroup_process_info *info_ptr;\n\tint r;\n\n\tfor (info_ptr = base_info; info_ptr; info_ptr = info_ptr->next) {\n\t\tif (!info_ptr->hierarchy)\n\t\t\tcontinue;\n\n\t\tif (!lxc_string_in_array(\"ns\", (const char **)info_ptr->hierarchy->subsystems))\n\t\t\tcontinue;\n\t\t/*\n\t\t * For any path which has ns cgroup mounted, handler->pid is already\n\t\t * moved into a container called '%d % (handler->pid)'.  Rename it to\n\t\t * the cgroup name and record that.\n\t\t */\n\t\tchar *tmp = cgroup_rename_nsgroup((const char *)info_ptr->designated_mount_point->mount_point,\n\t\t\t\tinfo_ptr->cgroup_path, pid, name);\n\t\tif (!tmp)\n\t\t\treturn -1;\n\t\tfree(info_ptr->cgroup_path);\n\t\tinfo_ptr->cgroup_path = tmp;\n\t\tr = lxc_grow_array((void ***)&info_ptr->created_paths, &info_ptr->created_paths_capacity, info_ptr->created_paths_count + 1, 8);\n\t\tif (r < 0)\n\t\t\treturn -1;\n\t\ttmp = strdup(tmp);\n\t\tif (!tmp)\n\t\t\treturn -1;\n\t\tinfo_ptr->created_paths[info_ptr->created_paths_count++] = tmp;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_valid_cgroup(const char *name);",
      "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
      "static int cgroup_recursive_task_count(const char *cgroup_path);",
      "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);",
      "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "tmp"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_grow_array",
          "args": [
            "(void ***)&info_ptr->created_paths",
            "&info_ptr->created_paths_capacity",
            "info_ptr->created_paths_count + 1",
            "8"
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_grow_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "894-921",
          "snippet": "int lxc_grow_array(void ***array, size_t* capacity, size_t new_size, size_t capacity_increment)\n{\n\tsize_t new_capacity;\n\tvoid **new_array;\n\n\t/* first time around, catch some trivial mistakes of the user\n\t * only initializing one of these */\n\tif (!*array || !*capacity) {\n\t\t*array = NULL;\n\t\t*capacity = 0;\n\t}\n\n\tnew_capacity = *capacity;\n\twhile (new_size + 1 > new_capacity)\n\t\tnew_capacity += capacity_increment;\n\tif (new_capacity != *capacity) {\n\t\t/* we have to reallocate */\n\t\tnew_array = realloc(*array, new_capacity * sizeof(void *));\n\t\tif (!new_array)\n\t\t\treturn -1;\n\t\tmemset(&new_array[*capacity], 0, (new_capacity - (*capacity)) * sizeof(void *));\n\t\t*array = new_array;\n\t\t*capacity = new_capacity;\n\t}\n\n\t/* array has sufficient elements */\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_grow_array(void ***array, size_t* capacity, size_t new_size, size_t capacity_increment)\n{\n\tsize_t new_capacity;\n\tvoid **new_array;\n\n\t/* first time around, catch some trivial mistakes of the user\n\t * only initializing one of these */\n\tif (!*array || !*capacity) {\n\t\t*array = NULL;\n\t\t*capacity = 0;\n\t}\n\n\tnew_capacity = *capacity;\n\twhile (new_size + 1 > new_capacity)\n\t\tnew_capacity += capacity_increment;\n\tif (new_capacity != *capacity) {\n\t\t/* we have to reallocate */\n\t\tnew_array = realloc(*array, new_capacity * sizeof(void *));\n\t\tif (!new_array)\n\t\t\treturn -1;\n\t\tmemset(&new_array[*capacity], 0, (new_capacity - (*capacity)) * sizeof(void *));\n\t\t*array = new_array;\n\t\t*capacity = new_capacity;\n\t}\n\n\t/* array has sufficient elements */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "info_ptr->cgroup_path"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "cgfs_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2501-2518",
          "snippet": "static bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_rename_nsgroup",
          "args": [
            "(const char *)info_ptr->designated_mount_point->mount_point",
            "info_ptr->cgroup_path",
            "pid",
            "name"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rename_nsgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "775-834",
          "snippet": "static char *cgroup_rename_nsgroup(const char *mountpath, const char *oldname, pid_t pid, const char *name)\n{\n\tchar *dir, *fulloldpath;\n\tchar *newname, *fullnewpath;\n\tint len, newlen, ret;\n\n\t/*\n\t * if cgroup is mounted at /cgroup and task is in cgroup /ab/, pid 2375 and\n\t * name is c1,\n\t * dir: /ab\n\t * fulloldpath = /cgroup/ab/2375\n\t * fullnewpath = /cgroup/ab/c1\n\t * newname = /ab/c1\n\t */\n\tdir = alloca(strlen(oldname) + 1);\n\tstrcpy(dir, oldname);\n\n\tlen = strlen(oldname) + strlen(mountpath) + 22;\n\tfulloldpath = alloca(len);\n\tret = snprintf(fulloldpath, len, \"%s/%s/%ld\", mountpath, oldname, (unsigned long)pid);\n\tif (ret < 0 || ret >= len)\n\t\treturn NULL;\n\n\tlen = strlen(dir) + strlen(name) + 2;\n\tnewname = malloc(len);\n\tif (!newname) {\n\t\tSYSERROR(\"Out of memory\");\n\t\treturn NULL;\n\t}\n\tret = snprintf(newname, len, \"%s/%s\", dir, name);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(newname);\n\t\treturn NULL;\n\t}\n\n\tnewlen = strlen(mountpath) + len + 2;\n\tfullnewpath = alloca(newlen);\n\tret = snprintf(fullnewpath, newlen, \"%s/%s\", mountpath, newname);\n\tif (ret < 0 || ret >= newlen) {\n\t\tfree(newname);\n\t\treturn NULL;\n\t}\n\n\tif (access(fullnewpath, F_OK) == 0) {\n\t\tif (rmdir(fullnewpath) != 0) {\n\t\t\tSYSERROR(\"container cgroup %s already exists.\", fullnewpath);\n\t\t\tfree(newname);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (rename(fulloldpath, fullnewpath)) {\n\t\tSYSERROR(\"failed to rename cgroup %s->%s\", fulloldpath, fullnewpath);\n\t\tfree(newname);\n\t\treturn NULL;\n\t}\n\n\tDEBUG(\"'%s' renamed to '%s'\", oldname, newname);\n\n\treturn newname;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_valid_cgroup(const char *name);",
            "static int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool is_valid_cgroup(const char *name);\nstatic int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);\n\nstatic char *cgroup_rename_nsgroup(const char *mountpath, const char *oldname, pid_t pid, const char *name)\n{\n\tchar *dir, *fulloldpath;\n\tchar *newname, *fullnewpath;\n\tint len, newlen, ret;\n\n\t/*\n\t * if cgroup is mounted at /cgroup and task is in cgroup /ab/, pid 2375 and\n\t * name is c1,\n\t * dir: /ab\n\t * fulloldpath = /cgroup/ab/2375\n\t * fullnewpath = /cgroup/ab/c1\n\t * newname = /ab/c1\n\t */\n\tdir = alloca(strlen(oldname) + 1);\n\tstrcpy(dir, oldname);\n\n\tlen = strlen(oldname) + strlen(mountpath) + 22;\n\tfulloldpath = alloca(len);\n\tret = snprintf(fulloldpath, len, \"%s/%s/%ld\", mountpath, oldname, (unsigned long)pid);\n\tif (ret < 0 || ret >= len)\n\t\treturn NULL;\n\n\tlen = strlen(dir) + strlen(name) + 2;\n\tnewname = malloc(len);\n\tif (!newname) {\n\t\tSYSERROR(\"Out of memory\");\n\t\treturn NULL;\n\t}\n\tret = snprintf(newname, len, \"%s/%s\", dir, name);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(newname);\n\t\treturn NULL;\n\t}\n\n\tnewlen = strlen(mountpath) + len + 2;\n\tfullnewpath = alloca(newlen);\n\tret = snprintf(fullnewpath, newlen, \"%s/%s\", mountpath, newname);\n\tif (ret < 0 || ret >= newlen) {\n\t\tfree(newname);\n\t\treturn NULL;\n\t}\n\n\tif (access(fullnewpath, F_OK) == 0) {\n\t\tif (rmdir(fullnewpath) != 0) {\n\t\t\tSYSERROR(\"container cgroup %s already exists.\", fullnewpath);\n\t\t\tfree(newname);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (rename(fulloldpath, fullnewpath)) {\n\t\tSYSERROR(\"failed to rename cgroup %s->%s\", fulloldpath, fullnewpath);\n\t\tfree(newname);\n\t\treturn NULL;\n\t}\n\n\tDEBUG(\"'%s' renamed to '%s'\", oldname, newname);\n\n\treturn newname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_string_in_array",
          "args": [
            "\"ns\"",
            "(const char **)info_ptr->hierarchy->subsystems"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_in_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "656-662",
          "snippet": "bool lxc_string_in_array(const char *needle, const char **haystack)\n{\n\tfor (; haystack && *haystack; haystack++)\n\t\tif (!strcmp(needle, *haystack))\n\t\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool lxc_string_in_array(const char *needle, const char **haystack)\n{\n\tfor (; haystack && *haystack; haystack++)\n\t\tif (!strcmp(needle, *haystack))\n\t\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool is_valid_cgroup(const char *name);\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\n\nstatic int lxc_cgroup_create_legacy(struct cgroup_process_info *base_info, const char *name, pid_t pid)\n{\n\tstruct cgroup_process_info *info_ptr;\n\tint r;\n\n\tfor (info_ptr = base_info; info_ptr; info_ptr = info_ptr->next) {\n\t\tif (!info_ptr->hierarchy)\n\t\t\tcontinue;\n\n\t\tif (!lxc_string_in_array(\"ns\", (const char **)info_ptr->hierarchy->subsystems))\n\t\t\tcontinue;\n\t\t/*\n\t\t * For any path which has ns cgroup mounted, handler->pid is already\n\t\t * moved into a container called '%d % (handler->pid)'.  Rename it to\n\t\t * the cgroup name and record that.\n\t\t */\n\t\tchar *tmp = cgroup_rename_nsgroup((const char *)info_ptr->designated_mount_point->mount_point,\n\t\t\t\tinfo_ptr->cgroup_path, pid, name);\n\t\tif (!tmp)\n\t\t\treturn -1;\n\t\tfree(info_ptr->cgroup_path);\n\t\tinfo_ptr->cgroup_path = tmp;\n\t\tr = lxc_grow_array((void ***)&info_ptr->created_paths, &info_ptr->created_paths_capacity, info_ptr->created_paths_count + 1, 8);\n\t\tif (r < 0)\n\t\t\treturn -1;\n\t\ttmp = strdup(tmp);\n\t\tif (!tmp)\n\t\t\treturn -1;\n\t\tinfo_ptr->created_paths[info_ptr->created_paths_count++] = tmp;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_cgroupfs_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "848-1120",
    "snippet": "static struct cgroup_process_info *lxc_cgroupfs_create(const char *name, const char *path_pattern, struct cgroup_meta_data *meta_data, const char *sub_pattern)\n{\n\tchar **cgroup_path_components = NULL;\n\tchar **p = NULL;\n\tchar *path_so_far = NULL;\n\tchar **new_cgroup_paths = NULL;\n\tchar **new_cgroup_paths_sub = NULL;\n\tstruct cgroup_mount_point *mp;\n\tstruct cgroup_hierarchy *h;\n\tstruct cgroup_process_info *base_info = NULL;\n\tstruct cgroup_process_info *info_ptr;\n\tint saved_errno;\n\tint r;\n\tunsigned suffix = 0;\n\tbool had_sub_pattern = false;\n\tsize_t i;\n\n\tif (!is_valid_cgroup(name)) {\n\t\tERROR(\"Invalid cgroup name: '%s'\", name);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (!strstr(path_pattern, \"%n\")) {\n\t\tERROR(\"Invalid cgroup path pattern: '%s'; contains no %%n for specifying container name\", path_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\t/* we will modify the result of this operation directly,\n\t * so we don't have to copy the data structure\n\t */\n\tbase_info = (path_pattern[0] == '/') ?\n\t\tlxc_cgroup_process_info_get_init(meta_data) :\n\t\tlxc_cgroup_process_info_get_self(meta_data);\n\tif (!base_info)\n\t\treturn NULL;\n\n\tnew_cgroup_paths = calloc(meta_data->maximum_hierarchy + 1, sizeof(char *));\n\tif (!new_cgroup_paths)\n\t\tgoto out_initial_error;\n\n\tnew_cgroup_paths_sub = calloc(meta_data->maximum_hierarchy + 1, sizeof(char *));\n\tif (!new_cgroup_paths_sub)\n\t\tgoto out_initial_error;\n\n\t/* find mount points we can use */\n\tfor (info_ptr = base_info; info_ptr; info_ptr = info_ptr->next) {\n\t\th = info_ptr->hierarchy;\n\t\tif (!h)\n\t\t\tcontinue;\n\t\tmp = lxc_cgroup_find_mount_point(h, info_ptr->cgroup_path, true);\n\t\tif (!mp) {\n\t\t\tERROR(\"Could not find writable mount point for cgroup hierarchy %d while trying to create cgroup.\", h->index);\n\t\t\tgoto out_initial_error;\n\t\t}\n\t\tinfo_ptr->designated_mount_point = mp;\n\n\t\tif (lxc_string_in_array(\"ns\", (const char **)h->subsystems))\n\t\t\tcontinue;\n\t\tif (handle_cgroup_settings(mp, info_ptr->cgroup_path) < 0) {\n\t\t\tERROR(\"Could not set clone_children to 1 for cpuset hierarchy in parent cgroup.\");\n\t\t\tgoto out_initial_error;\n\t\t}\n\t}\n\n\t/* normalize the path */\n\tcgroup_path_components = lxc_normalize_path(path_pattern);\n\tif (!cgroup_path_components)\n\t\tgoto out_initial_error;\n\n\t/* go through the path components to see if we can create them */\n\tfor (p = cgroup_path_components; *p || (sub_pattern && !had_sub_pattern); p++) {\n\t\t/* we only want to create the same component with -1, -2, etc.\n\t\t * if the component contains the container name itself, otherwise\n\t\t * it's not an error if it already exists\n\t\t */\n\t\tchar *p_eff = *p ? *p : (char *)sub_pattern;\n\t\tbool contains_name = strstr(p_eff, \"%n\");\n\t\tchar *current_component = NULL;\n\t\tchar *current_subpath = NULL;\n\t\tchar *current_entire_path = NULL;\n\t\tchar *parts[3];\n\t\tsize_t j = 0;\n\t\ti = 0;\n\n\t\t/* if we are processing the subpattern, we want to make sure\n\t\t * loop is ended the next time around\n\t\t */\n\t\tif (!*p) {\n\t\t\thad_sub_pattern = true;\n\t\t\tp--;\n\t\t}\n\n\t\tgoto find_name_on_this_level;\n\n\tcleanup_name_on_this_level:\n\t\t/* This is reached if we found a name clash.\n\t\t * In that case, remove the cgroup from all previous hierarchies\n\t\t */\n\t\tfor (j = 0, info_ptr = base_info; j < i && info_ptr; info_ptr = info_ptr->next, j++) {\n\t\t\tif (info_ptr->created_paths_count < 1)\n\t\t\t\tcontinue;\n\t\t\tr = remove_cgroup(info_ptr->designated_mount_point, info_ptr->created_paths[info_ptr->created_paths_count - 1], false, NULL);\n\t\t\tif (r < 0)\n\t\t\t\tWARN(\"could not clean up cgroup we created when trying to create container\");\n\t\t\tfree(info_ptr->created_paths[info_ptr->created_paths_count - 1]);\n\t\t\tinfo_ptr->created_paths[--info_ptr->created_paths_count] = NULL;\n\t\t}\n\t\tif (current_component != current_subpath)\n\t\t\tfree(current_subpath);\n\t\tif (current_component != p_eff)\n\t\t\tfree(current_component);\n\t\tcurrent_component = current_subpath = NULL;\n\t\t/* try again with another suffix */\n\t\t++suffix;\n\n\tfind_name_on_this_level:\n\t\t/* determine name of the path component we should create */\n\t\tif (contains_name && suffix > 0) {\n\t\t\tchar *buf = calloc(strlen(name) + 32, 1);\n\t\t\tif (!buf)\n\t\t\t\tgoto out_initial_error;\n\t\t\tsnprintf(buf, strlen(name) + 32, \"%s-%u\", name, suffix);\n\t\t\tcurrent_component = lxc_string_replace(\"%n\", buf, p_eff);\n\t\t\tfree(buf);\n\t\t} else {\n\t\t\tcurrent_component = contains_name ? lxc_string_replace(\"%n\", name, p_eff) : p_eff;\n\t\t}\n\t\tparts[0] = path_so_far;\n\t\tparts[1] = current_component;\n\t\tparts[2] = NULL;\n\t\tcurrent_subpath = path_so_far ? lxc_string_join(\"/\", (const char **)parts, false) : current_component;\n\n\t\t/* Now go through each hierarchy and try to create the\n\t\t * corresponding cgroup\n\t\t */\n\t\tfor (i = 0, info_ptr = base_info; info_ptr; info_ptr = info_ptr->next, i++) {\n\t\t\tchar *parts2[3];\n\n\t\t\tif (!info_ptr->hierarchy)\n\t\t\t\tcontinue;\n\n\t\t\tif (lxc_string_in_array(\"ns\", (const char **)info_ptr->hierarchy->subsystems))\n\t\t\t\tcontinue;\n\t\t\tcurrent_entire_path = NULL;\n\n\t\t\tparts2[0] = !strcmp(info_ptr->cgroup_path, \"/\") ? \"\" : info_ptr->cgroup_path;\n\t\t\tparts2[1] = current_subpath;\n\t\t\tparts2[2] = NULL;\n\t\t\tcurrent_entire_path = lxc_string_join(\"/\", (const char **)parts2, false);\n\n\t\t\tif (!*p) {\n\t\t\t\t/* we are processing the subpath, so only update that one */\n\t\t\t\tfree(new_cgroup_paths_sub[i]);\n\t\t\t\tnew_cgroup_paths_sub[i] = strdup(current_entire_path);\n\t\t\t\tif (!new_cgroup_paths_sub[i])\n\t\t\t\t\tgoto cleanup_from_error;\n\t\t\t} else {\n\t\t\t\t/* remember which path was used on this controller */\n\t\t\t\tfree(new_cgroup_paths[i]);\n\t\t\t\tnew_cgroup_paths[i] = strdup(current_entire_path);\n\t\t\t\tif (!new_cgroup_paths[i])\n\t\t\t\t\tgoto cleanup_from_error;\n\t\t\t}\n\n\t\t\tr = create_cgroup(info_ptr->designated_mount_point, current_entire_path);\n\t\t\tif (r < 0 && errno == EEXIST && contains_name) {\n\t\t\t\t/* name clash => try new name with new suffix */\n\t\t\t\tfree(current_entire_path);\n\t\t\t\tcurrent_entire_path = NULL;\n\t\t\t\tgoto cleanup_name_on_this_level;\n\t\t\t} else if (r < 0 && errno != EEXIST) {\n\t\t\t\tif (is_crucial_hierarchy(info_ptr->hierarchy)) {\n\t\t\t\t\tSYSERROR(\"Could not create cgroup '%s' in '%s'.\", current_entire_path, info_ptr->designated_mount_point->mount_point);\n\t\t\t\t\tgoto cleanup_from_error;\n\t\t\t\t}\n\t\t\t\tgoto skip;\n\t\t\t} else if (r == 0) {\n\t\t\t\t/* successfully created */\n\t\t\t\tr = lxc_grow_array((void ***)&info_ptr->created_paths, &info_ptr->created_paths_capacity, info_ptr->created_paths_count + 1, 8);\n\t\t\t\tif (r < 0)\n\t\t\t\t\tgoto cleanup_from_error;\n\t\t\t\tif (!init_cpuset_if_needed(info_ptr->designated_mount_point, current_entire_path)) {\n\t\t\t\t\tERROR(\"Failed to initialize cpuset for '%s' in '%s'.\", current_entire_path, info_ptr->designated_mount_point->mount_point);\n\t\t\t\t\tgoto cleanup_from_error;\n\t\t\t\t}\n\t\t\t\tinfo_ptr->created_paths[info_ptr->created_paths_count++] = current_entire_path;\n\t\t\t} else {\n\t\t\t\t/* if we didn't create the cgroup, then we have to make sure that\n\t\t\t\t * further cgroups will be created properly\n\t\t\t\t */\n\t\t\t\tif (handle_cgroup_settings(info_ptr->designated_mount_point, info_ptr->cgroup_path) < 0) {\n\t\t\t\t\tERROR(\"Could not set clone_children to 1 for cpuset hierarchy in pre-existing cgroup.\");\n\t\t\t\t\tgoto cleanup_from_error;\n\t\t\t\t}\n\t\t\t\tif (!init_cpuset_if_needed(info_ptr->designated_mount_point, info_ptr->cgroup_path)) {\n\t\t\t\t\tERROR(\"Failed to initialize cpuset in pre-existing '%s'.\", info_ptr->cgroup_path);\n\t\t\t\t\tgoto cleanup_from_error;\n\t\t\t\t}\n\nskip:\n\t\t\t\t/* already existed but path component of pattern didn't contain '%n',\n\t\t\t\t * so this is not an error; but then we don't need current_entire_path\n\t\t\t\t * anymore...\n\t\t\t\t */\n\t\t\t\tfree(current_entire_path);\n\t\t\t\tcurrent_entire_path = NULL;\n\t\t\t}\n\t\t}\n\n\t\t/* save path so far */\n\t\tfree(path_so_far);\n\t\tpath_so_far = strdup(current_subpath);\n\t\tif (!path_so_far)\n\t\t\tgoto cleanup_from_error;\n\n\t\t/* cleanup */\n\t\tif (current_component != current_subpath)\n\t\t\tfree(current_subpath);\n\t\tif (current_component != p_eff)\n\t\t\tfree(current_component);\n\t\tcurrent_component = current_subpath = NULL;\n\t\tcontinue;\n\n\tcleanup_from_error:\n\t\t/* called if an error occurred in the loop, so we\n\t\t * do some additional cleanup here\n\t\t */\n\t\tsaved_errno = errno;\n\t\tif (current_component != current_subpath)\n\t\t\tfree(current_subpath);\n\t\tif (current_component != p_eff)\n\t\t\tfree(current_component);\n\t\tfree(current_entire_path);\n\t\terrno = saved_errno;\n\t\tgoto out_initial_error;\n\t}\n\n\t/* we're done, now update the paths */\n\tfor (i = 0, info_ptr = base_info; info_ptr; info_ptr = info_ptr->next, i++) {\n\t\tif (!info_ptr->hierarchy)\n\t\t\tcontinue;\n\t\t/* ignore legacy 'ns' subsystem here, lxc_cgroup_create_legacy\n\t\t * will take care of it\n\t\t * Since we do a continue in above loop, new_cgroup_paths[i] is\n\t\t * unset anyway, as is new_cgroup_paths_sub[i]\n\t\t */\n\t\tif (lxc_string_in_array(\"ns\", (const char **)info_ptr->hierarchy->subsystems))\n\t\t\tcontinue;\n\t\tfree(info_ptr->cgroup_path);\n\t\tinfo_ptr->cgroup_path = new_cgroup_paths[i];\n\t\tinfo_ptr->cgroup_path_sub = new_cgroup_paths_sub[i];\n\t}\n\t/* don't use lxc_free_array since we used the array members\n\t * to store them in our result...\n\t */\n\tfree(new_cgroup_paths);\n\tfree(new_cgroup_paths_sub);\n\tfree(path_so_far);\n\tlxc_free_array((void **)cgroup_path_components, free);\n\treturn base_info;\n\nout_initial_error:\n\tsaved_errno = errno;\n\tfree(path_so_far);\n\tlxc_cgroup_process_info_free_and_remove(base_info, NULL);\n\tlxc_free_array((void **)new_cgroup_paths, free);\n\tlxc_free_array((void **)new_cgroup_paths_sub, free);\n\tlxc_free_array((void **)cgroup_path_components, free);\n\terrno = saved_errno;\n\treturn NULL;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
      "static void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);",
      "static bool is_valid_cgroup(const char *name);",
      "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
      "static char *cgroup_to_absolute_path(struct cgroup_mount_point *mp, const char *path, const char *suffix);",
      "static struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);",
      "static int cgroup_recursive_task_count(const char *cgroup_path);",
      "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);",
      "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);",
      "static struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);",
      "static struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_free_array",
          "args": [
            "(void **)cgroup_path_components",
            "free"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_free_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "886-892",
          "snippet": "void lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_process_info_free_and_remove",
          "args": [
            "base_info",
            "NULL"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_process_info_free_and_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1263-1291",
          "snippet": "void lxc_cgroup_process_info_free_and_remove(struct cgroup_process_info *info, struct lxc_conf *conf)\n{\n\tstruct cgroup_process_info *next;\n\tchar **pp;\n\tif (!info)\n\t\treturn;\n\tnext = info->next;\n\t{\n\t\tstruct cgroup_mount_point *mp = info->designated_mount_point;\n\t\tif (!mp)\n\t\t\tmp = lxc_cgroup_find_mount_point(info->hierarchy, info->cgroup_path, true);\n\t\tif (mp)\n\t\t\t/* ignore return value here, perhaps we created the\n\t\t\t * '/lxc' cgroup in this container but another container\n\t\t\t * is still running (for example)\n\t\t\t */\n\t\t\t(void)remove_cgroup(mp, info->cgroup_path, true, conf);\n\t}\n\tfor (pp = info->created_paths; pp && *pp; pp++);\n\tfor ((void)(pp && --pp); info->created_paths && pp >= info->created_paths; --pp) {\n\t\tfree(*pp);\n\t}\n\tfree(info->created_paths);\n\tlxc_cgroup_put_meta(info->meta_ref);\n\tfree(info->cgroup_path);\n\tfree(info->cgroup_path_sub);\n\tfree(info);\n\tlxc_cgroup_process_info_free_and_remove(next, conf);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
            "static int remove_cgroup(struct cgroup_mount_point *mp, const char *path, bool recurse,\n\t\t\t\tstruct lxc_conf *conf);",
            "static int do_cgroup_set(const char *cgroup_path, const char *sub_filename, const char *value);",
            "static int cgroup_recursive_task_count(const char *cgroup_path);",
            "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);",
            "static void lxc_cgroup_process_info_free(struct cgroup_process_info *info);",
            "static void lxc_cgroup_process_info_free_and_remove(struct cgroup_process_info *info,\n\t\t\t\tstruct lxc_conf *conf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic int remove_cgroup(struct cgroup_mount_point *mp, const char *path, bool recurse,\n\t\t\t\tstruct lxc_conf *conf);\nstatic int do_cgroup_set(const char *cgroup_path, const char *sub_filename, const char *value);\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\nstatic void lxc_cgroup_process_info_free(struct cgroup_process_info *info);\nstatic void lxc_cgroup_process_info_free_and_remove(struct cgroup_process_info *info,\n\t\t\t\tstruct lxc_conf *conf);\n\nvoid lxc_cgroup_process_info_free_and_remove(struct cgroup_process_info *info, struct lxc_conf *conf)\n{\n\tstruct cgroup_process_info *next;\n\tchar **pp;\n\tif (!info)\n\t\treturn;\n\tnext = info->next;\n\t{\n\t\tstruct cgroup_mount_point *mp = info->designated_mount_point;\n\t\tif (!mp)\n\t\t\tmp = lxc_cgroup_find_mount_point(info->hierarchy, info->cgroup_path, true);\n\t\tif (mp)\n\t\t\t/* ignore return value here, perhaps we created the\n\t\t\t * '/lxc' cgroup in this container but another container\n\t\t\t * is still running (for example)\n\t\t\t */\n\t\t\t(void)remove_cgroup(mp, info->cgroup_path, true, conf);\n\t}\n\tfor (pp = info->created_paths; pp && *pp; pp++);\n\tfor ((void)(pp && --pp); info->created_paths && pp >= info->created_paths; --pp) {\n\t\tfree(*pp);\n\t}\n\tfree(info->created_paths);\n\tlxc_cgroup_put_meta(info->meta_ref);\n\tfree(info->cgroup_path);\n\tfree(info->cgroup_path_sub);\n\tfree(info);\n\tlxc_cgroup_process_info_free_and_remove(next, conf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "path_so_far"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "cgfs_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2501-2518",
          "snippet": "static bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_string_in_array",
          "args": [
            "\"ns\"",
            "(const char **)info_ptr->hierarchy->subsystems"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_in_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "656-662",
          "snippet": "bool lxc_string_in_array(const char *needle, const char **haystack)\n{\n\tfor (; haystack && *haystack; haystack++)\n\t\tif (!strcmp(needle, *haystack))\n\t\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool lxc_string_in_array(const char *needle, const char **haystack)\n{\n\tfor (; haystack && *haystack; haystack++)\n\t\tif (!strcmp(needle, *haystack))\n\t\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "current_subpath"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to initialize cpuset in pre-existing '%s'.\"",
            "info_ptr->cgroup_path"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_cpuset_if_needed",
          "args": [
            "info_ptr->designated_mount_point",
            "info_ptr->cgroup_path"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpuset_if_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2295-2308",
          "snippet": "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp,\n\t\t\t\t  const char *path)\n{\n\t/* the files we have to handle here are only in cpuset hierarchies */\n\tif (!lxc_string_in_array(\"cpuset\",\n\t\t\t\t (const char **)mp->hierarchy->subsystems))\n\t\treturn true;\n\n\tif (!mp->need_cpuset_init)\n\t\treturn true;\n\n\treturn (do_init_cpuset_file(mp, path, \"/cpuset.cpus\") &&\n\t\tdo_init_cpuset_file(mp, path, \"/cpuset.mems\") );\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
            "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
            "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\n\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp,\n\t\t\t\t  const char *path)\n{\n\t/* the files we have to handle here are only in cpuset hierarchies */\n\tif (!lxc_string_in_array(\"cpuset\",\n\t\t\t\t (const char **)mp->hierarchy->subsystems))\n\t\treturn true;\n\n\tif (!mp->need_cpuset_init)\n\t\treturn true;\n\n\treturn (do_init_cpuset_file(mp, path, \"/cpuset.cpus\") &&\n\t\tdo_init_cpuset_file(mp, path, \"/cpuset.mems\") );\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Could not set clone_children to 1 for cpuset hierarchy in pre-existing cgroup.\""
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_cgroup_settings",
          "args": [
            "info_ptr->designated_mount_point",
            "info_ptr->cgroup_path"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "handle_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2159-2215",
          "snippet": "static int handle_cgroup_settings(struct cgroup_mount_point *mp,\n\t\t\t\t  char *cgroup_path)\n{\n\tint r, saved_errno = 0;\n\tchar buf[2];\n\n\tmp->need_cpuset_init = false;\n\n\t/* If this is the memory cgroup, we want to enforce hierarchy.\n\t * But don't fail if for some reason we can't.\n\t */\n\tif (lxc_string_in_array(\"memory\", (const char **)mp->hierarchy->subsystems)) {\n\t\tchar *cc_path = cgroup_to_absolute_path(mp, cgroup_path, \"/memory.use_hierarchy\");\n\t\tif (cc_path) {\n\t\t\tr = lxc_read_from_file(cc_path, buf, 1);\n\t\t\tif (r < 1 || buf[0] != '1') {\n\t\t\t\tr = lxc_write_to_file(cc_path, \"1\", 1, false);\n\t\t\t\tif (r < 0)\n\t\t\t\t\tSYSERROR(\"failed to set memory.use_hierarchy to 1; continuing\");\n\t\t\t}\n\t\t\tfree(cc_path);\n\t\t}\n\t}\n\n\t/* if this is a cpuset hierarchy, we have to set cgroup.clone_children in\n\t * the base cgroup, otherwise containers will start with an empty cpuset.mems\n\t * and cpuset.cpus and then\n\t */\n\tif (lxc_string_in_array(\"cpuset\", (const char **)mp->hierarchy->subsystems)) {\n\t\tchar *cc_path = cgroup_to_absolute_path(mp, cgroup_path, \"/cgroup.clone_children\");\n\t\tstruct stat sb;\n\n\t\tif (!cc_path)\n\t\t\treturn -1;\n\t\t/* cgroup.clone_children is not available when running under\n\t\t * older kernel versions; in this case, we'll initialize\n\t\t * cpuset.cpus and cpuset.mems later, after the new cgroup\n\t\t * was created\n\t\t */\n\t\tif (stat(cc_path, &sb) != 0 && errno == ENOENT) {\n\t\t\tmp->need_cpuset_init = true;\n\t\t\tfree(cc_path);\n\t\t\treturn 0;\n\t\t}\n\t\tr = lxc_read_from_file(cc_path, buf, 1);\n\t\tif (r == 1 && buf[0] == '1') {\n\t\t\tfree(cc_path);\n\t\t\treturn 0;\n\t\t}\n\t\tr = lxc_write_to_file(cc_path, \"1\", 1, false);\n\t\tsaved_errno = errno;\n\t\tfree(cc_path);\n\t\terrno = saved_errno;\n\t\treturn r < 0 ? -1 : 0;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
            "static int cgroup_recursive_task_count(const char *cgroup_path);",
            "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\n\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp,\n\t\t\t\t  char *cgroup_path)\n{\n\tint r, saved_errno = 0;\n\tchar buf[2];\n\n\tmp->need_cpuset_init = false;\n\n\t/* If this is the memory cgroup, we want to enforce hierarchy.\n\t * But don't fail if for some reason we can't.\n\t */\n\tif (lxc_string_in_array(\"memory\", (const char **)mp->hierarchy->subsystems)) {\n\t\tchar *cc_path = cgroup_to_absolute_path(mp, cgroup_path, \"/memory.use_hierarchy\");\n\t\tif (cc_path) {\n\t\t\tr = lxc_read_from_file(cc_path, buf, 1);\n\t\t\tif (r < 1 || buf[0] != '1') {\n\t\t\t\tr = lxc_write_to_file(cc_path, \"1\", 1, false);\n\t\t\t\tif (r < 0)\n\t\t\t\t\tSYSERROR(\"failed to set memory.use_hierarchy to 1; continuing\");\n\t\t\t}\n\t\t\tfree(cc_path);\n\t\t}\n\t}\n\n\t/* if this is a cpuset hierarchy, we have to set cgroup.clone_children in\n\t * the base cgroup, otherwise containers will start with an empty cpuset.mems\n\t * and cpuset.cpus and then\n\t */\n\tif (lxc_string_in_array(\"cpuset\", (const char **)mp->hierarchy->subsystems)) {\n\t\tchar *cc_path = cgroup_to_absolute_path(mp, cgroup_path, \"/cgroup.clone_children\");\n\t\tstruct stat sb;\n\n\t\tif (!cc_path)\n\t\t\treturn -1;\n\t\t/* cgroup.clone_children is not available when running under\n\t\t * older kernel versions; in this case, we'll initialize\n\t\t * cpuset.cpus and cpuset.mems later, after the new cgroup\n\t\t * was created\n\t\t */\n\t\tif (stat(cc_path, &sb) != 0 && errno == ENOENT) {\n\t\t\tmp->need_cpuset_init = true;\n\t\t\tfree(cc_path);\n\t\t\treturn 0;\n\t\t}\n\t\tr = lxc_read_from_file(cc_path, buf, 1);\n\t\tif (r == 1 && buf[0] == '1') {\n\t\t\tfree(cc_path);\n\t\t\treturn 0;\n\t\t}\n\t\tr = lxc_write_to_file(cc_path, \"1\", 1, false);\n\t\tsaved_errno = errno;\n\t\tfree(cc_path);\n\t\terrno = saved_errno;\n\t\treturn r < 0 ? -1 : 0;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to initialize cpuset for '%s' in '%s'.\"",
            "current_entire_path",
            "info_ptr->designated_mount_point->mount_point"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_grow_array",
          "args": [
            "(void ***)&info_ptr->created_paths",
            "&info_ptr->created_paths_capacity",
            "info_ptr->created_paths_count + 1",
            "8"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_grow_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "894-921",
          "snippet": "int lxc_grow_array(void ***array, size_t* capacity, size_t new_size, size_t capacity_increment)\n{\n\tsize_t new_capacity;\n\tvoid **new_array;\n\n\t/* first time around, catch some trivial mistakes of the user\n\t * only initializing one of these */\n\tif (!*array || !*capacity) {\n\t\t*array = NULL;\n\t\t*capacity = 0;\n\t}\n\n\tnew_capacity = *capacity;\n\twhile (new_size + 1 > new_capacity)\n\t\tnew_capacity += capacity_increment;\n\tif (new_capacity != *capacity) {\n\t\t/* we have to reallocate */\n\t\tnew_array = realloc(*array, new_capacity * sizeof(void *));\n\t\tif (!new_array)\n\t\t\treturn -1;\n\t\tmemset(&new_array[*capacity], 0, (new_capacity - (*capacity)) * sizeof(void *));\n\t\t*array = new_array;\n\t\t*capacity = new_capacity;\n\t}\n\n\t/* array has sufficient elements */\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_grow_array(void ***array, size_t* capacity, size_t new_size, size_t capacity_increment)\n{\n\tsize_t new_capacity;\n\tvoid **new_array;\n\n\t/* first time around, catch some trivial mistakes of the user\n\t * only initializing one of these */\n\tif (!*array || !*capacity) {\n\t\t*array = NULL;\n\t\t*capacity = 0;\n\t}\n\n\tnew_capacity = *capacity;\n\twhile (new_size + 1 > new_capacity)\n\t\tnew_capacity += capacity_increment;\n\tif (new_capacity != *capacity) {\n\t\t/* we have to reallocate */\n\t\tnew_array = realloc(*array, new_capacity * sizeof(void *));\n\t\tif (!new_array)\n\t\t\treturn -1;\n\t\tmemset(&new_array[*capacity], 0, (new_capacity - (*capacity)) * sizeof(void *));\n\t\t*array = new_array;\n\t\t*capacity = new_capacity;\n\t}\n\n\t/* array has sufficient elements */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Could not create cgroup '%s' in '%s'.\"",
            "current_entire_path",
            "info_ptr->designated_mount_point->mount_point"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_crucial_hierarchy",
          "args": [
            "info_ptr->hierarchy"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "is_crucial_hierarchy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "836-845",
          "snippet": "static bool is_crucial_hierarchy(struct cgroup_hierarchy *h)\n{\n\tchar **p;\n\n\tfor (p = h->subsystems; *p; p++) {\n\t\tif (is_crucial_cgroup_subsystem(*p))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);\n\nstatic bool is_crucial_hierarchy(struct cgroup_hierarchy *h)\n{\n\tchar **p;\n\n\tfor (p = h->subsystems; *p; p++) {\n\t\tif (is_crucial_cgroup_subsystem(*p))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_cgroup",
          "args": [
            "info_ptr->designated_mount_point",
            "current_entire_path"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "create_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1890-1893",
          "snippet": "static int create_cgroup(struct cgroup_mount_point *mp, const char *path)\n{\n\treturn create_or_remove_cgroup(false, mp, path, false, NULL);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
            "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
            "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\n\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path)\n{\n\treturn create_or_remove_cgroup(false, mp, path, false, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "current_entire_path"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "current_entire_path"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_string_join",
          "args": [
            "\"/\"",
            "(const char **)parts2",
            "false"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_join",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "664-688",
          "snippet": "char *lxc_string_join(const char *sep, const char **parts, bool use_as_prefix)\n{\n\tchar *result;\n\tchar **p;\n\tsize_t sep_len = strlen(sep);\n\tsize_t result_len = use_as_prefix * sep_len;\n\n\t/* calculate new string length */\n\tfor (p = (char **)parts; *p; p++)\n\t\tresult_len += (p > (char **)parts) * sep_len + strlen(*p);\n\n\tresult = calloc(result_len + 1, 1);\n\tif (!result)\n\t\treturn NULL;\n\n\tif (use_as_prefix)\n\t\tstrcpy(result, sep);\n\tfor (p = (char **)parts; *p; p++) {\n\t\tif (p > (char **)parts)\n\t\t\tstrcat(result, sep);\n\t\tstrcat(result, *p);\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *lxc_string_join(const char *sep, const char **parts, bool use_as_prefix)\n{\n\tchar *result;\n\tchar **p;\n\tsize_t sep_len = strlen(sep);\n\tsize_t result_len = use_as_prefix * sep_len;\n\n\t/* calculate new string length */\n\tfor (p = (char **)parts; *p; p++)\n\t\tresult_len += (p > (char **)parts) * sep_len + strlen(*p);\n\n\tresult = calloc(result_len + 1, 1);\n\tif (!result)\n\t\treturn NULL;\n\n\tif (use_as_prefix)\n\t\tstrcpy(result, sep);\n\tfor (p = (char **)parts; *p; p++) {\n\t\tif (p > (char **)parts)\n\t\t\tstrcat(result, sep);\n\t\tstrcat(result, *p);\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "info_ptr->cgroup_path",
            "\"/\""
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_string_replace",
          "args": [
            "\"%n\"",
            "name",
            "p_eff"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "601-654",
          "snippet": "char *lxc_string_replace(const char *needle, const char *replacement, const char *haystack)\n{\n\tssize_t len = -1, saved_len = -1;\n\tchar *result = NULL;\n\tsize_t replacement_len = strlen(replacement);\n\tsize_t needle_len = strlen(needle);\n\n\t/* should be executed exactly twice */\n\twhile (len == -1 || result == NULL) {\n\t\tchar *p;\n\t\tchar *last_p;\n\t\tssize_t part_len;\n\n\t\tif (len != -1) {\n\t\t\tresult = calloc(1, len + 1);\n\t\t\tif (!result)\n\t\t\t\treturn NULL;\n\t\t\tsaved_len = len;\n\t\t}\n\n\t\tlen = 0;\n\n\t\tfor (last_p = (char *)haystack, p = strstr(last_p, needle); p; last_p = p, p = strstr(last_p, needle)) {\n\t\t\tpart_len = (ssize_t)(p - last_p);\n\t\t\tif (result && part_len > 0)\n\t\t\t\tmemcpy(&result[len], last_p, part_len);\n\t\t\tlen += part_len;\n\t\t\tif (result && replacement_len > 0)\n\t\t\t\tmemcpy(&result[len], replacement, replacement_len);\n\t\t\tlen += replacement_len;\n\t\t\tp += needle_len;\n\t\t}\n\t\tpart_len = strlen(last_p);\n\t\tif (result && part_len > 0)\n\t\t\tmemcpy(&result[len], last_p, part_len);\n\t\tlen += part_len;\n\t}\n\n\t/* make sure we did the same thing twice,\n\t * once for calculating length, the other\n\t * time for copying data */\n\tif (saved_len != len) {\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\t/* make sure we didn't overwrite any buffer,\n\t * due to calloc the string should be 0-terminated */\n\tif (result[len] != '\\0') {\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *lxc_string_replace(const char *needle, const char *replacement, const char *haystack)\n{\n\tssize_t len = -1, saved_len = -1;\n\tchar *result = NULL;\n\tsize_t replacement_len = strlen(replacement);\n\tsize_t needle_len = strlen(needle);\n\n\t/* should be executed exactly twice */\n\twhile (len == -1 || result == NULL) {\n\t\tchar *p;\n\t\tchar *last_p;\n\t\tssize_t part_len;\n\n\t\tif (len != -1) {\n\t\t\tresult = calloc(1, len + 1);\n\t\t\tif (!result)\n\t\t\t\treturn NULL;\n\t\t\tsaved_len = len;\n\t\t}\n\n\t\tlen = 0;\n\n\t\tfor (last_p = (char *)haystack, p = strstr(last_p, needle); p; last_p = p, p = strstr(last_p, needle)) {\n\t\t\tpart_len = (ssize_t)(p - last_p);\n\t\t\tif (result && part_len > 0)\n\t\t\t\tmemcpy(&result[len], last_p, part_len);\n\t\t\tlen += part_len;\n\t\t\tif (result && replacement_len > 0)\n\t\t\t\tmemcpy(&result[len], replacement, replacement_len);\n\t\t\tlen += replacement_len;\n\t\t\tp += needle_len;\n\t\t}\n\t\tpart_len = strlen(last_p);\n\t\tif (result && part_len > 0)\n\t\t\tmemcpy(&result[len], last_p, part_len);\n\t\tlen += part_len;\n\t}\n\n\t/* make sure we did the same thing twice,\n\t * once for calculating length, the other\n\t * time for copying data */\n\tif (saved_len != len) {\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\t/* make sure we didn't overwrite any buffer,\n\t * due to calloc the string should be 0-terminated */\n\tif (result[len] != '\\0') {\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "strlen(name) + 32",
            "\"%s-%u\"",
            "name",
            "suffix"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "strlen(name) + 32",
            "1"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"could not clean up cgroup we created when trying to create container\""
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_cgroup",
          "args": [
            "info_ptr->designated_mount_point",
            "info_ptr->created_paths[info_ptr->created_paths_count - 1]",
            "false",
            "NULL"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "remove_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1895-1899",
          "snippet": "static int remove_cgroup(struct cgroup_mount_point *mp,\n\t\t\t const char *path, bool recurse, struct lxc_conf *conf)\n{\n\treturn create_or_remove_cgroup(true, mp, path, recurse, conf);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
            "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
            "static int remove_cgroup(struct cgroup_mount_point *mp, const char *path, bool recurse,\n\t\t\t\tstruct lxc_conf *conf);",
            "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);",
            "static void lxc_cgroup_process_info_free_and_remove(struct cgroup_process_info *info,\n\t\t\t\tstruct lxc_conf *conf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic int remove_cgroup(struct cgroup_mount_point *mp, const char *path, bool recurse,\n\t\t\t\tstruct lxc_conf *conf);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\nstatic void lxc_cgroup_process_info_free_and_remove(struct cgroup_process_info *info,\n\t\t\t\tstruct lxc_conf *conf);\n\nstatic int remove_cgroup(struct cgroup_mount_point *mp,\n\t\t\t const char *path, bool recurse, struct lxc_conf *conf)\n{\n\treturn create_or_remove_cgroup(true, mp, path, recurse, conf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p_eff",
            "\"%n\""
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_normalize_path",
          "args": [
            "path_pattern"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_normalize_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "690-723",
          "snippet": "char **lxc_normalize_path(const char *path)\n{\n\tchar **components;\n\tchar **p;\n\tsize_t components_len = 0;\n\tsize_t pos = 0;\n\n\tcomponents = lxc_string_split(path, '/');\n\tif (!components)\n\t\treturn NULL;\n\tfor (p = components; *p; p++)\n\t\tcomponents_len++;\n\n\t/* resolve '.' and '..' */\n\tfor (pos = 0; pos < components_len; ) {\n\t\tif (!strcmp(components[pos], \".\") || (!strcmp(components[pos], \"..\") && pos == 0)) {\n\t\t\t/* eat this element */\n\t\t\tfree(components[pos]);\n\t\t\tmemmove(&components[pos], &components[pos+1], sizeof(char *) * (components_len - pos));\n\t\t\tcomponents_len--;\n\t\t} else if (!strcmp(components[pos], \"..\")) {\n\t\t\t/* eat this and the previous element */\n\t\t\tfree(components[pos - 1]);\n\t\t\tfree(components[pos]);\n\t\t\tmemmove(&components[pos-1], &components[pos+1], sizeof(char *) * (components_len - pos));\n\t\t\tcomponents_len -= 2;\n\t\t\tpos--;\n\t\t} else {\n\t\t\tpos++;\n\t\t}\n\t}\n\n\treturn components;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool btrfs_try_remove_subvol(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nchar **lxc_normalize_path(const char *path)\n{\n\tchar **components;\n\tchar **p;\n\tsize_t components_len = 0;\n\tsize_t pos = 0;\n\n\tcomponents = lxc_string_split(path, '/');\n\tif (!components)\n\t\treturn NULL;\n\tfor (p = components; *p; p++)\n\t\tcomponents_len++;\n\n\t/* resolve '.' and '..' */\n\tfor (pos = 0; pos < components_len; ) {\n\t\tif (!strcmp(components[pos], \".\") || (!strcmp(components[pos], \"..\") && pos == 0)) {\n\t\t\t/* eat this element */\n\t\t\tfree(components[pos]);\n\t\t\tmemmove(&components[pos], &components[pos+1], sizeof(char *) * (components_len - pos));\n\t\t\tcomponents_len--;\n\t\t} else if (!strcmp(components[pos], \"..\")) {\n\t\t\t/* eat this and the previous element */\n\t\t\tfree(components[pos - 1]);\n\t\t\tfree(components[pos]);\n\t\t\tmemmove(&components[pos-1], &components[pos+1], sizeof(char *) * (components_len - pos));\n\t\t\tcomponents_len -= 2;\n\t\t\tpos--;\n\t\t} else {\n\t\t\tpos++;\n\t\t}\n\t}\n\n\treturn components;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Could not set clone_children to 1 for cpuset hierarchy in parent cgroup.\""
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Could not find writable mount point for cgroup hierarchy %d while trying to create cgroup.\"",
            "h->index"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_find_mount_point",
          "args": [
            "h",
            "info_ptr->cgroup_path",
            "true"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_find_mount_point",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "670-711",
          "snippet": "static struct cgroup_mount_point *lxc_cgroup_find_mount_point(struct cgroup_hierarchy *hierarchy, const char *group, bool should_be_writable)\n{\n\tstruct cgroup_mount_point **mps;\n\tstruct cgroup_mount_point *current_result = NULL;\n\tssize_t quality = -1;\n\n\t/* trivial case */\n\tif (mountpoint_is_accessible(hierarchy->rw_absolute_mount_point))\n\t\treturn hierarchy->rw_absolute_mount_point;\n\tif (!should_be_writable && mountpoint_is_accessible(hierarchy->ro_absolute_mount_point))\n\t\treturn hierarchy->ro_absolute_mount_point;\n\n\tfor (mps = hierarchy->all_mount_points; mps && *mps; mps++) {\n\t\tstruct cgroup_mount_point *mp = *mps;\n\t\tsize_t prefix_len = mp->mount_prefix ? strlen(mp->mount_prefix) : 0;\n\n\t\tif (prefix_len == 1 && mp->mount_prefix[0] == '/')\n\t\t\tprefix_len = 0;\n\n\t\tif (!mountpoint_is_accessible(mp))\n\t\t\tcontinue;\n\n\t\tif (should_be_writable && mp->read_only)\n\t\t\tcontinue;\n\n\t\tif (!prefix_len ||\n\t\t    (strncmp(group, mp->mount_prefix, prefix_len) == 0 &&\n\t\t     (group[prefix_len] == '\\0' || group[prefix_len] == '/'))) {\n\t\t\t/* search for the best quality match, i.e. the match with the\n\t\t\t * shortest prefix where this group is still contained\n\t\t\t */\n\t\t\tif (quality == -1 || prefix_len < quality) {\n\t\t\t\tcurrent_result = mp;\n\t\t\t\tquality = prefix_len;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!current_result)\n\t\terrno = ENOENT;\n\treturn current_result;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\n\nstatic struct cgroup_mount_point *lxc_cgroup_find_mount_point(struct cgroup_hierarchy *hierarchy, const char *group, bool should_be_writable)\n{\n\tstruct cgroup_mount_point **mps;\n\tstruct cgroup_mount_point *current_result = NULL;\n\tssize_t quality = -1;\n\n\t/* trivial case */\n\tif (mountpoint_is_accessible(hierarchy->rw_absolute_mount_point))\n\t\treturn hierarchy->rw_absolute_mount_point;\n\tif (!should_be_writable && mountpoint_is_accessible(hierarchy->ro_absolute_mount_point))\n\t\treturn hierarchy->ro_absolute_mount_point;\n\n\tfor (mps = hierarchy->all_mount_points; mps && *mps; mps++) {\n\t\tstruct cgroup_mount_point *mp = *mps;\n\t\tsize_t prefix_len = mp->mount_prefix ? strlen(mp->mount_prefix) : 0;\n\n\t\tif (prefix_len == 1 && mp->mount_prefix[0] == '/')\n\t\t\tprefix_len = 0;\n\n\t\tif (!mountpoint_is_accessible(mp))\n\t\t\tcontinue;\n\n\t\tif (should_be_writable && mp->read_only)\n\t\t\tcontinue;\n\n\t\tif (!prefix_len ||\n\t\t    (strncmp(group, mp->mount_prefix, prefix_len) == 0 &&\n\t\t     (group[prefix_len] == '\\0' || group[prefix_len] == '/'))) {\n\t\t\t/* search for the best quality match, i.e. the match with the\n\t\t\t * shortest prefix where this group is still contained\n\t\t\t */\n\t\t\tif (quality == -1 || prefix_len < quality) {\n\t\t\t\tcurrent_result = mp;\n\t\t\t\tquality = prefix_len;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!current_result)\n\t\terrno = ENOENT;\n\treturn current_result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "meta_data->maximum_hierarchy + 1",
            "sizeof(char *)"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "meta_data->maximum_hierarchy + 1",
            "sizeof(char *)"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_process_info_get_self",
          "args": [
            "meta_data"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_process_info_get_self",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "759-766",
          "snippet": "static struct cgroup_process_info *lxc_cgroup_process_info_get_self(struct cgroup_meta_data *meta)\n{\n\tstruct cgroup_process_info *i;\n\ti = lxc_cgroup_process_info_getx(\"/proc/self/cgroup\", meta);\n\tif (!i)\n\t\ti = lxc_cgroup_process_info_get(getpid(), meta);\n\treturn i;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_process_info *lxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str, struct cgroup_meta_data *meta);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_process_info *lxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str, struct cgroup_meta_data *meta);\n\nstatic struct cgroup_process_info *lxc_cgroup_process_info_get_self(struct cgroup_meta_data *meta)\n{\n\tstruct cgroup_process_info *i;\n\ti = lxc_cgroup_process_info_getx(\"/proc/self/cgroup\", meta);\n\tif (!i)\n\t\ti = lxc_cgroup_process_info_get(getpid(), meta);\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_process_info_get_init",
          "args": [
            "meta_data"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_process_info_get_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "754-757",
          "snippet": "static struct cgroup_process_info *lxc_cgroup_process_info_get_init(struct cgroup_meta_data *meta)\n{\n\treturn lxc_cgroup_process_info_get(1, meta);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_process_info *lxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str, struct cgroup_meta_data *meta);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_process_info *lxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str, struct cgroup_meta_data *meta);\n\nstatic struct cgroup_process_info *lxc_cgroup_process_info_get_init(struct cgroup_meta_data *meta)\n{\n\treturn lxc_cgroup_process_info_get(1, meta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Invalid cgroup path pattern: '%s'; contains no %%n for specifying container name\"",
            "path_pattern"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "path_pattern",
            "\"%n\""
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Invalid cgroup name: '%s'\"",
            "name"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_valid_cgroup",
          "args": [
            "name"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "is_valid_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1848-1860",
          "snippet": "static bool is_valid_cgroup(const char *name)\n{\n\tconst char *p;\n\tfor (p = name; *p; p++) {\n\t\t/* Use the ASCII printable characters range(32 - 127)\n\t\t * is reasonable, we kick out 32(SPACE) because it'll\n\t\t * break legacy lxc-ls\n\t\t */\n\t\tif (*p <= 32 || *p >= 127 || *p == '/')\n\t\t\treturn false;\n\t}\n\treturn strcmp(name, \".\") != 0 && strcmp(name, \"..\") != 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_valid_cgroup(const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool is_valid_cgroup(const char *name);\n\nstatic bool is_valid_cgroup(const char *name)\n{\n\tconst char *p;\n\tfor (p = name; *p; p++) {\n\t\t/* Use the ASCII printable characters range(32 - 127)\n\t\t * is reasonable, we kick out 32(SPACE) because it'll\n\t\t * break legacy lxc-ls\n\t\t */\n\t\tif (*p <= 32 || *p >= 127 || *p == '/')\n\t\t\treturn false;\n\t}\n\treturn strcmp(name, \".\") != 0 && strcmp(name, \"..\") != 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);\nstatic bool is_valid_cgroup(const char *name);\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic char *cgroup_to_absolute_path(struct cgroup_mount_point *mp, const char *path, const char *suffix);\nstatic struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\nstatic struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);\nstatic struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);\n\nstatic struct cgroup_process_info *lxc_cgroupfs_create(const char *name, const char *path_pattern, struct cgroup_meta_data *meta_data, const char *sub_pattern)\n{\n\tchar **cgroup_path_components = NULL;\n\tchar **p = NULL;\n\tchar *path_so_far = NULL;\n\tchar **new_cgroup_paths = NULL;\n\tchar **new_cgroup_paths_sub = NULL;\n\tstruct cgroup_mount_point *mp;\n\tstruct cgroup_hierarchy *h;\n\tstruct cgroup_process_info *base_info = NULL;\n\tstruct cgroup_process_info *info_ptr;\n\tint saved_errno;\n\tint r;\n\tunsigned suffix = 0;\n\tbool had_sub_pattern = false;\n\tsize_t i;\n\n\tif (!is_valid_cgroup(name)) {\n\t\tERROR(\"Invalid cgroup name: '%s'\", name);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (!strstr(path_pattern, \"%n\")) {\n\t\tERROR(\"Invalid cgroup path pattern: '%s'; contains no %%n for specifying container name\", path_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\t/* we will modify the result of this operation directly,\n\t * so we don't have to copy the data structure\n\t */\n\tbase_info = (path_pattern[0] == '/') ?\n\t\tlxc_cgroup_process_info_get_init(meta_data) :\n\t\tlxc_cgroup_process_info_get_self(meta_data);\n\tif (!base_info)\n\t\treturn NULL;\n\n\tnew_cgroup_paths = calloc(meta_data->maximum_hierarchy + 1, sizeof(char *));\n\tif (!new_cgroup_paths)\n\t\tgoto out_initial_error;\n\n\tnew_cgroup_paths_sub = calloc(meta_data->maximum_hierarchy + 1, sizeof(char *));\n\tif (!new_cgroup_paths_sub)\n\t\tgoto out_initial_error;\n\n\t/* find mount points we can use */\n\tfor (info_ptr = base_info; info_ptr; info_ptr = info_ptr->next) {\n\t\th = info_ptr->hierarchy;\n\t\tif (!h)\n\t\t\tcontinue;\n\t\tmp = lxc_cgroup_find_mount_point(h, info_ptr->cgroup_path, true);\n\t\tif (!mp) {\n\t\t\tERROR(\"Could not find writable mount point for cgroup hierarchy %d while trying to create cgroup.\", h->index);\n\t\t\tgoto out_initial_error;\n\t\t}\n\t\tinfo_ptr->designated_mount_point = mp;\n\n\t\tif (lxc_string_in_array(\"ns\", (const char **)h->subsystems))\n\t\t\tcontinue;\n\t\tif (handle_cgroup_settings(mp, info_ptr->cgroup_path) < 0) {\n\t\t\tERROR(\"Could not set clone_children to 1 for cpuset hierarchy in parent cgroup.\");\n\t\t\tgoto out_initial_error;\n\t\t}\n\t}\n\n\t/* normalize the path */\n\tcgroup_path_components = lxc_normalize_path(path_pattern);\n\tif (!cgroup_path_components)\n\t\tgoto out_initial_error;\n\n\t/* go through the path components to see if we can create them */\n\tfor (p = cgroup_path_components; *p || (sub_pattern && !had_sub_pattern); p++) {\n\t\t/* we only want to create the same component with -1, -2, etc.\n\t\t * if the component contains the container name itself, otherwise\n\t\t * it's not an error if it already exists\n\t\t */\n\t\tchar *p_eff = *p ? *p : (char *)sub_pattern;\n\t\tbool contains_name = strstr(p_eff, \"%n\");\n\t\tchar *current_component = NULL;\n\t\tchar *current_subpath = NULL;\n\t\tchar *current_entire_path = NULL;\n\t\tchar *parts[3];\n\t\tsize_t j = 0;\n\t\ti = 0;\n\n\t\t/* if we are processing the subpattern, we want to make sure\n\t\t * loop is ended the next time around\n\t\t */\n\t\tif (!*p) {\n\t\t\thad_sub_pattern = true;\n\t\t\tp--;\n\t\t}\n\n\t\tgoto find_name_on_this_level;\n\n\tcleanup_name_on_this_level:\n\t\t/* This is reached if we found a name clash.\n\t\t * In that case, remove the cgroup from all previous hierarchies\n\t\t */\n\t\tfor (j = 0, info_ptr = base_info; j < i && info_ptr; info_ptr = info_ptr->next, j++) {\n\t\t\tif (info_ptr->created_paths_count < 1)\n\t\t\t\tcontinue;\n\t\t\tr = remove_cgroup(info_ptr->designated_mount_point, info_ptr->created_paths[info_ptr->created_paths_count - 1], false, NULL);\n\t\t\tif (r < 0)\n\t\t\t\tWARN(\"could not clean up cgroup we created when trying to create container\");\n\t\t\tfree(info_ptr->created_paths[info_ptr->created_paths_count - 1]);\n\t\t\tinfo_ptr->created_paths[--info_ptr->created_paths_count] = NULL;\n\t\t}\n\t\tif (current_component != current_subpath)\n\t\t\tfree(current_subpath);\n\t\tif (current_component != p_eff)\n\t\t\tfree(current_component);\n\t\tcurrent_component = current_subpath = NULL;\n\t\t/* try again with another suffix */\n\t\t++suffix;\n\n\tfind_name_on_this_level:\n\t\t/* determine name of the path component we should create */\n\t\tif (contains_name && suffix > 0) {\n\t\t\tchar *buf = calloc(strlen(name) + 32, 1);\n\t\t\tif (!buf)\n\t\t\t\tgoto out_initial_error;\n\t\t\tsnprintf(buf, strlen(name) + 32, \"%s-%u\", name, suffix);\n\t\t\tcurrent_component = lxc_string_replace(\"%n\", buf, p_eff);\n\t\t\tfree(buf);\n\t\t} else {\n\t\t\tcurrent_component = contains_name ? lxc_string_replace(\"%n\", name, p_eff) : p_eff;\n\t\t}\n\t\tparts[0] = path_so_far;\n\t\tparts[1] = current_component;\n\t\tparts[2] = NULL;\n\t\tcurrent_subpath = path_so_far ? lxc_string_join(\"/\", (const char **)parts, false) : current_component;\n\n\t\t/* Now go through each hierarchy and try to create the\n\t\t * corresponding cgroup\n\t\t */\n\t\tfor (i = 0, info_ptr = base_info; info_ptr; info_ptr = info_ptr->next, i++) {\n\t\t\tchar *parts2[3];\n\n\t\t\tif (!info_ptr->hierarchy)\n\t\t\t\tcontinue;\n\n\t\t\tif (lxc_string_in_array(\"ns\", (const char **)info_ptr->hierarchy->subsystems))\n\t\t\t\tcontinue;\n\t\t\tcurrent_entire_path = NULL;\n\n\t\t\tparts2[0] = !strcmp(info_ptr->cgroup_path, \"/\") ? \"\" : info_ptr->cgroup_path;\n\t\t\tparts2[1] = current_subpath;\n\t\t\tparts2[2] = NULL;\n\t\t\tcurrent_entire_path = lxc_string_join(\"/\", (const char **)parts2, false);\n\n\t\t\tif (!*p) {\n\t\t\t\t/* we are processing the subpath, so only update that one */\n\t\t\t\tfree(new_cgroup_paths_sub[i]);\n\t\t\t\tnew_cgroup_paths_sub[i] = strdup(current_entire_path);\n\t\t\t\tif (!new_cgroup_paths_sub[i])\n\t\t\t\t\tgoto cleanup_from_error;\n\t\t\t} else {\n\t\t\t\t/* remember which path was used on this controller */\n\t\t\t\tfree(new_cgroup_paths[i]);\n\t\t\t\tnew_cgroup_paths[i] = strdup(current_entire_path);\n\t\t\t\tif (!new_cgroup_paths[i])\n\t\t\t\t\tgoto cleanup_from_error;\n\t\t\t}\n\n\t\t\tr = create_cgroup(info_ptr->designated_mount_point, current_entire_path);\n\t\t\tif (r < 0 && errno == EEXIST && contains_name) {\n\t\t\t\t/* name clash => try new name with new suffix */\n\t\t\t\tfree(current_entire_path);\n\t\t\t\tcurrent_entire_path = NULL;\n\t\t\t\tgoto cleanup_name_on_this_level;\n\t\t\t} else if (r < 0 && errno != EEXIST) {\n\t\t\t\tif (is_crucial_hierarchy(info_ptr->hierarchy)) {\n\t\t\t\t\tSYSERROR(\"Could not create cgroup '%s' in '%s'.\", current_entire_path, info_ptr->designated_mount_point->mount_point);\n\t\t\t\t\tgoto cleanup_from_error;\n\t\t\t\t}\n\t\t\t\tgoto skip;\n\t\t\t} else if (r == 0) {\n\t\t\t\t/* successfully created */\n\t\t\t\tr = lxc_grow_array((void ***)&info_ptr->created_paths, &info_ptr->created_paths_capacity, info_ptr->created_paths_count + 1, 8);\n\t\t\t\tif (r < 0)\n\t\t\t\t\tgoto cleanup_from_error;\n\t\t\t\tif (!init_cpuset_if_needed(info_ptr->designated_mount_point, current_entire_path)) {\n\t\t\t\t\tERROR(\"Failed to initialize cpuset for '%s' in '%s'.\", current_entire_path, info_ptr->designated_mount_point->mount_point);\n\t\t\t\t\tgoto cleanup_from_error;\n\t\t\t\t}\n\t\t\t\tinfo_ptr->created_paths[info_ptr->created_paths_count++] = current_entire_path;\n\t\t\t} else {\n\t\t\t\t/* if we didn't create the cgroup, then we have to make sure that\n\t\t\t\t * further cgroups will be created properly\n\t\t\t\t */\n\t\t\t\tif (handle_cgroup_settings(info_ptr->designated_mount_point, info_ptr->cgroup_path) < 0) {\n\t\t\t\t\tERROR(\"Could not set clone_children to 1 for cpuset hierarchy in pre-existing cgroup.\");\n\t\t\t\t\tgoto cleanup_from_error;\n\t\t\t\t}\n\t\t\t\tif (!init_cpuset_if_needed(info_ptr->designated_mount_point, info_ptr->cgroup_path)) {\n\t\t\t\t\tERROR(\"Failed to initialize cpuset in pre-existing '%s'.\", info_ptr->cgroup_path);\n\t\t\t\t\tgoto cleanup_from_error;\n\t\t\t\t}\n\nskip:\n\t\t\t\t/* already existed but path component of pattern didn't contain '%n',\n\t\t\t\t * so this is not an error; but then we don't need current_entire_path\n\t\t\t\t * anymore...\n\t\t\t\t */\n\t\t\t\tfree(current_entire_path);\n\t\t\t\tcurrent_entire_path = NULL;\n\t\t\t}\n\t\t}\n\n\t\t/* save path so far */\n\t\tfree(path_so_far);\n\t\tpath_so_far = strdup(current_subpath);\n\t\tif (!path_so_far)\n\t\t\tgoto cleanup_from_error;\n\n\t\t/* cleanup */\n\t\tif (current_component != current_subpath)\n\t\t\tfree(current_subpath);\n\t\tif (current_component != p_eff)\n\t\t\tfree(current_component);\n\t\tcurrent_component = current_subpath = NULL;\n\t\tcontinue;\n\n\tcleanup_from_error:\n\t\t/* called if an error occurred in the loop, so we\n\t\t * do some additional cleanup here\n\t\t */\n\t\tsaved_errno = errno;\n\t\tif (current_component != current_subpath)\n\t\t\tfree(current_subpath);\n\t\tif (current_component != p_eff)\n\t\t\tfree(current_component);\n\t\tfree(current_entire_path);\n\t\terrno = saved_errno;\n\t\tgoto out_initial_error;\n\t}\n\n\t/* we're done, now update the paths */\n\tfor (i = 0, info_ptr = base_info; info_ptr; info_ptr = info_ptr->next, i++) {\n\t\tif (!info_ptr->hierarchy)\n\t\t\tcontinue;\n\t\t/* ignore legacy 'ns' subsystem here, lxc_cgroup_create_legacy\n\t\t * will take care of it\n\t\t * Since we do a continue in above loop, new_cgroup_paths[i] is\n\t\t * unset anyway, as is new_cgroup_paths_sub[i]\n\t\t */\n\t\tif (lxc_string_in_array(\"ns\", (const char **)info_ptr->hierarchy->subsystems))\n\t\t\tcontinue;\n\t\tfree(info_ptr->cgroup_path);\n\t\tinfo_ptr->cgroup_path = new_cgroup_paths[i];\n\t\tinfo_ptr->cgroup_path_sub = new_cgroup_paths_sub[i];\n\t}\n\t/* don't use lxc_free_array since we used the array members\n\t * to store them in our result...\n\t */\n\tfree(new_cgroup_paths);\n\tfree(new_cgroup_paths_sub);\n\tfree(path_so_far);\n\tlxc_free_array((void **)cgroup_path_components, free);\n\treturn base_info;\n\nout_initial_error:\n\tsaved_errno = errno;\n\tfree(path_so_far);\n\tlxc_cgroup_process_info_free_and_remove(base_info, NULL);\n\tlxc_free_array((void **)new_cgroup_paths, free);\n\tlxc_free_array((void **)new_cgroup_paths_sub, free);\n\tlxc_free_array((void **)cgroup_path_components, free);\n\terrno = saved_errno;\n\treturn NULL;\n}"
  },
  {
    "function_name": "is_crucial_hierarchy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "836-845",
    "snippet": "static bool is_crucial_hierarchy(struct cgroup_hierarchy *h)\n{\n\tchar **p;\n\n\tfor (p = h->subsystems; *p; p++) {\n\t\tif (is_crucial_cgroup_subsystem(*p))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_crucial_cgroup_subsystem",
          "args": [
            "*p"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "is_crucial_cgroup_subsystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgroup.c",
          "lines": "239-248",
          "snippet": "bool is_crucial_cgroup_subsystem(const char *s)\n{\n\tif (strcmp(s, \"systemd\") == 0)\n\t\treturn true;\n\tif (strcmp(s, \"name=systemd\") == 0)\n\t\treturn true;\n\tif (strcmp(s, \"freezer\") == 0)\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"log.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"log.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <unistd.h>\n\nbool is_crucial_cgroup_subsystem(const char *s)\n{\n\tif (strcmp(s, \"systemd\") == 0)\n\t\treturn true;\n\tif (strcmp(s, \"name=systemd\") == 0)\n\t\treturn true;\n\tif (strcmp(s, \"freezer\") == 0)\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);\n\nstatic bool is_crucial_hierarchy(struct cgroup_hierarchy *h)\n{\n\tchar **p;\n\n\tfor (p = h->subsystems; *p; p++) {\n\t\tif (is_crucial_cgroup_subsystem(*p))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "cgroup_rename_nsgroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "775-834",
    "snippet": "static char *cgroup_rename_nsgroup(const char *mountpath, const char *oldname, pid_t pid, const char *name)\n{\n\tchar *dir, *fulloldpath;\n\tchar *newname, *fullnewpath;\n\tint len, newlen, ret;\n\n\t/*\n\t * if cgroup is mounted at /cgroup and task is in cgroup /ab/, pid 2375 and\n\t * name is c1,\n\t * dir: /ab\n\t * fulloldpath = /cgroup/ab/2375\n\t * fullnewpath = /cgroup/ab/c1\n\t * newname = /ab/c1\n\t */\n\tdir = alloca(strlen(oldname) + 1);\n\tstrcpy(dir, oldname);\n\n\tlen = strlen(oldname) + strlen(mountpath) + 22;\n\tfulloldpath = alloca(len);\n\tret = snprintf(fulloldpath, len, \"%s/%s/%ld\", mountpath, oldname, (unsigned long)pid);\n\tif (ret < 0 || ret >= len)\n\t\treturn NULL;\n\n\tlen = strlen(dir) + strlen(name) + 2;\n\tnewname = malloc(len);\n\tif (!newname) {\n\t\tSYSERROR(\"Out of memory\");\n\t\treturn NULL;\n\t}\n\tret = snprintf(newname, len, \"%s/%s\", dir, name);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(newname);\n\t\treturn NULL;\n\t}\n\n\tnewlen = strlen(mountpath) + len + 2;\n\tfullnewpath = alloca(newlen);\n\tret = snprintf(fullnewpath, newlen, \"%s/%s\", mountpath, newname);\n\tif (ret < 0 || ret >= newlen) {\n\t\tfree(newname);\n\t\treturn NULL;\n\t}\n\n\tif (access(fullnewpath, F_OK) == 0) {\n\t\tif (rmdir(fullnewpath) != 0) {\n\t\t\tSYSERROR(\"container cgroup %s already exists.\", fullnewpath);\n\t\t\tfree(newname);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (rename(fulloldpath, fullnewpath)) {\n\t\tSYSERROR(\"failed to rename cgroup %s->%s\", fulloldpath, fullnewpath);\n\t\tfree(newname);\n\t\treturn NULL;\n\t}\n\n\tDEBUG(\"'%s' renamed to '%s'\", oldname, newname);\n\n\treturn newname;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_valid_cgroup(const char *name);",
      "static int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"'%s' renamed to '%s'\"",
            "oldname",
            "newname"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "newname"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "cgfs_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2501-2518",
          "snippet": "static bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to rename cgroup %s->%s\"",
            "fulloldpath",
            "fullnewpath"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rename",
          "args": [
            "fulloldpath",
            "fullnewpath"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "do_lxcapi_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "3249-3282",
          "snippet": "static bool do_lxcapi_rename(struct lxc_container *c, const char *newname)\n{\n\tstruct bdev *bdev;\n\tstruct lxc_container *newc;\n\n\tif (!c || !c->name || !c->config_path || !c->lxc_conf)\n\t\treturn false;\n\n\tif (has_fs_snapshots(c) || has_snapshots(c)) {\n\t\tERROR(\"Renaming a container with snapshots is not supported\");\n\t\treturn false;\n\t}\n\tbdev = bdev_init(c->lxc_conf, c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);\n\tif (!bdev) {\n\t\tERROR(\"Failed to find original backing store type\");\n\t\treturn false;\n\t}\n\n\tnewc = lxcapi_clone(c, newname, c->config_path, LXC_CLONE_KEEPMACADDR, NULL, bdev->type, 0, NULL);\n\tbdev_put(bdev);\n\tif (!newc) {\n\t\tlxc_container_put(newc);\n\t\treturn false;\n\t}\n\n\tif (newc && lxcapi_is_defined(newc))\n\t\tlxc_container_put(newc);\n\n\tif (!container_destroy(c)) {\n\t\tERROR(\"Could not destroy existing container %s\", c->name);\n\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_rename(struct lxc_container *c, const char *newname)\n{\n\tstruct bdev *bdev;\n\tstruct lxc_container *newc;\n\n\tif (!c || !c->name || !c->config_path || !c->lxc_conf)\n\t\treturn false;\n\n\tif (has_fs_snapshots(c) || has_snapshots(c)) {\n\t\tERROR(\"Renaming a container with snapshots is not supported\");\n\t\treturn false;\n\t}\n\tbdev = bdev_init(c->lxc_conf, c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);\n\tif (!bdev) {\n\t\tERROR(\"Failed to find original backing store type\");\n\t\treturn false;\n\t}\n\n\tnewc = lxcapi_clone(c, newname, c->config_path, LXC_CLONE_KEEPMACADDR, NULL, bdev->type, 0, NULL);\n\tbdev_put(bdev);\n\tif (!newc) {\n\t\tlxc_container_put(newc);\n\t\treturn false;\n\t}\n\n\tif (newc && lxcapi_is_defined(newc))\n\t\tlxc_container_put(newc);\n\n\tif (!container_destroy(c)) {\n\t\tERROR(\"Could not destroy existing container %s\", c->name);\n\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"container cgroup %s already exists.\"",
            "fullnewpath"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmdir",
          "args": [
            "fullnewpath"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "rmdir_wrapper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "227-239",
          "snippet": "static int rmdir_wrapper(void *data)\n{\n\tchar *path = data;\n\n\tif (setresgid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setgid to 0\");\n\tif (setresuid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setuid to 0\");\n\tif (setgroups(0, NULL) < 0)\n\t\tSYSERROR(\"Failed to clear groups\");\n\n\treturn cgroup_rmdir(path);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
            "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\n\nstatic int rmdir_wrapper(void *data)\n{\n\tchar *path = data;\n\n\tif (setresgid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setgid to 0\");\n\tif (setresuid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setuid to 0\");\n\tif (setgroups(0, NULL) < 0)\n\t\tSYSERROR(\"Failed to clear groups\");\n\n\treturn cgroup_rmdir(path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "fullnewpath",
            "F_OK"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "fullnewpath",
            "newlen",
            "\"%s/%s\"",
            "mountpath",
            "newname"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "newlen"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "mountpath"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "newname",
            "len",
            "\"%s/%s\"",
            "dir",
            "name"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Out of memory\""
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dir"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "fulloldpath",
            "len",
            "\"%s/%s/%ld\"",
            "mountpath",
            "oldname",
            "(unsigned long)pid"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "len"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "mountpath"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "oldname"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dir",
            "oldname"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "strlen(oldname) + 1"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "oldname"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool is_valid_cgroup(const char *name);\nstatic int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);\n\nstatic char *cgroup_rename_nsgroup(const char *mountpath, const char *oldname, pid_t pid, const char *name)\n{\n\tchar *dir, *fulloldpath;\n\tchar *newname, *fullnewpath;\n\tint len, newlen, ret;\n\n\t/*\n\t * if cgroup is mounted at /cgroup and task is in cgroup /ab/, pid 2375 and\n\t * name is c1,\n\t * dir: /ab\n\t * fulloldpath = /cgroup/ab/2375\n\t * fullnewpath = /cgroup/ab/c1\n\t * newname = /ab/c1\n\t */\n\tdir = alloca(strlen(oldname) + 1);\n\tstrcpy(dir, oldname);\n\n\tlen = strlen(oldname) + strlen(mountpath) + 22;\n\tfulloldpath = alloca(len);\n\tret = snprintf(fulloldpath, len, \"%s/%s/%ld\", mountpath, oldname, (unsigned long)pid);\n\tif (ret < 0 || ret >= len)\n\t\treturn NULL;\n\n\tlen = strlen(dir) + strlen(name) + 2;\n\tnewname = malloc(len);\n\tif (!newname) {\n\t\tSYSERROR(\"Out of memory\");\n\t\treturn NULL;\n\t}\n\tret = snprintf(newname, len, \"%s/%s\", dir, name);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(newname);\n\t\treturn NULL;\n\t}\n\n\tnewlen = strlen(mountpath) + len + 2;\n\tfullnewpath = alloca(newlen);\n\tret = snprintf(fullnewpath, newlen, \"%s/%s\", mountpath, newname);\n\tif (ret < 0 || ret >= newlen) {\n\t\tfree(newname);\n\t\treturn NULL;\n\t}\n\n\tif (access(fullnewpath, F_OK) == 0) {\n\t\tif (rmdir(fullnewpath) != 0) {\n\t\t\tSYSERROR(\"container cgroup %s already exists.\", fullnewpath);\n\t\t\tfree(newname);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (rename(fulloldpath, fullnewpath)) {\n\t\tSYSERROR(\"failed to rename cgroup %s->%s\", fulloldpath, fullnewpath);\n\t\tfree(newname);\n\t\treturn NULL;\n\t}\n\n\tDEBUG(\"'%s' renamed to '%s'\", oldname, newname);\n\n\treturn newname;\n}"
  },
  {
    "function_name": "lxc_cgroup_process_info_get_self",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "759-766",
    "snippet": "static struct cgroup_process_info *lxc_cgroup_process_info_get_self(struct cgroup_meta_data *meta)\n{\n\tstruct cgroup_process_info *i;\n\ti = lxc_cgroup_process_info_getx(\"/proc/self/cgroup\", meta);\n\tif (!i)\n\t\ti = lxc_cgroup_process_info_get(getpid(), meta);\n\treturn i;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cgroup_process_info *lxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str, struct cgroup_meta_data *meta);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_cgroup_process_info_get",
          "args": [
            "getpid()",
            "meta"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_process_info_getx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1675-1779",
          "snippet": "static struct cgroup_process_info *\nlxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str,\n\t\t\t     struct cgroup_meta_data *meta)\n{\n\tstruct cgroup_process_info *result = NULL;\n\tFILE *proc_pid_cgroup = NULL;\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tint saved_errno = 0;\n\tstruct cgroup_process_info **cptr = &result;\n\tstruct cgroup_process_info *entry = NULL;\n\n\tproc_pid_cgroup = fopen_cloexec(proc_pid_cgroup_str, \"r\");\n\tif (!proc_pid_cgroup)\n\t\treturn NULL;\n\n\twhile (getline(&line, &sz, proc_pid_cgroup) != -1) {\n\t\t/* file format: hierarchy:subsystems:group */\n\t\tchar *colon1;\n\t\tchar *colon2;\n\t\tchar *endptr;\n\t\tint hierarchy_number;\n\t\tstruct cgroup_hierarchy *h = NULL;\n\n\t\tif (!line[0])\n\t\t\tcontinue;\n\n\t\tif (line[strlen(line) - 1] == '\\n')\n\t\t\tline[strlen(line) - 1] = '\\0';\n\n\t\tcolon1 = strchr(line, ':');\n\t\tif (!colon1)\n\t\t\tcontinue;\n\t\t*colon1++ = '\\0';\n\t\tcolon2 = strchr(colon1, ':');\n\t\tif (!colon2)\n\t\t\tcontinue;\n\t\t*colon2++ = '\\0';\n\n\t\tendptr = NULL;\n\n\t\t/* With cgroupv2 /proc/self/cgroup can contain entries of the\n\t\t * form: 0::/\n\t\t * These entries need to be skipped.\n\t\t */\n\t\tif (!strcmp(colon1, \"\"))\n\t\t\tcontinue;\n\n\t\thierarchy_number = strtoul(line, &endptr, 10);\n\t\tif (!endptr || *endptr)\n\t\t\tcontinue;\n\n\t\tif (hierarchy_number > meta->maximum_hierarchy) {\n\t\t\t/* we encountered a hierarchy we didn't have before,\n\t\t\t * so probably somebody remounted some stuff in the\n\t\t\t * mean time...\n\t\t\t */\n\t\t\terrno = EAGAIN;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\th = meta->hierarchies[hierarchy_number];\n\t\tif (!h) {\n\t\t\t/* we encountered a hierarchy that was thought to be\n\t\t\t * dead before, so probably somebody remounted some\n\t\t\t * stuff in the mean time...\n\t\t\t */\n\t\t\terrno = EAGAIN;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\t/* we are told that we should ignore this hierarchy */\n\t\tif (!h->used)\n\t\t\tcontinue;\n\n\t\tentry = calloc(1, sizeof(struct cgroup_process_info));\n\t\tif (!entry)\n\t\t\tgoto out_error;\n\n\t\tentry->meta_ref = lxc_cgroup_get_meta(meta);\n\t\tentry->hierarchy = h;\n\t\tentry->cgroup_path = strdup(colon2);\n\t\tif (!entry->cgroup_path)\n\t\t\tgoto out_error;\n\t\tprune_init_scope(entry->cgroup_path);\n\n\t\t*cptr = entry;\n\t\tcptr = &entry->next;\n\t\tentry = NULL;\n\t}\n\n\tfclose(proc_pid_cgroup);\n\tfree(line);\n\treturn result;\n\nout_error:\n\tsaved_errno = errno;\n\tif (proc_pid_cgroup)\n\t\tfclose(proc_pid_cgroup);\n\tlxc_cgroup_process_info_free(result);\n\tlxc_cgroup_process_info_free(entry);\n\tfree(line);\n\terrno = saved_errno;\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_process_info *lxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str, struct cgroup_meta_data *meta);",
            "static void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);",
            "static int cgroup_recursive_task_count(const char *cgroup_path);",
            "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_process_info *lxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str, struct cgroup_meta_data *meta);\nstatic void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\n\nstatic struct cgroup_process_info *\nlxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str,\n\t\t\t     struct cgroup_meta_data *meta)\n{\n\tstruct cgroup_process_info *result = NULL;\n\tFILE *proc_pid_cgroup = NULL;\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tint saved_errno = 0;\n\tstruct cgroup_process_info **cptr = &result;\n\tstruct cgroup_process_info *entry = NULL;\n\n\tproc_pid_cgroup = fopen_cloexec(proc_pid_cgroup_str, \"r\");\n\tif (!proc_pid_cgroup)\n\t\treturn NULL;\n\n\twhile (getline(&line, &sz, proc_pid_cgroup) != -1) {\n\t\t/* file format: hierarchy:subsystems:group */\n\t\tchar *colon1;\n\t\tchar *colon2;\n\t\tchar *endptr;\n\t\tint hierarchy_number;\n\t\tstruct cgroup_hierarchy *h = NULL;\n\n\t\tif (!line[0])\n\t\t\tcontinue;\n\n\t\tif (line[strlen(line) - 1] == '\\n')\n\t\t\tline[strlen(line) - 1] = '\\0';\n\n\t\tcolon1 = strchr(line, ':');\n\t\tif (!colon1)\n\t\t\tcontinue;\n\t\t*colon1++ = '\\0';\n\t\tcolon2 = strchr(colon1, ':');\n\t\tif (!colon2)\n\t\t\tcontinue;\n\t\t*colon2++ = '\\0';\n\n\t\tendptr = NULL;\n\n\t\t/* With cgroupv2 /proc/self/cgroup can contain entries of the\n\t\t * form: 0::/\n\t\t * These entries need to be skipped.\n\t\t */\n\t\tif (!strcmp(colon1, \"\"))\n\t\t\tcontinue;\n\n\t\thierarchy_number = strtoul(line, &endptr, 10);\n\t\tif (!endptr || *endptr)\n\t\t\tcontinue;\n\n\t\tif (hierarchy_number > meta->maximum_hierarchy) {\n\t\t\t/* we encountered a hierarchy we didn't have before,\n\t\t\t * so probably somebody remounted some stuff in the\n\t\t\t * mean time...\n\t\t\t */\n\t\t\terrno = EAGAIN;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\th = meta->hierarchies[hierarchy_number];\n\t\tif (!h) {\n\t\t\t/* we encountered a hierarchy that was thought to be\n\t\t\t * dead before, so probably somebody remounted some\n\t\t\t * stuff in the mean time...\n\t\t\t */\n\t\t\terrno = EAGAIN;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\t/* we are told that we should ignore this hierarchy */\n\t\tif (!h->used)\n\t\t\tcontinue;\n\n\t\tentry = calloc(1, sizeof(struct cgroup_process_info));\n\t\tif (!entry)\n\t\t\tgoto out_error;\n\n\t\tentry->meta_ref = lxc_cgroup_get_meta(meta);\n\t\tentry->hierarchy = h;\n\t\tentry->cgroup_path = strdup(colon2);\n\t\tif (!entry->cgroup_path)\n\t\t\tgoto out_error;\n\t\tprune_init_scope(entry->cgroup_path);\n\n\t\t*cptr = entry;\n\t\tcptr = &entry->next;\n\t\tentry = NULL;\n\t}\n\n\tfclose(proc_pid_cgroup);\n\tfree(line);\n\treturn result;\n\nout_error:\n\tsaved_errno = errno;\n\tif (proc_pid_cgroup)\n\t\tfclose(proc_pid_cgroup);\n\tlxc_cgroup_process_info_free(result);\n\tlxc_cgroup_process_info_free(entry);\n\tfree(line);\n\terrno = saved_errno;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_process_info *lxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str, struct cgroup_meta_data *meta);\n\nstatic struct cgroup_process_info *lxc_cgroup_process_info_get_self(struct cgroup_meta_data *meta)\n{\n\tstruct cgroup_process_info *i;\n\ti = lxc_cgroup_process_info_getx(\"/proc/self/cgroup\", meta);\n\tif (!i)\n\t\ti = lxc_cgroup_process_info_get(getpid(), meta);\n\treturn i;\n}"
  },
  {
    "function_name": "lxc_cgroup_process_info_get_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "754-757",
    "snippet": "static struct cgroup_process_info *lxc_cgroup_process_info_get_init(struct cgroup_meta_data *meta)\n{\n\treturn lxc_cgroup_process_info_get(1, meta);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cgroup_process_info *lxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str, struct cgroup_meta_data *meta);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_cgroup_process_info_get",
          "args": [
            "1",
            "meta"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_process_info_getx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1675-1779",
          "snippet": "static struct cgroup_process_info *\nlxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str,\n\t\t\t     struct cgroup_meta_data *meta)\n{\n\tstruct cgroup_process_info *result = NULL;\n\tFILE *proc_pid_cgroup = NULL;\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tint saved_errno = 0;\n\tstruct cgroup_process_info **cptr = &result;\n\tstruct cgroup_process_info *entry = NULL;\n\n\tproc_pid_cgroup = fopen_cloexec(proc_pid_cgroup_str, \"r\");\n\tif (!proc_pid_cgroup)\n\t\treturn NULL;\n\n\twhile (getline(&line, &sz, proc_pid_cgroup) != -1) {\n\t\t/* file format: hierarchy:subsystems:group */\n\t\tchar *colon1;\n\t\tchar *colon2;\n\t\tchar *endptr;\n\t\tint hierarchy_number;\n\t\tstruct cgroup_hierarchy *h = NULL;\n\n\t\tif (!line[0])\n\t\t\tcontinue;\n\n\t\tif (line[strlen(line) - 1] == '\\n')\n\t\t\tline[strlen(line) - 1] = '\\0';\n\n\t\tcolon1 = strchr(line, ':');\n\t\tif (!colon1)\n\t\t\tcontinue;\n\t\t*colon1++ = '\\0';\n\t\tcolon2 = strchr(colon1, ':');\n\t\tif (!colon2)\n\t\t\tcontinue;\n\t\t*colon2++ = '\\0';\n\n\t\tendptr = NULL;\n\n\t\t/* With cgroupv2 /proc/self/cgroup can contain entries of the\n\t\t * form: 0::/\n\t\t * These entries need to be skipped.\n\t\t */\n\t\tif (!strcmp(colon1, \"\"))\n\t\t\tcontinue;\n\n\t\thierarchy_number = strtoul(line, &endptr, 10);\n\t\tif (!endptr || *endptr)\n\t\t\tcontinue;\n\n\t\tif (hierarchy_number > meta->maximum_hierarchy) {\n\t\t\t/* we encountered a hierarchy we didn't have before,\n\t\t\t * so probably somebody remounted some stuff in the\n\t\t\t * mean time...\n\t\t\t */\n\t\t\terrno = EAGAIN;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\th = meta->hierarchies[hierarchy_number];\n\t\tif (!h) {\n\t\t\t/* we encountered a hierarchy that was thought to be\n\t\t\t * dead before, so probably somebody remounted some\n\t\t\t * stuff in the mean time...\n\t\t\t */\n\t\t\terrno = EAGAIN;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\t/* we are told that we should ignore this hierarchy */\n\t\tif (!h->used)\n\t\t\tcontinue;\n\n\t\tentry = calloc(1, sizeof(struct cgroup_process_info));\n\t\tif (!entry)\n\t\t\tgoto out_error;\n\n\t\tentry->meta_ref = lxc_cgroup_get_meta(meta);\n\t\tentry->hierarchy = h;\n\t\tentry->cgroup_path = strdup(colon2);\n\t\tif (!entry->cgroup_path)\n\t\t\tgoto out_error;\n\t\tprune_init_scope(entry->cgroup_path);\n\n\t\t*cptr = entry;\n\t\tcptr = &entry->next;\n\t\tentry = NULL;\n\t}\n\n\tfclose(proc_pid_cgroup);\n\tfree(line);\n\treturn result;\n\nout_error:\n\tsaved_errno = errno;\n\tif (proc_pid_cgroup)\n\t\tfclose(proc_pid_cgroup);\n\tlxc_cgroup_process_info_free(result);\n\tlxc_cgroup_process_info_free(entry);\n\tfree(line);\n\terrno = saved_errno;\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_process_info *lxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str, struct cgroup_meta_data *meta);",
            "static void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);",
            "static int cgroup_recursive_task_count(const char *cgroup_path);",
            "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_process_info *lxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str, struct cgroup_meta_data *meta);\nstatic void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\n\nstatic struct cgroup_process_info *\nlxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str,\n\t\t\t     struct cgroup_meta_data *meta)\n{\n\tstruct cgroup_process_info *result = NULL;\n\tFILE *proc_pid_cgroup = NULL;\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tint saved_errno = 0;\n\tstruct cgroup_process_info **cptr = &result;\n\tstruct cgroup_process_info *entry = NULL;\n\n\tproc_pid_cgroup = fopen_cloexec(proc_pid_cgroup_str, \"r\");\n\tif (!proc_pid_cgroup)\n\t\treturn NULL;\n\n\twhile (getline(&line, &sz, proc_pid_cgroup) != -1) {\n\t\t/* file format: hierarchy:subsystems:group */\n\t\tchar *colon1;\n\t\tchar *colon2;\n\t\tchar *endptr;\n\t\tint hierarchy_number;\n\t\tstruct cgroup_hierarchy *h = NULL;\n\n\t\tif (!line[0])\n\t\t\tcontinue;\n\n\t\tif (line[strlen(line) - 1] == '\\n')\n\t\t\tline[strlen(line) - 1] = '\\0';\n\n\t\tcolon1 = strchr(line, ':');\n\t\tif (!colon1)\n\t\t\tcontinue;\n\t\t*colon1++ = '\\0';\n\t\tcolon2 = strchr(colon1, ':');\n\t\tif (!colon2)\n\t\t\tcontinue;\n\t\t*colon2++ = '\\0';\n\n\t\tendptr = NULL;\n\n\t\t/* With cgroupv2 /proc/self/cgroup can contain entries of the\n\t\t * form: 0::/\n\t\t * These entries need to be skipped.\n\t\t */\n\t\tif (!strcmp(colon1, \"\"))\n\t\t\tcontinue;\n\n\t\thierarchy_number = strtoul(line, &endptr, 10);\n\t\tif (!endptr || *endptr)\n\t\t\tcontinue;\n\n\t\tif (hierarchy_number > meta->maximum_hierarchy) {\n\t\t\t/* we encountered a hierarchy we didn't have before,\n\t\t\t * so probably somebody remounted some stuff in the\n\t\t\t * mean time...\n\t\t\t */\n\t\t\terrno = EAGAIN;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\th = meta->hierarchies[hierarchy_number];\n\t\tif (!h) {\n\t\t\t/* we encountered a hierarchy that was thought to be\n\t\t\t * dead before, so probably somebody remounted some\n\t\t\t * stuff in the mean time...\n\t\t\t */\n\t\t\terrno = EAGAIN;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\t/* we are told that we should ignore this hierarchy */\n\t\tif (!h->used)\n\t\t\tcontinue;\n\n\t\tentry = calloc(1, sizeof(struct cgroup_process_info));\n\t\tif (!entry)\n\t\t\tgoto out_error;\n\n\t\tentry->meta_ref = lxc_cgroup_get_meta(meta);\n\t\tentry->hierarchy = h;\n\t\tentry->cgroup_path = strdup(colon2);\n\t\tif (!entry->cgroup_path)\n\t\t\tgoto out_error;\n\t\tprune_init_scope(entry->cgroup_path);\n\n\t\t*cptr = entry;\n\t\tcptr = &entry->next;\n\t\tentry = NULL;\n\t}\n\n\tfclose(proc_pid_cgroup);\n\tfree(line);\n\treturn result;\n\nout_error:\n\tsaved_errno = errno;\n\tif (proc_pid_cgroup)\n\t\tfclose(proc_pid_cgroup);\n\tlxc_cgroup_process_info_free(result);\n\tlxc_cgroup_process_info_free(entry);\n\tfree(line);\n\terrno = saved_errno;\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_process_info *lxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str, struct cgroup_meta_data *meta);\n\nstatic struct cgroup_process_info *lxc_cgroup_process_info_get_init(struct cgroup_meta_data *meta)\n{\n\treturn lxc_cgroup_process_info_get(1, meta);\n}"
  },
  {
    "function_name": "lxc_cgroup_process_info_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "747-752",
    "snippet": "static struct cgroup_process_info *lxc_cgroup_process_info_get(pid_t pid, struct cgroup_meta_data *meta)\n{\n\tchar pid_buf[32];\n\tsnprintf(pid_buf, 32, \"/proc/%lu/cgroup\", (unsigned long)pid);\n\treturn lxc_cgroup_process_info_getx(pid_buf, meta);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cgroup_process_info *lxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str, struct cgroup_meta_data *meta);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_cgroup_process_info_getx",
          "args": [
            "pid_buf",
            "meta"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_process_info_getx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1675-1779",
          "snippet": "static struct cgroup_process_info *\nlxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str,\n\t\t\t     struct cgroup_meta_data *meta)\n{\n\tstruct cgroup_process_info *result = NULL;\n\tFILE *proc_pid_cgroup = NULL;\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tint saved_errno = 0;\n\tstruct cgroup_process_info **cptr = &result;\n\tstruct cgroup_process_info *entry = NULL;\n\n\tproc_pid_cgroup = fopen_cloexec(proc_pid_cgroup_str, \"r\");\n\tif (!proc_pid_cgroup)\n\t\treturn NULL;\n\n\twhile (getline(&line, &sz, proc_pid_cgroup) != -1) {\n\t\t/* file format: hierarchy:subsystems:group */\n\t\tchar *colon1;\n\t\tchar *colon2;\n\t\tchar *endptr;\n\t\tint hierarchy_number;\n\t\tstruct cgroup_hierarchy *h = NULL;\n\n\t\tif (!line[0])\n\t\t\tcontinue;\n\n\t\tif (line[strlen(line) - 1] == '\\n')\n\t\t\tline[strlen(line) - 1] = '\\0';\n\n\t\tcolon1 = strchr(line, ':');\n\t\tif (!colon1)\n\t\t\tcontinue;\n\t\t*colon1++ = '\\0';\n\t\tcolon2 = strchr(colon1, ':');\n\t\tif (!colon2)\n\t\t\tcontinue;\n\t\t*colon2++ = '\\0';\n\n\t\tendptr = NULL;\n\n\t\t/* With cgroupv2 /proc/self/cgroup can contain entries of the\n\t\t * form: 0::/\n\t\t * These entries need to be skipped.\n\t\t */\n\t\tif (!strcmp(colon1, \"\"))\n\t\t\tcontinue;\n\n\t\thierarchy_number = strtoul(line, &endptr, 10);\n\t\tif (!endptr || *endptr)\n\t\t\tcontinue;\n\n\t\tif (hierarchy_number > meta->maximum_hierarchy) {\n\t\t\t/* we encountered a hierarchy we didn't have before,\n\t\t\t * so probably somebody remounted some stuff in the\n\t\t\t * mean time...\n\t\t\t */\n\t\t\terrno = EAGAIN;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\th = meta->hierarchies[hierarchy_number];\n\t\tif (!h) {\n\t\t\t/* we encountered a hierarchy that was thought to be\n\t\t\t * dead before, so probably somebody remounted some\n\t\t\t * stuff in the mean time...\n\t\t\t */\n\t\t\terrno = EAGAIN;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\t/* we are told that we should ignore this hierarchy */\n\t\tif (!h->used)\n\t\t\tcontinue;\n\n\t\tentry = calloc(1, sizeof(struct cgroup_process_info));\n\t\tif (!entry)\n\t\t\tgoto out_error;\n\n\t\tentry->meta_ref = lxc_cgroup_get_meta(meta);\n\t\tentry->hierarchy = h;\n\t\tentry->cgroup_path = strdup(colon2);\n\t\tif (!entry->cgroup_path)\n\t\t\tgoto out_error;\n\t\tprune_init_scope(entry->cgroup_path);\n\n\t\t*cptr = entry;\n\t\tcptr = &entry->next;\n\t\tentry = NULL;\n\t}\n\n\tfclose(proc_pid_cgroup);\n\tfree(line);\n\treturn result;\n\nout_error:\n\tsaved_errno = errno;\n\tif (proc_pid_cgroup)\n\t\tfclose(proc_pid_cgroup);\n\tlxc_cgroup_process_info_free(result);\n\tlxc_cgroup_process_info_free(entry);\n\tfree(line);\n\terrno = saved_errno;\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_process_info *lxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str, struct cgroup_meta_data *meta);",
            "static void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);",
            "static int cgroup_recursive_task_count(const char *cgroup_path);",
            "static int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_process_info *lxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str, struct cgroup_meta_data *meta);\nstatic void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);\nstatic int cgroup_recursive_task_count(const char *cgroup_path);\nstatic int handle_cgroup_settings(struct cgroup_mount_point *mp, char *cgroup_path);\n\nstatic struct cgroup_process_info *\nlxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str,\n\t\t\t     struct cgroup_meta_data *meta)\n{\n\tstruct cgroup_process_info *result = NULL;\n\tFILE *proc_pid_cgroup = NULL;\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tint saved_errno = 0;\n\tstruct cgroup_process_info **cptr = &result;\n\tstruct cgroup_process_info *entry = NULL;\n\n\tproc_pid_cgroup = fopen_cloexec(proc_pid_cgroup_str, \"r\");\n\tif (!proc_pid_cgroup)\n\t\treturn NULL;\n\n\twhile (getline(&line, &sz, proc_pid_cgroup) != -1) {\n\t\t/* file format: hierarchy:subsystems:group */\n\t\tchar *colon1;\n\t\tchar *colon2;\n\t\tchar *endptr;\n\t\tint hierarchy_number;\n\t\tstruct cgroup_hierarchy *h = NULL;\n\n\t\tif (!line[0])\n\t\t\tcontinue;\n\n\t\tif (line[strlen(line) - 1] == '\\n')\n\t\t\tline[strlen(line) - 1] = '\\0';\n\n\t\tcolon1 = strchr(line, ':');\n\t\tif (!colon1)\n\t\t\tcontinue;\n\t\t*colon1++ = '\\0';\n\t\tcolon2 = strchr(colon1, ':');\n\t\tif (!colon2)\n\t\t\tcontinue;\n\t\t*colon2++ = '\\0';\n\n\t\tendptr = NULL;\n\n\t\t/* With cgroupv2 /proc/self/cgroup can contain entries of the\n\t\t * form: 0::/\n\t\t * These entries need to be skipped.\n\t\t */\n\t\tif (!strcmp(colon1, \"\"))\n\t\t\tcontinue;\n\n\t\thierarchy_number = strtoul(line, &endptr, 10);\n\t\tif (!endptr || *endptr)\n\t\t\tcontinue;\n\n\t\tif (hierarchy_number > meta->maximum_hierarchy) {\n\t\t\t/* we encountered a hierarchy we didn't have before,\n\t\t\t * so probably somebody remounted some stuff in the\n\t\t\t * mean time...\n\t\t\t */\n\t\t\terrno = EAGAIN;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\th = meta->hierarchies[hierarchy_number];\n\t\tif (!h) {\n\t\t\t/* we encountered a hierarchy that was thought to be\n\t\t\t * dead before, so probably somebody remounted some\n\t\t\t * stuff in the mean time...\n\t\t\t */\n\t\t\terrno = EAGAIN;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\t/* we are told that we should ignore this hierarchy */\n\t\tif (!h->used)\n\t\t\tcontinue;\n\n\t\tentry = calloc(1, sizeof(struct cgroup_process_info));\n\t\tif (!entry)\n\t\t\tgoto out_error;\n\n\t\tentry->meta_ref = lxc_cgroup_get_meta(meta);\n\t\tentry->hierarchy = h;\n\t\tentry->cgroup_path = strdup(colon2);\n\t\tif (!entry->cgroup_path)\n\t\t\tgoto out_error;\n\t\tprune_init_scope(entry->cgroup_path);\n\n\t\t*cptr = entry;\n\t\tcptr = &entry->next;\n\t\tentry = NULL;\n\t}\n\n\tfclose(proc_pid_cgroup);\n\tfree(line);\n\treturn result;\n\nout_error:\n\tsaved_errno = errno;\n\tif (proc_pid_cgroup)\n\t\tfclose(proc_pid_cgroup);\n\tlxc_cgroup_process_info_free(result);\n\tlxc_cgroup_process_info_free(entry);\n\tfree(line);\n\terrno = saved_errno;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "pid_buf",
            "32",
            "\"/proc/%lu/cgroup\"",
            "(unsigned long)pid"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_process_info *lxc_cgroup_process_info_getx(const char *proc_pid_cgroup_str, struct cgroup_meta_data *meta);\n\nstatic struct cgroup_process_info *lxc_cgroup_process_info_get(pid_t pid, struct cgroup_meta_data *meta)\n{\n\tchar pid_buf[32];\n\tsnprintf(pid_buf, 32, \"/proc/%lu/cgroup\", (unsigned long)pid);\n\treturn lxc_cgroup_process_info_getx(pid_buf, meta);\n}"
  },
  {
    "function_name": "lxc_cgroup_find_abs_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "713-745",
    "snippet": "static char *lxc_cgroup_find_abs_path(const char *subsystem, const char *group, bool should_be_writable, const char *suffix)\n{\n\tstruct cgroup_meta_data *meta_data;\n\tstruct cgroup_hierarchy *h;\n\tstruct cgroup_mount_point *mp;\n\tchar *result;\n\tint saved_errno;\n\n\tmeta_data = lxc_cgroup_load_meta();\n\tif (!meta_data)\n\t\treturn NULL;\n\n\th = lxc_cgroup_find_hierarchy(meta_data, subsystem);\n\tif (!h)\n\t\tgoto out_error;\n\n\tmp = lxc_cgroup_find_mount_point(h, group, should_be_writable);\n\tif (!mp)\n\t\tgoto out_error;\n\n\tresult = cgroup_to_absolute_path(mp, group, suffix);\n\tif (!result)\n\t\tgoto out_error;\n\n\tlxc_cgroup_put_meta(meta_data);\n\treturn result;\n\nout_error:\n\tsaved_errno = errno;\n\tlxc_cgroup_put_meta(meta_data);\n\terrno = saved_errno;\n\treturn NULL;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
      "static void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);",
      "static char *cgroup_to_absolute_path(struct cgroup_mount_point *mp, const char *path, const char *suffix);",
      "static struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);",
      "static struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);",
      "static struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_cgroup_put_meta",
          "args": [
            "meta_data"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_put_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "635-650",
          "snippet": "static struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data)\n{\n\tsize_t i;\n\tif (!meta_data)\n\t\treturn NULL;\n\tif (--meta_data->ref > 0)\n\t\treturn meta_data;\n\tlxc_free_array((void **)meta_data->mount_points, (lxc_free_fn)lxc_cgroup_mount_point_free);\n\tif (meta_data->hierarchies)\n\t\tfor (i = 0; i <= meta_data->maximum_hierarchy; i++)\n\t\t\tif (meta_data->hierarchies[i])\n\t\t\t\tlxc_cgroup_hierarchy_free(meta_data->hierarchies[i]);\n\tfree(meta_data->hierarchies);\n\tfree(meta_data);\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);",
            "static struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);\nstatic struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);\n\nstatic struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data)\n{\n\tsize_t i;\n\tif (!meta_data)\n\t\treturn NULL;\n\tif (--meta_data->ref > 0)\n\t\treturn meta_data;\n\tlxc_free_array((void **)meta_data->mount_points, (lxc_free_fn)lxc_cgroup_mount_point_free);\n\tif (meta_data->hierarchies)\n\t\tfor (i = 0; i <= meta_data->maximum_hierarchy; i++)\n\t\t\tif (meta_data->hierarchies[i])\n\t\t\t\tlxc_cgroup_hierarchy_free(meta_data->hierarchies[i]);\n\tfree(meta_data->hierarchies);\n\tfree(meta_data);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_to_absolute_path",
          "args": [
            "mp",
            "group",
            "suffix"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_to_absolute_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1901-1944",
          "snippet": "static char *cgroup_to_absolute_path(struct cgroup_mount_point *mp,\n\t\t\t\t     const char *path, const char *suffix)\n{\n\t/* first we have to make sure we subtract the mount point's prefix */\n\tchar *prefix = mp->mount_prefix;\n\tchar *buf;\n\tssize_t len, rv;\n\n\t/* we want to make sure only absolute paths to cgroups are passed to us */\n\tif (path[0] != '/') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (prefix && !strcmp(prefix, \"/\"))\n\t\tprefix = NULL;\n\n\t/* prefix doesn't match */\n\tif (prefix && strncmp(prefix, path, strlen(prefix)) != 0) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\t/* if prefix is /foo and path is /foobar */\n\tif (prefix && path[strlen(prefix)] != '/' && path[strlen(prefix)] != '\\0') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\t/* remove prefix from path */\n\tpath += prefix ? strlen(prefix) : 0;\n\n\tlen = strlen(mp->mount_point) + strlen(path) + (suffix ? strlen(suffix) : 0);\n\tbuf = calloc(len + 1, 1);\n\tif (!buf)\n\t\treturn NULL;\n\trv = snprintf(buf, len + 1, \"%s%s%s\", mp->mount_point, path, suffix ? suffix : \"\");\n\tif (rv > len) {\n\t\tfree(buf);\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\treturn buf;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);",
            "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
            "static char *cgroup_to_absolute_path(struct cgroup_mount_point *mp, const char *path, const char *suffix);",
            "static int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);",
            "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic char *cgroup_to_absolute_path(struct cgroup_mount_point *mp, const char *path, const char *suffix);\nstatic int do_cgroup_get(const char *cgroup_path, const char *sub_filename, char *value, size_t len);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\n\nstatic char *cgroup_to_absolute_path(struct cgroup_mount_point *mp,\n\t\t\t\t     const char *path, const char *suffix)\n{\n\t/* first we have to make sure we subtract the mount point's prefix */\n\tchar *prefix = mp->mount_prefix;\n\tchar *buf;\n\tssize_t len, rv;\n\n\t/* we want to make sure only absolute paths to cgroups are passed to us */\n\tif (path[0] != '/') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (prefix && !strcmp(prefix, \"/\"))\n\t\tprefix = NULL;\n\n\t/* prefix doesn't match */\n\tif (prefix && strncmp(prefix, path, strlen(prefix)) != 0) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\t/* if prefix is /foo and path is /foobar */\n\tif (prefix && path[strlen(prefix)] != '/' && path[strlen(prefix)] != '\\0') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\t/* remove prefix from path */\n\tpath += prefix ? strlen(prefix) : 0;\n\n\tlen = strlen(mp->mount_point) + strlen(path) + (suffix ? strlen(suffix) : 0);\n\tbuf = calloc(len + 1, 1);\n\tif (!buf)\n\t\treturn NULL;\n\trv = snprintf(buf, len + 1, \"%s%s%s\", mp->mount_point, path, suffix ? suffix : \"\");\n\tif (rv > len) {\n\t\tfree(buf);\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_find_mount_point",
          "args": [
            "h",
            "group",
            "should_be_writable"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_find_mount_point",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "670-711",
          "snippet": "static struct cgroup_mount_point *lxc_cgroup_find_mount_point(struct cgroup_hierarchy *hierarchy, const char *group, bool should_be_writable)\n{\n\tstruct cgroup_mount_point **mps;\n\tstruct cgroup_mount_point *current_result = NULL;\n\tssize_t quality = -1;\n\n\t/* trivial case */\n\tif (mountpoint_is_accessible(hierarchy->rw_absolute_mount_point))\n\t\treturn hierarchy->rw_absolute_mount_point;\n\tif (!should_be_writable && mountpoint_is_accessible(hierarchy->ro_absolute_mount_point))\n\t\treturn hierarchy->ro_absolute_mount_point;\n\n\tfor (mps = hierarchy->all_mount_points; mps && *mps; mps++) {\n\t\tstruct cgroup_mount_point *mp = *mps;\n\t\tsize_t prefix_len = mp->mount_prefix ? strlen(mp->mount_prefix) : 0;\n\n\t\tif (prefix_len == 1 && mp->mount_prefix[0] == '/')\n\t\t\tprefix_len = 0;\n\n\t\tif (!mountpoint_is_accessible(mp))\n\t\t\tcontinue;\n\n\t\tif (should_be_writable && mp->read_only)\n\t\t\tcontinue;\n\n\t\tif (!prefix_len ||\n\t\t    (strncmp(group, mp->mount_prefix, prefix_len) == 0 &&\n\t\t     (group[prefix_len] == '\\0' || group[prefix_len] == '/'))) {\n\t\t\t/* search for the best quality match, i.e. the match with the\n\t\t\t * shortest prefix where this group is still contained\n\t\t\t */\n\t\t\tif (quality == -1 || prefix_len < quality) {\n\t\t\t\tcurrent_result = mp;\n\t\t\t\tquality = prefix_len;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!current_result)\n\t\terrno = ENOENT;\n\treturn current_result;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\n\nstatic struct cgroup_mount_point *lxc_cgroup_find_mount_point(struct cgroup_hierarchy *hierarchy, const char *group, bool should_be_writable)\n{\n\tstruct cgroup_mount_point **mps;\n\tstruct cgroup_mount_point *current_result = NULL;\n\tssize_t quality = -1;\n\n\t/* trivial case */\n\tif (mountpoint_is_accessible(hierarchy->rw_absolute_mount_point))\n\t\treturn hierarchy->rw_absolute_mount_point;\n\tif (!should_be_writable && mountpoint_is_accessible(hierarchy->ro_absolute_mount_point))\n\t\treturn hierarchy->ro_absolute_mount_point;\n\n\tfor (mps = hierarchy->all_mount_points; mps && *mps; mps++) {\n\t\tstruct cgroup_mount_point *mp = *mps;\n\t\tsize_t prefix_len = mp->mount_prefix ? strlen(mp->mount_prefix) : 0;\n\n\t\tif (prefix_len == 1 && mp->mount_prefix[0] == '/')\n\t\t\tprefix_len = 0;\n\n\t\tif (!mountpoint_is_accessible(mp))\n\t\t\tcontinue;\n\n\t\tif (should_be_writable && mp->read_only)\n\t\t\tcontinue;\n\n\t\tif (!prefix_len ||\n\t\t    (strncmp(group, mp->mount_prefix, prefix_len) == 0 &&\n\t\t     (group[prefix_len] == '\\0' || group[prefix_len] == '/'))) {\n\t\t\t/* search for the best quality match, i.e. the match with the\n\t\t\t * shortest prefix where this group is still contained\n\t\t\t */\n\t\t\tif (quality == -1 || prefix_len < quality) {\n\t\t\t\tcurrent_result = mp;\n\t\t\t\tquality = prefix_len;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!current_result)\n\t\terrno = ENOENT;\n\treturn current_result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_find_hierarchy",
          "args": [
            "meta_data",
            "subsystem"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_find_hierarchy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "652-663",
          "snippet": "static struct cgroup_hierarchy *lxc_cgroup_find_hierarchy(struct cgroup_meta_data *meta_data, const char *subsystem)\n{\n\tsize_t i;\n\tfor (i = 0; i <= meta_data->maximum_hierarchy; i++) {\n\t\tstruct cgroup_hierarchy *h = meta_data->hierarchies[i];\n\t\tif (!h)\n\t\t\tcontinue;\n\t\tif (h && lxc_string_in_array(subsystem, (const char **)h->subsystems))\n\t\t\treturn h;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);",
            "static struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);",
            "static struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);",
            "static struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);\nstatic struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);\nstatic struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);\nstatic struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);\n\nstatic struct cgroup_hierarchy *lxc_cgroup_find_hierarchy(struct cgroup_meta_data *meta_data, const char *subsystem)\n{\n\tsize_t i;\n\tfor (i = 0; i <= meta_data->maximum_hierarchy; i++) {\n\t\tstruct cgroup_hierarchy *h = meta_data->hierarchies[i];\n\t\tif (!h)\n\t\t\tcontinue;\n\t\tif (h && lxc_string_in_array(subsystem, (const char **)h->subsystems))\n\t\t\treturn h;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_load_meta",
          "args": [],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_load_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "241-263",
          "snippet": "static struct cgroup_meta_data *lxc_cgroup_load_meta()\n{\n\tconst char *cgroup_use = NULL;\n\tchar **cgroup_use_list = NULL;\n\tstruct cgroup_meta_data *md = NULL;\n\tint saved_errno;\n\n\terrno = 0;\n\tcgroup_use = lxc_global_config_value(\"lxc.cgroup.use\");\n\tif (!cgroup_use && errno != 0)\n\t\treturn NULL;\n\tif (cgroup_use) {\n\t\tcgroup_use_list = lxc_string_split_and_trim(cgroup_use, ',');\n\t\tif (!cgroup_use_list)\n\t\t\treturn NULL;\n\t}\n\n\tmd = lxc_cgroup_load_meta2((const char **)cgroup_use_list);\n\tsaved_errno = errno;\n\tlxc_free_array((void **)cgroup_use_list, free);\n\terrno = saved_errno;\n\treturn md;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_meta_data *lxc_cgroup_load_meta()\n{\n\tconst char *cgroup_use = NULL;\n\tchar **cgroup_use_list = NULL;\n\tstruct cgroup_meta_data *md = NULL;\n\tint saved_errno;\n\n\terrno = 0;\n\tcgroup_use = lxc_global_config_value(\"lxc.cgroup.use\");\n\tif (!cgroup_use && errno != 0)\n\t\treturn NULL;\n\tif (cgroup_use) {\n\t\tcgroup_use_list = lxc_string_split_and_trim(cgroup_use, ',');\n\t\tif (!cgroup_use_list)\n\t\t\treturn NULL;\n\t}\n\n\tmd = lxc_cgroup_load_meta2((const char **)cgroup_use_list);\n\tsaved_errno = errno;\n\tlxc_free_array((void **)cgroup_use_list, free);\n\terrno = saved_errno;\n\treturn md;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\nstatic void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);\nstatic char *cgroup_to_absolute_path(struct cgroup_mount_point *mp, const char *path, const char *suffix);\nstatic struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);\nstatic struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);\nstatic struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);\n\nstatic char *lxc_cgroup_find_abs_path(const char *subsystem, const char *group, bool should_be_writable, const char *suffix)\n{\n\tstruct cgroup_meta_data *meta_data;\n\tstruct cgroup_hierarchy *h;\n\tstruct cgroup_mount_point *mp;\n\tchar *result;\n\tint saved_errno;\n\n\tmeta_data = lxc_cgroup_load_meta();\n\tif (!meta_data)\n\t\treturn NULL;\n\n\th = lxc_cgroup_find_hierarchy(meta_data, subsystem);\n\tif (!h)\n\t\tgoto out_error;\n\n\tmp = lxc_cgroup_find_mount_point(h, group, should_be_writable);\n\tif (!mp)\n\t\tgoto out_error;\n\n\tresult = cgroup_to_absolute_path(mp, group, suffix);\n\tif (!result)\n\t\tgoto out_error;\n\n\tlxc_cgroup_put_meta(meta_data);\n\treturn result;\n\nout_error:\n\tsaved_errno = errno;\n\tlxc_cgroup_put_meta(meta_data);\n\terrno = saved_errno;\n\treturn NULL;\n}"
  },
  {
    "function_name": "lxc_cgroup_find_mount_point",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "670-711",
    "snippet": "static struct cgroup_mount_point *lxc_cgroup_find_mount_point(struct cgroup_hierarchy *hierarchy, const char *group, bool should_be_writable)\n{\n\tstruct cgroup_mount_point **mps;\n\tstruct cgroup_mount_point *current_result = NULL;\n\tssize_t quality = -1;\n\n\t/* trivial case */\n\tif (mountpoint_is_accessible(hierarchy->rw_absolute_mount_point))\n\t\treturn hierarchy->rw_absolute_mount_point;\n\tif (!should_be_writable && mountpoint_is_accessible(hierarchy->ro_absolute_mount_point))\n\t\treturn hierarchy->ro_absolute_mount_point;\n\n\tfor (mps = hierarchy->all_mount_points; mps && *mps; mps++) {\n\t\tstruct cgroup_mount_point *mp = *mps;\n\t\tsize_t prefix_len = mp->mount_prefix ? strlen(mp->mount_prefix) : 0;\n\n\t\tif (prefix_len == 1 && mp->mount_prefix[0] == '/')\n\t\t\tprefix_len = 0;\n\n\t\tif (!mountpoint_is_accessible(mp))\n\t\t\tcontinue;\n\n\t\tif (should_be_writable && mp->read_only)\n\t\t\tcontinue;\n\n\t\tif (!prefix_len ||\n\t\t    (strncmp(group, mp->mount_prefix, prefix_len) == 0 &&\n\t\t     (group[prefix_len] == '\\0' || group[prefix_len] == '/'))) {\n\t\t\t/* search for the best quality match, i.e. the match with the\n\t\t\t * shortest prefix where this group is still contained\n\t\t\t */\n\t\t\tif (quality == -1 || prefix_len < quality) {\n\t\t\t\tcurrent_result = mp;\n\t\t\t\tquality = prefix_len;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!current_result)\n\t\terrno = ENOENT;\n\treturn current_result;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "group",
            "mp->mount_prefix",
            "prefix_len"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mountpoint_is_accessible",
          "args": [
            "mp"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "mountpoint_is_accessible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "665-668",
          "snippet": "static bool mountpoint_is_accessible(struct cgroup_mount_point *mp)\n{\n\treturn mp && access(mp->mount_point, F_OK) == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\n\nstatic bool mountpoint_is_accessible(struct cgroup_mount_point *mp)\n{\n\treturn mp && access(mp->mount_point, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "mp->mount_prefix"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\n\nstatic struct cgroup_mount_point *lxc_cgroup_find_mount_point(struct cgroup_hierarchy *hierarchy, const char *group, bool should_be_writable)\n{\n\tstruct cgroup_mount_point **mps;\n\tstruct cgroup_mount_point *current_result = NULL;\n\tssize_t quality = -1;\n\n\t/* trivial case */\n\tif (mountpoint_is_accessible(hierarchy->rw_absolute_mount_point))\n\t\treturn hierarchy->rw_absolute_mount_point;\n\tif (!should_be_writable && mountpoint_is_accessible(hierarchy->ro_absolute_mount_point))\n\t\treturn hierarchy->ro_absolute_mount_point;\n\n\tfor (mps = hierarchy->all_mount_points; mps && *mps; mps++) {\n\t\tstruct cgroup_mount_point *mp = *mps;\n\t\tsize_t prefix_len = mp->mount_prefix ? strlen(mp->mount_prefix) : 0;\n\n\t\tif (prefix_len == 1 && mp->mount_prefix[0] == '/')\n\t\t\tprefix_len = 0;\n\n\t\tif (!mountpoint_is_accessible(mp))\n\t\t\tcontinue;\n\n\t\tif (should_be_writable && mp->read_only)\n\t\t\tcontinue;\n\n\t\tif (!prefix_len ||\n\t\t    (strncmp(group, mp->mount_prefix, prefix_len) == 0 &&\n\t\t     (group[prefix_len] == '\\0' || group[prefix_len] == '/'))) {\n\t\t\t/* search for the best quality match, i.e. the match with the\n\t\t\t * shortest prefix where this group is still contained\n\t\t\t */\n\t\t\tif (quality == -1 || prefix_len < quality) {\n\t\t\t\tcurrent_result = mp;\n\t\t\t\tquality = prefix_len;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!current_result)\n\t\terrno = ENOENT;\n\treturn current_result;\n}"
  },
  {
    "function_name": "mountpoint_is_accessible",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "665-668",
    "snippet": "static bool mountpoint_is_accessible(struct cgroup_mount_point *mp)\n{\n\treturn mp && access(mp->mount_point, F_OK) == 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "access",
          "args": [
            "mp->mount_point",
            "F_OK"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_mount_point_free(struct cgroup_mount_point *mp);\n\nstatic bool mountpoint_is_accessible(struct cgroup_mount_point *mp)\n{\n\treturn mp && access(mp->mount_point, F_OK) == 0;\n}"
  },
  {
    "function_name": "lxc_cgroup_find_hierarchy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "652-663",
    "snippet": "static struct cgroup_hierarchy *lxc_cgroup_find_hierarchy(struct cgroup_meta_data *meta_data, const char *subsystem)\n{\n\tsize_t i;\n\tfor (i = 0; i <= meta_data->maximum_hierarchy; i++) {\n\t\tstruct cgroup_hierarchy *h = meta_data->hierarchies[i];\n\t\tif (!h)\n\t\t\tcontinue;\n\t\tif (h && lxc_string_in_array(subsystem, (const char **)h->subsystems))\n\t\t\treturn h;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);",
      "static struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);",
      "static struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);",
      "static struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_string_in_array",
          "args": [
            "subsystem",
            "(const char **)h->subsystems"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_in_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "656-662",
          "snippet": "bool lxc_string_in_array(const char *needle, const char **haystack)\n{\n\tfor (; haystack && *haystack; haystack++)\n\t\tif (!strcmp(needle, *haystack))\n\t\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool lxc_string_in_array(const char *needle, const char **haystack)\n{\n\tfor (; haystack && *haystack; haystack++)\n\t\tif (!strcmp(needle, *haystack))\n\t\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);\nstatic struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);\nstatic struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);\nstatic struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);\n\nstatic struct cgroup_hierarchy *lxc_cgroup_find_hierarchy(struct cgroup_meta_data *meta_data, const char *subsystem)\n{\n\tsize_t i;\n\tfor (i = 0; i <= meta_data->maximum_hierarchy; i++) {\n\t\tstruct cgroup_hierarchy *h = meta_data->hierarchies[i];\n\t\tif (!h)\n\t\t\tcontinue;\n\t\tif (h && lxc_string_in_array(subsystem, (const char **)h->subsystems))\n\t\t\treturn h;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "lxc_cgroup_put_meta",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "635-650",
    "snippet": "static struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data)\n{\n\tsize_t i;\n\tif (!meta_data)\n\t\treturn NULL;\n\tif (--meta_data->ref > 0)\n\t\treturn meta_data;\n\tlxc_free_array((void **)meta_data->mount_points, (lxc_free_fn)lxc_cgroup_mount_point_free);\n\tif (meta_data->hierarchies)\n\t\tfor (i = 0; i <= meta_data->maximum_hierarchy; i++)\n\t\t\tif (meta_data->hierarchies[i])\n\t\t\t\tlxc_cgroup_hierarchy_free(meta_data->hierarchies[i]);\n\tfree(meta_data->hierarchies);\n\tfree(meta_data);\n\treturn NULL;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);",
      "static struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "meta_data"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "cgfs_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2501-2518",
          "snippet": "static bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_hierarchy_free",
          "args": [
            "meta_data->hierarchies[i]"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_hierarchy_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1832-1846",
          "snippet": "static void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h)\n{\n\tif (!h)\n\t\treturn;\n\tif (h->subsystems) {\n\t\tlxc_free_array((void **)h->subsystems, free);\n\t\th->subsystems = NULL;\n\t}\n\tif (h->all_mount_points) {\n\t\tfree(h->all_mount_points);\n\t\th->all_mount_points = NULL;\n\t}\n\tfree(h);\n\th = NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);\n\nstatic void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h)\n{\n\tif (!h)\n\t\treturn;\n\tif (h->subsystems) {\n\t\tlxc_free_array((void **)h->subsystems, free);\n\t\th->subsystems = NULL;\n\t}\n\tif (h->all_mount_points) {\n\t\tfree(h->all_mount_points);\n\t\th->all_mount_points = NULL;\n\t}\n\tfree(h);\n\th = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_free_array",
          "args": [
            "(void **)meta_data->mount_points",
            "(lxc_free_fn)lxc_cgroup_mount_point_free"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_free_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "886-892",
          "snippet": "void lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);\nstatic struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);\n\nstatic struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data)\n{\n\tsize_t i;\n\tif (!meta_data)\n\t\treturn NULL;\n\tif (--meta_data->ref > 0)\n\t\treturn meta_data;\n\tlxc_free_array((void **)meta_data->mount_points, (lxc_free_fn)lxc_cgroup_mount_point_free);\n\tif (meta_data->hierarchies)\n\t\tfor (i = 0; i <= meta_data->maximum_hierarchy; i++)\n\t\t\tif (meta_data->hierarchies[i])\n\t\t\t\tlxc_cgroup_hierarchy_free(meta_data->hierarchies[i]);\n\tfree(meta_data->hierarchies);\n\tfree(meta_data);\n\treturn NULL;\n}"
  },
  {
    "function_name": "lxc_cgroup_get_meta",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "629-633",
    "snippet": "static struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data)\n{\n\tmeta_data->ref++;\n\treturn meta_data;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);",
      "static struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);\nstatic struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);\n\nstatic struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data)\n{\n\tmeta_data->ref++;\n\treturn meta_data;\n}"
  },
  {
    "function_name": "lxc_cgroup_load_meta2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "573-627",
    "snippet": "static struct cgroup_meta_data *lxc_cgroup_load_meta2(const char **subsystem_whitelist)\n{\n\tbool all_kernel_subsystems = true;\n\tbool all_named_subsystems = false;\n\tstruct cgroup_meta_data *meta_data = NULL;\n\tchar **kernel_subsystems = NULL;\n\tint saved_errno = 0;\n\n\t/* if the subsystem whitelist is not specified, include all\n\t * hierarchies that contain kernel subsystems by default but\n\t * no hierarchies that only contain named subsystems\n\t *\n\t * if it is specified, the specifier @all will select all\n\t * hierarchies, @kernel will select all hierarchies with\n\t * kernel subsystems and @named will select all named\n\t * hierarchies\n\t */\n\tall_kernel_subsystems = subsystem_whitelist ?\n\t\t(lxc_string_in_array(\"@kernel\", subsystem_whitelist) || lxc_string_in_array(\"@all\", subsystem_whitelist)) :\n\t\ttrue;\n\tall_named_subsystems = subsystem_whitelist ?\n\t\t(lxc_string_in_array(\"@named\", subsystem_whitelist) || lxc_string_in_array(\"@all\", subsystem_whitelist)) :\n\t\ttrue;\n\n\tmeta_data = calloc(1, sizeof(struct cgroup_meta_data));\n\tif (!meta_data)\n\t\treturn NULL;\n\tmeta_data->ref = 1;\n\n\tif (!find_cgroup_subsystems(&kernel_subsystems))\n\t\tgoto out_error;\n\n\tif (!find_cgroup_hierarchies(meta_data, all_kernel_subsystems,\n\t\t\t\tall_named_subsystems, subsystem_whitelist))\n\t\tgoto out_error;\n\n\tif (!find_hierarchy_mountpts(meta_data, kernel_subsystems))\n\t\tgoto out_error;\n\n\t/* oops, we couldn't find anything */\n\tif (!meta_data->hierarchies || !meta_data->mount_points) {\n\t\terrno = EINVAL;\n\t\tgoto out_error;\n\t}\n\n\tlxc_free_array((void **)kernel_subsystems, free);\n\treturn meta_data;\n\nout_error:\n\tsaved_errno = errno;\n\tlxc_free_array((void **)kernel_subsystems, free);\n\tlxc_cgroup_put_meta(meta_data);\n\terrno = saved_errno;\n\treturn NULL;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);",
      "static struct cgroup_meta_data *lxc_cgroup_load_meta2(const char **subsystem_whitelist);",
      "static struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);",
      "static struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_cgroup_put_meta",
          "args": [
            "meta_data"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_put_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "635-650",
          "snippet": "static struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data)\n{\n\tsize_t i;\n\tif (!meta_data)\n\t\treturn NULL;\n\tif (--meta_data->ref > 0)\n\t\treturn meta_data;\n\tlxc_free_array((void **)meta_data->mount_points, (lxc_free_fn)lxc_cgroup_mount_point_free);\n\tif (meta_data->hierarchies)\n\t\tfor (i = 0; i <= meta_data->maximum_hierarchy; i++)\n\t\t\tif (meta_data->hierarchies[i])\n\t\t\t\tlxc_cgroup_hierarchy_free(meta_data->hierarchies[i]);\n\tfree(meta_data->hierarchies);\n\tfree(meta_data);\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);",
            "static struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);\nstatic struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);\n\nstatic struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data)\n{\n\tsize_t i;\n\tif (!meta_data)\n\t\treturn NULL;\n\tif (--meta_data->ref > 0)\n\t\treturn meta_data;\n\tlxc_free_array((void **)meta_data->mount_points, (lxc_free_fn)lxc_cgroup_mount_point_free);\n\tif (meta_data->hierarchies)\n\t\tfor (i = 0; i <= meta_data->maximum_hierarchy; i++)\n\t\t\tif (meta_data->hierarchies[i])\n\t\t\t\tlxc_cgroup_hierarchy_free(meta_data->hierarchies[i]);\n\tfree(meta_data->hierarchies);\n\tfree(meta_data);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_free_array",
          "args": [
            "(void **)kernel_subsystems",
            "free"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_free_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "886-892",
          "snippet": "void lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_hierarchy_mountpts",
          "args": [
            "meta_data",
            "kernel_subsystems"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "find_hierarchy_mountpts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "433-571",
          "snippet": "static bool find_hierarchy_mountpts( struct cgroup_meta_data *meta_data, char **kernel_subsystems)\n{\n\tbool bret = false;\n\tFILE *proc_self_mountinfo;\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tchar **tokens = NULL;\n\tsize_t mount_point_count = 0;\n\tsize_t mount_point_capacity = 0;\n\tsize_t token_capacity = 0;\n\tint r;\n\tbool is_cgns = cgns_supported();\n\n\tproc_self_mountinfo = fopen_cloexec(\"/proc/self/mountinfo\", \"r\");\n\t/* if for some reason (because of setns() and pid namespace for example),\n\t * /proc/self is not valid, we try /proc/1/cgroup... */\n\tif (!proc_self_mountinfo)\n\t\tproc_self_mountinfo = fopen_cloexec(\"/proc/1/mountinfo\", \"r\");\n\tif (!proc_self_mountinfo)\n\t\treturn false;\n\n\twhile (getline(&line, &sz, proc_self_mountinfo) != -1) {\n\t\tchar *token, *line_tok, *saveptr = NULL;\n\t\tsize_t i, j, k;\n\t\tstruct cgroup_mount_point *mount_point;\n\t\tstruct cgroup_hierarchy *h;\n\t\tchar **subsystems;\n\t\tbool is_lxcfs = false;\n\n\t\tif (line[0] && line[strlen(line) - 1] == '\\n')\n\t\t\tline[strlen(line) - 1] = '\\0';\n\n\t\tfor (i = 0, line_tok = line; (token = strtok_r(line_tok, \" \", &saveptr)); line_tok = NULL) {\n\t\t\tr = lxc_grow_array((void ***)&tokens, &token_capacity, i + 1, 64);\n\t\t\tif (r < 0)\n\t\t\t\tgoto out;\n\t\t\ttokens[i++] = token;\n\t\t}\n\n\t\t/* layout of /proc/self/mountinfo:\n\t\t *      0: id\n\t\t *      1: parent id\n\t\t *      2: device major:minor\n\t\t *      3: mount prefix\n\t\t *      4: mount point\n\t\t *      5: per-mount options\n\t\t *    [optional X]: additional data\n\t\t *    X+7: \"-\"\n\t\t *    X+8: type\n\t\t *    X+9: source\n\t\t *    X+10: per-superblock options\n\t\t */\n\t\tfor (j = 6; j < i && tokens[j]; j++)\n\t\t\tif (!strcmp(tokens[j], \"-\"))\n\t\t\t\tbreak;\n\n\t\t/* could not find separator */\n\t\tif (j >= i || !tokens[j])\n\t\t\tcontinue;\n\t\t/* there should be exactly three fields after\n\t\t * the separator\n\t\t */\n\t\tif (i != j + 4)\n\t\t\tcontinue;\n\n\t\t/* not a cgroup filesystem */\n\t\tif (strcmp(tokens[j + 1], \"cgroup\") != 0) {\n\t\t\tif (strcmp(tokens[j + 1], \"fuse.lxcfs\") != 0)\n\t\t\t\tcontinue;\n\t\t\tif (strncmp(tokens[4], \"/sys/fs/cgroup/\", 15) != 0)\n\t\t\t\tcontinue;\n\t\t\tis_lxcfs = true;\n\t\t\tchar *curtok = tokens[4] + 15;\n\t\t\tsubsystems = subsystems_from_mount_options(curtok,\n\t\t\t\t\t\t\t kernel_subsystems);\n\t\t} else\n\t\t\tsubsystems = subsystems_from_mount_options(tokens[j + 3],\n\t\t\t\t\t\t\t kernel_subsystems);\n\t\tif (!subsystems)\n\t\t\tgoto out;\n\n\t\th = NULL;\n\t\tfor (k = 0; k <= meta_data->maximum_hierarchy; k++) {\n\t\t\tif (meta_data->hierarchies[k] &&\n\t\t\t    meta_data->hierarchies[k]->subsystems[0] &&\n\t\t\t    lxc_string_in_array(meta_data->hierarchies[k]->subsystems[0], (const char **)subsystems)) {\n\t\t\t\t/* TODO: we could also check if the lists really match completely,\n\t\t\t\t *       just to have an additional sanity check */\n\t\t\t\th = meta_data->hierarchies[k];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlxc_free_array((void **)subsystems, free);\n\n\t\tr = lxc_grow_array((void ***)&meta_data->mount_points, &mount_point_capacity, mount_point_count + 1, 12);\n\t\tif (r < 0)\n\t\t\tgoto out;\n\n\t\t/* create mount point object */\n\t\tmount_point = calloc(1, sizeof(*mount_point));\n\t\tif (!mount_point)\n\t\t\tgoto out;\n\n\t\tmeta_data->mount_points[mount_point_count++] = mount_point;\n\n\t\tmount_point->hierarchy = h;\n\t\tif (is_lxcfs || is_cgns)\n\t\t\tmount_point->mount_prefix = strdup(\"/\");\n\t\telse\n\t\t\tmount_point->mount_prefix = strdup(tokens[3]);\n\t\tmount_point->mount_point = strdup(tokens[4]);\n\t\tif (!mount_point->mount_point || !mount_point->mount_prefix)\n\t\t\tgoto out;\n\t\tmount_point->read_only = !lxc_string_in_list(\"rw\", tokens[5], ',');\n\n\t\tif (!strcmp(mount_point->mount_prefix, \"/\")) {\n\t\t\tif (mount_point->read_only) {\n\t\t\t\tif (!h->ro_absolute_mount_point)\n\t\t\t\t\th->ro_absolute_mount_point = mount_point;\n\t\t\t} else {\n\t\t\t\tif (!h->rw_absolute_mount_point)\n\t\t\t\t\th->rw_absolute_mount_point = mount_point;\n\t\t\t}\n\t\t}\n\n\t\tk = lxc_array_len((void **)h->all_mount_points);\n\t\tr = lxc_grow_array((void ***)&h->all_mount_points, &h->all_mount_point_capacity, k + 1, 4);\n\t\tif (r < 0)\n\t\t\tgoto out;\n\t\th->all_mount_points[k] = mount_point;\n\t}\n\tbret = true;\n\nout:\n\tfclose(proc_self_mountinfo);\n\tfree(tokens);\n\tfree(line);\n\treturn bret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);",
            "static struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);",
            "static struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);\nstatic struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);\nstatic struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);\n\nstatic bool find_hierarchy_mountpts( struct cgroup_meta_data *meta_data, char **kernel_subsystems)\n{\n\tbool bret = false;\n\tFILE *proc_self_mountinfo;\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tchar **tokens = NULL;\n\tsize_t mount_point_count = 0;\n\tsize_t mount_point_capacity = 0;\n\tsize_t token_capacity = 0;\n\tint r;\n\tbool is_cgns = cgns_supported();\n\n\tproc_self_mountinfo = fopen_cloexec(\"/proc/self/mountinfo\", \"r\");\n\t/* if for some reason (because of setns() and pid namespace for example),\n\t * /proc/self is not valid, we try /proc/1/cgroup... */\n\tif (!proc_self_mountinfo)\n\t\tproc_self_mountinfo = fopen_cloexec(\"/proc/1/mountinfo\", \"r\");\n\tif (!proc_self_mountinfo)\n\t\treturn false;\n\n\twhile (getline(&line, &sz, proc_self_mountinfo) != -1) {\n\t\tchar *token, *line_tok, *saveptr = NULL;\n\t\tsize_t i, j, k;\n\t\tstruct cgroup_mount_point *mount_point;\n\t\tstruct cgroup_hierarchy *h;\n\t\tchar **subsystems;\n\t\tbool is_lxcfs = false;\n\n\t\tif (line[0] && line[strlen(line) - 1] == '\\n')\n\t\t\tline[strlen(line) - 1] = '\\0';\n\n\t\tfor (i = 0, line_tok = line; (token = strtok_r(line_tok, \" \", &saveptr)); line_tok = NULL) {\n\t\t\tr = lxc_grow_array((void ***)&tokens, &token_capacity, i + 1, 64);\n\t\t\tif (r < 0)\n\t\t\t\tgoto out;\n\t\t\ttokens[i++] = token;\n\t\t}\n\n\t\t/* layout of /proc/self/mountinfo:\n\t\t *      0: id\n\t\t *      1: parent id\n\t\t *      2: device major:minor\n\t\t *      3: mount prefix\n\t\t *      4: mount point\n\t\t *      5: per-mount options\n\t\t *    [optional X]: additional data\n\t\t *    X+7: \"-\"\n\t\t *    X+8: type\n\t\t *    X+9: source\n\t\t *    X+10: per-superblock options\n\t\t */\n\t\tfor (j = 6; j < i && tokens[j]; j++)\n\t\t\tif (!strcmp(tokens[j], \"-\"))\n\t\t\t\tbreak;\n\n\t\t/* could not find separator */\n\t\tif (j >= i || !tokens[j])\n\t\t\tcontinue;\n\t\t/* there should be exactly three fields after\n\t\t * the separator\n\t\t */\n\t\tif (i != j + 4)\n\t\t\tcontinue;\n\n\t\t/* not a cgroup filesystem */\n\t\tif (strcmp(tokens[j + 1], \"cgroup\") != 0) {\n\t\t\tif (strcmp(tokens[j + 1], \"fuse.lxcfs\") != 0)\n\t\t\t\tcontinue;\n\t\t\tif (strncmp(tokens[4], \"/sys/fs/cgroup/\", 15) != 0)\n\t\t\t\tcontinue;\n\t\t\tis_lxcfs = true;\n\t\t\tchar *curtok = tokens[4] + 15;\n\t\t\tsubsystems = subsystems_from_mount_options(curtok,\n\t\t\t\t\t\t\t kernel_subsystems);\n\t\t} else\n\t\t\tsubsystems = subsystems_from_mount_options(tokens[j + 3],\n\t\t\t\t\t\t\t kernel_subsystems);\n\t\tif (!subsystems)\n\t\t\tgoto out;\n\n\t\th = NULL;\n\t\tfor (k = 0; k <= meta_data->maximum_hierarchy; k++) {\n\t\t\tif (meta_data->hierarchies[k] &&\n\t\t\t    meta_data->hierarchies[k]->subsystems[0] &&\n\t\t\t    lxc_string_in_array(meta_data->hierarchies[k]->subsystems[0], (const char **)subsystems)) {\n\t\t\t\t/* TODO: we could also check if the lists really match completely,\n\t\t\t\t *       just to have an additional sanity check */\n\t\t\t\th = meta_data->hierarchies[k];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlxc_free_array((void **)subsystems, free);\n\n\t\tr = lxc_grow_array((void ***)&meta_data->mount_points, &mount_point_capacity, mount_point_count + 1, 12);\n\t\tif (r < 0)\n\t\t\tgoto out;\n\n\t\t/* create mount point object */\n\t\tmount_point = calloc(1, sizeof(*mount_point));\n\t\tif (!mount_point)\n\t\t\tgoto out;\n\n\t\tmeta_data->mount_points[mount_point_count++] = mount_point;\n\n\t\tmount_point->hierarchy = h;\n\t\tif (is_lxcfs || is_cgns)\n\t\t\tmount_point->mount_prefix = strdup(\"/\");\n\t\telse\n\t\t\tmount_point->mount_prefix = strdup(tokens[3]);\n\t\tmount_point->mount_point = strdup(tokens[4]);\n\t\tif (!mount_point->mount_point || !mount_point->mount_prefix)\n\t\t\tgoto out;\n\t\tmount_point->read_only = !lxc_string_in_list(\"rw\", tokens[5], ',');\n\n\t\tif (!strcmp(mount_point->mount_prefix, \"/\")) {\n\t\t\tif (mount_point->read_only) {\n\t\t\t\tif (!h->ro_absolute_mount_point)\n\t\t\t\t\th->ro_absolute_mount_point = mount_point;\n\t\t\t} else {\n\t\t\t\tif (!h->rw_absolute_mount_point)\n\t\t\t\t\th->rw_absolute_mount_point = mount_point;\n\t\t\t}\n\t\t}\n\n\t\tk = lxc_array_len((void **)h->all_mount_points);\n\t\tr = lxc_grow_array((void ***)&h->all_mount_points, &h->all_mount_point_capacity, k + 1, 4);\n\t\tif (r < 0)\n\t\t\tgoto out;\n\t\th->all_mount_points[k] = mount_point;\n\t}\n\tbret = true;\n\nout:\n\tfclose(proc_self_mountinfo);\n\tfree(tokens);\n\tfree(line);\n\treturn bret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_cgroup_hierarchies",
          "args": [
            "meta_data",
            "all_kernel_subsystems",
            "all_named_subsystems",
            "subsystem_whitelist"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "find_cgroup_hierarchies",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "325-430",
          "snippet": "static bool find_cgroup_hierarchies(struct cgroup_meta_data *meta_data,\n\tbool all_kernel_subsystems, bool all_named_subsystems,\n\tconst char **subsystem_whitelist)\n{\n\tFILE *proc_self_cgroup;\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tint r;\n\tbool bret = false;\n\tsize_t hierarchy_capacity = 0;\n\n\tproc_self_cgroup = fopen_cloexec(\"/proc/self/cgroup\", \"r\");\n\t/* if for some reason (because of setns() and pid namespace for example),\n\t * /proc/self is not valid, we try /proc/1/cgroup... */\n\tif (!proc_self_cgroup)\n\t\tproc_self_cgroup = fopen_cloexec(\"/proc/1/cgroup\", \"r\");\n\tif (!proc_self_cgroup)\n\t\treturn false;\n\n\twhile (getline(&line, &sz, proc_self_cgroup) != -1) {\n\t\t/* file format: hierarchy:subsystems:group,\n\t\t * we only extract hierarchy and subsystems\n\t\t * here */\n\t\tchar *colon1;\n\t\tchar *colon2;\n\t\tint hierarchy_number;\n\t\tstruct cgroup_hierarchy *h = NULL;\n\t\tchar **p;\n\n\t\tif (!line[0])\n\t\t\tcontinue;\n\n\t\tcolon1 = strchr(line, ':');\n\t\tif (!colon1)\n\t\t\tcontinue;\n\t\t*colon1++ = '\\0';\n\t\tcolon2 = strchr(colon1, ':');\n\t\tif (!colon2)\n\t\t\tcontinue;\n\t\t*colon2 = '\\0';\n\n\t\tcolon2 = NULL;\n\n\t\t/* With cgroupv2 /proc/self/cgroup can contain entries of the\n\t\t * form: 0::/\n\t\t * These entries need to be skipped.\n\t\t */\n\t\tif (!strcmp(colon1, \"\"))\n\t\t\tcontinue;\n\n\t\thierarchy_number = strtoul(line, &colon2, 10);\n\t\tif (!colon2 || *colon2)\n\t\t\tcontinue;\n\n\t\tif (hierarchy_number > meta_data->maximum_hierarchy) {\n\t\t\t/* lxc_grow_array will never shrink, so even if we find a lower\n\t\t\t* hierarchy number here, the array will never be smaller\n\t\t\t*/\n\t\t\tr = lxc_grow_array((void ***)&meta_data->hierarchies, &hierarchy_capacity, hierarchy_number + 1, 12);\n\t\t\tif (r < 0)\n\t\t\t\tgoto out;\n\n\t\t\tmeta_data->maximum_hierarchy = hierarchy_number;\n\t\t}\n\n\t\t/* this shouldn't happen, we had this already */\n\t\tif (meta_data->hierarchies[hierarchy_number])\n\t\t\tgoto out;\n\n\t\th = calloc(1, sizeof(struct cgroup_hierarchy));\n\t\tif (!h)\n\t\t\tgoto out;\n\n\t\tmeta_data->hierarchies[hierarchy_number] = h;\n\n\t\th->index = hierarchy_number;\n\t\th->subsystems = lxc_string_split_and_trim(colon1, ',');\n\t\tif (!h->subsystems)\n\t\t\tgoto out;\n\t\t/* see if this hierarchy should be considered */\n\t\tif (!all_kernel_subsystems || !all_named_subsystems) {\n\t\t\tfor (p = h->subsystems; *p; p++) {\n\t\t\t\tif (!strncmp(*p, \"name=\", 5)) {\n\t\t\t\t\tif (all_named_subsystems || (subsystem_whitelist && lxc_string_in_array(*p, subsystem_whitelist))) {\n\t\t\t\t\t\th->used = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (all_kernel_subsystems || (subsystem_whitelist && lxc_string_in_array(*p, subsystem_whitelist))) {\n\t\t\t\t\t\th->used = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/* we want all hierarchy anyway */\n\t\t\th->used = true;\n\t\t}\n\t}\n\tbret = true;\n\nout:\n\tfclose(proc_self_cgroup);\n\tfree(line);\n\treturn bret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);",
            "static bool is_valid_cgroup(const char *name);",
            "static struct cgroup_meta_data *lxc_cgroup_load_meta2(const char **subsystem_whitelist);",
            "static struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);",
            "static struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);\nstatic bool is_valid_cgroup(const char *name);\nstatic struct cgroup_meta_data *lxc_cgroup_load_meta2(const char **subsystem_whitelist);\nstatic struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);\nstatic struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);\n\nstatic bool find_cgroup_hierarchies(struct cgroup_meta_data *meta_data,\n\tbool all_kernel_subsystems, bool all_named_subsystems,\n\tconst char **subsystem_whitelist)\n{\n\tFILE *proc_self_cgroup;\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tint r;\n\tbool bret = false;\n\tsize_t hierarchy_capacity = 0;\n\n\tproc_self_cgroup = fopen_cloexec(\"/proc/self/cgroup\", \"r\");\n\t/* if for some reason (because of setns() and pid namespace for example),\n\t * /proc/self is not valid, we try /proc/1/cgroup... */\n\tif (!proc_self_cgroup)\n\t\tproc_self_cgroup = fopen_cloexec(\"/proc/1/cgroup\", \"r\");\n\tif (!proc_self_cgroup)\n\t\treturn false;\n\n\twhile (getline(&line, &sz, proc_self_cgroup) != -1) {\n\t\t/* file format: hierarchy:subsystems:group,\n\t\t * we only extract hierarchy and subsystems\n\t\t * here */\n\t\tchar *colon1;\n\t\tchar *colon2;\n\t\tint hierarchy_number;\n\t\tstruct cgroup_hierarchy *h = NULL;\n\t\tchar **p;\n\n\t\tif (!line[0])\n\t\t\tcontinue;\n\n\t\tcolon1 = strchr(line, ':');\n\t\tif (!colon1)\n\t\t\tcontinue;\n\t\t*colon1++ = '\\0';\n\t\tcolon2 = strchr(colon1, ':');\n\t\tif (!colon2)\n\t\t\tcontinue;\n\t\t*colon2 = '\\0';\n\n\t\tcolon2 = NULL;\n\n\t\t/* With cgroupv2 /proc/self/cgroup can contain entries of the\n\t\t * form: 0::/\n\t\t * These entries need to be skipped.\n\t\t */\n\t\tif (!strcmp(colon1, \"\"))\n\t\t\tcontinue;\n\n\t\thierarchy_number = strtoul(line, &colon2, 10);\n\t\tif (!colon2 || *colon2)\n\t\t\tcontinue;\n\n\t\tif (hierarchy_number > meta_data->maximum_hierarchy) {\n\t\t\t/* lxc_grow_array will never shrink, so even if we find a lower\n\t\t\t* hierarchy number here, the array will never be smaller\n\t\t\t*/\n\t\t\tr = lxc_grow_array((void ***)&meta_data->hierarchies, &hierarchy_capacity, hierarchy_number + 1, 12);\n\t\t\tif (r < 0)\n\t\t\t\tgoto out;\n\n\t\t\tmeta_data->maximum_hierarchy = hierarchy_number;\n\t\t}\n\n\t\t/* this shouldn't happen, we had this already */\n\t\tif (meta_data->hierarchies[hierarchy_number])\n\t\t\tgoto out;\n\n\t\th = calloc(1, sizeof(struct cgroup_hierarchy));\n\t\tif (!h)\n\t\t\tgoto out;\n\n\t\tmeta_data->hierarchies[hierarchy_number] = h;\n\n\t\th->index = hierarchy_number;\n\t\th->subsystems = lxc_string_split_and_trim(colon1, ',');\n\t\tif (!h->subsystems)\n\t\t\tgoto out;\n\t\t/* see if this hierarchy should be considered */\n\t\tif (!all_kernel_subsystems || !all_named_subsystems) {\n\t\t\tfor (p = h->subsystems; *p; p++) {\n\t\t\t\tif (!strncmp(*p, \"name=\", 5)) {\n\t\t\t\t\tif (all_named_subsystems || (subsystem_whitelist && lxc_string_in_array(*p, subsystem_whitelist))) {\n\t\t\t\t\t\th->used = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (all_kernel_subsystems || (subsystem_whitelist && lxc_string_in_array(*p, subsystem_whitelist))) {\n\t\t\t\t\t\th->used = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/* we want all hierarchy anyway */\n\t\t\th->used = true;\n\t\t}\n\t}\n\tbret = true;\n\nout:\n\tfclose(proc_self_cgroup);\n\tfree(line);\n\treturn bret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_cgroup_subsystems",
          "args": [
            "&kernel_subsystems"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "find_cgroup_subsystems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "266-319",
          "snippet": "static bool find_cgroup_subsystems(char ***kernel_subsystems)\n{\n\tFILE *proc_cgroups;\n\tbool bret = false;\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tsize_t kernel_subsystems_count = 0;\n\tsize_t kernel_subsystems_capacity = 0;\n\tint r;\n\n\tproc_cgroups = fopen_cloexec(\"/proc/cgroups\", \"r\");\n\tif (!proc_cgroups)\n\t\treturn false;\n\n\twhile (getline(&line, &sz, proc_cgroups) != -1) {\n\t\tchar *tab1;\n\t\tchar *tab2;\n\t\tint hierarchy_number;\n\n\t\tif (line[0] == '#')\n\t\t\tcontinue;\n\t\tif (!line[0])\n\t\t\tcontinue;\n\n\t\ttab1 = strchr(line, '\\t');\n\t\tif (!tab1)\n\t\t\tcontinue;\n\t\t*tab1++ = '\\0';\n\t\ttab2 = strchr(tab1, '\\t');\n\t\tif (!tab2)\n\t\t\tcontinue;\n\t\t*tab2 = '\\0';\n\n\t\ttab2 = NULL;\n\t\thierarchy_number = strtoul(tab1, &tab2, 10);\n\t\tif (!tab2 || *tab2)\n\t\t\tcontinue;\n\t\t(void)hierarchy_number;\n\n\t\tr = lxc_grow_array((void ***)kernel_subsystems, &kernel_subsystems_capacity, kernel_subsystems_count + 1, 12);\n\t\tif (r < 0)\n\t\t\tgoto out;\n\t\t(*kernel_subsystems)[kernel_subsystems_count] = strdup(line);\n\t\tif (!(*kernel_subsystems)[kernel_subsystems_count])\n\t\t\tgoto out;\n\t\tkernel_subsystems_count++;\n\t}\n\tbret = true;\n\nout:\n\tfclose(proc_cgroups);\n\tfree(line);\n\treturn bret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool find_cgroup_subsystems(char ***kernel_subsystems)\n{\n\tFILE *proc_cgroups;\n\tbool bret = false;\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tsize_t kernel_subsystems_count = 0;\n\tsize_t kernel_subsystems_capacity = 0;\n\tint r;\n\n\tproc_cgroups = fopen_cloexec(\"/proc/cgroups\", \"r\");\n\tif (!proc_cgroups)\n\t\treturn false;\n\n\twhile (getline(&line, &sz, proc_cgroups) != -1) {\n\t\tchar *tab1;\n\t\tchar *tab2;\n\t\tint hierarchy_number;\n\n\t\tif (line[0] == '#')\n\t\t\tcontinue;\n\t\tif (!line[0])\n\t\t\tcontinue;\n\n\t\ttab1 = strchr(line, '\\t');\n\t\tif (!tab1)\n\t\t\tcontinue;\n\t\t*tab1++ = '\\0';\n\t\ttab2 = strchr(tab1, '\\t');\n\t\tif (!tab2)\n\t\t\tcontinue;\n\t\t*tab2 = '\\0';\n\n\t\ttab2 = NULL;\n\t\thierarchy_number = strtoul(tab1, &tab2, 10);\n\t\tif (!tab2 || *tab2)\n\t\t\tcontinue;\n\t\t(void)hierarchy_number;\n\n\t\tr = lxc_grow_array((void ***)kernel_subsystems, &kernel_subsystems_capacity, kernel_subsystems_count + 1, 12);\n\t\tif (r < 0)\n\t\t\tgoto out;\n\t\t(*kernel_subsystems)[kernel_subsystems_count] = strdup(line);\n\t\tif (!(*kernel_subsystems)[kernel_subsystems_count])\n\t\t\tgoto out;\n\t\tkernel_subsystems_count++;\n\t}\n\tbret = true;\n\nout:\n\tfclose(proc_cgroups);\n\tfree(line);\n\treturn bret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "sizeof(struct cgroup_meta_data)"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_string_in_array",
          "args": [
            "\"@all\"",
            "subsystem_whitelist"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_in_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "656-662",
          "snippet": "bool lxc_string_in_array(const char *needle, const char **haystack)\n{\n\tfor (; haystack && *haystack; haystack++)\n\t\tif (!strcmp(needle, *haystack))\n\t\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool lxc_string_in_array(const char *needle, const char **haystack)\n{\n\tfor (; haystack && *haystack; haystack++)\n\t\tif (!strcmp(needle, *haystack))\n\t\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);\nstatic struct cgroup_meta_data *lxc_cgroup_load_meta2(const char **subsystem_whitelist);\nstatic struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);\nstatic struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);\n\nstatic struct cgroup_meta_data *lxc_cgroup_load_meta2(const char **subsystem_whitelist)\n{\n\tbool all_kernel_subsystems = true;\n\tbool all_named_subsystems = false;\n\tstruct cgroup_meta_data *meta_data = NULL;\n\tchar **kernel_subsystems = NULL;\n\tint saved_errno = 0;\n\n\t/* if the subsystem whitelist is not specified, include all\n\t * hierarchies that contain kernel subsystems by default but\n\t * no hierarchies that only contain named subsystems\n\t *\n\t * if it is specified, the specifier @all will select all\n\t * hierarchies, @kernel will select all hierarchies with\n\t * kernel subsystems and @named will select all named\n\t * hierarchies\n\t */\n\tall_kernel_subsystems = subsystem_whitelist ?\n\t\t(lxc_string_in_array(\"@kernel\", subsystem_whitelist) || lxc_string_in_array(\"@all\", subsystem_whitelist)) :\n\t\ttrue;\n\tall_named_subsystems = subsystem_whitelist ?\n\t\t(lxc_string_in_array(\"@named\", subsystem_whitelist) || lxc_string_in_array(\"@all\", subsystem_whitelist)) :\n\t\ttrue;\n\n\tmeta_data = calloc(1, sizeof(struct cgroup_meta_data));\n\tif (!meta_data)\n\t\treturn NULL;\n\tmeta_data->ref = 1;\n\n\tif (!find_cgroup_subsystems(&kernel_subsystems))\n\t\tgoto out_error;\n\n\tif (!find_cgroup_hierarchies(meta_data, all_kernel_subsystems,\n\t\t\t\tall_named_subsystems, subsystem_whitelist))\n\t\tgoto out_error;\n\n\tif (!find_hierarchy_mountpts(meta_data, kernel_subsystems))\n\t\tgoto out_error;\n\n\t/* oops, we couldn't find anything */\n\tif (!meta_data->hierarchies || !meta_data->mount_points) {\n\t\terrno = EINVAL;\n\t\tgoto out_error;\n\t}\n\n\tlxc_free_array((void **)kernel_subsystems, free);\n\treturn meta_data;\n\nout_error:\n\tsaved_errno = errno;\n\tlxc_free_array((void **)kernel_subsystems, free);\n\tlxc_cgroup_put_meta(meta_data);\n\terrno = saved_errno;\n\treturn NULL;\n}"
  },
  {
    "function_name": "find_hierarchy_mountpts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "433-571",
    "snippet": "static bool find_hierarchy_mountpts( struct cgroup_meta_data *meta_data, char **kernel_subsystems)\n{\n\tbool bret = false;\n\tFILE *proc_self_mountinfo;\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tchar **tokens = NULL;\n\tsize_t mount_point_count = 0;\n\tsize_t mount_point_capacity = 0;\n\tsize_t token_capacity = 0;\n\tint r;\n\tbool is_cgns = cgns_supported();\n\n\tproc_self_mountinfo = fopen_cloexec(\"/proc/self/mountinfo\", \"r\");\n\t/* if for some reason (because of setns() and pid namespace for example),\n\t * /proc/self is not valid, we try /proc/1/cgroup... */\n\tif (!proc_self_mountinfo)\n\t\tproc_self_mountinfo = fopen_cloexec(\"/proc/1/mountinfo\", \"r\");\n\tif (!proc_self_mountinfo)\n\t\treturn false;\n\n\twhile (getline(&line, &sz, proc_self_mountinfo) != -1) {\n\t\tchar *token, *line_tok, *saveptr = NULL;\n\t\tsize_t i, j, k;\n\t\tstruct cgroup_mount_point *mount_point;\n\t\tstruct cgroup_hierarchy *h;\n\t\tchar **subsystems;\n\t\tbool is_lxcfs = false;\n\n\t\tif (line[0] && line[strlen(line) - 1] == '\\n')\n\t\t\tline[strlen(line) - 1] = '\\0';\n\n\t\tfor (i = 0, line_tok = line; (token = strtok_r(line_tok, \" \", &saveptr)); line_tok = NULL) {\n\t\t\tr = lxc_grow_array((void ***)&tokens, &token_capacity, i + 1, 64);\n\t\t\tif (r < 0)\n\t\t\t\tgoto out;\n\t\t\ttokens[i++] = token;\n\t\t}\n\n\t\t/* layout of /proc/self/mountinfo:\n\t\t *      0: id\n\t\t *      1: parent id\n\t\t *      2: device major:minor\n\t\t *      3: mount prefix\n\t\t *      4: mount point\n\t\t *      5: per-mount options\n\t\t *    [optional X]: additional data\n\t\t *    X+7: \"-\"\n\t\t *    X+8: type\n\t\t *    X+9: source\n\t\t *    X+10: per-superblock options\n\t\t */\n\t\tfor (j = 6; j < i && tokens[j]; j++)\n\t\t\tif (!strcmp(tokens[j], \"-\"))\n\t\t\t\tbreak;\n\n\t\t/* could not find separator */\n\t\tif (j >= i || !tokens[j])\n\t\t\tcontinue;\n\t\t/* there should be exactly three fields after\n\t\t * the separator\n\t\t */\n\t\tif (i != j + 4)\n\t\t\tcontinue;\n\n\t\t/* not a cgroup filesystem */\n\t\tif (strcmp(tokens[j + 1], \"cgroup\") != 0) {\n\t\t\tif (strcmp(tokens[j + 1], \"fuse.lxcfs\") != 0)\n\t\t\t\tcontinue;\n\t\t\tif (strncmp(tokens[4], \"/sys/fs/cgroup/\", 15) != 0)\n\t\t\t\tcontinue;\n\t\t\tis_lxcfs = true;\n\t\t\tchar *curtok = tokens[4] + 15;\n\t\t\tsubsystems = subsystems_from_mount_options(curtok,\n\t\t\t\t\t\t\t kernel_subsystems);\n\t\t} else\n\t\t\tsubsystems = subsystems_from_mount_options(tokens[j + 3],\n\t\t\t\t\t\t\t kernel_subsystems);\n\t\tif (!subsystems)\n\t\t\tgoto out;\n\n\t\th = NULL;\n\t\tfor (k = 0; k <= meta_data->maximum_hierarchy; k++) {\n\t\t\tif (meta_data->hierarchies[k] &&\n\t\t\t    meta_data->hierarchies[k]->subsystems[0] &&\n\t\t\t    lxc_string_in_array(meta_data->hierarchies[k]->subsystems[0], (const char **)subsystems)) {\n\t\t\t\t/* TODO: we could also check if the lists really match completely,\n\t\t\t\t *       just to have an additional sanity check */\n\t\t\t\th = meta_data->hierarchies[k];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlxc_free_array((void **)subsystems, free);\n\n\t\tr = lxc_grow_array((void ***)&meta_data->mount_points, &mount_point_capacity, mount_point_count + 1, 12);\n\t\tif (r < 0)\n\t\t\tgoto out;\n\n\t\t/* create mount point object */\n\t\tmount_point = calloc(1, sizeof(*mount_point));\n\t\tif (!mount_point)\n\t\t\tgoto out;\n\n\t\tmeta_data->mount_points[mount_point_count++] = mount_point;\n\n\t\tmount_point->hierarchy = h;\n\t\tif (is_lxcfs || is_cgns)\n\t\t\tmount_point->mount_prefix = strdup(\"/\");\n\t\telse\n\t\t\tmount_point->mount_prefix = strdup(tokens[3]);\n\t\tmount_point->mount_point = strdup(tokens[4]);\n\t\tif (!mount_point->mount_point || !mount_point->mount_prefix)\n\t\t\tgoto out;\n\t\tmount_point->read_only = !lxc_string_in_list(\"rw\", tokens[5], ',');\n\n\t\tif (!strcmp(mount_point->mount_prefix, \"/\")) {\n\t\t\tif (mount_point->read_only) {\n\t\t\t\tif (!h->ro_absolute_mount_point)\n\t\t\t\t\th->ro_absolute_mount_point = mount_point;\n\t\t\t} else {\n\t\t\t\tif (!h->rw_absolute_mount_point)\n\t\t\t\t\th->rw_absolute_mount_point = mount_point;\n\t\t\t}\n\t\t}\n\n\t\tk = lxc_array_len((void **)h->all_mount_points);\n\t\tr = lxc_grow_array((void ***)&h->all_mount_points, &h->all_mount_point_capacity, k + 1, 4);\n\t\tif (r < 0)\n\t\t\tgoto out;\n\t\th->all_mount_points[k] = mount_point;\n\t}\n\tbret = true;\n\nout:\n\tfclose(proc_self_mountinfo);\n\tfree(tokens);\n\tfree(line);\n\treturn bret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);",
      "static struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);",
      "static struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "line"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "cgfs_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2501-2518",
          "snippet": "static bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "proc_self_mountinfo"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_grow_array",
          "args": [
            "(void ***)&h->all_mount_points",
            "&h->all_mount_point_capacity",
            "k + 1",
            "4"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_grow_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "894-921",
          "snippet": "int lxc_grow_array(void ***array, size_t* capacity, size_t new_size, size_t capacity_increment)\n{\n\tsize_t new_capacity;\n\tvoid **new_array;\n\n\t/* first time around, catch some trivial mistakes of the user\n\t * only initializing one of these */\n\tif (!*array || !*capacity) {\n\t\t*array = NULL;\n\t\t*capacity = 0;\n\t}\n\n\tnew_capacity = *capacity;\n\twhile (new_size + 1 > new_capacity)\n\t\tnew_capacity += capacity_increment;\n\tif (new_capacity != *capacity) {\n\t\t/* we have to reallocate */\n\t\tnew_array = realloc(*array, new_capacity * sizeof(void *));\n\t\tif (!new_array)\n\t\t\treturn -1;\n\t\tmemset(&new_array[*capacity], 0, (new_capacity - (*capacity)) * sizeof(void *));\n\t\t*array = new_array;\n\t\t*capacity = new_capacity;\n\t}\n\n\t/* array has sufficient elements */\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_grow_array(void ***array, size_t* capacity, size_t new_size, size_t capacity_increment)\n{\n\tsize_t new_capacity;\n\tvoid **new_array;\n\n\t/* first time around, catch some trivial mistakes of the user\n\t * only initializing one of these */\n\tif (!*array || !*capacity) {\n\t\t*array = NULL;\n\t\t*capacity = 0;\n\t}\n\n\tnew_capacity = *capacity;\n\twhile (new_size + 1 > new_capacity)\n\t\tnew_capacity += capacity_increment;\n\tif (new_capacity != *capacity) {\n\t\t/* we have to reallocate */\n\t\tnew_array = realloc(*array, new_capacity * sizeof(void *));\n\t\tif (!new_array)\n\t\t\treturn -1;\n\t\tmemset(&new_array[*capacity], 0, (new_capacity - (*capacity)) * sizeof(void *));\n\t\t*array = new_array;\n\t\t*capacity = new_capacity;\n\t}\n\n\t/* array has sufficient elements */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_array_len",
          "args": [
            "(void **)h->all_mount_points"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_array_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "923-932",
          "snippet": "size_t lxc_array_len(void **array)\n{\n\tvoid **p;\n\tsize_t result = 0;\n\n\tfor (p = array; p && *p; p++)\n\t\tresult++;\n\n\treturn result;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nsize_t lxc_array_len(void **array)\n{\n\tvoid **p;\n\tsize_t result = 0;\n\n\tfor (p = array; p && *p; p++)\n\t\tresult++;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mount_point->mount_prefix",
            "\"/\""
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_string_in_list",
          "args": [
            "\"rw\"",
            "tokens[5]",
            "','"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_in_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "787-803",
          "snippet": "bool lxc_string_in_list(const char *needle, const char *haystack, char _sep)\n{\n\tchar *token, *str, *saveptr = NULL;\n\tchar sep[2] = { _sep, '\\0' };\n\n\tif (!haystack || !needle)\n\t\treturn 0;\n\n\tstr = alloca(strlen(haystack)+1);\n\tstrcpy(str, haystack);\n\tfor (; (token = strtok_r(str, sep, &saveptr)); str = NULL) {\n\t\tif (strcmp(needle, token) == 0)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool lxc_string_in_list(const char *needle, const char *haystack, char _sep)\n{\n\tchar *token, *str, *saveptr = NULL;\n\tchar sep[2] = { _sep, '\\0' };\n\n\tif (!haystack || !needle)\n\t\treturn 0;\n\n\tstr = alloca(strlen(haystack)+1);\n\tstrcpy(str, haystack);\n\tfor (; (token = strtok_r(str, sep, &saveptr)); str = NULL) {\n\t\tif (strcmp(needle, token) == 0)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "tokens[4]"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "tokens[3]"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"/\""
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "sizeof(*mount_point)"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_free_array",
          "args": [
            "(void **)subsystems",
            "free"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_free_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "886-892",
          "snippet": "void lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_string_in_array",
          "args": [
            "meta_data->hierarchies[k]->subsystems[0]",
            "(const char **)subsystems"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_in_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "656-662",
          "snippet": "bool lxc_string_in_array(const char *needle, const char **haystack)\n{\n\tfor (; haystack && *haystack; haystack++)\n\t\tif (!strcmp(needle, *haystack))\n\t\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool lxc_string_in_array(const char *needle, const char **haystack)\n{\n\tfor (; haystack && *haystack; haystack++)\n\t\tif (!strcmp(needle, *haystack))\n\t\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "subsystems_from_mount_options",
          "args": [
            "tokens[j + 3]",
            "kernel_subsystems"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "subsystems_from_mount_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "1781-1821",
          "snippet": "static char **subsystems_from_mount_options(const char *mount_options,\n\t\t\t\t\t    char **kernel_list)\n{\n\tchar *token, *str, *saveptr = NULL;\n\tchar **result = NULL;\n\tsize_t result_capacity = 0;\n\tsize_t result_count = 0;\n\tint saved_errno;\n\tint r;\n\n\tstr = alloca(strlen(mount_options)+1);\n\tstrcpy(str, mount_options);\n\tfor (; (token = strtok_r(str, \",\", &saveptr)); str = NULL) {\n\t\t/* we have a subsystem if it's either in the list of\n\t\t * subsystems provided by the kernel OR if it starts\n\t\t * with name= for named hierarchies\n\t\t */\n\t\tr = lxc_grow_array((void ***)&result, &result_capacity, result_count + 1, 12);\n\t\tif (r < 0)\n\t\t\tgoto out_free;\n\t\tresult[result_count + 1] = NULL;\n\t\tif (strncmp(token, \"name=\", 5) && !lxc_string_in_array(token, (const char **)kernel_list)) {\n\t\t\t// this is eg 'systemd' but the mount will be 'name=systemd'\n\t\t\tresult[result_count] = malloc(strlen(token) + 6);\n\t\t\tif (result[result_count])\n\t\t\t\tsprintf(result[result_count], \"name=%s\", token);\n\t\t} else\n\t\t\tresult[result_count] = strdup(token);\n\t\tif (!result[result_count])\n\t\t\tgoto out_free;\n\t\tresult_count++;\n\t}\n\n\treturn result;\n\nout_free:\n\tsaved_errno = errno;\n\tlxc_free_array((void**)result, free);\n\terrno = saved_errno;\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char **subsystems_from_mount_options(const char *mount_options, char **kernel_list);",
            "static bool is_valid_cgroup(const char *name);",
            "static struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic char **subsystems_from_mount_options(const char *mount_options, char **kernel_list);\nstatic bool is_valid_cgroup(const char *name);\nstatic struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);\n\nstatic char **subsystems_from_mount_options(const char *mount_options,\n\t\t\t\t\t    char **kernel_list)\n{\n\tchar *token, *str, *saveptr = NULL;\n\tchar **result = NULL;\n\tsize_t result_capacity = 0;\n\tsize_t result_count = 0;\n\tint saved_errno;\n\tint r;\n\n\tstr = alloca(strlen(mount_options)+1);\n\tstrcpy(str, mount_options);\n\tfor (; (token = strtok_r(str, \",\", &saveptr)); str = NULL) {\n\t\t/* we have a subsystem if it's either in the list of\n\t\t * subsystems provided by the kernel OR if it starts\n\t\t * with name= for named hierarchies\n\t\t */\n\t\tr = lxc_grow_array((void ***)&result, &result_capacity, result_count + 1, 12);\n\t\tif (r < 0)\n\t\t\tgoto out_free;\n\t\tresult[result_count + 1] = NULL;\n\t\tif (strncmp(token, \"name=\", 5) && !lxc_string_in_array(token, (const char **)kernel_list)) {\n\t\t\t// this is eg 'systemd' but the mount will be 'name=systemd'\n\t\t\tresult[result_count] = malloc(strlen(token) + 6);\n\t\t\tif (result[result_count])\n\t\t\t\tsprintf(result[result_count], \"name=%s\", token);\n\t\t} else\n\t\t\tresult[result_count] = strdup(token);\n\t\tif (!result[result_count])\n\t\t\tgoto out_free;\n\t\tresult_count++;\n\t}\n\n\treturn result;\n\nout_free:\n\tsaved_errno = errno;\n\tlxc_free_array((void**)result, free);\n\terrno = saved_errno;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "tokens[4]",
            "\"/sys/fs/cgroup/\"",
            "15"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "tokens[j + 1]",
            "\"fuse.lxcfs\""
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "tokens[j + 1]",
            "\"cgroup\""
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "tokens[j]",
            "\"-\""
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "line_tok",
            "\" \"",
            "&saveptr"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "line"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "line"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&line",
            "&sz",
            "proc_self_mountinfo"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getline.c",
          "lines": "39-60",
          "snippet": "ssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fopen_cloexec",
          "args": [
            "\"/proc/1/mountinfo\"",
            "\"r\""
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgns_supported",
          "args": [],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "cgns_supported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1247-1250",
          "snippet": "bool cgns_supported(void)\n{\n\treturn file_exists(\"/proc/self/ns/cgroup\");\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool cgns_supported(void)\n{\n\treturn file_exists(\"/proc/self/ns/cgroup\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);\nstatic struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);\nstatic struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);\n\nstatic bool find_hierarchy_mountpts( struct cgroup_meta_data *meta_data, char **kernel_subsystems)\n{\n\tbool bret = false;\n\tFILE *proc_self_mountinfo;\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tchar **tokens = NULL;\n\tsize_t mount_point_count = 0;\n\tsize_t mount_point_capacity = 0;\n\tsize_t token_capacity = 0;\n\tint r;\n\tbool is_cgns = cgns_supported();\n\n\tproc_self_mountinfo = fopen_cloexec(\"/proc/self/mountinfo\", \"r\");\n\t/* if for some reason (because of setns() and pid namespace for example),\n\t * /proc/self is not valid, we try /proc/1/cgroup... */\n\tif (!proc_self_mountinfo)\n\t\tproc_self_mountinfo = fopen_cloexec(\"/proc/1/mountinfo\", \"r\");\n\tif (!proc_self_mountinfo)\n\t\treturn false;\n\n\twhile (getline(&line, &sz, proc_self_mountinfo) != -1) {\n\t\tchar *token, *line_tok, *saveptr = NULL;\n\t\tsize_t i, j, k;\n\t\tstruct cgroup_mount_point *mount_point;\n\t\tstruct cgroup_hierarchy *h;\n\t\tchar **subsystems;\n\t\tbool is_lxcfs = false;\n\n\t\tif (line[0] && line[strlen(line) - 1] == '\\n')\n\t\t\tline[strlen(line) - 1] = '\\0';\n\n\t\tfor (i = 0, line_tok = line; (token = strtok_r(line_tok, \" \", &saveptr)); line_tok = NULL) {\n\t\t\tr = lxc_grow_array((void ***)&tokens, &token_capacity, i + 1, 64);\n\t\t\tif (r < 0)\n\t\t\t\tgoto out;\n\t\t\ttokens[i++] = token;\n\t\t}\n\n\t\t/* layout of /proc/self/mountinfo:\n\t\t *      0: id\n\t\t *      1: parent id\n\t\t *      2: device major:minor\n\t\t *      3: mount prefix\n\t\t *      4: mount point\n\t\t *      5: per-mount options\n\t\t *    [optional X]: additional data\n\t\t *    X+7: \"-\"\n\t\t *    X+8: type\n\t\t *    X+9: source\n\t\t *    X+10: per-superblock options\n\t\t */\n\t\tfor (j = 6; j < i && tokens[j]; j++)\n\t\t\tif (!strcmp(tokens[j], \"-\"))\n\t\t\t\tbreak;\n\n\t\t/* could not find separator */\n\t\tif (j >= i || !tokens[j])\n\t\t\tcontinue;\n\t\t/* there should be exactly three fields after\n\t\t * the separator\n\t\t */\n\t\tif (i != j + 4)\n\t\t\tcontinue;\n\n\t\t/* not a cgroup filesystem */\n\t\tif (strcmp(tokens[j + 1], \"cgroup\") != 0) {\n\t\t\tif (strcmp(tokens[j + 1], \"fuse.lxcfs\") != 0)\n\t\t\t\tcontinue;\n\t\t\tif (strncmp(tokens[4], \"/sys/fs/cgroup/\", 15) != 0)\n\t\t\t\tcontinue;\n\t\t\tis_lxcfs = true;\n\t\t\tchar *curtok = tokens[4] + 15;\n\t\t\tsubsystems = subsystems_from_mount_options(curtok,\n\t\t\t\t\t\t\t kernel_subsystems);\n\t\t} else\n\t\t\tsubsystems = subsystems_from_mount_options(tokens[j + 3],\n\t\t\t\t\t\t\t kernel_subsystems);\n\t\tif (!subsystems)\n\t\t\tgoto out;\n\n\t\th = NULL;\n\t\tfor (k = 0; k <= meta_data->maximum_hierarchy; k++) {\n\t\t\tif (meta_data->hierarchies[k] &&\n\t\t\t    meta_data->hierarchies[k]->subsystems[0] &&\n\t\t\t    lxc_string_in_array(meta_data->hierarchies[k]->subsystems[0], (const char **)subsystems)) {\n\t\t\t\t/* TODO: we could also check if the lists really match completely,\n\t\t\t\t *       just to have an additional sanity check */\n\t\t\t\th = meta_data->hierarchies[k];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlxc_free_array((void **)subsystems, free);\n\n\t\tr = lxc_grow_array((void ***)&meta_data->mount_points, &mount_point_capacity, mount_point_count + 1, 12);\n\t\tif (r < 0)\n\t\t\tgoto out;\n\n\t\t/* create mount point object */\n\t\tmount_point = calloc(1, sizeof(*mount_point));\n\t\tif (!mount_point)\n\t\t\tgoto out;\n\n\t\tmeta_data->mount_points[mount_point_count++] = mount_point;\n\n\t\tmount_point->hierarchy = h;\n\t\tif (is_lxcfs || is_cgns)\n\t\t\tmount_point->mount_prefix = strdup(\"/\");\n\t\telse\n\t\t\tmount_point->mount_prefix = strdup(tokens[3]);\n\t\tmount_point->mount_point = strdup(tokens[4]);\n\t\tif (!mount_point->mount_point || !mount_point->mount_prefix)\n\t\t\tgoto out;\n\t\tmount_point->read_only = !lxc_string_in_list(\"rw\", tokens[5], ',');\n\n\t\tif (!strcmp(mount_point->mount_prefix, \"/\")) {\n\t\t\tif (mount_point->read_only) {\n\t\t\t\tif (!h->ro_absolute_mount_point)\n\t\t\t\t\th->ro_absolute_mount_point = mount_point;\n\t\t\t} else {\n\t\t\t\tif (!h->rw_absolute_mount_point)\n\t\t\t\t\th->rw_absolute_mount_point = mount_point;\n\t\t\t}\n\t\t}\n\n\t\tk = lxc_array_len((void **)h->all_mount_points);\n\t\tr = lxc_grow_array((void ***)&h->all_mount_points, &h->all_mount_point_capacity, k + 1, 4);\n\t\tif (r < 0)\n\t\t\tgoto out;\n\t\th->all_mount_points[k] = mount_point;\n\t}\n\tbret = true;\n\nout:\n\tfclose(proc_self_mountinfo);\n\tfree(tokens);\n\tfree(line);\n\treturn bret;\n}"
  },
  {
    "function_name": "find_cgroup_hierarchies",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "325-430",
    "snippet": "static bool find_cgroup_hierarchies(struct cgroup_meta_data *meta_data,\n\tbool all_kernel_subsystems, bool all_named_subsystems,\n\tconst char **subsystem_whitelist)\n{\n\tFILE *proc_self_cgroup;\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tint r;\n\tbool bret = false;\n\tsize_t hierarchy_capacity = 0;\n\n\tproc_self_cgroup = fopen_cloexec(\"/proc/self/cgroup\", \"r\");\n\t/* if for some reason (because of setns() and pid namespace for example),\n\t * /proc/self is not valid, we try /proc/1/cgroup... */\n\tif (!proc_self_cgroup)\n\t\tproc_self_cgroup = fopen_cloexec(\"/proc/1/cgroup\", \"r\");\n\tif (!proc_self_cgroup)\n\t\treturn false;\n\n\twhile (getline(&line, &sz, proc_self_cgroup) != -1) {\n\t\t/* file format: hierarchy:subsystems:group,\n\t\t * we only extract hierarchy and subsystems\n\t\t * here */\n\t\tchar *colon1;\n\t\tchar *colon2;\n\t\tint hierarchy_number;\n\t\tstruct cgroup_hierarchy *h = NULL;\n\t\tchar **p;\n\n\t\tif (!line[0])\n\t\t\tcontinue;\n\n\t\tcolon1 = strchr(line, ':');\n\t\tif (!colon1)\n\t\t\tcontinue;\n\t\t*colon1++ = '\\0';\n\t\tcolon2 = strchr(colon1, ':');\n\t\tif (!colon2)\n\t\t\tcontinue;\n\t\t*colon2 = '\\0';\n\n\t\tcolon2 = NULL;\n\n\t\t/* With cgroupv2 /proc/self/cgroup can contain entries of the\n\t\t * form: 0::/\n\t\t * These entries need to be skipped.\n\t\t */\n\t\tif (!strcmp(colon1, \"\"))\n\t\t\tcontinue;\n\n\t\thierarchy_number = strtoul(line, &colon2, 10);\n\t\tif (!colon2 || *colon2)\n\t\t\tcontinue;\n\n\t\tif (hierarchy_number > meta_data->maximum_hierarchy) {\n\t\t\t/* lxc_grow_array will never shrink, so even if we find a lower\n\t\t\t* hierarchy number here, the array will never be smaller\n\t\t\t*/\n\t\t\tr = lxc_grow_array((void ***)&meta_data->hierarchies, &hierarchy_capacity, hierarchy_number + 1, 12);\n\t\t\tif (r < 0)\n\t\t\t\tgoto out;\n\n\t\t\tmeta_data->maximum_hierarchy = hierarchy_number;\n\t\t}\n\n\t\t/* this shouldn't happen, we had this already */\n\t\tif (meta_data->hierarchies[hierarchy_number])\n\t\t\tgoto out;\n\n\t\th = calloc(1, sizeof(struct cgroup_hierarchy));\n\t\tif (!h)\n\t\t\tgoto out;\n\n\t\tmeta_data->hierarchies[hierarchy_number] = h;\n\n\t\th->index = hierarchy_number;\n\t\th->subsystems = lxc_string_split_and_trim(colon1, ',');\n\t\tif (!h->subsystems)\n\t\t\tgoto out;\n\t\t/* see if this hierarchy should be considered */\n\t\tif (!all_kernel_subsystems || !all_named_subsystems) {\n\t\t\tfor (p = h->subsystems; *p; p++) {\n\t\t\t\tif (!strncmp(*p, \"name=\", 5)) {\n\t\t\t\t\tif (all_named_subsystems || (subsystem_whitelist && lxc_string_in_array(*p, subsystem_whitelist))) {\n\t\t\t\t\t\th->used = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (all_kernel_subsystems || (subsystem_whitelist && lxc_string_in_array(*p, subsystem_whitelist))) {\n\t\t\t\t\t\th->used = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/* we want all hierarchy anyway */\n\t\t\th->used = true;\n\t\t}\n\t}\n\tbret = true;\n\nout:\n\tfclose(proc_self_cgroup);\n\tfree(line);\n\treturn bret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);",
      "static bool is_valid_cgroup(const char *name);",
      "static struct cgroup_meta_data *lxc_cgroup_load_meta2(const char **subsystem_whitelist);",
      "static struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);",
      "static struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "line"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "cgfs_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2501-2518",
          "snippet": "static bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "proc_self_cgroup"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_string_in_array",
          "args": [
            "*p",
            "subsystem_whitelist"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_in_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "656-662",
          "snippet": "bool lxc_string_in_array(const char *needle, const char **haystack)\n{\n\tfor (; haystack && *haystack; haystack++)\n\t\tif (!strcmp(needle, *haystack))\n\t\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool lxc_string_in_array(const char *needle, const char **haystack)\n{\n\tfor (; haystack && *haystack; haystack++)\n\t\tif (!strcmp(needle, *haystack))\n\t\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "*p",
            "\"name=\"",
            "5"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_string_split_and_trim",
          "args": [
            "colon1",
            "','"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_split_and_trim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "845-884",
          "snippet": "char **lxc_string_split_and_trim(const char *string, char _sep)\n{\n\tchar *token, *str, *saveptr = NULL;\n\tchar sep[2] = { _sep, '\\0' };\n\tchar **result = NULL;\n\tsize_t result_capacity = 0;\n\tsize_t result_count = 0;\n\tint r, saved_errno;\n\tsize_t i = 0;\n\n\tif (!string)\n\t\treturn calloc(1, sizeof(char *));\n\n\tstr = alloca(strlen(string)+1);\n\tstrcpy(str, string);\n\tfor (; (token = strtok_r(str, sep, &saveptr)); str = NULL) {\n\t\twhile (token[0] == ' ' || token[0] == '\\t')\n\t\t\ttoken++;\n\t\ti = strlen(token);\n\t\twhile (i > 0 && (token[i - 1] == ' ' || token[i - 1] == '\\t')) {\n\t\t\ttoken[i - 1] = '\\0';\n\t\t\ti--;\n\t\t}\n\t\tr = lxc_grow_array((void ***)&result, &result_capacity, result_count + 1, 16);\n\t\tif (r < 0)\n\t\t\tgoto error_out;\n\t\tresult[result_count] = strdup(token);\n\t\tif (!result[result_count])\n\t\t\tgoto error_out;\n\t\tresult_count++;\n\t}\n\n\t/* if we allocated too much, reduce it */\n\treturn realloc(result, (result_count + 1) * sizeof(char *));\nerror_out:\n\tsaved_errno = errno;\n\tlxc_free_array((void **)result, free);\n\terrno = saved_errno;\n\treturn NULL;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar **lxc_string_split_and_trim(const char *string, char _sep)\n{\n\tchar *token, *str, *saveptr = NULL;\n\tchar sep[2] = { _sep, '\\0' };\n\tchar **result = NULL;\n\tsize_t result_capacity = 0;\n\tsize_t result_count = 0;\n\tint r, saved_errno;\n\tsize_t i = 0;\n\n\tif (!string)\n\t\treturn calloc(1, sizeof(char *));\n\n\tstr = alloca(strlen(string)+1);\n\tstrcpy(str, string);\n\tfor (; (token = strtok_r(str, sep, &saveptr)); str = NULL) {\n\t\twhile (token[0] == ' ' || token[0] == '\\t')\n\t\t\ttoken++;\n\t\ti = strlen(token);\n\t\twhile (i > 0 && (token[i - 1] == ' ' || token[i - 1] == '\\t')) {\n\t\t\ttoken[i - 1] = '\\0';\n\t\t\ti--;\n\t\t}\n\t\tr = lxc_grow_array((void ***)&result, &result_capacity, result_count + 1, 16);\n\t\tif (r < 0)\n\t\t\tgoto error_out;\n\t\tresult[result_count] = strdup(token);\n\t\tif (!result[result_count])\n\t\t\tgoto error_out;\n\t\tresult_count++;\n\t}\n\n\t/* if we allocated too much, reduce it */\n\treturn realloc(result, (result_count + 1) * sizeof(char *));\nerror_out:\n\tsaved_errno = errno;\n\tlxc_free_array((void **)result, free);\n\terrno = saved_errno;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "sizeof(struct cgroup_hierarchy)"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_grow_array",
          "args": [
            "(void ***)&meta_data->hierarchies",
            "&hierarchy_capacity",
            "hierarchy_number + 1",
            "12"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_grow_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "894-921",
          "snippet": "int lxc_grow_array(void ***array, size_t* capacity, size_t new_size, size_t capacity_increment)\n{\n\tsize_t new_capacity;\n\tvoid **new_array;\n\n\t/* first time around, catch some trivial mistakes of the user\n\t * only initializing one of these */\n\tif (!*array || !*capacity) {\n\t\t*array = NULL;\n\t\t*capacity = 0;\n\t}\n\n\tnew_capacity = *capacity;\n\twhile (new_size + 1 > new_capacity)\n\t\tnew_capacity += capacity_increment;\n\tif (new_capacity != *capacity) {\n\t\t/* we have to reallocate */\n\t\tnew_array = realloc(*array, new_capacity * sizeof(void *));\n\t\tif (!new_array)\n\t\t\treturn -1;\n\t\tmemset(&new_array[*capacity], 0, (new_capacity - (*capacity)) * sizeof(void *));\n\t\t*array = new_array;\n\t\t*capacity = new_capacity;\n\t}\n\n\t/* array has sufficient elements */\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_grow_array(void ***array, size_t* capacity, size_t new_size, size_t capacity_increment)\n{\n\tsize_t new_capacity;\n\tvoid **new_array;\n\n\t/* first time around, catch some trivial mistakes of the user\n\t * only initializing one of these */\n\tif (!*array || !*capacity) {\n\t\t*array = NULL;\n\t\t*capacity = 0;\n\t}\n\n\tnew_capacity = *capacity;\n\twhile (new_size + 1 > new_capacity)\n\t\tnew_capacity += capacity_increment;\n\tif (new_capacity != *capacity) {\n\t\t/* we have to reallocate */\n\t\tnew_array = realloc(*array, new_capacity * sizeof(void *));\n\t\tif (!new_array)\n\t\t\treturn -1;\n\t\tmemset(&new_array[*capacity], 0, (new_capacity - (*capacity)) * sizeof(void *));\n\t\t*array = new_array;\n\t\t*capacity = new_capacity;\n\t}\n\n\t/* array has sufficient elements */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "line",
            "&colon2",
            "10"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "colon1",
            "\"\""
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "colon1",
            "':'"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&line",
            "&sz",
            "proc_self_cgroup"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getline.c",
          "lines": "39-60",
          "snippet": "ssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fopen_cloexec",
          "args": [
            "\"/proc/1/cgroup\"",
            "\"r\""
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lxc_cgroup_hierarchy_free(struct cgroup_hierarchy *h);\nstatic bool is_valid_cgroup(const char *name);\nstatic struct cgroup_meta_data *lxc_cgroup_load_meta2(const char **subsystem_whitelist);\nstatic struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);\nstatic struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);\n\nstatic bool find_cgroup_hierarchies(struct cgroup_meta_data *meta_data,\n\tbool all_kernel_subsystems, bool all_named_subsystems,\n\tconst char **subsystem_whitelist)\n{\n\tFILE *proc_self_cgroup;\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tint r;\n\tbool bret = false;\n\tsize_t hierarchy_capacity = 0;\n\n\tproc_self_cgroup = fopen_cloexec(\"/proc/self/cgroup\", \"r\");\n\t/* if for some reason (because of setns() and pid namespace for example),\n\t * /proc/self is not valid, we try /proc/1/cgroup... */\n\tif (!proc_self_cgroup)\n\t\tproc_self_cgroup = fopen_cloexec(\"/proc/1/cgroup\", \"r\");\n\tif (!proc_self_cgroup)\n\t\treturn false;\n\n\twhile (getline(&line, &sz, proc_self_cgroup) != -1) {\n\t\t/* file format: hierarchy:subsystems:group,\n\t\t * we only extract hierarchy and subsystems\n\t\t * here */\n\t\tchar *colon1;\n\t\tchar *colon2;\n\t\tint hierarchy_number;\n\t\tstruct cgroup_hierarchy *h = NULL;\n\t\tchar **p;\n\n\t\tif (!line[0])\n\t\t\tcontinue;\n\n\t\tcolon1 = strchr(line, ':');\n\t\tif (!colon1)\n\t\t\tcontinue;\n\t\t*colon1++ = '\\0';\n\t\tcolon2 = strchr(colon1, ':');\n\t\tif (!colon2)\n\t\t\tcontinue;\n\t\t*colon2 = '\\0';\n\n\t\tcolon2 = NULL;\n\n\t\t/* With cgroupv2 /proc/self/cgroup can contain entries of the\n\t\t * form: 0::/\n\t\t * These entries need to be skipped.\n\t\t */\n\t\tif (!strcmp(colon1, \"\"))\n\t\t\tcontinue;\n\n\t\thierarchy_number = strtoul(line, &colon2, 10);\n\t\tif (!colon2 || *colon2)\n\t\t\tcontinue;\n\n\t\tif (hierarchy_number > meta_data->maximum_hierarchy) {\n\t\t\t/* lxc_grow_array will never shrink, so even if we find a lower\n\t\t\t* hierarchy number here, the array will never be smaller\n\t\t\t*/\n\t\t\tr = lxc_grow_array((void ***)&meta_data->hierarchies, &hierarchy_capacity, hierarchy_number + 1, 12);\n\t\t\tif (r < 0)\n\t\t\t\tgoto out;\n\n\t\t\tmeta_data->maximum_hierarchy = hierarchy_number;\n\t\t}\n\n\t\t/* this shouldn't happen, we had this already */\n\t\tif (meta_data->hierarchies[hierarchy_number])\n\t\t\tgoto out;\n\n\t\th = calloc(1, sizeof(struct cgroup_hierarchy));\n\t\tif (!h)\n\t\t\tgoto out;\n\n\t\tmeta_data->hierarchies[hierarchy_number] = h;\n\n\t\th->index = hierarchy_number;\n\t\th->subsystems = lxc_string_split_and_trim(colon1, ',');\n\t\tif (!h->subsystems)\n\t\t\tgoto out;\n\t\t/* see if this hierarchy should be considered */\n\t\tif (!all_kernel_subsystems || !all_named_subsystems) {\n\t\t\tfor (p = h->subsystems; *p; p++) {\n\t\t\t\tif (!strncmp(*p, \"name=\", 5)) {\n\t\t\t\t\tif (all_named_subsystems || (subsystem_whitelist && lxc_string_in_array(*p, subsystem_whitelist))) {\n\t\t\t\t\t\th->used = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (all_kernel_subsystems || (subsystem_whitelist && lxc_string_in_array(*p, subsystem_whitelist))) {\n\t\t\t\t\t\th->used = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/* we want all hierarchy anyway */\n\t\t\th->used = true;\n\t\t}\n\t}\n\tbret = true;\n\nout:\n\tfclose(proc_self_cgroup);\n\tfree(line);\n\treturn bret;\n}"
  },
  {
    "function_name": "find_cgroup_subsystems",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "266-319",
    "snippet": "static bool find_cgroup_subsystems(char ***kernel_subsystems)\n{\n\tFILE *proc_cgroups;\n\tbool bret = false;\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tsize_t kernel_subsystems_count = 0;\n\tsize_t kernel_subsystems_capacity = 0;\n\tint r;\n\n\tproc_cgroups = fopen_cloexec(\"/proc/cgroups\", \"r\");\n\tif (!proc_cgroups)\n\t\treturn false;\n\n\twhile (getline(&line, &sz, proc_cgroups) != -1) {\n\t\tchar *tab1;\n\t\tchar *tab2;\n\t\tint hierarchy_number;\n\n\t\tif (line[0] == '#')\n\t\t\tcontinue;\n\t\tif (!line[0])\n\t\t\tcontinue;\n\n\t\ttab1 = strchr(line, '\\t');\n\t\tif (!tab1)\n\t\t\tcontinue;\n\t\t*tab1++ = '\\0';\n\t\ttab2 = strchr(tab1, '\\t');\n\t\tif (!tab2)\n\t\t\tcontinue;\n\t\t*tab2 = '\\0';\n\n\t\ttab2 = NULL;\n\t\thierarchy_number = strtoul(tab1, &tab2, 10);\n\t\tif (!tab2 || *tab2)\n\t\t\tcontinue;\n\t\t(void)hierarchy_number;\n\n\t\tr = lxc_grow_array((void ***)kernel_subsystems, &kernel_subsystems_capacity, kernel_subsystems_count + 1, 12);\n\t\tif (r < 0)\n\t\t\tgoto out;\n\t\t(*kernel_subsystems)[kernel_subsystems_count] = strdup(line);\n\t\tif (!(*kernel_subsystems)[kernel_subsystems_count])\n\t\t\tgoto out;\n\t\tkernel_subsystems_count++;\n\t}\n\tbret = true;\n\nout:\n\tfclose(proc_cgroups);\n\tfree(line);\n\treturn bret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "line"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "cgfs_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2501-2518",
          "snippet": "static bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgfs_unfreeze(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tchar *cgabspath, *cgrelpath;\n\tint ret;\n\n\tif (!d)\n\t\treturn false;\n\n\tcgrelpath = lxc_cgroup_get_hierarchy_path_data(\"freezer\", d);\n\tcgabspath = lxc_cgroup_find_abs_path(\"freezer\", cgrelpath, true, NULL);\n\tif (!cgabspath)\n\t\treturn false;\n\n\tret = do_cgroup_set(cgabspath, \"freezer.state\", \"THAWED\");\n\tfree(cgabspath);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "proc_cgroups"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "line"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_grow_array",
          "args": [
            "(void ***)kernel_subsystems",
            "&kernel_subsystems_capacity",
            "kernel_subsystems_count + 1",
            "12"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_grow_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "894-921",
          "snippet": "int lxc_grow_array(void ***array, size_t* capacity, size_t new_size, size_t capacity_increment)\n{\n\tsize_t new_capacity;\n\tvoid **new_array;\n\n\t/* first time around, catch some trivial mistakes of the user\n\t * only initializing one of these */\n\tif (!*array || !*capacity) {\n\t\t*array = NULL;\n\t\t*capacity = 0;\n\t}\n\n\tnew_capacity = *capacity;\n\twhile (new_size + 1 > new_capacity)\n\t\tnew_capacity += capacity_increment;\n\tif (new_capacity != *capacity) {\n\t\t/* we have to reallocate */\n\t\tnew_array = realloc(*array, new_capacity * sizeof(void *));\n\t\tif (!new_array)\n\t\t\treturn -1;\n\t\tmemset(&new_array[*capacity], 0, (new_capacity - (*capacity)) * sizeof(void *));\n\t\t*array = new_array;\n\t\t*capacity = new_capacity;\n\t}\n\n\t/* array has sufficient elements */\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_grow_array(void ***array, size_t* capacity, size_t new_size, size_t capacity_increment)\n{\n\tsize_t new_capacity;\n\tvoid **new_array;\n\n\t/* first time around, catch some trivial mistakes of the user\n\t * only initializing one of these */\n\tif (!*array || !*capacity) {\n\t\t*array = NULL;\n\t\t*capacity = 0;\n\t}\n\n\tnew_capacity = *capacity;\n\twhile (new_size + 1 > new_capacity)\n\t\tnew_capacity += capacity_increment;\n\tif (new_capacity != *capacity) {\n\t\t/* we have to reallocate */\n\t\tnew_array = realloc(*array, new_capacity * sizeof(void *));\n\t\tif (!new_array)\n\t\t\treturn -1;\n\t\tmemset(&new_array[*capacity], 0, (new_capacity - (*capacity)) * sizeof(void *));\n\t\t*array = new_array;\n\t\t*capacity = new_capacity;\n\t}\n\n\t/* array has sufficient elements */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "tab1",
            "&tab2",
            "10"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "tab1",
            "'\\t'"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&line",
            "&sz",
            "proc_cgroups"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getline.c",
          "lines": "39-60",
          "snippet": "ssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fopen_cloexec",
          "args": [
            "\"/proc/cgroups\"",
            "\"r\""
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool find_cgroup_subsystems(char ***kernel_subsystems)\n{\n\tFILE *proc_cgroups;\n\tbool bret = false;\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tsize_t kernel_subsystems_count = 0;\n\tsize_t kernel_subsystems_capacity = 0;\n\tint r;\n\n\tproc_cgroups = fopen_cloexec(\"/proc/cgroups\", \"r\");\n\tif (!proc_cgroups)\n\t\treturn false;\n\n\twhile (getline(&line, &sz, proc_cgroups) != -1) {\n\t\tchar *tab1;\n\t\tchar *tab2;\n\t\tint hierarchy_number;\n\n\t\tif (line[0] == '#')\n\t\t\tcontinue;\n\t\tif (!line[0])\n\t\t\tcontinue;\n\n\t\ttab1 = strchr(line, '\\t');\n\t\tif (!tab1)\n\t\t\tcontinue;\n\t\t*tab1++ = '\\0';\n\t\ttab2 = strchr(tab1, '\\t');\n\t\tif (!tab2)\n\t\t\tcontinue;\n\t\t*tab2 = '\\0';\n\n\t\ttab2 = NULL;\n\t\thierarchy_number = strtoul(tab1, &tab2, 10);\n\t\tif (!tab2 || *tab2)\n\t\t\tcontinue;\n\t\t(void)hierarchy_number;\n\n\t\tr = lxc_grow_array((void ***)kernel_subsystems, &kernel_subsystems_capacity, kernel_subsystems_count + 1, 12);\n\t\tif (r < 0)\n\t\t\tgoto out;\n\t\t(*kernel_subsystems)[kernel_subsystems_count] = strdup(line);\n\t\tif (!(*kernel_subsystems)[kernel_subsystems_count])\n\t\t\tgoto out;\n\t\tkernel_subsystems_count++;\n\t}\n\tbret = true;\n\nout:\n\tfclose(proc_cgroups);\n\tfree(line);\n\treturn bret;\n}"
  },
  {
    "function_name": "lxc_cgroup_load_meta",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "241-263",
    "snippet": "static struct cgroup_meta_data *lxc_cgroup_load_meta()\n{\n\tconst char *cgroup_use = NULL;\n\tchar **cgroup_use_list = NULL;\n\tstruct cgroup_meta_data *md = NULL;\n\tint saved_errno;\n\n\terrno = 0;\n\tcgroup_use = lxc_global_config_value(\"lxc.cgroup.use\");\n\tif (!cgroup_use && errno != 0)\n\t\treturn NULL;\n\tif (cgroup_use) {\n\t\tcgroup_use_list = lxc_string_split_and_trim(cgroup_use, ',');\n\t\tif (!cgroup_use_list)\n\t\t\treturn NULL;\n\t}\n\n\tmd = lxc_cgroup_load_meta2((const char **)cgroup_use_list);\n\tsaved_errno = errno;\n\tlxc_free_array((void **)cgroup_use_list, free);\n\terrno = saved_errno;\n\treturn md;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_free_array",
          "args": [
            "(void **)cgroup_use_list",
            "free"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_free_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "886-892",
          "snippet": "void lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_load_meta2",
          "args": [
            "(const char **)cgroup_use_list"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_load_meta2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "573-627",
          "snippet": "static struct cgroup_meta_data *lxc_cgroup_load_meta2(const char **subsystem_whitelist)\n{\n\tbool all_kernel_subsystems = true;\n\tbool all_named_subsystems = false;\n\tstruct cgroup_meta_data *meta_data = NULL;\n\tchar **kernel_subsystems = NULL;\n\tint saved_errno = 0;\n\n\t/* if the subsystem whitelist is not specified, include all\n\t * hierarchies that contain kernel subsystems by default but\n\t * no hierarchies that only contain named subsystems\n\t *\n\t * if it is specified, the specifier @all will select all\n\t * hierarchies, @kernel will select all hierarchies with\n\t * kernel subsystems and @named will select all named\n\t * hierarchies\n\t */\n\tall_kernel_subsystems = subsystem_whitelist ?\n\t\t(lxc_string_in_array(\"@kernel\", subsystem_whitelist) || lxc_string_in_array(\"@all\", subsystem_whitelist)) :\n\t\ttrue;\n\tall_named_subsystems = subsystem_whitelist ?\n\t\t(lxc_string_in_array(\"@named\", subsystem_whitelist) || lxc_string_in_array(\"@all\", subsystem_whitelist)) :\n\t\ttrue;\n\n\tmeta_data = calloc(1, sizeof(struct cgroup_meta_data));\n\tif (!meta_data)\n\t\treturn NULL;\n\tmeta_data->ref = 1;\n\n\tif (!find_cgroup_subsystems(&kernel_subsystems))\n\t\tgoto out_error;\n\n\tif (!find_cgroup_hierarchies(meta_data, all_kernel_subsystems,\n\t\t\t\tall_named_subsystems, subsystem_whitelist))\n\t\tgoto out_error;\n\n\tif (!find_hierarchy_mountpts(meta_data, kernel_subsystems))\n\t\tgoto out_error;\n\n\t/* oops, we couldn't find anything */\n\tif (!meta_data->hierarchies || !meta_data->mount_points) {\n\t\terrno = EINVAL;\n\t\tgoto out_error;\n\t}\n\n\tlxc_free_array((void **)kernel_subsystems, free);\n\treturn meta_data;\n\nout_error:\n\tsaved_errno = errno;\n\tlxc_free_array((void **)kernel_subsystems, free);\n\tlxc_cgroup_put_meta(meta_data);\n\terrno = saved_errno;\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);",
            "static struct cgroup_meta_data *lxc_cgroup_load_meta2(const char **subsystem_whitelist);",
            "static struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);",
            "static struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_process_info *find_info_for_subsystem(struct cgroup_process_info *info, const char *subsystem);\nstatic struct cgroup_meta_data *lxc_cgroup_load_meta2(const char **subsystem_whitelist);\nstatic struct cgroup_meta_data *lxc_cgroup_get_meta(struct cgroup_meta_data *meta_data);\nstatic struct cgroup_meta_data *lxc_cgroup_put_meta(struct cgroup_meta_data *meta_data);\n\nstatic struct cgroup_meta_data *lxc_cgroup_load_meta2(const char **subsystem_whitelist)\n{\n\tbool all_kernel_subsystems = true;\n\tbool all_named_subsystems = false;\n\tstruct cgroup_meta_data *meta_data = NULL;\n\tchar **kernel_subsystems = NULL;\n\tint saved_errno = 0;\n\n\t/* if the subsystem whitelist is not specified, include all\n\t * hierarchies that contain kernel subsystems by default but\n\t * no hierarchies that only contain named subsystems\n\t *\n\t * if it is specified, the specifier @all will select all\n\t * hierarchies, @kernel will select all hierarchies with\n\t * kernel subsystems and @named will select all named\n\t * hierarchies\n\t */\n\tall_kernel_subsystems = subsystem_whitelist ?\n\t\t(lxc_string_in_array(\"@kernel\", subsystem_whitelist) || lxc_string_in_array(\"@all\", subsystem_whitelist)) :\n\t\ttrue;\n\tall_named_subsystems = subsystem_whitelist ?\n\t\t(lxc_string_in_array(\"@named\", subsystem_whitelist) || lxc_string_in_array(\"@all\", subsystem_whitelist)) :\n\t\ttrue;\n\n\tmeta_data = calloc(1, sizeof(struct cgroup_meta_data));\n\tif (!meta_data)\n\t\treturn NULL;\n\tmeta_data->ref = 1;\n\n\tif (!find_cgroup_subsystems(&kernel_subsystems))\n\t\tgoto out_error;\n\n\tif (!find_cgroup_hierarchies(meta_data, all_kernel_subsystems,\n\t\t\t\tall_named_subsystems, subsystem_whitelist))\n\t\tgoto out_error;\n\n\tif (!find_hierarchy_mountpts(meta_data, kernel_subsystems))\n\t\tgoto out_error;\n\n\t/* oops, we couldn't find anything */\n\tif (!meta_data->hierarchies || !meta_data->mount_points) {\n\t\terrno = EINVAL;\n\t\tgoto out_error;\n\t}\n\n\tlxc_free_array((void **)kernel_subsystems, free);\n\treturn meta_data;\n\nout_error:\n\tsaved_errno = errno;\n\tlxc_free_array((void **)kernel_subsystems, free);\n\tlxc_cgroup_put_meta(meta_data);\n\terrno = saved_errno;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_string_split_and_trim",
          "args": [
            "cgroup_use",
            "','"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_split_and_trim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "845-884",
          "snippet": "char **lxc_string_split_and_trim(const char *string, char _sep)\n{\n\tchar *token, *str, *saveptr = NULL;\n\tchar sep[2] = { _sep, '\\0' };\n\tchar **result = NULL;\n\tsize_t result_capacity = 0;\n\tsize_t result_count = 0;\n\tint r, saved_errno;\n\tsize_t i = 0;\n\n\tif (!string)\n\t\treturn calloc(1, sizeof(char *));\n\n\tstr = alloca(strlen(string)+1);\n\tstrcpy(str, string);\n\tfor (; (token = strtok_r(str, sep, &saveptr)); str = NULL) {\n\t\twhile (token[0] == ' ' || token[0] == '\\t')\n\t\t\ttoken++;\n\t\ti = strlen(token);\n\t\twhile (i > 0 && (token[i - 1] == ' ' || token[i - 1] == '\\t')) {\n\t\t\ttoken[i - 1] = '\\0';\n\t\t\ti--;\n\t\t}\n\t\tr = lxc_grow_array((void ***)&result, &result_capacity, result_count + 1, 16);\n\t\tif (r < 0)\n\t\t\tgoto error_out;\n\t\tresult[result_count] = strdup(token);\n\t\tif (!result[result_count])\n\t\t\tgoto error_out;\n\t\tresult_count++;\n\t}\n\n\t/* if we allocated too much, reduce it */\n\treturn realloc(result, (result_count + 1) * sizeof(char *));\nerror_out:\n\tsaved_errno = errno;\n\tlxc_free_array((void **)result, free);\n\terrno = saved_errno;\n\treturn NULL;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar **lxc_string_split_and_trim(const char *string, char _sep)\n{\n\tchar *token, *str, *saveptr = NULL;\n\tchar sep[2] = { _sep, '\\0' };\n\tchar **result = NULL;\n\tsize_t result_capacity = 0;\n\tsize_t result_count = 0;\n\tint r, saved_errno;\n\tsize_t i = 0;\n\n\tif (!string)\n\t\treturn calloc(1, sizeof(char *));\n\n\tstr = alloca(strlen(string)+1);\n\tstrcpy(str, string);\n\tfor (; (token = strtok_r(str, sep, &saveptr)); str = NULL) {\n\t\twhile (token[0] == ' ' || token[0] == '\\t')\n\t\t\ttoken++;\n\t\ti = strlen(token);\n\t\twhile (i > 0 && (token[i - 1] == ' ' || token[i - 1] == '\\t')) {\n\t\t\ttoken[i - 1] = '\\0';\n\t\t\ti--;\n\t\t}\n\t\tr = lxc_grow_array((void ***)&result, &result_capacity, result_count + 1, 16);\n\t\tif (r < 0)\n\t\t\tgoto error_out;\n\t\tresult[result_count] = strdup(token);\n\t\tif (!result[result_count])\n\t\t\tgoto error_out;\n\t\tresult_count++;\n\t}\n\n\t/* if we allocated too much, reduce it */\n\treturn realloc(result, (result_count + 1) * sizeof(char *));\nerror_out:\n\tsaved_errno = errno;\n\tlxc_free_array((void **)result, free);\n\terrno = saved_errno;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_global_config_value",
          "args": [
            "\"lxc.cgroup.use\""
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_global_config_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "88-247",
          "snippet": "const char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nconst char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct cgroup_meta_data *lxc_cgroup_load_meta()\n{\n\tconst char *cgroup_use = NULL;\n\tchar **cgroup_use_list = NULL;\n\tstruct cgroup_meta_data *md = NULL;\n\tint saved_errno;\n\n\terrno = 0;\n\tcgroup_use = lxc_global_config_value(\"lxc.cgroup.use\");\n\tif (!cgroup_use && errno != 0)\n\t\treturn NULL;\n\tif (cgroup_use) {\n\t\tcgroup_use_list = lxc_string_split_and_trim(cgroup_use, ',');\n\t\tif (!cgroup_use_list)\n\t\t\treturn NULL;\n\t}\n\n\tmd = lxc_cgroup_load_meta2((const char **)cgroup_use_list);\n\tsaved_errno = errno;\n\tlxc_free_array((void **)cgroup_use_list, free);\n\terrno = saved_errno;\n\treturn md;\n}"
  },
  {
    "function_name": "rmdir_wrapper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "227-239",
    "snippet": "static int rmdir_wrapper(void *data)\n{\n\tchar *path = data;\n\n\tif (setresgid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setgid to 0\");\n\tif (setresuid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setuid to 0\");\n\tif (setgroups(0, NULL) < 0)\n\t\tSYSERROR(\"Failed to clear groups\");\n\n\treturn cgroup_rmdir(path);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
      "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_rmdir",
          "args": [
            "path"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "158-225",
          "snippet": "static int cgroup_rmdir(char *dirname)\n{\n\tstruct dirent *direntp;\n\tint saved_errno = 0;\n\tDIR *dir;\n\tint ret, failed=0;\n\tchar pathname[MAXPATHLEN];\n\n\tdir = opendir(dirname);\n\tif (!dir) {\n\t\tERROR(\"%s: failed to open %s\", __func__, dirname);\n\t\treturn -1;\n\t}\n\n\twhile ((direntp = readdir(dir))) {\n\t\tstruct stat mystat;\n\t\tint rc;\n\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\") ||\n\t\t    !strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\trc = snprintf(pathname, MAXPATHLEN, \"%s/%s\", dirname, direntp->d_name);\n\t\tif (rc < 0 || rc >= MAXPATHLEN) {\n\t\t\tERROR(\"pathname too long\");\n\t\t\tfailed=1;\n\t\t\tif (!saved_errno)\n\t\t\t\tsaved_errno = -ENOMEM;\n\t\t\tcontinue;\n\t\t}\n\t\tret = lstat(pathname, &mystat);\n\t\tif (ret) {\n\t\t\tSYSERROR(\"%s: failed to stat %s\", __func__, pathname);\n\t\t\tfailed=1;\n\t\t\tif (!saved_errno)\n\t\t\t\tsaved_errno = errno;\n\t\t\tcontinue;\n\t\t}\n\t\tif (S_ISDIR(mystat.st_mode)) {\n\t\t\tif (cgroup_rmdir(pathname) < 0) {\n\t\t\t\tif (!saved_errno)\n\t\t\t\t\tsaved_errno = errno;\n\t\t\t\tfailed=1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rmdir(dirname) < 0) {\n\t\tSYSERROR(\"%s: failed to delete %s\", __func__, dirname);\n\t\tif (!saved_errno)\n\t\t\tsaved_errno = errno;\n\t\tfailed=1;\n\t}\n\n\tret = closedir(dir);\n\tif (ret) {\n\t\tSYSERROR(\"%s: failed to close directory %s\", __func__, dirname);\n\t\tif (!saved_errno)\n\t\t\tsaved_errno = errno;\n\t\tfailed=1;\n\t}\n\n\terrno = saved_errno;\n\treturn failed ? -1 : 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int cgroup_rmdir(char *dirname)\n{\n\tstruct dirent *direntp;\n\tint saved_errno = 0;\n\tDIR *dir;\n\tint ret, failed=0;\n\tchar pathname[MAXPATHLEN];\n\n\tdir = opendir(dirname);\n\tif (!dir) {\n\t\tERROR(\"%s: failed to open %s\", __func__, dirname);\n\t\treturn -1;\n\t}\n\n\twhile ((direntp = readdir(dir))) {\n\t\tstruct stat mystat;\n\t\tint rc;\n\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\") ||\n\t\t    !strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\trc = snprintf(pathname, MAXPATHLEN, \"%s/%s\", dirname, direntp->d_name);\n\t\tif (rc < 0 || rc >= MAXPATHLEN) {\n\t\t\tERROR(\"pathname too long\");\n\t\t\tfailed=1;\n\t\t\tif (!saved_errno)\n\t\t\t\tsaved_errno = -ENOMEM;\n\t\t\tcontinue;\n\t\t}\n\t\tret = lstat(pathname, &mystat);\n\t\tif (ret) {\n\t\t\tSYSERROR(\"%s: failed to stat %s\", __func__, pathname);\n\t\t\tfailed=1;\n\t\t\tif (!saved_errno)\n\t\t\t\tsaved_errno = errno;\n\t\t\tcontinue;\n\t\t}\n\t\tif (S_ISDIR(mystat.st_mode)) {\n\t\t\tif (cgroup_rmdir(pathname) < 0) {\n\t\t\t\tif (!saved_errno)\n\t\t\t\t\tsaved_errno = errno;\n\t\t\t\tfailed=1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rmdir(dirname) < 0) {\n\t\tSYSERROR(\"%s: failed to delete %s\", __func__, dirname);\n\t\tif (!saved_errno)\n\t\t\tsaved_errno = errno;\n\t\tfailed=1;\n\t}\n\n\tret = closedir(dir);\n\tif (ret) {\n\t\tSYSERROR(\"%s: failed to close directory %s\", __func__, dirname);\n\t\tif (!saved_errno)\n\t\t\tsaved_errno = errno;\n\t\tfailed=1;\n\t}\n\n\terrno = saved_errno;\n\treturn failed ? -1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to clear groups\""
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setgroups",
          "args": [
            "0",
            "NULL"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_setgroups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "2063-2072",
          "snippet": "int lxc_setgroups(int size, gid_t list[])\n{\n\tif (setgroups(size, list) < 0) {\n\t\tSYSERROR(\"Failed to setgroups().\");\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Dropped additional groups.\");\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_setgroups(int size, gid_t list[])\n{\n\tif (setgroups(size, list) < 0) {\n\t\tSYSERROR(\"Failed to setgroups().\");\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Dropped additional groups.\");\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to setuid to 0\""
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setresuid",
          "args": [
            "0",
            "0",
            "0"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to setgid to 0\""
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setresgid",
          "args": [
            "0",
            "0",
            "0"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\n\nstatic int rmdir_wrapper(void *data)\n{\n\tchar *path = data;\n\n\tif (setresgid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setgid to 0\");\n\tif (setresuid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setuid to 0\");\n\tif (setgroups(0, NULL) < 0)\n\t\tSYSERROR(\"Failed to clear groups\");\n\n\treturn cgroup_rmdir(path);\n}"
  },
  {
    "function_name": "cgroup_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
    "lines": "158-225",
    "snippet": "static int cgroup_rmdir(char *dirname)\n{\n\tstruct dirent *direntp;\n\tint saved_errno = 0;\n\tDIR *dir;\n\tint ret, failed=0;\n\tchar pathname[MAXPATHLEN];\n\n\tdir = opendir(dirname);\n\tif (!dir) {\n\t\tERROR(\"%s: failed to open %s\", __func__, dirname);\n\t\treturn -1;\n\t}\n\n\twhile ((direntp = readdir(dir))) {\n\t\tstruct stat mystat;\n\t\tint rc;\n\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\") ||\n\t\t    !strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\trc = snprintf(pathname, MAXPATHLEN, \"%s/%s\", dirname, direntp->d_name);\n\t\tif (rc < 0 || rc >= MAXPATHLEN) {\n\t\t\tERROR(\"pathname too long\");\n\t\t\tfailed=1;\n\t\t\tif (!saved_errno)\n\t\t\t\tsaved_errno = -ENOMEM;\n\t\t\tcontinue;\n\t\t}\n\t\tret = lstat(pathname, &mystat);\n\t\tif (ret) {\n\t\t\tSYSERROR(\"%s: failed to stat %s\", __func__, pathname);\n\t\t\tfailed=1;\n\t\t\tif (!saved_errno)\n\t\t\t\tsaved_errno = errno;\n\t\t\tcontinue;\n\t\t}\n\t\tif (S_ISDIR(mystat.st_mode)) {\n\t\t\tif (cgroup_rmdir(pathname) < 0) {\n\t\t\t\tif (!saved_errno)\n\t\t\t\t\tsaved_errno = errno;\n\t\t\t\tfailed=1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rmdir(dirname) < 0) {\n\t\tSYSERROR(\"%s: failed to delete %s\", __func__, dirname);\n\t\tif (!saved_errno)\n\t\t\tsaved_errno = errno;\n\t\tfailed=1;\n\t}\n\n\tret = closedir(dir);\n\tif (ret) {\n\t\tSYSERROR(\"%s: failed to close directory %s\", __func__, dirname);\n\t\tif (!saved_errno)\n\t\t\tsaved_errno = errno;\n\t\tfailed=1;\n\t}\n\n\terrno = saved_errno;\n\treturn failed ? -1 : 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"%s: failed to close directory %s\"",
            "__func__",
            "dirname"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dir"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"%s: failed to delete %s\"",
            "__func__",
            "dirname"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmdir",
          "args": [
            "dirname"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "rmdir_wrapper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "227-239",
          "snippet": "static int rmdir_wrapper(void *data)\n{\n\tchar *path = data;\n\n\tif (setresgid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setgid to 0\");\n\tif (setresuid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setuid to 0\");\n\tif (setgroups(0, NULL) < 0)\n\t\tSYSERROR(\"Failed to clear groups\");\n\n\treturn cgroup_rmdir(path);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int create_cgroup(struct cgroup_mount_point *mp, const char *path);",
            "static bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int create_cgroup(struct cgroup_mount_point *mp, const char *path);\nstatic bool init_cpuset_if_needed(struct cgroup_mount_point *mp, const char *path);\n\nstatic int rmdir_wrapper(void *data)\n{\n\tchar *path = data;\n\n\tif (setresgid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setgid to 0\");\n\tif (setresuid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setuid to 0\");\n\tif (setgroups(0, NULL) < 0)\n\t\tSYSERROR(\"Failed to clear groups\");\n\n\treturn cgroup_rmdir(path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_rmdir",
          "args": [
            "pathname"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "158-225",
          "snippet": "static int cgroup_rmdir(char *dirname)\n{\n\tstruct dirent *direntp;\n\tint saved_errno = 0;\n\tDIR *dir;\n\tint ret, failed=0;\n\tchar pathname[MAXPATHLEN];\n\n\tdir = opendir(dirname);\n\tif (!dir) {\n\t\tERROR(\"%s: failed to open %s\", __func__, dirname);\n\t\treturn -1;\n\t}\n\n\twhile ((direntp = readdir(dir))) {\n\t\tstruct stat mystat;\n\t\tint rc;\n\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\") ||\n\t\t    !strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\trc = snprintf(pathname, MAXPATHLEN, \"%s/%s\", dirname, direntp->d_name);\n\t\tif (rc < 0 || rc >= MAXPATHLEN) {\n\t\t\tERROR(\"pathname too long\");\n\t\t\tfailed=1;\n\t\t\tif (!saved_errno)\n\t\t\t\tsaved_errno = -ENOMEM;\n\t\t\tcontinue;\n\t\t}\n\t\tret = lstat(pathname, &mystat);\n\t\tif (ret) {\n\t\t\tSYSERROR(\"%s: failed to stat %s\", __func__, pathname);\n\t\t\tfailed=1;\n\t\t\tif (!saved_errno)\n\t\t\t\tsaved_errno = errno;\n\t\t\tcontinue;\n\t\t}\n\t\tif (S_ISDIR(mystat.st_mode)) {\n\t\t\tif (cgroup_rmdir(pathname) < 0) {\n\t\t\t\tif (!saved_errno)\n\t\t\t\t\tsaved_errno = errno;\n\t\t\t\tfailed=1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rmdir(dirname) < 0) {\n\t\tSYSERROR(\"%s: failed to delete %s\", __func__, dirname);\n\t\tif (!saved_errno)\n\t\t\tsaved_errno = errno;\n\t\tfailed=1;\n\t}\n\n\tret = closedir(dir);\n\tif (ret) {\n\t\tSYSERROR(\"%s: failed to close directory %s\", __func__, dirname);\n\t\tif (!saved_errno)\n\t\t\tsaved_errno = errno;\n\t\tfailed=1;\n\t}\n\n\terrno = saved_errno;\n\treturn failed ? -1 : 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mystat.st_mode"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"%s: failed to stat %s\"",
            "__func__",
            "pathname"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lstat",
          "args": [
            "pathname",
            "&mystat"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"pathname too long\""
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "pathname",
            "MAXPATHLEN",
            "\"%s/%s\"",
            "dirname",
            "direntp->d_name"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "direntp->d_name",
            "\"..\""
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "direntp->d_name",
            "\".\""
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "dir"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"%s: failed to open %s\"",
            "__func__",
            "dirname"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "dirname"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int cgroup_rmdir(char *dirname)\n{\n\tstruct dirent *direntp;\n\tint saved_errno = 0;\n\tDIR *dir;\n\tint ret, failed=0;\n\tchar pathname[MAXPATHLEN];\n\n\tdir = opendir(dirname);\n\tif (!dir) {\n\t\tERROR(\"%s: failed to open %s\", __func__, dirname);\n\t\treturn -1;\n\t}\n\n\twhile ((direntp = readdir(dir))) {\n\t\tstruct stat mystat;\n\t\tint rc;\n\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\") ||\n\t\t    !strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\trc = snprintf(pathname, MAXPATHLEN, \"%s/%s\", dirname, direntp->d_name);\n\t\tif (rc < 0 || rc >= MAXPATHLEN) {\n\t\t\tERROR(\"pathname too long\");\n\t\t\tfailed=1;\n\t\t\tif (!saved_errno)\n\t\t\t\tsaved_errno = -ENOMEM;\n\t\t\tcontinue;\n\t\t}\n\t\tret = lstat(pathname, &mystat);\n\t\tif (ret) {\n\t\t\tSYSERROR(\"%s: failed to stat %s\", __func__, pathname);\n\t\t\tfailed=1;\n\t\t\tif (!saved_errno)\n\t\t\t\tsaved_errno = errno;\n\t\t\tcontinue;\n\t\t}\n\t\tif (S_ISDIR(mystat.st_mode)) {\n\t\t\tif (cgroup_rmdir(pathname) < 0) {\n\t\t\t\tif (!saved_errno)\n\t\t\t\t\tsaved_errno = errno;\n\t\t\t\tfailed=1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rmdir(dirname) < 0) {\n\t\tSYSERROR(\"%s: failed to delete %s\", __func__, dirname);\n\t\tif (!saved_errno)\n\t\t\tsaved_errno = errno;\n\t\tfailed=1;\n\t}\n\n\tret = closedir(dir);\n\tif (ret) {\n\t\tSYSERROR(\"%s: failed to close directory %s\", __func__, dirname);\n\t\tif (!saved_errno)\n\t\t\tsaved_errno = errno;\n\t\tfailed=1;\n\t}\n\n\terrno = saved_errno;\n\treturn failed ? -1 : 0;\n}"
  }
]