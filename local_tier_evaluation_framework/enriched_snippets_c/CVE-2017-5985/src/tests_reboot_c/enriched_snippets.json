[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/reboot.c",
    "lines": "96-140",
    "snippet": "int main(int argc, char *argv[])\n{\n\tint status;\n\n\tif (getuid() != 0) {\n\t\tprintf(\"Must run as root.\\n\");\n\t\treturn 1;\n\t}\n\n\tstatus = have_reboot_patch();\n\tif (status != 0) {\n\t\tprintf(\"Your kernel does not have the container reboot patch\\n\");\n\t\treturn 1;\n\t}\n\n\tstatus = test_reboot(LINUX_REBOOT_CMD_CAD_ON, -1);\n\tif (status >= 0) {\n\t\tprintf(\"reboot(LINUX_REBOOT_CMD_CAD_ON) should have failed\\n\");\n\t\treturn 1;\n\t}\n\tprintf(\"reboot(LINUX_REBOOT_CMD_CAD_ON) has failed as expected\\n\");\n\n\tstatus = test_reboot(LINUX_REBOOT_CMD_RESTART, SIGHUP);\n\tif (status < 0)\n\t\treturn 1;\n\tprintf(\"reboot(LINUX_REBOOT_CMD_RESTART) succeed\\n\");\n\n\tstatus = test_reboot(LINUX_REBOOT_CMD_RESTART2, SIGHUP);\n\tif (status < 0)\n\t\treturn 1;\n\tprintf(\"reboot(LINUX_REBOOT_CMD_RESTART2) succeed\\n\");\n\n\tstatus = test_reboot(LINUX_REBOOT_CMD_HALT, SIGINT);\n\tif (status < 0)\n\t\treturn 1;\n\tprintf(\"reboot(LINUX_REBOOT_CMD_HALT) succeed\\n\");\n\n\tstatus = test_reboot(LINUX_REBOOT_CMD_POWER_OFF, SIGINT);\n\tif (status < 0)\n\t\treturn 1;\n\tprintf(\"reboot(LINUX_REBOOT_CMD_POWERR_OFF) succeed\\n\");\n\n\tprintf(\"All tests passed\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <linux/sched.h>",
      "#include <sched.h>",
      "#include \"lxc/namespace.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/reboot.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sched.h>",
      "#include <stdio.h>",
      "#include <alloca.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"All tests passed\\n\""
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"reboot(LINUX_REBOOT_CMD_POWERR_OFF) succeed\\n\""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_reboot",
          "args": [
            "LINUX_REBOOT_CMD_POWER_OFF",
            "SIGINT"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "test_reboot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/reboot.c",
          "lines": "45-75",
          "snippet": "static int test_reboot(int cmd, int sig)\n{\n\tlong stack_size = 4096;\n\tvoid *stack = alloca(stack_size) + stack_size;\n\tint status;\n\tpid_t ret;\n\n\tret = clone(do_reboot, stack, CLONE_NEWPID | SIGCHLD, &cmd);\n\tif (ret < 0) {\n\t\tprintf(\"failed to clone: %m\\n\");\n\t\treturn -1;\n\t}\n\n\tif (wait(&status) < 0) {\n\t\tprintf(\"unexpected wait error: %m\\n\");\n\t\treturn -1;\n\t}\n\n\tif (!WIFSIGNALED(status)) {\n\t\tif (sig != -1)\n\t\t\tprintf(\"child process exited but was not signaled\\n\");\n\t\treturn -1;\n\t}\n\n\tif (WTERMSIG(status) != sig) {\n\t\tprintf(\"signal termination is not the one expected\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/sched.h>",
            "#include <sched.h>",
            "#include \"lxc/namespace.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/reboot.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sched.h>",
            "#include <stdio.h>",
            "#include <alloca.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/sched.h>\n#include <sched.h>\n#include \"lxc/namespace.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/reboot.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sched.h>\n#include <stdio.h>\n#include <alloca.h>\n\nstatic int test_reboot(int cmd, int sig)\n{\n\tlong stack_size = 4096;\n\tvoid *stack = alloca(stack_size) + stack_size;\n\tint status;\n\tpid_t ret;\n\n\tret = clone(do_reboot, stack, CLONE_NEWPID | SIGCHLD, &cmd);\n\tif (ret < 0) {\n\t\tprintf(\"failed to clone: %m\\n\");\n\t\treturn -1;\n\t}\n\n\tif (wait(&status) < 0) {\n\t\tprintf(\"unexpected wait error: %m\\n\");\n\t\treturn -1;\n\t}\n\n\tif (!WIFSIGNALED(status)) {\n\t\tif (sig != -1)\n\t\t\tprintf(\"child process exited but was not signaled\\n\");\n\t\treturn -1;\n\t}\n\n\tif (WTERMSIG(status) != sig) {\n\t\tprintf(\"signal termination is not the one expected\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"reboot(LINUX_REBOOT_CMD_HALT) succeed\\n\""
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"reboot(LINUX_REBOOT_CMD_RESTART2) succeed\\n\""
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"reboot(LINUX_REBOOT_CMD_RESTART) succeed\\n\""
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"reboot(LINUX_REBOOT_CMD_CAD_ON) has failed as expected\\n\""
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"reboot(LINUX_REBOOT_CMD_CAD_ON) should have failed\\n\""
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Your kernel does not have the container reboot patch\\n\""
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "have_reboot_patch",
          "args": [],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "have_reboot_patch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/reboot.c",
          "lines": "77-94",
          "snippet": "static int have_reboot_patch(void)\n{\n\tFILE *f = fopen(\"/proc/sys/kernel/ctrl-alt-del\", \"r\");\n\tint ret;\n\tint v;\n\n\tif (!f)\n\t\treturn 0;\n\n\tret = fscanf(f, \"%d\", &v);\n\tfclose(f);\n\tif (ret != 1)\n\t\treturn 0;\n\tret = reboot(v ? LINUX_REBOOT_CMD_CAD_ON : LINUX_REBOOT_CMD_CAD_OFF);\n\tif (ret != -1)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/sched.h>",
            "#include <sched.h>",
            "#include \"lxc/namespace.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/reboot.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sched.h>",
            "#include <stdio.h>",
            "#include <alloca.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/sched.h>\n#include <sched.h>\n#include \"lxc/namespace.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/reboot.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sched.h>\n#include <stdio.h>\n#include <alloca.h>\n\nstatic int have_reboot_patch(void)\n{\n\tFILE *f = fopen(\"/proc/sys/kernel/ctrl-alt-del\", \"r\");\n\tint ret;\n\tint v;\n\n\tif (!f)\n\t\treturn 0;\n\n\tret = fscanf(f, \"%d\", &v);\n\tfclose(f);\n\tif (ret != 1)\n\t\treturn 0;\n\tret = reboot(v ? LINUX_REBOOT_CMD_CAD_ON : LINUX_REBOOT_CMD_CAD_OFF);\n\tif (ret != -1)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Must run as root.\\n\""
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/sched.h>\n#include <sched.h>\n#include \"lxc/namespace.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/reboot.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sched.h>\n#include <stdio.h>\n#include <alloca.h>\n\nint main(int argc, char *argv[])\n{\n\tint status;\n\n\tif (getuid() != 0) {\n\t\tprintf(\"Must run as root.\\n\");\n\t\treturn 1;\n\t}\n\n\tstatus = have_reboot_patch();\n\tif (status != 0) {\n\t\tprintf(\"Your kernel does not have the container reboot patch\\n\");\n\t\treturn 1;\n\t}\n\n\tstatus = test_reboot(LINUX_REBOOT_CMD_CAD_ON, -1);\n\tif (status >= 0) {\n\t\tprintf(\"reboot(LINUX_REBOOT_CMD_CAD_ON) should have failed\\n\");\n\t\treturn 1;\n\t}\n\tprintf(\"reboot(LINUX_REBOOT_CMD_CAD_ON) has failed as expected\\n\");\n\n\tstatus = test_reboot(LINUX_REBOOT_CMD_RESTART, SIGHUP);\n\tif (status < 0)\n\t\treturn 1;\n\tprintf(\"reboot(LINUX_REBOOT_CMD_RESTART) succeed\\n\");\n\n\tstatus = test_reboot(LINUX_REBOOT_CMD_RESTART2, SIGHUP);\n\tif (status < 0)\n\t\treturn 1;\n\tprintf(\"reboot(LINUX_REBOOT_CMD_RESTART2) succeed\\n\");\n\n\tstatus = test_reboot(LINUX_REBOOT_CMD_HALT, SIGINT);\n\tif (status < 0)\n\t\treturn 1;\n\tprintf(\"reboot(LINUX_REBOOT_CMD_HALT) succeed\\n\");\n\n\tstatus = test_reboot(LINUX_REBOOT_CMD_POWER_OFF, SIGINT);\n\tif (status < 0)\n\t\treturn 1;\n\tprintf(\"reboot(LINUX_REBOOT_CMD_POWERR_OFF) succeed\\n\");\n\n\tprintf(\"All tests passed\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "have_reboot_patch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/reboot.c",
    "lines": "77-94",
    "snippet": "static int have_reboot_patch(void)\n{\n\tFILE *f = fopen(\"/proc/sys/kernel/ctrl-alt-del\", \"r\");\n\tint ret;\n\tint v;\n\n\tif (!f)\n\t\treturn 0;\n\n\tret = fscanf(f, \"%d\", &v);\n\tfclose(f);\n\tif (ret != 1)\n\t\treturn 0;\n\tret = reboot(v ? LINUX_REBOOT_CMD_CAD_ON : LINUX_REBOOT_CMD_CAD_OFF);\n\tif (ret != -1)\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <linux/sched.h>",
      "#include <sched.h>",
      "#include \"lxc/namespace.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/reboot.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sched.h>",
      "#include <stdio.h>",
      "#include <alloca.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reboot",
          "args": [
            "v ? LINUX_REBOOT_CMD_CAD_ON : LINUX_REBOOT_CMD_CAD_OFF"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "do_reboot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/reboot.c",
          "lines": "36-43",
          "snippet": "static int do_reboot(void *arg)\n{\n\tint *cmd = arg;\n\n\tif (reboot(*cmd))\n\t\tprintf(\"failed to reboot(%d): %m\\n\", *cmd);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/sched.h>",
            "#include <sched.h>",
            "#include \"lxc/namespace.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/reboot.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sched.h>",
            "#include <stdio.h>",
            "#include <alloca.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int clone(int (*fn)(void *), void *child_stack, int flags, void *arg, ...);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/sched.h>\n#include <sched.h>\n#include \"lxc/namespace.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/reboot.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sched.h>\n#include <stdio.h>\n#include <alloca.h>\n\nint clone(int (*fn)(void *), void *child_stack, int flags, void *arg, ...);\n\nstatic int do_reboot(void *arg)\n{\n\tint *cmd = arg;\n\n\tif (reboot(*cmd))\n\t\tprintf(\"failed to reboot(%d): %m\\n\", *cmd);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "f",
            "\"%d\"",
            "&v"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "\"/proc/sys/kernel/ctrl-alt-del\"",
            "\"r\""
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/sched.h>\n#include <sched.h>\n#include \"lxc/namespace.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/reboot.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sched.h>\n#include <stdio.h>\n#include <alloca.h>\n\nstatic int have_reboot_patch(void)\n{\n\tFILE *f = fopen(\"/proc/sys/kernel/ctrl-alt-del\", \"r\");\n\tint ret;\n\tint v;\n\n\tif (!f)\n\t\treturn 0;\n\n\tret = fscanf(f, \"%d\", &v);\n\tfclose(f);\n\tif (ret != 1)\n\t\treturn 0;\n\tret = reboot(v ? LINUX_REBOOT_CMD_CAD_ON : LINUX_REBOOT_CMD_CAD_OFF);\n\tif (ret != -1)\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "test_reboot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/reboot.c",
    "lines": "45-75",
    "snippet": "static int test_reboot(int cmd, int sig)\n{\n\tlong stack_size = 4096;\n\tvoid *stack = alloca(stack_size) + stack_size;\n\tint status;\n\tpid_t ret;\n\n\tret = clone(do_reboot, stack, CLONE_NEWPID | SIGCHLD, &cmd);\n\tif (ret < 0) {\n\t\tprintf(\"failed to clone: %m\\n\");\n\t\treturn -1;\n\t}\n\n\tif (wait(&status) < 0) {\n\t\tprintf(\"unexpected wait error: %m\\n\");\n\t\treturn -1;\n\t}\n\n\tif (!WIFSIGNALED(status)) {\n\t\tif (sig != -1)\n\t\t\tprintf(\"child process exited but was not signaled\\n\");\n\t\treturn -1;\n\t}\n\n\tif (WTERMSIG(status) != sig) {\n\t\tprintf(\"signal termination is not the one expected\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <linux/sched.h>",
      "#include <sched.h>",
      "#include \"lxc/namespace.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/reboot.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sched.h>",
      "#include <stdio.h>",
      "#include <alloca.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"signal termination is not the one expected\\n\""
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WTERMSIG",
          "args": [
            "status"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"child process exited but was not signaled\\n\""
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFSIGNALED",
          "args": [
            "status"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"unexpected wait error: %m\\n\""
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait",
          "args": [
            "&status"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "67-81",
          "snippet": "static int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"failed to clone: %m\\n\""
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clone",
          "args": [
            "do_reboot",
            "stack",
            "CLONE_NEWPID | SIGCHLD",
            "&cmd"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "do_clone_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "517-537",
          "snippet": "static int do_clone_task(struct lxc_container *c, enum task task, int flags,\n\t\t\t char **args)\n{\n\tint ret = 0;\n\n\tswitch (task) {\n\tcase DESTROY:\n\t\tret = do_clone_ephemeral(c, &my_args, args, flags);\n\t\tbreak;\n\tcase RENAME:\n\t\tret = do_clone_rename(c, my_args.newname);\n\t\tbreak;\n\tdefault:\n\t\tret = do_clone(c, my_args.newname, my_args.newpath, flags,\n\t\t\t       my_args.bdevtype, my_args.fssize, my_args.task,\n\t\t\t       args);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lxc_arguments my_args = {\n\t.progname = \"lxc-copy\",\n\t.help = \"\\n\\\n--name=NAME [-P lxcpath] -N newname [-p newpath] [-B backingstorage] [-s] [-K] [-M] [-L size [unit]] -- hook options\\n\\\n--name=NAME [-P lxcpath] [-N newname] [-p newpath] [-B backingstorage] -e [-d] [-D] [-K] [-M] [-m {bind,aufs,overlay}=/src:/dest] -- hook options\\n\\\n--name=NAME [-P lxcpath] -N newname -R\\n\\\n\\n\\\nlxc-copy clone a container\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME           NAME of the container\\n\\\n  -N, --newname=NEWNAME     NEWNAME for the restored container\\n\\\n  -p, --newpath=NEWPATH     NEWPATH for the container to be stored\\n\\\n  -R, --rename              rename container\\n\\\n  -s, --snapshot            create snapshot instead of clone\\n\\\n  -F, --foreground          start with current tty attached to /dev/console\\n\\\n  -d, --daemon              daemonize the container (default)\\n\\\n  -e, --ephemeral           start ephemeral container\\n\\\n  -m, --mount               directory to mount into container, either \\n\\\n                            {bind,aufs,overlay}=/src-path or {bind,aufs,overlay}=/src-path:/dst-path\\n\\\n  -B, --backingstorage=TYPE backingstorage type for the container\\n\\\n  -t, --tmpfs               place ephemeral container on a tmpfs\\n\\\n                            (WARNING: On reboot all changes made to the container will be lost.)\\n\\\n  -L, --fssize              size of the new block device for block device containers\\n\\\n  -D, --keedata             pass together with -e start a persistent snapshot \\n\\\n  -K, --keepname            keep the hostname of the original container\\n\\\n  --  hook options          arguments passed to the hook program\\n\\\n  -M, --keepmac             keep the MAC address of the original container\\n\\\n  --rcfile=FILE             Load configuration file FILE\\n\",\n\t.options = my_longopts,\n\t.parser = my_parser,\n\t.task = CLONE,\n\t.daemonize = 1,\n\t.quiet = false,\n\t.tmpfs = false,\n};",
            "static int do_clone(struct lxc_container *c, char *newname, char *newpath,\n\t\t    int flags, char *bdevtype, uint64_t fssize, enum task task,\n\t\t    char **args);",
            "static int do_clone_ephemeral(struct lxc_container *c,\n\t\t\t      struct lxc_arguments *arg, char **args,\n\t\t\t      int flags);",
            "static int do_clone_rename(struct lxc_container *c, char *newname);",
            "static int do_clone_task(struct lxc_container *c, enum task task, int flags,\n\t\t\t char **args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic struct lxc_arguments my_args = {\n\t.progname = \"lxc-copy\",\n\t.help = \"\\n\\\n--name=NAME [-P lxcpath] -N newname [-p newpath] [-B backingstorage] [-s] [-K] [-M] [-L size [unit]] -- hook options\\n\\\n--name=NAME [-P lxcpath] [-N newname] [-p newpath] [-B backingstorage] -e [-d] [-D] [-K] [-M] [-m {bind,aufs,overlay}=/src:/dest] -- hook options\\n\\\n--name=NAME [-P lxcpath] -N newname -R\\n\\\n\\n\\\nlxc-copy clone a container\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME           NAME of the container\\n\\\n  -N, --newname=NEWNAME     NEWNAME for the restored container\\n\\\n  -p, --newpath=NEWPATH     NEWPATH for the container to be stored\\n\\\n  -R, --rename              rename container\\n\\\n  -s, --snapshot            create snapshot instead of clone\\n\\\n  -F, --foreground          start with current tty attached to /dev/console\\n\\\n  -d, --daemon              daemonize the container (default)\\n\\\n  -e, --ephemeral           start ephemeral container\\n\\\n  -m, --mount               directory to mount into container, either \\n\\\n                            {bind,aufs,overlay}=/src-path or {bind,aufs,overlay}=/src-path:/dst-path\\n\\\n  -B, --backingstorage=TYPE backingstorage type for the container\\n\\\n  -t, --tmpfs               place ephemeral container on a tmpfs\\n\\\n                            (WARNING: On reboot all changes made to the container will be lost.)\\n\\\n  -L, --fssize              size of the new block device for block device containers\\n\\\n  -D, --keedata             pass together with -e start a persistent snapshot \\n\\\n  -K, --keepname            keep the hostname of the original container\\n\\\n  --  hook options          arguments passed to the hook program\\n\\\n  -M, --keepmac             keep the MAC address of the original container\\n\\\n  --rcfile=FILE             Load configuration file FILE\\n\",\n\t.options = my_longopts,\n\t.parser = my_parser,\n\t.task = CLONE,\n\t.daemonize = 1,\n\t.quiet = false,\n\t.tmpfs = false,\n};\nstatic int do_clone(struct lxc_container *c, char *newname, char *newpath,\n\t\t    int flags, char *bdevtype, uint64_t fssize, enum task task,\n\t\t    char **args);\nstatic int do_clone_ephemeral(struct lxc_container *c,\n\t\t\t      struct lxc_arguments *arg, char **args,\n\t\t\t      int flags);\nstatic int do_clone_rename(struct lxc_container *c, char *newname);\nstatic int do_clone_task(struct lxc_container *c, enum task task, int flags,\n\t\t\t char **args);\n\nstatic int do_clone_task(struct lxc_container *c, enum task task, int flags,\n\t\t\t char **args)\n{\n\tint ret = 0;\n\n\tswitch (task) {\n\tcase DESTROY:\n\t\tret = do_clone_ephemeral(c, &my_args, args, flags);\n\t\tbreak;\n\tcase RENAME:\n\t\tret = do_clone_rename(c, my_args.newname);\n\t\tbreak;\n\tdefault:\n\t\tret = do_clone(c, my_args.newname, my_args.newpath, flags,\n\t\t\t       my_args.bdevtype, my_args.fssize, my_args.task,\n\t\t\t       args);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "stack_size"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/sched.h>\n#include <sched.h>\n#include \"lxc/namespace.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/reboot.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sched.h>\n#include <stdio.h>\n#include <alloca.h>\n\nstatic int test_reboot(int cmd, int sig)\n{\n\tlong stack_size = 4096;\n\tvoid *stack = alloca(stack_size) + stack_size;\n\tint status;\n\tpid_t ret;\n\n\tret = clone(do_reboot, stack, CLONE_NEWPID | SIGCHLD, &cmd);\n\tif (ret < 0) {\n\t\tprintf(\"failed to clone: %m\\n\");\n\t\treturn -1;\n\t}\n\n\tif (wait(&status) < 0) {\n\t\tprintf(\"unexpected wait error: %m\\n\");\n\t\treturn -1;\n\t}\n\n\tif (!WIFSIGNALED(status)) {\n\t\tif (sig != -1)\n\t\t\tprintf(\"child process exited but was not signaled\\n\");\n\t\treturn -1;\n\t}\n\n\tif (WTERMSIG(status) != sig) {\n\t\tprintf(\"signal termination is not the one expected\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "do_reboot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/reboot.c",
    "lines": "36-43",
    "snippet": "static int do_reboot(void *arg)\n{\n\tint *cmd = arg;\n\n\tif (reboot(*cmd))\n\t\tprintf(\"failed to reboot(%d): %m\\n\", *cmd);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <linux/sched.h>",
      "#include <sched.h>",
      "#include \"lxc/namespace.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/reboot.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sched.h>",
      "#include <stdio.h>",
      "#include <alloca.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int clone(int (*fn)(void *), void *child_stack, int flags, void *arg, ...);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"failed to reboot(%d): %m\\n\"",
            "*cmd"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reboot",
          "args": [
            "*cmd"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "do_reboot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/reboot.c",
          "lines": "36-43",
          "snippet": "static int do_reboot(void *arg)\n{\n\tint *cmd = arg;\n\n\tif (reboot(*cmd))\n\t\tprintf(\"failed to reboot(%d): %m\\n\", *cmd);\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/sched.h>\n#include <sched.h>\n#include \"lxc/namespace.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/reboot.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sched.h>\n#include <stdio.h>\n#include <alloca.h>\n\nint clone(int (*fn)(void *), void *child_stack, int flags, void *arg, ...);\n\nstatic int do_reboot(void *arg)\n{\n\tint *cmd = arg;\n\n\tif (reboot(*cmd))\n\t\tprintf(\"failed to reboot(%d): %m\\n\", *cmd);\n\treturn 0;\n}"
  }
]