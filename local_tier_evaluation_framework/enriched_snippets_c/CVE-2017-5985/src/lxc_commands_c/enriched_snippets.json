[
  {
    "function_name": "lxc_cmd_mainloop_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
    "lines": "1008-1021",
    "snippet": "int lxc_cmd_mainloop_add(const char *name,\n\t\t\t struct lxc_epoll_descr *descr,\n\t\t\t struct lxc_handler *handler)\n{\n\tint ret, fd = handler->conf->maincmd_fd;\n\n\tret = lxc_mainloop_add_handler(descr, fd, lxc_cmd_accept, handler);\n\tif (ret) {\n\t\tERROR(\"Failed to add handler for command socket.\");\n\t\tclose(fd);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"af_unix.h\"",
      "#include \"mainloop.h\"",
      "#include \"confile.h\"",
      "#include \"console.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"utils.h\"",
      "#include \"start.h\"\t/* for struct lxc_handler */",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/un.h>",
      "#include <inttypes.h>",
      "#include <sys/socket.h>",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to add handler for command socket.\""
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_mainloop_add_handler",
          "args": [
            "descr",
            "fd",
            "lxc_cmd_accept",
            "handler"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_mainloop_add_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/mainloop.c",
          "lines": "75-107",
          "snippet": "int lxc_mainloop_add_handler(struct lxc_epoll_descr *descr, int fd,\n\t\t\t     lxc_mainloop_callback_t callback, void *data)\n{\n\tstruct epoll_event ev;\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *item;\n\n\thandler = malloc(sizeof(*handler));\n\tif (!handler)\n\t\treturn -1;\n\n\thandler->callback = callback;\n\thandler->fd = fd;\n\thandler->data = data;\n\n\tev.events = EPOLLIN;\n\tev.data.ptr = handler;\n\n\tif (epoll_ctl(descr->epfd, EPOLL_CTL_ADD, fd, &ev) < 0)\n\t\tgoto out_free_handler;\n\n\titem = malloc(sizeof(*item));\n\tif (!item)\n\t\tgoto out_free_handler;\n\n\titem->elem = handler;\n\tlxc_list_add(&descr->handlers, item);\n\treturn 0;\n\nout_free_handler:\n\tfree(handler);\n\treturn -1;\n}",
          "includes": [
            "#include \"mainloop.h\"",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mainloop.h\"\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint lxc_mainloop_add_handler(struct lxc_epoll_descr *descr, int fd,\n\t\t\t     lxc_mainloop_callback_t callback, void *data)\n{\n\tstruct epoll_event ev;\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *item;\n\n\thandler = malloc(sizeof(*handler));\n\tif (!handler)\n\t\treturn -1;\n\n\thandler->callback = callback;\n\thandler->fd = fd;\n\thandler->data = data;\n\n\tev.events = EPOLLIN;\n\tev.data.ptr = handler;\n\n\tif (epoll_ctl(descr->epfd, EPOLL_CTL_ADD, fd, &ev) < 0)\n\t\tgoto out_free_handler;\n\n\titem = malloc(sizeof(*item));\n\tif (!item)\n\t\tgoto out_free_handler;\n\n\titem->elem = handler;\n\tlxc_list_add(&descr->handlers, item);\n\treturn 0;\n\nout_free_handler:\n\tfree(handler);\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nint lxc_cmd_mainloop_add(const char *name,\n\t\t\t struct lxc_epoll_descr *descr,\n\t\t\t struct lxc_handler *handler)\n{\n\tint ret, fd = handler->conf->maincmd_fd;\n\n\tret = lxc_mainloop_add_handler(descr, fd, lxc_cmd_accept, handler);\n\tif (ret) {\n\t\tERROR(\"Failed to add handler for command socket.\");\n\t\tclose(fd);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "lxc_cmd_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
    "lines": "972-1006",
    "snippet": "int lxc_cmd_init(const char *name, struct lxc_handler *handler,\n\t\t const char *lxcpath)\n{\n\tint fd;\n\tchar path[sizeof(((struct sockaddr_un *)0)->sun_path)] = { 0 };\n\tchar *offset = &path[1];\n\tint len;\n\n\t/* -2 here because this is an abstract unix socket so it needs a\n\t * leading \\0, and we null terminate, so it needs a trailing \\0.\n\t * Although null termination isn't required by the API, we do it anyway\n\t * because we print the sockname out sometimes.\n\t */\n\tlen = sizeof(path)-2;\n\tif (fill_sock_name(offset, len, name, lxcpath, NULL))\n\t\treturn -1;\n\n\tfd = lxc_abstract_unix_open(path, SOCK_STREAM, 0);\n\tif (fd < 0) {\n\t\tERROR(\"Failed to create the command service point %s: %s.\",\n\t\t      offset, strerror(errno));\n\t\tif (errno == EADDRINUSE)\n\t\t\tERROR(\"Container \\\"%s\\\" appears to be already running!\", name);\n\t\treturn -1;\n\t}\n\n\tif (fcntl(fd, F_SETFD, FD_CLOEXEC)) {\n\t\tSYSERROR(\"Failed to set FD_CLOEXEC on signal file descriptor.\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\thandler->conf->maincmd_fd = fd;\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"af_unix.h\"",
      "#include \"mainloop.h\"",
      "#include \"confile.h\"",
      "#include \"console.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"utils.h\"",
      "#include \"start.h\"\t/* for struct lxc_handler */",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/un.h>",
      "#include <inttypes.h>",
      "#include <sys/socket.h>",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to set FD_CLOEXEC on signal file descriptor.\""
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "fd",
            "F_SETFD",
            "FD_CLOEXEC"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Container \\\"%s\\\" appears to be already running!\"",
            "name"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to create the command service point %s: %s.\"",
            "offset",
            "strerror(errno)"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_abstract_unix_open",
          "args": [
            "path",
            "SOCK_STREAM",
            "0"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "37-82",
          "snippet": "int lxc_abstract_unix_open(const char *path, int type, int flags)\n{\n\tint fd;\n\tsize_t len;\n\tstruct sockaddr_un addr;\n\n\tif (flags & O_TRUNC)\n\t\tunlink(path);\n\n\tfd = socket(PF_UNIX, type, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\n\t/* Clear address structure */\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (!path)\n\t\treturn fd;\n\n\taddr.sun_family = AF_UNIX;\n\n\tlen = strlen(&path[1]) + 1;\n\tif (len >= sizeof(addr.sun_path) - 1) {\n\t\tclose(fd);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\t/* addr.sun_path[0] has already been set to 0 by memset() */\n\tstrncpy(&addr.sun_path[1], &path[1], strlen(&path[1]));\n\n\tif (bind(fd, (struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path) + len)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\tif (type == SOCK_STREAM && listen(fd, 100)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_open(const char *path, int type, int flags)\n{\n\tint fd;\n\tsize_t len;\n\tstruct sockaddr_un addr;\n\n\tif (flags & O_TRUNC)\n\t\tunlink(path);\n\n\tfd = socket(PF_UNIX, type, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\n\t/* Clear address structure */\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (!path)\n\t\treturn fd;\n\n\taddr.sun_family = AF_UNIX;\n\n\tlen = strlen(&path[1]) + 1;\n\tif (len >= sizeof(addr.sun_path) - 1) {\n\t\tclose(fd);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\t/* addr.sun_path[0] has already been set to 0 by memset() */\n\tstrncpy(&addr.sun_path[1], &path[1], strlen(&path[1]));\n\n\tif (bind(fd, (struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path) + len)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\tif (type == SOCK_STREAM && listen(fd, 100)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_sock_name",
          "args": [
            "offset",
            "len",
            "name",
            "lxcpath",
            "NULL"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "fill_sock_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "77-126",
          "snippet": "static int fill_sock_name(char *path, int len, const char *name,\n\t\t\t  const char *lxcpath, const char *hashed_sock_name)\n{\n\tchar *tmppath;\n\tsize_t tmplen;\n\tuint64_t hash;\n\tint ret;\n\n\tif (hashed_sock_name != NULL) {\n\t\tret = snprintf(path, len, \"lxc/%s/command\", hashed_sock_name);\n\t\tif (ret < 0 || ret >= len) {\n\t\t\tERROR(\"Error writing to command sock path\");\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (!lxcpath) {\n\t\tlxcpath = lxc_global_config_value(\"lxc.lxcpath\");\n\t\tif (!lxcpath) {\n\t\t\tERROR(\"Out of memory getting lxcpath\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tret = snprintf(path, len, \"%s/%s/command\", lxcpath, name);\n\tif (ret < 0) {\n\t\tERROR(\"Error writing to command sock path\");\n\t\treturn -1;\n\t}\n\tif (ret < len)\n\t\treturn 0;\n\n\t/* ret >= len; lxcpath or name is too long.  hash both */\n\ttmplen = strlen(name) + strlen(lxcpath) + 2;\n\ttmppath = alloca(tmplen);\n\tret = snprintf(tmppath, tmplen, \"%s/%s\", lxcpath, name);\n\tif (ret < 0 || ret >= tmplen) {\n\t\tERROR(\"memory error\");\n\t\treturn -1;\n\t}\n\thash = fnv_64a_buf(tmppath, ret, FNV1A_64_INIT);\n\tret = snprintf(path, len, \"lxc/%016\" PRIx64 \"/command\", hash);\n\tif (ret < 0 || ret >= len) {\n\t\tERROR(\"Command socket name too long\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int fill_sock_name(char *path, int len, const char *name,\n\t\t\t  const char *lxcpath, const char *hashed_sock_name)\n{\n\tchar *tmppath;\n\tsize_t tmplen;\n\tuint64_t hash;\n\tint ret;\n\n\tif (hashed_sock_name != NULL) {\n\t\tret = snprintf(path, len, \"lxc/%s/command\", hashed_sock_name);\n\t\tif (ret < 0 || ret >= len) {\n\t\t\tERROR(\"Error writing to command sock path\");\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (!lxcpath) {\n\t\tlxcpath = lxc_global_config_value(\"lxc.lxcpath\");\n\t\tif (!lxcpath) {\n\t\t\tERROR(\"Out of memory getting lxcpath\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tret = snprintf(path, len, \"%s/%s/command\", lxcpath, name);\n\tif (ret < 0) {\n\t\tERROR(\"Error writing to command sock path\");\n\t\treturn -1;\n\t}\n\tif (ret < len)\n\t\treturn 0;\n\n\t/* ret >= len; lxcpath or name is too long.  hash both */\n\ttmplen = strlen(name) + strlen(lxcpath) + 2;\n\ttmppath = alloca(tmplen);\n\tret = snprintf(tmppath, tmplen, \"%s/%s\", lxcpath, name);\n\tif (ret < 0 || ret >= tmplen) {\n\t\tERROR(\"memory error\");\n\t\treturn -1;\n\t}\n\thash = fnv_64a_buf(tmppath, ret, FNV1A_64_INIT);\n\tret = snprintf(path, len, \"lxc/%016\" PRIx64 \"/command\", hash);\n\tif (ret < 0 || ret >= len) {\n\t\tERROR(\"Command socket name too long\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nint lxc_cmd_init(const char *name, struct lxc_handler *handler,\n\t\t const char *lxcpath)\n{\n\tint fd;\n\tchar path[sizeof(((struct sockaddr_un *)0)->sun_path)] = { 0 };\n\tchar *offset = &path[1];\n\tint len;\n\n\t/* -2 here because this is an abstract unix socket so it needs a\n\t * leading \\0, and we null terminate, so it needs a trailing \\0.\n\t * Although null termination isn't required by the API, we do it anyway\n\t * because we print the sockname out sometimes.\n\t */\n\tlen = sizeof(path)-2;\n\tif (fill_sock_name(offset, len, name, lxcpath, NULL))\n\t\treturn -1;\n\n\tfd = lxc_abstract_unix_open(path, SOCK_STREAM, 0);\n\tif (fd < 0) {\n\t\tERROR(\"Failed to create the command service point %s: %s.\",\n\t\t      offset, strerror(errno));\n\t\tif (errno == EADDRINUSE)\n\t\t\tERROR(\"Container \\\"%s\\\" appears to be already running!\", name);\n\t\treturn -1;\n\t}\n\n\tif (fcntl(fd, F_SETFD, FD_CLOEXEC)) {\n\t\tSYSERROR(\"Failed to set FD_CLOEXEC on signal file descriptor.\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\thandler->conf->maincmd_fd = fd;\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_cmd_accept",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
    "lines": "936-970",
    "snippet": "static int lxc_cmd_accept(int fd, uint32_t events, void *data,\n\t\t\t  struct lxc_epoll_descr *descr)\n{\n\tint opt = 1, ret = -1, connection;\n\n\tconnection = accept(fd, NULL, 0);\n\tif (connection < 0) {\n\t\tSYSERROR(\"Failed to accept connection to run command.\");\n\t\treturn -1;\n\t}\n\n\tif (fcntl(connection, F_SETFD, FD_CLOEXEC)) {\n\t\tSYSERROR(\"Failed to set close-on-exec on incoming command connection.\");\n\t\tgoto out_close;\n\t}\n\n\tif (setsockopt(connection, SOL_SOCKET,\n\t\t       SO_PASSCRED, &opt, sizeof(opt))) {\n\t\tSYSERROR(\"Failed to enable necessary credentials on command socket.\");\n\t\tgoto out_close;\n\t}\n\n\tret = lxc_mainloop_add_handler(descr, connection, lxc_cmd_handler, data);\n\tif (ret) {\n\t\tERROR(\"Failed to add command handler.\");\n\t\tgoto out_close;\n\t}\n\nout:\n\treturn ret;\n\nout_close:\n\tclose(connection);\n\tgoto out;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"af_unix.h\"",
      "#include \"mainloop.h\"",
      "#include \"confile.h\"",
      "#include \"console.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"utils.h\"",
      "#include \"start.h\"\t/* for struct lxc_handler */",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/un.h>",
      "#include <inttypes.h>",
      "#include <sys/socket.h>",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "connection"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to add command handler.\""
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_mainloop_add_handler",
          "args": [
            "descr",
            "connection",
            "lxc_cmd_handler",
            "data"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_mainloop_add_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/mainloop.c",
          "lines": "75-107",
          "snippet": "int lxc_mainloop_add_handler(struct lxc_epoll_descr *descr, int fd,\n\t\t\t     lxc_mainloop_callback_t callback, void *data)\n{\n\tstruct epoll_event ev;\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *item;\n\n\thandler = malloc(sizeof(*handler));\n\tif (!handler)\n\t\treturn -1;\n\n\thandler->callback = callback;\n\thandler->fd = fd;\n\thandler->data = data;\n\n\tev.events = EPOLLIN;\n\tev.data.ptr = handler;\n\n\tif (epoll_ctl(descr->epfd, EPOLL_CTL_ADD, fd, &ev) < 0)\n\t\tgoto out_free_handler;\n\n\titem = malloc(sizeof(*item));\n\tif (!item)\n\t\tgoto out_free_handler;\n\n\titem->elem = handler;\n\tlxc_list_add(&descr->handlers, item);\n\treturn 0;\n\nout_free_handler:\n\tfree(handler);\n\treturn -1;\n}",
          "includes": [
            "#include \"mainloop.h\"",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mainloop.h\"\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint lxc_mainloop_add_handler(struct lxc_epoll_descr *descr, int fd,\n\t\t\t     lxc_mainloop_callback_t callback, void *data)\n{\n\tstruct epoll_event ev;\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *item;\n\n\thandler = malloc(sizeof(*handler));\n\tif (!handler)\n\t\treturn -1;\n\n\thandler->callback = callback;\n\thandler->fd = fd;\n\thandler->data = data;\n\n\tev.events = EPOLLIN;\n\tev.data.ptr = handler;\n\n\tif (epoll_ctl(descr->epfd, EPOLL_CTL_ADD, fd, &ev) < 0)\n\t\tgoto out_free_handler;\n\n\titem = malloc(sizeof(*item));\n\tif (!item)\n\t\tgoto out_free_handler;\n\n\titem->elem = handler;\n\tlxc_list_add(&descr->handlers, item);\n\treturn 0;\n\nout_free_handler:\n\tfree(handler);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to enable necessary credentials on command socket.\""
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "connection",
            "SOL_SOCKET",
            "SO_PASSCRED",
            "&opt",
            "sizeof(opt)"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to set close-on-exec on incoming command connection.\""
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "connection",
            "F_SETFD",
            "FD_CLOEXEC"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to accept connection to run command.\""
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "accept",
          "args": [
            "fd",
            "NULL",
            "0"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd_accept(int fd, uint32_t events, void *data,\n\t\t\t  struct lxc_epoll_descr *descr)\n{\n\tint opt = 1, ret = -1, connection;\n\n\tconnection = accept(fd, NULL, 0);\n\tif (connection < 0) {\n\t\tSYSERROR(\"Failed to accept connection to run command.\");\n\t\treturn -1;\n\t}\n\n\tif (fcntl(connection, F_SETFD, FD_CLOEXEC)) {\n\t\tSYSERROR(\"Failed to set close-on-exec on incoming command connection.\");\n\t\tgoto out_close;\n\t}\n\n\tif (setsockopt(connection, SOL_SOCKET,\n\t\t       SO_PASSCRED, &opt, sizeof(opt))) {\n\t\tSYSERROR(\"Failed to enable necessary credentials on command socket.\");\n\t\tgoto out_close;\n\t}\n\n\tret = lxc_mainloop_add_handler(descr, connection, lxc_cmd_handler, data);\n\tif (ret) {\n\t\tERROR(\"Failed to add command handler.\");\n\t\tgoto out_close;\n\t}\n\nout:\n\treturn ret;\n\nout_close:\n\tclose(connection);\n\tgoto out;\n}"
  },
  {
    "function_name": "lxc_cmd_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
    "lines": "871-934",
    "snippet": "static int lxc_cmd_handler(int fd, uint32_t events, void *data,\n\t\t\t   struct lxc_epoll_descr *descr)\n{\n\tint ret;\n\tstruct lxc_cmd_req req;\n\tstruct lxc_handler *handler = data;\n\n\tret = lxc_abstract_unix_rcv_credential(fd, &req, sizeof(req));\n\tif (ret == -EACCES) {\n\t\t/* we don't care for the peer, just send and close */\n\t\tstruct lxc_cmd_rsp rsp = { .ret = ret };\n\n\t\tlxc_cmd_rsp_send(fd, &rsp);\n\t\tgoto out_close;\n\t}\n\n\tif (ret < 0) {\n\t\tSYSERROR(\"Failed to receive data on command socket.\");\n\t\tgoto out_close;\n\t}\n\n\tif (!ret) {\n\t\tDEBUG(\"Peer has disconnected.\");\n\t\tgoto out_close;\n\t}\n\n\tif (ret != sizeof(req)) {\n\t\tWARN(\"Failed to receive full command request. Ignoring request.\");\n\t\tret = -1;\n\t\tgoto out_close;\n\t}\n\n\tif (req.datalen > LXC_CMD_DATA_MAX) {\n\t\tERROR(\"Received command data length %d is too large.\", req.datalen);\n\t\tret = -1;\n\t\tgoto out_close;\n\t}\n\n\tif (req.datalen > 0) {\n\t\tvoid *reqdata;\n\n\t\treqdata = alloca(req.datalen);\n\t\tret = recv(fd, reqdata, req.datalen, 0);\n\t\tif (ret != req.datalen) {\n\t\t\tWARN(\"Failed to receive full command request. Ignoring request.\");\n\t\t\tret = -1;\n\t\t\tgoto out_close;\n\t\t}\n\t\treq.data = reqdata;\n\t}\n\n\tret = lxc_cmd_process(fd, &req, handler);\n\tif (ret) {\n\t\t/* this is not an error, but only a request to close fd */\n\t\tret = 0;\n\t\tgoto out_close;\n\t}\n\nout:\n\treturn ret;\nout_close:\n\tlxc_cmd_fd_cleanup(fd, handler, descr);\n\tgoto out;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"af_unix.h\"",
      "#include \"mainloop.h\"",
      "#include \"confile.h\"",
      "#include \"console.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"utils.h\"",
      "#include \"start.h\"\t/* for struct lxc_handler */",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/un.h>",
      "#include <inttypes.h>",
      "#include <sys/socket.h>",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_cmd_fd_cleanup",
          "args": [
            "fd",
            "handler",
            "descr"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_fd_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "863-869",
          "snippet": "static void lxc_cmd_fd_cleanup(int fd, struct lxc_handler *handler,\n\t\t\t       struct lxc_epoll_descr *descr)\n{\n\tlxc_console_free(handler->conf, fd);\n\tlxc_mainloop_del_handler(descr, fd);\n\tclose(fd);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic void lxc_cmd_fd_cleanup(int fd, struct lxc_handler *handler,\n\t\t\t       struct lxc_epoll_descr *descr)\n{\n\tlxc_console_free(handler->conf, fd);\n\tlxc_mainloop_del_handler(descr, fd);\n\tclose(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cmd_process",
          "args": [
            "fd",
            "&req",
            "handler"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "838-861",
          "snippet": "static int lxc_cmd_process(int fd, struct lxc_cmd_req *req,\n\t\t\t   struct lxc_handler *handler)\n{\n\ttypedef int (*callback)(int, struct lxc_cmd_req *, struct lxc_handler *);\n\n\tcallback cb[LXC_CMD_MAX] = {\n\t\t[LXC_CMD_CONSOLE]         = lxc_cmd_console_callback,\n\t\t[LXC_CMD_CONSOLE_WINCH]   = lxc_cmd_console_winch_callback,\n\t\t[LXC_CMD_STOP]            = lxc_cmd_stop_callback,\n\t\t[LXC_CMD_GET_STATE]       = lxc_cmd_get_state_callback,\n\t\t[LXC_CMD_GET_INIT_PID]    = lxc_cmd_get_init_pid_callback,\n\t\t[LXC_CMD_GET_CLONE_FLAGS] = lxc_cmd_get_clone_flags_callback,\n\t\t[LXC_CMD_GET_CGROUP]      = lxc_cmd_get_cgroup_callback,\n\t\t[LXC_CMD_GET_CONFIG_ITEM] = lxc_cmd_get_config_item_callback,\n\t\t[LXC_CMD_GET_NAME]        = lxc_cmd_get_name_callback,\n\t\t[LXC_CMD_GET_LXCPATH]     = lxc_cmd_get_lxcpath_callback,\n\t};\n\n\tif (req->cmd >= LXC_CMD_MAX) {\n\t\tERROR(\"Undefined command id %d received.\", req->cmd);\n\t\treturn -1;\n\t}\n\treturn cb[req->cmd](fd, req, handler);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd_process(int fd, struct lxc_cmd_req *req,\n\t\t\t   struct lxc_handler *handler)\n{\n\ttypedef int (*callback)(int, struct lxc_cmd_req *, struct lxc_handler *);\n\n\tcallback cb[LXC_CMD_MAX] = {\n\t\t[LXC_CMD_CONSOLE]         = lxc_cmd_console_callback,\n\t\t[LXC_CMD_CONSOLE_WINCH]   = lxc_cmd_console_winch_callback,\n\t\t[LXC_CMD_STOP]            = lxc_cmd_stop_callback,\n\t\t[LXC_CMD_GET_STATE]       = lxc_cmd_get_state_callback,\n\t\t[LXC_CMD_GET_INIT_PID]    = lxc_cmd_get_init_pid_callback,\n\t\t[LXC_CMD_GET_CLONE_FLAGS] = lxc_cmd_get_clone_flags_callback,\n\t\t[LXC_CMD_GET_CGROUP]      = lxc_cmd_get_cgroup_callback,\n\t\t[LXC_CMD_GET_CONFIG_ITEM] = lxc_cmd_get_config_item_callback,\n\t\t[LXC_CMD_GET_NAME]        = lxc_cmd_get_name_callback,\n\t\t[LXC_CMD_GET_LXCPATH]     = lxc_cmd_get_lxcpath_callback,\n\t};\n\n\tif (req->cmd >= LXC_CMD_MAX) {\n\t\tERROR(\"Undefined command id %d received.\", req->cmd);\n\t\treturn -1;\n\t}\n\treturn cb[req->cmd](fd, req, handler);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to receive full command request. Ignoring request.\""
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv",
          "args": [
            "fd",
            "reqdata",
            "req.datalen",
            "0"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_recv_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "164-201",
          "snippet": "int lxc_abstract_unix_recv_fd(int fd, int *recvfd, void *data, size_t size)\n{\n\tstruct msghdr msg = { 0 };\n\tstruct iovec iov;\n\tstruct cmsghdr *cmsg;\n\tchar cmsgbuf[CMSG_SPACE(sizeof(int))];\n\tchar buf[1];\n\tint ret, *val;\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_namelen = 0;\n\tmsg.msg_control = cmsgbuf;\n\tmsg.msg_controllen = sizeof(cmsgbuf);\n\n\tiov.iov_base = data ? data : buf;\n\tiov.iov_len = data ? size : sizeof(buf);\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\tret = recvmsg(fd, &msg, 0);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\n\t/* if the message is wrong the variable will not be\n\t * filled and the peer will notified about a problem */\n\t*recvfd = -1;\n\n\tif (cmsg && cmsg->cmsg_len == CMSG_LEN(sizeof(int)) &&\n\t\t\tcmsg->cmsg_level == SOL_SOCKET &&\n\t\t\tcmsg->cmsg_type == SCM_RIGHTS) {\n\t\tval = (int *) CMSG_DATA(cmsg);\n\t\t*recvfd = *val;\n\t}\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_recv_fd(int fd, int *recvfd, void *data, size_t size)\n{\n\tstruct msghdr msg = { 0 };\n\tstruct iovec iov;\n\tstruct cmsghdr *cmsg;\n\tchar cmsgbuf[CMSG_SPACE(sizeof(int))];\n\tchar buf[1];\n\tint ret, *val;\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_namelen = 0;\n\tmsg.msg_control = cmsgbuf;\n\tmsg.msg_controllen = sizeof(cmsgbuf);\n\n\tiov.iov_base = data ? data : buf;\n\tiov.iov_len = data ? size : sizeof(buf);\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\tret = recvmsg(fd, &msg, 0);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\n\t/* if the message is wrong the variable will not be\n\t * filled and the peer will notified about a problem */\n\t*recvfd = -1;\n\n\tif (cmsg && cmsg->cmsg_len == CMSG_LEN(sizeof(int)) &&\n\t\t\tcmsg->cmsg_level == SOL_SOCKET &&\n\t\t\tcmsg->cmsg_type == SCM_RIGHTS) {\n\t\tval = (int *) CMSG_DATA(cmsg);\n\t\t*recvfd = *val;\n\t}\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "req.datalen"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Received command data length %d is too large.\"",
            "req.datalen"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to receive full command request. Ignoring request.\""
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Peer has disconnected.\""
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to receive data on command socket.\""
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cmd_rsp_send",
          "args": [
            "fd",
            "&rsp"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_rsp_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "230-250",
          "snippet": "static int lxc_cmd_rsp_send(int fd, struct lxc_cmd_rsp *rsp)\n{\n\tint ret;\n\n\tret = send(fd, rsp, sizeof(*rsp), 0);\n\tif (ret != sizeof(*rsp)) {\n\t\tERROR(\"Failed to send command response %d: %s.\", ret,\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (rsp->datalen > 0) {\n\t\tret = send(fd, rsp->data, rsp->datalen, 0);\n\t\tif (ret != rsp->datalen) {\n\t\t\tWARN(\"Failed to send command response data %d: %s.\",\n\t\t\t     ret, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd_rsp_send(int fd, struct lxc_cmd_rsp *rsp)\n{\n\tint ret;\n\n\tret = send(fd, rsp, sizeof(*rsp), 0);\n\tif (ret != sizeof(*rsp)) {\n\t\tERROR(\"Failed to send command response %d: %s.\", ret,\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (rsp->datalen > 0) {\n\t\tret = send(fd, rsp->data, rsp->datalen, 0);\n\t\tif (ret != rsp->datalen) {\n\t\t\tWARN(\"Failed to send command response data %d: %s.\",\n\t\t\t     ret, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_abstract_unix_rcv_credential",
          "args": [
            "fd",
            "&req",
            "sizeof(req)"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_rcv_credential",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "236-273",
          "snippet": "int lxc_abstract_unix_rcv_credential(int fd, void *data, size_t size)\n{\n\tstruct msghdr msg = { 0 };\n\tstruct iovec iov;\n\tstruct cmsghdr *cmsg;\n\tstruct ucred cred;\n\tchar cmsgbuf[CMSG_SPACE(sizeof(cred))];\n\tchar buf[1];\n\tint ret;\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_namelen = 0;\n\tmsg.msg_control = cmsgbuf;\n\tmsg.msg_controllen = sizeof(cmsgbuf);\n\n\tiov.iov_base = data ? data : buf;\n\tiov.iov_len = data ? size : sizeof(buf);\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\tret = recvmsg(fd, &msg, 0);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\n\tif (cmsg && cmsg->cmsg_len == CMSG_LEN(sizeof(struct ucred)) &&\n\t\t\tcmsg->cmsg_level == SOL_SOCKET &&\n\t\t\tcmsg->cmsg_type == SCM_CREDENTIALS) {\n\t\tmemcpy(&cred, CMSG_DATA(cmsg), sizeof(cred));\n\t\tif (cred.uid && (cred.uid != getuid() || cred.gid != getgid())) {\n\t\t\tINFO(\"message denied for '%d/%d'\", cred.uid, cred.gid);\n\t\t\treturn -EACCES;\n\t\t}\n\t}\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_rcv_credential(int fd, void *data, size_t size)\n{\n\tstruct msghdr msg = { 0 };\n\tstruct iovec iov;\n\tstruct cmsghdr *cmsg;\n\tstruct ucred cred;\n\tchar cmsgbuf[CMSG_SPACE(sizeof(cred))];\n\tchar buf[1];\n\tint ret;\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_namelen = 0;\n\tmsg.msg_control = cmsgbuf;\n\tmsg.msg_controllen = sizeof(cmsgbuf);\n\n\tiov.iov_base = data ? data : buf;\n\tiov.iov_len = data ? size : sizeof(buf);\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\tret = recvmsg(fd, &msg, 0);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\n\tif (cmsg && cmsg->cmsg_len == CMSG_LEN(sizeof(struct ucred)) &&\n\t\t\tcmsg->cmsg_level == SOL_SOCKET &&\n\t\t\tcmsg->cmsg_type == SCM_CREDENTIALS) {\n\t\tmemcpy(&cred, CMSG_DATA(cmsg), sizeof(cred));\n\t\tif (cred.uid && (cred.uid != getuid() || cred.gid != getgid())) {\n\t\t\tINFO(\"message denied for '%d/%d'\", cred.uid, cred.gid);\n\t\t\treturn -EACCES;\n\t\t}\n\t}\nout:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd_handler(int fd, uint32_t events, void *data,\n\t\t\t   struct lxc_epoll_descr *descr)\n{\n\tint ret;\n\tstruct lxc_cmd_req req;\n\tstruct lxc_handler *handler = data;\n\n\tret = lxc_abstract_unix_rcv_credential(fd, &req, sizeof(req));\n\tif (ret == -EACCES) {\n\t\t/* we don't care for the peer, just send and close */\n\t\tstruct lxc_cmd_rsp rsp = { .ret = ret };\n\n\t\tlxc_cmd_rsp_send(fd, &rsp);\n\t\tgoto out_close;\n\t}\n\n\tif (ret < 0) {\n\t\tSYSERROR(\"Failed to receive data on command socket.\");\n\t\tgoto out_close;\n\t}\n\n\tif (!ret) {\n\t\tDEBUG(\"Peer has disconnected.\");\n\t\tgoto out_close;\n\t}\n\n\tif (ret != sizeof(req)) {\n\t\tWARN(\"Failed to receive full command request. Ignoring request.\");\n\t\tret = -1;\n\t\tgoto out_close;\n\t}\n\n\tif (req.datalen > LXC_CMD_DATA_MAX) {\n\t\tERROR(\"Received command data length %d is too large.\", req.datalen);\n\t\tret = -1;\n\t\tgoto out_close;\n\t}\n\n\tif (req.datalen > 0) {\n\t\tvoid *reqdata;\n\n\t\treqdata = alloca(req.datalen);\n\t\tret = recv(fd, reqdata, req.datalen, 0);\n\t\tif (ret != req.datalen) {\n\t\t\tWARN(\"Failed to receive full command request. Ignoring request.\");\n\t\t\tret = -1;\n\t\t\tgoto out_close;\n\t\t}\n\t\treq.data = reqdata;\n\t}\n\n\tret = lxc_cmd_process(fd, &req, handler);\n\tif (ret) {\n\t\t/* this is not an error, but only a request to close fd */\n\t\tret = 0;\n\t\tgoto out_close;\n\t}\n\nout:\n\treturn ret;\nout_close:\n\tlxc_cmd_fd_cleanup(fd, handler, descr);\n\tgoto out;\n}"
  },
  {
    "function_name": "lxc_cmd_fd_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
    "lines": "863-869",
    "snippet": "static void lxc_cmd_fd_cleanup(int fd, struct lxc_handler *handler,\n\t\t\t       struct lxc_epoll_descr *descr)\n{\n\tlxc_console_free(handler->conf, fd);\n\tlxc_mainloop_del_handler(descr, fd);\n\tclose(fd);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"af_unix.h\"",
      "#include \"mainloop.h\"",
      "#include \"confile.h\"",
      "#include \"console.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"utils.h\"",
      "#include \"start.h\"\t/* for struct lxc_handler */",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/un.h>",
      "#include <inttypes.h>",
      "#include <sys/socket.h>",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_mainloop_del_handler",
          "args": [
            "descr",
            "fd"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_mainloop_del_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/mainloop.c",
          "lines": "109-130",
          "snippet": "int lxc_mainloop_del_handler(struct lxc_epoll_descr *descr, int fd)\n{\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *iterator;\n\n\tlxc_list_for_each(iterator, &descr->handlers) {\n\t\thandler = iterator->elem;\n\n\t\tif (handler->fd == fd) {\n\t\t\t/* found */\n\t\t\tif (epoll_ctl(descr->epfd, EPOLL_CTL_DEL, fd, NULL))\n\t\t\t\treturn -1;\n\n\t\t\tlxc_list_del(iterator);\n\t\t\tfree(iterator->elem);\n\t\t\tfree(iterator);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include \"mainloop.h\"",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mainloop.h\"\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint lxc_mainloop_del_handler(struct lxc_epoll_descr *descr, int fd)\n{\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *iterator;\n\n\tlxc_list_for_each(iterator, &descr->handlers) {\n\t\thandler = iterator->elem;\n\n\t\tif (handler->fd == fd) {\n\t\t\t/* found */\n\t\t\tif (epoll_ctl(descr->epfd, EPOLL_CTL_DEL, fd, NULL))\n\t\t\t\treturn -1;\n\n\t\t\tlxc_list_del(iterator);\n\t\t\tfree(iterator->elem);\n\t\t\tfree(iterator);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_console_free",
          "args": [
            "handler->conf",
            "fd"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_console_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
          "lines": "401-416",
          "snippet": "void lxc_console_free(struct lxc_conf *conf, int fd)\n{\n\tint i;\n\tstruct lxc_tty_info *tty_info = &conf->tty_info;\n\tstruct lxc_console *console = &conf->console;\n\n\tfor (i = 0; i < tty_info->nbtty; i++) {\n\t\tif (tty_info->pty_info[i].busy == fd)\n\t\t\ttty_info->pty_info[i].busy = 0;\n\t}\n\n\tif (console->peerpty.busy == fd) {\n\t\tlxc_mainloop_del_handler(console->descr, console->peerpty.slave);\n\t\tlxc_console_peer_proxy_free(console);\n\t}\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"start.h\" \t/* for struct lxc_handler */",
            "#include \"mainloop.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"caps.h\"",
            "#include \"af_unix.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nvoid lxc_console_free(struct lxc_conf *conf, int fd)\n{\n\tint i;\n\tstruct lxc_tty_info *tty_info = &conf->tty_info;\n\tstruct lxc_console *console = &conf->console;\n\n\tfor (i = 0; i < tty_info->nbtty; i++) {\n\t\tif (tty_info->pty_info[i].busy == fd)\n\t\t\ttty_info->pty_info[i].busy = 0;\n\t}\n\n\tif (console->peerpty.busy == fd) {\n\t\tlxc_mainloop_del_handler(console->descr, console->peerpty.slave);\n\t\tlxc_console_peer_proxy_free(console);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic void lxc_cmd_fd_cleanup(int fd, struct lxc_handler *handler,\n\t\t\t       struct lxc_epoll_descr *descr)\n{\n\tlxc_console_free(handler->conf, fd);\n\tlxc_mainloop_del_handler(descr, fd);\n\tclose(fd);\n}"
  },
  {
    "function_name": "lxc_cmd_process",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
    "lines": "838-861",
    "snippet": "static int lxc_cmd_process(int fd, struct lxc_cmd_req *req,\n\t\t\t   struct lxc_handler *handler)\n{\n\ttypedef int (*callback)(int, struct lxc_cmd_req *, struct lxc_handler *);\n\n\tcallback cb[LXC_CMD_MAX] = {\n\t\t[LXC_CMD_CONSOLE]         = lxc_cmd_console_callback,\n\t\t[LXC_CMD_CONSOLE_WINCH]   = lxc_cmd_console_winch_callback,\n\t\t[LXC_CMD_STOP]            = lxc_cmd_stop_callback,\n\t\t[LXC_CMD_GET_STATE]       = lxc_cmd_get_state_callback,\n\t\t[LXC_CMD_GET_INIT_PID]    = lxc_cmd_get_init_pid_callback,\n\t\t[LXC_CMD_GET_CLONE_FLAGS] = lxc_cmd_get_clone_flags_callback,\n\t\t[LXC_CMD_GET_CGROUP]      = lxc_cmd_get_cgroup_callback,\n\t\t[LXC_CMD_GET_CONFIG_ITEM] = lxc_cmd_get_config_item_callback,\n\t\t[LXC_CMD_GET_NAME]        = lxc_cmd_get_name_callback,\n\t\t[LXC_CMD_GET_LXCPATH]     = lxc_cmd_get_lxcpath_callback,\n\t};\n\n\tif (req->cmd >= LXC_CMD_MAX) {\n\t\tERROR(\"Undefined command id %d received.\", req->cmd);\n\t\treturn -1;\n\t}\n\treturn cb[req->cmd](fd, req, handler);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"af_unix.h\"",
      "#include \"mainloop.h\"",
      "#include \"confile.h\"",
      "#include \"console.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"utils.h\"",
      "#include \"start.h\"\t/* for struct lxc_handler */",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/un.h>",
      "#include <inttypes.h>",
      "#include <sys/socket.h>",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cb[req->cmd]",
          "args": [
            "fd",
            "req",
            "handler"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Undefined command id %d received.\"",
            "req->cmd"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd_process(int fd, struct lxc_cmd_req *req,\n\t\t\t   struct lxc_handler *handler)\n{\n\ttypedef int (*callback)(int, struct lxc_cmd_req *, struct lxc_handler *);\n\n\tcallback cb[LXC_CMD_MAX] = {\n\t\t[LXC_CMD_CONSOLE]         = lxc_cmd_console_callback,\n\t\t[LXC_CMD_CONSOLE_WINCH]   = lxc_cmd_console_winch_callback,\n\t\t[LXC_CMD_STOP]            = lxc_cmd_stop_callback,\n\t\t[LXC_CMD_GET_STATE]       = lxc_cmd_get_state_callback,\n\t\t[LXC_CMD_GET_INIT_PID]    = lxc_cmd_get_init_pid_callback,\n\t\t[LXC_CMD_GET_CLONE_FLAGS] = lxc_cmd_get_clone_flags_callback,\n\t\t[LXC_CMD_GET_CGROUP]      = lxc_cmd_get_cgroup_callback,\n\t\t[LXC_CMD_GET_CONFIG_ITEM] = lxc_cmd_get_config_item_callback,\n\t\t[LXC_CMD_GET_NAME]        = lxc_cmd_get_name_callback,\n\t\t[LXC_CMD_GET_LXCPATH]     = lxc_cmd_get_lxcpath_callback,\n\t};\n\n\tif (req->cmd >= LXC_CMD_MAX) {\n\t\tERROR(\"Undefined command id %d received.\", req->cmd);\n\t\treturn -1;\n\t}\n\treturn cb[req->cmd](fd, req, handler);\n}"
  },
  {
    "function_name": "lxc_cmd_get_lxcpath_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
    "lines": "824-836",
    "snippet": "static int lxc_cmd_get_lxcpath_callback(int fd, struct lxc_cmd_req *req,\n\t\t\t\t\tstruct lxc_handler *handler)\n{\n\tstruct lxc_cmd_rsp rsp;\n\n\tmemset(&rsp, 0, sizeof(rsp));\n\n\trsp.data = (char *)handler->lxcpath;\n\trsp.datalen = strlen(handler->lxcpath) + 1;\n\trsp.ret = 0;\n\n\treturn lxc_cmd_rsp_send(fd, &rsp);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"af_unix.h\"",
      "#include \"mainloop.h\"",
      "#include \"confile.h\"",
      "#include \"console.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"utils.h\"",
      "#include \"start.h\"\t/* for struct lxc_handler */",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/un.h>",
      "#include <inttypes.h>",
      "#include <sys/socket.h>",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_cmd_rsp_send",
          "args": [
            "fd",
            "&rsp"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_rsp_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "230-250",
          "snippet": "static int lxc_cmd_rsp_send(int fd, struct lxc_cmd_rsp *rsp)\n{\n\tint ret;\n\n\tret = send(fd, rsp, sizeof(*rsp), 0);\n\tif (ret != sizeof(*rsp)) {\n\t\tERROR(\"Failed to send command response %d: %s.\", ret,\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (rsp->datalen > 0) {\n\t\tret = send(fd, rsp->data, rsp->datalen, 0);\n\t\tif (ret != rsp->datalen) {\n\t\t\tWARN(\"Failed to send command response data %d: %s.\",\n\t\t\t     ret, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd_rsp_send(int fd, struct lxc_cmd_rsp *rsp)\n{\n\tint ret;\n\n\tret = send(fd, rsp, sizeof(*rsp), 0);\n\tif (ret != sizeof(*rsp)) {\n\t\tERROR(\"Failed to send command response %d: %s.\", ret,\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (rsp->datalen > 0) {\n\t\tret = send(fd, rsp->data, rsp->datalen, 0);\n\t\tif (ret != rsp->datalen) {\n\t\t\tWARN(\"Failed to send command response data %d: %s.\",\n\t\t\t     ret, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "handler->lxcpath"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&rsp",
            "0",
            "sizeof(rsp)"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd_get_lxcpath_callback(int fd, struct lxc_cmd_req *req,\n\t\t\t\t\tstruct lxc_handler *handler)\n{\n\tstruct lxc_cmd_rsp rsp;\n\n\tmemset(&rsp, 0, sizeof(rsp));\n\n\trsp.data = (char *)handler->lxcpath;\n\trsp.datalen = strlen(handler->lxcpath) + 1;\n\trsp.ret = 0;\n\n\treturn lxc_cmd_rsp_send(fd, &rsp);\n}"
  },
  {
    "function_name": "lxc_cmd_get_lxcpath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
    "lines": "807-822",
    "snippet": "char *lxc_cmd_get_lxcpath(const char *hashed_sock_name)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_GET_LXCPATH},\n\t};\n\n\tret = lxc_cmd(NULL, &cmd, &stopped, NULL, hashed_sock_name);\n\tif (ret < 0) {\n\t\treturn NULL;\n\t}\n\n\tif (cmd.rsp.ret == 0)\n\t\treturn cmd.rsp.data;\n\treturn NULL;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"af_unix.h\"",
      "#include \"mainloop.h\"",
      "#include \"confile.h\"",
      "#include \"console.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"utils.h\"",
      "#include \"start.h\"\t/* for struct lxc_handler */",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/un.h>",
      "#include <inttypes.h>",
      "#include <sys/socket.h>",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_cmd",
          "args": [
            "NULL",
            "&cmd",
            "&stopped",
            "NULL",
            "hashed_sock_name"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "271-338",
          "snippet": "static int lxc_cmd(const char *name, struct lxc_cmd_rr *cmd, int *stopped,\n\t\t   const char *lxcpath, const char *hashed_sock_name)\n{\n\tint sock, ret = -1;\n\tchar path[sizeof(((struct sockaddr_un *)0)->sun_path)] = { 0 };\n\tchar *offset = &path[1];\n\tint len;\n\tint stay_connected = cmd->req.cmd == LXC_CMD_CONSOLE;\n\n\t*stopped = 0;\n\n\t/* -2 here because this is an abstract unix socket so it needs a\n\t * leading \\0, and we null terminate, so it needs a trailing \\0.\n\t * Although null termination isn't required by the API, we do it anyway\n\t * because we print the sockname out sometimes.\n\t */\n\tlen = sizeof(path)-2;\n\tif (fill_sock_name(offset, len, name, lxcpath, hashed_sock_name))\n\t\treturn -1;\n\n\tsock = lxc_abstract_unix_connect(path);\n\tif (sock < 0) {\n\t\tif (errno == ECONNREFUSED)\n\t\t\t*stopped = 1;\n\t\telse\n\t\t\tSYSERROR(\"Command %s failed to connect to \\\"@%s\\\".\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset);\n\t\treturn -1;\n\t}\n\n\tret = lxc_abstract_unix_send_credential(sock, &cmd->req, sizeof(cmd->req));\n\tif (ret != sizeof(cmd->req)) {\n\t\tif (errno == EPIPE)\n\t\t\tgoto epipe;\n\t\tSYSERROR(\"Command %s failed to send req to \\\"@%s\\\" %d.\",\n\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\tif (ret >=0)\n\t\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (cmd->req.datalen > 0) {\n\t\tret = send(sock, cmd->req.data, cmd->req.datalen, MSG_NOSIGNAL);\n\t\tif (ret != cmd->req.datalen) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tgoto epipe;\n\t\t\tSYSERROR(\"Command %s failed to send request data to \\\"@%s\\\" %d.\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\t\tif (ret >=0)\n\t\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = lxc_cmd_rsp_recv(sock, cmd);\nout:\n\tif (!stay_connected || ret <= 0)\n\t\tclose(sock);\n\tif (stay_connected && ret > 0)\n\t\tcmd->rsp.ret = sock;\n\n\treturn ret;\n\nepipe:\n\tclose(sock);\n\t*stopped = 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd(const char *name, struct lxc_cmd_rr *cmd, int *stopped,\n\t\t   const char *lxcpath, const char *hashed_sock_name)\n{\n\tint sock, ret = -1;\n\tchar path[sizeof(((struct sockaddr_un *)0)->sun_path)] = { 0 };\n\tchar *offset = &path[1];\n\tint len;\n\tint stay_connected = cmd->req.cmd == LXC_CMD_CONSOLE;\n\n\t*stopped = 0;\n\n\t/* -2 here because this is an abstract unix socket so it needs a\n\t * leading \\0, and we null terminate, so it needs a trailing \\0.\n\t * Although null termination isn't required by the API, we do it anyway\n\t * because we print the sockname out sometimes.\n\t */\n\tlen = sizeof(path)-2;\n\tif (fill_sock_name(offset, len, name, lxcpath, hashed_sock_name))\n\t\treturn -1;\n\n\tsock = lxc_abstract_unix_connect(path);\n\tif (sock < 0) {\n\t\tif (errno == ECONNREFUSED)\n\t\t\t*stopped = 1;\n\t\telse\n\t\t\tSYSERROR(\"Command %s failed to connect to \\\"@%s\\\".\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset);\n\t\treturn -1;\n\t}\n\n\tret = lxc_abstract_unix_send_credential(sock, &cmd->req, sizeof(cmd->req));\n\tif (ret != sizeof(cmd->req)) {\n\t\tif (errno == EPIPE)\n\t\t\tgoto epipe;\n\t\tSYSERROR(\"Command %s failed to send req to \\\"@%s\\\" %d.\",\n\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\tif (ret >=0)\n\t\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (cmd->req.datalen > 0) {\n\t\tret = send(sock, cmd->req.data, cmd->req.datalen, MSG_NOSIGNAL);\n\t\tif (ret != cmd->req.datalen) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tgoto epipe;\n\t\t\tSYSERROR(\"Command %s failed to send request data to \\\"@%s\\\" %d.\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\t\tif (ret >=0)\n\t\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = lxc_cmd_rsp_recv(sock, cmd);\nout:\n\tif (!stay_connected || ret <= 0)\n\t\tclose(sock);\n\tif (stay_connected && ret > 0)\n\t\tcmd->rsp.ret = sock;\n\n\treturn ret;\n\nepipe:\n\tclose(sock);\n\t*stopped = 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nchar *lxc_cmd_get_lxcpath(const char *hashed_sock_name)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_GET_LXCPATH},\n\t};\n\n\tret = lxc_cmd(NULL, &cmd, &stopped, NULL, hashed_sock_name);\n\tif (ret < 0) {\n\t\treturn NULL;\n\t}\n\n\tif (cmd.rsp.ret == 0)\n\t\treturn cmd.rsp.data;\n\treturn NULL;\n}"
  },
  {
    "function_name": "lxc_cmd_get_name_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
    "lines": "786-798",
    "snippet": "static int lxc_cmd_get_name_callback(int fd, struct lxc_cmd_req *req,\n\t\t\t\t\t    struct lxc_handler *handler)\n{\n\tstruct lxc_cmd_rsp rsp;\n\n\tmemset(&rsp, 0, sizeof(rsp));\n\n\trsp.data = handler->name;\n\trsp.datalen = strlen(handler->name) + 1;\n\trsp.ret = 0;\n\n\treturn lxc_cmd_rsp_send(fd, &rsp);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"af_unix.h\"",
      "#include \"mainloop.h\"",
      "#include \"confile.h\"",
      "#include \"console.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"utils.h\"",
      "#include \"start.h\"\t/* for struct lxc_handler */",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/un.h>",
      "#include <inttypes.h>",
      "#include <sys/socket.h>",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_cmd_rsp_send",
          "args": [
            "fd",
            "&rsp"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_rsp_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "230-250",
          "snippet": "static int lxc_cmd_rsp_send(int fd, struct lxc_cmd_rsp *rsp)\n{\n\tint ret;\n\n\tret = send(fd, rsp, sizeof(*rsp), 0);\n\tif (ret != sizeof(*rsp)) {\n\t\tERROR(\"Failed to send command response %d: %s.\", ret,\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (rsp->datalen > 0) {\n\t\tret = send(fd, rsp->data, rsp->datalen, 0);\n\t\tif (ret != rsp->datalen) {\n\t\t\tWARN(\"Failed to send command response data %d: %s.\",\n\t\t\t     ret, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd_rsp_send(int fd, struct lxc_cmd_rsp *rsp)\n{\n\tint ret;\n\n\tret = send(fd, rsp, sizeof(*rsp), 0);\n\tif (ret != sizeof(*rsp)) {\n\t\tERROR(\"Failed to send command response %d: %s.\", ret,\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (rsp->datalen > 0) {\n\t\tret = send(fd, rsp->data, rsp->datalen, 0);\n\t\tif (ret != rsp->datalen) {\n\t\t\tWARN(\"Failed to send command response data %d: %s.\",\n\t\t\t     ret, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "handler->name"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&rsp",
            "0",
            "sizeof(rsp)"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd_get_name_callback(int fd, struct lxc_cmd_req *req,\n\t\t\t\t\t    struct lxc_handler *handler)\n{\n\tstruct lxc_cmd_rsp rsp;\n\n\tmemset(&rsp, 0, sizeof(rsp));\n\n\trsp.data = handler->name;\n\trsp.datalen = strlen(handler->name) + 1;\n\trsp.ret = 0;\n\n\treturn lxc_cmd_rsp_send(fd, &rsp);\n}"
  },
  {
    "function_name": "lxc_cmd_get_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
    "lines": "769-784",
    "snippet": "char *lxc_cmd_get_name(const char *hashed_sock_name)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_GET_NAME},\n\t};\n\n\tret = lxc_cmd(NULL, &cmd, &stopped, NULL, hashed_sock_name);\n\tif (ret < 0) {\n\t\treturn NULL;\n\t}\n\n\tif (cmd.rsp.ret == 0)\n\t\treturn cmd.rsp.data;\n\treturn NULL;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"af_unix.h\"",
      "#include \"mainloop.h\"",
      "#include \"confile.h\"",
      "#include \"console.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"utils.h\"",
      "#include \"start.h\"\t/* for struct lxc_handler */",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/un.h>",
      "#include <inttypes.h>",
      "#include <sys/socket.h>",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_cmd",
          "args": [
            "NULL",
            "&cmd",
            "&stopped",
            "NULL",
            "hashed_sock_name"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "271-338",
          "snippet": "static int lxc_cmd(const char *name, struct lxc_cmd_rr *cmd, int *stopped,\n\t\t   const char *lxcpath, const char *hashed_sock_name)\n{\n\tint sock, ret = -1;\n\tchar path[sizeof(((struct sockaddr_un *)0)->sun_path)] = { 0 };\n\tchar *offset = &path[1];\n\tint len;\n\tint stay_connected = cmd->req.cmd == LXC_CMD_CONSOLE;\n\n\t*stopped = 0;\n\n\t/* -2 here because this is an abstract unix socket so it needs a\n\t * leading \\0, and we null terminate, so it needs a trailing \\0.\n\t * Although null termination isn't required by the API, we do it anyway\n\t * because we print the sockname out sometimes.\n\t */\n\tlen = sizeof(path)-2;\n\tif (fill_sock_name(offset, len, name, lxcpath, hashed_sock_name))\n\t\treturn -1;\n\n\tsock = lxc_abstract_unix_connect(path);\n\tif (sock < 0) {\n\t\tif (errno == ECONNREFUSED)\n\t\t\t*stopped = 1;\n\t\telse\n\t\t\tSYSERROR(\"Command %s failed to connect to \\\"@%s\\\".\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset);\n\t\treturn -1;\n\t}\n\n\tret = lxc_abstract_unix_send_credential(sock, &cmd->req, sizeof(cmd->req));\n\tif (ret != sizeof(cmd->req)) {\n\t\tif (errno == EPIPE)\n\t\t\tgoto epipe;\n\t\tSYSERROR(\"Command %s failed to send req to \\\"@%s\\\" %d.\",\n\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\tif (ret >=0)\n\t\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (cmd->req.datalen > 0) {\n\t\tret = send(sock, cmd->req.data, cmd->req.datalen, MSG_NOSIGNAL);\n\t\tif (ret != cmd->req.datalen) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tgoto epipe;\n\t\t\tSYSERROR(\"Command %s failed to send request data to \\\"@%s\\\" %d.\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\t\tif (ret >=0)\n\t\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = lxc_cmd_rsp_recv(sock, cmd);\nout:\n\tif (!stay_connected || ret <= 0)\n\t\tclose(sock);\n\tif (stay_connected && ret > 0)\n\t\tcmd->rsp.ret = sock;\n\n\treturn ret;\n\nepipe:\n\tclose(sock);\n\t*stopped = 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd(const char *name, struct lxc_cmd_rr *cmd, int *stopped,\n\t\t   const char *lxcpath, const char *hashed_sock_name)\n{\n\tint sock, ret = -1;\n\tchar path[sizeof(((struct sockaddr_un *)0)->sun_path)] = { 0 };\n\tchar *offset = &path[1];\n\tint len;\n\tint stay_connected = cmd->req.cmd == LXC_CMD_CONSOLE;\n\n\t*stopped = 0;\n\n\t/* -2 here because this is an abstract unix socket so it needs a\n\t * leading \\0, and we null terminate, so it needs a trailing \\0.\n\t * Although null termination isn't required by the API, we do it anyway\n\t * because we print the sockname out sometimes.\n\t */\n\tlen = sizeof(path)-2;\n\tif (fill_sock_name(offset, len, name, lxcpath, hashed_sock_name))\n\t\treturn -1;\n\n\tsock = lxc_abstract_unix_connect(path);\n\tif (sock < 0) {\n\t\tif (errno == ECONNREFUSED)\n\t\t\t*stopped = 1;\n\t\telse\n\t\t\tSYSERROR(\"Command %s failed to connect to \\\"@%s\\\".\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset);\n\t\treturn -1;\n\t}\n\n\tret = lxc_abstract_unix_send_credential(sock, &cmd->req, sizeof(cmd->req));\n\tif (ret != sizeof(cmd->req)) {\n\t\tif (errno == EPIPE)\n\t\t\tgoto epipe;\n\t\tSYSERROR(\"Command %s failed to send req to \\\"@%s\\\" %d.\",\n\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\tif (ret >=0)\n\t\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (cmd->req.datalen > 0) {\n\t\tret = send(sock, cmd->req.data, cmd->req.datalen, MSG_NOSIGNAL);\n\t\tif (ret != cmd->req.datalen) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tgoto epipe;\n\t\t\tSYSERROR(\"Command %s failed to send request data to \\\"@%s\\\" %d.\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\t\tif (ret >=0)\n\t\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = lxc_cmd_rsp_recv(sock, cmd);\nout:\n\tif (!stay_connected || ret <= 0)\n\t\tclose(sock);\n\tif (stay_connected && ret > 0)\n\t\tcmd->rsp.ret = sock;\n\n\treturn ret;\n\nepipe:\n\tclose(sock);\n\t*stopped = 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nchar *lxc_cmd_get_name(const char *hashed_sock_name)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_GET_NAME},\n\t};\n\n\tret = lxc_cmd(NULL, &cmd, &stopped, NULL, hashed_sock_name);\n\tif (ret < 0) {\n\t\treturn NULL;\n\t}\n\n\tif (cmd.rsp.ret == 0)\n\t\treturn cmd.rsp.data;\n\treturn NULL;\n}"
  },
  {
    "function_name": "lxc_cmd_console_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
    "lines": "734-760",
    "snippet": "static int lxc_cmd_console_callback(int fd, struct lxc_cmd_req *req,\n\t\t\t\t    struct lxc_handler *handler)\n{\n\tint ttynum = PTR_TO_INT(req->data);\n\tint masterfd;\n\tstruct lxc_cmd_rsp rsp;\n\n\tmasterfd = lxc_console_allocate(handler->conf, fd, &ttynum);\n\tif (masterfd < 0)\n\t\tgoto out_close;\n\n\tmemset(&rsp, 0, sizeof(rsp));\n\trsp.data = INT_TO_PTR(ttynum);\n\tif (lxc_abstract_unix_send_fd(fd, masterfd, &rsp, sizeof(rsp)) < 0) {\n\t\tERROR(\"Failed to send tty to client.\");\n\t\tlxc_console_free(handler->conf, fd);\n\t\tgoto out_close;\n\t}\n\n\treturn 0;\n\nout_close:\n\t/* special indicator to lxc_cmd_handler() to close the fd and do\n\t * related cleanup\n\t */\n\treturn 1;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"af_unix.h\"",
      "#include \"mainloop.h\"",
      "#include \"confile.h\"",
      "#include \"console.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"utils.h\"",
      "#include \"start.h\"\t/* for struct lxc_handler */",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/un.h>",
      "#include <inttypes.h>",
      "#include <sys/socket.h>",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_console_free",
          "args": [
            "handler->conf",
            "fd"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_console_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
          "lines": "401-416",
          "snippet": "void lxc_console_free(struct lxc_conf *conf, int fd)\n{\n\tint i;\n\tstruct lxc_tty_info *tty_info = &conf->tty_info;\n\tstruct lxc_console *console = &conf->console;\n\n\tfor (i = 0; i < tty_info->nbtty; i++) {\n\t\tif (tty_info->pty_info[i].busy == fd)\n\t\t\ttty_info->pty_info[i].busy = 0;\n\t}\n\n\tif (console->peerpty.busy == fd) {\n\t\tlxc_mainloop_del_handler(console->descr, console->peerpty.slave);\n\t\tlxc_console_peer_proxy_free(console);\n\t}\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"start.h\" \t/* for struct lxc_handler */",
            "#include \"mainloop.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"caps.h\"",
            "#include \"af_unix.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nvoid lxc_console_free(struct lxc_conf *conf, int fd)\n{\n\tint i;\n\tstruct lxc_tty_info *tty_info = &conf->tty_info;\n\tstruct lxc_console *console = &conf->console;\n\n\tfor (i = 0; i < tty_info->nbtty; i++) {\n\t\tif (tty_info->pty_info[i].busy == fd)\n\t\t\ttty_info->pty_info[i].busy = 0;\n\t}\n\n\tif (console->peerpty.busy == fd) {\n\t\tlxc_mainloop_del_handler(console->descr, console->peerpty.slave);\n\t\tlxc_console_peer_proxy_free(console);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to send tty to client.\""
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_abstract_unix_send_fd",
          "args": [
            "fd",
            "masterfd",
            "&rsp",
            "sizeof(rsp)"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_send_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "134-162",
          "snippet": "int lxc_abstract_unix_send_fd(int fd, int sendfd, void *data, size_t size)\n{\n\tstruct msghdr msg = { 0 };\n\tstruct iovec iov;\n\tstruct cmsghdr *cmsg;\n\tchar cmsgbuf[CMSG_SPACE(sizeof(int))];\n\tchar buf[1];\n\tint *val;\n\n\tmsg.msg_control = cmsgbuf;\n\tmsg.msg_controllen = sizeof(cmsgbuf);\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(int));\n\tcmsg->cmsg_level = SOL_SOCKET;\n\tcmsg->cmsg_type = SCM_RIGHTS;\n\tval = (int *)(CMSG_DATA(cmsg));\n\t*val = sendfd;\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_namelen = 0;\n\n\tiov.iov_base = data ? data : buf;\n\tiov.iov_len = data ? size : sizeof(buf);\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\treturn sendmsg(fd, &msg, MSG_NOSIGNAL);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_send_fd(int fd, int sendfd, void *data, size_t size)\n{\n\tstruct msghdr msg = { 0 };\n\tstruct iovec iov;\n\tstruct cmsghdr *cmsg;\n\tchar cmsgbuf[CMSG_SPACE(sizeof(int))];\n\tchar buf[1];\n\tint *val;\n\n\tmsg.msg_control = cmsgbuf;\n\tmsg.msg_controllen = sizeof(cmsgbuf);\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(int));\n\tcmsg->cmsg_level = SOL_SOCKET;\n\tcmsg->cmsg_type = SCM_RIGHTS;\n\tval = (int *)(CMSG_DATA(cmsg));\n\t*val = sendfd;\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_namelen = 0;\n\n\tiov.iov_base = data ? data : buf;\n\tiov.iov_len = data ? size : sizeof(buf);\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\treturn sendmsg(fd, &msg, MSG_NOSIGNAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INT_TO_PTR",
          "args": [
            "ttynum"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&rsp",
            "0",
            "sizeof(rsp)"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_console_allocate",
          "args": [
            "handler->conf",
            "fd",
            "&ttynum"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_console_allocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
          "lines": "359-399",
          "snippet": "int lxc_console_allocate(struct lxc_conf *conf, int sockfd, int *ttyreq)\n{\n\tint masterfd = -1, ttynum;\n\tstruct lxc_tty_info *tty_info = &conf->tty_info;\n\tstruct lxc_console *console = &conf->console;\n\n\tif (*ttyreq == 0) {\n\t\tif (lxc_console_peer_proxy_alloc(console, sockfd) < 0)\n\t\t\tgoto out;\n\t\tmasterfd = console->peerpty.master;\n\t\tgoto out;\n\t}\n\n\tif (*ttyreq > 0) {\n\t\tif (*ttyreq > tty_info->nbtty)\n\t\t\tgoto out;\n\n\t\tif (tty_info->pty_info[*ttyreq - 1].busy)\n\t\t\tgoto out;\n\n\t\t/* the requested tty is available */\n\t\tttynum = *ttyreq;\n\t\tgoto out_tty;\n\t}\n\n\t/* search for next available tty, fixup index tty1 => [0] */\n\tfor (ttynum = 1; ttynum <= tty_info->nbtty && tty_info->pty_info[ttynum - 1].busy; ttynum++)\n\t\t;\n\n\t/* we didn't find any available slot for tty */\n\tif (ttynum > tty_info->nbtty)\n\t\tgoto out;\n\n\t*ttyreq = ttynum;\n\nout_tty:\n\ttty_info->pty_info[ttynum - 1].busy = sockfd;\n\tmasterfd = tty_info->pty_info[ttynum - 1].master;\nout:\n\treturn masterfd;\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"start.h\" \t/* for struct lxc_handler */",
            "#include \"mainloop.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"caps.h\"",
            "#include \"af_unix.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_console_allocate(struct lxc_conf *conf, int sockfd, int *ttyreq)\n{\n\tint masterfd = -1, ttynum;\n\tstruct lxc_tty_info *tty_info = &conf->tty_info;\n\tstruct lxc_console *console = &conf->console;\n\n\tif (*ttyreq == 0) {\n\t\tif (lxc_console_peer_proxy_alloc(console, sockfd) < 0)\n\t\t\tgoto out;\n\t\tmasterfd = console->peerpty.master;\n\t\tgoto out;\n\t}\n\n\tif (*ttyreq > 0) {\n\t\tif (*ttyreq > tty_info->nbtty)\n\t\t\tgoto out;\n\n\t\tif (tty_info->pty_info[*ttyreq - 1].busy)\n\t\t\tgoto out;\n\n\t\t/* the requested tty is available */\n\t\tttynum = *ttyreq;\n\t\tgoto out_tty;\n\t}\n\n\t/* search for next available tty, fixup index tty1 => [0] */\n\tfor (ttynum = 1; ttynum <= tty_info->nbtty && tty_info->pty_info[ttynum - 1].busy; ttynum++)\n\t\t;\n\n\t/* we didn't find any available slot for tty */\n\tif (ttynum > tty_info->nbtty)\n\t\tgoto out;\n\n\t*ttyreq = ttynum;\n\nout_tty:\n\ttty_info->pty_info[ttynum - 1].busy = sockfd;\n\tmasterfd = tty_info->pty_info[ttynum - 1].master;\nout:\n\treturn masterfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_TO_INT",
          "args": [
            "req->data"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd_console_callback(int fd, struct lxc_cmd_req *req,\n\t\t\t\t    struct lxc_handler *handler)\n{\n\tint ttynum = PTR_TO_INT(req->data);\n\tint masterfd;\n\tstruct lxc_cmd_rsp rsp;\n\n\tmasterfd = lxc_console_allocate(handler->conf, fd, &ttynum);\n\tif (masterfd < 0)\n\t\tgoto out_close;\n\n\tmemset(&rsp, 0, sizeof(rsp));\n\trsp.data = INT_TO_PTR(ttynum);\n\tif (lxc_abstract_unix_send_fd(fd, masterfd, &rsp, sizeof(rsp)) < 0) {\n\t\tERROR(\"Failed to send tty to client.\");\n\t\tlxc_console_free(handler->conf, fd);\n\t\tgoto out_close;\n\t}\n\n\treturn 0;\n\nout_close:\n\t/* special indicator to lxc_cmd_handler() to close the fd and do\n\t * related cleanup\n\t */\n\treturn 1;\n}"
  },
  {
    "function_name": "lxc_cmd_console",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
    "lines": "695-732",
    "snippet": "int lxc_cmd_console(const char *name, int *ttynum, int *fd, const char *lxcpath)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_console_rsp_data *rspdata;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_CONSOLE, .data = INT_TO_PTR(*ttynum) },\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (cmd.rsp.ret < 0) {\n\t\tERROR(\"Console access denied: %s.\", strerror(-cmd.rsp.ret));\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (ret == 0) {\n\t\tERROR(\"Console %d invalid, busy or all consoles busy.\", *ttynum);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\trspdata = cmd.rsp.data;\n\tif (rspdata->masterfd < 0) {\n\t\tERROR(\"Unable to allocate fd for tty %d.\", rspdata->ttynum);\n\t\tgoto out;\n\t}\n\n\tret = cmd.rsp.ret;\t/* sock fd */\n\t*fd = rspdata->masterfd;\n\t*ttynum = rspdata->ttynum;\n\tINFO(\"tty %d allocated fd %d sock %d.\", rspdata->ttynum, *fd, ret);\nout:\n\tfree(cmd.rsp.data);\n\treturn ret;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"af_unix.h\"",
      "#include \"mainloop.h\"",
      "#include \"confile.h\"",
      "#include \"console.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"utils.h\"",
      "#include \"start.h\"\t/* for struct lxc_handler */",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/un.h>",
      "#include <inttypes.h>",
      "#include <sys/socket.h>",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cmd.rsp.data"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"tty %d allocated fd %d sock %d.\"",
            "rspdata->ttynum",
            "*fd",
            "ret"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Unable to allocate fd for tty %d.\"",
            "rspdata->ttynum"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Console %d invalid, busy or all consoles busy.\"",
            "*ttynum"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Console access denied: %s.\"",
            "strerror(-cmd.rsp.ret)"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "-cmd.rsp.ret"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cmd",
          "args": [
            "name",
            "&cmd",
            "&stopped",
            "lxcpath",
            "NULL"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "271-338",
          "snippet": "static int lxc_cmd(const char *name, struct lxc_cmd_rr *cmd, int *stopped,\n\t\t   const char *lxcpath, const char *hashed_sock_name)\n{\n\tint sock, ret = -1;\n\tchar path[sizeof(((struct sockaddr_un *)0)->sun_path)] = { 0 };\n\tchar *offset = &path[1];\n\tint len;\n\tint stay_connected = cmd->req.cmd == LXC_CMD_CONSOLE;\n\n\t*stopped = 0;\n\n\t/* -2 here because this is an abstract unix socket so it needs a\n\t * leading \\0, and we null terminate, so it needs a trailing \\0.\n\t * Although null termination isn't required by the API, we do it anyway\n\t * because we print the sockname out sometimes.\n\t */\n\tlen = sizeof(path)-2;\n\tif (fill_sock_name(offset, len, name, lxcpath, hashed_sock_name))\n\t\treturn -1;\n\n\tsock = lxc_abstract_unix_connect(path);\n\tif (sock < 0) {\n\t\tif (errno == ECONNREFUSED)\n\t\t\t*stopped = 1;\n\t\telse\n\t\t\tSYSERROR(\"Command %s failed to connect to \\\"@%s\\\".\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset);\n\t\treturn -1;\n\t}\n\n\tret = lxc_abstract_unix_send_credential(sock, &cmd->req, sizeof(cmd->req));\n\tif (ret != sizeof(cmd->req)) {\n\t\tif (errno == EPIPE)\n\t\t\tgoto epipe;\n\t\tSYSERROR(\"Command %s failed to send req to \\\"@%s\\\" %d.\",\n\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\tif (ret >=0)\n\t\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (cmd->req.datalen > 0) {\n\t\tret = send(sock, cmd->req.data, cmd->req.datalen, MSG_NOSIGNAL);\n\t\tif (ret != cmd->req.datalen) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tgoto epipe;\n\t\t\tSYSERROR(\"Command %s failed to send request data to \\\"@%s\\\" %d.\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\t\tif (ret >=0)\n\t\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = lxc_cmd_rsp_recv(sock, cmd);\nout:\n\tif (!stay_connected || ret <= 0)\n\t\tclose(sock);\n\tif (stay_connected && ret > 0)\n\t\tcmd->rsp.ret = sock;\n\n\treturn ret;\n\nepipe:\n\tclose(sock);\n\t*stopped = 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd(const char *name, struct lxc_cmd_rr *cmd, int *stopped,\n\t\t   const char *lxcpath, const char *hashed_sock_name)\n{\n\tint sock, ret = -1;\n\tchar path[sizeof(((struct sockaddr_un *)0)->sun_path)] = { 0 };\n\tchar *offset = &path[1];\n\tint len;\n\tint stay_connected = cmd->req.cmd == LXC_CMD_CONSOLE;\n\n\t*stopped = 0;\n\n\t/* -2 here because this is an abstract unix socket so it needs a\n\t * leading \\0, and we null terminate, so it needs a trailing \\0.\n\t * Although null termination isn't required by the API, we do it anyway\n\t * because we print the sockname out sometimes.\n\t */\n\tlen = sizeof(path)-2;\n\tif (fill_sock_name(offset, len, name, lxcpath, hashed_sock_name))\n\t\treturn -1;\n\n\tsock = lxc_abstract_unix_connect(path);\n\tif (sock < 0) {\n\t\tif (errno == ECONNREFUSED)\n\t\t\t*stopped = 1;\n\t\telse\n\t\t\tSYSERROR(\"Command %s failed to connect to \\\"@%s\\\".\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset);\n\t\treturn -1;\n\t}\n\n\tret = lxc_abstract_unix_send_credential(sock, &cmd->req, sizeof(cmd->req));\n\tif (ret != sizeof(cmd->req)) {\n\t\tif (errno == EPIPE)\n\t\t\tgoto epipe;\n\t\tSYSERROR(\"Command %s failed to send req to \\\"@%s\\\" %d.\",\n\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\tif (ret >=0)\n\t\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (cmd->req.datalen > 0) {\n\t\tret = send(sock, cmd->req.data, cmd->req.datalen, MSG_NOSIGNAL);\n\t\tif (ret != cmd->req.datalen) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tgoto epipe;\n\t\t\tSYSERROR(\"Command %s failed to send request data to \\\"@%s\\\" %d.\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\t\tif (ret >=0)\n\t\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = lxc_cmd_rsp_recv(sock, cmd);\nout:\n\tif (!stay_connected || ret <= 0)\n\t\tclose(sock);\n\tif (stay_connected && ret > 0)\n\t\tcmd->rsp.ret = sock;\n\n\treturn ret;\n\nepipe:\n\tclose(sock);\n\t*stopped = 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INT_TO_PTR",
          "args": [
            "*ttynum"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nint lxc_cmd_console(const char *name, int *ttynum, int *fd, const char *lxcpath)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_console_rsp_data *rspdata;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_CONSOLE, .data = INT_TO_PTR(*ttynum) },\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (cmd.rsp.ret < 0) {\n\t\tERROR(\"Console access denied: %s.\", strerror(-cmd.rsp.ret));\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (ret == 0) {\n\t\tERROR(\"Console %d invalid, busy or all consoles busy.\", *ttynum);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\trspdata = cmd.rsp.data;\n\tif (rspdata->masterfd < 0) {\n\t\tERROR(\"Unable to allocate fd for tty %d.\", rspdata->ttynum);\n\t\tgoto out;\n\t}\n\n\tret = cmd.rsp.ret;\t/* sock fd */\n\t*fd = rspdata->masterfd;\n\t*ttynum = rspdata->ttynum;\n\tINFO(\"tty %d allocated fd %d sock %d.\", rspdata->ttynum, *fd, ret);\nout:\n\tfree(cmd.rsp.data);\n\treturn ret;\n}"
  },
  {
    "function_name": "lxc_cmd_console_winch_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
    "lines": "675-682",
    "snippet": "static int lxc_cmd_console_winch_callback(int fd, struct lxc_cmd_req *req,\n\t\t\t\t\t  struct lxc_handler *handler)\n{\n\tstruct lxc_cmd_rsp rsp = { .data = 0 };\n\n\tlxc_console_sigwinch(SIGWINCH);\n\treturn lxc_cmd_rsp_send(fd, &rsp);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"af_unix.h\"",
      "#include \"mainloop.h\"",
      "#include \"confile.h\"",
      "#include \"console.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"utils.h\"",
      "#include \"start.h\"\t/* for struct lxc_handler */",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/un.h>",
      "#include <inttypes.h>",
      "#include <sys/socket.h>",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_cmd_rsp_send",
          "args": [
            "fd",
            "&rsp"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_rsp_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "230-250",
          "snippet": "static int lxc_cmd_rsp_send(int fd, struct lxc_cmd_rsp *rsp)\n{\n\tint ret;\n\n\tret = send(fd, rsp, sizeof(*rsp), 0);\n\tif (ret != sizeof(*rsp)) {\n\t\tERROR(\"Failed to send command response %d: %s.\", ret,\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (rsp->datalen > 0) {\n\t\tret = send(fd, rsp->data, rsp->datalen, 0);\n\t\tif (ret != rsp->datalen) {\n\t\t\tWARN(\"Failed to send command response data %d: %s.\",\n\t\t\t     ret, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd_rsp_send(int fd, struct lxc_cmd_rsp *rsp)\n{\n\tint ret;\n\n\tret = send(fd, rsp, sizeof(*rsp), 0);\n\tif (ret != sizeof(*rsp)) {\n\t\tERROR(\"Failed to send command response %d: %s.\", ret,\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (rsp->datalen > 0) {\n\t\tret = send(fd, rsp->data, rsp->datalen, 0);\n\t\tif (ret != rsp->datalen) {\n\t\t\tWARN(\"Failed to send command response data %d: %s.\",\n\t\t\t     ret, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_console_sigwinch",
          "args": [
            "SIGWINCH"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_console_sigwinch_fini",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
          "lines": "148-156",
          "snippet": "void lxc_console_sigwinch_fini(struct lxc_tty_state *ts)\n{\n\tif (ts->sigfd >= 0)\n\t\tclose(ts->sigfd);\n\n\tlxc_list_del(&ts->node);\n\tsigprocmask(SIG_SETMASK, &ts->oldmask, NULL);\n\tfree(ts);\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"start.h\" \t/* for struct lxc_handler */",
            "#include \"mainloop.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"caps.h\"",
            "#include \"af_unix.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nvoid lxc_console_sigwinch_fini(struct lxc_tty_state *ts)\n{\n\tif (ts->sigfd >= 0)\n\t\tclose(ts->sigfd);\n\n\tlxc_list_del(&ts->node);\n\tsigprocmask(SIG_SETMASK, &ts->oldmask, NULL);\n\tfree(ts);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd_console_winch_callback(int fd, struct lxc_cmd_req *req,\n\t\t\t\t\t  struct lxc_handler *handler)\n{\n\tstruct lxc_cmd_rsp rsp = { .data = 0 };\n\n\tlxc_console_sigwinch(SIGWINCH);\n\treturn lxc_cmd_rsp_send(fd, &rsp);\n}"
  },
  {
    "function_name": "lxc_cmd_console_winch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
    "lines": "661-673",
    "snippet": "int lxc_cmd_console_winch(const char *name, const char *lxcpath)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_CONSOLE_WINCH },\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"af_unix.h\"",
      "#include \"mainloop.h\"",
      "#include \"confile.h\"",
      "#include \"console.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"utils.h\"",
      "#include \"start.h\"\t/* for struct lxc_handler */",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/un.h>",
      "#include <inttypes.h>",
      "#include <sys/socket.h>",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_cmd",
          "args": [
            "name",
            "&cmd",
            "&stopped",
            "lxcpath",
            "NULL"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "271-338",
          "snippet": "static int lxc_cmd(const char *name, struct lxc_cmd_rr *cmd, int *stopped,\n\t\t   const char *lxcpath, const char *hashed_sock_name)\n{\n\tint sock, ret = -1;\n\tchar path[sizeof(((struct sockaddr_un *)0)->sun_path)] = { 0 };\n\tchar *offset = &path[1];\n\tint len;\n\tint stay_connected = cmd->req.cmd == LXC_CMD_CONSOLE;\n\n\t*stopped = 0;\n\n\t/* -2 here because this is an abstract unix socket so it needs a\n\t * leading \\0, and we null terminate, so it needs a trailing \\0.\n\t * Although null termination isn't required by the API, we do it anyway\n\t * because we print the sockname out sometimes.\n\t */\n\tlen = sizeof(path)-2;\n\tif (fill_sock_name(offset, len, name, lxcpath, hashed_sock_name))\n\t\treturn -1;\n\n\tsock = lxc_abstract_unix_connect(path);\n\tif (sock < 0) {\n\t\tif (errno == ECONNREFUSED)\n\t\t\t*stopped = 1;\n\t\telse\n\t\t\tSYSERROR(\"Command %s failed to connect to \\\"@%s\\\".\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset);\n\t\treturn -1;\n\t}\n\n\tret = lxc_abstract_unix_send_credential(sock, &cmd->req, sizeof(cmd->req));\n\tif (ret != sizeof(cmd->req)) {\n\t\tif (errno == EPIPE)\n\t\t\tgoto epipe;\n\t\tSYSERROR(\"Command %s failed to send req to \\\"@%s\\\" %d.\",\n\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\tif (ret >=0)\n\t\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (cmd->req.datalen > 0) {\n\t\tret = send(sock, cmd->req.data, cmd->req.datalen, MSG_NOSIGNAL);\n\t\tif (ret != cmd->req.datalen) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tgoto epipe;\n\t\t\tSYSERROR(\"Command %s failed to send request data to \\\"@%s\\\" %d.\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\t\tif (ret >=0)\n\t\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = lxc_cmd_rsp_recv(sock, cmd);\nout:\n\tif (!stay_connected || ret <= 0)\n\t\tclose(sock);\n\tif (stay_connected && ret > 0)\n\t\tcmd->rsp.ret = sock;\n\n\treturn ret;\n\nepipe:\n\tclose(sock);\n\t*stopped = 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd(const char *name, struct lxc_cmd_rr *cmd, int *stopped,\n\t\t   const char *lxcpath, const char *hashed_sock_name)\n{\n\tint sock, ret = -1;\n\tchar path[sizeof(((struct sockaddr_un *)0)->sun_path)] = { 0 };\n\tchar *offset = &path[1];\n\tint len;\n\tint stay_connected = cmd->req.cmd == LXC_CMD_CONSOLE;\n\n\t*stopped = 0;\n\n\t/* -2 here because this is an abstract unix socket so it needs a\n\t * leading \\0, and we null terminate, so it needs a trailing \\0.\n\t * Although null termination isn't required by the API, we do it anyway\n\t * because we print the sockname out sometimes.\n\t */\n\tlen = sizeof(path)-2;\n\tif (fill_sock_name(offset, len, name, lxcpath, hashed_sock_name))\n\t\treturn -1;\n\n\tsock = lxc_abstract_unix_connect(path);\n\tif (sock < 0) {\n\t\tif (errno == ECONNREFUSED)\n\t\t\t*stopped = 1;\n\t\telse\n\t\t\tSYSERROR(\"Command %s failed to connect to \\\"@%s\\\".\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset);\n\t\treturn -1;\n\t}\n\n\tret = lxc_abstract_unix_send_credential(sock, &cmd->req, sizeof(cmd->req));\n\tif (ret != sizeof(cmd->req)) {\n\t\tif (errno == EPIPE)\n\t\t\tgoto epipe;\n\t\tSYSERROR(\"Command %s failed to send req to \\\"@%s\\\" %d.\",\n\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\tif (ret >=0)\n\t\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (cmd->req.datalen > 0) {\n\t\tret = send(sock, cmd->req.data, cmd->req.datalen, MSG_NOSIGNAL);\n\t\tif (ret != cmd->req.datalen) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tgoto epipe;\n\t\t\tSYSERROR(\"Command %s failed to send request data to \\\"@%s\\\" %d.\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\t\tif (ret >=0)\n\t\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = lxc_cmd_rsp_recv(sock, cmd);\nout:\n\tif (!stay_connected || ret <= 0)\n\t\tclose(sock);\n\tif (stay_connected && ret > 0)\n\t\tcmd->rsp.ret = sock;\n\n\treturn ret;\n\nepipe:\n\tclose(sock);\n\t*stopped = 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nint lxc_cmd_console_winch(const char *name, const char *lxcpath)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_CONSOLE_WINCH },\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_cmd_stop_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
    "lines": "628-651",
    "snippet": "static int lxc_cmd_stop_callback(int fd, struct lxc_cmd_req *req,\n\t\t\t\t struct lxc_handler *handler)\n{\n\tstruct lxc_cmd_rsp rsp;\n\tint stopsignal = SIGKILL;\n\n\tif (handler->conf->stopsignal)\n\t\tstopsignal = handler->conf->stopsignal;\n\tmemset(&rsp, 0, sizeof(rsp));\n\trsp.ret = kill(handler->pid, stopsignal);\n\tif (!rsp.ret) {\n\t\t/* we can't just use lxc_unfreeze() since we are already in the\n\t\t * context of handling the STOP cmd in lxc-start, and calling\n\t\t * lxc_unfreeze() would do another cmd (GET_CGROUP) which would\n\t\t * deadlock us\n\t\t */\n\t\tif (cgroup_unfreeze(handler))\n\t\t\treturn 0;\n\t\tERROR(\"Failed to unfreeze container \\\"%s\\\".\", handler->name);\n\t\trsp.ret = -1;\n\t}\n\n\treturn lxc_cmd_rsp_send(fd, &rsp);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"af_unix.h\"",
      "#include \"mainloop.h\"",
      "#include \"confile.h\"",
      "#include \"console.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"utils.h\"",
      "#include \"start.h\"\t/* for struct lxc_handler */",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/un.h>",
      "#include <inttypes.h>",
      "#include <sys/socket.h>",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_cmd_rsp_send",
          "args": [
            "fd",
            "&rsp"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_rsp_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "230-250",
          "snippet": "static int lxc_cmd_rsp_send(int fd, struct lxc_cmd_rsp *rsp)\n{\n\tint ret;\n\n\tret = send(fd, rsp, sizeof(*rsp), 0);\n\tif (ret != sizeof(*rsp)) {\n\t\tERROR(\"Failed to send command response %d: %s.\", ret,\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (rsp->datalen > 0) {\n\t\tret = send(fd, rsp->data, rsp->datalen, 0);\n\t\tif (ret != rsp->datalen) {\n\t\t\tWARN(\"Failed to send command response data %d: %s.\",\n\t\t\t     ret, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd_rsp_send(int fd, struct lxc_cmd_rsp *rsp)\n{\n\tint ret;\n\n\tret = send(fd, rsp, sizeof(*rsp), 0);\n\tif (ret != sizeof(*rsp)) {\n\t\tERROR(\"Failed to send command response %d: %s.\", ret,\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (rsp->datalen > 0) {\n\t\tret = send(fd, rsp->data, rsp->datalen, 0);\n\t\tif (ret != rsp->datalen) {\n\t\t\tWARN(\"Failed to send command response data %d: %s.\",\n\t\t\t     ret, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to unfreeze container \\\"%s\\\".\"",
            "handler->name"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_unfreeze",
          "args": [
            "handler"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgroup.c",
          "lines": "138-143",
          "snippet": "bool cgroup_unfreeze(struct lxc_handler *handler)\n{\n\tif (ops)\n\t\treturn ops->unfreeze(handler->cgroup_data);\n\treturn false;\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"log.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_ops *ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"log.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <unistd.h>\n\nstatic struct cgroup_ops *ops = NULL;\n\nbool cgroup_unfreeze(struct lxc_handler *handler)\n{\n\tif (ops)\n\t\treturn ops->unfreeze(handler->cgroup_data);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "handler->pid",
            "stopsignal"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&rsp",
            "0",
            "sizeof(rsp)"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd_stop_callback(int fd, struct lxc_cmd_req *req,\n\t\t\t\t struct lxc_handler *handler)\n{\n\tstruct lxc_cmd_rsp rsp;\n\tint stopsignal = SIGKILL;\n\n\tif (handler->conf->stopsignal)\n\t\tstopsignal = handler->conf->stopsignal;\n\tmemset(&rsp, 0, sizeof(rsp));\n\trsp.ret = kill(handler->pid, stopsignal);\n\tif (!rsp.ret) {\n\t\t/* we can't just use lxc_unfreeze() since we are already in the\n\t\t * context of handling the STOP cmd in lxc-start, and calling\n\t\t * lxc_unfreeze() would do another cmd (GET_CGROUP) which would\n\t\t * deadlock us\n\t\t */\n\t\tif (cgroup_unfreeze(handler))\n\t\t\treturn 0;\n\t\tERROR(\"Failed to unfreeze container \\\"%s\\\".\", handler->name);\n\t\trsp.ret = -1;\n\t}\n\n\treturn lxc_cmd_rsp_send(fd, &rsp);\n}"
  },
  {
    "function_name": "lxc_cmd_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
    "lines": "599-626",
    "snippet": "int lxc_cmd_stop(const char *name, const char *lxcpath)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_STOP },\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0) {\n\t\tif (stopped) {\n\t\t\tINFO(\"Container \\\"%s\\\" is already stopped.\", name);\n\t\t\treturn 0;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/* we do not expect any answer, because we wait for the connection to be\n\t * closed\n\t */\n\tif (ret > 0) {\n\t\tERROR(\"Failed to stop container \\\"%s\\\": %s.\", name,\n\t\t      strerror(-cmd.rsp.ret));\n\t\treturn -1;\n\t}\n\n\tINFO(\"Container \\\"%s\\\" has stopped.\", name);\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"af_unix.h\"",
      "#include \"mainloop.h\"",
      "#include \"confile.h\"",
      "#include \"console.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"utils.h\"",
      "#include \"start.h\"\t/* for struct lxc_handler */",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/un.h>",
      "#include <inttypes.h>",
      "#include <sys/socket.h>",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Container \\\"%s\\\" has stopped.\"",
            "name"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to stop container \\\"%s\\\": %s.\"",
            "name",
            "strerror(-cmd.rsp.ret)"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "-cmd.rsp.ret"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Container \\\"%s\\\" is already stopped.\"",
            "name"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cmd",
          "args": [
            "name",
            "&cmd",
            "&stopped",
            "lxcpath",
            "NULL"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "271-338",
          "snippet": "static int lxc_cmd(const char *name, struct lxc_cmd_rr *cmd, int *stopped,\n\t\t   const char *lxcpath, const char *hashed_sock_name)\n{\n\tint sock, ret = -1;\n\tchar path[sizeof(((struct sockaddr_un *)0)->sun_path)] = { 0 };\n\tchar *offset = &path[1];\n\tint len;\n\tint stay_connected = cmd->req.cmd == LXC_CMD_CONSOLE;\n\n\t*stopped = 0;\n\n\t/* -2 here because this is an abstract unix socket so it needs a\n\t * leading \\0, and we null terminate, so it needs a trailing \\0.\n\t * Although null termination isn't required by the API, we do it anyway\n\t * because we print the sockname out sometimes.\n\t */\n\tlen = sizeof(path)-2;\n\tif (fill_sock_name(offset, len, name, lxcpath, hashed_sock_name))\n\t\treturn -1;\n\n\tsock = lxc_abstract_unix_connect(path);\n\tif (sock < 0) {\n\t\tif (errno == ECONNREFUSED)\n\t\t\t*stopped = 1;\n\t\telse\n\t\t\tSYSERROR(\"Command %s failed to connect to \\\"@%s\\\".\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset);\n\t\treturn -1;\n\t}\n\n\tret = lxc_abstract_unix_send_credential(sock, &cmd->req, sizeof(cmd->req));\n\tif (ret != sizeof(cmd->req)) {\n\t\tif (errno == EPIPE)\n\t\t\tgoto epipe;\n\t\tSYSERROR(\"Command %s failed to send req to \\\"@%s\\\" %d.\",\n\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\tif (ret >=0)\n\t\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (cmd->req.datalen > 0) {\n\t\tret = send(sock, cmd->req.data, cmd->req.datalen, MSG_NOSIGNAL);\n\t\tif (ret != cmd->req.datalen) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tgoto epipe;\n\t\t\tSYSERROR(\"Command %s failed to send request data to \\\"@%s\\\" %d.\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\t\tif (ret >=0)\n\t\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = lxc_cmd_rsp_recv(sock, cmd);\nout:\n\tif (!stay_connected || ret <= 0)\n\t\tclose(sock);\n\tif (stay_connected && ret > 0)\n\t\tcmd->rsp.ret = sock;\n\n\treturn ret;\n\nepipe:\n\tclose(sock);\n\t*stopped = 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd(const char *name, struct lxc_cmd_rr *cmd, int *stopped,\n\t\t   const char *lxcpath, const char *hashed_sock_name)\n{\n\tint sock, ret = -1;\n\tchar path[sizeof(((struct sockaddr_un *)0)->sun_path)] = { 0 };\n\tchar *offset = &path[1];\n\tint len;\n\tint stay_connected = cmd->req.cmd == LXC_CMD_CONSOLE;\n\n\t*stopped = 0;\n\n\t/* -2 here because this is an abstract unix socket so it needs a\n\t * leading \\0, and we null terminate, so it needs a trailing \\0.\n\t * Although null termination isn't required by the API, we do it anyway\n\t * because we print the sockname out sometimes.\n\t */\n\tlen = sizeof(path)-2;\n\tif (fill_sock_name(offset, len, name, lxcpath, hashed_sock_name))\n\t\treturn -1;\n\n\tsock = lxc_abstract_unix_connect(path);\n\tif (sock < 0) {\n\t\tif (errno == ECONNREFUSED)\n\t\t\t*stopped = 1;\n\t\telse\n\t\t\tSYSERROR(\"Command %s failed to connect to \\\"@%s\\\".\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset);\n\t\treturn -1;\n\t}\n\n\tret = lxc_abstract_unix_send_credential(sock, &cmd->req, sizeof(cmd->req));\n\tif (ret != sizeof(cmd->req)) {\n\t\tif (errno == EPIPE)\n\t\t\tgoto epipe;\n\t\tSYSERROR(\"Command %s failed to send req to \\\"@%s\\\" %d.\",\n\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\tif (ret >=0)\n\t\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (cmd->req.datalen > 0) {\n\t\tret = send(sock, cmd->req.data, cmd->req.datalen, MSG_NOSIGNAL);\n\t\tif (ret != cmd->req.datalen) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tgoto epipe;\n\t\t\tSYSERROR(\"Command %s failed to send request data to \\\"@%s\\\" %d.\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\t\tif (ret >=0)\n\t\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = lxc_cmd_rsp_recv(sock, cmd);\nout:\n\tif (!stay_connected || ret <= 0)\n\t\tclose(sock);\n\tif (stay_connected && ret > 0)\n\t\tcmd->rsp.ret = sock;\n\n\treturn ret;\n\nepipe:\n\tclose(sock);\n\t*stopped = 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nint lxc_cmd_stop(const char *name, const char *lxcpath)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_STOP },\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0) {\n\t\tif (stopped) {\n\t\t\tINFO(\"Container \\\"%s\\\" is already stopped.\", name);\n\t\t\treturn 0;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/* we do not expect any answer, because we wait for the connection to be\n\t * closed\n\t */\n\tif (ret > 0) {\n\t\tERROR(\"Failed to stop container \\\"%s\\\": %s.\", name,\n\t\t      strerror(-cmd.rsp.ret));\n\t\treturn -1;\n\t}\n\n\tINFO(\"Container \\\"%s\\\" has stopped.\", name);\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_cmd_get_state_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
    "lines": "582-588",
    "snippet": "static int lxc_cmd_get_state_callback(int fd, struct lxc_cmd_req *req,\n\t\t\t\t      struct lxc_handler *handler)\n{\n\tstruct lxc_cmd_rsp rsp = { .data = INT_TO_PTR(handler->state) };\n\n\treturn lxc_cmd_rsp_send(fd, &rsp);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"af_unix.h\"",
      "#include \"mainloop.h\"",
      "#include \"confile.h\"",
      "#include \"console.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"utils.h\"",
      "#include \"start.h\"\t/* for struct lxc_handler */",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/un.h>",
      "#include <inttypes.h>",
      "#include <sys/socket.h>",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_cmd_rsp_send",
          "args": [
            "fd",
            "&rsp"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_rsp_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "230-250",
          "snippet": "static int lxc_cmd_rsp_send(int fd, struct lxc_cmd_rsp *rsp)\n{\n\tint ret;\n\n\tret = send(fd, rsp, sizeof(*rsp), 0);\n\tif (ret != sizeof(*rsp)) {\n\t\tERROR(\"Failed to send command response %d: %s.\", ret,\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (rsp->datalen > 0) {\n\t\tret = send(fd, rsp->data, rsp->datalen, 0);\n\t\tif (ret != rsp->datalen) {\n\t\t\tWARN(\"Failed to send command response data %d: %s.\",\n\t\t\t     ret, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd_rsp_send(int fd, struct lxc_cmd_rsp *rsp)\n{\n\tint ret;\n\n\tret = send(fd, rsp, sizeof(*rsp), 0);\n\tif (ret != sizeof(*rsp)) {\n\t\tERROR(\"Failed to send command response %d: %s.\", ret,\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (rsp->datalen > 0) {\n\t\tret = send(fd, rsp->data, rsp->datalen, 0);\n\t\tif (ret != rsp->datalen) {\n\t\t\tWARN(\"Failed to send command response data %d: %s.\",\n\t\t\t     ret, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INT_TO_PTR",
          "args": [
            "handler->state"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd_get_state_callback(int fd, struct lxc_cmd_req *req,\n\t\t\t\t      struct lxc_handler *handler)\n{\n\tstruct lxc_cmd_rsp rsp = { .data = INT_TO_PTR(handler->state) };\n\n\treturn lxc_cmd_rsp_send(fd, &rsp);\n}"
  },
  {
    "function_name": "lxc_cmd_get_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
    "lines": "558-580",
    "snippet": "lxc_state_t lxc_cmd_get_state(const char *name, const char *lxcpath)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_GET_STATE }\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0 && stopped)\n\t\treturn STOPPED;\n\n\tif (ret < 0)\n\t\treturn -1;\n\n\tif (!ret) {\n\t\tWARN(\"Container \\\"%s\\\" has stopped before sending its state.\", name);\n\t\treturn -1;\n\t}\n\n\tDEBUG(\"Container \\\"%s\\\" is in \\\"%s\\\" state.\", name,\n\t      lxc_state2str(PTR_TO_INT(cmd.rsp.data)));\n\treturn PTR_TO_INT(cmd.rsp.data);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"af_unix.h\"",
      "#include \"mainloop.h\"",
      "#include \"confile.h\"",
      "#include \"console.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"utils.h\"",
      "#include \"start.h\"\t/* for struct lxc_handler */",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/un.h>",
      "#include <inttypes.h>",
      "#include <sys/socket.h>",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_TO_INT",
          "args": [
            "cmd.rsp.data"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Container \\\"%s\\\" is in \\\"%s\\\" state.\"",
            "name",
            "lxc_state2str(PTR_TO_INT(cmd.rsp.data))"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_state2str",
          "args": [
            "PTR_TO_INT(cmd.rsp.data)"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_state2str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/state.c",
          "lines": "52-57",
          "snippet": "const char *lxc_state2str(lxc_state_t state)\n{\n\tif (state < STOPPED || state > MAX_STATE - 1)\n\t\treturn NULL;\n\treturn strstate[state];\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"monitor.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const strstate[] = {\n\t\"STOPPED\", \"STARTING\", \"RUNNING\", \"STOPPING\",\n\t\"ABORTING\", \"FREEZING\", \"FROZEN\", \"THAWED\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"monitor.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic const char * const strstate[] = {\n\t\"STOPPED\", \"STARTING\", \"RUNNING\", \"STOPPING\",\n\t\"ABORTING\", \"FREEZING\", \"FROZEN\", \"THAWED\",\n};\n\nconst char *lxc_state2str(lxc_state_t state)\n{\n\tif (state < STOPPED || state > MAX_STATE - 1)\n\t\treturn NULL;\n\treturn strstate[state];\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_TO_INT",
          "args": [
            "cmd.rsp.data"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Container \\\"%s\\\" has stopped before sending its state.\"",
            "name"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cmd",
          "args": [
            "name",
            "&cmd",
            "&stopped",
            "lxcpath",
            "NULL"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "271-338",
          "snippet": "static int lxc_cmd(const char *name, struct lxc_cmd_rr *cmd, int *stopped,\n\t\t   const char *lxcpath, const char *hashed_sock_name)\n{\n\tint sock, ret = -1;\n\tchar path[sizeof(((struct sockaddr_un *)0)->sun_path)] = { 0 };\n\tchar *offset = &path[1];\n\tint len;\n\tint stay_connected = cmd->req.cmd == LXC_CMD_CONSOLE;\n\n\t*stopped = 0;\n\n\t/* -2 here because this is an abstract unix socket so it needs a\n\t * leading \\0, and we null terminate, so it needs a trailing \\0.\n\t * Although null termination isn't required by the API, we do it anyway\n\t * because we print the sockname out sometimes.\n\t */\n\tlen = sizeof(path)-2;\n\tif (fill_sock_name(offset, len, name, lxcpath, hashed_sock_name))\n\t\treturn -1;\n\n\tsock = lxc_abstract_unix_connect(path);\n\tif (sock < 0) {\n\t\tif (errno == ECONNREFUSED)\n\t\t\t*stopped = 1;\n\t\telse\n\t\t\tSYSERROR(\"Command %s failed to connect to \\\"@%s\\\".\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset);\n\t\treturn -1;\n\t}\n\n\tret = lxc_abstract_unix_send_credential(sock, &cmd->req, sizeof(cmd->req));\n\tif (ret != sizeof(cmd->req)) {\n\t\tif (errno == EPIPE)\n\t\t\tgoto epipe;\n\t\tSYSERROR(\"Command %s failed to send req to \\\"@%s\\\" %d.\",\n\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\tif (ret >=0)\n\t\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (cmd->req.datalen > 0) {\n\t\tret = send(sock, cmd->req.data, cmd->req.datalen, MSG_NOSIGNAL);\n\t\tif (ret != cmd->req.datalen) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tgoto epipe;\n\t\t\tSYSERROR(\"Command %s failed to send request data to \\\"@%s\\\" %d.\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\t\tif (ret >=0)\n\t\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = lxc_cmd_rsp_recv(sock, cmd);\nout:\n\tif (!stay_connected || ret <= 0)\n\t\tclose(sock);\n\tif (stay_connected && ret > 0)\n\t\tcmd->rsp.ret = sock;\n\n\treturn ret;\n\nepipe:\n\tclose(sock);\n\t*stopped = 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd(const char *name, struct lxc_cmd_rr *cmd, int *stopped,\n\t\t   const char *lxcpath, const char *hashed_sock_name)\n{\n\tint sock, ret = -1;\n\tchar path[sizeof(((struct sockaddr_un *)0)->sun_path)] = { 0 };\n\tchar *offset = &path[1];\n\tint len;\n\tint stay_connected = cmd->req.cmd == LXC_CMD_CONSOLE;\n\n\t*stopped = 0;\n\n\t/* -2 here because this is an abstract unix socket so it needs a\n\t * leading \\0, and we null terminate, so it needs a trailing \\0.\n\t * Although null termination isn't required by the API, we do it anyway\n\t * because we print the sockname out sometimes.\n\t */\n\tlen = sizeof(path)-2;\n\tif (fill_sock_name(offset, len, name, lxcpath, hashed_sock_name))\n\t\treturn -1;\n\n\tsock = lxc_abstract_unix_connect(path);\n\tif (sock < 0) {\n\t\tif (errno == ECONNREFUSED)\n\t\t\t*stopped = 1;\n\t\telse\n\t\t\tSYSERROR(\"Command %s failed to connect to \\\"@%s\\\".\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset);\n\t\treturn -1;\n\t}\n\n\tret = lxc_abstract_unix_send_credential(sock, &cmd->req, sizeof(cmd->req));\n\tif (ret != sizeof(cmd->req)) {\n\t\tif (errno == EPIPE)\n\t\t\tgoto epipe;\n\t\tSYSERROR(\"Command %s failed to send req to \\\"@%s\\\" %d.\",\n\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\tif (ret >=0)\n\t\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (cmd->req.datalen > 0) {\n\t\tret = send(sock, cmd->req.data, cmd->req.datalen, MSG_NOSIGNAL);\n\t\tif (ret != cmd->req.datalen) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tgoto epipe;\n\t\t\tSYSERROR(\"Command %s failed to send request data to \\\"@%s\\\" %d.\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\t\tif (ret >=0)\n\t\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = lxc_cmd_rsp_recv(sock, cmd);\nout:\n\tif (!stay_connected || ret <= 0)\n\t\tclose(sock);\n\tif (stay_connected && ret > 0)\n\t\tcmd->rsp.ret = sock;\n\n\treturn ret;\n\nepipe:\n\tclose(sock);\n\t*stopped = 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nlxc_state_t lxc_cmd_get_state(const char *name, const char *lxcpath)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_GET_STATE }\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0 && stopped)\n\t\treturn STOPPED;\n\n\tif (ret < 0)\n\t\treturn -1;\n\n\tif (!ret) {\n\t\tWARN(\"Container \\\"%s\\\" has stopped before sending its state.\", name);\n\t\treturn -1;\n\t}\n\n\tDEBUG(\"Container \\\"%s\\\" is in \\\"%s\\\" state.\", name,\n\t      lxc_state2str(PTR_TO_INT(cmd.rsp.data)));\n\treturn PTR_TO_INT(cmd.rsp.data);\n}"
  },
  {
    "function_name": "lxc_cmd_get_config_item_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
    "lines": "523-548",
    "snippet": "static int lxc_cmd_get_config_item_callback(int fd, struct lxc_cmd_req *req,\n\t\t\t\t\t    struct lxc_handler *handler)\n{\n\tint cilen;\n\tstruct lxc_cmd_rsp rsp;\n\tchar *cidata;\n\n\tmemset(&rsp, 0, sizeof(rsp));\n\tcilen = lxc_get_config_item(handler->conf, req->data, NULL, 0);\n\tif (cilen <= 0)\n\t\tgoto err1;\n\n\tcidata = alloca(cilen + 1);\n\tif (lxc_get_config_item(handler->conf, req->data, cidata, cilen + 1) != cilen)\n\t\tgoto err1;\n\tcidata[cilen] = '\\0';\n\trsp.data = cidata;\n\trsp.datalen = cilen + 1;\n\trsp.ret = 0;\n\tgoto out;\n\nerr1:\n\trsp.ret = -1;\nout:\n\treturn lxc_cmd_rsp_send(fd, &rsp);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"af_unix.h\"",
      "#include \"mainloop.h\"",
      "#include \"confile.h\"",
      "#include \"console.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"utils.h\"",
      "#include \"start.h\"\t/* for struct lxc_handler */",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/un.h>",
      "#include <inttypes.h>",
      "#include <sys/socket.h>",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_cmd_rsp_send",
          "args": [
            "fd",
            "&rsp"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_rsp_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "230-250",
          "snippet": "static int lxc_cmd_rsp_send(int fd, struct lxc_cmd_rsp *rsp)\n{\n\tint ret;\n\n\tret = send(fd, rsp, sizeof(*rsp), 0);\n\tif (ret != sizeof(*rsp)) {\n\t\tERROR(\"Failed to send command response %d: %s.\", ret,\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (rsp->datalen > 0) {\n\t\tret = send(fd, rsp->data, rsp->datalen, 0);\n\t\tif (ret != rsp->datalen) {\n\t\t\tWARN(\"Failed to send command response data %d: %s.\",\n\t\t\t     ret, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd_rsp_send(int fd, struct lxc_cmd_rsp *rsp)\n{\n\tint ret;\n\n\tret = send(fd, rsp, sizeof(*rsp), 0);\n\tif (ret != sizeof(*rsp)) {\n\t\tERROR(\"Failed to send command response %d: %s.\", ret,\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (rsp->datalen > 0) {\n\t\tret = send(fd, rsp->data, rsp->datalen, 0);\n\t\tif (ret != rsp->datalen) {\n\t\t\tWARN(\"Failed to send command response data %d: %s.\",\n\t\t\t     ret, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_get_config_item",
          "args": [
            "handler->conf",
            "req->data",
            "cidata",
            "cilen + 1"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_get_config_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/confile.c",
          "lines": "2598-2688",
          "snippet": "int lxc_get_config_item(struct lxc_conf *c, const char *key, char *retv,\n\t\t\tint inlen)\n{\n\tconst char *v = NULL;\n\n\tif (strcmp(key, \"lxc.mount.entry\") == 0)\n\t\treturn lxc_get_mount_entries(c, retv, inlen);\n\telse if (strcmp(key, \"lxc.mount.auto\") == 0)\n\t\treturn lxc_get_auto_mounts(c, retv, inlen);\n\telse if (strcmp(key, \"lxc.mount\") == 0)\n\t\tv = c->fstab;\n\telse if (strcmp(key, \"lxc.tty\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->tty);\n\telse if (strcmp(key, \"lxc.pts\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->pts);\n\telse if (strcmp(key, \"lxc.devttydir\") == 0)\n\t\tv = c->ttydir;\n\telse if (strcmp(key, \"lxc.arch\") == 0)\n\t\treturn lxc_get_arch_entry(c, retv, inlen);\n\telse if (strcmp(key, \"lxc.aa_profile\") == 0)\n\t\tv = c->lsm_aa_profile;\n\telse if (strcmp(key, \"lxc.aa_allow_incomplete\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->lsm_aa_allow_incomplete);\n\telse if (strcmp(key, \"lxc.se_context\") == 0)\n\t\tv = c->lsm_se_context;\n\telse if (strcmp(key, \"lxc.logfile\") == 0)\n\t\tv = c->logfile;\n\telse if (strcmp(key, \"lxc.loglevel\") == 0)\n\t\tv = lxc_log_priority_to_string(c->loglevel);\n\telse if (strcmp(key, \"lxc.cgroup\") == 0) // all cgroup info\n\t\treturn lxc_get_cgroup_entry(c, retv, inlen, \"all\");\n\telse if (strncmp(key, \"lxc.cgroup.\", 11) == 0) // specific cgroup info\n\t\treturn lxc_get_cgroup_entry(c, retv, inlen, key + 11);\n\telse if (strcmp(key, \"lxc.utsname\") == 0)\n\t\tv = c->utsname ? c->utsname->nodename : NULL;\n\telse if (strcmp(key, \"lxc.console.logfile\") == 0)\n\t\tv = c->console.log_path;\n\telse if (strcmp(key, \"lxc.console\") == 0)\n\t\tv = c->console.path;\n\telse if (strcmp(key, \"lxc.rootfs.mount\") == 0)\n\t\tv = c->rootfs.mount;\n\telse if (strcmp(key, \"lxc.rootfs.backend\") == 0)\n\t\tv = c->rootfs.bdev_type;\n\telse if (strcmp(key, \"lxc.rootfs.options\") == 0)\n\t\tv = c->rootfs.options;\n\telse if (strcmp(key, \"lxc.rootfs\") == 0)\n\t\tv = c->rootfs.path;\n\telse if (strcmp(key, \"lxc.cap.drop\") == 0)\n\t\treturn lxc_get_item_cap_drop(c, retv, inlen);\n\telse if (strcmp(key, \"lxc.cap.keep\") == 0)\n\t\treturn lxc_get_item_cap_keep(c, retv, inlen);\n\telse if (strncmp(key, \"lxc.hook\", 8) == 0)\n\t\treturn lxc_get_item_hooks(c, retv, inlen, key);\n\telse if (strcmp(key, \"lxc.network\") == 0)\n\t\treturn lxc_get_item_network(c, retv, inlen);\n\telse if (strncmp(key, \"lxc.network.\", 12) == 0)\n\t\treturn lxc_get_item_nic(c, retv, inlen, key + 12);\n\telse if (strcmp(key, \"lxc.start.auto\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->start_auto);\n\telse if (strcmp(key, \"lxc.start.delay\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->start_delay);\n\telse if (strcmp(key, \"lxc.start.order\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->start_order);\n\telse if (strcmp(key, \"lxc.monitor.unshare\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->monitor_unshare);\n\telse if (strcmp(key, \"lxc.group\") == 0)\n\t\treturn lxc_get_item_groups(c, retv, inlen);\n\telse if (strcmp(key, \"lxc.seccomp\") == 0)\n\t\tv = c->seccomp;\n\telse if (strcmp(key, \"lxc.environment\") == 0)\n\t\treturn lxc_get_item_environment(c, retv, inlen);\n\telse if (strcmp(key, \"lxc.init_cmd\") == 0)\n\t\tv = c->init_cmd;\n\telse if (strcmp(key, \"lxc.init_uid\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->init_uid);\n\telse if (strcmp(key, \"lxc.init_gid\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->init_gid);\n\telse if (strcmp(key, \"lxc.ephemeral\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->ephemeral);\n\telse if (strcmp(key, \"lxc.syslog\") == 0)\n\t\tv = c->syslog;\n\telse if (strcmp(key, \"lxc.no_new_privs\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->no_new_privs);\n\telse return -1;\n\n\tif (!v)\n\t\treturn 0;\n\tif (retv && inlen >= strlen(v) + 1)\n\t\tstrncpy(retv, v, strlen(v)+1);\n\treturn strlen(v);\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"network.h\"",
            "#include \"conf.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"confile.h\"",
            "#include \"config.h\"",
            "#include \"parse.h\"",
            "#include \"bdev.h\"",
            "#include <syslog.h>",
            "#include <dirent.h>",
            "#include <time.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int config_personality(const char *, const char *, struct lxc_conf *);",
            "static int config_pts(const char *, const char *, struct lxc_conf *);",
            "static int config_tty(const char *, const char *, struct lxc_conf *);",
            "static int config_ttydir(const char *, const char *, struct lxc_conf *);",
            "static int config_kmsg(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_aa_profile(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_aa_incomplete(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_se_context(const char *, const char *, struct lxc_conf *);",
            "static int config_cgroup(const char *, const char *, struct lxc_conf *);",
            "static int config_idmap(const char *, const char *, struct lxc_conf *);",
            "static int config_loglevel(const char *, const char *, struct lxc_conf *);",
            "static int config_logfile(const char *, const char *, struct lxc_conf *);",
            "static int config_mount(const char *, const char *, struct lxc_conf *);",
            "static int config_mount_auto(const char *, const char *, struct lxc_conf *);",
            "static int config_fstab(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_mount(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_options(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_backend(const char *, const char *, struct lxc_conf *);",
            "static int config_pivotdir(const char *, const char *, struct lxc_conf *);",
            "static int config_utsname(const char *, const char *, struct lxc_conf *);",
            "static int config_hook(const char *, const char *, struct lxc_conf *lxc_conf);",
            "static int config_network(const char *, const char *, struct lxc_conf *);",
            "static int config_network_type(const char *, const char *, struct lxc_conf *);",
            "static int config_network_flags(const char *, const char *, struct lxc_conf *);",
            "static int config_network_link(const char *, const char *, struct lxc_conf *);",
            "static int config_network_name(const char *, const char *, struct lxc_conf *);",
            "static int config_network_veth_pair(const char *, const char *, struct lxc_conf *);",
            "static int config_network_macvlan_mode(const char *, const char *, struct lxc_conf *);",
            "static int config_network_hwaddr(const char *, const char *, struct lxc_conf *);",
            "static int config_network_vlan_id(const char *, const char *, struct lxc_conf *);",
            "static int config_network_mtu(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv4(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv4_gateway(const char *, const char *, struct lxc_conf *);",
            "static int config_network_script_up(const char *, const char *, struct lxc_conf *);",
            "static int config_network_script_down(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv6(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv6_gateway(const char *, const char *, struct lxc_conf *);",
            "static int config_cap_drop(const char *, const char *, struct lxc_conf *);",
            "static int config_cap_keep(const char *, const char *, struct lxc_conf *);",
            "static int config_console(const char *, const char *, struct lxc_conf *);",
            "static int config_console_logfile(const char *, const char *, struct lxc_conf *);",
            "static int config_seccomp(const char *, const char *, struct lxc_conf *);",
            "static int config_includefile(const char *, const char *, struct lxc_conf *);",
            "static int config_network_nic(const char *, const char *, struct lxc_conf *);",
            "static int config_autodev(const char *, const char *, struct lxc_conf *);",
            "static int config_haltsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_rebootsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_stopsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_start(const char *, const char *, struct lxc_conf *);",
            "static int config_syslog(const char *, const char *, struct lxc_conf *);",
            "static int config_monitor(const char *, const char *, struct lxc_conf *);",
            "static int config_group(const char *, const char *, struct lxc_conf *);",
            "static int config_environment(const char *, const char *, struct lxc_conf *);",
            "static int config_init_cmd(const char *, const char *, struct lxc_conf *);",
            "static int config_init_uid(const char *, const char *, struct lxc_conf *);",
            "static int config_init_gid(const char *, const char *, struct lxc_conf *);",
            "static int config_ephemeral(const char *, const char *, struct lxc_conf *);",
            "static int config_no_new_privs(const char *, const char *, struct lxc_conf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"lxcseccomp.h\"\n#include \"network.h\"\n#include \"conf.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"confile.h\"\n#include \"config.h\"\n#include \"parse.h\"\n#include \"bdev.h\"\n#include <syslog.h>\n#include <dirent.h>\n#include <time.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int config_personality(const char *, const char *, struct lxc_conf *);\nstatic int config_pts(const char *, const char *, struct lxc_conf *);\nstatic int config_tty(const char *, const char *, struct lxc_conf *);\nstatic int config_ttydir(const char *, const char *, struct lxc_conf *);\nstatic int config_kmsg(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_aa_profile(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_aa_incomplete(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_se_context(const char *, const char *, struct lxc_conf *);\nstatic int config_cgroup(const char *, const char *, struct lxc_conf *);\nstatic int config_idmap(const char *, const char *, struct lxc_conf *);\nstatic int config_loglevel(const char *, const char *, struct lxc_conf *);\nstatic int config_logfile(const char *, const char *, struct lxc_conf *);\nstatic int config_mount(const char *, const char *, struct lxc_conf *);\nstatic int config_mount_auto(const char *, const char *, struct lxc_conf *);\nstatic int config_fstab(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_mount(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_options(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_backend(const char *, const char *, struct lxc_conf *);\nstatic int config_pivotdir(const char *, const char *, struct lxc_conf *);\nstatic int config_utsname(const char *, const char *, struct lxc_conf *);\nstatic int config_hook(const char *, const char *, struct lxc_conf *lxc_conf);\nstatic int config_network(const char *, const char *, struct lxc_conf *);\nstatic int config_network_type(const char *, const char *, struct lxc_conf *);\nstatic int config_network_flags(const char *, const char *, struct lxc_conf *);\nstatic int config_network_link(const char *, const char *, struct lxc_conf *);\nstatic int config_network_name(const char *, const char *, struct lxc_conf *);\nstatic int config_network_veth_pair(const char *, const char *, struct lxc_conf *);\nstatic int config_network_macvlan_mode(const char *, const char *, struct lxc_conf *);\nstatic int config_network_hwaddr(const char *, const char *, struct lxc_conf *);\nstatic int config_network_vlan_id(const char *, const char *, struct lxc_conf *);\nstatic int config_network_mtu(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv4(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv4_gateway(const char *, const char *, struct lxc_conf *);\nstatic int config_network_script_up(const char *, const char *, struct lxc_conf *);\nstatic int config_network_script_down(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv6(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv6_gateway(const char *, const char *, struct lxc_conf *);\nstatic int config_cap_drop(const char *, const char *, struct lxc_conf *);\nstatic int config_cap_keep(const char *, const char *, struct lxc_conf *);\nstatic int config_console(const char *, const char *, struct lxc_conf *);\nstatic int config_console_logfile(const char *, const char *, struct lxc_conf *);\nstatic int config_seccomp(const char *, const char *, struct lxc_conf *);\nstatic int config_includefile(const char *, const char *, struct lxc_conf *);\nstatic int config_network_nic(const char *, const char *, struct lxc_conf *);\nstatic int config_autodev(const char *, const char *, struct lxc_conf *);\nstatic int config_haltsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_rebootsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_stopsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_start(const char *, const char *, struct lxc_conf *);\nstatic int config_syslog(const char *, const char *, struct lxc_conf *);\nstatic int config_monitor(const char *, const char *, struct lxc_conf *);\nstatic int config_group(const char *, const char *, struct lxc_conf *);\nstatic int config_environment(const char *, const char *, struct lxc_conf *);\nstatic int config_init_cmd(const char *, const char *, struct lxc_conf *);\nstatic int config_init_uid(const char *, const char *, struct lxc_conf *);\nstatic int config_init_gid(const char *, const char *, struct lxc_conf *);\nstatic int config_ephemeral(const char *, const char *, struct lxc_conf *);\nstatic int config_no_new_privs(const char *, const char *, struct lxc_conf *);\n\nint lxc_get_config_item(struct lxc_conf *c, const char *key, char *retv,\n\t\t\tint inlen)\n{\n\tconst char *v = NULL;\n\n\tif (strcmp(key, \"lxc.mount.entry\") == 0)\n\t\treturn lxc_get_mount_entries(c, retv, inlen);\n\telse if (strcmp(key, \"lxc.mount.auto\") == 0)\n\t\treturn lxc_get_auto_mounts(c, retv, inlen);\n\telse if (strcmp(key, \"lxc.mount\") == 0)\n\t\tv = c->fstab;\n\telse if (strcmp(key, \"lxc.tty\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->tty);\n\telse if (strcmp(key, \"lxc.pts\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->pts);\n\telse if (strcmp(key, \"lxc.devttydir\") == 0)\n\t\tv = c->ttydir;\n\telse if (strcmp(key, \"lxc.arch\") == 0)\n\t\treturn lxc_get_arch_entry(c, retv, inlen);\n\telse if (strcmp(key, \"lxc.aa_profile\") == 0)\n\t\tv = c->lsm_aa_profile;\n\telse if (strcmp(key, \"lxc.aa_allow_incomplete\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->lsm_aa_allow_incomplete);\n\telse if (strcmp(key, \"lxc.se_context\") == 0)\n\t\tv = c->lsm_se_context;\n\telse if (strcmp(key, \"lxc.logfile\") == 0)\n\t\tv = c->logfile;\n\telse if (strcmp(key, \"lxc.loglevel\") == 0)\n\t\tv = lxc_log_priority_to_string(c->loglevel);\n\telse if (strcmp(key, \"lxc.cgroup\") == 0) // all cgroup info\n\t\treturn lxc_get_cgroup_entry(c, retv, inlen, \"all\");\n\telse if (strncmp(key, \"lxc.cgroup.\", 11) == 0) // specific cgroup info\n\t\treturn lxc_get_cgroup_entry(c, retv, inlen, key + 11);\n\telse if (strcmp(key, \"lxc.utsname\") == 0)\n\t\tv = c->utsname ? c->utsname->nodename : NULL;\n\telse if (strcmp(key, \"lxc.console.logfile\") == 0)\n\t\tv = c->console.log_path;\n\telse if (strcmp(key, \"lxc.console\") == 0)\n\t\tv = c->console.path;\n\telse if (strcmp(key, \"lxc.rootfs.mount\") == 0)\n\t\tv = c->rootfs.mount;\n\telse if (strcmp(key, \"lxc.rootfs.backend\") == 0)\n\t\tv = c->rootfs.bdev_type;\n\telse if (strcmp(key, \"lxc.rootfs.options\") == 0)\n\t\tv = c->rootfs.options;\n\telse if (strcmp(key, \"lxc.rootfs\") == 0)\n\t\tv = c->rootfs.path;\n\telse if (strcmp(key, \"lxc.cap.drop\") == 0)\n\t\treturn lxc_get_item_cap_drop(c, retv, inlen);\n\telse if (strcmp(key, \"lxc.cap.keep\") == 0)\n\t\treturn lxc_get_item_cap_keep(c, retv, inlen);\n\telse if (strncmp(key, \"lxc.hook\", 8) == 0)\n\t\treturn lxc_get_item_hooks(c, retv, inlen, key);\n\telse if (strcmp(key, \"lxc.network\") == 0)\n\t\treturn lxc_get_item_network(c, retv, inlen);\n\telse if (strncmp(key, \"lxc.network.\", 12) == 0)\n\t\treturn lxc_get_item_nic(c, retv, inlen, key + 12);\n\telse if (strcmp(key, \"lxc.start.auto\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->start_auto);\n\telse if (strcmp(key, \"lxc.start.delay\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->start_delay);\n\telse if (strcmp(key, \"lxc.start.order\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->start_order);\n\telse if (strcmp(key, \"lxc.monitor.unshare\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->monitor_unshare);\n\telse if (strcmp(key, \"lxc.group\") == 0)\n\t\treturn lxc_get_item_groups(c, retv, inlen);\n\telse if (strcmp(key, \"lxc.seccomp\") == 0)\n\t\tv = c->seccomp;\n\telse if (strcmp(key, \"lxc.environment\") == 0)\n\t\treturn lxc_get_item_environment(c, retv, inlen);\n\telse if (strcmp(key, \"lxc.init_cmd\") == 0)\n\t\tv = c->init_cmd;\n\telse if (strcmp(key, \"lxc.init_uid\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->init_uid);\n\telse if (strcmp(key, \"lxc.init_gid\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->init_gid);\n\telse if (strcmp(key, \"lxc.ephemeral\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->ephemeral);\n\telse if (strcmp(key, \"lxc.syslog\") == 0)\n\t\tv = c->syslog;\n\telse if (strcmp(key, \"lxc.no_new_privs\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->no_new_privs);\n\telse return -1;\n\n\tif (!v)\n\t\treturn 0;\n\tif (retv && inlen >= strlen(v) + 1)\n\t\tstrncpy(retv, v, strlen(v)+1);\n\treturn strlen(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "cilen + 1"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&rsp",
            "0",
            "sizeof(rsp)"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd_get_config_item_callback(int fd, struct lxc_cmd_req *req,\n\t\t\t\t\t    struct lxc_handler *handler)\n{\n\tint cilen;\n\tstruct lxc_cmd_rsp rsp;\n\tchar *cidata;\n\n\tmemset(&rsp, 0, sizeof(rsp));\n\tcilen = lxc_get_config_item(handler->conf, req->data, NULL, 0);\n\tif (cilen <= 0)\n\t\tgoto err1;\n\n\tcidata = alloca(cilen + 1);\n\tif (lxc_get_config_item(handler->conf, req->data, cidata, cilen + 1) != cilen)\n\t\tgoto err1;\n\tcidata[cilen] = '\\0';\n\trsp.data = cidata;\n\trsp.datalen = cilen + 1;\n\trsp.ret = 0;\n\tgoto out;\n\nerr1:\n\trsp.ret = -1;\nout:\n\treturn lxc_cmd_rsp_send(fd, &rsp);\n}"
  },
  {
    "function_name": "lxc_cmd_get_config_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
    "lines": "503-521",
    "snippet": "char *lxc_cmd_get_config_item(const char *name, const char *item,\n\t\t\t      const char *lxcpath)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_GET_CONFIG_ITEM,\n\t\t\t .data = item,\n\t\t\t .datalen = strlen(item)+1,\n\t\t       },\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn NULL;\n\n\tif (cmd.rsp.ret == 0)\n\t\treturn cmd.rsp.data;\n\treturn NULL;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"af_unix.h\"",
      "#include \"mainloop.h\"",
      "#include \"confile.h\"",
      "#include \"console.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"utils.h\"",
      "#include \"start.h\"\t/* for struct lxc_handler */",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/un.h>",
      "#include <inttypes.h>",
      "#include <sys/socket.h>",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_cmd",
          "args": [
            "name",
            "&cmd",
            "&stopped",
            "lxcpath",
            "NULL"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "271-338",
          "snippet": "static int lxc_cmd(const char *name, struct lxc_cmd_rr *cmd, int *stopped,\n\t\t   const char *lxcpath, const char *hashed_sock_name)\n{\n\tint sock, ret = -1;\n\tchar path[sizeof(((struct sockaddr_un *)0)->sun_path)] = { 0 };\n\tchar *offset = &path[1];\n\tint len;\n\tint stay_connected = cmd->req.cmd == LXC_CMD_CONSOLE;\n\n\t*stopped = 0;\n\n\t/* -2 here because this is an abstract unix socket so it needs a\n\t * leading \\0, and we null terminate, so it needs a trailing \\0.\n\t * Although null termination isn't required by the API, we do it anyway\n\t * because we print the sockname out sometimes.\n\t */\n\tlen = sizeof(path)-2;\n\tif (fill_sock_name(offset, len, name, lxcpath, hashed_sock_name))\n\t\treturn -1;\n\n\tsock = lxc_abstract_unix_connect(path);\n\tif (sock < 0) {\n\t\tif (errno == ECONNREFUSED)\n\t\t\t*stopped = 1;\n\t\telse\n\t\t\tSYSERROR(\"Command %s failed to connect to \\\"@%s\\\".\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset);\n\t\treturn -1;\n\t}\n\n\tret = lxc_abstract_unix_send_credential(sock, &cmd->req, sizeof(cmd->req));\n\tif (ret != sizeof(cmd->req)) {\n\t\tif (errno == EPIPE)\n\t\t\tgoto epipe;\n\t\tSYSERROR(\"Command %s failed to send req to \\\"@%s\\\" %d.\",\n\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\tif (ret >=0)\n\t\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (cmd->req.datalen > 0) {\n\t\tret = send(sock, cmd->req.data, cmd->req.datalen, MSG_NOSIGNAL);\n\t\tif (ret != cmd->req.datalen) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tgoto epipe;\n\t\t\tSYSERROR(\"Command %s failed to send request data to \\\"@%s\\\" %d.\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\t\tif (ret >=0)\n\t\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = lxc_cmd_rsp_recv(sock, cmd);\nout:\n\tif (!stay_connected || ret <= 0)\n\t\tclose(sock);\n\tif (stay_connected && ret > 0)\n\t\tcmd->rsp.ret = sock;\n\n\treturn ret;\n\nepipe:\n\tclose(sock);\n\t*stopped = 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd(const char *name, struct lxc_cmd_rr *cmd, int *stopped,\n\t\t   const char *lxcpath, const char *hashed_sock_name)\n{\n\tint sock, ret = -1;\n\tchar path[sizeof(((struct sockaddr_un *)0)->sun_path)] = { 0 };\n\tchar *offset = &path[1];\n\tint len;\n\tint stay_connected = cmd->req.cmd == LXC_CMD_CONSOLE;\n\n\t*stopped = 0;\n\n\t/* -2 here because this is an abstract unix socket so it needs a\n\t * leading \\0, and we null terminate, so it needs a trailing \\0.\n\t * Although null termination isn't required by the API, we do it anyway\n\t * because we print the sockname out sometimes.\n\t */\n\tlen = sizeof(path)-2;\n\tif (fill_sock_name(offset, len, name, lxcpath, hashed_sock_name))\n\t\treturn -1;\n\n\tsock = lxc_abstract_unix_connect(path);\n\tif (sock < 0) {\n\t\tif (errno == ECONNREFUSED)\n\t\t\t*stopped = 1;\n\t\telse\n\t\t\tSYSERROR(\"Command %s failed to connect to \\\"@%s\\\".\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset);\n\t\treturn -1;\n\t}\n\n\tret = lxc_abstract_unix_send_credential(sock, &cmd->req, sizeof(cmd->req));\n\tif (ret != sizeof(cmd->req)) {\n\t\tif (errno == EPIPE)\n\t\t\tgoto epipe;\n\t\tSYSERROR(\"Command %s failed to send req to \\\"@%s\\\" %d.\",\n\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\tif (ret >=0)\n\t\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (cmd->req.datalen > 0) {\n\t\tret = send(sock, cmd->req.data, cmd->req.datalen, MSG_NOSIGNAL);\n\t\tif (ret != cmd->req.datalen) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tgoto epipe;\n\t\t\tSYSERROR(\"Command %s failed to send request data to \\\"@%s\\\" %d.\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\t\tif (ret >=0)\n\t\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = lxc_cmd_rsp_recv(sock, cmd);\nout:\n\tif (!stay_connected || ret <= 0)\n\t\tclose(sock);\n\tif (stay_connected && ret > 0)\n\t\tcmd->rsp.ret = sock;\n\n\treturn ret;\n\nepipe:\n\tclose(sock);\n\t*stopped = 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "item"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nchar *lxc_cmd_get_config_item(const char *name, const char *item,\n\t\t\t      const char *lxcpath)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_GET_CONFIG_ITEM,\n\t\t\t .data = item,\n\t\t\t .datalen = strlen(item)+1,\n\t\t       },\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn NULL;\n\n\tif (cmd.rsp.ret == 0)\n\t\treturn cmd.rsp.data;\n\treturn NULL;\n}"
  },
  {
    "function_name": "lxc_cmd_get_cgroup_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
    "lines": "474-491",
    "snippet": "static int lxc_cmd_get_cgroup_callback(int fd, struct lxc_cmd_req *req,\n\t\t\t\t       struct lxc_handler *handler)\n{\n\tstruct lxc_cmd_rsp rsp;\n\tconst char *path;\n\n\tif (req->datalen < 1)\n\t\treturn -1;\n\n\tpath = cgroup_get_cgroup(handler, req->data);\n\tif (!path)\n\t\treturn -1;\n\trsp.datalen = strlen(path) + 1,\n\trsp.data = (char *)path;\n\trsp.ret = 0;\n\n\treturn lxc_cmd_rsp_send(fd, &rsp);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"af_unix.h\"",
      "#include \"mainloop.h\"",
      "#include \"confile.h\"",
      "#include \"console.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"utils.h\"",
      "#include \"start.h\"\t/* for struct lxc_handler */",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/un.h>",
      "#include <inttypes.h>",
      "#include <sys/socket.h>",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_cmd_rsp_send",
          "args": [
            "fd",
            "&rsp"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_rsp_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "230-250",
          "snippet": "static int lxc_cmd_rsp_send(int fd, struct lxc_cmd_rsp *rsp)\n{\n\tint ret;\n\n\tret = send(fd, rsp, sizeof(*rsp), 0);\n\tif (ret != sizeof(*rsp)) {\n\t\tERROR(\"Failed to send command response %d: %s.\", ret,\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (rsp->datalen > 0) {\n\t\tret = send(fd, rsp->data, rsp->datalen, 0);\n\t\tif (ret != rsp->datalen) {\n\t\t\tWARN(\"Failed to send command response data %d: %s.\",\n\t\t\t     ret, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd_rsp_send(int fd, struct lxc_cmd_rsp *rsp)\n{\n\tint ret;\n\n\tret = send(fd, rsp, sizeof(*rsp), 0);\n\tif (ret != sizeof(*rsp)) {\n\t\tERROR(\"Failed to send command response %d: %s.\", ret,\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (rsp->datalen > 0) {\n\t\tret = send(fd, rsp->data, rsp->datalen, 0);\n\t\tif (ret != rsp->datalen) {\n\t\t\tWARN(\"Failed to send command response data %d: %s.\",\n\t\t\t     ret, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_get_cgroup",
          "args": [
            "handler",
            "req->data"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_get_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgroup.c",
          "lines": "108-113",
          "snippet": "const char *cgroup_get_cgroup(struct lxc_handler *handler, const char *subsystem)\n{\n\tif (ops)\n\t\treturn ops->get_cgroup(handler->cgroup_data, subsystem);\n\treturn NULL;\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"log.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_ops *ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"log.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <unistd.h>\n\nstatic struct cgroup_ops *ops = NULL;\n\nconst char *cgroup_get_cgroup(struct lxc_handler *handler, const char *subsystem)\n{\n\tif (ops)\n\t\treturn ops->get_cgroup(handler->cgroup_data, subsystem);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd_get_cgroup_callback(int fd, struct lxc_cmd_req *req,\n\t\t\t\t       struct lxc_handler *handler)\n{\n\tstruct lxc_cmd_rsp rsp;\n\tconst char *path;\n\n\tif (req->datalen < 1)\n\t\treturn -1;\n\n\tpath = cgroup_get_cgroup(handler, req->data);\n\tif (!path)\n\t\treturn -1;\n\trsp.datalen = strlen(path) + 1,\n\trsp.data = (char *)path;\n\trsp.ret = 0;\n\n\treturn lxc_cmd_rsp_send(fd, &rsp);\n}"
  },
  {
    "function_name": "lxc_cmd_get_cgroup_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
    "lines": "444-472",
    "snippet": "char *lxc_cmd_get_cgroup_path(const char *name, const char *lxcpath,\n\tconst char *subsystem)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = {\n\t\t\t.cmd = LXC_CMD_GET_CGROUP,\n\t\t\t.datalen = strlen(subsystem)+1,\n\t\t\t.data = subsystem,\n\t\t},\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn NULL;\n\n\tif (!ret) {\n\t\tWARN(\"Container \\\"%s\\\" has stopped before sending its state.\", name);\n\t\treturn NULL;\n\t}\n\n\tif (cmd.rsp.ret < 0 || cmd.rsp.datalen < 0) {\n\t\tERROR(\"Command %s failed for container \\\"%s\\\": %s.\",\n\t\t      lxc_cmd_str(cmd.req.cmd), name, strerror(-cmd.rsp.ret));\n\t\treturn NULL;\n\t}\n\n\treturn cmd.rsp.data;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"af_unix.h\"",
      "#include \"mainloop.h\"",
      "#include \"confile.h\"",
      "#include \"console.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"utils.h\"",
      "#include \"start.h\"\t/* for struct lxc_handler */",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/un.h>",
      "#include <inttypes.h>",
      "#include <sys/socket.h>",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Command %s failed for container \\\"%s\\\": %s.\"",
            "lxc_cmd_str(cmd.req.cmd)",
            "name",
            "strerror(-cmd.rsp.ret)"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "-cmd.rsp.ret"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cmd_str",
          "args": [
            "cmd.req.cmd"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "128-145",
          "snippet": "static const char *lxc_cmd_str(lxc_cmd_t cmd)\n{\n\tstatic const char * const cmdname[LXC_CMD_MAX] = {\n\t\t[LXC_CMD_CONSOLE]         = \"console\",\n\t\t[LXC_CMD_STOP]            = \"stop\",\n\t\t[LXC_CMD_GET_STATE]       = \"get_state\",\n\t\t[LXC_CMD_GET_INIT_PID]    = \"get_init_pid\",\n\t\t[LXC_CMD_GET_CLONE_FLAGS] = \"get_clone_flags\",\n\t\t[LXC_CMD_GET_CGROUP]      = \"get_cgroup\",\n\t\t[LXC_CMD_GET_CONFIG_ITEM] = \"get_config_item\",\n\t\t[LXC_CMD_GET_NAME]        = \"get_name\",\n\t\t[LXC_CMD_GET_LXCPATH]     = \"get_lxcpath\",\n\t};\n\n\tif (cmd >= LXC_CMD_MAX)\n\t\treturn \"Unknown cmd\";\n\treturn cmdname[cmd];\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic const char *lxc_cmd_str(lxc_cmd_t cmd)\n{\n\tstatic const char * const cmdname[LXC_CMD_MAX] = {\n\t\t[LXC_CMD_CONSOLE]         = \"console\",\n\t\t[LXC_CMD_STOP]            = \"stop\",\n\t\t[LXC_CMD_GET_STATE]       = \"get_state\",\n\t\t[LXC_CMD_GET_INIT_PID]    = \"get_init_pid\",\n\t\t[LXC_CMD_GET_CLONE_FLAGS] = \"get_clone_flags\",\n\t\t[LXC_CMD_GET_CGROUP]      = \"get_cgroup\",\n\t\t[LXC_CMD_GET_CONFIG_ITEM] = \"get_config_item\",\n\t\t[LXC_CMD_GET_NAME]        = \"get_name\",\n\t\t[LXC_CMD_GET_LXCPATH]     = \"get_lxcpath\",\n\t};\n\n\tif (cmd >= LXC_CMD_MAX)\n\t\treturn \"Unknown cmd\";\n\treturn cmdname[cmd];\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Container \\\"%s\\\" has stopped before sending its state.\"",
            "name"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cmd",
          "args": [
            "name",
            "&cmd",
            "&stopped",
            "lxcpath",
            "NULL"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "271-338",
          "snippet": "static int lxc_cmd(const char *name, struct lxc_cmd_rr *cmd, int *stopped,\n\t\t   const char *lxcpath, const char *hashed_sock_name)\n{\n\tint sock, ret = -1;\n\tchar path[sizeof(((struct sockaddr_un *)0)->sun_path)] = { 0 };\n\tchar *offset = &path[1];\n\tint len;\n\tint stay_connected = cmd->req.cmd == LXC_CMD_CONSOLE;\n\n\t*stopped = 0;\n\n\t/* -2 here because this is an abstract unix socket so it needs a\n\t * leading \\0, and we null terminate, so it needs a trailing \\0.\n\t * Although null termination isn't required by the API, we do it anyway\n\t * because we print the sockname out sometimes.\n\t */\n\tlen = sizeof(path)-2;\n\tif (fill_sock_name(offset, len, name, lxcpath, hashed_sock_name))\n\t\treturn -1;\n\n\tsock = lxc_abstract_unix_connect(path);\n\tif (sock < 0) {\n\t\tif (errno == ECONNREFUSED)\n\t\t\t*stopped = 1;\n\t\telse\n\t\t\tSYSERROR(\"Command %s failed to connect to \\\"@%s\\\".\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset);\n\t\treturn -1;\n\t}\n\n\tret = lxc_abstract_unix_send_credential(sock, &cmd->req, sizeof(cmd->req));\n\tif (ret != sizeof(cmd->req)) {\n\t\tif (errno == EPIPE)\n\t\t\tgoto epipe;\n\t\tSYSERROR(\"Command %s failed to send req to \\\"@%s\\\" %d.\",\n\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\tif (ret >=0)\n\t\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (cmd->req.datalen > 0) {\n\t\tret = send(sock, cmd->req.data, cmd->req.datalen, MSG_NOSIGNAL);\n\t\tif (ret != cmd->req.datalen) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tgoto epipe;\n\t\t\tSYSERROR(\"Command %s failed to send request data to \\\"@%s\\\" %d.\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\t\tif (ret >=0)\n\t\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = lxc_cmd_rsp_recv(sock, cmd);\nout:\n\tif (!stay_connected || ret <= 0)\n\t\tclose(sock);\n\tif (stay_connected && ret > 0)\n\t\tcmd->rsp.ret = sock;\n\n\treturn ret;\n\nepipe:\n\tclose(sock);\n\t*stopped = 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd(const char *name, struct lxc_cmd_rr *cmd, int *stopped,\n\t\t   const char *lxcpath, const char *hashed_sock_name)\n{\n\tint sock, ret = -1;\n\tchar path[sizeof(((struct sockaddr_un *)0)->sun_path)] = { 0 };\n\tchar *offset = &path[1];\n\tint len;\n\tint stay_connected = cmd->req.cmd == LXC_CMD_CONSOLE;\n\n\t*stopped = 0;\n\n\t/* -2 here because this is an abstract unix socket so it needs a\n\t * leading \\0, and we null terminate, so it needs a trailing \\0.\n\t * Although null termination isn't required by the API, we do it anyway\n\t * because we print the sockname out sometimes.\n\t */\n\tlen = sizeof(path)-2;\n\tif (fill_sock_name(offset, len, name, lxcpath, hashed_sock_name))\n\t\treturn -1;\n\n\tsock = lxc_abstract_unix_connect(path);\n\tif (sock < 0) {\n\t\tif (errno == ECONNREFUSED)\n\t\t\t*stopped = 1;\n\t\telse\n\t\t\tSYSERROR(\"Command %s failed to connect to \\\"@%s\\\".\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset);\n\t\treturn -1;\n\t}\n\n\tret = lxc_abstract_unix_send_credential(sock, &cmd->req, sizeof(cmd->req));\n\tif (ret != sizeof(cmd->req)) {\n\t\tif (errno == EPIPE)\n\t\t\tgoto epipe;\n\t\tSYSERROR(\"Command %s failed to send req to \\\"@%s\\\" %d.\",\n\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\tif (ret >=0)\n\t\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (cmd->req.datalen > 0) {\n\t\tret = send(sock, cmd->req.data, cmd->req.datalen, MSG_NOSIGNAL);\n\t\tif (ret != cmd->req.datalen) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tgoto epipe;\n\t\t\tSYSERROR(\"Command %s failed to send request data to \\\"@%s\\\" %d.\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\t\tif (ret >=0)\n\t\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = lxc_cmd_rsp_recv(sock, cmd);\nout:\n\tif (!stay_connected || ret <= 0)\n\t\tclose(sock);\n\tif (stay_connected && ret > 0)\n\t\tcmd->rsp.ret = sock;\n\n\treturn ret;\n\nepipe:\n\tclose(sock);\n\t*stopped = 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "subsystem"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nchar *lxc_cmd_get_cgroup_path(const char *name, const char *lxcpath,\n\tconst char *subsystem)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = {\n\t\t\t.cmd = LXC_CMD_GET_CGROUP,\n\t\t\t.datalen = strlen(subsystem)+1,\n\t\t\t.data = subsystem,\n\t\t},\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn NULL;\n\n\tif (!ret) {\n\t\tWARN(\"Container \\\"%s\\\" has stopped before sending its state.\", name);\n\t\treturn NULL;\n\t}\n\n\tif (cmd.rsp.ret < 0 || cmd.rsp.datalen < 0) {\n\t\tERROR(\"Command %s failed for container \\\"%s\\\": %s.\",\n\t\t      lxc_cmd_str(cmd.req.cmd), name, strerror(-cmd.rsp.ret));\n\t\treturn NULL;\n\t}\n\n\treturn cmd.rsp.data;\n}"
  },
  {
    "function_name": "lxc_cmd_get_clone_flags_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
    "lines": "424-430",
    "snippet": "static int lxc_cmd_get_clone_flags_callback(int fd, struct lxc_cmd_req *req,\n\t\t\t\t\t    struct lxc_handler *handler)\n{\n\tstruct lxc_cmd_rsp rsp = { .data = INT_TO_PTR(handler->clone_flags) };\n\n\treturn lxc_cmd_rsp_send(fd, &rsp);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"af_unix.h\"",
      "#include \"mainloop.h\"",
      "#include \"confile.h\"",
      "#include \"console.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"utils.h\"",
      "#include \"start.h\"\t/* for struct lxc_handler */",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/un.h>",
      "#include <inttypes.h>",
      "#include <sys/socket.h>",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_cmd_rsp_send",
          "args": [
            "fd",
            "&rsp"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_rsp_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "230-250",
          "snippet": "static int lxc_cmd_rsp_send(int fd, struct lxc_cmd_rsp *rsp)\n{\n\tint ret;\n\n\tret = send(fd, rsp, sizeof(*rsp), 0);\n\tif (ret != sizeof(*rsp)) {\n\t\tERROR(\"Failed to send command response %d: %s.\", ret,\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (rsp->datalen > 0) {\n\t\tret = send(fd, rsp->data, rsp->datalen, 0);\n\t\tif (ret != rsp->datalen) {\n\t\t\tWARN(\"Failed to send command response data %d: %s.\",\n\t\t\t     ret, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd_rsp_send(int fd, struct lxc_cmd_rsp *rsp)\n{\n\tint ret;\n\n\tret = send(fd, rsp, sizeof(*rsp), 0);\n\tif (ret != sizeof(*rsp)) {\n\t\tERROR(\"Failed to send command response %d: %s.\", ret,\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (rsp->datalen > 0) {\n\t\tret = send(fd, rsp->data, rsp->datalen, 0);\n\t\tif (ret != rsp->datalen) {\n\t\t\tWARN(\"Failed to send command response data %d: %s.\",\n\t\t\t     ret, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INT_TO_PTR",
          "args": [
            "handler->clone_flags"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd_get_clone_flags_callback(int fd, struct lxc_cmd_req *req,\n\t\t\t\t\t    struct lxc_handler *handler)\n{\n\tstruct lxc_cmd_rsp rsp = { .data = INT_TO_PTR(handler->clone_flags) };\n\n\treturn lxc_cmd_rsp_send(fd, &rsp);\n}"
  },
  {
    "function_name": "lxc_cmd_get_clone_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
    "lines": "410-422",
    "snippet": "int lxc_cmd_get_clone_flags(const char *name, const char *lxcpath)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_GET_CLONE_FLAGS },\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn PTR_TO_INT(cmd.rsp.data);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"af_unix.h\"",
      "#include \"mainloop.h\"",
      "#include \"confile.h\"",
      "#include \"console.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"utils.h\"",
      "#include \"start.h\"\t/* for struct lxc_handler */",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/un.h>",
      "#include <inttypes.h>",
      "#include <sys/socket.h>",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_TO_INT",
          "args": [
            "cmd.rsp.data"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cmd",
          "args": [
            "name",
            "&cmd",
            "&stopped",
            "lxcpath",
            "NULL"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "271-338",
          "snippet": "static int lxc_cmd(const char *name, struct lxc_cmd_rr *cmd, int *stopped,\n\t\t   const char *lxcpath, const char *hashed_sock_name)\n{\n\tint sock, ret = -1;\n\tchar path[sizeof(((struct sockaddr_un *)0)->sun_path)] = { 0 };\n\tchar *offset = &path[1];\n\tint len;\n\tint stay_connected = cmd->req.cmd == LXC_CMD_CONSOLE;\n\n\t*stopped = 0;\n\n\t/* -2 here because this is an abstract unix socket so it needs a\n\t * leading \\0, and we null terminate, so it needs a trailing \\0.\n\t * Although null termination isn't required by the API, we do it anyway\n\t * because we print the sockname out sometimes.\n\t */\n\tlen = sizeof(path)-2;\n\tif (fill_sock_name(offset, len, name, lxcpath, hashed_sock_name))\n\t\treturn -1;\n\n\tsock = lxc_abstract_unix_connect(path);\n\tif (sock < 0) {\n\t\tif (errno == ECONNREFUSED)\n\t\t\t*stopped = 1;\n\t\telse\n\t\t\tSYSERROR(\"Command %s failed to connect to \\\"@%s\\\".\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset);\n\t\treturn -1;\n\t}\n\n\tret = lxc_abstract_unix_send_credential(sock, &cmd->req, sizeof(cmd->req));\n\tif (ret != sizeof(cmd->req)) {\n\t\tif (errno == EPIPE)\n\t\t\tgoto epipe;\n\t\tSYSERROR(\"Command %s failed to send req to \\\"@%s\\\" %d.\",\n\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\tif (ret >=0)\n\t\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (cmd->req.datalen > 0) {\n\t\tret = send(sock, cmd->req.data, cmd->req.datalen, MSG_NOSIGNAL);\n\t\tif (ret != cmd->req.datalen) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tgoto epipe;\n\t\t\tSYSERROR(\"Command %s failed to send request data to \\\"@%s\\\" %d.\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\t\tif (ret >=0)\n\t\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = lxc_cmd_rsp_recv(sock, cmd);\nout:\n\tif (!stay_connected || ret <= 0)\n\t\tclose(sock);\n\tif (stay_connected && ret > 0)\n\t\tcmd->rsp.ret = sock;\n\n\treturn ret;\n\nepipe:\n\tclose(sock);\n\t*stopped = 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd(const char *name, struct lxc_cmd_rr *cmd, int *stopped,\n\t\t   const char *lxcpath, const char *hashed_sock_name)\n{\n\tint sock, ret = -1;\n\tchar path[sizeof(((struct sockaddr_un *)0)->sun_path)] = { 0 };\n\tchar *offset = &path[1];\n\tint len;\n\tint stay_connected = cmd->req.cmd == LXC_CMD_CONSOLE;\n\n\t*stopped = 0;\n\n\t/* -2 here because this is an abstract unix socket so it needs a\n\t * leading \\0, and we null terminate, so it needs a trailing \\0.\n\t * Although null termination isn't required by the API, we do it anyway\n\t * because we print the sockname out sometimes.\n\t */\n\tlen = sizeof(path)-2;\n\tif (fill_sock_name(offset, len, name, lxcpath, hashed_sock_name))\n\t\treturn -1;\n\n\tsock = lxc_abstract_unix_connect(path);\n\tif (sock < 0) {\n\t\tif (errno == ECONNREFUSED)\n\t\t\t*stopped = 1;\n\t\telse\n\t\t\tSYSERROR(\"Command %s failed to connect to \\\"@%s\\\".\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset);\n\t\treturn -1;\n\t}\n\n\tret = lxc_abstract_unix_send_credential(sock, &cmd->req, sizeof(cmd->req));\n\tif (ret != sizeof(cmd->req)) {\n\t\tif (errno == EPIPE)\n\t\t\tgoto epipe;\n\t\tSYSERROR(\"Command %s failed to send req to \\\"@%s\\\" %d.\",\n\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\tif (ret >=0)\n\t\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (cmd->req.datalen > 0) {\n\t\tret = send(sock, cmd->req.data, cmd->req.datalen, MSG_NOSIGNAL);\n\t\tif (ret != cmd->req.datalen) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tgoto epipe;\n\t\t\tSYSERROR(\"Command %s failed to send request data to \\\"@%s\\\" %d.\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\t\tif (ret >=0)\n\t\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = lxc_cmd_rsp_recv(sock, cmd);\nout:\n\tif (!stay_connected || ret <= 0)\n\t\tclose(sock);\n\tif (stay_connected && ret > 0)\n\t\tcmd->rsp.ret = sock;\n\n\treturn ret;\n\nepipe:\n\tclose(sock);\n\t*stopped = 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nint lxc_cmd_get_clone_flags(const char *name, const char *lxcpath)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_GET_CLONE_FLAGS },\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn PTR_TO_INT(cmd.rsp.data);\n}"
  },
  {
    "function_name": "lxc_cmd_get_init_pid_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
    "lines": "394-400",
    "snippet": "static int lxc_cmd_get_init_pid_callback(int fd, struct lxc_cmd_req *req,\n\t\t\t\t\t struct lxc_handler *handler)\n{\n\tstruct lxc_cmd_rsp rsp = { .data = INT_TO_PTR(handler->pid) };\n\n\treturn lxc_cmd_rsp_send(fd, &rsp);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"af_unix.h\"",
      "#include \"mainloop.h\"",
      "#include \"confile.h\"",
      "#include \"console.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"utils.h\"",
      "#include \"start.h\"\t/* for struct lxc_handler */",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/un.h>",
      "#include <inttypes.h>",
      "#include <sys/socket.h>",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_cmd_rsp_send",
          "args": [
            "fd",
            "&rsp"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_rsp_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "230-250",
          "snippet": "static int lxc_cmd_rsp_send(int fd, struct lxc_cmd_rsp *rsp)\n{\n\tint ret;\n\n\tret = send(fd, rsp, sizeof(*rsp), 0);\n\tif (ret != sizeof(*rsp)) {\n\t\tERROR(\"Failed to send command response %d: %s.\", ret,\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (rsp->datalen > 0) {\n\t\tret = send(fd, rsp->data, rsp->datalen, 0);\n\t\tif (ret != rsp->datalen) {\n\t\t\tWARN(\"Failed to send command response data %d: %s.\",\n\t\t\t     ret, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd_rsp_send(int fd, struct lxc_cmd_rsp *rsp)\n{\n\tint ret;\n\n\tret = send(fd, rsp, sizeof(*rsp), 0);\n\tif (ret != sizeof(*rsp)) {\n\t\tERROR(\"Failed to send command response %d: %s.\", ret,\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (rsp->datalen > 0) {\n\t\tret = send(fd, rsp->data, rsp->datalen, 0);\n\t\tif (ret != rsp->datalen) {\n\t\t\tWARN(\"Failed to send command response data %d: %s.\",\n\t\t\t     ret, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INT_TO_PTR",
          "args": [
            "handler->pid"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd_get_init_pid_callback(int fd, struct lxc_cmd_req *req,\n\t\t\t\t\t struct lxc_handler *handler)\n{\n\tstruct lxc_cmd_rsp rsp = { .data = INT_TO_PTR(handler->pid) };\n\n\treturn lxc_cmd_rsp_send(fd, &rsp);\n}"
  },
  {
    "function_name": "lxc_cmd_get_init_pid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
    "lines": "380-392",
    "snippet": "pid_t lxc_cmd_get_init_pid(const char *name, const char *lxcpath)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_GET_INIT_PID },\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn PTR_TO_INT(cmd.rsp.data);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"af_unix.h\"",
      "#include \"mainloop.h\"",
      "#include \"confile.h\"",
      "#include \"console.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"utils.h\"",
      "#include \"start.h\"\t/* for struct lxc_handler */",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/un.h>",
      "#include <inttypes.h>",
      "#include <sys/socket.h>",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_TO_INT",
          "args": [
            "cmd.rsp.data"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cmd",
          "args": [
            "name",
            "&cmd",
            "&stopped",
            "lxcpath",
            "NULL"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "271-338",
          "snippet": "static int lxc_cmd(const char *name, struct lxc_cmd_rr *cmd, int *stopped,\n\t\t   const char *lxcpath, const char *hashed_sock_name)\n{\n\tint sock, ret = -1;\n\tchar path[sizeof(((struct sockaddr_un *)0)->sun_path)] = { 0 };\n\tchar *offset = &path[1];\n\tint len;\n\tint stay_connected = cmd->req.cmd == LXC_CMD_CONSOLE;\n\n\t*stopped = 0;\n\n\t/* -2 here because this is an abstract unix socket so it needs a\n\t * leading \\0, and we null terminate, so it needs a trailing \\0.\n\t * Although null termination isn't required by the API, we do it anyway\n\t * because we print the sockname out sometimes.\n\t */\n\tlen = sizeof(path)-2;\n\tif (fill_sock_name(offset, len, name, lxcpath, hashed_sock_name))\n\t\treturn -1;\n\n\tsock = lxc_abstract_unix_connect(path);\n\tif (sock < 0) {\n\t\tif (errno == ECONNREFUSED)\n\t\t\t*stopped = 1;\n\t\telse\n\t\t\tSYSERROR(\"Command %s failed to connect to \\\"@%s\\\".\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset);\n\t\treturn -1;\n\t}\n\n\tret = lxc_abstract_unix_send_credential(sock, &cmd->req, sizeof(cmd->req));\n\tif (ret != sizeof(cmd->req)) {\n\t\tif (errno == EPIPE)\n\t\t\tgoto epipe;\n\t\tSYSERROR(\"Command %s failed to send req to \\\"@%s\\\" %d.\",\n\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\tif (ret >=0)\n\t\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (cmd->req.datalen > 0) {\n\t\tret = send(sock, cmd->req.data, cmd->req.datalen, MSG_NOSIGNAL);\n\t\tif (ret != cmd->req.datalen) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tgoto epipe;\n\t\t\tSYSERROR(\"Command %s failed to send request data to \\\"@%s\\\" %d.\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\t\tif (ret >=0)\n\t\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = lxc_cmd_rsp_recv(sock, cmd);\nout:\n\tif (!stay_connected || ret <= 0)\n\t\tclose(sock);\n\tif (stay_connected && ret > 0)\n\t\tcmd->rsp.ret = sock;\n\n\treturn ret;\n\nepipe:\n\tclose(sock);\n\t*stopped = 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd(const char *name, struct lxc_cmd_rr *cmd, int *stopped,\n\t\t   const char *lxcpath, const char *hashed_sock_name)\n{\n\tint sock, ret = -1;\n\tchar path[sizeof(((struct sockaddr_un *)0)->sun_path)] = { 0 };\n\tchar *offset = &path[1];\n\tint len;\n\tint stay_connected = cmd->req.cmd == LXC_CMD_CONSOLE;\n\n\t*stopped = 0;\n\n\t/* -2 here because this is an abstract unix socket so it needs a\n\t * leading \\0, and we null terminate, so it needs a trailing \\0.\n\t * Although null termination isn't required by the API, we do it anyway\n\t * because we print the sockname out sometimes.\n\t */\n\tlen = sizeof(path)-2;\n\tif (fill_sock_name(offset, len, name, lxcpath, hashed_sock_name))\n\t\treturn -1;\n\n\tsock = lxc_abstract_unix_connect(path);\n\tif (sock < 0) {\n\t\tif (errno == ECONNREFUSED)\n\t\t\t*stopped = 1;\n\t\telse\n\t\t\tSYSERROR(\"Command %s failed to connect to \\\"@%s\\\".\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset);\n\t\treturn -1;\n\t}\n\n\tret = lxc_abstract_unix_send_credential(sock, &cmd->req, sizeof(cmd->req));\n\tif (ret != sizeof(cmd->req)) {\n\t\tif (errno == EPIPE)\n\t\t\tgoto epipe;\n\t\tSYSERROR(\"Command %s failed to send req to \\\"@%s\\\" %d.\",\n\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\tif (ret >=0)\n\t\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (cmd->req.datalen > 0) {\n\t\tret = send(sock, cmd->req.data, cmd->req.datalen, MSG_NOSIGNAL);\n\t\tif (ret != cmd->req.datalen) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tgoto epipe;\n\t\t\tSYSERROR(\"Command %s failed to send request data to \\\"@%s\\\" %d.\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\t\tif (ret >=0)\n\t\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = lxc_cmd_rsp_recv(sock, cmd);\nout:\n\tif (!stay_connected || ret <= 0)\n\t\tclose(sock);\n\tif (stay_connected && ret > 0)\n\t\tcmd->rsp.ret = sock;\n\n\treturn ret;\n\nepipe:\n\tclose(sock);\n\t*stopped = 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\npid_t lxc_cmd_get_init_pid(const char *name, const char *lxcpath)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_GET_INIT_PID },\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn PTR_TO_INT(cmd.rsp.data);\n}"
  },
  {
    "function_name": "lxc_try_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
    "lines": "340-368",
    "snippet": "int lxc_try_cmd(const char *name, const char *lxcpath)\n{\n\tint stopped, ret;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_GET_INIT_PID },\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\n\tif (stopped)\n\t\treturn 0;\n\tif (ret > 0 && cmd.rsp.ret < 0) {\n\t\terrno = cmd.rsp.ret;\n\t\treturn -1;\n\t}\n\tif (ret > 0)\n\t\treturn 0;\n\n\t/*\n\t * At this point we weren't denied access, and the\n\t * container *was* started.  There was some inexplicable\n\t * error in the protocol.\n\t * I'm not clear on whether we should return -1 here, but\n\t * we didn't receive a -EACCES, so technically it's not that\n\t * we're not allowed to control the container - it's just not\n\t * behaving.\n\t */\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"af_unix.h\"",
      "#include \"mainloop.h\"",
      "#include \"confile.h\"",
      "#include \"console.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"utils.h\"",
      "#include \"start.h\"\t/* for struct lxc_handler */",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/un.h>",
      "#include <inttypes.h>",
      "#include <sys/socket.h>",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_cmd",
          "args": [
            "name",
            "&cmd",
            "&stopped",
            "lxcpath",
            "NULL"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "271-338",
          "snippet": "static int lxc_cmd(const char *name, struct lxc_cmd_rr *cmd, int *stopped,\n\t\t   const char *lxcpath, const char *hashed_sock_name)\n{\n\tint sock, ret = -1;\n\tchar path[sizeof(((struct sockaddr_un *)0)->sun_path)] = { 0 };\n\tchar *offset = &path[1];\n\tint len;\n\tint stay_connected = cmd->req.cmd == LXC_CMD_CONSOLE;\n\n\t*stopped = 0;\n\n\t/* -2 here because this is an abstract unix socket so it needs a\n\t * leading \\0, and we null terminate, so it needs a trailing \\0.\n\t * Although null termination isn't required by the API, we do it anyway\n\t * because we print the sockname out sometimes.\n\t */\n\tlen = sizeof(path)-2;\n\tif (fill_sock_name(offset, len, name, lxcpath, hashed_sock_name))\n\t\treturn -1;\n\n\tsock = lxc_abstract_unix_connect(path);\n\tif (sock < 0) {\n\t\tif (errno == ECONNREFUSED)\n\t\t\t*stopped = 1;\n\t\telse\n\t\t\tSYSERROR(\"Command %s failed to connect to \\\"@%s\\\".\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset);\n\t\treturn -1;\n\t}\n\n\tret = lxc_abstract_unix_send_credential(sock, &cmd->req, sizeof(cmd->req));\n\tif (ret != sizeof(cmd->req)) {\n\t\tif (errno == EPIPE)\n\t\t\tgoto epipe;\n\t\tSYSERROR(\"Command %s failed to send req to \\\"@%s\\\" %d.\",\n\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\tif (ret >=0)\n\t\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (cmd->req.datalen > 0) {\n\t\tret = send(sock, cmd->req.data, cmd->req.datalen, MSG_NOSIGNAL);\n\t\tif (ret != cmd->req.datalen) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tgoto epipe;\n\t\t\tSYSERROR(\"Command %s failed to send request data to \\\"@%s\\\" %d.\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\t\tif (ret >=0)\n\t\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = lxc_cmd_rsp_recv(sock, cmd);\nout:\n\tif (!stay_connected || ret <= 0)\n\t\tclose(sock);\n\tif (stay_connected && ret > 0)\n\t\tcmd->rsp.ret = sock;\n\n\treturn ret;\n\nepipe:\n\tclose(sock);\n\t*stopped = 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd(const char *name, struct lxc_cmd_rr *cmd, int *stopped,\n\t\t   const char *lxcpath, const char *hashed_sock_name)\n{\n\tint sock, ret = -1;\n\tchar path[sizeof(((struct sockaddr_un *)0)->sun_path)] = { 0 };\n\tchar *offset = &path[1];\n\tint len;\n\tint stay_connected = cmd->req.cmd == LXC_CMD_CONSOLE;\n\n\t*stopped = 0;\n\n\t/* -2 here because this is an abstract unix socket so it needs a\n\t * leading \\0, and we null terminate, so it needs a trailing \\0.\n\t * Although null termination isn't required by the API, we do it anyway\n\t * because we print the sockname out sometimes.\n\t */\n\tlen = sizeof(path)-2;\n\tif (fill_sock_name(offset, len, name, lxcpath, hashed_sock_name))\n\t\treturn -1;\n\n\tsock = lxc_abstract_unix_connect(path);\n\tif (sock < 0) {\n\t\tif (errno == ECONNREFUSED)\n\t\t\t*stopped = 1;\n\t\telse\n\t\t\tSYSERROR(\"Command %s failed to connect to \\\"@%s\\\".\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset);\n\t\treturn -1;\n\t}\n\n\tret = lxc_abstract_unix_send_credential(sock, &cmd->req, sizeof(cmd->req));\n\tif (ret != sizeof(cmd->req)) {\n\t\tif (errno == EPIPE)\n\t\t\tgoto epipe;\n\t\tSYSERROR(\"Command %s failed to send req to \\\"@%s\\\" %d.\",\n\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\tif (ret >=0)\n\t\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (cmd->req.datalen > 0) {\n\t\tret = send(sock, cmd->req.data, cmd->req.datalen, MSG_NOSIGNAL);\n\t\tif (ret != cmd->req.datalen) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tgoto epipe;\n\t\t\tSYSERROR(\"Command %s failed to send request data to \\\"@%s\\\" %d.\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\t\tif (ret >=0)\n\t\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = lxc_cmd_rsp_recv(sock, cmd);\nout:\n\tif (!stay_connected || ret <= 0)\n\t\tclose(sock);\n\tif (stay_connected && ret > 0)\n\t\tcmd->rsp.ret = sock;\n\n\treturn ret;\n\nepipe:\n\tclose(sock);\n\t*stopped = 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nint lxc_try_cmd(const char *name, const char *lxcpath)\n{\n\tint stopped, ret;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_GET_INIT_PID },\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\n\tif (stopped)\n\t\treturn 0;\n\tif (ret > 0 && cmd.rsp.ret < 0) {\n\t\terrno = cmd.rsp.ret;\n\t\treturn -1;\n\t}\n\tif (ret > 0)\n\t\treturn 0;\n\n\t/*\n\t * At this point we weren't denied access, and the\n\t * container *was* started.  There was some inexplicable\n\t * error in the protocol.\n\t * I'm not clear on whether we should return -1 here, but\n\t * we didn't receive a -EACCES, so technically it's not that\n\t * we're not allowed to control the container - it's just not\n\t * behaving.\n\t */\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
    "lines": "271-338",
    "snippet": "static int lxc_cmd(const char *name, struct lxc_cmd_rr *cmd, int *stopped,\n\t\t   const char *lxcpath, const char *hashed_sock_name)\n{\n\tint sock, ret = -1;\n\tchar path[sizeof(((struct sockaddr_un *)0)->sun_path)] = { 0 };\n\tchar *offset = &path[1];\n\tint len;\n\tint stay_connected = cmd->req.cmd == LXC_CMD_CONSOLE;\n\n\t*stopped = 0;\n\n\t/* -2 here because this is an abstract unix socket so it needs a\n\t * leading \\0, and we null terminate, so it needs a trailing \\0.\n\t * Although null termination isn't required by the API, we do it anyway\n\t * because we print the sockname out sometimes.\n\t */\n\tlen = sizeof(path)-2;\n\tif (fill_sock_name(offset, len, name, lxcpath, hashed_sock_name))\n\t\treturn -1;\n\n\tsock = lxc_abstract_unix_connect(path);\n\tif (sock < 0) {\n\t\tif (errno == ECONNREFUSED)\n\t\t\t*stopped = 1;\n\t\telse\n\t\t\tSYSERROR(\"Command %s failed to connect to \\\"@%s\\\".\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset);\n\t\treturn -1;\n\t}\n\n\tret = lxc_abstract_unix_send_credential(sock, &cmd->req, sizeof(cmd->req));\n\tif (ret != sizeof(cmd->req)) {\n\t\tif (errno == EPIPE)\n\t\t\tgoto epipe;\n\t\tSYSERROR(\"Command %s failed to send req to \\\"@%s\\\" %d.\",\n\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\tif (ret >=0)\n\t\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (cmd->req.datalen > 0) {\n\t\tret = send(sock, cmd->req.data, cmd->req.datalen, MSG_NOSIGNAL);\n\t\tif (ret != cmd->req.datalen) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tgoto epipe;\n\t\t\tSYSERROR(\"Command %s failed to send request data to \\\"@%s\\\" %d.\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\t\tif (ret >=0)\n\t\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = lxc_cmd_rsp_recv(sock, cmd);\nout:\n\tif (!stay_connected || ret <= 0)\n\t\tclose(sock);\n\tif (stay_connected && ret > 0)\n\t\tcmd->rsp.ret = sock;\n\n\treturn ret;\n\nepipe:\n\tclose(sock);\n\t*stopped = 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"af_unix.h\"",
      "#include \"mainloop.h\"",
      "#include \"confile.h\"",
      "#include \"console.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"utils.h\"",
      "#include \"start.h\"\t/* for struct lxc_handler */",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/un.h>",
      "#include <inttypes.h>",
      "#include <sys/socket.h>",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cmd_rsp_recv",
          "args": [
            "sock",
            "cmd"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_rsp_recv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "164-220",
          "snippet": "static int lxc_cmd_rsp_recv(int sock, struct lxc_cmd_rr *cmd)\n{\n\tint ret,rspfd;\n\tstruct lxc_cmd_rsp *rsp = &cmd->rsp;\n\n\tret = lxc_abstract_unix_recv_fd(sock, &rspfd, rsp, sizeof(*rsp));\n\tif (ret < 0) {\n\t\tWARN(\"Command %s failed to receive response: %s.\",\n\t\t     lxc_cmd_str(cmd->req.cmd), strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (cmd->req.cmd == LXC_CMD_CONSOLE) {\n\t\tstruct lxc_cmd_console_rsp_data *rspdata;\n\n\t\t/* recv() returns 0 bytes when a tty cannot be allocated,\n\t\t * rsp->ret is < 0 when the peer permission check failed\n\t\t */\n\t\tif (ret == 0 || rsp->ret < 0)\n\t\t\treturn 0;\n\n\t\trspdata = malloc(sizeof(*rspdata));\n\t\tif (!rspdata) {\n\t\t\tERROR(\"Command %s couldn't allocate response buffer.\",\n\t\t\t      lxc_cmd_str(cmd->req.cmd));\n\t\t\treturn -1;\n\t\t}\n\t\trspdata->masterfd = rspfd;\n\t\trspdata->ttynum = PTR_TO_INT(rsp->data);\n\t\trsp->data = rspdata;\n\t}\n\n\tif (rsp->datalen == 0)\n\t\treturn ret;\n\tif (rsp->datalen > LXC_CMD_DATA_MAX) {\n\t\tERROR(\"Command %s response data %d too long.\",\n\t\t      lxc_cmd_str(cmd->req.cmd), rsp->datalen);\n\t\terrno = EFBIG;\n\t\treturn -1;\n\t}\n\n\trsp->data = malloc(rsp->datalen);\n\tif (!rsp->data) {\n\t\tERROR(\"Command %s was unable to allocate response buffer.\",\n\t\t      lxc_cmd_str(cmd->req.cmd));\n\t\treturn -1;\n\t}\n\tret = recv(sock, rsp->data, rsp->datalen, 0);\n\tif (ret != rsp->datalen) {\n\t\tERROR(\"Command %s failed to receive response data: %s.\",\n\t\t      lxc_cmd_str(cmd->req.cmd), strerror(errno));\n\t\tif (ret >= 0)\n\t\t\tret = -1;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd_rsp_recv(int sock, struct lxc_cmd_rr *cmd)\n{\n\tint ret,rspfd;\n\tstruct lxc_cmd_rsp *rsp = &cmd->rsp;\n\n\tret = lxc_abstract_unix_recv_fd(sock, &rspfd, rsp, sizeof(*rsp));\n\tif (ret < 0) {\n\t\tWARN(\"Command %s failed to receive response: %s.\",\n\t\t     lxc_cmd_str(cmd->req.cmd), strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (cmd->req.cmd == LXC_CMD_CONSOLE) {\n\t\tstruct lxc_cmd_console_rsp_data *rspdata;\n\n\t\t/* recv() returns 0 bytes when a tty cannot be allocated,\n\t\t * rsp->ret is < 0 when the peer permission check failed\n\t\t */\n\t\tif (ret == 0 || rsp->ret < 0)\n\t\t\treturn 0;\n\n\t\trspdata = malloc(sizeof(*rspdata));\n\t\tif (!rspdata) {\n\t\t\tERROR(\"Command %s couldn't allocate response buffer.\",\n\t\t\t      lxc_cmd_str(cmd->req.cmd));\n\t\t\treturn -1;\n\t\t}\n\t\trspdata->masterfd = rspfd;\n\t\trspdata->ttynum = PTR_TO_INT(rsp->data);\n\t\trsp->data = rspdata;\n\t}\n\n\tif (rsp->datalen == 0)\n\t\treturn ret;\n\tif (rsp->datalen > LXC_CMD_DATA_MAX) {\n\t\tERROR(\"Command %s response data %d too long.\",\n\t\t      lxc_cmd_str(cmd->req.cmd), rsp->datalen);\n\t\terrno = EFBIG;\n\t\treturn -1;\n\t}\n\n\trsp->data = malloc(rsp->datalen);\n\tif (!rsp->data) {\n\t\tERROR(\"Command %s was unable to allocate response buffer.\",\n\t\t      lxc_cmd_str(cmd->req.cmd));\n\t\treturn -1;\n\t}\n\tret = recv(sock, rsp->data, rsp->datalen, 0);\n\tif (ret != rsp->datalen) {\n\t\tERROR(\"Command %s failed to receive response data: %s.\",\n\t\t      lxc_cmd_str(cmd->req.cmd), strerror(errno));\n\t\tif (ret >= 0)\n\t\t\tret = -1;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Command %s failed to send request data to \\\"@%s\\\" %d.\"",
            "lxc_cmd_str(cmd->req.cmd)",
            "offset",
            "ret"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cmd_str",
          "args": [
            "cmd->req.cmd"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "128-145",
          "snippet": "static const char *lxc_cmd_str(lxc_cmd_t cmd)\n{\n\tstatic const char * const cmdname[LXC_CMD_MAX] = {\n\t\t[LXC_CMD_CONSOLE]         = \"console\",\n\t\t[LXC_CMD_STOP]            = \"stop\",\n\t\t[LXC_CMD_GET_STATE]       = \"get_state\",\n\t\t[LXC_CMD_GET_INIT_PID]    = \"get_init_pid\",\n\t\t[LXC_CMD_GET_CLONE_FLAGS] = \"get_clone_flags\",\n\t\t[LXC_CMD_GET_CGROUP]      = \"get_cgroup\",\n\t\t[LXC_CMD_GET_CONFIG_ITEM] = \"get_config_item\",\n\t\t[LXC_CMD_GET_NAME]        = \"get_name\",\n\t\t[LXC_CMD_GET_LXCPATH]     = \"get_lxcpath\",\n\t};\n\n\tif (cmd >= LXC_CMD_MAX)\n\t\treturn \"Unknown cmd\";\n\treturn cmdname[cmd];\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic const char *lxc_cmd_str(lxc_cmd_t cmd)\n{\n\tstatic const char * const cmdname[LXC_CMD_MAX] = {\n\t\t[LXC_CMD_CONSOLE]         = \"console\",\n\t\t[LXC_CMD_STOP]            = \"stop\",\n\t\t[LXC_CMD_GET_STATE]       = \"get_state\",\n\t\t[LXC_CMD_GET_INIT_PID]    = \"get_init_pid\",\n\t\t[LXC_CMD_GET_CLONE_FLAGS] = \"get_clone_flags\",\n\t\t[LXC_CMD_GET_CGROUP]      = \"get_cgroup\",\n\t\t[LXC_CMD_GET_CONFIG_ITEM] = \"get_config_item\",\n\t\t[LXC_CMD_GET_NAME]        = \"get_name\",\n\t\t[LXC_CMD_GET_LXCPATH]     = \"get_lxcpath\",\n\t};\n\n\tif (cmd >= LXC_CMD_MAX)\n\t\treturn \"Unknown cmd\";\n\treturn cmdname[cmd];\n}"
        }
      },
      {
        "call_info": {
          "callee": "send",
          "args": [
            "sock",
            "cmd->req.data",
            "cmd->req.datalen",
            "MSG_NOSIGNAL"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_send_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "134-162",
          "snippet": "int lxc_abstract_unix_send_fd(int fd, int sendfd, void *data, size_t size)\n{\n\tstruct msghdr msg = { 0 };\n\tstruct iovec iov;\n\tstruct cmsghdr *cmsg;\n\tchar cmsgbuf[CMSG_SPACE(sizeof(int))];\n\tchar buf[1];\n\tint *val;\n\n\tmsg.msg_control = cmsgbuf;\n\tmsg.msg_controllen = sizeof(cmsgbuf);\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(int));\n\tcmsg->cmsg_level = SOL_SOCKET;\n\tcmsg->cmsg_type = SCM_RIGHTS;\n\tval = (int *)(CMSG_DATA(cmsg));\n\t*val = sendfd;\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_namelen = 0;\n\n\tiov.iov_base = data ? data : buf;\n\tiov.iov_len = data ? size : sizeof(buf);\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\treturn sendmsg(fd, &msg, MSG_NOSIGNAL);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_send_fd(int fd, int sendfd, void *data, size_t size)\n{\n\tstruct msghdr msg = { 0 };\n\tstruct iovec iov;\n\tstruct cmsghdr *cmsg;\n\tchar cmsgbuf[CMSG_SPACE(sizeof(int))];\n\tchar buf[1];\n\tint *val;\n\n\tmsg.msg_control = cmsgbuf;\n\tmsg.msg_controllen = sizeof(cmsgbuf);\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(int));\n\tcmsg->cmsg_level = SOL_SOCKET;\n\tcmsg->cmsg_type = SCM_RIGHTS;\n\tval = (int *)(CMSG_DATA(cmsg));\n\t*val = sendfd;\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_namelen = 0;\n\n\tiov.iov_base = data ? data : buf;\n\tiov.iov_len = data ? size : sizeof(buf);\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\treturn sendmsg(fd, &msg, MSG_NOSIGNAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Command %s failed to send req to \\\"@%s\\\" %d.\"",
            "lxc_cmd_str(cmd->req.cmd)",
            "offset",
            "ret"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_abstract_unix_send_credential",
          "args": [
            "sock",
            "&cmd->req",
            "sizeof(cmd->req)"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_send_credential",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "203-234",
          "snippet": "int lxc_abstract_unix_send_credential(int fd, void *data, size_t size)\n{\n\tstruct msghdr msg = { 0 };\n\tstruct iovec iov;\n\tstruct cmsghdr *cmsg;\n\tstruct ucred cred = {\n\t\t.pid = getpid(),\n\t\t.uid = getuid(),\n\t\t.gid = getgid(),\n\t};\n\tchar cmsgbuf[CMSG_SPACE(sizeof(cred))];\n\tchar buf[1];\n\n\tmsg.msg_control = cmsgbuf;\n\tmsg.msg_controllen = sizeof(cmsgbuf);\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(struct ucred));\n\tcmsg->cmsg_level = SOL_SOCKET;\n\tcmsg->cmsg_type = SCM_CREDENTIALS;\n\tmemcpy(CMSG_DATA(cmsg), &cred, sizeof(cred));\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_namelen = 0;\n\n\tiov.iov_base = data ? data : buf;\n\tiov.iov_len = data ? size : sizeof(buf);\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\treturn sendmsg(fd, &msg, MSG_NOSIGNAL);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_send_credential(int fd, void *data, size_t size)\n{\n\tstruct msghdr msg = { 0 };\n\tstruct iovec iov;\n\tstruct cmsghdr *cmsg;\n\tstruct ucred cred = {\n\t\t.pid = getpid(),\n\t\t.uid = getuid(),\n\t\t.gid = getgid(),\n\t};\n\tchar cmsgbuf[CMSG_SPACE(sizeof(cred))];\n\tchar buf[1];\n\n\tmsg.msg_control = cmsgbuf;\n\tmsg.msg_controllen = sizeof(cmsgbuf);\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(struct ucred));\n\tcmsg->cmsg_level = SOL_SOCKET;\n\tcmsg->cmsg_type = SCM_CREDENTIALS;\n\tmemcpy(CMSG_DATA(cmsg), &cred, sizeof(cred));\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_namelen = 0;\n\n\tiov.iov_base = data ? data : buf;\n\tiov.iov_len = data ? size : sizeof(buf);\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\treturn sendmsg(fd, &msg, MSG_NOSIGNAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Command %s failed to connect to \\\"@%s\\\".\"",
            "lxc_cmd_str(cmd->req.cmd)",
            "offset"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_abstract_unix_connect",
          "args": [
            "path"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "98-132",
          "snippet": "int lxc_abstract_unix_connect(const char *path)\n{\n\tint fd;\n\tsize_t len;\n\tstruct sockaddr_un addr;\n\n\tfd = socket(PF_UNIX, SOCK_STREAM, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tmemset(&addr, 0, sizeof(addr));\n\n\taddr.sun_family = AF_UNIX;\n\n\tlen = strlen(&path[1]) + 1;\n\tif (len >= sizeof(addr.sun_path) - 1) {\n\t\tclose(fd);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\t/* addr.sun_path[0] has already been set to 0 by memset() */\n\tstrncpy(&addr.sun_path[1], &path[1], strlen(&path[1]));\n\n\tif (connect(fd, (struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path) + len)) {\n\t\tint tmp = errno;\n\t\t/* special case to connect to older containers */\n\t\tif (connect(fd, (struct sockaddr *)&addr, sizeof(addr)) == 0)\n\t\t\treturn fd;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_connect(const char *path)\n{\n\tint fd;\n\tsize_t len;\n\tstruct sockaddr_un addr;\n\n\tfd = socket(PF_UNIX, SOCK_STREAM, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tmemset(&addr, 0, sizeof(addr));\n\n\taddr.sun_family = AF_UNIX;\n\n\tlen = strlen(&path[1]) + 1;\n\tif (len >= sizeof(addr.sun_path) - 1) {\n\t\tclose(fd);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\t/* addr.sun_path[0] has already been set to 0 by memset() */\n\tstrncpy(&addr.sun_path[1], &path[1], strlen(&path[1]));\n\n\tif (connect(fd, (struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path) + len)) {\n\t\tint tmp = errno;\n\t\t/* special case to connect to older containers */\n\t\tif (connect(fd, (struct sockaddr *)&addr, sizeof(addr)) == 0)\n\t\t\treturn fd;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_sock_name",
          "args": [
            "offset",
            "len",
            "name",
            "lxcpath",
            "hashed_sock_name"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "fill_sock_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "77-126",
          "snippet": "static int fill_sock_name(char *path, int len, const char *name,\n\t\t\t  const char *lxcpath, const char *hashed_sock_name)\n{\n\tchar *tmppath;\n\tsize_t tmplen;\n\tuint64_t hash;\n\tint ret;\n\n\tif (hashed_sock_name != NULL) {\n\t\tret = snprintf(path, len, \"lxc/%s/command\", hashed_sock_name);\n\t\tif (ret < 0 || ret >= len) {\n\t\t\tERROR(\"Error writing to command sock path\");\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (!lxcpath) {\n\t\tlxcpath = lxc_global_config_value(\"lxc.lxcpath\");\n\t\tif (!lxcpath) {\n\t\t\tERROR(\"Out of memory getting lxcpath\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tret = snprintf(path, len, \"%s/%s/command\", lxcpath, name);\n\tif (ret < 0) {\n\t\tERROR(\"Error writing to command sock path\");\n\t\treturn -1;\n\t}\n\tif (ret < len)\n\t\treturn 0;\n\n\t/* ret >= len; lxcpath or name is too long.  hash both */\n\ttmplen = strlen(name) + strlen(lxcpath) + 2;\n\ttmppath = alloca(tmplen);\n\tret = snprintf(tmppath, tmplen, \"%s/%s\", lxcpath, name);\n\tif (ret < 0 || ret >= tmplen) {\n\t\tERROR(\"memory error\");\n\t\treturn -1;\n\t}\n\thash = fnv_64a_buf(tmppath, ret, FNV1A_64_INIT);\n\tret = snprintf(path, len, \"lxc/%016\" PRIx64 \"/command\", hash);\n\tif (ret < 0 || ret >= len) {\n\t\tERROR(\"Command socket name too long\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int fill_sock_name(char *path, int len, const char *name,\n\t\t\t  const char *lxcpath, const char *hashed_sock_name)\n{\n\tchar *tmppath;\n\tsize_t tmplen;\n\tuint64_t hash;\n\tint ret;\n\n\tif (hashed_sock_name != NULL) {\n\t\tret = snprintf(path, len, \"lxc/%s/command\", hashed_sock_name);\n\t\tif (ret < 0 || ret >= len) {\n\t\t\tERROR(\"Error writing to command sock path\");\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (!lxcpath) {\n\t\tlxcpath = lxc_global_config_value(\"lxc.lxcpath\");\n\t\tif (!lxcpath) {\n\t\t\tERROR(\"Out of memory getting lxcpath\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tret = snprintf(path, len, \"%s/%s/command\", lxcpath, name);\n\tif (ret < 0) {\n\t\tERROR(\"Error writing to command sock path\");\n\t\treturn -1;\n\t}\n\tif (ret < len)\n\t\treturn 0;\n\n\t/* ret >= len; lxcpath or name is too long.  hash both */\n\ttmplen = strlen(name) + strlen(lxcpath) + 2;\n\ttmppath = alloca(tmplen);\n\tret = snprintf(tmppath, tmplen, \"%s/%s\", lxcpath, name);\n\tif (ret < 0 || ret >= tmplen) {\n\t\tERROR(\"memory error\");\n\t\treturn -1;\n\t}\n\thash = fnv_64a_buf(tmppath, ret, FNV1A_64_INIT);\n\tret = snprintf(path, len, \"lxc/%016\" PRIx64 \"/command\", hash);\n\tif (ret < 0 || ret >= len) {\n\t\tERROR(\"Command socket name too long\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd(const char *name, struct lxc_cmd_rr *cmd, int *stopped,\n\t\t   const char *lxcpath, const char *hashed_sock_name)\n{\n\tint sock, ret = -1;\n\tchar path[sizeof(((struct sockaddr_un *)0)->sun_path)] = { 0 };\n\tchar *offset = &path[1];\n\tint len;\n\tint stay_connected = cmd->req.cmd == LXC_CMD_CONSOLE;\n\n\t*stopped = 0;\n\n\t/* -2 here because this is an abstract unix socket so it needs a\n\t * leading \\0, and we null terminate, so it needs a trailing \\0.\n\t * Although null termination isn't required by the API, we do it anyway\n\t * because we print the sockname out sometimes.\n\t */\n\tlen = sizeof(path)-2;\n\tif (fill_sock_name(offset, len, name, lxcpath, hashed_sock_name))\n\t\treturn -1;\n\n\tsock = lxc_abstract_unix_connect(path);\n\tif (sock < 0) {\n\t\tif (errno == ECONNREFUSED)\n\t\t\t*stopped = 1;\n\t\telse\n\t\t\tSYSERROR(\"Command %s failed to connect to \\\"@%s\\\".\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset);\n\t\treturn -1;\n\t}\n\n\tret = lxc_abstract_unix_send_credential(sock, &cmd->req, sizeof(cmd->req));\n\tif (ret != sizeof(cmd->req)) {\n\t\tif (errno == EPIPE)\n\t\t\tgoto epipe;\n\t\tSYSERROR(\"Command %s failed to send req to \\\"@%s\\\" %d.\",\n\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\tif (ret >=0)\n\t\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (cmd->req.datalen > 0) {\n\t\tret = send(sock, cmd->req.data, cmd->req.datalen, MSG_NOSIGNAL);\n\t\tif (ret != cmd->req.datalen) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tgoto epipe;\n\t\t\tSYSERROR(\"Command %s failed to send request data to \\\"@%s\\\" %d.\",\n\t\t\t\t lxc_cmd_str(cmd->req.cmd), offset, ret);\n\t\t\tif (ret >=0)\n\t\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = lxc_cmd_rsp_recv(sock, cmd);\nout:\n\tif (!stay_connected || ret <= 0)\n\t\tclose(sock);\n\tif (stay_connected && ret > 0)\n\t\tcmd->rsp.ret = sock;\n\n\treturn ret;\n\nepipe:\n\tclose(sock);\n\t*stopped = 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_cmd_rsp_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
    "lines": "230-250",
    "snippet": "static int lxc_cmd_rsp_send(int fd, struct lxc_cmd_rsp *rsp)\n{\n\tint ret;\n\n\tret = send(fd, rsp, sizeof(*rsp), 0);\n\tif (ret != sizeof(*rsp)) {\n\t\tERROR(\"Failed to send command response %d: %s.\", ret,\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (rsp->datalen > 0) {\n\t\tret = send(fd, rsp->data, rsp->datalen, 0);\n\t\tif (ret != rsp->datalen) {\n\t\t\tWARN(\"Failed to send command response data %d: %s.\",\n\t\t\t     ret, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"af_unix.h\"",
      "#include \"mainloop.h\"",
      "#include \"confile.h\"",
      "#include \"console.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"utils.h\"",
      "#include \"start.h\"\t/* for struct lxc_handler */",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/un.h>",
      "#include <inttypes.h>",
      "#include <sys/socket.h>",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to send command response data %d: %s.\"",
            "ret",
            "strerror(errno)"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send",
          "args": [
            "fd",
            "rsp->data",
            "rsp->datalen",
            "0"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_send_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "134-162",
          "snippet": "int lxc_abstract_unix_send_fd(int fd, int sendfd, void *data, size_t size)\n{\n\tstruct msghdr msg = { 0 };\n\tstruct iovec iov;\n\tstruct cmsghdr *cmsg;\n\tchar cmsgbuf[CMSG_SPACE(sizeof(int))];\n\tchar buf[1];\n\tint *val;\n\n\tmsg.msg_control = cmsgbuf;\n\tmsg.msg_controllen = sizeof(cmsgbuf);\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(int));\n\tcmsg->cmsg_level = SOL_SOCKET;\n\tcmsg->cmsg_type = SCM_RIGHTS;\n\tval = (int *)(CMSG_DATA(cmsg));\n\t*val = sendfd;\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_namelen = 0;\n\n\tiov.iov_base = data ? data : buf;\n\tiov.iov_len = data ? size : sizeof(buf);\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\treturn sendmsg(fd, &msg, MSG_NOSIGNAL);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_send_fd(int fd, int sendfd, void *data, size_t size)\n{\n\tstruct msghdr msg = { 0 };\n\tstruct iovec iov;\n\tstruct cmsghdr *cmsg;\n\tchar cmsgbuf[CMSG_SPACE(sizeof(int))];\n\tchar buf[1];\n\tint *val;\n\n\tmsg.msg_control = cmsgbuf;\n\tmsg.msg_controllen = sizeof(cmsgbuf);\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(int));\n\tcmsg->cmsg_level = SOL_SOCKET;\n\tcmsg->cmsg_type = SCM_RIGHTS;\n\tval = (int *)(CMSG_DATA(cmsg));\n\t*val = sendfd;\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_namelen = 0;\n\n\tiov.iov_base = data ? data : buf;\n\tiov.iov_len = data ? size : sizeof(buf);\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\treturn sendmsg(fd, &msg, MSG_NOSIGNAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to send command response %d: %s.\"",
            "ret",
            "strerror(errno)"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd_rsp_send(int fd, struct lxc_cmd_rsp *rsp)\n{\n\tint ret;\n\n\tret = send(fd, rsp, sizeof(*rsp), 0);\n\tif (ret != sizeof(*rsp)) {\n\t\tERROR(\"Failed to send command response %d: %s.\", ret,\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (rsp->datalen > 0) {\n\t\tret = send(fd, rsp->data, rsp->datalen, 0);\n\t\tif (ret != rsp->datalen) {\n\t\t\tWARN(\"Failed to send command response data %d: %s.\",\n\t\t\t     ret, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_cmd_rsp_recv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
    "lines": "164-220",
    "snippet": "static int lxc_cmd_rsp_recv(int sock, struct lxc_cmd_rr *cmd)\n{\n\tint ret,rspfd;\n\tstruct lxc_cmd_rsp *rsp = &cmd->rsp;\n\n\tret = lxc_abstract_unix_recv_fd(sock, &rspfd, rsp, sizeof(*rsp));\n\tif (ret < 0) {\n\t\tWARN(\"Command %s failed to receive response: %s.\",\n\t\t     lxc_cmd_str(cmd->req.cmd), strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (cmd->req.cmd == LXC_CMD_CONSOLE) {\n\t\tstruct lxc_cmd_console_rsp_data *rspdata;\n\n\t\t/* recv() returns 0 bytes when a tty cannot be allocated,\n\t\t * rsp->ret is < 0 when the peer permission check failed\n\t\t */\n\t\tif (ret == 0 || rsp->ret < 0)\n\t\t\treturn 0;\n\n\t\trspdata = malloc(sizeof(*rspdata));\n\t\tif (!rspdata) {\n\t\t\tERROR(\"Command %s couldn't allocate response buffer.\",\n\t\t\t      lxc_cmd_str(cmd->req.cmd));\n\t\t\treturn -1;\n\t\t}\n\t\trspdata->masterfd = rspfd;\n\t\trspdata->ttynum = PTR_TO_INT(rsp->data);\n\t\trsp->data = rspdata;\n\t}\n\n\tif (rsp->datalen == 0)\n\t\treturn ret;\n\tif (rsp->datalen > LXC_CMD_DATA_MAX) {\n\t\tERROR(\"Command %s response data %d too long.\",\n\t\t      lxc_cmd_str(cmd->req.cmd), rsp->datalen);\n\t\terrno = EFBIG;\n\t\treturn -1;\n\t}\n\n\trsp->data = malloc(rsp->datalen);\n\tif (!rsp->data) {\n\t\tERROR(\"Command %s was unable to allocate response buffer.\",\n\t\t      lxc_cmd_str(cmd->req.cmd));\n\t\treturn -1;\n\t}\n\tret = recv(sock, rsp->data, rsp->datalen, 0);\n\tif (ret != rsp->datalen) {\n\t\tERROR(\"Command %s failed to receive response data: %s.\",\n\t\t      lxc_cmd_str(cmd->req.cmd), strerror(errno));\n\t\tif (ret >= 0)\n\t\t\tret = -1;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"af_unix.h\"",
      "#include \"mainloop.h\"",
      "#include \"confile.h\"",
      "#include \"console.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"utils.h\"",
      "#include \"start.h\"\t/* for struct lxc_handler */",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/un.h>",
      "#include <inttypes.h>",
      "#include <sys/socket.h>",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Command %s failed to receive response data: %s.\"",
            "lxc_cmd_str(cmd->req.cmd)",
            "strerror(errno)"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cmd_str",
          "args": [
            "cmd->req.cmd"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "128-145",
          "snippet": "static const char *lxc_cmd_str(lxc_cmd_t cmd)\n{\n\tstatic const char * const cmdname[LXC_CMD_MAX] = {\n\t\t[LXC_CMD_CONSOLE]         = \"console\",\n\t\t[LXC_CMD_STOP]            = \"stop\",\n\t\t[LXC_CMD_GET_STATE]       = \"get_state\",\n\t\t[LXC_CMD_GET_INIT_PID]    = \"get_init_pid\",\n\t\t[LXC_CMD_GET_CLONE_FLAGS] = \"get_clone_flags\",\n\t\t[LXC_CMD_GET_CGROUP]      = \"get_cgroup\",\n\t\t[LXC_CMD_GET_CONFIG_ITEM] = \"get_config_item\",\n\t\t[LXC_CMD_GET_NAME]        = \"get_name\",\n\t\t[LXC_CMD_GET_LXCPATH]     = \"get_lxcpath\",\n\t};\n\n\tif (cmd >= LXC_CMD_MAX)\n\t\treturn \"Unknown cmd\";\n\treturn cmdname[cmd];\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic const char *lxc_cmd_str(lxc_cmd_t cmd)\n{\n\tstatic const char * const cmdname[LXC_CMD_MAX] = {\n\t\t[LXC_CMD_CONSOLE]         = \"console\",\n\t\t[LXC_CMD_STOP]            = \"stop\",\n\t\t[LXC_CMD_GET_STATE]       = \"get_state\",\n\t\t[LXC_CMD_GET_INIT_PID]    = \"get_init_pid\",\n\t\t[LXC_CMD_GET_CLONE_FLAGS] = \"get_clone_flags\",\n\t\t[LXC_CMD_GET_CGROUP]      = \"get_cgroup\",\n\t\t[LXC_CMD_GET_CONFIG_ITEM] = \"get_config_item\",\n\t\t[LXC_CMD_GET_NAME]        = \"get_name\",\n\t\t[LXC_CMD_GET_LXCPATH]     = \"get_lxcpath\",\n\t};\n\n\tif (cmd >= LXC_CMD_MAX)\n\t\treturn \"Unknown cmd\";\n\treturn cmdname[cmd];\n}"
        }
      },
      {
        "call_info": {
          "callee": "recv",
          "args": [
            "sock",
            "rsp->data",
            "rsp->datalen",
            "0"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_recv_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "164-201",
          "snippet": "int lxc_abstract_unix_recv_fd(int fd, int *recvfd, void *data, size_t size)\n{\n\tstruct msghdr msg = { 0 };\n\tstruct iovec iov;\n\tstruct cmsghdr *cmsg;\n\tchar cmsgbuf[CMSG_SPACE(sizeof(int))];\n\tchar buf[1];\n\tint ret, *val;\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_namelen = 0;\n\tmsg.msg_control = cmsgbuf;\n\tmsg.msg_controllen = sizeof(cmsgbuf);\n\n\tiov.iov_base = data ? data : buf;\n\tiov.iov_len = data ? size : sizeof(buf);\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\tret = recvmsg(fd, &msg, 0);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\n\t/* if the message is wrong the variable will not be\n\t * filled and the peer will notified about a problem */\n\t*recvfd = -1;\n\n\tif (cmsg && cmsg->cmsg_len == CMSG_LEN(sizeof(int)) &&\n\t\t\tcmsg->cmsg_level == SOL_SOCKET &&\n\t\t\tcmsg->cmsg_type == SCM_RIGHTS) {\n\t\tval = (int *) CMSG_DATA(cmsg);\n\t\t*recvfd = *val;\n\t}\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_recv_fd(int fd, int *recvfd, void *data, size_t size)\n{\n\tstruct msghdr msg = { 0 };\n\tstruct iovec iov;\n\tstruct cmsghdr *cmsg;\n\tchar cmsgbuf[CMSG_SPACE(sizeof(int))];\n\tchar buf[1];\n\tint ret, *val;\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_namelen = 0;\n\tmsg.msg_control = cmsgbuf;\n\tmsg.msg_controllen = sizeof(cmsgbuf);\n\n\tiov.iov_base = data ? data : buf;\n\tiov.iov_len = data ? size : sizeof(buf);\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\tret = recvmsg(fd, &msg, 0);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\n\t/* if the message is wrong the variable will not be\n\t * filled and the peer will notified about a problem */\n\t*recvfd = -1;\n\n\tif (cmsg && cmsg->cmsg_len == CMSG_LEN(sizeof(int)) &&\n\t\t\tcmsg->cmsg_level == SOL_SOCKET &&\n\t\t\tcmsg->cmsg_type == SCM_RIGHTS) {\n\t\tval = (int *) CMSG_DATA(cmsg);\n\t\t*recvfd = *val;\n\t}\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Command %s was unable to allocate response buffer.\"",
            "lxc_cmd_str(cmd->req.cmd)"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "rsp->datalen"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Command %s response data %d too long.\"",
            "lxc_cmd_str(cmd->req.cmd)",
            "rsp->datalen"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_TO_INT",
          "args": [
            "rsp->data"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Command %s couldn't allocate response buffer.\"",
            "lxc_cmd_str(cmd->req.cmd)"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*rspdata)"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Command %s failed to receive response: %s.\"",
            "lxc_cmd_str(cmd->req.cmd)",
            "strerror(errno)"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd_rsp_recv(int sock, struct lxc_cmd_rr *cmd)\n{\n\tint ret,rspfd;\n\tstruct lxc_cmd_rsp *rsp = &cmd->rsp;\n\n\tret = lxc_abstract_unix_recv_fd(sock, &rspfd, rsp, sizeof(*rsp));\n\tif (ret < 0) {\n\t\tWARN(\"Command %s failed to receive response: %s.\",\n\t\t     lxc_cmd_str(cmd->req.cmd), strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (cmd->req.cmd == LXC_CMD_CONSOLE) {\n\t\tstruct lxc_cmd_console_rsp_data *rspdata;\n\n\t\t/* recv() returns 0 bytes when a tty cannot be allocated,\n\t\t * rsp->ret is < 0 when the peer permission check failed\n\t\t */\n\t\tif (ret == 0 || rsp->ret < 0)\n\t\t\treturn 0;\n\n\t\trspdata = malloc(sizeof(*rspdata));\n\t\tif (!rspdata) {\n\t\t\tERROR(\"Command %s couldn't allocate response buffer.\",\n\t\t\t      lxc_cmd_str(cmd->req.cmd));\n\t\t\treturn -1;\n\t\t}\n\t\trspdata->masterfd = rspfd;\n\t\trspdata->ttynum = PTR_TO_INT(rsp->data);\n\t\trsp->data = rspdata;\n\t}\n\n\tif (rsp->datalen == 0)\n\t\treturn ret;\n\tif (rsp->datalen > LXC_CMD_DATA_MAX) {\n\t\tERROR(\"Command %s response data %d too long.\",\n\t\t      lxc_cmd_str(cmd->req.cmd), rsp->datalen);\n\t\terrno = EFBIG;\n\t\treturn -1;\n\t}\n\n\trsp->data = malloc(rsp->datalen);\n\tif (!rsp->data) {\n\t\tERROR(\"Command %s was unable to allocate response buffer.\",\n\t\t      lxc_cmd_str(cmd->req.cmd));\n\t\treturn -1;\n\t}\n\tret = recv(sock, rsp->data, rsp->datalen, 0);\n\tif (ret != rsp->datalen) {\n\t\tERROR(\"Command %s failed to receive response data: %s.\",\n\t\t      lxc_cmd_str(cmd->req.cmd), strerror(errno));\n\t\tif (ret >= 0)\n\t\t\tret = -1;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "lxc_cmd_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
    "lines": "128-145",
    "snippet": "static const char *lxc_cmd_str(lxc_cmd_t cmd)\n{\n\tstatic const char * const cmdname[LXC_CMD_MAX] = {\n\t\t[LXC_CMD_CONSOLE]         = \"console\",\n\t\t[LXC_CMD_STOP]            = \"stop\",\n\t\t[LXC_CMD_GET_STATE]       = \"get_state\",\n\t\t[LXC_CMD_GET_INIT_PID]    = \"get_init_pid\",\n\t\t[LXC_CMD_GET_CLONE_FLAGS] = \"get_clone_flags\",\n\t\t[LXC_CMD_GET_CGROUP]      = \"get_cgroup\",\n\t\t[LXC_CMD_GET_CONFIG_ITEM] = \"get_config_item\",\n\t\t[LXC_CMD_GET_NAME]        = \"get_name\",\n\t\t[LXC_CMD_GET_LXCPATH]     = \"get_lxcpath\",\n\t};\n\n\tif (cmd >= LXC_CMD_MAX)\n\t\treturn \"Unknown cmd\";\n\treturn cmdname[cmd];\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"af_unix.h\"",
      "#include \"mainloop.h\"",
      "#include \"confile.h\"",
      "#include \"console.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"utils.h\"",
      "#include \"start.h\"\t/* for struct lxc_handler */",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/un.h>",
      "#include <inttypes.h>",
      "#include <sys/socket.h>",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic const char *lxc_cmd_str(lxc_cmd_t cmd)\n{\n\tstatic const char * const cmdname[LXC_CMD_MAX] = {\n\t\t[LXC_CMD_CONSOLE]         = \"console\",\n\t\t[LXC_CMD_STOP]            = \"stop\",\n\t\t[LXC_CMD_GET_STATE]       = \"get_state\",\n\t\t[LXC_CMD_GET_INIT_PID]    = \"get_init_pid\",\n\t\t[LXC_CMD_GET_CLONE_FLAGS] = \"get_clone_flags\",\n\t\t[LXC_CMD_GET_CGROUP]      = \"get_cgroup\",\n\t\t[LXC_CMD_GET_CONFIG_ITEM] = \"get_config_item\",\n\t\t[LXC_CMD_GET_NAME]        = \"get_name\",\n\t\t[LXC_CMD_GET_LXCPATH]     = \"get_lxcpath\",\n\t};\n\n\tif (cmd >= LXC_CMD_MAX)\n\t\treturn \"Unknown cmd\";\n\treturn cmdname[cmd];\n}"
  },
  {
    "function_name": "fill_sock_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
    "lines": "77-126",
    "snippet": "static int fill_sock_name(char *path, int len, const char *name,\n\t\t\t  const char *lxcpath, const char *hashed_sock_name)\n{\n\tchar *tmppath;\n\tsize_t tmplen;\n\tuint64_t hash;\n\tint ret;\n\n\tif (hashed_sock_name != NULL) {\n\t\tret = snprintf(path, len, \"lxc/%s/command\", hashed_sock_name);\n\t\tif (ret < 0 || ret >= len) {\n\t\t\tERROR(\"Error writing to command sock path\");\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (!lxcpath) {\n\t\tlxcpath = lxc_global_config_value(\"lxc.lxcpath\");\n\t\tif (!lxcpath) {\n\t\t\tERROR(\"Out of memory getting lxcpath\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tret = snprintf(path, len, \"%s/%s/command\", lxcpath, name);\n\tif (ret < 0) {\n\t\tERROR(\"Error writing to command sock path\");\n\t\treturn -1;\n\t}\n\tif (ret < len)\n\t\treturn 0;\n\n\t/* ret >= len; lxcpath or name is too long.  hash both */\n\ttmplen = strlen(name) + strlen(lxcpath) + 2;\n\ttmppath = alloca(tmplen);\n\tret = snprintf(tmppath, tmplen, \"%s/%s\", lxcpath, name);\n\tif (ret < 0 || ret >= tmplen) {\n\t\tERROR(\"memory error\");\n\t\treturn -1;\n\t}\n\thash = fnv_64a_buf(tmppath, ret, FNV1A_64_INIT);\n\tret = snprintf(path, len, \"lxc/%016\" PRIx64 \"/command\", hash);\n\tif (ret < 0 || ret >= len) {\n\t\tERROR(\"Command socket name too long\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"af_unix.h\"",
      "#include \"mainloop.h\"",
      "#include \"confile.h\"",
      "#include \"console.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"utils.h\"",
      "#include \"start.h\"\t/* for struct lxc_handler */",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/un.h>",
      "#include <inttypes.h>",
      "#include <sys/socket.h>",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Command socket name too long\""
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "len",
            "\"lxc/%016\" PRIx64 \"/command\"",
            "hash"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fnv_64a_buf",
          "args": [
            "tmppath",
            "ret",
            "FNV1A_64_INIT"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "fnv_64a_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1076-1093",
          "snippet": "uint64_t fnv_64a_buf(void *buf, size_t len, uint64_t hval)\n{\n\tunsigned char *bp;\n\n\tfor(bp = buf; bp < (unsigned char *)buf + len; bp++)\n\t{\n\t\t/* xor the bottom with the current octet */\n\t\thval ^= (uint64_t)*bp;\n\n\t\t/* gcc optimised:\n\t\t * multiply by the 64 bit FNV magic prime mod 2^64\n\t\t */\n\t\thval += (hval << 1) + (hval << 4) + (hval << 5) +\n\t\t\t(hval << 7) + (hval << 8) + (hval << 40);\n\t}\n\n\treturn hval;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nuint64_t fnv_64a_buf(void *buf, size_t len, uint64_t hval)\n{\n\tunsigned char *bp;\n\n\tfor(bp = buf; bp < (unsigned char *)buf + len; bp++)\n\t{\n\t\t/* xor the bottom with the current octet */\n\t\thval ^= (uint64_t)*bp;\n\n\t\t/* gcc optimised:\n\t\t * multiply by the 64 bit FNV magic prime mod 2^64\n\t\t */\n\t\thval += (hval << 1) + (hval << 4) + (hval << 5) +\n\t\t\t(hval << 7) + (hval << 8) + (hval << 40);\n\t}\n\n\treturn hval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"memory error\""
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tmppath",
            "tmplen",
            "\"%s/%s\"",
            "lxcpath",
            "name"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "tmplen"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "lxcpath"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error writing to command sock path\""
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "len",
            "\"%s/%s/command\"",
            "lxcpath",
            "name"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Out of memory getting lxcpath\""
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_global_config_value",
          "args": [
            "\"lxc.lxcpath\""
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_global_config_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "88-247",
          "snippet": "const char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nconst char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error writing to command sock path\""
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "len",
            "\"lxc/%s/command\"",
            "hashed_sock_name"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int fill_sock_name(char *path, int len, const char *name,\n\t\t\t  const char *lxcpath, const char *hashed_sock_name)\n{\n\tchar *tmppath;\n\tsize_t tmplen;\n\tuint64_t hash;\n\tint ret;\n\n\tif (hashed_sock_name != NULL) {\n\t\tret = snprintf(path, len, \"lxc/%s/command\", hashed_sock_name);\n\t\tif (ret < 0 || ret >= len) {\n\t\t\tERROR(\"Error writing to command sock path\");\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (!lxcpath) {\n\t\tlxcpath = lxc_global_config_value(\"lxc.lxcpath\");\n\t\tif (!lxcpath) {\n\t\t\tERROR(\"Out of memory getting lxcpath\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tret = snprintf(path, len, \"%s/%s/command\", lxcpath, name);\n\tif (ret < 0) {\n\t\tERROR(\"Error writing to command sock path\");\n\t\treturn -1;\n\t}\n\tif (ret < len)\n\t\treturn 0;\n\n\t/* ret >= len; lxcpath or name is too long.  hash both */\n\ttmplen = strlen(name) + strlen(lxcpath) + 2;\n\ttmppath = alloca(tmplen);\n\tret = snprintf(tmppath, tmplen, \"%s/%s\", lxcpath, name);\n\tif (ret < 0 || ret >= tmplen) {\n\t\tERROR(\"memory error\");\n\t\treturn -1;\n\t}\n\thash = fnv_64a_buf(tmppath, ret, FNV1A_64_INIT);\n\tret = snprintf(path, len, \"lxc/%016\" PRIx64 \"/command\", hash);\n\tif (ret < 0 || ret >= len) {\n\t\tERROR(\"Command socket name too long\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  }
]