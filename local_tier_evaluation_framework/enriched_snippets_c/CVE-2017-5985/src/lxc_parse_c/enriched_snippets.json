[
  {
    "function_name": "lxc_is_line_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/parse.c",
    "lines": "93-104",
    "snippet": "int lxc_is_line_empty(const char *line)\n{\n\tint i;\n\tsize_t len = strlen(line);\n\n\tfor (i = 0; i < len; i++)\n\t\tif (line[i] != ' ' && line[i] != '\\t' &&\n\t\t    line[i] != '\\n' && line[i] != '\\r' &&\n\t\t    line[i] != '\\f' && line[i] != '\\0')\n\t\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include \"parse.h\"",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "line"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"parse.h\"\n#include <dirent.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint lxc_is_line_empty(const char *line)\n{\n\tint i;\n\tsize_t len = strlen(line);\n\n\tfor (i = 0; i < len; i++)\n\t\tif (line[i] != ' ' && line[i] != '\\t' &&\n\t\t    line[i] != '\\n' && line[i] != '\\r' &&\n\t\t    line[i] != '\\f' && line[i] != '\\0')\n\t\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "lxc_char_right_gc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/parse.c",
    "lines": "79-91",
    "snippet": "int lxc_char_right_gc(const char *buffer, size_t len)\n{\n\tint i;\n\tfor (i = len - 1; i >= 0; i--) {\n\t\tif (buffer[i] == ' '  ||\n\t\t    buffer[i] == '\\t' ||\n\t\t    buffer[i] == '\\n' ||\n\t\t    buffer[i] == '\\0')\n\t\t\tcontinue;\n\t\treturn i + 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include \"parse.h\"",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"log.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"parse.h\"\n#include <dirent.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint lxc_char_right_gc(const char *buffer, size_t len)\n{\n\tint i;\n\tfor (i = len - 1; i >= 0; i--) {\n\t\tif (buffer[i] == ' '  ||\n\t\t    buffer[i] == '\\t' ||\n\t\t    buffer[i] == '\\n' ||\n\t\t    buffer[i] == '\\0')\n\t\t\tcontinue;\n\t\treturn i + 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_char_left_gc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/parse.c",
    "lines": "67-77",
    "snippet": "int lxc_char_left_gc(const char *buffer, size_t len)\n{\n\tsize_t i;\n\tfor (i = 0; i < len; i++) {\n\t\tif (buffer[i] == ' ' ||\n\t\t    buffer[i] == '\\t')\n\t\t\tcontinue;\n\t\treturn i;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include \"parse.h\"",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"log.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"parse.h\"\n#include <dirent.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint lxc_char_left_gc(const char *buffer, size_t len)\n{\n\tsize_t i;\n\tfor (i = 0; i < len; i++) {\n\t\tif (buffer[i] == ' ' ||\n\t\t    buffer[i] == '\\t')\n\t\t\tcontinue;\n\t\treturn i;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_file_for_each_line",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/parse.c",
    "lines": "38-65",
    "snippet": "int lxc_file_for_each_line(const char *file, lxc_file_cb callback, void *data)\n{\n\tFILE *f;\n\tint err = 0;\n\tchar *line = NULL;\n\tsize_t len = 0;\n\n\tf = fopen(file, \"r\");\n\tif (!f) {\n\t\tSYSERROR(\"failed to open %s\", file);\n\t\treturn -1;\n\t}\n\n\twhile (getline(&line, &len, f) != -1) {\n\t\terr = callback(line, data);\n\t\tif (err) {\n\t\t\t// callback rv > 0 means stop here\n\t\t\t// callback rv < 0 means error\n\t\t\tif (err < 0)\n\t\t\t\tERROR(\"Failed to parse config: %s\", line);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree(line);\n\tfclose(f);\n\treturn err;\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include \"parse.h\"",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "line"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to parse config: %s\"",
            "line"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "callback",
          "args": [
            "line",
            "data"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&line",
            "&len",
            "f"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getline.c",
          "lines": "39-60",
          "snippet": "ssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to open %s\"",
            "file"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "file",
            "\"r\""
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"parse.h\"\n#include <dirent.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint lxc_file_for_each_line(const char *file, lxc_file_cb callback, void *data)\n{\n\tFILE *f;\n\tint err = 0;\n\tchar *line = NULL;\n\tsize_t len = 0;\n\n\tf = fopen(file, \"r\");\n\tif (!f) {\n\t\tSYSERROR(\"failed to open %s\", file);\n\t\treturn -1;\n\t}\n\n\twhile (getline(&line, &len, f) != -1) {\n\t\terr = callback(line, data);\n\t\tif (err) {\n\t\t\t// callback rv > 0 means stop here\n\t\t\t// callback rv < 0 means error\n\t\t\tif (err < 0)\n\t\t\t\tERROR(\"Failed to parse config: %s\", line);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree(line);\n\tfclose(f);\n\treturn err;\n}"
  }
]