[
  {
    "function_name": "lxc_log_options_no_override",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
    "lines": "685-689",
    "snippet": "extern void lxc_log_options_no_override()\n{\n\tlxc_quiet_specified = 1;\n\tlxc_loglevel_specified = 1;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"caps.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <syslog.h>",
      "#include <time.h>",
      "#include <pthread.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <stdint.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int lxc_quiet_specified;",
      "static int lxc_loglevel_specified;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nint lxc_quiet_specified;\nstatic int lxc_loglevel_specified;\n\nextern void lxc_log_options_no_override()\n{\n\tlxc_quiet_specified = 1;\n\tlxc_loglevel_specified = 1;\n}"
  },
  {
    "function_name": "lxc_log_get_prefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
    "lines": "680-683",
    "snippet": "extern const char *lxc_log_get_prefix(void)\n{\n\treturn log_prefix;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"caps.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <syslog.h>",
      "#include <time.h>",
      "#include <pthread.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <stdint.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char log_prefix[LXC_LOG_PREFIX_SIZE] = \"lxc\";"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nstatic char log_prefix[LXC_LOG_PREFIX_SIZE] = \"lxc\";\n\nextern const char *lxc_log_get_prefix(void)\n{\n\treturn log_prefix;\n}"
  },
  {
    "function_name": "lxc_log_set_prefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
    "lines": "674-678",
    "snippet": "extern void lxc_log_set_prefix(const char *prefix)\n{\n\tstrncpy(log_prefix, prefix, sizeof(log_prefix));\n\tlog_prefix[sizeof(log_prefix) - 1] = 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"caps.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <syslog.h>",
      "#include <time.h>",
      "#include <pthread.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <stdint.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char log_prefix[LXC_LOG_PREFIX_SIZE] = \"lxc\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "log_prefix",
            "prefix",
            "sizeof(log_prefix)"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nstatic char log_prefix[LXC_LOG_PREFIX_SIZE] = \"lxc\";\n\nextern void lxc_log_set_prefix(const char *prefix)\n{\n\tstrncpy(log_prefix, prefix, sizeof(log_prefix));\n\tlog_prefix[sizeof(log_prefix) - 1] = 0;\n}"
  },
  {
    "function_name": "lxc_log_get_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
    "lines": "669-672",
    "snippet": "extern const char *lxc_log_get_file(void)\n{\n\treturn log_fname;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"caps.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <syslog.h>",
      "#include <time.h>",
      "#include <pthread.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <stdint.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *log_fname = NULL;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nstatic char *log_fname = NULL;\n\nextern const char *lxc_log_get_file(void)\n{\n\treturn log_fname;\n}"
  },
  {
    "function_name": "lxc_log_set_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
    "lines": "650-667",
    "snippet": "extern int lxc_log_set_file(int *fd, const char *fname)\n{\n\tif (*fd != -1) {\n\t\tclose(*fd);\n\t\t*fd = -1;\n\t}\n\n\tif (build_dir(fname)) {\n\t\tERROR(\"failed to create dir for log file \\\"%s\\\" : %s\", fname,\n\t\t\t\tstrerror(errno));\n\t\treturn -1;\n\t}\n\n\t*fd = log_open(fname);\n\tif (*fd == -1)\n\t\treturn -errno;\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"caps.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <syslog.h>",
      "#include <time.h>",
      "#include <pthread.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <stdint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_open",
          "args": [
            "fname"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "log_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
          "lines": "371-393",
          "snippet": "static int log_open(const char *name)\n{\n\tint fd;\n\tint newfd;\n\n\tfd = lxc_unpriv(open(name, O_CREAT | O_WRONLY |\n\t\t\t     O_APPEND | O_CLOEXEC, 0666));\n\tif (fd == -1) {\n\t\tERROR(\"failed to open log file \\\"%s\\\" : %s\", name,\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (fd > 2)\n\t\treturn fd;\n\n\tnewfd = fcntl(fd, F_DUPFD_CLOEXEC, 3);\n\tif (newfd == -1)\n\t\tERROR(\"failed to dup log fd %d : %s\", fd, strerror(errno));\n\n\tclose(fd);\n\treturn newfd;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"caps.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <pthread.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nstatic int log_open(const char *name)\n{\n\tint fd;\n\tint newfd;\n\n\tfd = lxc_unpriv(open(name, O_CREAT | O_WRONLY |\n\t\t\t     O_APPEND | O_CLOEXEC, 0666));\n\tif (fd == -1) {\n\t\tERROR(\"failed to open log file \\\"%s\\\" : %s\", name,\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (fd > 2)\n\t\treturn fd;\n\n\tnewfd = fcntl(fd, F_DUPFD_CLOEXEC, 3);\n\tif (newfd == -1)\n\t\tERROR(\"failed to dup log fd %d : %s\", fd, strerror(errno));\n\n\tclose(fd);\n\treturn newfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to create dir for log file \\\"%s\\\" : %s\"",
            "fname",
            "strerror(errno)"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_dir",
          "args": [
            "fname"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "build_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
          "lines": "340-368",
          "snippet": "static int build_dir(const char *name)\n{\n\tchar *n = strdup(name);  // because we'll be modifying it\n\tchar *p, *e;\n\tint ret;\n\n\tif (!n) {\n\t\tERROR(\"Out of memory while creating directory '%s'.\", name);\n\t\treturn -1;\n\t}\n\n\te = &n[strlen(n)];\n\tfor (p = n+1; p < e; p++) {\n\t\tif (*p != '/')\n\t\t\tcontinue;\n\t\t*p = '\\0';\n\t\tif (access(n, F_OK)) {\n\t\t\tret = lxc_unpriv(mkdir(n, 0755));\n\t\t\tif (ret && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'.\", n);\n\t\t\t\tfree(n);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\t*p = '/';\n\t}\n\tfree(n);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"caps.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <pthread.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nstatic int build_dir(const char *name)\n{\n\tchar *n = strdup(name);  // because we'll be modifying it\n\tchar *p, *e;\n\tint ret;\n\n\tif (!n) {\n\t\tERROR(\"Out of memory while creating directory '%s'.\", name);\n\t\treturn -1;\n\t}\n\n\te = &n[strlen(n)];\n\tfor (p = n+1; p < e; p++) {\n\t\tif (*p != '/')\n\t\t\tcontinue;\n\t\t*p = '\\0';\n\t\tif (access(n, F_OK)) {\n\t\t\tret = lxc_unpriv(mkdir(n, 0755));\n\t\t\tif (ret && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'.\", n);\n\t\t\t\tfree(n);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\t*p = '/';\n\t}\n\tfree(n);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "*fd"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nextern int lxc_log_set_file(int *fd, const char *fname)\n{\n\tif (*fd != -1) {\n\t\tclose(*fd);\n\t\t*fd = -1;\n\t}\n\n\tif (build_dir(fname)) {\n\t\tERROR(\"failed to create dir for log file \\\"%s\\\" : %s\", fname,\n\t\t\t\tstrerror(errno));\n\t\treturn -1;\n\t}\n\n\t*fd = log_open(fname);\n\tif (*fd == -1)\n\t\treturn -errno;\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_log_has_valid_level",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
    "lines": "637-643",
    "snippet": "extern bool lxc_log_has_valid_level(void)\n{\n\tint log_level = lxc_log_get_level();\n\tif (log_level < 0 || log_level >= LXC_LOG_PRIORITY_NOTSET)\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"caps.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <syslog.h>",
      "#include <time.h>",
      "#include <pthread.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <stdint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_log_get_level",
          "args": [],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_log_get_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
          "lines": "632-635",
          "snippet": "extern int lxc_log_get_level(void)\n{\n\treturn lxc_log_category_lxc.priority;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"caps.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <pthread.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lxc_log_category lxc_log_category_lxc = {\n\t.name\t\t= \"lxc\",\n\t.priority\t= LXC_LOG_PRIORITY_ERROR,\n\t.appender\t= &log_appender_logfile,\n\t.parent\t\t= &log_root\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nstruct lxc_log_category lxc_log_category_lxc = {\n\t.name\t\t= \"lxc\",\n\t.priority\t= LXC_LOG_PRIORITY_ERROR,\n\t.appender\t= &log_appender_logfile,\n\t.parent\t\t= &log_root\n};\n\nextern int lxc_log_get_level(void)\n{\n\treturn lxc_log_category_lxc.priority;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nextern bool lxc_log_has_valid_level(void)\n{\n\tint log_level = lxc_log_get_level();\n\tif (log_level < 0 || log_level >= LXC_LOG_PRIORITY_NOTSET)\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "lxc_log_get_level",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
    "lines": "632-635",
    "snippet": "extern int lxc_log_get_level(void)\n{\n\treturn lxc_log_category_lxc.priority;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"caps.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <syslog.h>",
      "#include <time.h>",
      "#include <pthread.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <stdint.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct lxc_log_category lxc_log_category_lxc = {\n\t.name\t\t= \"lxc\",\n\t.priority\t= LXC_LOG_PRIORITY_ERROR,\n\t.appender\t= &log_appender_logfile,\n\t.parent\t\t= &log_root\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nstruct lxc_log_category lxc_log_category_lxc = {\n\t.name\t\t= \"lxc\",\n\t.priority\t= LXC_LOG_PRIORITY_ERROR,\n\t.appender\t= &log_appender_logfile,\n\t.parent\t\t= &log_root\n};\n\nextern int lxc_log_get_level(void)\n{\n\treturn lxc_log_category_lxc.priority;\n}"
  },
  {
    "function_name": "lxc_log_set_level",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
    "lines": "622-630",
    "snippet": "extern int lxc_log_set_level(int *dest, int level)\n{\n\tif (level < 0 || level >= LXC_LOG_PRIORITY_NOTSET) {\n\t\tERROR(\"invalid log priority %d\", level);\n\t\treturn -1;\n\t}\n\t*dest = level;\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"caps.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <syslog.h>",
      "#include <time.h>",
      "#include <pthread.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <stdint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"invalid log priority %d\"",
            "level"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nextern int lxc_log_set_level(int *dest, int level)\n{\n\tif (level < 0 || level >= LXC_LOG_PRIORITY_NOTSET) {\n\t\tERROR(\"invalid log priority %d\", level);\n\t\treturn -1;\n\t}\n\t*dest = level;\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_log_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
    "lines": "546-615",
    "snippet": "extern int lxc_log_init(const char *name, const char *file,\n\t\t\tconst char *priority, const char *prefix, int quiet,\n\t\t\tconst char *lxcpath)\n{\n\tint lxc_priority = LXC_LOG_PRIORITY_ERROR;\n\tint ret;\n\n\tif (lxc_log_fd != -1) {\n\t\tWARN(\"lxc_log_init called with log already initialized\");\n\t\treturn 0;\n\t}\n\n\tif (priority)\n\t\tlxc_priority = lxc_log_priority_to_int(priority);\n\n\tif (!lxc_loglevel_specified) {\n\t\tlxc_log_category_lxc.priority = lxc_priority;\n\t\tlxc_loglevel_specified = 1;\n\t}\n\n\tif (!lxc_quiet_specified) {\n\t\tif (!quiet)\n\t\t\tlxc_log_category_lxc.appender->next = &log_appender_stderr;\n\t}\n\n\tif (prefix)\n\t\tlxc_log_set_prefix(prefix);\n\n\tif (name)\n\t\tlog_vmname = strdup(name);\n\n\tif (file) {\n\t\tif (strcmp(file, \"none\") == 0)\n\t\t\treturn 0;\n\t\tret = __lxc_log_set_file(file, 1);\n\t\tlxc_log_use_global_fd = 1;\n\t} else {\n\t\t/* if no name was specified, there nothing to do */\n\t\tif (!name)\n\t\t\treturn 0;\n\n\t\tret = -1;\n\n\t\tif (!lxcpath)\n\t\t\tlxcpath = LOGPATH;\n\n\t\t/* try LOGPATH if lxcpath is the default for the privileged containers */\n\t\tif (!geteuid() && strcmp(LXCPATH, lxcpath) == 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\n\t\t/* try in lxcpath */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, lxcpath, 1);\n\n\t\t/* try LOGPATH in case its writable by the caller */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\t}\n\n\t/*\n\t * If !file, that is, if the user did not request this logpath, then\n\t * ignore failures and continue logging to console\n\t */\n\tif (!file && ret != 0) {\n\t\tINFO(\"Ignoring failure to open default logfile.\");\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"caps.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <syslog.h>",
      "#include <time.h>",
      "#include <pthread.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <stdint.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int lxc_log_fd = -1;",
      "int lxc_quiet_specified;",
      "int lxc_log_use_global_fd;",
      "static int lxc_loglevel_specified;",
      "static char *log_vmname = NULL;",
      "static struct lxc_log_appender log_appender_stderr = {\n\t.name\t\t= \"stderr\",\n\t.append\t\t= log_append_stderr,\n\t.next\t\t= NULL,\n};",
      "struct lxc_log_category lxc_log_category_lxc = {\n\t.name\t\t= \"lxc\",\n\t.priority\t= LXC_LOG_PRIORITY_ERROR,\n\t.appender\t= &log_appender_logfile,\n\t.parent\t\t= &log_root\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Ignoring failure to open default logfile.\""
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_lxc_log_set_file",
          "args": [
            "name",
            "NULL",
            "0"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "_lxc_log_set_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
          "lines": "504-517",
          "snippet": "static int _lxc_log_set_file(const char *name, const char *lxcpath, int create_dirs)\n{\n\tchar *logfile;\n\tint ret;\n\n\tlogfile = build_log_path(name, lxcpath);\n\tif (!logfile) {\n\t\tERROR(\"could not build log path\");\n\t\treturn -1;\n\t}\n\tret = __lxc_log_set_file(logfile, create_dirs);\n\tfree(logfile);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"caps.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <pthread.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nstatic int _lxc_log_set_file(const char *name, const char *lxcpath, int create_dirs)\n{\n\tchar *logfile;\n\tint ret;\n\n\tlogfile = build_log_path(name, lxcpath);\n\tif (!logfile) {\n\t\tERROR(\"could not build log path\");\n\t\treturn -1;\n\t}\n\tret = __lxc_log_set_file(logfile, create_dirs);\n\tfree(logfile);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "LXCPATH",
            "lxcpath"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__lxc_log_set_file",
          "args": [
            "file",
            "1"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "__lxc_log_set_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
          "lines": "470-502",
          "snippet": "static int __lxc_log_set_file(const char *fname, int create_dirs)\n{\n\tif (lxc_log_fd != -1) {\n\t\t// we are overriding the default.\n\t\tlxc_log_close();\n\t}\n\n\tif (!fname)\n\t\treturn -1;\n\n\tif (strlen(fname) == 0) {\n\t\tlog_fname = NULL;\n\t\treturn 0;\n\t}\n\n#if USE_CONFIGPATH_LOGS\n\t// we don't build_dir for the default if the default is\n\t// i.e. /var/lib/lxc/$container/$container.log\n\tif (create_dirs)\n#endif\n\tif (build_dir(fname)) {\n\t\tERROR(\"failed to create dir for log file \\\"%s\\\" : %s\", fname,\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n\tlxc_log_fd = log_open(fname);\n\tif (lxc_log_fd == -1)\n\t\treturn -1;\n\n\tlog_fname = strdup(fname);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"caps.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <pthread.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int lxc_log_fd = -1;",
            "static char *log_fname = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nint lxc_log_fd = -1;\nstatic char *log_fname = NULL;\n\nstatic int __lxc_log_set_file(const char *fname, int create_dirs)\n{\n\tif (lxc_log_fd != -1) {\n\t\t// we are overriding the default.\n\t\tlxc_log_close();\n\t}\n\n\tif (!fname)\n\t\treturn -1;\n\n\tif (strlen(fname) == 0) {\n\t\tlog_fname = NULL;\n\t\treturn 0;\n\t}\n\n#if USE_CONFIGPATH_LOGS\n\t// we don't build_dir for the default if the default is\n\t// i.e. /var/lib/lxc/$container/$container.log\n\tif (create_dirs)\n#endif\n\tif (build_dir(fname)) {\n\t\tERROR(\"failed to create dir for log file \\\"%s\\\" : %s\", fname,\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n\tlxc_log_fd = log_open(fname);\n\tif (lxc_log_fd == -1)\n\t\treturn -1;\n\n\tlog_fname = strdup(fname);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "file",
            "\"none\""
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "name"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_log_set_prefix",
          "args": [
            "prefix"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_log_set_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
          "lines": "674-678",
          "snippet": "extern void lxc_log_set_prefix(const char *prefix)\n{\n\tstrncpy(log_prefix, prefix, sizeof(log_prefix));\n\tlog_prefix[sizeof(log_prefix) - 1] = 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"caps.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <pthread.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char log_prefix[LXC_LOG_PREFIX_SIZE] = \"lxc\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nstatic char log_prefix[LXC_LOG_PREFIX_SIZE] = \"lxc\";\n\nextern void lxc_log_set_prefix(const char *prefix)\n{\n\tstrncpy(log_prefix, prefix, sizeof(log_prefix));\n\tlog_prefix[sizeof(log_prefix) - 1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_log_priority_to_int",
          "args": [
            "priority"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_log_priority_to_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.h",
          "lines": "178-191",
          "snippet": "static inline int lxc_log_priority_to_int(const char* name)\n{\n\tif (!strcasecmp(\"TRACE\",  name)) return LXC_LOG_PRIORITY_TRACE;\n\tif (!strcasecmp(\"DEBUG\",  name)) return LXC_LOG_PRIORITY_DEBUG;\n\tif (!strcasecmp(\"INFO\",   name)) return LXC_LOG_PRIORITY_INFO;\n\tif (!strcasecmp(\"NOTICE\", name)) return LXC_LOG_PRIORITY_NOTICE;\n\tif (!strcasecmp(\"WARN\",   name)) return LXC_LOG_PRIORITY_WARN;\n\tif (!strcasecmp(\"ERROR\",  name)) return LXC_LOG_PRIORITY_ERROR;\n\tif (!strcasecmp(\"CRIT\",   name)) return LXC_LOG_PRIORITY_CRIT;\n\tif (!strcasecmp(\"ALERT\",  name)) return LXC_LOG_PRIORITY_ALERT;\n\tif (!strcasecmp(\"FATAL\",  name)) return LXC_LOG_PRIORITY_FATAL;\n\n\treturn LXC_LOG_PRIORITY_NOTSET;\n}",
          "includes": [
            "#include \"conf.h\"",
            "#include <time.h>",
            "#include <syslog.h>",
            "#include <stdbool.h>",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <sys/time.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"conf.h\"\n#include <time.h>\n#include <syslog.h>\n#include <stdbool.h>\n#include <strings.h>\n#include <string.h>\n#include <sys/time.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic inline int lxc_log_priority_to_int(const char* name)\n{\n\tif (!strcasecmp(\"TRACE\",  name)) return LXC_LOG_PRIORITY_TRACE;\n\tif (!strcasecmp(\"DEBUG\",  name)) return LXC_LOG_PRIORITY_DEBUG;\n\tif (!strcasecmp(\"INFO\",   name)) return LXC_LOG_PRIORITY_INFO;\n\tif (!strcasecmp(\"NOTICE\", name)) return LXC_LOG_PRIORITY_NOTICE;\n\tif (!strcasecmp(\"WARN\",   name)) return LXC_LOG_PRIORITY_WARN;\n\tif (!strcasecmp(\"ERROR\",  name)) return LXC_LOG_PRIORITY_ERROR;\n\tif (!strcasecmp(\"CRIT\",   name)) return LXC_LOG_PRIORITY_CRIT;\n\tif (!strcasecmp(\"ALERT\",  name)) return LXC_LOG_PRIORITY_ALERT;\n\tif (!strcasecmp(\"FATAL\",  name)) return LXC_LOG_PRIORITY_FATAL;\n\n\treturn LXC_LOG_PRIORITY_NOTSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"lxc_log_init called with log already initialized\""
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nint lxc_log_fd = -1;\nint lxc_quiet_specified;\nint lxc_log_use_global_fd;\nstatic int lxc_loglevel_specified;\nstatic char *log_vmname = NULL;\nstatic struct lxc_log_appender log_appender_stderr = {\n\t.name\t\t= \"stderr\",\n\t.append\t\t= log_append_stderr,\n\t.next\t\t= NULL,\n};\nstruct lxc_log_category lxc_log_category_lxc = {\n\t.name\t\t= \"lxc\",\n\t.priority\t= LXC_LOG_PRIORITY_ERROR,\n\t.appender\t= &log_appender_logfile,\n\t.parent\t\t= &log_root\n};\n\nextern int lxc_log_init(const char *name, const char *file,\n\t\t\tconst char *priority, const char *prefix, int quiet,\n\t\t\tconst char *lxcpath)\n{\n\tint lxc_priority = LXC_LOG_PRIORITY_ERROR;\n\tint ret;\n\n\tif (lxc_log_fd != -1) {\n\t\tWARN(\"lxc_log_init called with log already initialized\");\n\t\treturn 0;\n\t}\n\n\tif (priority)\n\t\tlxc_priority = lxc_log_priority_to_int(priority);\n\n\tif (!lxc_loglevel_specified) {\n\t\tlxc_log_category_lxc.priority = lxc_priority;\n\t\tlxc_loglevel_specified = 1;\n\t}\n\n\tif (!lxc_quiet_specified) {\n\t\tif (!quiet)\n\t\t\tlxc_log_category_lxc.appender->next = &log_appender_stderr;\n\t}\n\n\tif (prefix)\n\t\tlxc_log_set_prefix(prefix);\n\n\tif (name)\n\t\tlog_vmname = strdup(name);\n\n\tif (file) {\n\t\tif (strcmp(file, \"none\") == 0)\n\t\t\treturn 0;\n\t\tret = __lxc_log_set_file(file, 1);\n\t\tlxc_log_use_global_fd = 1;\n\t} else {\n\t\t/* if no name was specified, there nothing to do */\n\t\tif (!name)\n\t\t\treturn 0;\n\n\t\tret = -1;\n\n\t\tif (!lxcpath)\n\t\t\tlxcpath = LOGPATH;\n\n\t\t/* try LOGPATH if lxcpath is the default for the privileged containers */\n\t\tif (!geteuid() && strcmp(LXCPATH, lxcpath) == 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\n\t\t/* try in lxcpath */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, lxcpath, 1);\n\n\t\t/* try LOGPATH in case its writable by the caller */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\t}\n\n\t/*\n\t * If !file, that is, if the user did not request this logpath, then\n\t * ignore failures and continue logging to console\n\t */\n\tif (!file && ret != 0) {\n\t\tINFO(\"Ignoring failure to open default logfile.\");\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "lxc_log_enable_syslog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
    "lines": "536-539",
    "snippet": "extern void lxc_log_enable_syslog(void)\n{\n\tsyslog_enable = 1;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"caps.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <syslog.h>",
      "#include <time.h>",
      "#include <pthread.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <stdint.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int syslog_enable = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nstatic int syslog_enable = 0;\n\nextern void lxc_log_enable_syslog(void)\n{\n\tsyslog_enable = 1;\n}"
  },
  {
    "function_name": "lxc_log_syslog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
    "lines": "519-534",
    "snippet": "extern int lxc_log_syslog(int facility)\n{\n\tstruct lxc_log_appender *appender;\n\n\topenlog(log_prefix, LOG_PID, facility);\n\tif (!lxc_log_category_lxc.appender) {\n\t\tlxc_log_category_lxc.appender = &log_appender_syslog;\n\t\treturn 0;\n\t}\n\tappender = lxc_log_category_lxc.appender;\n\twhile (appender->next != NULL)\n\t\tappender = appender->next;\n\tappender->next = &log_appender_syslog;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"caps.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <syslog.h>",
      "#include <time.h>",
      "#include <pthread.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <stdint.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char log_prefix[LXC_LOG_PREFIX_SIZE] = \"lxc\";",
      "static struct lxc_log_appender log_appender_syslog = {\n\t.name\t\t= \"syslog\",\n\t.append\t\t= log_append_syslog,\n\t.next\t\t= NULL,\n};",
      "struct lxc_log_category lxc_log_category_lxc = {\n\t.name\t\t= \"lxc\",\n\t.priority\t= LXC_LOG_PRIORITY_ERROR,\n\t.appender\t= &log_appender_logfile,\n\t.parent\t\t= &log_root\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "openlog",
          "args": [
            "log_prefix",
            "LOG_PID",
            "facility"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nstatic char log_prefix[LXC_LOG_PREFIX_SIZE] = \"lxc\";\nstatic struct lxc_log_appender log_appender_syslog = {\n\t.name\t\t= \"syslog\",\n\t.append\t\t= log_append_syslog,\n\t.next\t\t= NULL,\n};\nstruct lxc_log_category lxc_log_category_lxc = {\n\t.name\t\t= \"lxc\",\n\t.priority\t= LXC_LOG_PRIORITY_ERROR,\n\t.appender\t= &log_appender_logfile,\n\t.parent\t\t= &log_root\n};\n\nextern int lxc_log_syslog(int facility)\n{\n\tstruct lxc_log_appender *appender;\n\n\topenlog(log_prefix, LOG_PID, facility);\n\tif (!lxc_log_category_lxc.appender) {\n\t\tlxc_log_category_lxc.appender = &log_appender_syslog;\n\t\treturn 0;\n\t}\n\tappender = lxc_log_category_lxc.appender;\n\twhile (appender->next != NULL)\n\t\tappender = appender->next;\n\tappender->next = &log_appender_syslog;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "_lxc_log_set_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
    "lines": "504-517",
    "snippet": "static int _lxc_log_set_file(const char *name, const char *lxcpath, int create_dirs)\n{\n\tchar *logfile;\n\tint ret;\n\n\tlogfile = build_log_path(name, lxcpath);\n\tif (!logfile) {\n\t\tERROR(\"could not build log path\");\n\t\treturn -1;\n\t}\n\tret = __lxc_log_set_file(logfile, create_dirs);\n\tfree(logfile);\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"caps.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <syslog.h>",
      "#include <time.h>",
      "#include <pthread.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <stdint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "logfile"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lxc_log_set_file",
          "args": [
            "logfile",
            "create_dirs"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "__lxc_log_set_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
          "lines": "470-502",
          "snippet": "static int __lxc_log_set_file(const char *fname, int create_dirs)\n{\n\tif (lxc_log_fd != -1) {\n\t\t// we are overriding the default.\n\t\tlxc_log_close();\n\t}\n\n\tif (!fname)\n\t\treturn -1;\n\n\tif (strlen(fname) == 0) {\n\t\tlog_fname = NULL;\n\t\treturn 0;\n\t}\n\n#if USE_CONFIGPATH_LOGS\n\t// we don't build_dir for the default if the default is\n\t// i.e. /var/lib/lxc/$container/$container.log\n\tif (create_dirs)\n#endif\n\tif (build_dir(fname)) {\n\t\tERROR(\"failed to create dir for log file \\\"%s\\\" : %s\", fname,\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n\tlxc_log_fd = log_open(fname);\n\tif (lxc_log_fd == -1)\n\t\treturn -1;\n\n\tlog_fname = strdup(fname);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"caps.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <pthread.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int lxc_log_fd = -1;",
            "static char *log_fname = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nint lxc_log_fd = -1;\nstatic char *log_fname = NULL;\n\nstatic int __lxc_log_set_file(const char *fname, int create_dirs)\n{\n\tif (lxc_log_fd != -1) {\n\t\t// we are overriding the default.\n\t\tlxc_log_close();\n\t}\n\n\tif (!fname)\n\t\treturn -1;\n\n\tif (strlen(fname) == 0) {\n\t\tlog_fname = NULL;\n\t\treturn 0;\n\t}\n\n#if USE_CONFIGPATH_LOGS\n\t// we don't build_dir for the default if the default is\n\t// i.e. /var/lib/lxc/$container/$container.log\n\tif (create_dirs)\n#endif\n\tif (build_dir(fname)) {\n\t\tERROR(\"failed to create dir for log file \\\"%s\\\" : %s\", fname,\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n\tlxc_log_fd = log_open(fname);\n\tif (lxc_log_fd == -1)\n\t\treturn -1;\n\n\tlog_fname = strdup(fname);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"could not build log path\""
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_log_path",
          "args": [
            "name",
            "lxcpath"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "build_log_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
          "lines": "401-447",
          "snippet": "static char *build_log_path(const char *name, const char *lxcpath)\n{\n\tchar *p;\n\tint len, ret, use_dir;\n\n\tif (!name)\n\t\treturn NULL;\n\n#if USE_CONFIGPATH_LOGS\n\tuse_dir = 1;\n#else\n\tuse_dir = 0;\n#endif\n\n\t/*\n\t * If USE_CONFIGPATH_LOGS is true or lxcpath is given, the resulting\n\t * path will be:\n\t * '$logpath' + '/' + '$name' + '/' + '$name' + '.log' + '\\0'\n\t *\n\t * If USE_CONFIGPATH_LOGS is false the resulting path will be:\n\t * '$logpath' + '/' + '$name' + '.log' + '\\0'\n\t */\n\tlen = strlen(name) + 6; /* 6 == '/' + '.log' + '\\0' */\n\tif (lxcpath)\n\t\tuse_dir = 1;\n\telse\n\t\tlxcpath = LOGPATH;\n\n\tif (use_dir)\n\t\tlen += strlen(lxcpath) + 1 + strlen(name) + 1;  /* add \"/$container_name/\" */\n\telse\n\t\tlen += strlen(lxcpath) + 1;\n\tp = malloc(len);\n\tif (!p)\n\t\treturn p;\n\n\tif (use_dir)\n\t\tret = snprintf(p, len, \"%s/%s/%s.log\", lxcpath, name, name);\n\telse\n\t\tret = snprintf(p, len, \"%s/%s.log\", lxcpath, name);\n\n\tif (ret < 0 || ret >= len) {\n\t\tfree(p);\n\t\treturn NULL;\n\t}\n\treturn p;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"caps.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <pthread.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nstatic char *build_log_path(const char *name, const char *lxcpath)\n{\n\tchar *p;\n\tint len, ret, use_dir;\n\n\tif (!name)\n\t\treturn NULL;\n\n#if USE_CONFIGPATH_LOGS\n\tuse_dir = 1;\n#else\n\tuse_dir = 0;\n#endif\n\n\t/*\n\t * If USE_CONFIGPATH_LOGS is true or lxcpath is given, the resulting\n\t * path will be:\n\t * '$logpath' + '/' + '$name' + '/' + '$name' + '.log' + '\\0'\n\t *\n\t * If USE_CONFIGPATH_LOGS is false the resulting path will be:\n\t * '$logpath' + '/' + '$name' + '.log' + '\\0'\n\t */\n\tlen = strlen(name) + 6; /* 6 == '/' + '.log' + '\\0' */\n\tif (lxcpath)\n\t\tuse_dir = 1;\n\telse\n\t\tlxcpath = LOGPATH;\n\n\tif (use_dir)\n\t\tlen += strlen(lxcpath) + 1 + strlen(name) + 1;  /* add \"/$container_name/\" */\n\telse\n\t\tlen += strlen(lxcpath) + 1;\n\tp = malloc(len);\n\tif (!p)\n\t\treturn p;\n\n\tif (use_dir)\n\t\tret = snprintf(p, len, \"%s/%s/%s.log\", lxcpath, name, name);\n\telse\n\t\tret = snprintf(p, len, \"%s/%s.log\", lxcpath, name);\n\n\tif (ret < 0 || ret >= len) {\n\t\tfree(p);\n\t\treturn NULL;\n\t}\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nstatic int _lxc_log_set_file(const char *name, const char *lxcpath, int create_dirs)\n{\n\tchar *logfile;\n\tint ret;\n\n\tlogfile = build_log_path(name, lxcpath);\n\tif (!logfile) {\n\t\tERROR(\"could not build log path\");\n\t\treturn -1;\n\t}\n\tret = __lxc_log_set_file(logfile, create_dirs);\n\tfree(logfile);\n\treturn ret;\n}"
  },
  {
    "function_name": "__lxc_log_set_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
    "lines": "470-502",
    "snippet": "static int __lxc_log_set_file(const char *fname, int create_dirs)\n{\n\tif (lxc_log_fd != -1) {\n\t\t// we are overriding the default.\n\t\tlxc_log_close();\n\t}\n\n\tif (!fname)\n\t\treturn -1;\n\n\tif (strlen(fname) == 0) {\n\t\tlog_fname = NULL;\n\t\treturn 0;\n\t}\n\n#if USE_CONFIGPATH_LOGS\n\t// we don't build_dir for the default if the default is\n\t// i.e. /var/lib/lxc/$container/$container.log\n\tif (create_dirs)\n#endif\n\tif (build_dir(fname)) {\n\t\tERROR(\"failed to create dir for log file \\\"%s\\\" : %s\", fname,\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n\tlxc_log_fd = log_open(fname);\n\tif (lxc_log_fd == -1)\n\t\treturn -1;\n\n\tlog_fname = strdup(fname);\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"caps.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <syslog.h>",
      "#include <time.h>",
      "#include <pthread.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <stdint.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int lxc_log_fd = -1;",
      "static char *log_fname = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "fname"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_open",
          "args": [
            "fname"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "log_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
          "lines": "371-393",
          "snippet": "static int log_open(const char *name)\n{\n\tint fd;\n\tint newfd;\n\n\tfd = lxc_unpriv(open(name, O_CREAT | O_WRONLY |\n\t\t\t     O_APPEND | O_CLOEXEC, 0666));\n\tif (fd == -1) {\n\t\tERROR(\"failed to open log file \\\"%s\\\" : %s\", name,\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (fd > 2)\n\t\treturn fd;\n\n\tnewfd = fcntl(fd, F_DUPFD_CLOEXEC, 3);\n\tif (newfd == -1)\n\t\tERROR(\"failed to dup log fd %d : %s\", fd, strerror(errno));\n\n\tclose(fd);\n\treturn newfd;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"caps.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <pthread.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nstatic int log_open(const char *name)\n{\n\tint fd;\n\tint newfd;\n\n\tfd = lxc_unpriv(open(name, O_CREAT | O_WRONLY |\n\t\t\t     O_APPEND | O_CLOEXEC, 0666));\n\tif (fd == -1) {\n\t\tERROR(\"failed to open log file \\\"%s\\\" : %s\", name,\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (fd > 2)\n\t\treturn fd;\n\n\tnewfd = fcntl(fd, F_DUPFD_CLOEXEC, 3);\n\tif (newfd == -1)\n\t\tERROR(\"failed to dup log fd %d : %s\", fd, strerror(errno));\n\n\tclose(fd);\n\treturn newfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to create dir for log file \\\"%s\\\" : %s\"",
            "fname",
            "strerror(errno)"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_dir",
          "args": [
            "fname"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "build_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
          "lines": "340-368",
          "snippet": "static int build_dir(const char *name)\n{\n\tchar *n = strdup(name);  // because we'll be modifying it\n\tchar *p, *e;\n\tint ret;\n\n\tif (!n) {\n\t\tERROR(\"Out of memory while creating directory '%s'.\", name);\n\t\treturn -1;\n\t}\n\n\te = &n[strlen(n)];\n\tfor (p = n+1; p < e; p++) {\n\t\tif (*p != '/')\n\t\t\tcontinue;\n\t\t*p = '\\0';\n\t\tif (access(n, F_OK)) {\n\t\t\tret = lxc_unpriv(mkdir(n, 0755));\n\t\t\tif (ret && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'.\", n);\n\t\t\t\tfree(n);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\t*p = '/';\n\t}\n\tfree(n);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"caps.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <pthread.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nstatic int build_dir(const char *name)\n{\n\tchar *n = strdup(name);  // because we'll be modifying it\n\tchar *p, *e;\n\tint ret;\n\n\tif (!n) {\n\t\tERROR(\"Out of memory while creating directory '%s'.\", name);\n\t\treturn -1;\n\t}\n\n\te = &n[strlen(n)];\n\tfor (p = n+1; p < e; p++) {\n\t\tif (*p != '/')\n\t\t\tcontinue;\n\t\t*p = '\\0';\n\t\tif (access(n, F_OK)) {\n\t\t\tret = lxc_unpriv(mkdir(n, 0755));\n\t\t\tif (ret && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'.\", n);\n\t\t\t\tfree(n);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\t*p = '/';\n\t}\n\tfree(n);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fname"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_log_close",
          "args": [],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_log_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
          "lines": "449-460",
          "snippet": "extern void lxc_log_close(void)\n{\n\tcloselog();\n\tfree(log_vmname);\n\tlog_vmname = NULL;\n\tif (lxc_log_fd == -1)\n\t\treturn;\n\tclose(lxc_log_fd);\n\tlxc_log_fd = -1;\n\tfree(log_fname);\n\tlog_fname = NULL;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"caps.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <pthread.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int lxc_log_fd = -1;",
            "static char *log_fname = NULL;",
            "static char *log_vmname = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nint lxc_log_fd = -1;\nstatic char *log_fname = NULL;\nstatic char *log_vmname = NULL;\n\nextern void lxc_log_close(void)\n{\n\tcloselog();\n\tfree(log_vmname);\n\tlog_vmname = NULL;\n\tif (lxc_log_fd == -1)\n\t\treturn;\n\tclose(lxc_log_fd);\n\tlxc_log_fd = -1;\n\tfree(log_fname);\n\tlog_fname = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nint lxc_log_fd = -1;\nstatic char *log_fname = NULL;\n\nstatic int __lxc_log_set_file(const char *fname, int create_dirs)\n{\n\tif (lxc_log_fd != -1) {\n\t\t// we are overriding the default.\n\t\tlxc_log_close();\n\t}\n\n\tif (!fname)\n\t\treturn -1;\n\n\tif (strlen(fname) == 0) {\n\t\tlog_fname = NULL;\n\t\treturn 0;\n\t}\n\n#if USE_CONFIGPATH_LOGS\n\t// we don't build_dir for the default if the default is\n\t// i.e. /var/lib/lxc/$container/$container.log\n\tif (create_dirs)\n#endif\n\tif (build_dir(fname)) {\n\t\tERROR(\"failed to create dir for log file \\\"%s\\\" : %s\", fname,\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n\tlxc_log_fd = log_open(fname);\n\tif (lxc_log_fd == -1)\n\t\treturn -1;\n\n\tlog_fname = strdup(fname);\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_log_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
    "lines": "449-460",
    "snippet": "extern void lxc_log_close(void)\n{\n\tcloselog();\n\tfree(log_vmname);\n\tlog_vmname = NULL;\n\tif (lxc_log_fd == -1)\n\t\treturn;\n\tclose(lxc_log_fd);\n\tlxc_log_fd = -1;\n\tfree(log_fname);\n\tlog_fname = NULL;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"caps.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <syslog.h>",
      "#include <time.h>",
      "#include <pthread.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <stdint.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int lxc_log_fd = -1;",
      "static char *log_fname = NULL;",
      "static char *log_vmname = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "log_fname"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "lxc_log_fd"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "closelog",
          "args": [],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nint lxc_log_fd = -1;\nstatic char *log_fname = NULL;\nstatic char *log_vmname = NULL;\n\nextern void lxc_log_close(void)\n{\n\tcloselog();\n\tfree(log_vmname);\n\tlog_vmname = NULL;\n\tif (lxc_log_fd == -1)\n\t\treturn;\n\tclose(lxc_log_fd);\n\tlxc_log_fd = -1;\n\tfree(log_fname);\n\tlog_fname = NULL;\n}"
  },
  {
    "function_name": "build_log_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
    "lines": "401-447",
    "snippet": "static char *build_log_path(const char *name, const char *lxcpath)\n{\n\tchar *p;\n\tint len, ret, use_dir;\n\n\tif (!name)\n\t\treturn NULL;\n\n#if USE_CONFIGPATH_LOGS\n\tuse_dir = 1;\n#else\n\tuse_dir = 0;\n#endif\n\n\t/*\n\t * If USE_CONFIGPATH_LOGS is true or lxcpath is given, the resulting\n\t * path will be:\n\t * '$logpath' + '/' + '$name' + '/' + '$name' + '.log' + '\\0'\n\t *\n\t * If USE_CONFIGPATH_LOGS is false the resulting path will be:\n\t * '$logpath' + '/' + '$name' + '.log' + '\\0'\n\t */\n\tlen = strlen(name) + 6; /* 6 == '/' + '.log' + '\\0' */\n\tif (lxcpath)\n\t\tuse_dir = 1;\n\telse\n\t\tlxcpath = LOGPATH;\n\n\tif (use_dir)\n\t\tlen += strlen(lxcpath) + 1 + strlen(name) + 1;  /* add \"/$container_name/\" */\n\telse\n\t\tlen += strlen(lxcpath) + 1;\n\tp = malloc(len);\n\tif (!p)\n\t\treturn p;\n\n\tif (use_dir)\n\t\tret = snprintf(p, len, \"%s/%s/%s.log\", lxcpath, name, name);\n\telse\n\t\tret = snprintf(p, len, \"%s/%s.log\", lxcpath, name);\n\n\tif (ret < 0 || ret >= len) {\n\t\tfree(p);\n\t\treturn NULL;\n\t}\n\treturn p;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"caps.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <syslog.h>",
      "#include <time.h>",
      "#include <pthread.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <stdint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "p"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "p",
            "len",
            "\"%s/%s.log\"",
            "lxcpath",
            "name"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "p",
            "len",
            "\"%s/%s/%s.log\"",
            "lxcpath",
            "name",
            "name"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "lxcpath"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "lxcpath"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nstatic char *build_log_path(const char *name, const char *lxcpath)\n{\n\tchar *p;\n\tint len, ret, use_dir;\n\n\tif (!name)\n\t\treturn NULL;\n\n#if USE_CONFIGPATH_LOGS\n\tuse_dir = 1;\n#else\n\tuse_dir = 0;\n#endif\n\n\t/*\n\t * If USE_CONFIGPATH_LOGS is true or lxcpath is given, the resulting\n\t * path will be:\n\t * '$logpath' + '/' + '$name' + '/' + '$name' + '.log' + '\\0'\n\t *\n\t * If USE_CONFIGPATH_LOGS is false the resulting path will be:\n\t * '$logpath' + '/' + '$name' + '.log' + '\\0'\n\t */\n\tlen = strlen(name) + 6; /* 6 == '/' + '.log' + '\\0' */\n\tif (lxcpath)\n\t\tuse_dir = 1;\n\telse\n\t\tlxcpath = LOGPATH;\n\n\tif (use_dir)\n\t\tlen += strlen(lxcpath) + 1 + strlen(name) + 1;  /* add \"/$container_name/\" */\n\telse\n\t\tlen += strlen(lxcpath) + 1;\n\tp = malloc(len);\n\tif (!p)\n\t\treturn p;\n\n\tif (use_dir)\n\t\tret = snprintf(p, len, \"%s/%s/%s.log\", lxcpath, name, name);\n\telse\n\t\tret = snprintf(p, len, \"%s/%s.log\", lxcpath, name);\n\n\tif (ret < 0 || ret >= len) {\n\t\tfree(p);\n\t\treturn NULL;\n\t}\n\treturn p;\n}"
  },
  {
    "function_name": "log_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
    "lines": "371-393",
    "snippet": "static int log_open(const char *name)\n{\n\tint fd;\n\tint newfd;\n\n\tfd = lxc_unpriv(open(name, O_CREAT | O_WRONLY |\n\t\t\t     O_APPEND | O_CLOEXEC, 0666));\n\tif (fd == -1) {\n\t\tERROR(\"failed to open log file \\\"%s\\\" : %s\", name,\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (fd > 2)\n\t\treturn fd;\n\n\tnewfd = fcntl(fd, F_DUPFD_CLOEXEC, 3);\n\tif (newfd == -1)\n\t\tERROR(\"failed to dup log fd %d : %s\", fd, strerror(errno));\n\n\tclose(fd);\n\treturn newfd;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"caps.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <syslog.h>",
      "#include <time.h>",
      "#include <pthread.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <stdint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to dup log fd %d : %s\"",
            "fd",
            "strerror(errno)"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "fd",
            "F_DUPFD_CLOEXEC",
            "3"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to open log file \\\"%s\\\" : %s\"",
            "name",
            "strerror(errno)"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_unpriv",
          "args": [
            "open(name, O_CREAT | O_WRONLY |\n\t\t\t     O_APPEND | O_CLOEXEC, 0666)"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "name",
            "O_CREAT | O_WRONLY |\n\t\t\t     O_APPEND | O_CLOEXEC",
            "0666"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "37-82",
          "snippet": "int lxc_abstract_unix_open(const char *path, int type, int flags)\n{\n\tint fd;\n\tsize_t len;\n\tstruct sockaddr_un addr;\n\n\tif (flags & O_TRUNC)\n\t\tunlink(path);\n\n\tfd = socket(PF_UNIX, type, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\n\t/* Clear address structure */\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (!path)\n\t\treturn fd;\n\n\taddr.sun_family = AF_UNIX;\n\n\tlen = strlen(&path[1]) + 1;\n\tif (len >= sizeof(addr.sun_path) - 1) {\n\t\tclose(fd);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\t/* addr.sun_path[0] has already been set to 0 by memset() */\n\tstrncpy(&addr.sun_path[1], &path[1], strlen(&path[1]));\n\n\tif (bind(fd, (struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path) + len)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\tif (type == SOCK_STREAM && listen(fd, 100)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_open(const char *path, int type, int flags)\n{\n\tint fd;\n\tsize_t len;\n\tstruct sockaddr_un addr;\n\n\tif (flags & O_TRUNC)\n\t\tunlink(path);\n\n\tfd = socket(PF_UNIX, type, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\n\t/* Clear address structure */\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (!path)\n\t\treturn fd;\n\n\taddr.sun_family = AF_UNIX;\n\n\tlen = strlen(&path[1]) + 1;\n\tif (len >= sizeof(addr.sun_path) - 1) {\n\t\tclose(fd);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\t/* addr.sun_path[0] has already been set to 0 by memset() */\n\tstrncpy(&addr.sun_path[1], &path[1], strlen(&path[1]));\n\n\tif (bind(fd, (struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path) + len)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\tif (type == SOCK_STREAM && listen(fd, 100)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nstatic int log_open(const char *name)\n{\n\tint fd;\n\tint newfd;\n\n\tfd = lxc_unpriv(open(name, O_CREAT | O_WRONLY |\n\t\t\t     O_APPEND | O_CLOEXEC, 0666));\n\tif (fd == -1) {\n\t\tERROR(\"failed to open log file \\\"%s\\\" : %s\", name,\n\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (fd > 2)\n\t\treturn fd;\n\n\tnewfd = fcntl(fd, F_DUPFD_CLOEXEC, 3);\n\tif (newfd == -1)\n\t\tERROR(\"failed to dup log fd %d : %s\", fd, strerror(errno));\n\n\tclose(fd);\n\treturn newfd;\n}"
  },
  {
    "function_name": "build_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
    "lines": "340-368",
    "snippet": "static int build_dir(const char *name)\n{\n\tchar *n = strdup(name);  // because we'll be modifying it\n\tchar *p, *e;\n\tint ret;\n\n\tif (!n) {\n\t\tERROR(\"Out of memory while creating directory '%s'.\", name);\n\t\treturn -1;\n\t}\n\n\te = &n[strlen(n)];\n\tfor (p = n+1; p < e; p++) {\n\t\tif (*p != '/')\n\t\t\tcontinue;\n\t\t*p = '\\0';\n\t\tif (access(n, F_OK)) {\n\t\t\tret = lxc_unpriv(mkdir(n, 0755));\n\t\t\tif (ret && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'.\", n);\n\t\t\t\tfree(n);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\t*p = '/';\n\t}\n\tfree(n);\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"caps.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <syslog.h>",
      "#include <time.h>",
      "#include <pthread.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <stdint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "n"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to create directory '%s'.\"",
            "n"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_unpriv",
          "args": [
            "mkdir(n, 0755)"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "n",
            "0755"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "241-262",
          "snippet": "extern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "n",
            "F_OK"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "n"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Out of memory while creating directory '%s'.\"",
            "name"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "name"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nstatic int build_dir(const char *name)\n{\n\tchar *n = strdup(name);  // because we'll be modifying it\n\tchar *p, *e;\n\tint ret;\n\n\tif (!n) {\n\t\tERROR(\"Out of memory while creating directory '%s'.\", name);\n\t\treturn -1;\n\t}\n\n\te = &n[strlen(n)];\n\tfor (p = n+1; p < e; p++) {\n\t\tif (*p != '/')\n\t\t\tcontinue;\n\t\t*p = '\\0';\n\t\tif (access(n, F_OK)) {\n\t\t\tret = lxc_unpriv(mkdir(n, 0755));\n\t\t\tif (ret && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'.\", n);\n\t\t\t\tfree(n);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\t*p = '/';\n\t}\n\tfree(n);\n\treturn 0;\n}"
  },
  {
    "function_name": "log_append_logfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
    "lines": "261-305",
    "snippet": "static int log_append_logfile(const struct lxc_log_appender *appender,\n\t\t\t      struct lxc_log_event *event)\n{\n\tchar buffer[LXC_LOG_BUFFER_SIZE];\n\tchar date_time[LXC_LOG_TIME_SIZE];\n\tint n;\n\tint fd_to_use = -1;\n\n#ifndef NO_LXC_CONF\n\tif (!lxc_log_use_global_fd && current_config)\n\t\tfd_to_use = current_config->logfd;\n#endif\n\n\tif (fd_to_use == -1)\n\t\tfd_to_use = lxc_log_fd;\n\n\tif (fd_to_use == -1)\n\t\treturn 0;\n\n\tif (lxc_unix_epoch_to_utc(date_time, LXC_LOG_TIME_SIZE, &event->timestamp) < 0)\n\t\treturn 0;\n\n\tn = snprintf(buffer, sizeof(buffer),\n\t\t\t\"%15s%s%s %s %-8s %s - %s:%s:%d - \",\n\t\t\tlog_prefix,\n\t\t\tlog_vmname ? \" \" : \"\",\n\t\t\tlog_vmname ? log_vmname : \"\",\n\t\t\tdate_time,\n\t\t\tlxc_log_priority_to_string(event->priority),\n\t\t\tevent->category,\n\t\t\tevent->locinfo->file, event->locinfo->func,\n\t\t\tevent->locinfo->line);\n\n\tif (n < 0)\n\t\treturn n;\n\n\tif ((size_t)n < (sizeof(buffer) - 1))\n\t\tn += vsnprintf(buffer + n, sizeof(buffer) - n, event->fmt, *event->vap);\n\telse\n\t\tn = sizeof(buffer) - 1;\n\n\tbuffer[n] = '\\n';\n\n\treturn write(fd_to_use, buffer, n + 1);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"caps.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <syslog.h>",
      "#include <time.h>",
      "#include <pthread.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <stdint.h>"
    ],
    "macros_used": [
      "#define LXC_LOG_TIME_SIZE ((LXC_NUMSTRLEN64)*2)"
    ],
    "globals_used": [
      "int lxc_log_fd = -1;",
      "int lxc_log_use_global_fd;",
      "static char log_prefix[LXC_LOG_PREFIX_SIZE] = \"lxc\";",
      "static char *log_vmname = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fd_to_use",
            "buffer",
            "n + 1"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_nointr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "327-335",
          "snippet": "ssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vsnprintf",
          "args": [
            "buffer + n",
            "sizeof(buffer) - n",
            "event->fmt",
            "*event->vap"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "\"%15s%s%s %s %-8s %s - %s:%s:%d - \"",
            "log_prefix",
            "log_vmname ? \" \" : \"\"",
            "log_vmname ? log_vmname : \"\"",
            "date_time",
            "lxc_log_priority_to_string(event->priority)",
            "event->category",
            "event->locinfo->file",
            "event->locinfo->func",
            "event->locinfo->line"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_log_priority_to_string",
          "args": [
            "event->priority"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_log_priority_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.h",
          "lines": "141-156",
          "snippet": "static inline const char* lxc_log_priority_to_string(int priority)\n{\n\tswitch (priority) {\n\tcase LXC_LOG_PRIORITY_TRACE:\treturn \"TRACE\";\n\tcase LXC_LOG_PRIORITY_DEBUG:\treturn \"DEBUG\";\n\tcase LXC_LOG_PRIORITY_INFO:\treturn \"INFO\";\n\tcase LXC_LOG_PRIORITY_NOTICE:\treturn \"NOTICE\";\n\tcase LXC_LOG_PRIORITY_WARN:\treturn \"WARN\";\n\tcase LXC_LOG_PRIORITY_ERROR:\treturn \"ERROR\";\n\tcase LXC_LOG_PRIORITY_CRIT:\treturn \"CRIT\";\n\tcase LXC_LOG_PRIORITY_ALERT:\treturn \"ALERT\";\n\tcase LXC_LOG_PRIORITY_FATAL:\treturn \"FATAL\";\n\tdefault:\n\t\treturn \"NOTSET\";\n\t}\n}",
          "includes": [
            "#include \"conf.h\"",
            "#include <time.h>",
            "#include <syslog.h>",
            "#include <stdbool.h>",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <sys/time.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"conf.h\"\n#include <time.h>\n#include <syslog.h>\n#include <stdbool.h>\n#include <strings.h>\n#include <string.h>\n#include <sys/time.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic inline const char* lxc_log_priority_to_string(int priority)\n{\n\tswitch (priority) {\n\tcase LXC_LOG_PRIORITY_TRACE:\treturn \"TRACE\";\n\tcase LXC_LOG_PRIORITY_DEBUG:\treturn \"DEBUG\";\n\tcase LXC_LOG_PRIORITY_INFO:\treturn \"INFO\";\n\tcase LXC_LOG_PRIORITY_NOTICE:\treturn \"NOTICE\";\n\tcase LXC_LOG_PRIORITY_WARN:\treturn \"WARN\";\n\tcase LXC_LOG_PRIORITY_ERROR:\treturn \"ERROR\";\n\tcase LXC_LOG_PRIORITY_CRIT:\treturn \"CRIT\";\n\tcase LXC_LOG_PRIORITY_ALERT:\treturn \"ALERT\";\n\tcase LXC_LOG_PRIORITY_FATAL:\treturn \"FATAL\";\n\tdefault:\n\t\treturn \"NOTSET\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_unix_epoch_to_utc",
          "args": [
            "date_time",
            "LXC_LOG_TIME_SIZE",
            "&event->timestamp"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_unix_epoch_to_utc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
          "lines": "143-239",
          "snippet": "int lxc_unix_epoch_to_utc(char *buf, size_t bufsize, const struct timespec *time)\n{\n\tint64_t epoch_to_days, z, era, doe, yoe, year, doy, mp, day, month,\n\t    d_in_s, hours, h_in_s, minutes, seconds;\n\tchar nanosec[LXC_NUMSTRLEN64];\n\tint ret;\n\n\t/* See https://howardhinnant.github.io/date_algorithms.html for an\n\t * explanation of the algorithm used here.\n\t */\n\n\t/* Convert Epoch in seconds to number of days. */\n\tepoch_to_days = time->tv_sec / 86400;\n\n\t/* Shift the Epoch from 1970-01-01 to 0000-03-01. */\n\tz = epoch_to_days + 719468;\n\n\t/* compute the era from the serial date by simply dividing by the number\n\t * of days in an era (146097).\n\t */\n\tera = (z >= 0 ? z : z - 146096) / 146097;\n\n\t/* The day-of-era (doe) can then be found by subtracting the era number\n\t * times the number of days per era, from the serial date.\n\t */\n\tdoe = (z - era * 146097);\n\n\t/* From the day-of-era (doe), the year-of-era (yoe, range [0, 399]) can\n\t * be computed.\n\t */\n\tyoe = (doe - doe / 1460 + doe / 36524 - doe / 146096) / 365;\n\n\t/* Given year-of-era, and era, one can now compute the year. */\n\tyear = yoe + era * 400;\n\n\t/* Also the day-of-year, again with the year beginning on Mar. 1, can be\n\t * computed from the day-of-era and year-of-era.\n\t */\n\tdoy = doe - (365 * yoe + yoe / 4 - yoe / 100);\n\n\t/* Given day-of-year, find the month number. */\n\tmp = (5 * doy + 2) / 153;\n\n\t/* From day-of-year and month-of-year we can now easily compute\n\t * day-of-month.\n\t */\n\tday = doy - (153 * mp + 2) / 5 + 1;\n\n\t/* Transform the month number from the [0, 11] / [Mar, Feb] system to\n\t * the civil system: [1, 12] to find the correct month.\n\t */\n\tmonth = mp + (mp < 10 ? 3 : -9);\n\n\t/* The algorithm assumes that a year begins on 1 March, so add 1 before\n\t * that. */\n\tif (month < 3)\n\t\tyear++;\n\n\t/* Transform days in the epoch to seconds. */\n\td_in_s = epoch_to_days * 86400;\n\n\t/* To find the current hour simply substract the Epoch_to_days from the\n\t * total Epoch and divide by the number of seconds in an hour.\n\t */\n\thours = (time->tv_sec - d_in_s) / 3600;\n\n\t/* Transform hours to seconds. */\n\th_in_s = hours * 3600;\n\n\t/* Calculate minutes by substracting the seconds for all days in the\n\t * epoch and for all hours in the epoch and divide by the number of\n\t * minutes in an hour.\n\t */\n\tminutes = (time->tv_sec - d_in_s - h_in_s) / 60;\n\n\t/* Calculate the seconds by substracting the seconds for all days in the\n\t * epoch, hours in the epoch and minutes in the epoch.\n\t */\n\tseconds = (time->tv_sec - d_in_s - h_in_s - (minutes * 60));\n\n\t/* Make string from nanoseconds. */\n\tret = snprintf(nanosec, LXC_NUMSTRLEN64, \"%ld\", time->tv_nsec);\n\tif (ret < 0 || ret >= LXC_NUMSTRLEN64)\n\t\treturn -1;\n\n\t/* Create final timestamp for the log and shorten nanoseconds to 3\n\t * digit precision.\n\t */\n\tret = snprintf(buf, bufsize,\n\t\t       \"%\" PRId64 \"%02\" PRId64 \"%02\" PRId64 \"%02\" PRId64\n\t\t       \"%02\" PRId64 \"%02\" PRId64 \".%.3s\",\n\t\t       year, month, day, hours, minutes, seconds, nanosec);\n\tif (ret < 0 || (size_t)ret >= bufsize)\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"caps.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <pthread.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nint lxc_unix_epoch_to_utc(char *buf, size_t bufsize, const struct timespec *time)\n{\n\tint64_t epoch_to_days, z, era, doe, yoe, year, doy, mp, day, month,\n\t    d_in_s, hours, h_in_s, minutes, seconds;\n\tchar nanosec[LXC_NUMSTRLEN64];\n\tint ret;\n\n\t/* See https://howardhinnant.github.io/date_algorithms.html for an\n\t * explanation of the algorithm used here.\n\t */\n\n\t/* Convert Epoch in seconds to number of days. */\n\tepoch_to_days = time->tv_sec / 86400;\n\n\t/* Shift the Epoch from 1970-01-01 to 0000-03-01. */\n\tz = epoch_to_days + 719468;\n\n\t/* compute the era from the serial date by simply dividing by the number\n\t * of days in an era (146097).\n\t */\n\tera = (z >= 0 ? z : z - 146096) / 146097;\n\n\t/* The day-of-era (doe) can then be found by subtracting the era number\n\t * times the number of days per era, from the serial date.\n\t */\n\tdoe = (z - era * 146097);\n\n\t/* From the day-of-era (doe), the year-of-era (yoe, range [0, 399]) can\n\t * be computed.\n\t */\n\tyoe = (doe - doe / 1460 + doe / 36524 - doe / 146096) / 365;\n\n\t/* Given year-of-era, and era, one can now compute the year. */\n\tyear = yoe + era * 400;\n\n\t/* Also the day-of-year, again with the year beginning on Mar. 1, can be\n\t * computed from the day-of-era and year-of-era.\n\t */\n\tdoy = doe - (365 * yoe + yoe / 4 - yoe / 100);\n\n\t/* Given day-of-year, find the month number. */\n\tmp = (5 * doy + 2) / 153;\n\n\t/* From day-of-year and month-of-year we can now easily compute\n\t * day-of-month.\n\t */\n\tday = doy - (153 * mp + 2) / 5 + 1;\n\n\t/* Transform the month number from the [0, 11] / [Mar, Feb] system to\n\t * the civil system: [1, 12] to find the correct month.\n\t */\n\tmonth = mp + (mp < 10 ? 3 : -9);\n\n\t/* The algorithm assumes that a year begins on 1 March, so add 1 before\n\t * that. */\n\tif (month < 3)\n\t\tyear++;\n\n\t/* Transform days in the epoch to seconds. */\n\td_in_s = epoch_to_days * 86400;\n\n\t/* To find the current hour simply substract the Epoch_to_days from the\n\t * total Epoch and divide by the number of seconds in an hour.\n\t */\n\thours = (time->tv_sec - d_in_s) / 3600;\n\n\t/* Transform hours to seconds. */\n\th_in_s = hours * 3600;\n\n\t/* Calculate minutes by substracting the seconds for all days in the\n\t * epoch and for all hours in the epoch and divide by the number of\n\t * minutes in an hour.\n\t */\n\tminutes = (time->tv_sec - d_in_s - h_in_s) / 60;\n\n\t/* Calculate the seconds by substracting the seconds for all days in the\n\t * epoch, hours in the epoch and minutes in the epoch.\n\t */\n\tseconds = (time->tv_sec - d_in_s - h_in_s - (minutes * 60));\n\n\t/* Make string from nanoseconds. */\n\tret = snprintf(nanosec, LXC_NUMSTRLEN64, \"%ld\", time->tv_nsec);\n\tif (ret < 0 || ret >= LXC_NUMSTRLEN64)\n\t\treturn -1;\n\n\t/* Create final timestamp for the log and shorten nanoseconds to 3\n\t * digit precision.\n\t */\n\tret = snprintf(buf, bufsize,\n\t\t       \"%\" PRId64 \"%02\" PRId64 \"%02\" PRId64 \"%02\" PRId64\n\t\t       \"%02\" PRId64 \"%02\" PRId64 \".%.3s\",\n\t\t       year, month, day, hours, minutes, seconds, nanosec);\n\tif (ret < 0 || (size_t)ret >= bufsize)\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\n#define LXC_LOG_TIME_SIZE ((LXC_NUMSTRLEN64)*2)\n\nint lxc_log_fd = -1;\nint lxc_log_use_global_fd;\nstatic char log_prefix[LXC_LOG_PREFIX_SIZE] = \"lxc\";\nstatic char *log_vmname = NULL;\n\nstatic int log_append_logfile(const struct lxc_log_appender *appender,\n\t\t\t      struct lxc_log_event *event)\n{\n\tchar buffer[LXC_LOG_BUFFER_SIZE];\n\tchar date_time[LXC_LOG_TIME_SIZE];\n\tint n;\n\tint fd_to_use = -1;\n\n#ifndef NO_LXC_CONF\n\tif (!lxc_log_use_global_fd && current_config)\n\t\tfd_to_use = current_config->logfd;\n#endif\n\n\tif (fd_to_use == -1)\n\t\tfd_to_use = lxc_log_fd;\n\n\tif (fd_to_use == -1)\n\t\treturn 0;\n\n\tif (lxc_unix_epoch_to_utc(date_time, LXC_LOG_TIME_SIZE, &event->timestamp) < 0)\n\t\treturn 0;\n\n\tn = snprintf(buffer, sizeof(buffer),\n\t\t\t\"%15s%s%s %s %-8s %s - %s:%s:%d - \",\n\t\t\tlog_prefix,\n\t\t\tlog_vmname ? \" \" : \"\",\n\t\t\tlog_vmname ? log_vmname : \"\",\n\t\t\tdate_time,\n\t\t\tlxc_log_priority_to_string(event->priority),\n\t\t\tevent->category,\n\t\t\tevent->locinfo->file, event->locinfo->func,\n\t\t\tevent->locinfo->line);\n\n\tif (n < 0)\n\t\treturn n;\n\n\tif ((size_t)n < (sizeof(buffer) - 1))\n\t\tn += vsnprintf(buffer + n, sizeof(buffer) - n, event->fmt, *event->vap);\n\telse\n\t\tn = sizeof(buffer) - 1;\n\n\tbuffer[n] = '\\n';\n\n\treturn write(fd_to_use, buffer, n + 1);\n}"
  },
  {
    "function_name": "lxc_unix_epoch_to_utc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
    "lines": "143-239",
    "snippet": "int lxc_unix_epoch_to_utc(char *buf, size_t bufsize, const struct timespec *time)\n{\n\tint64_t epoch_to_days, z, era, doe, yoe, year, doy, mp, day, month,\n\t    d_in_s, hours, h_in_s, minutes, seconds;\n\tchar nanosec[LXC_NUMSTRLEN64];\n\tint ret;\n\n\t/* See https://howardhinnant.github.io/date_algorithms.html for an\n\t * explanation of the algorithm used here.\n\t */\n\n\t/* Convert Epoch in seconds to number of days. */\n\tepoch_to_days = time->tv_sec / 86400;\n\n\t/* Shift the Epoch from 1970-01-01 to 0000-03-01. */\n\tz = epoch_to_days + 719468;\n\n\t/* compute the era from the serial date by simply dividing by the number\n\t * of days in an era (146097).\n\t */\n\tera = (z >= 0 ? z : z - 146096) / 146097;\n\n\t/* The day-of-era (doe) can then be found by subtracting the era number\n\t * times the number of days per era, from the serial date.\n\t */\n\tdoe = (z - era * 146097);\n\n\t/* From the day-of-era (doe), the year-of-era (yoe, range [0, 399]) can\n\t * be computed.\n\t */\n\tyoe = (doe - doe / 1460 + doe / 36524 - doe / 146096) / 365;\n\n\t/* Given year-of-era, and era, one can now compute the year. */\n\tyear = yoe + era * 400;\n\n\t/* Also the day-of-year, again with the year beginning on Mar. 1, can be\n\t * computed from the day-of-era and year-of-era.\n\t */\n\tdoy = doe - (365 * yoe + yoe / 4 - yoe / 100);\n\n\t/* Given day-of-year, find the month number. */\n\tmp = (5 * doy + 2) / 153;\n\n\t/* From day-of-year and month-of-year we can now easily compute\n\t * day-of-month.\n\t */\n\tday = doy - (153 * mp + 2) / 5 + 1;\n\n\t/* Transform the month number from the [0, 11] / [Mar, Feb] system to\n\t * the civil system: [1, 12] to find the correct month.\n\t */\n\tmonth = mp + (mp < 10 ? 3 : -9);\n\n\t/* The algorithm assumes that a year begins on 1 March, so add 1 before\n\t * that. */\n\tif (month < 3)\n\t\tyear++;\n\n\t/* Transform days in the epoch to seconds. */\n\td_in_s = epoch_to_days * 86400;\n\n\t/* To find the current hour simply substract the Epoch_to_days from the\n\t * total Epoch and divide by the number of seconds in an hour.\n\t */\n\thours = (time->tv_sec - d_in_s) / 3600;\n\n\t/* Transform hours to seconds. */\n\th_in_s = hours * 3600;\n\n\t/* Calculate minutes by substracting the seconds for all days in the\n\t * epoch and for all hours in the epoch and divide by the number of\n\t * minutes in an hour.\n\t */\n\tminutes = (time->tv_sec - d_in_s - h_in_s) / 60;\n\n\t/* Calculate the seconds by substracting the seconds for all days in the\n\t * epoch, hours in the epoch and minutes in the epoch.\n\t */\n\tseconds = (time->tv_sec - d_in_s - h_in_s - (minutes * 60));\n\n\t/* Make string from nanoseconds. */\n\tret = snprintf(nanosec, LXC_NUMSTRLEN64, \"%ld\", time->tv_nsec);\n\tif (ret < 0 || ret >= LXC_NUMSTRLEN64)\n\t\treturn -1;\n\n\t/* Create final timestamp for the log and shorten nanoseconds to 3\n\t * digit precision.\n\t */\n\tret = snprintf(buf, bufsize,\n\t\t       \"%\" PRId64 \"%02\" PRId64 \"%02\" PRId64 \"%02\" PRId64\n\t\t       \"%02\" PRId64 \"%02\" PRId64 \".%.3s\",\n\t\t       year, month, day, hours, minutes, seconds, nanosec);\n\tif (ret < 0 || (size_t)ret >= bufsize)\n\t\treturn -1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"caps.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <syslog.h>",
      "#include <time.h>",
      "#include <pthread.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <stdint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufsize",
            "\"%\" PRId64 \"%02\" PRId64 \"%02\" PRId64 \"%02\" PRId64\n\t\t       \"%02\" PRId64 \"%02\" PRId64 \".%.3s\"",
            "year",
            "month",
            "day",
            "hours",
            "minutes",
            "seconds",
            "nanosec"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "nanosec",
            "LXC_NUMSTRLEN64",
            "\"%ld\"",
            "time->tv_nsec"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nint lxc_unix_epoch_to_utc(char *buf, size_t bufsize, const struct timespec *time)\n{\n\tint64_t epoch_to_days, z, era, doe, yoe, year, doy, mp, day, month,\n\t    d_in_s, hours, h_in_s, minutes, seconds;\n\tchar nanosec[LXC_NUMSTRLEN64];\n\tint ret;\n\n\t/* See https://howardhinnant.github.io/date_algorithms.html for an\n\t * explanation of the algorithm used here.\n\t */\n\n\t/* Convert Epoch in seconds to number of days. */\n\tepoch_to_days = time->tv_sec / 86400;\n\n\t/* Shift the Epoch from 1970-01-01 to 0000-03-01. */\n\tz = epoch_to_days + 719468;\n\n\t/* compute the era from the serial date by simply dividing by the number\n\t * of days in an era (146097).\n\t */\n\tera = (z >= 0 ? z : z - 146096) / 146097;\n\n\t/* The day-of-era (doe) can then be found by subtracting the era number\n\t * times the number of days per era, from the serial date.\n\t */\n\tdoe = (z - era * 146097);\n\n\t/* From the day-of-era (doe), the year-of-era (yoe, range [0, 399]) can\n\t * be computed.\n\t */\n\tyoe = (doe - doe / 1460 + doe / 36524 - doe / 146096) / 365;\n\n\t/* Given year-of-era, and era, one can now compute the year. */\n\tyear = yoe + era * 400;\n\n\t/* Also the day-of-year, again with the year beginning on Mar. 1, can be\n\t * computed from the day-of-era and year-of-era.\n\t */\n\tdoy = doe - (365 * yoe + yoe / 4 - yoe / 100);\n\n\t/* Given day-of-year, find the month number. */\n\tmp = (5 * doy + 2) / 153;\n\n\t/* From day-of-year and month-of-year we can now easily compute\n\t * day-of-month.\n\t */\n\tday = doy - (153 * mp + 2) / 5 + 1;\n\n\t/* Transform the month number from the [0, 11] / [Mar, Feb] system to\n\t * the civil system: [1, 12] to find the correct month.\n\t */\n\tmonth = mp + (mp < 10 ? 3 : -9);\n\n\t/* The algorithm assumes that a year begins on 1 March, so add 1 before\n\t * that. */\n\tif (month < 3)\n\t\tyear++;\n\n\t/* Transform days in the epoch to seconds. */\n\td_in_s = epoch_to_days * 86400;\n\n\t/* To find the current hour simply substract the Epoch_to_days from the\n\t * total Epoch and divide by the number of seconds in an hour.\n\t */\n\thours = (time->tv_sec - d_in_s) / 3600;\n\n\t/* Transform hours to seconds. */\n\th_in_s = hours * 3600;\n\n\t/* Calculate minutes by substracting the seconds for all days in the\n\t * epoch and for all hours in the epoch and divide by the number of\n\t * minutes in an hour.\n\t */\n\tminutes = (time->tv_sec - d_in_s - h_in_s) / 60;\n\n\t/* Calculate the seconds by substracting the seconds for all days in the\n\t * epoch, hours in the epoch and minutes in the epoch.\n\t */\n\tseconds = (time->tv_sec - d_in_s - h_in_s - (minutes * 60));\n\n\t/* Make string from nanoseconds. */\n\tret = snprintf(nanosec, LXC_NUMSTRLEN64, \"%ld\", time->tv_nsec);\n\tif (ret < 0 || ret >= LXC_NUMSTRLEN64)\n\t\treturn -1;\n\n\t/* Create final timestamp for the log and shorten nanoseconds to 3\n\t * digit precision.\n\t */\n\tret = snprintf(buf, bufsize,\n\t\t       \"%\" PRId64 \"%02\" PRId64 \"%02\" PRId64 \"%02\" PRId64\n\t\t       \"%02\" PRId64 \"%02\" PRId64 \".%.3s\",\n\t\t       year, month, day, hours, minutes, seconds, nanosec);\n\tif (ret < 0 || (size_t)ret >= bufsize)\n\t\treturn -1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "log_append_stderr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
    "lines": "129-140",
    "snippet": "static int log_append_stderr(const struct lxc_log_appender *appender,\n\t\t\t     struct lxc_log_event *event)\n{\n\tif (event->priority < LXC_LOG_PRIORITY_ERROR)\n\t\treturn 0;\n\n\tfprintf(stderr, \"%s: %s%s\", log_prefix, log_vmname ? log_vmname : \"\", log_vmname ? \": \" : \"\");\n\tfprintf(stderr, \"%s: %s: %d \", event->locinfo->file, event->locinfo->func, event->locinfo->line);\n\tvfprintf(stderr, event->fmt, *event->vap);\n\tfprintf(stderr, \"\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"caps.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <syslog.h>",
      "#include <time.h>",
      "#include <pthread.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <stdint.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char log_prefix[LXC_LOG_PREFIX_SIZE] = \"lxc\";",
      "static char *log_vmname = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfprintf",
          "args": [
            "stderr",
            "event->fmt",
            "*event->vap"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: %s: %d \"",
            "event->locinfo->file",
            "event->locinfo->func",
            "event->locinfo->line"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: %s%s\"",
            "log_prefix",
            "log_vmname ? log_vmname : \"\"",
            "log_vmname ? \": \" : \"\""
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nstatic char log_prefix[LXC_LOG_PREFIX_SIZE] = \"lxc\";\nstatic char *log_vmname = NULL;\n\nstatic int log_append_stderr(const struct lxc_log_appender *appender,\n\t\t\t     struct lxc_log_event *event)\n{\n\tif (event->priority < LXC_LOG_PRIORITY_ERROR)\n\t\treturn 0;\n\n\tfprintf(stderr, \"%s: %s%s\", log_prefix, log_vmname ? log_vmname : \"\", log_vmname ? \": \" : \"\");\n\tfprintf(stderr, \"%s: %s: %d \", event->locinfo->file, event->locinfo->func, event->locinfo->line);\n\tvfprintf(stderr, event->fmt, *event->vap);\n\tfprintf(stderr, \"\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "log_append_syslog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
    "lines": "94-126",
    "snippet": "static int log_append_syslog(const struct lxc_log_appender *appender,\n\t\t\t     struct lxc_log_event *event)\n{\n\tchar *msg;\n\tint rc, len;\n\tva_list args;\n\n\tif (!syslog_enable)\n\t\treturn 0;\n\n\tva_copy(args, *event->vap);\n\tlen = vsnprintf(NULL, 0, event->fmt, args) + 1;\n\tva_end(args);\n\tmsg = malloc(len * sizeof(char));\n\tif (msg == NULL)\n\t\treturn 0;\n\trc = vsnprintf(msg, len, event->fmt, *event->vap);\n\tif (rc == -1 || rc >= len) {\n\t\tfree(msg);\n\t\treturn 0;\n\t}\n\n\tsyslog(lxc_log_priority_to_syslog(event->priority),\n\t\t\"%s%s %s - %s:%s:%d - %s\" ,\n\t\tlog_vmname ? log_vmname : \"\",\n\t\tlog_vmname ? \":\" : \"\",\n\t\tevent->category,\n\t\tevent->locinfo->file, event->locinfo->func,\n\t\tevent->locinfo->line,\n\t\tmsg);\n\tfree(msg);\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"caps.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <syslog.h>",
      "#include <time.h>",
      "#include <pthread.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <stdint.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int syslog_enable = 0;",
      "static char *log_vmname = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "msg"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "syslog",
          "args": [
            "lxc_log_priority_to_syslog(event->priority)",
            "\"%s%s %s - %s:%s:%d - %s\"",
            "log_vmname ? log_vmname : \"\"",
            "log_vmname ? \":\" : \"\"",
            "event->category",
            "event->locinfo->file",
            "event->locinfo->func",
            "event->locinfo->line",
            "msg"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_log_priority_to_syslog",
          "args": [
            "event->priority"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_log_priority_to_syslog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
          "lines": "66-91",
          "snippet": "static int lxc_log_priority_to_syslog(int priority)\n{\n\tswitch (priority) {\n\tcase LXC_LOG_PRIORITY_FATAL:\n\t\treturn LOG_EMERG;\n\tcase LXC_LOG_PRIORITY_ALERT:\n\t\treturn LOG_ALERT;\n\tcase LXC_LOG_PRIORITY_CRIT:\n\t\treturn LOG_CRIT;\n\tcase LXC_LOG_PRIORITY_ERROR:\n\t\treturn LOG_ERR;\n\tcase LXC_LOG_PRIORITY_WARN:\n\t\treturn LOG_WARNING;\n\tcase LXC_LOG_PRIORITY_NOTICE:\n\tcase LXC_LOG_PRIORITY_NOTSET:\n\t\treturn LOG_NOTICE;\n\tcase LXC_LOG_PRIORITY_INFO:\n\t\treturn LOG_INFO;\n\tcase LXC_LOG_PRIORITY_TRACE:\n\tcase LXC_LOG_PRIORITY_DEBUG:\n\t\treturn LOG_DEBUG;\n\t}\n\n\t/* Not reached */\n\treturn LOG_NOTICE;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"caps.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <pthread.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nstatic int lxc_log_priority_to_syslog(int priority)\n{\n\tswitch (priority) {\n\tcase LXC_LOG_PRIORITY_FATAL:\n\t\treturn LOG_EMERG;\n\tcase LXC_LOG_PRIORITY_ALERT:\n\t\treturn LOG_ALERT;\n\tcase LXC_LOG_PRIORITY_CRIT:\n\t\treturn LOG_CRIT;\n\tcase LXC_LOG_PRIORITY_ERROR:\n\t\treturn LOG_ERR;\n\tcase LXC_LOG_PRIORITY_WARN:\n\t\treturn LOG_WARNING;\n\tcase LXC_LOG_PRIORITY_NOTICE:\n\tcase LXC_LOG_PRIORITY_NOTSET:\n\t\treturn LOG_NOTICE;\n\tcase LXC_LOG_PRIORITY_INFO:\n\t\treturn LOG_INFO;\n\tcase LXC_LOG_PRIORITY_TRACE:\n\tcase LXC_LOG_PRIORITY_DEBUG:\n\t\treturn LOG_DEBUG;\n\t}\n\n\t/* Not reached */\n\treturn LOG_NOTICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vsnprintf",
          "args": [
            "msg",
            "len",
            "event->fmt",
            "*event->vap"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len * sizeof(char)"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vsnprintf",
          "args": [
            "NULL",
            "0",
            "event->fmt",
            "args"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_copy",
          "args": [
            "args",
            "*event->vap"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nstatic int syslog_enable = 0;\nstatic char *log_vmname = NULL;\n\nstatic int log_append_syslog(const struct lxc_log_appender *appender,\n\t\t\t     struct lxc_log_event *event)\n{\n\tchar *msg;\n\tint rc, len;\n\tva_list args;\n\n\tif (!syslog_enable)\n\t\treturn 0;\n\n\tva_copy(args, *event->vap);\n\tlen = vsnprintf(NULL, 0, event->fmt, args) + 1;\n\tva_end(args);\n\tmsg = malloc(len * sizeof(char));\n\tif (msg == NULL)\n\t\treturn 0;\n\trc = vsnprintf(msg, len, event->fmt, *event->vap);\n\tif (rc == -1 || rc >= len) {\n\t\tfree(msg);\n\t\treturn 0;\n\t}\n\n\tsyslog(lxc_log_priority_to_syslog(event->priority),\n\t\t\"%s%s %s - %s:%s:%d - %s\" ,\n\t\tlog_vmname ? log_vmname : \"\",\n\t\tlog_vmname ? \":\" : \"\",\n\t\tevent->category,\n\t\tevent->locinfo->file, event->locinfo->func,\n\t\tevent->locinfo->line,\n\t\tmsg);\n\tfree(msg);\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_log_priority_to_syslog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
    "lines": "66-91",
    "snippet": "static int lxc_log_priority_to_syslog(int priority)\n{\n\tswitch (priority) {\n\tcase LXC_LOG_PRIORITY_FATAL:\n\t\treturn LOG_EMERG;\n\tcase LXC_LOG_PRIORITY_ALERT:\n\t\treturn LOG_ALERT;\n\tcase LXC_LOG_PRIORITY_CRIT:\n\t\treturn LOG_CRIT;\n\tcase LXC_LOG_PRIORITY_ERROR:\n\t\treturn LOG_ERR;\n\tcase LXC_LOG_PRIORITY_WARN:\n\t\treturn LOG_WARNING;\n\tcase LXC_LOG_PRIORITY_NOTICE:\n\tcase LXC_LOG_PRIORITY_NOTSET:\n\t\treturn LOG_NOTICE;\n\tcase LXC_LOG_PRIORITY_INFO:\n\t\treturn LOG_INFO;\n\tcase LXC_LOG_PRIORITY_TRACE:\n\tcase LXC_LOG_PRIORITY_DEBUG:\n\t\treturn LOG_DEBUG;\n\t}\n\n\t/* Not reached */\n\treturn LOG_NOTICE;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"caps.h\"",
      "#include \"log.h\"",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <syslog.h>",
      "#include <time.h>",
      "#include <pthread.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <stdint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nstatic int lxc_log_priority_to_syslog(int priority)\n{\n\tswitch (priority) {\n\tcase LXC_LOG_PRIORITY_FATAL:\n\t\treturn LOG_EMERG;\n\tcase LXC_LOG_PRIORITY_ALERT:\n\t\treturn LOG_ALERT;\n\tcase LXC_LOG_PRIORITY_CRIT:\n\t\treturn LOG_CRIT;\n\tcase LXC_LOG_PRIORITY_ERROR:\n\t\treturn LOG_ERR;\n\tcase LXC_LOG_PRIORITY_WARN:\n\t\treturn LOG_WARNING;\n\tcase LXC_LOG_PRIORITY_NOTICE:\n\tcase LXC_LOG_PRIORITY_NOTSET:\n\t\treturn LOG_NOTICE;\n\tcase LXC_LOG_PRIORITY_INFO:\n\t\treturn LOG_INFO;\n\tcase LXC_LOG_PRIORITY_TRACE:\n\tcase LXC_LOG_PRIORITY_DEBUG:\n\t\treturn LOG_DEBUG;\n\t}\n\n\t/* Not reached */\n\treturn LOG_NOTICE;\n}"
  }
]