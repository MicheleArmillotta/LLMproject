[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_monitor.c",
    "lines": "86-207",
    "snippet": "int main(int argc, char *argv[])\n{\n\tchar *regexp;\n\tstruct lxc_msg msg;\n\tregex_t preg;\n\tstruct pollfd *fds;\n\tnfds_t nfds;\n\tint len, rc_main, rc_snp, i;\n\n\trc_main = EXIT_FAILURE;\n\n\tif (lxc_arguments_parse(&my_args, argc, argv))\n\t\texit(rc_main);\n\n\tif (!my_args.log_file)\n\t\tmy_args.log_file = \"none\";\n\n\tif (lxc_log_init(my_args.name, my_args.log_file, my_args.log_priority,\n\t\t\t my_args.progname, my_args.quiet, my_args.lxcpath[0]))\n\t\texit(rc_main);\n\tlxc_log_options_no_override();\n\n\tif (quit_monitord) {\n\t\tint ret = EXIT_SUCCESS;\n\t\tfor (i = 0; i < my_args.lxcpath_cnt; i++) {\n\t\t\tint fd;\n\n\t\t\tfd = lxc_monitor_open(my_args.lxcpath[i]);\n\t\t\tif (fd < 0) {\n\t\t\t\tERROR(\"Unable to open monitor on path: %s\", my_args.lxcpath[i]);\n\t\t\t\tret = EXIT_FAILURE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (write(fd, \"quit\", 4) < 0) {\n\t\t\t\tSYSERROR(\"Unable to close monitor on path: %s\", my_args.lxcpath[i]);\n\t\t\t\tret = EXIT_FAILURE;\n\t\t\t\tclose(fd);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(fd);\n\t\t}\n\t\texit(ret);\n\t}\n\n\tlen = strlen(my_args.name) + 3;\n\tregexp = malloc(len + 3);\n\tif (!regexp) {\n\t\tERROR(\"failed to allocate memory\");\n\t\texit(rc_main);\n\t}\n\trc_snp = snprintf(regexp, len, \"^%s$\", my_args.name);\n\tif (rc_snp < 0 || rc_snp >= len) {\n\t\tERROR(\"Name too long\");\n\t\tgoto error;\n\t}\n\n\tif (regcomp(&preg, regexp, REG_NOSUB|REG_EXTENDED)) {\n\t\tERROR(\"failed to compile the regex '%s'\", my_args.name);\n\t\tgoto error;\n\t}\n\n\tfds = malloc(my_args.lxcpath_cnt * sizeof(struct pollfd));\n\tif (!fds) {\n\t\tSYSERROR(\"out of memory\");\n\t\tgoto cleanup;\n\t}\n\n\tnfds = my_args.lxcpath_cnt;\n\tfor (i = 0; i < nfds; i++) {\n\t\tint fd;\n\n\t\tlxc_monitord_spawn(my_args.lxcpath[i]);\n\n\t\tfd = lxc_monitor_open(my_args.lxcpath[i]);\n\t\tif (fd < 0) {\n\t\t\tclose_fds(fds, i);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfds[i].fd = fd;\n\t\tfds[i].events = POLLIN;\n\t\tfds[i].revents = 0;\n\t}\n\n\tsetlinebuf(stdout);\n\n\tfor (;;) {\n\t\tif (lxc_monitor_read_fdset(fds, nfds, &msg, -1) < 0) {\n\t\t\tgoto close_and_clean;\n\t\t}\n\n\t\tmsg.name[sizeof(msg.name)-1] = '\\0';\n\t\tif (regexec(&preg, msg.name, 0, NULL, 0))\n\t\t\tcontinue;\n\n\t\tswitch (msg.type) {\n\t\tcase lxc_msg_state:\n\t\t\tprintf(\"'%s' changed state to [%s]\\n\",\n\t\t\t       msg.name, lxc_state2str(msg.value));\n\t\t\tbreak;\n\t\tcase lxc_msg_exit_code:\n\t\t\tprintf(\"'%s' exited with status [%d]\\n\",\n\t\t\t       msg.name, WEXITSTATUS(msg.value));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* ignore garbage */\n\t\t\tbreak;\n\t\t}\n\t}\n\trc_main = 0;\n\nclose_and_clean:\n\tclose_fds(fds, nfds);\n\ncleanup:\n\tregfree(&preg);\n\tfree(fds);\n\nerror:\n\tfree(regexp);\n\n\texit(rc_main);\n}",
    "includes": [
      "#include \"arguments.h\"",
      "#include \"monitor.h\"",
      "#include \"log.h\"",
      "#include \"lxc.h\"",
      "#include <poll.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <regex.h>",
      "#include <unistd.h>",
      "#include <libgen.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool quit_monitord;",
      "static struct lxc_arguments my_args = {\n\t.progname = \"lxc-monitor\",\n\t.help     = \"\\\n[--name=NAME]\\n\\\n\\n\\\nlxc-monitor monitors the state of the NAME container\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME   NAME of the container\\n\\\n                    NAME may be a regular expression\\n\\\n  -Q, --quit        tell lxc-monitord to quit\\n\",\n\t.name     = \".*\",\n\t.options  = my_longopts,\n\t.parser   = my_parser,\n\t.checker  = NULL,\n\t.lxcpath_additional = -1,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "rc_main"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "regexp"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "free_mnts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "539-554",
          "snippet": "static void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int mnt_table_size = 0;",
            "static struct mnts *mnt_table = NULL;",
            "static void free_mnts(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic unsigned int mnt_table_size = 0;\nstatic struct mnts *mnt_table = NULL;\nstatic void free_mnts(void);\n\nstatic void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "regfree",
          "args": [
            "&preg"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close_fds",
          "args": [
            "fds",
            "nfds"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "close_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_monitor.c",
          "lines": "74-84",
          "snippet": "static void close_fds(struct pollfd *fds, nfds_t nfds)\n{\n\tnfds_t i;\n\n\tif (nfds < 1)\n\t\treturn;\n\n\tfor (i = 0; i < nfds; ++i) {\n\t\tclose(fds[i].fd);\n\t}\n}",
          "includes": [
            "#include \"arguments.h\"",
            "#include \"monitor.h\"",
            "#include \"log.h\"",
            "#include \"lxc.h\"",
            "#include <poll.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <regex.h>",
            "#include <unistd.h>",
            "#include <libgen.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"arguments.h\"\n#include \"monitor.h\"\n#include \"log.h\"\n#include \"lxc.h\"\n#include <poll.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <regex.h>\n#include <unistd.h>\n#include <libgen.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic void close_fds(struct pollfd *fds, nfds_t nfds)\n{\n\tnfds_t i;\n\n\tif (nfds < 1)\n\t\treturn;\n\n\tfor (i = 0; i < nfds; ++i) {\n\t\tclose(fds[i].fd);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"'%s' exited with status [%d]\\n\"",
            "msg.name",
            "WEXITSTATUS(msg.value)"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "msg.value"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"'%s' changed state to [%s]\\n\"",
            "msg.name",
            "lxc_state2str(msg.value)"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_state2str",
          "args": [
            "msg.value"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_state2str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/state.c",
          "lines": "52-57",
          "snippet": "const char *lxc_state2str(lxc_state_t state)\n{\n\tif (state < STOPPED || state > MAX_STATE - 1)\n\t\treturn NULL;\n\treturn strstate[state];\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"monitor.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const strstate[] = {\n\t\"STOPPED\", \"STARTING\", \"RUNNING\", \"STOPPING\",\n\t\"ABORTING\", \"FREEZING\", \"FROZEN\", \"THAWED\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"monitor.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic const char * const strstate[] = {\n\t\"STOPPED\", \"STARTING\", \"RUNNING\", \"STOPPING\",\n\t\"ABORTING\", \"FREEZING\", \"FROZEN\", \"THAWED\",\n};\n\nconst char *lxc_state2str(lxc_state_t state)\n{\n\tif (state < STOPPED || state > MAX_STATE - 1)\n\t\treturn NULL;\n\treturn strstate[state];\n}"
        }
      },
      {
        "call_info": {
          "callee": "regexec",
          "args": [
            "&preg",
            "msg.name",
            "0",
            "NULL",
            "0"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_monitor_read_fdset",
          "args": [
            "fds",
            "nfds",
            "&msg",
            "-1"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_monitor_read_fdset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/monitor.c",
          "lines": "234-264",
          "snippet": "int lxc_monitor_read_fdset(struct pollfd *fds, nfds_t nfds, struct lxc_msg *msg,\n\t\t\t   int timeout)\n{\n\tlong i;\n\tint ret;\n\n\tret = poll(fds, nfds, timeout * 1000);\n\tif (ret == -1)\n\t\treturn -1;\n\telse if (ret == 0)\n\t\treturn -2;  // timed out\n\n\t/* Only read from the first ready fd, the others will remain ready for\n\t * when this routine is called again.\n\t */\n\tfor (i = 0; i < nfds; i++) {\n\t\tif (fds[i].revents != 0) {\n\t\t\tfds[i].revents = 0;\n\t\t\tret = recv(fds[i].fd, msg, sizeof(*msg), 0);\n\t\t\tif (ret <= 0) {\n\t\t\t\tSYSERROR(\"Failed to receive message. Did monitord die?: %s.\", strerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tSYSERROR(\"No ready fd found.\");\n\n\treturn -1;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"af_unix.h\"",
            "#include \"config.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include <poll.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"state.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"af_unix.h\"\n#include \"config.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_monitor_read_fdset(struct pollfd *fds, nfds_t nfds, struct lxc_msg *msg,\n\t\t\t   int timeout)\n{\n\tlong i;\n\tint ret;\n\n\tret = poll(fds, nfds, timeout * 1000);\n\tif (ret == -1)\n\t\treturn -1;\n\telse if (ret == 0)\n\t\treturn -2;  // timed out\n\n\t/* Only read from the first ready fd, the others will remain ready for\n\t * when this routine is called again.\n\t */\n\tfor (i = 0; i < nfds; i++) {\n\t\tif (fds[i].revents != 0) {\n\t\t\tfds[i].revents = 0;\n\t\t\tret = recv(fds[i].fd, msg, sizeof(*msg), 0);\n\t\t\tif (ret <= 0) {\n\t\t\t\tSYSERROR(\"Failed to receive message. Did monitord die?: %s.\", strerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tSYSERROR(\"No ready fd found.\");\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setlinebuf",
          "args": [
            "stdout"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_monitor_open",
          "args": [
            "my_args.lxcpath[i]"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_monitor_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/monitor.c",
          "lines": "190-232",
          "snippet": "int lxc_monitor_open(const char *lxcpath)\n{\n\tstruct sockaddr_un addr;\n\tint fd;\n\tsize_t retry;\n\tsize_t len;\n\tint ret = 0, backoff_ms[] = {10, 50, 100};\n\n\tif (lxc_monitor_sock_name(lxcpath, &addr) < 0)\n\t\treturn -1;\n\n\tfd = socket(PF_UNIX, SOCK_STREAM, 0);\n\tif (fd < 0) {\n\t\tERROR(\"Failed to create socket: %s.\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tlen = strlen(&addr.sun_path[1]) + 1;\n\tif (len >= sizeof(addr.sun_path) - 1) {\n\t\tret = -1;\n\t\terrno = ENAMETOOLONG;\n\t\tgoto on_error;\n\t}\n\n\tfor (retry = 0; retry < sizeof(backoff_ms) / sizeof(backoff_ms[0]); retry++) {\n\t\tret = connect(fd, (struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path) + len);\n\t\tif (ret == 0 || errno != ECONNREFUSED)\n\t\t\tbreak;\n\t\tERROR(\"Failed to connect to monitor socket. Retrying in %d ms.\", backoff_ms[retry]);\n\t\tusleep(backoff_ms[retry] * 1000);\n\t}\n\n\tif (ret < 0) {\n\t\tERROR(\"Failed to connect to monitor socket: %s.\", strerror(errno));\n\t\tgoto on_error;\n\t}\n\n\treturn fd;\n\non_error:\n\tclose(fd);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"af_unix.h\"",
            "#include \"config.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include <poll.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"state.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"af_unix.h\"\n#include \"config.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_monitor_open(const char *lxcpath)\n{\n\tstruct sockaddr_un addr;\n\tint fd;\n\tsize_t retry;\n\tsize_t len;\n\tint ret = 0, backoff_ms[] = {10, 50, 100};\n\n\tif (lxc_monitor_sock_name(lxcpath, &addr) < 0)\n\t\treturn -1;\n\n\tfd = socket(PF_UNIX, SOCK_STREAM, 0);\n\tif (fd < 0) {\n\t\tERROR(\"Failed to create socket: %s.\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tlen = strlen(&addr.sun_path[1]) + 1;\n\tif (len >= sizeof(addr.sun_path) - 1) {\n\t\tret = -1;\n\t\terrno = ENAMETOOLONG;\n\t\tgoto on_error;\n\t}\n\n\tfor (retry = 0; retry < sizeof(backoff_ms) / sizeof(backoff_ms[0]); retry++) {\n\t\tret = connect(fd, (struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path) + len);\n\t\tif (ret == 0 || errno != ECONNREFUSED)\n\t\t\tbreak;\n\t\tERROR(\"Failed to connect to monitor socket. Retrying in %d ms.\", backoff_ms[retry]);\n\t\tusleep(backoff_ms[retry] * 1000);\n\t}\n\n\tif (ret < 0) {\n\t\tERROR(\"Failed to connect to monitor socket: %s.\", strerror(errno));\n\t\tgoto on_error;\n\t}\n\n\treturn fd;\n\non_error:\n\tclose(fd);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_monitord_spawn",
          "args": [
            "my_args.lxcpath[i]"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_monitord_spawn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/monitor.c",
          "lines": "287-372",
          "snippet": "int lxc_monitord_spawn(const char *lxcpath)\n{\n\tint ret;\n\tint pipefd[2];\n\tchar pipefd_str[LXC_NUMSTRLEN64];\n\tpid_t pid1, pid2;\n\n\tchar *const args[] = {\n\t    LXC_MONITORD_PATH,\n\t    (char *)lxcpath,\n\t    pipefd_str,\n\t    NULL,\n\t};\n\n\t/* double fork to avoid zombies when monitord exits */\n\tpid1 = fork();\n\tif (pid1 < 0) {\n\t\tSYSERROR(\"Failed to fork().\");\n\t\treturn -1;\n\t}\n\n\tif (pid1) {\n\t\tDEBUG(\"Going to wait for pid %d.\", pid1);\n\t\tif (waitpid(pid1, NULL, 0) != pid1)\n\t\t\treturn -1;\n\t\tDEBUG(\"Finished waiting on pid %d.\", pid1);\n\t\treturn 0;\n\t}\n\n\tif (pipe(pipefd) < 0) {\n\t\tSYSERROR(\"Failed to create pipe.\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tpid2 = fork();\n\tif (pid2 < 0) {\n\t\tSYSERROR(\"Failed to fork().\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (pid2) {\n\t\tDEBUG(\"Trying to sync with child process.\");\n\t\tchar c;\n\t\t/* Wait for daemon to create socket. */\n\t\tclose(pipefd[1]);\n\n\t\t/* Sync with child, we're ignoring the return from read\n\t\t * because regardless if it works or not, either way we've\n\t\t * synced with the child process. the if-empty-statement\n\t\t * construct is to quiet the warn-unused-result warning.\n\t\t */\n\t\tif (read(pipefd[0], &c, 1))\n\t\t\t;\n\n\t\tclose(pipefd[0]);\n\n\t\tDEBUG(\"Successfully synced with child process.\");\n\t\texit(EXIT_SUCCESS);\n\t}\n\n\tif (setsid() < 0) {\n\t\tSYSERROR(\"Failed to setsid().\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tlxc_check_inherited(NULL, true, pipefd[1]);\n\tif (null_stdfds() < 0) {\n\t\tSYSERROR(\"Failed to dup2() standard file descriptors to /dev/null.\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tclose(pipefd[0]);\n\n\tret = snprintf(pipefd_str, LXC_NUMSTRLEN64, \"%d\", pipefd[1]);\n\tif (ret < 0 || ret >= LXC_NUMSTRLEN64) {\n\t\tERROR(\"Failed to create pid argument to pass to monitord.\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tDEBUG(\"Using pipe file descriptor %d for monitord.\", pipefd[1]);\n\n\texecvp(args[0], args);\n\tERROR(\"Failed to exec lxc-monitord.\");\n\n\texit(EXIT_FAILURE);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"af_unix.h\"",
            "#include \"config.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include <poll.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [
            "#define LXC_MONITORD_PATH LIBEXECDIR \"/lxc/lxc-monitord\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"state.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"af_unix.h\"\n#include \"config.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define LXC_MONITORD_PATH LIBEXECDIR \"/lxc/lxc-monitord\"\n\nint lxc_monitord_spawn(const char *lxcpath)\n{\n\tint ret;\n\tint pipefd[2];\n\tchar pipefd_str[LXC_NUMSTRLEN64];\n\tpid_t pid1, pid2;\n\n\tchar *const args[] = {\n\t    LXC_MONITORD_PATH,\n\t    (char *)lxcpath,\n\t    pipefd_str,\n\t    NULL,\n\t};\n\n\t/* double fork to avoid zombies when monitord exits */\n\tpid1 = fork();\n\tif (pid1 < 0) {\n\t\tSYSERROR(\"Failed to fork().\");\n\t\treturn -1;\n\t}\n\n\tif (pid1) {\n\t\tDEBUG(\"Going to wait for pid %d.\", pid1);\n\t\tif (waitpid(pid1, NULL, 0) != pid1)\n\t\t\treturn -1;\n\t\tDEBUG(\"Finished waiting on pid %d.\", pid1);\n\t\treturn 0;\n\t}\n\n\tif (pipe(pipefd) < 0) {\n\t\tSYSERROR(\"Failed to create pipe.\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tpid2 = fork();\n\tif (pid2 < 0) {\n\t\tSYSERROR(\"Failed to fork().\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (pid2) {\n\t\tDEBUG(\"Trying to sync with child process.\");\n\t\tchar c;\n\t\t/* Wait for daemon to create socket. */\n\t\tclose(pipefd[1]);\n\n\t\t/* Sync with child, we're ignoring the return from read\n\t\t * because regardless if it works or not, either way we've\n\t\t * synced with the child process. the if-empty-statement\n\t\t * construct is to quiet the warn-unused-result warning.\n\t\t */\n\t\tif (read(pipefd[0], &c, 1))\n\t\t\t;\n\n\t\tclose(pipefd[0]);\n\n\t\tDEBUG(\"Successfully synced with child process.\");\n\t\texit(EXIT_SUCCESS);\n\t}\n\n\tif (setsid() < 0) {\n\t\tSYSERROR(\"Failed to setsid().\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tlxc_check_inherited(NULL, true, pipefd[1]);\n\tif (null_stdfds() < 0) {\n\t\tSYSERROR(\"Failed to dup2() standard file descriptors to /dev/null.\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tclose(pipefd[0]);\n\n\tret = snprintf(pipefd_str, LXC_NUMSTRLEN64, \"%d\", pipefd[1]);\n\tif (ret < 0 || ret >= LXC_NUMSTRLEN64) {\n\t\tERROR(\"Failed to create pid argument to pass to monitord.\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tDEBUG(\"Using pipe file descriptor %d for monitord.\", pipefd[1]);\n\n\texecvp(args[0], args);\n\tERROR(\"Failed to exec lxc-monitord.\");\n\n\texit(EXIT_FAILURE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"out of memory\""
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "my_args.lxcpath_cnt * sizeof(struct pollfd)"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to compile the regex '%s'\"",
            "my_args.name"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "regcomp",
          "args": [
            "&preg",
            "regexp",
            "REG_NOSUB|REG_EXTENDED"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Name too long\""
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "regexp",
            "len",
            "\"^%s$\"",
            "my_args.name"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "rc_main"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to allocate memory\""
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len + 3"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "my_args.name"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "ret"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Unable to close monitor on path: %s\"",
            "my_args.lxcpath[i]"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fd",
            "\"quit\"",
            "4"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_nointr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "327-335",
          "snippet": "ssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Unable to open monitor on path: %s\"",
            "my_args.lxcpath[i]"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_log_options_no_override",
          "args": [],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_log_options_no_override",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
          "lines": "685-689",
          "snippet": "extern void lxc_log_options_no_override()\n{\n\tlxc_quiet_specified = 1;\n\tlxc_loglevel_specified = 1;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"caps.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <pthread.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int lxc_quiet_specified;",
            "static int lxc_loglevel_specified;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nint lxc_quiet_specified;\nstatic int lxc_loglevel_specified;\n\nextern void lxc_log_options_no_override()\n{\n\tlxc_quiet_specified = 1;\n\tlxc_loglevel_specified = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "rc_main"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_log_init",
          "args": [
            "my_args.name",
            "my_args.log_file",
            "my_args.log_priority",
            "my_args.progname",
            "my_args.quiet",
            "my_args.lxcpath[0]"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_log_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
          "lines": "546-615",
          "snippet": "extern int lxc_log_init(const char *name, const char *file,\n\t\t\tconst char *priority, const char *prefix, int quiet,\n\t\t\tconst char *lxcpath)\n{\n\tint lxc_priority = LXC_LOG_PRIORITY_ERROR;\n\tint ret;\n\n\tif (lxc_log_fd != -1) {\n\t\tWARN(\"lxc_log_init called with log already initialized\");\n\t\treturn 0;\n\t}\n\n\tif (priority)\n\t\tlxc_priority = lxc_log_priority_to_int(priority);\n\n\tif (!lxc_loglevel_specified) {\n\t\tlxc_log_category_lxc.priority = lxc_priority;\n\t\tlxc_loglevel_specified = 1;\n\t}\n\n\tif (!lxc_quiet_specified) {\n\t\tif (!quiet)\n\t\t\tlxc_log_category_lxc.appender->next = &log_appender_stderr;\n\t}\n\n\tif (prefix)\n\t\tlxc_log_set_prefix(prefix);\n\n\tif (name)\n\t\tlog_vmname = strdup(name);\n\n\tif (file) {\n\t\tif (strcmp(file, \"none\") == 0)\n\t\t\treturn 0;\n\t\tret = __lxc_log_set_file(file, 1);\n\t\tlxc_log_use_global_fd = 1;\n\t} else {\n\t\t/* if no name was specified, there nothing to do */\n\t\tif (!name)\n\t\t\treturn 0;\n\n\t\tret = -1;\n\n\t\tif (!lxcpath)\n\t\t\tlxcpath = LOGPATH;\n\n\t\t/* try LOGPATH if lxcpath is the default for the privileged containers */\n\t\tif (!geteuid() && strcmp(LXCPATH, lxcpath) == 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\n\t\t/* try in lxcpath */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, lxcpath, 1);\n\n\t\t/* try LOGPATH in case its writable by the caller */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\t}\n\n\t/*\n\t * If !file, that is, if the user did not request this logpath, then\n\t * ignore failures and continue logging to console\n\t */\n\tif (!file && ret != 0) {\n\t\tINFO(\"Ignoring failure to open default logfile.\");\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"caps.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <pthread.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int lxc_log_fd = -1;",
            "int lxc_quiet_specified;",
            "int lxc_log_use_global_fd;",
            "static int lxc_loglevel_specified;",
            "static char *log_vmname = NULL;",
            "static struct lxc_log_appender log_appender_stderr = {\n\t.name\t\t= \"stderr\",\n\t.append\t\t= log_append_stderr,\n\t.next\t\t= NULL,\n};",
            "struct lxc_log_category lxc_log_category_lxc = {\n\t.name\t\t= \"lxc\",\n\t.priority\t= LXC_LOG_PRIORITY_ERROR,\n\t.appender\t= &log_appender_logfile,\n\t.parent\t\t= &log_root\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nint lxc_log_fd = -1;\nint lxc_quiet_specified;\nint lxc_log_use_global_fd;\nstatic int lxc_loglevel_specified;\nstatic char *log_vmname = NULL;\nstatic struct lxc_log_appender log_appender_stderr = {\n\t.name\t\t= \"stderr\",\n\t.append\t\t= log_append_stderr,\n\t.next\t\t= NULL,\n};\nstruct lxc_log_category lxc_log_category_lxc = {\n\t.name\t\t= \"lxc\",\n\t.priority\t= LXC_LOG_PRIORITY_ERROR,\n\t.appender\t= &log_appender_logfile,\n\t.parent\t\t= &log_root\n};\n\nextern int lxc_log_init(const char *name, const char *file,\n\t\t\tconst char *priority, const char *prefix, int quiet,\n\t\t\tconst char *lxcpath)\n{\n\tint lxc_priority = LXC_LOG_PRIORITY_ERROR;\n\tint ret;\n\n\tif (lxc_log_fd != -1) {\n\t\tWARN(\"lxc_log_init called with log already initialized\");\n\t\treturn 0;\n\t}\n\n\tif (priority)\n\t\tlxc_priority = lxc_log_priority_to_int(priority);\n\n\tif (!lxc_loglevel_specified) {\n\t\tlxc_log_category_lxc.priority = lxc_priority;\n\t\tlxc_loglevel_specified = 1;\n\t}\n\n\tif (!lxc_quiet_specified) {\n\t\tif (!quiet)\n\t\t\tlxc_log_category_lxc.appender->next = &log_appender_stderr;\n\t}\n\n\tif (prefix)\n\t\tlxc_log_set_prefix(prefix);\n\n\tif (name)\n\t\tlog_vmname = strdup(name);\n\n\tif (file) {\n\t\tif (strcmp(file, \"none\") == 0)\n\t\t\treturn 0;\n\t\tret = __lxc_log_set_file(file, 1);\n\t\tlxc_log_use_global_fd = 1;\n\t} else {\n\t\t/* if no name was specified, there nothing to do */\n\t\tif (!name)\n\t\t\treturn 0;\n\n\t\tret = -1;\n\n\t\tif (!lxcpath)\n\t\t\tlxcpath = LOGPATH;\n\n\t\t/* try LOGPATH if lxcpath is the default for the privileged containers */\n\t\tif (!geteuid() && strcmp(LXCPATH, lxcpath) == 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\n\t\t/* try in lxcpath */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, lxcpath, 1);\n\n\t\t/* try LOGPATH in case its writable by the caller */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\t}\n\n\t/*\n\t * If !file, that is, if the user did not request this logpath, then\n\t * ignore failures and continue logging to console\n\t */\n\tif (!file && ret != 0) {\n\t\tINFO(\"Ignoring failure to open default logfile.\");\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "rc_main"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_arguments_parse",
          "args": [
            "&my_args",
            "argc",
            "argv"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_arguments_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/arguments.c",
          "lines": "182-252",
          "snippet": "extern int lxc_arguments_parse(struct lxc_arguments *args,\n\t\t\t       int argc, char * const argv[])\n{\n\tchar shortopts[256];\n\tint  ret = 0;\n\n\tret = build_shortopts(args->options, shortopts, sizeof(shortopts));\n\tif (ret < 0) {\n\t\tlxc_error(args, \"build_shortopts() failed : %s\",\n\t\t\t  strerror(errno));\n\t\treturn ret;\n\t}\n\n\twhile (1)  {\n\t\tint c, index = 0;\n\n\t\tc = getopt_long(argc, argv, shortopts, args->options, &index);\n\t\tif (c == -1)\n\t\t\tbreak;\n\t\tswitch (c) {\n\t\tcase 'n': \targs->name = optarg; break;\n\t\tcase 'o':\targs->log_file = optarg; break;\n\t\tcase 'l':\targs->log_priority = optarg; break;\n\t\tcase 'q':\targs->quiet = 1; break;\n\t\tcase OPT_RCFILE: args->rcfile = optarg; break;\n\t\tcase 'P':\n\t\t\tremove_trailing_slashes(optarg);\n\t\t\tret = lxc_arguments_lxcpath_add(args, optarg);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase OPT_USAGE: print_usage(args->options, args);\n\t\tcase OPT_VERSION: print_version();\n\t\tcase '?':\tprint_help(args, 1);\n\t\tcase 'h': \tprint_help(args, 0);\n\t\tdefault:\n\t\t\tif (args->parser) {\n\t\t\t\tret = args->parser(args, c, optarg);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Reclaim the remaining command arguments\n\t */\n\targs->argv = &argv[optind];\n\targs->argc = argc - optind;\n\n\t/* If no lxcpaths were given, use default */\n\tif (!args->lxcpath_cnt) {\n\t\tret = lxc_arguments_lxcpath_add(args, lxc_global_config_value(\"lxc.lxcpath\"));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t/* Check the command options */\n\n\tif (!args->name && strcmp(args->progname, \"lxc-autostart\") != 0) {\n\t\tlxc_error(args, \"missing container name, use --name option\");\n\t\treturn -1;\n\t}\n\n\tif (args->checker)\n\t\tret = args->checker(args);\nerror:\n\tif (ret)\n\t\tlxc_error(args, \"could not parse command line\");\n\treturn ret;\n}",
          "includes": [
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"arguments.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <ctype.h>\t\t/* for isprint() */",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"utils.h\"\n#include \"arguments.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <ctype.h>\t\t/* for isprint() */\n#include <string.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nextern int lxc_arguments_parse(struct lxc_arguments *args,\n\t\t\t       int argc, char * const argv[])\n{\n\tchar shortopts[256];\n\tint  ret = 0;\n\n\tret = build_shortopts(args->options, shortopts, sizeof(shortopts));\n\tif (ret < 0) {\n\t\tlxc_error(args, \"build_shortopts() failed : %s\",\n\t\t\t  strerror(errno));\n\t\treturn ret;\n\t}\n\n\twhile (1)  {\n\t\tint c, index = 0;\n\n\t\tc = getopt_long(argc, argv, shortopts, args->options, &index);\n\t\tif (c == -1)\n\t\t\tbreak;\n\t\tswitch (c) {\n\t\tcase 'n': \targs->name = optarg; break;\n\t\tcase 'o':\targs->log_file = optarg; break;\n\t\tcase 'l':\targs->log_priority = optarg; break;\n\t\tcase 'q':\targs->quiet = 1; break;\n\t\tcase OPT_RCFILE: args->rcfile = optarg; break;\n\t\tcase 'P':\n\t\t\tremove_trailing_slashes(optarg);\n\t\t\tret = lxc_arguments_lxcpath_add(args, optarg);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase OPT_USAGE: print_usage(args->options, args);\n\t\tcase OPT_VERSION: print_version();\n\t\tcase '?':\tprint_help(args, 1);\n\t\tcase 'h': \tprint_help(args, 0);\n\t\tdefault:\n\t\t\tif (args->parser) {\n\t\t\t\tret = args->parser(args, c, optarg);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Reclaim the remaining command arguments\n\t */\n\targs->argv = &argv[optind];\n\targs->argc = argc - optind;\n\n\t/* If no lxcpaths were given, use default */\n\tif (!args->lxcpath_cnt) {\n\t\tret = lxc_arguments_lxcpath_add(args, lxc_global_config_value(\"lxc.lxcpath\"));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t/* Check the command options */\n\n\tif (!args->name && strcmp(args->progname, \"lxc-autostart\") != 0) {\n\t\tlxc_error(args, \"missing container name, use --name option\");\n\t\treturn -1;\n\t}\n\n\tif (args->checker)\n\t\tret = args->checker(args);\nerror:\n\tif (ret)\n\t\tlxc_error(args, \"could not parse command line\");\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"arguments.h\"\n#include \"monitor.h\"\n#include \"log.h\"\n#include \"lxc.h\"\n#include <poll.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <regex.h>\n#include <unistd.h>\n#include <libgen.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool quit_monitord;\nstatic struct lxc_arguments my_args = {\n\t.progname = \"lxc-monitor\",\n\t.help     = \"\\\n[--name=NAME]\\n\\\n\\n\\\nlxc-monitor monitors the state of the NAME container\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME   NAME of the container\\n\\\n                    NAME may be a regular expression\\n\\\n  -Q, --quit        tell lxc-monitord to quit\\n\",\n\t.name     = \".*\",\n\t.options  = my_longopts,\n\t.parser   = my_parser,\n\t.checker  = NULL,\n\t.lxcpath_additional = -1,\n};\n\nint main(int argc, char *argv[])\n{\n\tchar *regexp;\n\tstruct lxc_msg msg;\n\tregex_t preg;\n\tstruct pollfd *fds;\n\tnfds_t nfds;\n\tint len, rc_main, rc_snp, i;\n\n\trc_main = EXIT_FAILURE;\n\n\tif (lxc_arguments_parse(&my_args, argc, argv))\n\t\texit(rc_main);\n\n\tif (!my_args.log_file)\n\t\tmy_args.log_file = \"none\";\n\n\tif (lxc_log_init(my_args.name, my_args.log_file, my_args.log_priority,\n\t\t\t my_args.progname, my_args.quiet, my_args.lxcpath[0]))\n\t\texit(rc_main);\n\tlxc_log_options_no_override();\n\n\tif (quit_monitord) {\n\t\tint ret = EXIT_SUCCESS;\n\t\tfor (i = 0; i < my_args.lxcpath_cnt; i++) {\n\t\t\tint fd;\n\n\t\t\tfd = lxc_monitor_open(my_args.lxcpath[i]);\n\t\t\tif (fd < 0) {\n\t\t\t\tERROR(\"Unable to open monitor on path: %s\", my_args.lxcpath[i]);\n\t\t\t\tret = EXIT_FAILURE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (write(fd, \"quit\", 4) < 0) {\n\t\t\t\tSYSERROR(\"Unable to close monitor on path: %s\", my_args.lxcpath[i]);\n\t\t\t\tret = EXIT_FAILURE;\n\t\t\t\tclose(fd);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(fd);\n\t\t}\n\t\texit(ret);\n\t}\n\n\tlen = strlen(my_args.name) + 3;\n\tregexp = malloc(len + 3);\n\tif (!regexp) {\n\t\tERROR(\"failed to allocate memory\");\n\t\texit(rc_main);\n\t}\n\trc_snp = snprintf(regexp, len, \"^%s$\", my_args.name);\n\tif (rc_snp < 0 || rc_snp >= len) {\n\t\tERROR(\"Name too long\");\n\t\tgoto error;\n\t}\n\n\tif (regcomp(&preg, regexp, REG_NOSUB|REG_EXTENDED)) {\n\t\tERROR(\"failed to compile the regex '%s'\", my_args.name);\n\t\tgoto error;\n\t}\n\n\tfds = malloc(my_args.lxcpath_cnt * sizeof(struct pollfd));\n\tif (!fds) {\n\t\tSYSERROR(\"out of memory\");\n\t\tgoto cleanup;\n\t}\n\n\tnfds = my_args.lxcpath_cnt;\n\tfor (i = 0; i < nfds; i++) {\n\t\tint fd;\n\n\t\tlxc_monitord_spawn(my_args.lxcpath[i]);\n\n\t\tfd = lxc_monitor_open(my_args.lxcpath[i]);\n\t\tif (fd < 0) {\n\t\t\tclose_fds(fds, i);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfds[i].fd = fd;\n\t\tfds[i].events = POLLIN;\n\t\tfds[i].revents = 0;\n\t}\n\n\tsetlinebuf(stdout);\n\n\tfor (;;) {\n\t\tif (lxc_monitor_read_fdset(fds, nfds, &msg, -1) < 0) {\n\t\t\tgoto close_and_clean;\n\t\t}\n\n\t\tmsg.name[sizeof(msg.name)-1] = '\\0';\n\t\tif (regexec(&preg, msg.name, 0, NULL, 0))\n\t\t\tcontinue;\n\n\t\tswitch (msg.type) {\n\t\tcase lxc_msg_state:\n\t\t\tprintf(\"'%s' changed state to [%s]\\n\",\n\t\t\t       msg.name, lxc_state2str(msg.value));\n\t\t\tbreak;\n\t\tcase lxc_msg_exit_code:\n\t\t\tprintf(\"'%s' exited with status [%d]\\n\",\n\t\t\t       msg.name, WEXITSTATUS(msg.value));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* ignore garbage */\n\t\t\tbreak;\n\t\t}\n\t}\n\trc_main = 0;\n\nclose_and_clean:\n\tclose_fds(fds, nfds);\n\ncleanup:\n\tregfree(&preg);\n\tfree(fds);\n\nerror:\n\tfree(regexp);\n\n\texit(rc_main);\n}"
  },
  {
    "function_name": "close_fds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_monitor.c",
    "lines": "74-84",
    "snippet": "static void close_fds(struct pollfd *fds, nfds_t nfds)\n{\n\tnfds_t i;\n\n\tif (nfds < 1)\n\t\treturn;\n\n\tfor (i = 0; i < nfds; ++i) {\n\t\tclose(fds[i].fd);\n\t}\n}",
    "includes": [
      "#include \"arguments.h\"",
      "#include \"monitor.h\"",
      "#include \"log.h\"",
      "#include \"lxc.h\"",
      "#include <poll.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <regex.h>",
      "#include <unistd.h>",
      "#include <libgen.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fds[i].fd"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"arguments.h\"\n#include \"monitor.h\"\n#include \"log.h\"\n#include \"lxc.h\"\n#include <poll.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <regex.h>\n#include <unistd.h>\n#include <libgen.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic void close_fds(struct pollfd *fds, nfds_t nfds)\n{\n\tnfds_t i;\n\n\tif (nfds < 1)\n\t\treturn;\n\n\tfor (i = 0; i < nfds; ++i) {\n\t\tclose(fds[i].fd);\n\t}\n}"
  },
  {
    "function_name": "my_parser",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_monitor.c",
    "lines": "43-49",
    "snippet": "static int my_parser(struct lxc_arguments* args, int c, char* arg)\n{\n\tswitch (c) {\n\tcase 'Q': quit_monitord = true; break;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"arguments.h\"",
      "#include \"monitor.h\"",
      "#include \"log.h\"",
      "#include \"lxc.h\"",
      "#include <poll.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <regex.h>",
      "#include <unistd.h>",
      "#include <libgen.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool quit_monitord;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"arguments.h\"\n#include \"monitor.h\"\n#include \"log.h\"\n#include \"lxc.h\"\n#include <poll.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <regex.h>\n#include <unistd.h>\n#include <libgen.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool quit_monitord;\n\nstatic int my_parser(struct lxc_arguments* args, int c, char* arg)\n{\n\tswitch (c) {\n\tcase 'Q': quit_monitord = true; break;\n\t}\n\treturn 0;\n}"
  }
]