[
  {
    "function_name": "list_all_containers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "4446-4526",
    "snippet": "int list_all_containers(const char *lxcpath, char ***nret,\n\t\t\tstruct lxc_container ***cret)\n{\n\tint i, ret, active_cnt, ct_cnt, ct_list_cnt;\n\tchar **active_name;\n\tchar **ct_name;\n\tstruct lxc_container **ct_list = NULL;\n\n\tct_cnt = list_defined_containers(lxcpath, &ct_name, NULL);\n\tif (ct_cnt < 0)\n\t\treturn ct_cnt;\n\n\tactive_cnt = list_active_containers(lxcpath, &active_name, NULL);\n\tif (active_cnt < 0) {\n\t\tret = active_cnt;\n\t\tgoto free_ct_name;\n\t}\n\n\tfor (i = 0; i < active_cnt; i++) {\n\t\tif (!array_contains(&ct_name, active_name[i], ct_cnt)) {\n\t\t\tif (!add_to_array(&ct_name, active_name[i], ct_cnt)) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto free_active_name;\n\t\t\t}\n\t\t\tct_cnt++;\n\t\t}\n\t\tfree(active_name[i]);\n\t\tactive_name[i] = NULL;\n\t}\n\tfree(active_name);\n\tactive_name = NULL;\n\tactive_cnt = 0;\n\n\tfor (i = 0, ct_list_cnt = 0; i < ct_cnt && cret; i++) {\n\t\tstruct lxc_container *c;\n\n\t\tc = lxc_container_new(ct_name[i], lxcpath);\n\t\tif (!c) {\n\t\t\tWARN(\"Container %s:%s could not be loaded\", lxcpath, ct_name[i]);\n\t\t\tremove_from_array(&ct_name, ct_name[i], ct_cnt--);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!add_to_clist(&ct_list, c, ct_list_cnt, false)) {\n\t\t\tlxc_container_put(c);\n\t\t\tret = -1;\n\t\t\tgoto free_ct_list;\n\t\t}\n\t\tct_list_cnt++;\n\t}\n\n\tif (cret)\n\t\t*cret = ct_list;\n\n\tif (nret)\n\t\t*nret = ct_name;\n\telse {\n\t\tret = ct_cnt;\n\t\tgoto free_ct_name;\n\t}\n\treturn ct_cnt;\n\nfree_ct_list:\n\tfor (i = 0; i < ct_list_cnt; i++) {\n\t\tlxc_container_put(ct_list[i]);\n\t}\n\tfree(ct_list);\n\nfree_active_name:\n\tfor (i = 0; i < active_cnt; i++) {\n\t\tfree(active_name[i]);\n\t}\n\tfree(active_name);\n\nfree_ct_name:\n\tfor (i = 0; i < ct_cnt; i++) {\n\t\tfree(ct_name[i]);\n\t}\n\tfree(ct_name);\n\treturn ret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ct_name"
          ],
          "line": 4524
        },
        "resolved": true,
        "details": {
          "function_name": "free_init_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "706-715",
          "snippet": "static void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_container_put",
          "args": [
            "ct_list[i]"
          ],
          "line": 4510
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "312-325",
          "snippet": "int lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_to_clist",
          "args": [
            "&ct_list",
            "c",
            "ct_list_cnt",
            "false"
          ],
          "line": 4489
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_clist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "1740-1756",
          "snippet": "static bool add_to_clist(struct lxc_container ***list, struct lxc_container *c, int pos, bool sort)\n{\n\tstruct lxc_container **newlist = realloc(*list, (pos+1) * sizeof(struct lxc_container *));\n\tif (!newlist) {\n\t\tERROR(\"Out of memory\");\n\t\treturn false;\n\t}\n\n\t*list = newlist;\n\tnewlist[pos] = c;\n\n\t// sort the arrray as we will use binary search on it\n\tif (sort)\n\t\tqsort(newlist, pos + 1, sizeof(struct lxc_container *), (int (*)(const void *,const void *))container_cmp);\n\n\treturn true;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool add_to_clist(struct lxc_container ***list, struct lxc_container *c, int pos, bool sort)\n{\n\tstruct lxc_container **newlist = realloc(*list, (pos+1) * sizeof(struct lxc_container *));\n\tif (!newlist) {\n\t\tERROR(\"Out of memory\");\n\t\treturn false;\n\t}\n\n\t*list = newlist;\n\tnewlist[pos] = c;\n\n\t// sort the arrray as we will use binary search on it\n\tif (sort)\n\t\tqsort(newlist, pos + 1, sizeof(struct lxc_container *), (int (*)(const void *,const void *))container_cmp);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_from_array",
          "args": [
            "&ct_name",
            "ct_name[i]",
            "ct_cnt--"
          ],
          "line": 4485
        },
        "resolved": true,
        "details": {
          "function_name": "remove_from_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "1770-1778",
          "snippet": "static bool remove_from_array(char ***names, char *cname, int size)\n{\n\tchar **result = get_from_array(names, cname, size);\n\tif (result != NULL) {\n\t\tfree(result);\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool remove_from_array(char ***names, char *cname, int size)\n{\n\tchar **result = get_from_array(names, cname, size);\n\tif (result != NULL) {\n\t\tfree(result);\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Container %s:%s could not be loaded\"",
            "lxcpath",
            "ct_name[i]"
          ],
          "line": 4484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_container_new",
          "args": [
            "ct_name[i]",
            "lxcpath"
          ],
          "line": 4482
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "4099-4218",
          "snippet": "struct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstruct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_to_array",
          "args": [
            "&ct_name",
            "active_name[i]",
            "ct_cnt"
          ],
          "line": 4466
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "1721-1738",
          "snippet": "static bool add_to_array(char ***names, char *cname, int pos)\n{\n\tchar **newnames = realloc(*names, (pos+1) * sizeof(char *));\n\tif (!newnames) {\n\t\tERROR(\"Out of memory\");\n\t\treturn false;\n\t}\n\n\t*names = newnames;\n\tnewnames[pos] = strdup(cname);\n\tif (!newnames[pos])\n\t\treturn false;\n\n\t// sort the arrray as we will use binary search on it\n\tqsort(newnames, pos + 1, sizeof(char *), (int (*)(const void *,const void *))string_cmp);\n\n\treturn true;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool add_to_array(char ***names, char *cname, int pos)\n{\n\tchar **newnames = realloc(*names, (pos+1) * sizeof(char *));\n\tif (!newnames) {\n\t\tERROR(\"Out of memory\");\n\t\treturn false;\n\t}\n\n\t*names = newnames;\n\tnewnames[pos] = strdup(cname);\n\tif (!newnames[pos])\n\t\treturn false;\n\n\t// sort the arrray as we will use binary search on it\n\tqsort(newnames, pos + 1, sizeof(char *), (int (*)(const void *,const void *))string_cmp);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_contains",
          "args": [
            "&ct_name",
            "active_name[i]",
            "ct_cnt"
          ],
          "line": 4465
        },
        "resolved": true,
        "details": {
          "function_name": "array_contains",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "1764-1768",
          "snippet": "static bool array_contains(char ***names, char *cname, int size) {\n\tif(get_from_array(names, cname, size) != NULL)\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool array_contains(char ***names, char *cname, int size) {\n\tif(get_from_array(names, cname, size) != NULL)\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_active_containers",
          "args": [
            "lxcpath",
            "&active_name",
            "NULL"
          ],
          "line": 4458
        },
        "resolved": true,
        "details": {
          "function_name": "list_active_containers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "4321-4444",
          "snippet": "int list_active_containers(const char *lxcpath, char ***nret,\n\t\t\t   struct lxc_container ***cret)\n{\n\tint i, ret = -1, cret_cnt = 0, ct_name_cnt = 0;\n\tint lxcpath_len;\n\tchar *line = NULL;\n\tchar **ct_name = NULL;\n\tsize_t len = 0;\n\tstruct lxc_container *c = NULL;\n\tbool is_hashed;\n\n\tif (!lxcpath)\n\t\tlxcpath = lxc_global_config_value(\"lxc.lxcpath\");\n\tlxcpath_len = strlen(lxcpath);\n\n\tif (cret)\n\t\t*cret = NULL;\n\tif (nret)\n\t\t*nret = NULL;\n\n\tFILE *f = fopen(\"/proc/net/unix\", \"r\");\n\tif (!f)\n\t\treturn -1;\n\n\twhile (getline(&line, &len, f) != -1) {\n\n\t\tchar *p = strrchr(line, ' '), *p2;\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tp++;\n\t\tif (*p != 0x40)\n\t\t\tcontinue;\n\t\tp++;\n\n\t\tis_hashed = false;\n\t\tif (strncmp(p, lxcpath, lxcpath_len) == 0) {\n\t\t\tp += lxcpath_len;\n\t\t} else if (strncmp(p, \"lxc/\", 4) == 0) {\n\t\t\tp += 4;\n\t\t\tis_hashed = true;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\twhile (*p == '/')\n\t\t\tp++;\n\n\t\t// Now p is the start of lxc_name\n\t\tp2 = strchr(p, '/');\n\t\tif (!p2 || strncmp(p2, \"/command\", 8) != 0)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\n\t\tif (is_hashed) {\n\t\t\tif (strncmp(lxcpath, lxc_cmd_get_lxcpath(p), lxcpath_len) != 0)\n\t\t\t\tcontinue;\n\t\t\tp = lxc_cmd_get_name(p);\n\t\t}\n\n\t\tif (array_contains(&ct_name, p, ct_name_cnt))\n\t\t\tcontinue;\n\n\t\tif (!add_to_array(&ct_name, p, ct_name_cnt))\n\t\t\tgoto free_cret_list;\n\n\t\tct_name_cnt++;\n\n\t\tif (!cret)\n\t\t\tcontinue;\n\n\t\tc = lxc_container_new(p, lxcpath);\n\t\tif (!c) {\n\t\t\tINFO(\"Container %s:%s is running but could not be loaded\",\n\t\t\t\tlxcpath, p);\n\t\t\tremove_from_array(&ct_name, p, ct_name_cnt--);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If this is an anonymous container, then is_defined *can*\n\t\t * return false.  So we don't do that check.  Count on the\n\t\t * fact that the command socket exists.\n\t\t */\n\n\t\tif (!add_to_clist(cret, c, cret_cnt, true)) {\n\t\t\tlxc_container_put(c);\n\t\t\tgoto free_cret_list;\n\t\t}\n\t\tcret_cnt++;\n\t}\n\n\tif (nret && cret && cret_cnt != ct_name_cnt) {\n\t\tif (c)\n\t\t\tlxc_container_put(c);\n\t\tgoto free_cret_list;\n\t}\n\n\tret = ct_name_cnt;\n\tif (nret)\n\t\t*nret = ct_name;\n\telse\n\t\tgoto free_ct_name;\n\tgoto out;\n\nfree_cret_list:\n\tif (cret && *cret) {\n\t\tfor (i = 0; i < cret_cnt; i++)\n\t\t\tlxc_container_put((*cret)[i]);\n\t\tfree(*cret);\n\t}\n\nfree_ct_name:\n\tif (ct_name) {\n\t\tfor (i = 0; i < ct_name_cnt; i++)\n\t\t\tfree(ct_name[i]);\n\t\tfree(ct_name);\n\t}\n\nout:\n\tfree(line);\n\n\tfclose(f);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint list_active_containers(const char *lxcpath, char ***nret,\n\t\t\t   struct lxc_container ***cret)\n{\n\tint i, ret = -1, cret_cnt = 0, ct_name_cnt = 0;\n\tint lxcpath_len;\n\tchar *line = NULL;\n\tchar **ct_name = NULL;\n\tsize_t len = 0;\n\tstruct lxc_container *c = NULL;\n\tbool is_hashed;\n\n\tif (!lxcpath)\n\t\tlxcpath = lxc_global_config_value(\"lxc.lxcpath\");\n\tlxcpath_len = strlen(lxcpath);\n\n\tif (cret)\n\t\t*cret = NULL;\n\tif (nret)\n\t\t*nret = NULL;\n\n\tFILE *f = fopen(\"/proc/net/unix\", \"r\");\n\tif (!f)\n\t\treturn -1;\n\n\twhile (getline(&line, &len, f) != -1) {\n\n\t\tchar *p = strrchr(line, ' '), *p2;\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tp++;\n\t\tif (*p != 0x40)\n\t\t\tcontinue;\n\t\tp++;\n\n\t\tis_hashed = false;\n\t\tif (strncmp(p, lxcpath, lxcpath_len) == 0) {\n\t\t\tp += lxcpath_len;\n\t\t} else if (strncmp(p, \"lxc/\", 4) == 0) {\n\t\t\tp += 4;\n\t\t\tis_hashed = true;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\twhile (*p == '/')\n\t\t\tp++;\n\n\t\t// Now p is the start of lxc_name\n\t\tp2 = strchr(p, '/');\n\t\tif (!p2 || strncmp(p2, \"/command\", 8) != 0)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\n\t\tif (is_hashed) {\n\t\t\tif (strncmp(lxcpath, lxc_cmd_get_lxcpath(p), lxcpath_len) != 0)\n\t\t\t\tcontinue;\n\t\t\tp = lxc_cmd_get_name(p);\n\t\t}\n\n\t\tif (array_contains(&ct_name, p, ct_name_cnt))\n\t\t\tcontinue;\n\n\t\tif (!add_to_array(&ct_name, p, ct_name_cnt))\n\t\t\tgoto free_cret_list;\n\n\t\tct_name_cnt++;\n\n\t\tif (!cret)\n\t\t\tcontinue;\n\n\t\tc = lxc_container_new(p, lxcpath);\n\t\tif (!c) {\n\t\t\tINFO(\"Container %s:%s is running but could not be loaded\",\n\t\t\t\tlxcpath, p);\n\t\t\tremove_from_array(&ct_name, p, ct_name_cnt--);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If this is an anonymous container, then is_defined *can*\n\t\t * return false.  So we don't do that check.  Count on the\n\t\t * fact that the command socket exists.\n\t\t */\n\n\t\tif (!add_to_clist(cret, c, cret_cnt, true)) {\n\t\t\tlxc_container_put(c);\n\t\t\tgoto free_cret_list;\n\t\t}\n\t\tcret_cnt++;\n\t}\n\n\tif (nret && cret && cret_cnt != ct_name_cnt) {\n\t\tif (c)\n\t\t\tlxc_container_put(c);\n\t\tgoto free_cret_list;\n\t}\n\n\tret = ct_name_cnt;\n\tif (nret)\n\t\t*nret = ct_name;\n\telse\n\t\tgoto free_ct_name;\n\tgoto out;\n\nfree_cret_list:\n\tif (cret && *cret) {\n\t\tfor (i = 0; i < cret_cnt; i++)\n\t\t\tlxc_container_put((*cret)[i]);\n\t\tfree(*cret);\n\t}\n\nfree_ct_name:\n\tif (ct_name) {\n\t\tfor (i = 0; i < ct_name_cnt; i++)\n\t\t\tfree(ct_name[i]);\n\t\tfree(ct_name);\n\t}\n\nout:\n\tfree(line);\n\n\tfclose(f);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_defined_containers",
          "args": [
            "lxcpath",
            "&ct_name",
            "NULL"
          ],
          "line": 4454
        },
        "resolved": true,
        "details": {
          "function_name": "list_defined_containers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "4234-4319",
          "snippet": "int list_defined_containers(const char *lxcpath, char ***names, struct lxc_container ***cret)\n{\n\tDIR *dir;\n\tint i, cfound = 0, nfound = 0;\n\tstruct dirent *direntp;\n\tstruct lxc_container *c;\n\n\tif (!lxcpath)\n\t\tlxcpath = lxc_global_config_value(\"lxc.lxcpath\");\n\n\tdir = opendir(lxcpath);\n\tif (!dir) {\n\t\tSYSERROR(\"opendir on lxcpath\");\n\t\treturn -1;\n\t}\n\n\tif (cret)\n\t\t*cret = NULL;\n\tif (names)\n\t\t*names = NULL;\n\n\twhile ((direntp = readdir(dir))) {\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\t// Ignore '.', '..' and any hidden directory\n\t\tif (!strncmp(direntp->d_name, \".\", 1))\n\t\t\tcontinue;\n\n\t\tif (!config_file_exists(lxcpath, direntp->d_name))\n\t\t\tcontinue;\n\n\t\tif (names) {\n\t\t\tif (!add_to_array(names, direntp->d_name, cfound))\n\t\t\t\tgoto free_bad;\n\t\t}\n\t\tcfound++;\n\n\t\tif (!cret) {\n\t\t\tnfound++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tc = lxc_container_new(direntp->d_name, lxcpath);\n\t\tif (!c) {\n\t\t\tINFO(\"Container %s:%s has a config but could not be loaded\",\n\t\t\t\tlxcpath, direntp->d_name);\n\t\t\tif (names)\n\t\t\t\tif(!remove_from_array(names, direntp->d_name, cfound--))\n\t\t\t\t\tgoto free_bad;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!do_lxcapi_is_defined(c)) {\n\t\t\tINFO(\"Container %s:%s has a config but is not defined\",\n\t\t\t\tlxcpath, direntp->d_name);\n\t\t\tif (names)\n\t\t\t\tif(!remove_from_array(names, direntp->d_name, cfound--))\n\t\t\t\t\tgoto free_bad;\n\t\t\tlxc_container_put(c);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!add_to_clist(cret, c, nfound, true)) {\n\t\t\tlxc_container_put(c);\n\t\t\tgoto free_bad;\n\t\t}\n\t\tnfound++;\n\t}\n\n\tclosedir(dir);\n\treturn nfound;\n\nfree_bad:\n\tif (names && *names) {\n\t\tfor (i=0; i<cfound; i++)\n\t\t\tfree((*names)[i]);\n\t\tfree(*names);\n\t}\n\tif (cret && *cret) {\n\t\tfor (i=0; i<nfound; i++)\n\t\t\tlxc_container_put((*cret)[i]);\n\t\tfree(*cret);\n\t}\n\tclosedir(dir);\n\treturn -1;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint list_defined_containers(const char *lxcpath, char ***names, struct lxc_container ***cret)\n{\n\tDIR *dir;\n\tint i, cfound = 0, nfound = 0;\n\tstruct dirent *direntp;\n\tstruct lxc_container *c;\n\n\tif (!lxcpath)\n\t\tlxcpath = lxc_global_config_value(\"lxc.lxcpath\");\n\n\tdir = opendir(lxcpath);\n\tif (!dir) {\n\t\tSYSERROR(\"opendir on lxcpath\");\n\t\treturn -1;\n\t}\n\n\tif (cret)\n\t\t*cret = NULL;\n\tif (names)\n\t\t*names = NULL;\n\n\twhile ((direntp = readdir(dir))) {\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\t// Ignore '.', '..' and any hidden directory\n\t\tif (!strncmp(direntp->d_name, \".\", 1))\n\t\t\tcontinue;\n\n\t\tif (!config_file_exists(lxcpath, direntp->d_name))\n\t\t\tcontinue;\n\n\t\tif (names) {\n\t\t\tif (!add_to_array(names, direntp->d_name, cfound))\n\t\t\t\tgoto free_bad;\n\t\t}\n\t\tcfound++;\n\n\t\tif (!cret) {\n\t\t\tnfound++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tc = lxc_container_new(direntp->d_name, lxcpath);\n\t\tif (!c) {\n\t\t\tINFO(\"Container %s:%s has a config but could not be loaded\",\n\t\t\t\tlxcpath, direntp->d_name);\n\t\t\tif (names)\n\t\t\t\tif(!remove_from_array(names, direntp->d_name, cfound--))\n\t\t\t\t\tgoto free_bad;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!do_lxcapi_is_defined(c)) {\n\t\t\tINFO(\"Container %s:%s has a config but is not defined\",\n\t\t\t\tlxcpath, direntp->d_name);\n\t\t\tif (names)\n\t\t\t\tif(!remove_from_array(names, direntp->d_name, cfound--))\n\t\t\t\t\tgoto free_bad;\n\t\t\tlxc_container_put(c);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!add_to_clist(cret, c, nfound, true)) {\n\t\t\tlxc_container_put(c);\n\t\t\tgoto free_bad;\n\t\t}\n\t\tnfound++;\n\t}\n\n\tclosedir(dir);\n\treturn nfound;\n\nfree_bad:\n\tif (names && *names) {\n\t\tfor (i=0; i<cfound; i++)\n\t\t\tfree((*names)[i]);\n\t\tfree(*names);\n\t}\n\tif (cret && *cret) {\n\t\tfor (i=0; i<nfound; i++)\n\t\t\tlxc_container_put((*cret)[i]);\n\t\tfree(*cret);\n\t}\n\tclosedir(dir);\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint list_all_containers(const char *lxcpath, char ***nret,\n\t\t\tstruct lxc_container ***cret)\n{\n\tint i, ret, active_cnt, ct_cnt, ct_list_cnt;\n\tchar **active_name;\n\tchar **ct_name;\n\tstruct lxc_container **ct_list = NULL;\n\n\tct_cnt = list_defined_containers(lxcpath, &ct_name, NULL);\n\tif (ct_cnt < 0)\n\t\treturn ct_cnt;\n\n\tactive_cnt = list_active_containers(lxcpath, &active_name, NULL);\n\tif (active_cnt < 0) {\n\t\tret = active_cnt;\n\t\tgoto free_ct_name;\n\t}\n\n\tfor (i = 0; i < active_cnt; i++) {\n\t\tif (!array_contains(&ct_name, active_name[i], ct_cnt)) {\n\t\t\tif (!add_to_array(&ct_name, active_name[i], ct_cnt)) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto free_active_name;\n\t\t\t}\n\t\t\tct_cnt++;\n\t\t}\n\t\tfree(active_name[i]);\n\t\tactive_name[i] = NULL;\n\t}\n\tfree(active_name);\n\tactive_name = NULL;\n\tactive_cnt = 0;\n\n\tfor (i = 0, ct_list_cnt = 0; i < ct_cnt && cret; i++) {\n\t\tstruct lxc_container *c;\n\n\t\tc = lxc_container_new(ct_name[i], lxcpath);\n\t\tif (!c) {\n\t\t\tWARN(\"Container %s:%s could not be loaded\", lxcpath, ct_name[i]);\n\t\t\tremove_from_array(&ct_name, ct_name[i], ct_cnt--);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!add_to_clist(&ct_list, c, ct_list_cnt, false)) {\n\t\t\tlxc_container_put(c);\n\t\t\tret = -1;\n\t\t\tgoto free_ct_list;\n\t\t}\n\t\tct_list_cnt++;\n\t}\n\n\tif (cret)\n\t\t*cret = ct_list;\n\n\tif (nret)\n\t\t*nret = ct_name;\n\telse {\n\t\tret = ct_cnt;\n\t\tgoto free_ct_name;\n\t}\n\treturn ct_cnt;\n\nfree_ct_list:\n\tfor (i = 0; i < ct_list_cnt; i++) {\n\t\tlxc_container_put(ct_list[i]);\n\t}\n\tfree(ct_list);\n\nfree_active_name:\n\tfor (i = 0; i < active_cnt; i++) {\n\t\tfree(active_name[i]);\n\t}\n\tfree(active_name);\n\nfree_ct_name:\n\tfor (i = 0; i < ct_cnt; i++) {\n\t\tfree(ct_name[i]);\n\t}\n\tfree(ct_name);\n\treturn ret;\n}"
  },
  {
    "function_name": "list_active_containers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "4321-4444",
    "snippet": "int list_active_containers(const char *lxcpath, char ***nret,\n\t\t\t   struct lxc_container ***cret)\n{\n\tint i, ret = -1, cret_cnt = 0, ct_name_cnt = 0;\n\tint lxcpath_len;\n\tchar *line = NULL;\n\tchar **ct_name = NULL;\n\tsize_t len = 0;\n\tstruct lxc_container *c = NULL;\n\tbool is_hashed;\n\n\tif (!lxcpath)\n\t\tlxcpath = lxc_global_config_value(\"lxc.lxcpath\");\n\tlxcpath_len = strlen(lxcpath);\n\n\tif (cret)\n\t\t*cret = NULL;\n\tif (nret)\n\t\t*nret = NULL;\n\n\tFILE *f = fopen(\"/proc/net/unix\", \"r\");\n\tif (!f)\n\t\treturn -1;\n\n\twhile (getline(&line, &len, f) != -1) {\n\n\t\tchar *p = strrchr(line, ' '), *p2;\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tp++;\n\t\tif (*p != 0x40)\n\t\t\tcontinue;\n\t\tp++;\n\n\t\tis_hashed = false;\n\t\tif (strncmp(p, lxcpath, lxcpath_len) == 0) {\n\t\t\tp += lxcpath_len;\n\t\t} else if (strncmp(p, \"lxc/\", 4) == 0) {\n\t\t\tp += 4;\n\t\t\tis_hashed = true;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\twhile (*p == '/')\n\t\t\tp++;\n\n\t\t// Now p is the start of lxc_name\n\t\tp2 = strchr(p, '/');\n\t\tif (!p2 || strncmp(p2, \"/command\", 8) != 0)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\n\t\tif (is_hashed) {\n\t\t\tif (strncmp(lxcpath, lxc_cmd_get_lxcpath(p), lxcpath_len) != 0)\n\t\t\t\tcontinue;\n\t\t\tp = lxc_cmd_get_name(p);\n\t\t}\n\n\t\tif (array_contains(&ct_name, p, ct_name_cnt))\n\t\t\tcontinue;\n\n\t\tif (!add_to_array(&ct_name, p, ct_name_cnt))\n\t\t\tgoto free_cret_list;\n\n\t\tct_name_cnt++;\n\n\t\tif (!cret)\n\t\t\tcontinue;\n\n\t\tc = lxc_container_new(p, lxcpath);\n\t\tif (!c) {\n\t\t\tINFO(\"Container %s:%s is running but could not be loaded\",\n\t\t\t\tlxcpath, p);\n\t\t\tremove_from_array(&ct_name, p, ct_name_cnt--);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If this is an anonymous container, then is_defined *can*\n\t\t * return false.  So we don't do that check.  Count on the\n\t\t * fact that the command socket exists.\n\t\t */\n\n\t\tif (!add_to_clist(cret, c, cret_cnt, true)) {\n\t\t\tlxc_container_put(c);\n\t\t\tgoto free_cret_list;\n\t\t}\n\t\tcret_cnt++;\n\t}\n\n\tif (nret && cret && cret_cnt != ct_name_cnt) {\n\t\tif (c)\n\t\t\tlxc_container_put(c);\n\t\tgoto free_cret_list;\n\t}\n\n\tret = ct_name_cnt;\n\tif (nret)\n\t\t*nret = ct_name;\n\telse\n\t\tgoto free_ct_name;\n\tgoto out;\n\nfree_cret_list:\n\tif (cret && *cret) {\n\t\tfor (i = 0; i < cret_cnt; i++)\n\t\t\tlxc_container_put((*cret)[i]);\n\t\tfree(*cret);\n\t}\n\nfree_ct_name:\n\tif (ct_name) {\n\t\tfor (i = 0; i < ct_name_cnt; i++)\n\t\t\tfree(ct_name[i]);\n\t\tfree(ct_name);\n\t}\n\nout:\n\tfree(line);\n\n\tfclose(f);\n\treturn ret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 4442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "line"
          ],
          "line": 4440
        },
        "resolved": true,
        "details": {
          "function_name": "free_init_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "706-715",
          "snippet": "static void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_container_put",
          "args": [
            "(*cret)[i]"
          ],
          "line": 4428
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "312-325",
          "snippet": "int lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_to_clist",
          "args": [
            "cret",
            "c",
            "cret_cnt",
            "true"
          ],
          "line": 4405
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_clist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "1740-1756",
          "snippet": "static bool add_to_clist(struct lxc_container ***list, struct lxc_container *c, int pos, bool sort)\n{\n\tstruct lxc_container **newlist = realloc(*list, (pos+1) * sizeof(struct lxc_container *));\n\tif (!newlist) {\n\t\tERROR(\"Out of memory\");\n\t\treturn false;\n\t}\n\n\t*list = newlist;\n\tnewlist[pos] = c;\n\n\t// sort the arrray as we will use binary search on it\n\tif (sort)\n\t\tqsort(newlist, pos + 1, sizeof(struct lxc_container *), (int (*)(const void *,const void *))container_cmp);\n\n\treturn true;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool add_to_clist(struct lxc_container ***list, struct lxc_container *c, int pos, bool sort)\n{\n\tstruct lxc_container **newlist = realloc(*list, (pos+1) * sizeof(struct lxc_container *));\n\tif (!newlist) {\n\t\tERROR(\"Out of memory\");\n\t\treturn false;\n\t}\n\n\t*list = newlist;\n\tnewlist[pos] = c;\n\n\t// sort the arrray as we will use binary search on it\n\tif (sort)\n\t\tqsort(newlist, pos + 1, sizeof(struct lxc_container *), (int (*)(const void *,const void *))container_cmp);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_from_array",
          "args": [
            "&ct_name",
            "p",
            "ct_name_cnt--"
          ],
          "line": 4395
        },
        "resolved": true,
        "details": {
          "function_name": "remove_from_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "1770-1778",
          "snippet": "static bool remove_from_array(char ***names, char *cname, int size)\n{\n\tchar **result = get_from_array(names, cname, size);\n\tif (result != NULL) {\n\t\tfree(result);\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool remove_from_array(char ***names, char *cname, int size)\n{\n\tchar **result = get_from_array(names, cname, size);\n\tif (result != NULL) {\n\t\tfree(result);\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Container %s:%s is running but could not be loaded\"",
            "lxcpath",
            "p"
          ],
          "line": 4393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_container_new",
          "args": [
            "p",
            "lxcpath"
          ],
          "line": 4391
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "4099-4218",
          "snippet": "struct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstruct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_to_array",
          "args": [
            "&ct_name",
            "p",
            "ct_name_cnt"
          ],
          "line": 4383
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "1721-1738",
          "snippet": "static bool add_to_array(char ***names, char *cname, int pos)\n{\n\tchar **newnames = realloc(*names, (pos+1) * sizeof(char *));\n\tif (!newnames) {\n\t\tERROR(\"Out of memory\");\n\t\treturn false;\n\t}\n\n\t*names = newnames;\n\tnewnames[pos] = strdup(cname);\n\tif (!newnames[pos])\n\t\treturn false;\n\n\t// sort the arrray as we will use binary search on it\n\tqsort(newnames, pos + 1, sizeof(char *), (int (*)(const void *,const void *))string_cmp);\n\n\treturn true;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool add_to_array(char ***names, char *cname, int pos)\n{\n\tchar **newnames = realloc(*names, (pos+1) * sizeof(char *));\n\tif (!newnames) {\n\t\tERROR(\"Out of memory\");\n\t\treturn false;\n\t}\n\n\t*names = newnames;\n\tnewnames[pos] = strdup(cname);\n\tif (!newnames[pos])\n\t\treturn false;\n\n\t// sort the arrray as we will use binary search on it\n\tqsort(newnames, pos + 1, sizeof(char *), (int (*)(const void *,const void *))string_cmp);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_contains",
          "args": [
            "&ct_name",
            "p",
            "ct_name_cnt"
          ],
          "line": 4380
        },
        "resolved": true,
        "details": {
          "function_name": "array_contains",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "1764-1768",
          "snippet": "static bool array_contains(char ***names, char *cname, int size) {\n\tif(get_from_array(names, cname, size) != NULL)\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool array_contains(char ***names, char *cname, int size) {\n\tif(get_from_array(names, cname, size) != NULL)\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cmd_get_name",
          "args": [
            "p"
          ],
          "line": 4377
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_get_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "769-784",
          "snippet": "char *lxc_cmd_get_name(const char *hashed_sock_name)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_GET_NAME},\n\t};\n\n\tret = lxc_cmd(NULL, &cmd, &stopped, NULL, hashed_sock_name);\n\tif (ret < 0) {\n\t\treturn NULL;\n\t}\n\n\tif (cmd.rsp.ret == 0)\n\t\treturn cmd.rsp.data;\n\treturn NULL;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nchar *lxc_cmd_get_name(const char *hashed_sock_name)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_GET_NAME},\n\t};\n\n\tret = lxc_cmd(NULL, &cmd, &stopped, NULL, hashed_sock_name);\n\tif (ret < 0) {\n\t\treturn NULL;\n\t}\n\n\tif (cmd.rsp.ret == 0)\n\t\treturn cmd.rsp.data;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "lxcpath",
            "lxc_cmd_get_lxcpath(p)",
            "lxcpath_len"
          ],
          "line": 4375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cmd_get_lxcpath",
          "args": [
            "p"
          ],
          "line": 4375
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_get_lxcpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "807-822",
          "snippet": "char *lxc_cmd_get_lxcpath(const char *hashed_sock_name)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_GET_LXCPATH},\n\t};\n\n\tret = lxc_cmd(NULL, &cmd, &stopped, NULL, hashed_sock_name);\n\tif (ret < 0) {\n\t\treturn NULL;\n\t}\n\n\tif (cmd.rsp.ret == 0)\n\t\treturn cmd.rsp.data;\n\treturn NULL;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nchar *lxc_cmd_get_lxcpath(const char *hashed_sock_name)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_GET_LXCPATH},\n\t};\n\n\tret = lxc_cmd(NULL, &cmd, &stopped, NULL, hashed_sock_name);\n\tif (ret < 0) {\n\t\treturn NULL;\n\t}\n\n\tif (cmd.rsp.ret == 0)\n\t\treturn cmd.rsp.data;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "p2",
            "\"/command\"",
            "8"
          ],
          "line": 4370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "'/'"
          ],
          "line": 4369
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "p",
            "\"lxc/\"",
            "4"
          ],
          "line": 4358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "p",
            "lxcpath",
            "lxcpath_len"
          ],
          "line": 4356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "line",
            "' '"
          ],
          "line": 4347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&line",
            "&len",
            "f"
          ],
          "line": 4345
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getline.c",
          "lines": "39-60",
          "snippet": "ssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "\"/proc/net/unix\"",
            "\"r\""
          ],
          "line": 4341
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "lxcpath"
          ],
          "line": 4334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_global_config_value",
          "args": [
            "\"lxc.lxcpath\""
          ],
          "line": 4333
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_global_config_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "88-247",
          "snippet": "const char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nconst char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint list_active_containers(const char *lxcpath, char ***nret,\n\t\t\t   struct lxc_container ***cret)\n{\n\tint i, ret = -1, cret_cnt = 0, ct_name_cnt = 0;\n\tint lxcpath_len;\n\tchar *line = NULL;\n\tchar **ct_name = NULL;\n\tsize_t len = 0;\n\tstruct lxc_container *c = NULL;\n\tbool is_hashed;\n\n\tif (!lxcpath)\n\t\tlxcpath = lxc_global_config_value(\"lxc.lxcpath\");\n\tlxcpath_len = strlen(lxcpath);\n\n\tif (cret)\n\t\t*cret = NULL;\n\tif (nret)\n\t\t*nret = NULL;\n\n\tFILE *f = fopen(\"/proc/net/unix\", \"r\");\n\tif (!f)\n\t\treturn -1;\n\n\twhile (getline(&line, &len, f) != -1) {\n\n\t\tchar *p = strrchr(line, ' '), *p2;\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tp++;\n\t\tif (*p != 0x40)\n\t\t\tcontinue;\n\t\tp++;\n\n\t\tis_hashed = false;\n\t\tif (strncmp(p, lxcpath, lxcpath_len) == 0) {\n\t\t\tp += lxcpath_len;\n\t\t} else if (strncmp(p, \"lxc/\", 4) == 0) {\n\t\t\tp += 4;\n\t\t\tis_hashed = true;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\twhile (*p == '/')\n\t\t\tp++;\n\n\t\t// Now p is the start of lxc_name\n\t\tp2 = strchr(p, '/');\n\t\tif (!p2 || strncmp(p2, \"/command\", 8) != 0)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\n\t\tif (is_hashed) {\n\t\t\tif (strncmp(lxcpath, lxc_cmd_get_lxcpath(p), lxcpath_len) != 0)\n\t\t\t\tcontinue;\n\t\t\tp = lxc_cmd_get_name(p);\n\t\t}\n\n\t\tif (array_contains(&ct_name, p, ct_name_cnt))\n\t\t\tcontinue;\n\n\t\tif (!add_to_array(&ct_name, p, ct_name_cnt))\n\t\t\tgoto free_cret_list;\n\n\t\tct_name_cnt++;\n\n\t\tif (!cret)\n\t\t\tcontinue;\n\n\t\tc = lxc_container_new(p, lxcpath);\n\t\tif (!c) {\n\t\t\tINFO(\"Container %s:%s is running but could not be loaded\",\n\t\t\t\tlxcpath, p);\n\t\t\tremove_from_array(&ct_name, p, ct_name_cnt--);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If this is an anonymous container, then is_defined *can*\n\t\t * return false.  So we don't do that check.  Count on the\n\t\t * fact that the command socket exists.\n\t\t */\n\n\t\tif (!add_to_clist(cret, c, cret_cnt, true)) {\n\t\t\tlxc_container_put(c);\n\t\t\tgoto free_cret_list;\n\t\t}\n\t\tcret_cnt++;\n\t}\n\n\tif (nret && cret && cret_cnt != ct_name_cnt) {\n\t\tif (c)\n\t\t\tlxc_container_put(c);\n\t\tgoto free_cret_list;\n\t}\n\n\tret = ct_name_cnt;\n\tif (nret)\n\t\t*nret = ct_name;\n\telse\n\t\tgoto free_ct_name;\n\tgoto out;\n\nfree_cret_list:\n\tif (cret && *cret) {\n\t\tfor (i = 0; i < cret_cnt; i++)\n\t\t\tlxc_container_put((*cret)[i]);\n\t\tfree(*cret);\n\t}\n\nfree_ct_name:\n\tif (ct_name) {\n\t\tfor (i = 0; i < ct_name_cnt; i++)\n\t\t\tfree(ct_name[i]);\n\t\tfree(ct_name);\n\t}\n\nout:\n\tfree(line);\n\n\tfclose(f);\n\treturn ret;\n}"
  },
  {
    "function_name": "list_defined_containers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "4234-4319",
    "snippet": "int list_defined_containers(const char *lxcpath, char ***names, struct lxc_container ***cret)\n{\n\tDIR *dir;\n\tint i, cfound = 0, nfound = 0;\n\tstruct dirent *direntp;\n\tstruct lxc_container *c;\n\n\tif (!lxcpath)\n\t\tlxcpath = lxc_global_config_value(\"lxc.lxcpath\");\n\n\tdir = opendir(lxcpath);\n\tif (!dir) {\n\t\tSYSERROR(\"opendir on lxcpath\");\n\t\treturn -1;\n\t}\n\n\tif (cret)\n\t\t*cret = NULL;\n\tif (names)\n\t\t*names = NULL;\n\n\twhile ((direntp = readdir(dir))) {\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\t// Ignore '.', '..' and any hidden directory\n\t\tif (!strncmp(direntp->d_name, \".\", 1))\n\t\t\tcontinue;\n\n\t\tif (!config_file_exists(lxcpath, direntp->d_name))\n\t\t\tcontinue;\n\n\t\tif (names) {\n\t\t\tif (!add_to_array(names, direntp->d_name, cfound))\n\t\t\t\tgoto free_bad;\n\t\t}\n\t\tcfound++;\n\n\t\tif (!cret) {\n\t\t\tnfound++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tc = lxc_container_new(direntp->d_name, lxcpath);\n\t\tif (!c) {\n\t\t\tINFO(\"Container %s:%s has a config but could not be loaded\",\n\t\t\t\tlxcpath, direntp->d_name);\n\t\t\tif (names)\n\t\t\t\tif(!remove_from_array(names, direntp->d_name, cfound--))\n\t\t\t\t\tgoto free_bad;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!do_lxcapi_is_defined(c)) {\n\t\t\tINFO(\"Container %s:%s has a config but is not defined\",\n\t\t\t\tlxcpath, direntp->d_name);\n\t\t\tif (names)\n\t\t\t\tif(!remove_from_array(names, direntp->d_name, cfound--))\n\t\t\t\t\tgoto free_bad;\n\t\t\tlxc_container_put(c);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!add_to_clist(cret, c, nfound, true)) {\n\t\t\tlxc_container_put(c);\n\t\t\tgoto free_bad;\n\t\t}\n\t\tnfound++;\n\t}\n\n\tclosedir(dir);\n\treturn nfound;\n\nfree_bad:\n\tif (names && *names) {\n\t\tfor (i=0; i<cfound; i++)\n\t\t\tfree((*names)[i]);\n\t\tfree(*names);\n\t}\n\tif (cret && *cret) {\n\t\tfor (i=0; i<nfound; i++)\n\t\t\tlxc_container_put((*cret)[i]);\n\t\tfree(*cret);\n\t}\n\tclosedir(dir);\n\treturn -1;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dir"
          ],
          "line": 4317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "*cret"
          ],
          "line": 4315
        },
        "resolved": true,
        "details": {
          "function_name": "free_init_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "706-715",
          "snippet": "static void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_container_put",
          "args": [
            "(*cret)[i]"
          ],
          "line": 4314
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "312-325",
          "snippet": "int lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dir"
          ],
          "line": 4303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_to_clist",
          "args": [
            "cret",
            "c",
            "nfound",
            "true"
          ],
          "line": 4296
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_clist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "1740-1756",
          "snippet": "static bool add_to_clist(struct lxc_container ***list, struct lxc_container *c, int pos, bool sort)\n{\n\tstruct lxc_container **newlist = realloc(*list, (pos+1) * sizeof(struct lxc_container *));\n\tif (!newlist) {\n\t\tERROR(\"Out of memory\");\n\t\treturn false;\n\t}\n\n\t*list = newlist;\n\tnewlist[pos] = c;\n\n\t// sort the arrray as we will use binary search on it\n\tif (sort)\n\t\tqsort(newlist, pos + 1, sizeof(struct lxc_container *), (int (*)(const void *,const void *))container_cmp);\n\n\treturn true;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool add_to_clist(struct lxc_container ***list, struct lxc_container *c, int pos, bool sort)\n{\n\tstruct lxc_container **newlist = realloc(*list, (pos+1) * sizeof(struct lxc_container *));\n\tif (!newlist) {\n\t\tERROR(\"Out of memory\");\n\t\treturn false;\n\t}\n\n\t*list = newlist;\n\tnewlist[pos] = c;\n\n\t// sort the arrray as we will use binary search on it\n\tif (sort)\n\t\tqsort(newlist, pos + 1, sizeof(struct lxc_container *), (int (*)(const void *,const void *))container_cmp);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_from_array",
          "args": [
            "names",
            "direntp->d_name",
            "cfound--"
          ],
          "line": 4290
        },
        "resolved": true,
        "details": {
          "function_name": "remove_from_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "1770-1778",
          "snippet": "static bool remove_from_array(char ***names, char *cname, int size)\n{\n\tchar **result = get_from_array(names, cname, size);\n\tif (result != NULL) {\n\t\tfree(result);\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool remove_from_array(char ***names, char *cname, int size)\n{\n\tchar **result = get_from_array(names, cname, size);\n\tif (result != NULL) {\n\t\tfree(result);\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Container %s:%s has a config but is not defined\"",
            "lxcpath",
            "direntp->d_name"
          ],
          "line": 4287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_lxcapi_is_defined",
          "args": [
            "c"
          ],
          "line": 4286
        },
        "resolved": true,
        "details": {
          "function_name": "do_lxcapi_is_defined",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "327-348",
          "snippet": "static bool do_lxcapi_is_defined(struct lxc_container *c)\n{\n\tstruct stat statbuf;\n\tbool ret = false;\n\tint statret;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (container_mem_lock(c))\n\t\treturn false;\n\tif (!c->configfile)\n\t\tgoto out;\n\tstatret = stat(c->configfile, &statbuf);\n\tif (statret != 0)\n\t\tgoto out;\n\tret = true;\n\nout:\n\tcontainer_mem_unlock(c);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_is_defined(struct lxc_container *c)\n{\n\tstruct stat statbuf;\n\tbool ret = false;\n\tint statret;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (container_mem_lock(c))\n\t\treturn false;\n\tif (!c->configfile)\n\t\tgoto out;\n\tstatret = stat(c->configfile, &statbuf);\n\tif (statret != 0)\n\t\tgoto out;\n\tret = true;\n\nout:\n\tcontainer_mem_unlock(c);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Container %s:%s has a config but could not be loaded\"",
            "lxcpath",
            "direntp->d_name"
          ],
          "line": 4279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_container_new",
          "args": [
            "direntp->d_name",
            "lxcpath"
          ],
          "line": 4277
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "4099-4218",
          "snippet": "struct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstruct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_to_array",
          "args": [
            "names",
            "direntp->d_name",
            "cfound"
          ],
          "line": 4267
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "1721-1738",
          "snippet": "static bool add_to_array(char ***names, char *cname, int pos)\n{\n\tchar **newnames = realloc(*names, (pos+1) * sizeof(char *));\n\tif (!newnames) {\n\t\tERROR(\"Out of memory\");\n\t\treturn false;\n\t}\n\n\t*names = newnames;\n\tnewnames[pos] = strdup(cname);\n\tif (!newnames[pos])\n\t\treturn false;\n\n\t// sort the arrray as we will use binary search on it\n\tqsort(newnames, pos + 1, sizeof(char *), (int (*)(const void *,const void *))string_cmp);\n\n\treturn true;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool add_to_array(char ***names, char *cname, int pos)\n{\n\tchar **newnames = realloc(*names, (pos+1) * sizeof(char *));\n\tif (!newnames) {\n\t\tERROR(\"Out of memory\");\n\t\treturn false;\n\t}\n\n\t*names = newnames;\n\tnewnames[pos] = strdup(cname);\n\tif (!newnames[pos])\n\t\treturn false;\n\n\t// sort the arrray as we will use binary search on it\n\tqsort(newnames, pos + 1, sizeof(char *), (int (*)(const void *,const void *))string_cmp);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "config_file_exists",
          "args": [
            "lxcpath",
            "direntp->d_name"
          ],
          "line": 4263
        },
        "resolved": true,
        "details": {
          "function_name": "config_file_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "111-122",
          "snippet": "static bool config_file_exists(const char *lxcpath, const char *cname)\n{\n\t/* $lxcpath + '/' + $cname + '/config' + \\0 */\n\tint ret, len = strlen(lxcpath) + strlen(cname) + 9;\n\tchar *fname = alloca(len);\n\n\tret = snprintf(fname, len,  \"%s/%s/config\", lxcpath, cname);\n\tif (ret < 0 || ret >= len)\n\t\treturn false;\n\n\treturn file_exists(fname);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool config_file_exists(const char *lxcpath, const char *cname)\n{\n\t/* $lxcpath + '/' + $cname + '/config' + \\0 */\n\tint ret, len = strlen(lxcpath) + strlen(cname) + 9;\n\tchar *fname = alloca(len);\n\n\tret = snprintf(fname, len,  \"%s/%s/config\", lxcpath, cname);\n\tif (ret < 0 || ret >= len)\n\t\treturn false;\n\n\treturn file_exists(fname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "direntp->d_name",
            "\".\"",
            "1"
          ],
          "line": 4260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "dir"
          ],
          "line": 4255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"opendir on lxcpath\""
          ],
          "line": 4246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "lxcpath"
          ],
          "line": 4244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_global_config_value",
          "args": [
            "\"lxc.lxcpath\""
          ],
          "line": 4242
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_global_config_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "88-247",
          "snippet": "const char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nconst char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint list_defined_containers(const char *lxcpath, char ***names, struct lxc_container ***cret)\n{\n\tDIR *dir;\n\tint i, cfound = 0, nfound = 0;\n\tstruct dirent *direntp;\n\tstruct lxc_container *c;\n\n\tif (!lxcpath)\n\t\tlxcpath = lxc_global_config_value(\"lxc.lxcpath\");\n\n\tdir = opendir(lxcpath);\n\tif (!dir) {\n\t\tSYSERROR(\"opendir on lxcpath\");\n\t\treturn -1;\n\t}\n\n\tif (cret)\n\t\t*cret = NULL;\n\tif (names)\n\t\t*names = NULL;\n\n\twhile ((direntp = readdir(dir))) {\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\t// Ignore '.', '..' and any hidden directory\n\t\tif (!strncmp(direntp->d_name, \".\", 1))\n\t\t\tcontinue;\n\n\t\tif (!config_file_exists(lxcpath, direntp->d_name))\n\t\t\tcontinue;\n\n\t\tif (names) {\n\t\t\tif (!add_to_array(names, direntp->d_name, cfound))\n\t\t\t\tgoto free_bad;\n\t\t}\n\t\tcfound++;\n\n\t\tif (!cret) {\n\t\t\tnfound++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tc = lxc_container_new(direntp->d_name, lxcpath);\n\t\tif (!c) {\n\t\t\tINFO(\"Container %s:%s has a config but could not be loaded\",\n\t\t\t\tlxcpath, direntp->d_name);\n\t\t\tif (names)\n\t\t\t\tif(!remove_from_array(names, direntp->d_name, cfound--))\n\t\t\t\t\tgoto free_bad;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!do_lxcapi_is_defined(c)) {\n\t\t\tINFO(\"Container %s:%s has a config but is not defined\",\n\t\t\t\tlxcpath, direntp->d_name);\n\t\t\tif (names)\n\t\t\t\tif(!remove_from_array(names, direntp->d_name, cfound--))\n\t\t\t\t\tgoto free_bad;\n\t\t\tlxc_container_put(c);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!add_to_clist(cret, c, nfound, true)) {\n\t\t\tlxc_container_put(c);\n\t\t\tgoto free_bad;\n\t\t}\n\t\tnfound++;\n\t}\n\n\tclosedir(dir);\n\treturn nfound;\n\nfree_bad:\n\tif (names && *names) {\n\t\tfor (i=0; i<cfound; i++)\n\t\t\tfree((*names)[i]);\n\t\tfree(*names);\n\t}\n\tif (cret && *cret) {\n\t\tfor (i=0; i<nfound; i++)\n\t\t\tlxc_container_put((*cret)[i]);\n\t\tfree(*cret);\n\t}\n\tclosedir(dir);\n\treturn -1;\n}"
  },
  {
    "function_name": "lxc_get_wait_states",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "4220-4228",
    "snippet": "int lxc_get_wait_states(const char **states)\n{\n\tint i;\n\n\tif (states)\n\t\tfor (i=0; i<MAX_STATE; i++)\n\t\t\tstates[i] = lxc_state2str(i);\n\treturn MAX_STATE;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_state2str",
          "args": [
            "i"
          ],
          "line": 4226
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_state2str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/state.c",
          "lines": "52-57",
          "snippet": "const char *lxc_state2str(lxc_state_t state)\n{\n\tif (state < STOPPED || state > MAX_STATE - 1)\n\t\treturn NULL;\n\treturn strstate[state];\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"monitor.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const strstate[] = {\n\t\"STOPPED\", \"STARTING\", \"RUNNING\", \"STOPPING\",\n\t\"ABORTING\", \"FREEZING\", \"FROZEN\", \"THAWED\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"monitor.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic const char * const strstate[] = {\n\t\"STOPPED\", \"STARTING\", \"RUNNING\", \"STOPPING\",\n\t\"ABORTING\", \"FREEZING\", \"FROZEN\", \"THAWED\",\n};\n\nconst char *lxc_state2str(lxc_state_t state)\n{\n\tif (state < STOPPED || state > MAX_STATE - 1)\n\t\treturn NULL;\n\treturn strstate[state];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nint lxc_get_wait_states(const char **states)\n{\n\tint i;\n\n\tif (states)\n\t\tfor (i=0; i<MAX_STATE; i++)\n\t\t\tstates[i] = lxc_state2str(i);\n\treturn MAX_STATE;\n}"
  },
  {
    "function_name": "lxc_container_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "4099-4218",
    "snippet": "struct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_container_free",
          "args": [
            "c"
          ],
          "line": 4216
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "238-265",
          "snippet": "static void lxc_container_free(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn;\n\n\tfree(c->configfile);\n\tc->configfile = NULL;\n\tfree(c->error_string);\n\tc->error_string = NULL;\n\tif (c->slock) {\n\t\tlxc_putlock(c->slock);\n\t\tc->slock = NULL;\n\t}\n\tif (c->privlock) {\n\t\tlxc_putlock(c->privlock);\n\t\tc->privlock = NULL;\n\t}\n\tfree(c->name);\n\tc->name = NULL;\n\tif (c->lxc_conf) {\n\t\tlxc_conf_free(c->lxc_conf);\n\t\tc->lxc_conf = NULL;\n\t}\n\tfree(c->config_path);\n\tc->config_path = NULL;\n\n\tfree(c);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic void lxc_container_free(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn;\n\n\tfree(c->configfile);\n\tc->configfile = NULL;\n\tfree(c->error_string);\n\tc->error_string = NULL;\n\tif (c->slock) {\n\t\tlxc_putlock(c->slock);\n\t\tc->slock = NULL;\n\t}\n\tif (c->privlock) {\n\t\tlxc_putlock(c->privlock);\n\t\tc->privlock = NULL;\n\t}\n\tfree(c->name);\n\tc->name = NULL;\n\tif (c->lxc_conf) {\n\t\tlxc_conf_free(c->lxc_conf);\n\t\tc->lxc_conf = NULL;\n\t}\n\tfree(c->config_path);\n\tc->config_path = NULL;\n\n\tfree(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxcapi_clear_config",
          "args": [
            "c"
          ],
          "line": 4153
        },
        "resolved": true,
        "details": {
          "function_name": "lxcapi_clear_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "1401-1409",
          "snippet": "static void lxcapi_clear_config(struct lxc_container *c)\n{\n\tif (c) {\n\t\tif (c->lxc_conf) {\n\t\t\tlxc_conf_free(c->lxc_conf);\n\t\t\tc->lxc_conf = NULL;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic void lxcapi_clear_config(struct lxc_container *c)\n{\n\tif (c) {\n\t\tif (c->lxc_conf) {\n\t\t\tlxc_conf_free(c->lxc_conf);\n\t\t\tc->lxc_conf = NULL;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_destroy",
          "args": [
            "c"
          ],
          "line": 4152
        },
        "resolved": true,
        "details": {
          "function_name": "container_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2338-2421",
          "snippet": "static bool container_destroy(struct lxc_container *c)\n{\n\tbool bret = false;\n\tint ret = 0;\n\tstruct lxc_conf *conf;\n\n\tif (!c || !do_lxcapi_is_defined(c))\n\t\treturn false;\n\n\tconf = c->lxc_conf;\n\tif (container_disk_lock(c))\n\t\treturn false;\n\n\tif (!is_stopped(c)) {\n\t\t// we should queue some sort of error - in c->error_string?\n\t\tERROR(\"container %s is not stopped\", c->name);\n\t\tgoto out;\n\t}\n\n\tif (conf && !lxc_list_empty(&conf->hooks[LXCHOOK_DESTROY])) {\n\t\t/* Start of environment variable setup for hooks */\n\t\tif (c->name && setenv(\"LXC_NAME\", c->name, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for container name\");\n\t\t}\n\t\tif (conf->rcfile && setenv(\"LXC_CONFIG_FILE\", conf->rcfile, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for config path\");\n\t\t}\n\t\tif (conf->rootfs.mount && setenv(\"LXC_ROOTFS_MOUNT\", conf->rootfs.mount, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for rootfs mount\");\n\t\t}\n\t\tif (conf->rootfs.path && setenv(\"LXC_ROOTFS_PATH\", conf->rootfs.path, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for rootfs mount\");\n\t\t}\n\t\tif (conf->console.path && setenv(\"LXC_CONSOLE\", conf->console.path, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for console path\");\n\t\t}\n\t\tif (conf->console.log_path && setenv(\"LXC_CONSOLE_LOGPATH\", conf->console.log_path, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for console log\");\n\t\t}\n\t\t/* End of environment variable setup for hooks */\n\n\t\tif (run_lxc_hooks(c->name, \"destroy\", conf, c->get_config_path(c), NULL)) {\n\t\t\tERROR(\"Error executing clone hook for %s\", c->name);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (current_config && conf == current_config) {\n\t\tcurrent_config = NULL;\n\t\tif (conf->logfd != -1) {\n\t\t\tclose(conf->logfd);\n\t\t\tconf->logfd = -1;\n\t\t}\n\t}\n\n\tif (conf && conf->rootfs.path && conf->rootfs.mount) {\n\t\tif (!do_destroy_container(conf)) {\n\t\t\tERROR(\"Error destroying rootfs for %s\", c->name);\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Destroyed rootfs for %s\", c->name);\n\t}\n\n\tmod_all_rdeps(c, false);\n\n\tconst char *p1 = do_lxcapi_get_config_path(c);\n\tchar *path = alloca(strlen(p1) + strlen(c->name) + 2);\n\tsprintf(path, \"%s/%s\", p1, c->name);\n\tif (am_unpriv())\n\t\tret = userns_exec_1(conf, lxc_rmdir_onedev_wrapper, path);\n\telse\n\t\tret = lxc_rmdir_onedev(path, \"snaps\");\n\tif (ret < 0) {\n\t\tERROR(\"Error destroying container directory for %s\", c->name);\n\t\tgoto out;\n\t}\n\tINFO(\"Destroyed directory for %s\", c->name);\n\n\tbret = true;\n\nout:\n\tcontainer_disk_unlock(c);\n\treturn bret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool container_destroy(struct lxc_container *c)\n{\n\tbool bret = false;\n\tint ret = 0;\n\tstruct lxc_conf *conf;\n\n\tif (!c || !do_lxcapi_is_defined(c))\n\t\treturn false;\n\n\tconf = c->lxc_conf;\n\tif (container_disk_lock(c))\n\t\treturn false;\n\n\tif (!is_stopped(c)) {\n\t\t// we should queue some sort of error - in c->error_string?\n\t\tERROR(\"container %s is not stopped\", c->name);\n\t\tgoto out;\n\t}\n\n\tif (conf && !lxc_list_empty(&conf->hooks[LXCHOOK_DESTROY])) {\n\t\t/* Start of environment variable setup for hooks */\n\t\tif (c->name && setenv(\"LXC_NAME\", c->name, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for container name\");\n\t\t}\n\t\tif (conf->rcfile && setenv(\"LXC_CONFIG_FILE\", conf->rcfile, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for config path\");\n\t\t}\n\t\tif (conf->rootfs.mount && setenv(\"LXC_ROOTFS_MOUNT\", conf->rootfs.mount, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for rootfs mount\");\n\t\t}\n\t\tif (conf->rootfs.path && setenv(\"LXC_ROOTFS_PATH\", conf->rootfs.path, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for rootfs mount\");\n\t\t}\n\t\tif (conf->console.path && setenv(\"LXC_CONSOLE\", conf->console.path, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for console path\");\n\t\t}\n\t\tif (conf->console.log_path && setenv(\"LXC_CONSOLE_LOGPATH\", conf->console.log_path, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for console log\");\n\t\t}\n\t\t/* End of environment variable setup for hooks */\n\n\t\tif (run_lxc_hooks(c->name, \"destroy\", conf, c->get_config_path(c), NULL)) {\n\t\t\tERROR(\"Error executing clone hook for %s\", c->name);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (current_config && conf == current_config) {\n\t\tcurrent_config = NULL;\n\t\tif (conf->logfd != -1) {\n\t\t\tclose(conf->logfd);\n\t\t\tconf->logfd = -1;\n\t\t}\n\t}\n\n\tif (conf && conf->rootfs.path && conf->rootfs.mount) {\n\t\tif (!do_destroy_container(conf)) {\n\t\t\tERROR(\"Error destroying rootfs for %s\", c->name);\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Destroyed rootfs for %s\", c->name);\n\t}\n\n\tmod_all_rdeps(c, false);\n\n\tconst char *p1 = do_lxcapi_get_config_path(c);\n\tchar *path = alloca(strlen(p1) + strlen(c->name) + 2);\n\tsprintf(path, \"%s/%s\", p1, c->name);\n\tif (am_unpriv())\n\t\tret = userns_exec_1(conf, lxc_rmdir_onedev_wrapper, path);\n\telse\n\t\tret = lxc_rmdir_onedev(path, \"snaps\");\n\tif (ret < 0) {\n\t\tERROR(\"Error destroying container directory for %s\", c->name);\n\t\tgoto out;\n\t}\n\tINFO(\"Destroyed directory for %s\", c->name);\n\n\tbret = true;\n\nout:\n\tcontainer_disk_unlock(c);\n\treturn bret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error: %s creation was not completed\"",
            "c->name"
          ],
          "line": 4151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ongoing_create",
          "args": [
            "c"
          ],
          "line": 4150
        },
        "resolved": true,
        "details": {
          "function_name": "ongoing_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "133-167",
          "snippet": "static int ongoing_create(struct lxc_container *c)\n{\n\tint len = strlen(c->config_path) + strlen(c->name) + 10;\n\tchar *path = alloca(len);\n\tint fd, ret;\n\tstruct flock lk;\n\n\tret = snprintf(path, len, \"%s/%s/partial\", c->config_path, c->name);\n\tif (ret < 0 || ret >= len) {\n\t\tERROR(\"Error writing partial pathname\");\n\t\treturn -1;\n\t}\n\n\tif (!file_exists(path))\n\t\treturn 0;\n\tfd = open(path, O_RDWR);\n\tif (fd < 0) {\n\t\t// give benefit of the doubt\n\t\tSYSERROR(\"Error opening partial file\");\n\t\treturn 0;\n\t}\n\tlk.l_type = F_WRLCK;\n\tlk.l_whence = SEEK_SET;\n\tlk.l_start = 0;\n\tlk.l_len = 0;\n\tlk.l_pid = -1;\n\tif (fcntl(fd, F_GETLK, &lk) == 0 && lk.l_pid != -1) {\n\t\t// create is still ongoing\n\t\tclose(fd);\n\t\treturn 1;\n\t}\n\t// create completed but partial is still there.\n\tclose(fd);\n\treturn 2;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic int ongoing_create(struct lxc_container *c)\n{\n\tint len = strlen(c->config_path) + strlen(c->name) + 10;\n\tchar *path = alloca(len);\n\tint fd, ret;\n\tstruct flock lk;\n\n\tret = snprintf(path, len, \"%s/%s/partial\", c->config_path, c->name);\n\tif (ret < 0 || ret >= len) {\n\t\tERROR(\"Error writing partial pathname\");\n\t\treturn -1;\n\t}\n\n\tif (!file_exists(path))\n\t\treturn 0;\n\tfd = open(path, O_RDWR);\n\tif (fd < 0) {\n\t\t// give benefit of the doubt\n\t\tSYSERROR(\"Error opening partial file\");\n\t\treturn 0;\n\t}\n\tlk.l_type = F_WRLCK;\n\tlk.l_whence = SEEK_SET;\n\tlk.l_start = 0;\n\tlk.l_len = 0;\n\tlk.l_pid = -1;\n\tif (fcntl(fd, F_GETLK, &lk) == 0 && lk.l_pid != -1) {\n\t\t// create is still ongoing\n\t\tclose(fd);\n\t\treturn 1;\n\t}\n\t// create completed but partial is still there.\n\tclose(fd);\n\treturn 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxcapi_load_config",
          "args": [
            "c",
            "NULL"
          ],
          "line": 4147
        },
        "resolved": true,
        "details": {
          "function_name": "do_lxcapi_load_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "532-567",
          "snippet": "static bool do_lxcapi_load_config(struct lxc_container *c, const char *alt_file)\n{\n\tbool ret = false, need_disklock = false;\n\tint lret;\n\tconst char *fname;\n\tif (!c)\n\t\treturn false;\n\n\tfname = c->configfile;\n\tif (alt_file)\n\t\tfname = alt_file;\n\tif (!fname)\n\t\treturn false;\n\t/*\n\t * If we're reading something other than the container's config,\n\t * we only need to lock the in-memory container.  If loading the\n\t * container's config file, take the disk lock.\n\t */\n\tif (strcmp(fname, c->configfile) == 0)\n\t\tneed_disklock = true;\n\n\tif (need_disklock)\n\t\tlret = container_disk_lock(c);\n\telse\n\t\tlret = container_mem_lock(c);\n\tif (lret)\n\t\treturn false;\n\n\tret = load_config_locked(c, fname);\n\n\tif (need_disklock)\n\t\tcontainer_disk_unlock(c);\n\telse\n\t\tcontainer_mem_unlock(c);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);",
            "static bool do_lxcapi_save_config(struct lxc_container *c, const char *alt_file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\nstatic bool do_lxcapi_save_config(struct lxc_container *c, const char *alt_file);\n\nstatic bool do_lxcapi_load_config(struct lxc_container *c, const char *alt_file)\n{\n\tbool ret = false, need_disklock = false;\n\tint lret;\n\tconst char *fname;\n\tif (!c)\n\t\treturn false;\n\n\tfname = c->configfile;\n\tif (alt_file)\n\t\tfname = alt_file;\n\tif (!fname)\n\t\treturn false;\n\t/*\n\t * If we're reading something other than the container's config,\n\t * we only need to lock the in-memory container.  If loading the\n\t * container's config file, take the disk lock.\n\t */\n\tif (strcmp(fname, c->configfile) == 0)\n\t\tneed_disklock = true;\n\n\tif (need_disklock)\n\t\tlret = container_disk_lock(c);\n\telse\n\t\tlret = container_mem_lock(c);\n\tif (lret)\n\t\treturn false;\n\n\tret = load_config_locked(c, fname);\n\n\tif (need_disklock)\n\t\tcontainer_disk_unlock(c);\n\telse\n\t\tcontainer_mem_unlock(c);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_exists",
          "args": [
            "c->configfile"
          ],
          "line": 4147
        },
        "resolved": true,
        "details": {
          "function_name": "file_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1240-1245",
          "snippet": "bool file_exists(const char *f)\n{\n\tstruct stat statbuf;\n\n\treturn stat(f, &statbuf) == 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool file_exists(const char *f)\n{\n\tstruct stat statbuf;\n\n\treturn stat(f, &statbuf) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error allocating config file pathname\\n\""
          ],
          "line": 4143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_config_filename",
          "args": [
            "c"
          ],
          "line": 4142
        },
        "resolved": true,
        "details": {
          "function_name": "set_config_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2509-2534",
          "snippet": "static bool set_config_filename(struct lxc_container *c)\n{\n\tchar *newpath;\n\tint len, ret;\n\n\tif (!c->config_path)\n\t\treturn false;\n\n\t/* $lxc_path + \"/\" + c->name + \"/\" + \"config\" + '\\0' */\n\tlen = strlen(c->config_path) + strlen(c->name) + strlen(\"config\") + 3;\n\tnewpath = malloc(len);\n\tif (!newpath)\n\t\treturn false;\n\n\tret = snprintf(newpath, len, \"%s/%s/config\", c->config_path, c->name);\n\tif (ret < 0 || ret >= len) {\n\t\tfprintf(stderr, \"Error printing out config file name\\n\");\n\t\tfree(newpath);\n\t\treturn false;\n\t}\n\n\tfree(c->configfile);\n\tc->configfile = newpath;\n\n\treturn true;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool set_config_filename(struct lxc_container *c)\n{\n\tchar *newpath;\n\tint len, ret;\n\n\tif (!c->config_path)\n\t\treturn false;\n\n\t/* $lxc_path + \"/\" + c->name + \"/\" + \"config\" + '\\0' */\n\tlen = strlen(c->config_path) + strlen(c->name) + strlen(\"config\") + 3;\n\tnewpath = malloc(len);\n\tif (!newpath)\n\t\treturn false;\n\n\tret = snprintf(newpath, len, \"%s/%s/config\", c->config_path, c->name);\n\tif (ret < 0 || ret >= len) {\n\t\tfprintf(stderr, \"Error printing out config file name\\n\");\n\t\tfree(newpath);\n\t\treturn false;\n\t}\n\n\tfree(c->configfile);\n\tc->configfile = newpath;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"failed to alloc privlock\\n\""
          ],
          "line": 4138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_newlock",
          "args": [
            "NULL",
            "NULL"
          ],
          "line": 4137
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_newlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "161-190",
          "snippet": "struct lxc_lock *lxc_newlock(const char *lxcpath, const char *name)\n{\n\tstruct lxc_lock *l;\n\n\tl = malloc(sizeof(*l));\n\tif (!l)\n\t\tgoto out;\n\n\tif (!name) {\n\t\tl->type = LXC_LOCK_ANON_SEM;\n\t\tl->u.sem = lxc_new_unnamed_sem();\n\t\tif (!l->u.sem) {\n\t\t\tfree(l);\n\t\t\tl = NULL;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tl->type = LXC_LOCK_FLOCK;\n\tl->u.f.fname = lxclock_name(lxcpath, name);\n\tif (!l->u.f.fname) {\n\t\tfree(l);\n\t\tl = NULL;\n\t\tgoto out;\n\t}\n\tl->u.f.fd = -1;\n\nout:\n\treturn l;\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nstruct lxc_lock *lxc_newlock(const char *lxcpath, const char *name)\n{\n\tstruct lxc_lock *l;\n\n\tl = malloc(sizeof(*l));\n\tif (!l)\n\t\tgoto out;\n\n\tif (!name) {\n\t\tl->type = LXC_LOCK_ANON_SEM;\n\t\tl->u.sem = lxc_new_unnamed_sem();\n\t\tif (!l->u.sem) {\n\t\t\tfree(l);\n\t\t\tl = NULL;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tl->type = LXC_LOCK_FLOCK;\n\tl->u.f.fname = lxclock_name(lxcpath, name);\n\tif (!l->u.f.fname) {\n\t\tfree(l);\n\t\tl = NULL;\n\t\tgoto out;\n\t}\n\tl->u.f.fd = -1;\n\nout:\n\treturn l;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"failed to create lock\\n\""
          ],
          "line": 4133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "c->name",
            "name"
          ],
          "line": 4129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error allocating lxc_container name\\n\""
          ],
          "line": 4126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(name)+1"
          ],
          "line": 4124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 4124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_trailing_slashes",
          "args": [
            "c->config_path"
          ],
          "line": 4123
        },
        "resolved": true,
        "details": {
          "function_name": "remove_trailing_slashes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "249-254",
          "snippet": "extern void remove_trailing_slashes(char *p)\n{\n\tint l = strlen(p);\n\twhile (--l >= 0 && (p[l] == '/' || p[l] == '\\n'))\n\t\tp[l] = '\\0';\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nextern void remove_trailing_slashes(char *p)\n{\n\tint l = strlen(p);\n\twhile (--l >= 0 && (p[l] == '/' || p[l] == '\\n'))\n\t\tp[l] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Out of memory\\n\""
          ],
          "line": 4119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "lxc_global_config_value(\"lxc.lxcpath\")"
          ],
          "line": 4116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_global_config_value",
          "args": [
            "\"lxc.lxcpath\""
          ],
          "line": 4116
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_global_config_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "88-247",
          "snippet": "const char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nconst char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "configpath"
          ],
          "line": 4114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "c",
            "0",
            "sizeof(*c)"
          ],
          "line": 4111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"failed to malloc lxc_container\\n\""
          ],
          "line": 4108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*c)"
          ],
          "line": 4106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstruct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}"
  },
  {
    "function_name": "lxcapi_attach_run_waitl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "4070-4097",
    "snippet": "static int lxcapi_attach_run_waitl(struct lxc_container *c, lxc_attach_options_t *options, const char *program, const char *arg, ...)\n{\n\tva_list ap;\n\tconst char **argv;\n\tint ret;\n\n\tif (!c)\n\t\treturn -1;\n\n\tcurrent_config = c->lxc_conf;\n\n\tva_start(ap, arg);\n\targv = lxc_va_arg_list_to_argv_const(ap, 1);\n\tva_end(ap);\n\n\tif (!argv) {\n\t\tERROR(\"Memory allocation error.\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\targv[0] = arg;\n\n\tret = do_lxcapi_attach_run_wait(c, options, program, (const char * const *)argv);\n\tfree((void*)argv);\nout:\n\tcurrent_config = NULL;\n\treturn ret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "(void*)argv"
          ],
          "line": 4093
        },
        "resolved": true,
        "details": {
          "function_name": "free_init_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "706-715",
          "snippet": "static void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_lxcapi_attach_run_wait",
          "args": [
            "c",
            "options",
            "program",
            "(const char * const *)argv"
          ],
          "line": 4092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Memory allocation error.\""
          ],
          "line": 4086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ap"
          ],
          "line": 4083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_va_arg_list_to_argv_const",
          "args": [
            "ap",
            "1"
          ],
          "line": 4082
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_va_arg_list_to_argv_const",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "464-467",
          "snippet": "const char** lxc_va_arg_list_to_argv_const(va_list ap, size_t skip)\n{\n\treturn (const char**)lxc_va_arg_list_to_argv(ap, skip, 0);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nconst char** lxc_va_arg_list_to_argv_const(va_list ap, size_t skip)\n{\n\treturn (const char**)lxc_va_arg_list_to_argv(ap, skip, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "ap",
            "arg"
          ],
          "line": 4081
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic int lxcapi_attach_run_waitl(struct lxc_container *c, lxc_attach_options_t *options, const char *program, const char *arg, ...)\n{\n\tva_list ap;\n\tconst char **argv;\n\tint ret;\n\n\tif (!c)\n\t\treturn -1;\n\n\tcurrent_config = c->lxc_conf;\n\n\tva_start(ap, arg);\n\targv = lxc_va_arg_list_to_argv_const(ap, 1);\n\tva_end(ap);\n\n\tif (!argv) {\n\t\tERROR(\"Memory allocation error.\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\targv[0] = arg;\n\n\tret = do_lxcapi_attach_run_wait(c, options, program, (const char * const *)argv);\n\tfree((void*)argv);\nout:\n\tcurrent_config = NULL;\n\treturn ret;\n}"
  },
  {
    "function_name": "do_lxcapi_restore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "4056-4066",
    "snippet": "static bool do_lxcapi_restore(struct lxc_container *c, char *directory, bool verbose)\n{\n\tstruct migrate_opts opts;\n\n\tmemset(&opts, 0, sizeof(opts));\n\n\topts.directory = directory;\n\topts.verbose = verbose;\n\n\treturn !do_lxcapi_migrate(c, MIGRATE_RESTORE, &opts, sizeof(opts));\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_lxcapi_migrate",
          "args": [
            "c",
            "MIGRATE_RESTORE",
            "&opts",
            "sizeof(opts)"
          ],
          "line": 4065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&opts",
            "0",
            "sizeof(opts)"
          ],
          "line": 4060
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_restore(struct lxc_container *c, char *directory, bool verbose)\n{\n\tstruct migrate_opts opts;\n\n\tmemset(&opts, 0, sizeof(opts));\n\n\topts.directory = directory;\n\topts.verbose = verbose;\n\n\treturn !do_lxcapi_migrate(c, MIGRATE_RESTORE, &opts, sizeof(opts));\n}"
  },
  {
    "function_name": "do_lxcapi_checkpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "4041-4052",
    "snippet": "static bool do_lxcapi_checkpoint(struct lxc_container *c, char *directory, bool stop, bool verbose)\n{\n\tstruct migrate_opts opts;\n\n\tmemset(&opts, 0, sizeof(opts));\n\n\topts.directory = directory;\n\topts.stop = stop;\n\topts.verbose = verbose;\n\n\treturn !do_lxcapi_migrate(c, MIGRATE_DUMP, &opts, sizeof(opts));\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_lxcapi_migrate",
          "args": [
            "c",
            "MIGRATE_DUMP",
            "&opts",
            "sizeof(opts)"
          ],
          "line": 4051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&opts",
            "0",
            "sizeof(opts)"
          ],
          "line": 4045
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_checkpoint(struct lxc_container *c, char *directory, bool stop, bool verbose)\n{\n\tstruct migrate_opts opts;\n\n\tmemset(&opts, 0, sizeof(opts));\n\n\topts.directory = directory;\n\topts.stop = stop;\n\topts.verbose = verbose;\n\n\treturn !do_lxcapi_migrate(c, MIGRATE_DUMP, &opts, sizeof(opts));\n}"
  },
  {
    "function_name": "do_lxcapi_add_device_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "3856-3863",
    "snippet": "static bool do_lxcapi_add_device_node(struct lxc_container *c, const char *src_path, const char *dest_path)\n{\n\tif (am_unpriv()) {\n\t\tERROR(NOT_SUPPORTED_ERROR, __FUNCTION__);\n\t\treturn false;\n\t}\n\treturn add_remove_device_node(c, src_path, dest_path, true);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [
      "#define NOT_SUPPORTED_ERROR \"the requested function %s is not currently supported with unprivileged containers\""
    ],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_remove_device_node",
          "args": [
            "c",
            "src_path",
            "dest_path",
            "true"
          ],
          "line": 3862
        },
        "resolved": true,
        "details": {
          "function_name": "add_remove_device_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "3805-3854",
          "snippet": "static bool add_remove_device_node(struct lxc_container *c, const char *src_path, const char *dest_path, bool add)\n{\n\tint ret;\n\tstruct stat st;\n\tchar value[MAX_BUFFER];\n\tconst char *p;\n\n\t/* make sure container is running */\n\tif (!do_lxcapi_is_running(c)) {\n\t\tERROR(\"container is not running\");\n\t\treturn false;\n\t}\n\n\t/* use src_path if dest_path is NULL otherwise use dest_path */\n\tp = dest_path ? dest_path : src_path;\n\n\t/* make sure we can access p */\n\tif(access(p, F_OK) < 0 || stat(p, &st) < 0)\n\t\treturn false;\n\n\t/* continue if path is character device or block device */\n\tif (S_ISCHR(st.st_mode))\n\t\tret = snprintf(value, MAX_BUFFER, \"c %d:%d rwm\", major(st.st_rdev), minor(st.st_rdev));\n\telse if (S_ISBLK(st.st_mode))\n\t\tret = snprintf(value, MAX_BUFFER, \"b %d:%d rwm\", major(st.st_rdev), minor(st.st_rdev));\n\telse\n\t\treturn false;\n\n\t/* check snprintf return code */\n\tif (ret < 0 || ret >= MAX_BUFFER)\n\t\treturn false;\n\n\tif (!do_add_remove_node(do_lxcapi_init_pid(c), p, add, &st))\n\t\treturn false;\n\n\t/* add or remove device to/from cgroup access list */\n\tif (add) {\n\t\tif (!do_lxcapi_set_cgroup_item(c, \"devices.allow\", value)) {\n\t\t\tERROR(\"set_cgroup_item failed while adding the device node\");\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tif (!do_lxcapi_set_cgroup_item(c, \"devices.deny\", value)) {\n\t\t\tERROR(\"set_cgroup_item failed while removing the device node\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [
            "#define MAX_BUFFER 4096"
          ],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\n#define MAX_BUFFER 4096\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool add_remove_device_node(struct lxc_container *c, const char *src_path, const char *dest_path, bool add)\n{\n\tint ret;\n\tstruct stat st;\n\tchar value[MAX_BUFFER];\n\tconst char *p;\n\n\t/* make sure container is running */\n\tif (!do_lxcapi_is_running(c)) {\n\t\tERROR(\"container is not running\");\n\t\treturn false;\n\t}\n\n\t/* use src_path if dest_path is NULL otherwise use dest_path */\n\tp = dest_path ? dest_path : src_path;\n\n\t/* make sure we can access p */\n\tif(access(p, F_OK) < 0 || stat(p, &st) < 0)\n\t\treturn false;\n\n\t/* continue if path is character device or block device */\n\tif (S_ISCHR(st.st_mode))\n\t\tret = snprintf(value, MAX_BUFFER, \"c %d:%d rwm\", major(st.st_rdev), minor(st.st_rdev));\n\telse if (S_ISBLK(st.st_mode))\n\t\tret = snprintf(value, MAX_BUFFER, \"b %d:%d rwm\", major(st.st_rdev), minor(st.st_rdev));\n\telse\n\t\treturn false;\n\n\t/* check snprintf return code */\n\tif (ret < 0 || ret >= MAX_BUFFER)\n\t\treturn false;\n\n\tif (!do_add_remove_node(do_lxcapi_init_pid(c), p, add, &st))\n\t\treturn false;\n\n\t/* add or remove device to/from cgroup access list */\n\tif (add) {\n\t\tif (!do_lxcapi_set_cgroup_item(c, \"devices.allow\", value)) {\n\t\t\tERROR(\"set_cgroup_item failed while adding the device node\");\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tif (!do_lxcapi_set_cgroup_item(c, \"devices.deny\", value)) {\n\t\t\tERROR(\"set_cgroup_item failed while removing the device node\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "NOT_SUPPORTED_ERROR",
            "__FUNCTION__"
          ],
          "line": 3859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "am_unpriv",
          "args": [],
          "line": 3858
        },
        "resolved": true,
        "details": {
          "function_name": "am_unpriv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.h",
          "lines": "288-290",
          "snippet": "inline static bool am_unpriv(void) {\n\treturn geteuid() != 0;\n}",
          "includes": [
            "#include <stdint.h>",
            "#  include <sys/signalfd.h>",
            "#include <../include/getline.h>",
            "#include \"initutils.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#  include <sys/signalfd.h>\n#include <../include/getline.h>\n#include \"initutils.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"config.h\"\n\ninline static bool am_unpriv(void) {\n\treturn geteuid() != 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\n#define NOT_SUPPORTED_ERROR \"the requested function %s is not currently supported with unprivileged containers\"\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_add_device_node(struct lxc_container *c, const char *src_path, const char *dest_path)\n{\n\tif (am_unpriv()) {\n\t\tERROR(NOT_SUPPORTED_ERROR, __FUNCTION__);\n\t\treturn false;\n\t}\n\treturn add_remove_device_node(c, src_path, dest_path, true);\n}"
  },
  {
    "function_name": "add_remove_device_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "3805-3854",
    "snippet": "static bool add_remove_device_node(struct lxc_container *c, const char *src_path, const char *dest_path, bool add)\n{\n\tint ret;\n\tstruct stat st;\n\tchar value[MAX_BUFFER];\n\tconst char *p;\n\n\t/* make sure container is running */\n\tif (!do_lxcapi_is_running(c)) {\n\t\tERROR(\"container is not running\");\n\t\treturn false;\n\t}\n\n\t/* use src_path if dest_path is NULL otherwise use dest_path */\n\tp = dest_path ? dest_path : src_path;\n\n\t/* make sure we can access p */\n\tif(access(p, F_OK) < 0 || stat(p, &st) < 0)\n\t\treturn false;\n\n\t/* continue if path is character device or block device */\n\tif (S_ISCHR(st.st_mode))\n\t\tret = snprintf(value, MAX_BUFFER, \"c %d:%d rwm\", major(st.st_rdev), minor(st.st_rdev));\n\telse if (S_ISBLK(st.st_mode))\n\t\tret = snprintf(value, MAX_BUFFER, \"b %d:%d rwm\", major(st.st_rdev), minor(st.st_rdev));\n\telse\n\t\treturn false;\n\n\t/* check snprintf return code */\n\tif (ret < 0 || ret >= MAX_BUFFER)\n\t\treturn false;\n\n\tif (!do_add_remove_node(do_lxcapi_init_pid(c), p, add, &st))\n\t\treturn false;\n\n\t/* add or remove device to/from cgroup access list */\n\tif (add) {\n\t\tif (!do_lxcapi_set_cgroup_item(c, \"devices.allow\", value)) {\n\t\t\tERROR(\"set_cgroup_item failed while adding the device node\");\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tif (!do_lxcapi_set_cgroup_item(c, \"devices.deny\", value)) {\n\t\t\tERROR(\"set_cgroup_item failed while removing the device node\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [
      "#define MAX_BUFFER 4096"
    ],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"set_cgroup_item failed while removing the device node\""
          ],
          "line": 3848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_lxcapi_set_cgroup_item",
          "args": [
            "c",
            "\"devices.deny\"",
            "value"
          ],
          "line": 3847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"set_cgroup_item failed while adding the device node\""
          ],
          "line": 3843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_lxcapi_set_cgroup_item",
          "args": [
            "c",
            "\"devices.allow\"",
            "value"
          ],
          "line": 3842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_add_remove_node",
          "args": [
            "do_lxcapi_init_pid(c)",
            "p",
            "add",
            "&st"
          ],
          "line": 3837
        },
        "resolved": true,
        "details": {
          "function_name": "do_add_remove_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "3750-3803",
          "snippet": "static bool do_add_remove_node(pid_t init_pid, const char *path, bool add,\n\t\tstruct stat *st)\n{\n\tchar chrootpath[MAXPATHLEN];\n\tchar *directory_path = NULL;\n\tpid_t pid;\n\tint ret;\n\n\tif ((pid = fork()) < 0) {\n\t\tSYSERROR(\"failed to fork a child helper\");\n\t\treturn false;\n\t}\n\tif (pid) {\n\t\tif (wait_for_pid(pid) != 0) {\n\t\t\tERROR(\"Failed to create note in guest\");\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/* prepare the path */\n\tret = snprintf(chrootpath, MAXPATHLEN, \"/proc/%d/root\", init_pid);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn false;\n\n\tif (chroot(chrootpath) < 0)\n\t\texit(1);\n\tif (chdir(\"/\") < 0)\n\t\texit(1);\n\t/* remove path if it exists */\n\tif(faccessat(AT_FDCWD, path, F_OK, AT_SYMLINK_NOFOLLOW) == 0) {\n\t\tif (unlink(path) < 0) {\n\t\t\tERROR(\"unlink failed\");\n\t\t\texit(1);\n\t\t}\n\t}\n\tif (!add)\n\t\texit(0);\n\n\t/* create any missing directories */\n\tdirectory_path = dirname(strdup(path));\n\tif (mkdir_p(directory_path, 0755) < 0 && errno != EEXIST) {\n\t\tERROR(\"failed to create directory\");\n\t\texit(1);\n\t}\n\n\t/* create the device node */\n\tif (mknod(path, st->st_mode, st->st_rdev) < 0) {\n\t\tERROR(\"mknod failed\");\n\t\texit(1);\n\t}\n\n\texit(0);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_add_remove_node(pid_t init_pid, const char *path, bool add,\n\t\tstruct stat *st)\n{\n\tchar chrootpath[MAXPATHLEN];\n\tchar *directory_path = NULL;\n\tpid_t pid;\n\tint ret;\n\n\tif ((pid = fork()) < 0) {\n\t\tSYSERROR(\"failed to fork a child helper\");\n\t\treturn false;\n\t}\n\tif (pid) {\n\t\tif (wait_for_pid(pid) != 0) {\n\t\t\tERROR(\"Failed to create note in guest\");\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/* prepare the path */\n\tret = snprintf(chrootpath, MAXPATHLEN, \"/proc/%d/root\", init_pid);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn false;\n\n\tif (chroot(chrootpath) < 0)\n\t\texit(1);\n\tif (chdir(\"/\") < 0)\n\t\texit(1);\n\t/* remove path if it exists */\n\tif(faccessat(AT_FDCWD, path, F_OK, AT_SYMLINK_NOFOLLOW) == 0) {\n\t\tif (unlink(path) < 0) {\n\t\t\tERROR(\"unlink failed\");\n\t\t\texit(1);\n\t\t}\n\t}\n\tif (!add)\n\t\texit(0);\n\n\t/* create any missing directories */\n\tdirectory_path = dirname(strdup(path));\n\tif (mkdir_p(directory_path, 0755) < 0 && errno != EEXIST) {\n\t\tERROR(\"failed to create directory\");\n\t\texit(1);\n\t}\n\n\t/* create the device node */\n\tif (mknod(path, st->st_mode, st->st_rdev) < 0) {\n\t\tERROR(\"mknod failed\");\n\t\texit(1);\n\t}\n\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_lxcapi_init_pid",
          "args": [
            "c"
          ],
          "line": 3837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "value",
            "MAX_BUFFER",
            "\"b %d:%d rwm\"",
            "major(st.st_rdev)",
            "minor(st.st_rdev)"
          ],
          "line": 3829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "st.st_rdev"
          ],
          "line": 3829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "major",
          "args": [
            "st.st_rdev"
          ],
          "line": 3829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "st.st_mode"
          ],
          "line": 3828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "value",
            "MAX_BUFFER",
            "\"c %d:%d rwm\"",
            "major(st.st_rdev)",
            "minor(st.st_rdev)"
          ],
          "line": 3827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "st.st_rdev"
          ],
          "line": 3827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "major",
          "args": [
            "st.st_rdev"
          ],
          "line": 3827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "st.st_mode"
          ],
          "line": 3826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "p",
            "&st"
          ],
          "line": 3822
        },
        "resolved": true,
        "details": {
          "function_name": "freezer_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/freezer.c",
          "lines": "42-51",
          "snippet": "lxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}",
          "includes": [
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"monitor.h\"",
            "#include \"state.h\"",
            "#include \"error.h\"",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxc.h\"\n#include \"log.h\"\n#include \"monitor.h\"\n#include \"state.h\"\n#include \"error.h\"\n#include <sys/param.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nlxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "p",
            "F_OK"
          ],
          "line": 3822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"container is not running\""
          ],
          "line": 3814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_lxcapi_is_running",
          "args": [
            "c"
          ],
          "line": 3813
        },
        "resolved": true,
        "details": {
          "function_name": "do_lxcapi_is_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "443-453",
          "snippet": "static bool do_lxcapi_is_running(struct lxc_container *c)\n{\n\tconst char *s;\n\n\tif (!c)\n\t\treturn false;\n\ts = do_lxcapi_state(c);\n\tif (!s || strcmp(s, \"STOPPED\") == 0)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_is_running(struct lxc_container *c)\n{\n\tconst char *s;\n\n\tif (!c)\n\t\treturn false;\n\ts = do_lxcapi_state(c);\n\tif (!s || strcmp(s, \"STOPPED\") == 0)\n\t\treturn false;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\n#define MAX_BUFFER 4096\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool add_remove_device_node(struct lxc_container *c, const char *src_path, const char *dest_path, bool add)\n{\n\tint ret;\n\tstruct stat st;\n\tchar value[MAX_BUFFER];\n\tconst char *p;\n\n\t/* make sure container is running */\n\tif (!do_lxcapi_is_running(c)) {\n\t\tERROR(\"container is not running\");\n\t\treturn false;\n\t}\n\n\t/* use src_path if dest_path is NULL otherwise use dest_path */\n\tp = dest_path ? dest_path : src_path;\n\n\t/* make sure we can access p */\n\tif(access(p, F_OK) < 0 || stat(p, &st) < 0)\n\t\treturn false;\n\n\t/* continue if path is character device or block device */\n\tif (S_ISCHR(st.st_mode))\n\t\tret = snprintf(value, MAX_BUFFER, \"c %d:%d rwm\", major(st.st_rdev), minor(st.st_rdev));\n\telse if (S_ISBLK(st.st_mode))\n\t\tret = snprintf(value, MAX_BUFFER, \"b %d:%d rwm\", major(st.st_rdev), minor(st.st_rdev));\n\telse\n\t\treturn false;\n\n\t/* check snprintf return code */\n\tif (ret < 0 || ret >= MAX_BUFFER)\n\t\treturn false;\n\n\tif (!do_add_remove_node(do_lxcapi_init_pid(c), p, add, &st))\n\t\treturn false;\n\n\t/* add or remove device to/from cgroup access list */\n\tif (add) {\n\t\tif (!do_lxcapi_set_cgroup_item(c, \"devices.allow\", value)) {\n\t\t\tERROR(\"set_cgroup_item failed while adding the device node\");\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tif (!do_lxcapi_set_cgroup_item(c, \"devices.deny\", value)) {\n\t\t\tERROR(\"set_cgroup_item failed while removing the device node\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "do_add_remove_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "3750-3803",
    "snippet": "static bool do_add_remove_node(pid_t init_pid, const char *path, bool add,\n\t\tstruct stat *st)\n{\n\tchar chrootpath[MAXPATHLEN];\n\tchar *directory_path = NULL;\n\tpid_t pid;\n\tint ret;\n\n\tif ((pid = fork()) < 0) {\n\t\tSYSERROR(\"failed to fork a child helper\");\n\t\treturn false;\n\t}\n\tif (pid) {\n\t\tif (wait_for_pid(pid) != 0) {\n\t\t\tERROR(\"Failed to create note in guest\");\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/* prepare the path */\n\tret = snprintf(chrootpath, MAXPATHLEN, \"/proc/%d/root\", init_pid);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn false;\n\n\tif (chroot(chrootpath) < 0)\n\t\texit(1);\n\tif (chdir(\"/\") < 0)\n\t\texit(1);\n\t/* remove path if it exists */\n\tif(faccessat(AT_FDCWD, path, F_OK, AT_SYMLINK_NOFOLLOW) == 0) {\n\t\tif (unlink(path) < 0) {\n\t\t\tERROR(\"unlink failed\");\n\t\t\texit(1);\n\t\t}\n\t}\n\tif (!add)\n\t\texit(0);\n\n\t/* create any missing directories */\n\tdirectory_path = dirname(strdup(path));\n\tif (mkdir_p(directory_path, 0755) < 0 && errno != EEXIST) {\n\t\tERROR(\"failed to create directory\");\n\t\texit(1);\n\t}\n\n\t/* create the device node */\n\tif (mknod(path, st->st_mode, st->st_rdev) < 0) {\n\t\tERROR(\"mknod failed\");\n\t\texit(1);\n\t}\n\n\texit(0);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 3802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 3799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"mknod failed\""
          ],
          "line": 3798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mknod",
          "args": [
            "path",
            "st->st_mode",
            "st->st_rdev"
          ],
          "line": 3797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 3793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to create directory\""
          ],
          "line": 3792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir_p",
          "args": [
            "directory_path",
            "0755"
          ],
          "line": 3791
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "241-262",
          "snippet": "extern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dirname",
          "args": [
            "strdup(path)"
          ],
          "line": 3790
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_util_dirname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lua-lxc/core.c",
          "lines": "569-573",
          "snippet": "static int lxc_util_dirname(lua_State *L) {\n    char *path = strdupa(luaL_checkstring(L, 1));\n    lua_pushstring(L, dirname(path));\n    return 1;\n}",
          "includes": [
            "#include \"lxc/commands.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <libgen.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <assert.h>",
            "#include <lauxlib.h>",
            "#include <lua.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxc/commands.h\"\n#include <lxc/lxccontainer.h>\n#include <libgen.h>\n#include <unistd.h>\n#include <string.h>\n#include <assert.h>\n#include <lauxlib.h>\n#include <lua.h>\n\nstatic int lxc_util_dirname(lua_State *L) {\n    char *path = strdupa(luaL_checkstring(L, 1));\n    lua_pushstring(L, dirname(path));\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "path"
          ],
          "line": 3790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 3787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 3783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"unlink failed\""
          ],
          "line": 3782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "path"
          ],
          "line": 3781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "faccessat",
          "args": [
            "AT_FDCWD",
            "path",
            "F_OK",
            "AT_SYMLINK_NOFOLLOW"
          ],
          "line": 3780
        },
        "resolved": true,
        "details": {
          "function_name": "faccessat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "89-97",
          "snippet": "static int faccessat(int __fd, const char *__file, int __type, int __flag)\n{\n#ifdef __NR_faccessat\nreturn syscall(__NR_faccessat, __fd, __file, __type, __flag);\n#else\nerrno = ENOSYS;\nreturn -1;\n#endif\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic int faccessat(int __fd, const char *__file, int __type, int __flag)\n{\n#ifdef __NR_faccessat\nreturn syscall(__NR_faccessat, __fd, __file, __type, __flag);\n#else\nerrno = ENOSYS;\nreturn -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 3778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "\"/\""
          ],
          "line": 3777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 3776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chroot",
          "args": [
            "chrootpath"
          ],
          "line": 3775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "chrootpath",
            "MAXPATHLEN",
            "\"/proc/%d/root\"",
            "init_pid"
          ],
          "line": 3771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to create note in guest\""
          ],
          "line": 3764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_pid",
          "args": [
            "pid"
          ],
          "line": 3763
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "311-325",
          "snippet": "int lxc_wait_for_pid_status(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\treturn status;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_wait_for_pid_status(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to fork a child helper\""
          ],
          "line": 3759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 3758
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_add_remove_node(pid_t init_pid, const char *path, bool add,\n\t\tstruct stat *st)\n{\n\tchar chrootpath[MAXPATHLEN];\n\tchar *directory_path = NULL;\n\tpid_t pid;\n\tint ret;\n\n\tif ((pid = fork()) < 0) {\n\t\tSYSERROR(\"failed to fork a child helper\");\n\t\treturn false;\n\t}\n\tif (pid) {\n\t\tif (wait_for_pid(pid) != 0) {\n\t\t\tERROR(\"Failed to create note in guest\");\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/* prepare the path */\n\tret = snprintf(chrootpath, MAXPATHLEN, \"/proc/%d/root\", init_pid);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn false;\n\n\tif (chroot(chrootpath) < 0)\n\t\texit(1);\n\tif (chdir(\"/\") < 0)\n\t\texit(1);\n\t/* remove path if it exists */\n\tif(faccessat(AT_FDCWD, path, F_OK, AT_SYMLINK_NOFOLLOW) == 0) {\n\t\tif (unlink(path) < 0) {\n\t\t\tERROR(\"unlink failed\");\n\t\t\texit(1);\n\t\t}\n\t}\n\tif (!add)\n\t\texit(0);\n\n\t/* create any missing directories */\n\tdirectory_path = dirname(strdup(path));\n\tif (mkdir_p(directory_path, 0755) < 0 && errno != EEXIST) {\n\t\tERROR(\"failed to create directory\");\n\t\texit(1);\n\t}\n\n\t/* create the device node */\n\tif (mknod(path, st->st_mode, st->st_rdev) < 0) {\n\t\tERROR(\"mknod failed\");\n\t\texit(1);\n\t}\n\n\texit(0);\n}"
  },
  {
    "function_name": "do_lxcapi_may_control",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "3743-3746",
    "snippet": "static bool do_lxcapi_may_control(struct lxc_container *c)\n{\n\treturn lxc_try_cmd(c->name, c->config_path) == 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_try_cmd",
          "args": [
            "c->name",
            "c->config_path"
          ],
          "line": 3745
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_try_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "340-368",
          "snippet": "int lxc_try_cmd(const char *name, const char *lxcpath)\n{\n\tint stopped, ret;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_GET_INIT_PID },\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\n\tif (stopped)\n\t\treturn 0;\n\tif (ret > 0 && cmd.rsp.ret < 0) {\n\t\terrno = cmd.rsp.ret;\n\t\treturn -1;\n\t}\n\tif (ret > 0)\n\t\treturn 0;\n\n\t/*\n\t * At this point we weren't denied access, and the\n\t * container *was* started.  There was some inexplicable\n\t * error in the protocol.\n\t * I'm not clear on whether we should return -1 here, but\n\t * we didn't receive a -EACCES, so technically it's not that\n\t * we're not allowed to control the container - it's just not\n\t * behaving.\n\t */\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nint lxc_try_cmd(const char *name, const char *lxcpath)\n{\n\tint stopped, ret;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_GET_INIT_PID },\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\n\tif (stopped)\n\t\treturn 0;\n\tif (ret > 0 && cmd.rsp.ret < 0) {\n\t\terrno = cmd.rsp.ret;\n\t\treturn -1;\n\t}\n\tif (ret > 0)\n\t\treturn 0;\n\n\t/*\n\t * At this point we weren't denied access, and the\n\t * container *was* started.  There was some inexplicable\n\t * error in the protocol.\n\t * I'm not clear on whether we should return -1 here, but\n\t * we didn't receive a -EACCES, so technically it's not that\n\t * we're not allowed to control the container - it's just not\n\t * behaving.\n\t */\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_may_control(struct lxc_container *c)\n{\n\treturn lxc_try_cmd(c->name, c->config_path) == 0;\n}"
  },
  {
    "function_name": "do_lxcapi_snapshot_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "3713-3724",
    "snippet": "static bool do_lxcapi_snapshot_destroy(struct lxc_container *c, const char *snapname)\n{\n\tchar clonelxcpath[MAXPATHLEN];\n\n\tif (!c || !c->name || !c->config_path || !snapname)\n\t\treturn false;\n\n\tif (!get_snappath_dir(c, clonelxcpath))\n\t\treturn false;\n\n\treturn do_snapshot_destroy(snapname, clonelxcpath);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_snapshot_destroy",
          "args": [
            "snapname",
            "clonelxcpath"
          ],
          "line": 3723
        },
        "resolved": true,
        "details": {
          "function_name": "do_snapshot_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_snapshot.c",
          "lines": "210-225",
          "snippet": "static int do_snapshot_destroy(struct lxc_container *c, char *snapname)\n{\n\tbool ret;\n\n\tif (strcmp(snapname, \"ALL\") == 0)\n\t\tret = c->snapshot_destroy_all(c);\n\telse\n\t\tret = c->snapshot_destroy(c, snapname);\n\n\tif (!ret) {\n\t\tERROR(\"Error destroying snapshot %s\", snapname);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"arguments.h\"",
            "#include \"log.h\"",
            "#include \"lxc.h\"",
            "#include \"bdev.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <libgen.h>",
            "#include <stdio.h>",
            "#include \"confile.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int do_snapshot_destroy(struct lxc_container *c, char *snapname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"arguments.h\"\n#include \"log.h\"\n#include \"lxc.h\"\n#include \"bdev.h\"\n#include <lxc/lxccontainer.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <libgen.h>\n#include <stdio.h>\n#include \"confile.h\"\n\nstatic int do_snapshot_destroy(struct lxc_container *c, char *snapname);\n\nstatic int do_snapshot_destroy(struct lxc_container *c, char *snapname)\n{\n\tbool ret;\n\n\tif (strcmp(snapname, \"ALL\") == 0)\n\t\tret = c->snapshot_destroy_all(c);\n\telse\n\t\tret = c->snapshot_destroy(c, snapname);\n\n\tif (!ret) {\n\t\tERROR(\"Error destroying snapshot %s\", snapname);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_snappath_dir",
          "args": [
            "c",
            "clonelxcpath"
          ],
          "line": 3720
        },
        "resolved": true,
        "details": {
          "function_name": "get_snappath_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "3344-3369",
          "snippet": "static bool get_snappath_dir(struct lxc_container *c, char *snappath)\n{\n\tint ret;\n\t/*\n\t * If the old style snapshot path exists, use it\n\t * /var/lib/lxc -> /var/lib/lxcsnaps\n\t */\n\tret = snprintf(snappath, MAXPATHLEN, \"%ssnaps\", c->config_path);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn false;\n\tif (dir_exists(snappath)) {\n\t\tret = snprintf(snappath, MAXPATHLEN, \"%ssnaps/%s\", c->config_path, c->name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/*\n\t * Use the new style path\n\t * /var/lib/lxc -> /var/lib/lxc + c->name + /snaps + \\0\n\t */\n\tret = snprintf(snappath, MAXPATHLEN, \"%s/%s/snaps\", c->config_path, c->name);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool get_snappath_dir(struct lxc_container *c, char *snappath);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool get_snappath_dir(struct lxc_container *c, char *snappath);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool get_snappath_dir(struct lxc_container *c, char *snappath)\n{\n\tint ret;\n\t/*\n\t * If the old style snapshot path exists, use it\n\t * /var/lib/lxc -> /var/lib/lxcsnaps\n\t */\n\tret = snprintf(snappath, MAXPATHLEN, \"%ssnaps\", c->config_path);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn false;\n\tif (dir_exists(snappath)) {\n\t\tret = snprintf(snappath, MAXPATHLEN, \"%ssnaps/%s\", c->config_path, c->name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/*\n\t * Use the new style path\n\t * /var/lib/lxc -> /var/lib/lxc + c->name + /snaps + \\0\n\t */\n\tret = snprintf(snappath, MAXPATHLEN, \"%s/%s/snaps\", c->config_path, c->name);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn false;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_snapshot_destroy(struct lxc_container *c, const char *snapname)\n{\n\tchar clonelxcpath[MAXPATHLEN];\n\n\tif (!c || !c->name || !c->config_path || !snapname)\n\t\treturn false;\n\n\tif (!get_snappath_dir(c, clonelxcpath))\n\t\treturn false;\n\n\treturn do_snapshot_destroy(snapname, clonelxcpath);\n}"
  },
  {
    "function_name": "do_lxcapi_snapshot_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "3517-3591",
    "snippet": "static int do_lxcapi_snapshot_list(struct lxc_container *c, struct lxc_snapshot **ret_snaps)\n{\n\tchar snappath[MAXPATHLEN], path2[MAXPATHLEN];\n\tint count = 0, ret;\n\tstruct dirent *direntp;\n\tstruct lxc_snapshot *snaps =NULL, *nsnaps;\n\tDIR *dir;\n\n\tif (!c || !lxcapi_is_defined(c))\n\t\treturn -1;\n\n\tif (!get_snappath_dir(c, snappath)) {\n\t\tERROR(\"path name too long\");\n\t\treturn -1;\n\t}\n\tdir = opendir(snappath);\n\tif (!dir) {\n\t\tINFO(\"failed to open %s - assuming no snapshots\", snappath);\n\t\treturn 0;\n\t}\n\n\twhile ((direntp = readdir(dir))) {\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\"))\n\t\t\tcontinue;\n\n\t\tif (!strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\tret = snprintf(path2, MAXPATHLEN, \"%s/%s/config\", snappath, direntp->d_name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\t\tERROR(\"pathname too long\");\n\t\t\tgoto out_free;\n\t\t}\n\t\tif (!file_exists(path2))\n\t\t\tcontinue;\n\t\tnsnaps = realloc(snaps, (count + 1)*sizeof(*snaps));\n\t\tif (!nsnaps) {\n\t\t\tSYSERROR(\"Out of memory\");\n\t\t\tgoto out_free;\n\t\t}\n\t\tsnaps = nsnaps;\n\t\tsnaps[count].free = lxcsnap_free;\n\t\tsnaps[count].name = strdup(direntp->d_name);\n\t\tif (!snaps[count].name)\n\t\t\tgoto out_free;\n\t\tsnaps[count].lxcpath = strdup(snappath);\n\t\tif (!snaps[count].lxcpath) {\n\t\t\tfree(snaps[count].name);\n\t\t\tgoto out_free;\n\t\t}\n\t\tsnaps[count].comment_pathname = get_snapcomment_path(snappath, direntp->d_name);\n\t\tsnaps[count].timestamp = get_timestamp(snappath, direntp->d_name);\n\t\tcount++;\n\t}\n\n\tif (closedir(dir))\n\t\tWARN(\"failed to close directory\");\n\n\t*ret_snaps = snaps;\n\treturn count;\n\nout_free:\n\tif (snaps) {\n\t\tint i;\n\t\tfor (i=0; i<count; i++)\n\t\t\tlxcsnap_free(&snaps[i]);\n\t\tfree(snaps);\n\t}\n\tif (closedir(dir))\n\t\tWARN(\"failed to close directory\");\n\treturn -1;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool get_snappath_dir(struct lxc_container *c, char *snappath);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"failed to close directory\""
          ],
          "line": 3589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dir"
          ],
          "line": 3588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "snaps"
          ],
          "line": 3586
        },
        "resolved": true,
        "details": {
          "function_name": "free_init_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "706-715",
          "snippet": "static void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxcsnap_free",
          "args": [
            "&snaps[i]"
          ],
          "line": 3585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"failed to close directory\""
          ],
          "line": 3576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dir"
          ],
          "line": 3575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_timestamp",
          "args": [
            "snappath",
            "direntp->d_name"
          ],
          "line": 3571
        },
        "resolved": true,
        "details": {
          "function_name": "get_timestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "3487-3515",
          "snippet": "static char *get_timestamp(char* snappath, char *name)\n{\n\tchar path[MAXPATHLEN], *s = NULL;\n\tint ret, len;\n\tFILE *fin;\n\n\tret = snprintf(path, MAXPATHLEN, \"%s/%s/ts\", snappath, name);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn NULL;\n\tfin = fopen(path, \"r\");\n\tif (!fin)\n\t\treturn NULL;\n\t(void) fseek(fin, 0, SEEK_END);\n\tlen = ftell(fin);\n\t(void) fseek(fin, 0, SEEK_SET);\n\tif (len > 0) {\n\t\ts = malloc(len+1);\n\t\tif (s) {\n\t\t\ts[len] = '\\0';\n\t\t\tif (fread(s, 1, len, fin) != len) {\n\t\t\t\tSYSERROR(\"reading timestamp\");\n\t\t\t\tfree(s);\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t}\n\t}\n\tfclose(fin);\n\treturn s;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool get_snappath_dir(struct lxc_container *c, char *snappath);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool get_snappath_dir(struct lxc_container *c, char *snappath);\n\nstatic char *get_timestamp(char* snappath, char *name)\n{\n\tchar path[MAXPATHLEN], *s = NULL;\n\tint ret, len;\n\tFILE *fin;\n\n\tret = snprintf(path, MAXPATHLEN, \"%s/%s/ts\", snappath, name);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn NULL;\n\tfin = fopen(path, \"r\");\n\tif (!fin)\n\t\treturn NULL;\n\t(void) fseek(fin, 0, SEEK_END);\n\tlen = ftell(fin);\n\t(void) fseek(fin, 0, SEEK_SET);\n\tif (len > 0) {\n\t\ts = malloc(len+1);\n\t\tif (s) {\n\t\t\ts[len] = '\\0';\n\t\t\tif (fread(s, 1, len, fin) != len) {\n\t\t\t\tSYSERROR(\"reading timestamp\");\n\t\t\t\tfree(s);\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t}\n\t}\n\tfclose(fin);\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_snapcomment_path",
          "args": [
            "snappath",
            "direntp->d_name"
          ],
          "line": 3570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "snappath"
          ],
          "line": 3565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "direntp->d_name"
          ],
          "line": 3562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Out of memory\""
          ],
          "line": 3557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "snaps",
            "(count + 1)*sizeof(*snaps)"
          ],
          "line": 3555
        },
        "resolved": true,
        "details": {
          "function_name": "must_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "116-124",
          "snippet": "static void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_exists",
          "args": [
            "path2"
          ],
          "line": 3553
        },
        "resolved": true,
        "details": {
          "function_name": "file_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1240-1245",
          "snippet": "bool file_exists(const char *f)\n{\n\tstruct stat statbuf;\n\n\treturn stat(f, &statbuf) == 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool file_exists(const char *f)\n{\n\tstruct stat statbuf;\n\n\treturn stat(f, &statbuf) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"pathname too long\""
          ],
          "line": 3550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path2",
            "MAXPATHLEN",
            "\"%s/%s/config\"",
            "snappath",
            "direntp->d_name"
          ],
          "line": 3548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "direntp->d_name",
            "\"..\""
          ],
          "line": 3545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "direntp->d_name",
            "\".\""
          ],
          "line": 3542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "dir"
          ],
          "line": 3538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"failed to open %s - assuming no snapshots\"",
            "snappath"
          ],
          "line": 3534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "snappath"
          ],
          "line": 3532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"path name too long\""
          ],
          "line": 3529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_snappath_dir",
          "args": [
            "c",
            "snappath"
          ],
          "line": 3528
        },
        "resolved": true,
        "details": {
          "function_name": "get_snappath_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "3344-3369",
          "snippet": "static bool get_snappath_dir(struct lxc_container *c, char *snappath)\n{\n\tint ret;\n\t/*\n\t * If the old style snapshot path exists, use it\n\t * /var/lib/lxc -> /var/lib/lxcsnaps\n\t */\n\tret = snprintf(snappath, MAXPATHLEN, \"%ssnaps\", c->config_path);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn false;\n\tif (dir_exists(snappath)) {\n\t\tret = snprintf(snappath, MAXPATHLEN, \"%ssnaps/%s\", c->config_path, c->name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/*\n\t * Use the new style path\n\t * /var/lib/lxc -> /var/lib/lxc + c->name + /snaps + \\0\n\t */\n\tret = snprintf(snappath, MAXPATHLEN, \"%s/%s/snaps\", c->config_path, c->name);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool get_snappath_dir(struct lxc_container *c, char *snappath);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool get_snappath_dir(struct lxc_container *c, char *snappath);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool get_snappath_dir(struct lxc_container *c, char *snappath)\n{\n\tint ret;\n\t/*\n\t * If the old style snapshot path exists, use it\n\t * /var/lib/lxc -> /var/lib/lxcsnaps\n\t */\n\tret = snprintf(snappath, MAXPATHLEN, \"%ssnaps\", c->config_path);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn false;\n\tif (dir_exists(snappath)) {\n\t\tret = snprintf(snappath, MAXPATHLEN, \"%ssnaps/%s\", c->config_path, c->name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/*\n\t * Use the new style path\n\t * /var/lib/lxc -> /var/lib/lxc + c->name + /snaps + \\0\n\t */\n\tret = snprintf(snappath, MAXPATHLEN, \"%s/%s/snaps\", c->config_path, c->name);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxcapi_is_defined",
          "args": [
            "c"
          ],
          "line": 3525
        },
        "resolved": true,
        "details": {
          "function_name": "do_lxcapi_is_defined",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "327-348",
          "snippet": "static bool do_lxcapi_is_defined(struct lxc_container *c)\n{\n\tstruct stat statbuf;\n\tbool ret = false;\n\tint statret;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (container_mem_lock(c))\n\t\treturn false;\n\tif (!c->configfile)\n\t\tgoto out;\n\tstatret = stat(c->configfile, &statbuf);\n\tif (statret != 0)\n\t\tgoto out;\n\tret = true;\n\nout:\n\tcontainer_mem_unlock(c);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_is_defined(struct lxc_container *c)\n{\n\tstruct stat statbuf;\n\tbool ret = false;\n\tint statret;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (container_mem_lock(c))\n\t\treturn false;\n\tif (!c->configfile)\n\t\tgoto out;\n\tstatret = stat(c->configfile, &statbuf);\n\tif (statret != 0)\n\t\tgoto out;\n\tret = true;\n\nout:\n\tcontainer_mem_unlock(c);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool get_snappath_dir(struct lxc_container *c, char *snappath);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic int do_lxcapi_snapshot_list(struct lxc_container *c, struct lxc_snapshot **ret_snaps)\n{\n\tchar snappath[MAXPATHLEN], path2[MAXPATHLEN];\n\tint count = 0, ret;\n\tstruct dirent *direntp;\n\tstruct lxc_snapshot *snaps =NULL, *nsnaps;\n\tDIR *dir;\n\n\tif (!c || !lxcapi_is_defined(c))\n\t\treturn -1;\n\n\tif (!get_snappath_dir(c, snappath)) {\n\t\tERROR(\"path name too long\");\n\t\treturn -1;\n\t}\n\tdir = opendir(snappath);\n\tif (!dir) {\n\t\tINFO(\"failed to open %s - assuming no snapshots\", snappath);\n\t\treturn 0;\n\t}\n\n\twhile ((direntp = readdir(dir))) {\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\"))\n\t\t\tcontinue;\n\n\t\tif (!strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\tret = snprintf(path2, MAXPATHLEN, \"%s/%s/config\", snappath, direntp->d_name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\t\tERROR(\"pathname too long\");\n\t\t\tgoto out_free;\n\t\t}\n\t\tif (!file_exists(path2))\n\t\t\tcontinue;\n\t\tnsnaps = realloc(snaps, (count + 1)*sizeof(*snaps));\n\t\tif (!nsnaps) {\n\t\t\tSYSERROR(\"Out of memory\");\n\t\t\tgoto out_free;\n\t\t}\n\t\tsnaps = nsnaps;\n\t\tsnaps[count].free = lxcsnap_free;\n\t\tsnaps[count].name = strdup(direntp->d_name);\n\t\tif (!snaps[count].name)\n\t\t\tgoto out_free;\n\t\tsnaps[count].lxcpath = strdup(snappath);\n\t\tif (!snaps[count].lxcpath) {\n\t\t\tfree(snaps[count].name);\n\t\t\tgoto out_free;\n\t\t}\n\t\tsnaps[count].comment_pathname = get_snapcomment_path(snappath, direntp->d_name);\n\t\tsnaps[count].timestamp = get_timestamp(snappath, direntp->d_name);\n\t\tcount++;\n\t}\n\n\tif (closedir(dir))\n\t\tWARN(\"failed to close directory\");\n\n\t*ret_snaps = snaps;\n\treturn count;\n\nout_free:\n\tif (snaps) {\n\t\tint i;\n\t\tfor (i=0; i<count; i++)\n\t\t\tlxcsnap_free(&snaps[i]);\n\t\tfree(snaps);\n\t}\n\tif (closedir(dir))\n\t\tWARN(\"failed to close directory\");\n\treturn -1;\n}"
  },
  {
    "function_name": "get_timestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "3487-3515",
    "snippet": "static char *get_timestamp(char* snappath, char *name)\n{\n\tchar path[MAXPATHLEN], *s = NULL;\n\tint ret, len;\n\tFILE *fin;\n\n\tret = snprintf(path, MAXPATHLEN, \"%s/%s/ts\", snappath, name);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn NULL;\n\tfin = fopen(path, \"r\");\n\tif (!fin)\n\t\treturn NULL;\n\t(void) fseek(fin, 0, SEEK_END);\n\tlen = ftell(fin);\n\t(void) fseek(fin, 0, SEEK_SET);\n\tif (len > 0) {\n\t\ts = malloc(len+1);\n\t\tif (s) {\n\t\t\ts[len] = '\\0';\n\t\t\tif (fread(s, 1, len, fin) != len) {\n\t\t\t\tSYSERROR(\"reading timestamp\");\n\t\t\t\tfree(s);\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t}\n\t}\n\tfclose(fin);\n\treturn s;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool get_snappath_dir(struct lxc_container *c, char *snappath);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fin"
          ],
          "line": 3513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "s"
          ],
          "line": 3508
        },
        "resolved": true,
        "details": {
          "function_name": "free_init_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "706-715",
          "snippet": "static void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"reading timestamp\""
          ],
          "line": 3507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "s",
            "1",
            "len",
            "fin"
          ],
          "line": 3506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len+1"
          ],
          "line": 3503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fseek",
          "args": [
            "fin",
            "0",
            "SEEK_SET"
          ],
          "line": 3501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftell",
          "args": [
            "fin"
          ],
          "line": 3500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fseek",
          "args": [
            "fin",
            "0",
            "SEEK_END"
          ],
          "line": 3499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "path",
            "\"r\""
          ],
          "line": 3496
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "MAXPATHLEN",
            "\"%s/%s/ts\"",
            "snappath",
            "name"
          ],
          "line": 3493
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool get_snappath_dir(struct lxc_container *c, char *snappath);\n\nstatic char *get_timestamp(char* snappath, char *name)\n{\n\tchar path[MAXPATHLEN], *s = NULL;\n\tint ret, len;\n\tFILE *fin;\n\n\tret = snprintf(path, MAXPATHLEN, \"%s/%s/ts\", snappath, name);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn NULL;\n\tfin = fopen(path, \"r\");\n\tif (!fin)\n\t\treturn NULL;\n\t(void) fseek(fin, 0, SEEK_END);\n\tlen = ftell(fin);\n\t(void) fseek(fin, 0, SEEK_SET);\n\tif (len > 0) {\n\t\ts = malloc(len+1);\n\t\tif (s) {\n\t\t\ts[len] = '\\0';\n\t\t\tif (fread(s, 1, len, fin) != len) {\n\t\t\t\tSYSERROR(\"reading timestamp\");\n\t\t\t\tfree(s);\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t}\n\t}\n\tfclose(fin);\n\treturn s;\n}"
  },
  {
    "function_name": "do_lxcapi_snapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "3371-3459",
    "snippet": "static int do_lxcapi_snapshot(struct lxc_container *c, const char *commentfile)\n{\n\tint i, flags, ret;\n\tstruct lxc_container *c2;\n\tchar snappath[MAXPATHLEN], newname[20];\n\n\tif (!c || !lxcapi_is_defined(c))\n\t\treturn -1;\n\n\tif (!bdev_can_backup(c->lxc_conf)) {\n\t\tERROR(\"%s's backing store cannot be backed up.\", c->name);\n\t\tERROR(\"Your container must use another backing store type.\");\n\t\treturn -1;\n\t}\n\n\tif (!get_snappath_dir(c, snappath))\n\t\treturn -1;\n\n\ti = get_next_index(snappath, c->name);\n\n\tif (mkdir_p(snappath, 0755) < 0) {\n\t\tERROR(\"Failed to create snapshot directory %s\", snappath);\n\t\treturn -1;\n\t}\n\n\tret = snprintf(newname, 20, \"snap%d\", i);\n\tif (ret < 0 || ret >= 20)\n\t\treturn -1;\n\n\t/*\n\t * We pass LXC_CLONE_SNAPSHOT to make sure that a rdepends file entry is\n\t * created in the original container\n\t */\n\tflags = LXC_CLONE_SNAPSHOT | LXC_CLONE_KEEPMACADDR | LXC_CLONE_KEEPNAME |\n\t\tLXC_CLONE_KEEPBDEVTYPE | LXC_CLONE_MAYBE_SNAPSHOT;\n\tif (bdev_is_dir(c->lxc_conf, c->lxc_conf->rootfs.path)) {\n\t\tERROR(\"Snapshot of directory-backed container requested.\");\n\t\tERROR(\"Making a copy-clone.  If you do want snapshots, then\");\n\t\tERROR(\"please create an aufs or overlayfs clone first, snapshot that\");\n\t\tERROR(\"and keep the original container pristine.\");\n\t\tflags &= ~LXC_CLONE_SNAPSHOT | LXC_CLONE_MAYBE_SNAPSHOT;\n\t}\n\tc2 = do_lxcapi_clone(c, newname, snappath, flags, NULL, NULL, 0, NULL);\n\tif (!c2) {\n\t\tERROR(\"clone of %s:%s failed\", c->config_path, c->name);\n\t\treturn -1;\n\t}\n\n\tlxc_container_put(c2);\n\n\t// Now write down the creation time\n\ttime_t timer;\n\tchar buffer[25];\n\tstruct tm* tm_info;\n\tFILE *f;\n\n\ttime(&timer);\n\ttm_info = localtime(&timer);\n\n\tstrftime(buffer, 25, \"%Y:%m:%d %H:%M:%S\", tm_info);\n\n\tchar *dfnam = alloca(strlen(snappath) + strlen(newname) + 5);\n\tsprintf(dfnam, \"%s/%s/ts\", snappath, newname);\n\tf = fopen(dfnam, \"w\");\n\tif (!f) {\n\t\tERROR(\"Failed to open %s\", dfnam);\n\t\treturn -1;\n\t}\n\tif (fprintf(f, \"%s\", buffer) < 0) {\n\t\tSYSERROR(\"Writing timestamp\");\n\t\tfclose(f);\n\t\treturn -1;\n\t}\n\tret = fclose(f);\n\tif (ret != 0) {\n\t\tSYSERROR(\"Writing timestamp\");\n\t\treturn -1;\n\t}\n\n\tif (commentfile) {\n\t\t// $p / $name / comment \\0\n\t\tint len = strlen(snappath) + strlen(newname) + 10;\n\t\tchar *path = alloca(len);\n\t\tsprintf(path, \"%s/%s/comment\", snappath, newname);\n\t\treturn copy_file(commentfile, path) < 0 ? -1 : i;\n\t}\n\n\treturn i;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool get_snappath_dir(struct lxc_container *c, char *snappath);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_file",
          "args": [
            "commentfile",
            "path"
          ],
          "line": 3455
        },
        "resolved": true,
        "details": {
          "function_name": "copy_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2628-2687",
          "snippet": "static int copy_file(const char *old, const char *new)\n{\n\tint in, out;\n\tssize_t len, ret;\n\tchar buf[8096];\n\tstruct stat sbuf;\n\n\tif (file_exists(new)) {\n\t\tERROR(\"copy destination %s exists\", new);\n\t\treturn -1;\n\t}\n\tret = stat(old, &sbuf);\n\tif (ret < 0) {\n\t\tINFO(\"Error stat'ing %s\", old);\n\t\treturn -1;\n\t}\n\n\tin = open(old, O_RDONLY);\n\tif (in < 0) {\n\t\tSYSERROR(\"Error opening original file %s\", old);\n\t\treturn -1;\n\t}\n\tout = open(new, O_CREAT | O_EXCL | O_WRONLY, 0644);\n\tif (out < 0) {\n\t\tSYSERROR(\"Error opening new file %s\", new);\n\t\tclose(in);\n\t\treturn -1;\n\t}\n\n\twhile (1) {\n\t\tlen = read(in, buf, 8096);\n\t\tif (len < 0) {\n\t\t\tSYSERROR(\"Error reading old file %s\", old);\n\t\t\tgoto err;\n\t\t}\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tret = write(out, buf, len);\n\t\tif (ret < len) { // should we retry?\n\t\t\tSYSERROR(\"Error: write to new file %s was interrupted\", new);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tclose(in);\n\tclose(out);\n\n\t// we set mode, but not owner/group\n\tret = chmod(new, sbuf.st_mode);\n\tif (ret) {\n\t\tSYSERROR(\"Error setting mode on %s\", new);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n\nerr:\n\tclose(in);\n\tclose(out);\n\treturn -1;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic int copy_file(const char *old, const char *new)\n{\n\tint in, out;\n\tssize_t len, ret;\n\tchar buf[8096];\n\tstruct stat sbuf;\n\n\tif (file_exists(new)) {\n\t\tERROR(\"copy destination %s exists\", new);\n\t\treturn -1;\n\t}\n\tret = stat(old, &sbuf);\n\tif (ret < 0) {\n\t\tINFO(\"Error stat'ing %s\", old);\n\t\treturn -1;\n\t}\n\n\tin = open(old, O_RDONLY);\n\tif (in < 0) {\n\t\tSYSERROR(\"Error opening original file %s\", old);\n\t\treturn -1;\n\t}\n\tout = open(new, O_CREAT | O_EXCL | O_WRONLY, 0644);\n\tif (out < 0) {\n\t\tSYSERROR(\"Error opening new file %s\", new);\n\t\tclose(in);\n\t\treturn -1;\n\t}\n\n\twhile (1) {\n\t\tlen = read(in, buf, 8096);\n\t\tif (len < 0) {\n\t\t\tSYSERROR(\"Error reading old file %s\", old);\n\t\t\tgoto err;\n\t\t}\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tret = write(out, buf, len);\n\t\tif (ret < len) { // should we retry?\n\t\t\tSYSERROR(\"Error: write to new file %s was interrupted\", new);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tclose(in);\n\tclose(out);\n\n\t// we set mode, but not owner/group\n\tret = chmod(new, sbuf.st_mode);\n\tif (ret) {\n\t\tSYSERROR(\"Error setting mode on %s\", new);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n\nerr:\n\tclose(in);\n\tclose(out);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "path",
            "\"%s/%s/comment\"",
            "snappath",
            "newname"
          ],
          "line": 3454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "len"
          ],
          "line": 3453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "newname"
          ],
          "line": 3452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "snappath"
          ],
          "line": 3452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Writing timestamp\""
          ],
          "line": 3446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 3444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 3441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Writing timestamp\""
          ],
          "line": 3440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"%s\"",
            "buffer"
          ],
          "line": 3439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to open %s\"",
            "dfnam"
          ],
          "line": 3436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "dfnam",
            "\"w\""
          ],
          "line": 3434
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "dfnam",
            "\"%s/%s/ts\"",
            "snappath",
            "newname"
          ],
          "line": 3433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "strlen(snappath) + strlen(newname) + 5"
          ],
          "line": 3432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "newname"
          ],
          "line": 3432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "snappath"
          ],
          "line": 3432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strftime",
          "args": [
            "buffer",
            "25",
            "\"%Y:%m:%d %H:%M:%S\"",
            "tm_info"
          ],
          "line": 3430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "localtime",
          "args": [
            "&timer"
          ],
          "line": 3428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "&timer"
          ],
          "line": 3427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_container_put",
          "args": [
            "c2"
          ],
          "line": 3419
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "312-325",
          "snippet": "int lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"clone of %s:%s failed\"",
            "c->config_path",
            "c->name"
          ],
          "line": 3415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_lxcapi_clone",
          "args": [
            "c",
            "newname",
            "snappath",
            "flags",
            "NULL",
            "NULL",
            "0",
            "NULL"
          ],
          "line": 3413
        },
        "resolved": true,
        "details": {
          "function_name": "do_lxcapi_clone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "3058-3235",
          "snippet": "static struct lxc_container *do_lxcapi_clone(struct lxc_container *c, const char *newname,\n\t\tconst char *lxcpath, int flags,\n\t\tconst char *bdevtype, const char *bdevdata, uint64_t newsize,\n\t\tchar **hookargs)\n{\n\tstruct lxc_container *c2 = NULL;\n\tchar newpath[MAXPATHLEN];\n\tint ret, storage_copied = 0;\n\tchar *origroot = NULL, *saved_unexp_conf = NULL;\n\tstruct clone_update_data data;\n\tsize_t saved_unexp_len;\n\tFILE *fout;\n\tpid_t pid;\n\n\tif (!c || !do_lxcapi_is_defined(c))\n\t\treturn NULL;\n\n\tif (container_mem_lock(c))\n\t\treturn NULL;\n\n\tif (!is_stopped(c)) {\n\t\tERROR(\"error: Original container (%s) is running\", c->name);\n\t\tgoto out;\n\t}\n\n\t// Make sure the container doesn't yet exist.\n\tif (!newname)\n\t\tnewname = c->name;\n\tif (!lxcpath)\n\t\tlxcpath = do_lxcapi_get_config_path(c);\n\tret = snprintf(newpath, MAXPATHLEN, \"%s/%s/config\", lxcpath, newname);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"clone: failed making config pathname\");\n\t\tgoto out;\n\t}\n\tif (file_exists(newpath)) {\n\t\tERROR(\"error: clone: %s exists\", newpath);\n\t\tgoto out;\n\t}\n\n\tret = create_file_dirname(newpath, c->lxc_conf);\n\tif (ret < 0 && errno != EEXIST) {\n\t\tERROR(\"Error creating container dir for %s\", newpath);\n\t\tgoto out;\n\t}\n\n\t// copy the configuration, tweak it as needed,\n\tif (c->lxc_conf->rootfs.path) {\n\t\torigroot = c->lxc_conf->rootfs.path;\n\t\tc->lxc_conf->rootfs.path = NULL;\n\t}\n\tfout = fopen(newpath, \"w\");\n\tif (!fout) {\n\t\tSYSERROR(\"open %s\", newpath);\n\t\tgoto out;\n\t}\n\n\tsaved_unexp_conf = c->lxc_conf->unexpanded_config;\n\tsaved_unexp_len = c->lxc_conf->unexpanded_len;\n\tc->lxc_conf->unexpanded_config = strdup(saved_unexp_conf);\n\tif (!c->lxc_conf->unexpanded_config) {\n\t\tERROR(\"Out of memory\");\n\t\tfclose(fout);\n\t\tgoto out;\n\t}\n\tclear_unexp_config_line(c->lxc_conf, \"lxc.rootfs\", false);\n\twrite_config(fout, c->lxc_conf);\n\tfclose(fout);\n\tc->lxc_conf->rootfs.path = origroot;\n\tfree(c->lxc_conf->unexpanded_config);\n\tc->lxc_conf->unexpanded_config = saved_unexp_conf;\n\tsaved_unexp_conf = NULL;\n\tc->lxc_conf->unexpanded_len = saved_unexp_len;\n\n\tsprintf(newpath, \"%s/%s/rootfs\", lxcpath, newname);\n\tif (mkdir(newpath, 0755) < 0) {\n\t\tSYSERROR(\"error creating %s\", newpath);\n\t\tgoto out;\n\t}\n\n\tif (am_unpriv()) {\n\t\tif (chown_mapped_root(newpath, c->lxc_conf) < 0) {\n\t\t\tERROR(\"Error chowning %s to container root\", newpath);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tc2 = lxc_container_new(newname, lxcpath);\n\tif (!c2) {\n\t\tERROR(\"clone: failed to create new container (%s %s)\", newname,\n\t\t\t\tlxcpath);\n\t\tgoto out;\n\t}\n\n\t// copy/snapshot rootfs's\n\tret = copy_storage(c, c2, bdevtype, flags, bdevdata, newsize);\n\tif (ret < 0)\n\t\tgoto out;\n\n\n\t// update utsname\n\tif (!(flags & LXC_CLONE_KEEPNAME)) {\n\t\tclear_unexp_config_line(c2->lxc_conf, \"lxc.utsname\", false);\n\n\t\tif (!set_config_item_locked(c2, \"lxc.utsname\", newname)) {\n\t\t\tERROR(\"Error setting new hostname\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t// copy hooks\n\tret = copyhooks(c, c2);\n\tif (ret < 0) {\n\t\tERROR(\"error copying hooks\");\n\t\tgoto out;\n\t}\n\n\tif (copy_fstab(c, c2) < 0) {\n\t\tERROR(\"error copying fstab\");\n\t\tgoto out;\n\t}\n\n\t// update macaddrs\n\tif (!(flags & LXC_CLONE_KEEPMACADDR)) {\n\t\tif (!network_new_hwaddrs(c2->lxc_conf)) {\n\t\t\tERROR(\"Error updating mac addresses\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t// update absolute paths for overlay mount directories\n\tif (ovl_update_abs_paths(c2->lxc_conf, c->config_path, c->name, lxcpath, newname) < 0)\n\t\tgoto out;\n\n\t// We've now successfully created c2's storage, so clear it out if we\n\t// fail after this\n\tstorage_copied = 1;\n\n\tif (!c2->save_config(c2, NULL))\n\t\tgoto out;\n\n\tif ((pid = fork()) < 0) {\n\t\tSYSERROR(\"fork\");\n\t\tgoto out;\n\t}\n\tif (pid > 0) {\n\t\tret = wait_for_pid(pid);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tcontainer_mem_unlock(c);\n\t\treturn c2;\n\t}\n\tdata.c0 = c;\n\tdata.c1 = c2;\n\tdata.flags = flags;\n\tdata.hookargs = hookargs;\n\tif (am_unpriv())\n\t\tret = userns_exec_1(c->lxc_conf, clone_update_rootfs_wrapper,\n\t\t\t\t&data);\n\telse\n\t\tret = clone_update_rootfs(&data);\n\tif (ret < 0)\n\t\texit(1);\n\n\tcontainer_mem_unlock(c);\n\texit(0);\n\nout:\n\tcontainer_mem_unlock(c);\n\tif (c2) {\n\t\tif (!storage_copied)\n\t\t\tc2->lxc_conf->rootfs.path = NULL;\n\t\tc2->destroy(c2);\n\t\tlxc_container_put(c2);\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic struct lxc_container *do_lxcapi_clone(struct lxc_container *c, const char *newname,\n\t\tconst char *lxcpath, int flags,\n\t\tconst char *bdevtype, const char *bdevdata, uint64_t newsize,\n\t\tchar **hookargs)\n{\n\tstruct lxc_container *c2 = NULL;\n\tchar newpath[MAXPATHLEN];\n\tint ret, storage_copied = 0;\n\tchar *origroot = NULL, *saved_unexp_conf = NULL;\n\tstruct clone_update_data data;\n\tsize_t saved_unexp_len;\n\tFILE *fout;\n\tpid_t pid;\n\n\tif (!c || !do_lxcapi_is_defined(c))\n\t\treturn NULL;\n\n\tif (container_mem_lock(c))\n\t\treturn NULL;\n\n\tif (!is_stopped(c)) {\n\t\tERROR(\"error: Original container (%s) is running\", c->name);\n\t\tgoto out;\n\t}\n\n\t// Make sure the container doesn't yet exist.\n\tif (!newname)\n\t\tnewname = c->name;\n\tif (!lxcpath)\n\t\tlxcpath = do_lxcapi_get_config_path(c);\n\tret = snprintf(newpath, MAXPATHLEN, \"%s/%s/config\", lxcpath, newname);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"clone: failed making config pathname\");\n\t\tgoto out;\n\t}\n\tif (file_exists(newpath)) {\n\t\tERROR(\"error: clone: %s exists\", newpath);\n\t\tgoto out;\n\t}\n\n\tret = create_file_dirname(newpath, c->lxc_conf);\n\tif (ret < 0 && errno != EEXIST) {\n\t\tERROR(\"Error creating container dir for %s\", newpath);\n\t\tgoto out;\n\t}\n\n\t// copy the configuration, tweak it as needed,\n\tif (c->lxc_conf->rootfs.path) {\n\t\torigroot = c->lxc_conf->rootfs.path;\n\t\tc->lxc_conf->rootfs.path = NULL;\n\t}\n\tfout = fopen(newpath, \"w\");\n\tif (!fout) {\n\t\tSYSERROR(\"open %s\", newpath);\n\t\tgoto out;\n\t}\n\n\tsaved_unexp_conf = c->lxc_conf->unexpanded_config;\n\tsaved_unexp_len = c->lxc_conf->unexpanded_len;\n\tc->lxc_conf->unexpanded_config = strdup(saved_unexp_conf);\n\tif (!c->lxc_conf->unexpanded_config) {\n\t\tERROR(\"Out of memory\");\n\t\tfclose(fout);\n\t\tgoto out;\n\t}\n\tclear_unexp_config_line(c->lxc_conf, \"lxc.rootfs\", false);\n\twrite_config(fout, c->lxc_conf);\n\tfclose(fout);\n\tc->lxc_conf->rootfs.path = origroot;\n\tfree(c->lxc_conf->unexpanded_config);\n\tc->lxc_conf->unexpanded_config = saved_unexp_conf;\n\tsaved_unexp_conf = NULL;\n\tc->lxc_conf->unexpanded_len = saved_unexp_len;\n\n\tsprintf(newpath, \"%s/%s/rootfs\", lxcpath, newname);\n\tif (mkdir(newpath, 0755) < 0) {\n\t\tSYSERROR(\"error creating %s\", newpath);\n\t\tgoto out;\n\t}\n\n\tif (am_unpriv()) {\n\t\tif (chown_mapped_root(newpath, c->lxc_conf) < 0) {\n\t\t\tERROR(\"Error chowning %s to container root\", newpath);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tc2 = lxc_container_new(newname, lxcpath);\n\tif (!c2) {\n\t\tERROR(\"clone: failed to create new container (%s %s)\", newname,\n\t\t\t\tlxcpath);\n\t\tgoto out;\n\t}\n\n\t// copy/snapshot rootfs's\n\tret = copy_storage(c, c2, bdevtype, flags, bdevdata, newsize);\n\tif (ret < 0)\n\t\tgoto out;\n\n\n\t// update utsname\n\tif (!(flags & LXC_CLONE_KEEPNAME)) {\n\t\tclear_unexp_config_line(c2->lxc_conf, \"lxc.utsname\", false);\n\n\t\tif (!set_config_item_locked(c2, \"lxc.utsname\", newname)) {\n\t\t\tERROR(\"Error setting new hostname\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t// copy hooks\n\tret = copyhooks(c, c2);\n\tif (ret < 0) {\n\t\tERROR(\"error copying hooks\");\n\t\tgoto out;\n\t}\n\n\tif (copy_fstab(c, c2) < 0) {\n\t\tERROR(\"error copying fstab\");\n\t\tgoto out;\n\t}\n\n\t// update macaddrs\n\tif (!(flags & LXC_CLONE_KEEPMACADDR)) {\n\t\tif (!network_new_hwaddrs(c2->lxc_conf)) {\n\t\t\tERROR(\"Error updating mac addresses\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t// update absolute paths for overlay mount directories\n\tif (ovl_update_abs_paths(c2->lxc_conf, c->config_path, c->name, lxcpath, newname) < 0)\n\t\tgoto out;\n\n\t// We've now successfully created c2's storage, so clear it out if we\n\t// fail after this\n\tstorage_copied = 1;\n\n\tif (!c2->save_config(c2, NULL))\n\t\tgoto out;\n\n\tif ((pid = fork()) < 0) {\n\t\tSYSERROR(\"fork\");\n\t\tgoto out;\n\t}\n\tif (pid > 0) {\n\t\tret = wait_for_pid(pid);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tcontainer_mem_unlock(c);\n\t\treturn c2;\n\t}\n\tdata.c0 = c;\n\tdata.c1 = c2;\n\tdata.flags = flags;\n\tdata.hookargs = hookargs;\n\tif (am_unpriv())\n\t\tret = userns_exec_1(c->lxc_conf, clone_update_rootfs_wrapper,\n\t\t\t\t&data);\n\telse\n\t\tret = clone_update_rootfs(&data);\n\tif (ret < 0)\n\t\texit(1);\n\n\tcontainer_mem_unlock(c);\n\texit(0);\n\nout:\n\tcontainer_mem_unlock(c);\n\tif (c2) {\n\t\tif (!storage_copied)\n\t\t\tc2->lxc_conf->rootfs.path = NULL;\n\t\tc2->destroy(c2);\n\t\tlxc_container_put(c2);\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"and keep the original container pristine.\""
          ],
          "line": 3410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"please create an aufs or overlayfs clone first, snapshot that\""
          ],
          "line": 3409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Making a copy-clone.  If you do want snapshots, then\""
          ],
          "line": 3408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Snapshot of directory-backed container requested.\""
          ],
          "line": 3407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_is_dir",
          "args": [
            "c->lxc_conf",
            "c->lxc_conf->rootfs.path"
          ],
          "line": 3406
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_is_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "567-577",
          "snippet": "bool bdev_is_dir(struct lxc_conf *conf, const char *path)\n{\n\tstruct bdev *orig = bdev_init(conf, path, NULL, NULL);\n\tbool ret = false;\n\tif (!orig)\n\t\treturn ret;\n\tif (strcmp(orig->type, \"dir\") == 0)\n\t\tret = true;\n\tbdev_put(orig);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bdev *bdev_get(const char *type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic struct bdev *bdev_get(const char *type);\n\nbool bdev_is_dir(struct lxc_conf *conf, const char *path)\n{\n\tstruct bdev *orig = bdev_init(conf, path, NULL, NULL);\n\tbool ret = false;\n\tif (!orig)\n\t\treturn ret;\n\tif (strcmp(orig->type, \"dir\") == 0)\n\t\tret = true;\n\tbdev_put(orig);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "newname",
            "20",
            "\"snap%d\"",
            "i"
          ],
          "line": 3396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to create snapshot directory %s\"",
            "snappath"
          ],
          "line": 3392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir_p",
          "args": [
            "snappath",
            "0755"
          ],
          "line": 3391
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "241-262",
          "snippet": "extern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_next_index",
          "args": [
            "snappath",
            "c->name"
          ],
          "line": 3389
        },
        "resolved": true,
        "details": {
          "function_name": "get_next_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "3328-3342",
          "snippet": "static int get_next_index(const char *lxcpath, char *cname)\n{\n\tchar *fname;\n\tstruct stat sb;\n\tint i = 0, ret;\n\n\tfname = alloca(strlen(lxcpath) + 20);\n\twhile (1) {\n\t\tsprintf(fname, \"%s/snap%d\", lxcpath, i);\n\t\tret = stat(fname, &sb);\n\t\tif (ret != 0)\n\t\t\treturn i;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic int get_next_index(const char *lxcpath, char *cname)\n{\n\tchar *fname;\n\tstruct stat sb;\n\tint i = 0, ret;\n\n\tfname = alloca(strlen(lxcpath) + 20);\n\twhile (1) {\n\t\tsprintf(fname, \"%s/snap%d\", lxcpath, i);\n\t\tret = stat(fname, &sb);\n\t\tif (ret != 0)\n\t\t\treturn i;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_snappath_dir",
          "args": [
            "c",
            "snappath"
          ],
          "line": 3386
        },
        "resolved": true,
        "details": {
          "function_name": "get_snappath_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "3344-3369",
          "snippet": "static bool get_snappath_dir(struct lxc_container *c, char *snappath)\n{\n\tint ret;\n\t/*\n\t * If the old style snapshot path exists, use it\n\t * /var/lib/lxc -> /var/lib/lxcsnaps\n\t */\n\tret = snprintf(snappath, MAXPATHLEN, \"%ssnaps\", c->config_path);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn false;\n\tif (dir_exists(snappath)) {\n\t\tret = snprintf(snappath, MAXPATHLEN, \"%ssnaps/%s\", c->config_path, c->name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/*\n\t * Use the new style path\n\t * /var/lib/lxc -> /var/lib/lxc + c->name + /snaps + \\0\n\t */\n\tret = snprintf(snappath, MAXPATHLEN, \"%s/%s/snaps\", c->config_path, c->name);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool get_snappath_dir(struct lxc_container *c, char *snappath);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool get_snappath_dir(struct lxc_container *c, char *snappath);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool get_snappath_dir(struct lxc_container *c, char *snappath)\n{\n\tint ret;\n\t/*\n\t * If the old style snapshot path exists, use it\n\t * /var/lib/lxc -> /var/lib/lxcsnaps\n\t */\n\tret = snprintf(snappath, MAXPATHLEN, \"%ssnaps\", c->config_path);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn false;\n\tif (dir_exists(snappath)) {\n\t\tret = snprintf(snappath, MAXPATHLEN, \"%ssnaps/%s\", c->config_path, c->name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/*\n\t * Use the new style path\n\t * /var/lib/lxc -> /var/lib/lxc + c->name + /snaps + \\0\n\t */\n\tret = snprintf(snappath, MAXPATHLEN, \"%s/%s/snaps\", c->config_path, c->name);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Your container must use another backing store type.\""
          ],
          "line": 3382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"%s's backing store cannot be backed up.\"",
            "c->name"
          ],
          "line": 3381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_can_backup",
          "args": [
            "c->lxc_conf"
          ],
          "line": 3380
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_can_backup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "279-289",
          "snippet": "bool bdev_can_backup(struct lxc_conf *conf)\n{\n\tstruct bdev *bdev = bdev_init(conf, NULL, NULL, NULL);\n\tbool ret;\n\n\tif (!bdev)\n\t\treturn false;\n\tret = bdev->ops->can_backup;\n\tbdev_put(bdev);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nbool bdev_can_backup(struct lxc_conf *conf)\n{\n\tstruct bdev *bdev = bdev_init(conf, NULL, NULL, NULL);\n\tbool ret;\n\n\tif (!bdev)\n\t\treturn false;\n\tret = bdev->ops->can_backup;\n\tbdev_put(bdev);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxcapi_is_defined",
          "args": [
            "c"
          ],
          "line": 3377
        },
        "resolved": true,
        "details": {
          "function_name": "do_lxcapi_is_defined",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "327-348",
          "snippet": "static bool do_lxcapi_is_defined(struct lxc_container *c)\n{\n\tstruct stat statbuf;\n\tbool ret = false;\n\tint statret;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (container_mem_lock(c))\n\t\treturn false;\n\tif (!c->configfile)\n\t\tgoto out;\n\tstatret = stat(c->configfile, &statbuf);\n\tif (statret != 0)\n\t\tgoto out;\n\tret = true;\n\nout:\n\tcontainer_mem_unlock(c);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_is_defined(struct lxc_container *c)\n{\n\tstruct stat statbuf;\n\tbool ret = false;\n\tint statret;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (container_mem_lock(c))\n\t\treturn false;\n\tif (!c->configfile)\n\t\tgoto out;\n\tstatret = stat(c->configfile, &statbuf);\n\tif (statret != 0)\n\t\tgoto out;\n\tret = true;\n\nout:\n\tcontainer_mem_unlock(c);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool get_snappath_dir(struct lxc_container *c, char *snappath);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic int do_lxcapi_snapshot(struct lxc_container *c, const char *commentfile)\n{\n\tint i, flags, ret;\n\tstruct lxc_container *c2;\n\tchar snappath[MAXPATHLEN], newname[20];\n\n\tif (!c || !lxcapi_is_defined(c))\n\t\treturn -1;\n\n\tif (!bdev_can_backup(c->lxc_conf)) {\n\t\tERROR(\"%s's backing store cannot be backed up.\", c->name);\n\t\tERROR(\"Your container must use another backing store type.\");\n\t\treturn -1;\n\t}\n\n\tif (!get_snappath_dir(c, snappath))\n\t\treturn -1;\n\n\ti = get_next_index(snappath, c->name);\n\n\tif (mkdir_p(snappath, 0755) < 0) {\n\t\tERROR(\"Failed to create snapshot directory %s\", snappath);\n\t\treturn -1;\n\t}\n\n\tret = snprintf(newname, 20, \"snap%d\", i);\n\tif (ret < 0 || ret >= 20)\n\t\treturn -1;\n\n\t/*\n\t * We pass LXC_CLONE_SNAPSHOT to make sure that a rdepends file entry is\n\t * created in the original container\n\t */\n\tflags = LXC_CLONE_SNAPSHOT | LXC_CLONE_KEEPMACADDR | LXC_CLONE_KEEPNAME |\n\t\tLXC_CLONE_KEEPBDEVTYPE | LXC_CLONE_MAYBE_SNAPSHOT;\n\tif (bdev_is_dir(c->lxc_conf, c->lxc_conf->rootfs.path)) {\n\t\tERROR(\"Snapshot of directory-backed container requested.\");\n\t\tERROR(\"Making a copy-clone.  If you do want snapshots, then\");\n\t\tERROR(\"please create an aufs or overlayfs clone first, snapshot that\");\n\t\tERROR(\"and keep the original container pristine.\");\n\t\tflags &= ~LXC_CLONE_SNAPSHOT | LXC_CLONE_MAYBE_SNAPSHOT;\n\t}\n\tc2 = do_lxcapi_clone(c, newname, snappath, flags, NULL, NULL, 0, NULL);\n\tif (!c2) {\n\t\tERROR(\"clone of %s:%s failed\", c->config_path, c->name);\n\t\treturn -1;\n\t}\n\n\tlxc_container_put(c2);\n\n\t// Now write down the creation time\n\ttime_t timer;\n\tchar buffer[25];\n\tstruct tm* tm_info;\n\tFILE *f;\n\n\ttime(&timer);\n\ttm_info = localtime(&timer);\n\n\tstrftime(buffer, 25, \"%Y:%m:%d %H:%M:%S\", tm_info);\n\n\tchar *dfnam = alloca(strlen(snappath) + strlen(newname) + 5);\n\tsprintf(dfnam, \"%s/%s/ts\", snappath, newname);\n\tf = fopen(dfnam, \"w\");\n\tif (!f) {\n\t\tERROR(\"Failed to open %s\", dfnam);\n\t\treturn -1;\n\t}\n\tif (fprintf(f, \"%s\", buffer) < 0) {\n\t\tSYSERROR(\"Writing timestamp\");\n\t\tfclose(f);\n\t\treturn -1;\n\t}\n\tret = fclose(f);\n\tif (ret != 0) {\n\t\tSYSERROR(\"Writing timestamp\");\n\t\treturn -1;\n\t}\n\n\tif (commentfile) {\n\t\t// $p / $name / comment \\0\n\t\tint len = strlen(snappath) + strlen(newname) + 10;\n\t\tchar *path = alloca(len);\n\t\tsprintf(path, \"%s/%s/comment\", snappath, newname);\n\t\treturn copy_file(commentfile, path) < 0 ? -1 : i;\n\t}\n\n\treturn i;\n}"
  },
  {
    "function_name": "get_snappath_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "3344-3369",
    "snippet": "static bool get_snappath_dir(struct lxc_container *c, char *snappath)\n{\n\tint ret;\n\t/*\n\t * If the old style snapshot path exists, use it\n\t * /var/lib/lxc -> /var/lib/lxcsnaps\n\t */\n\tret = snprintf(snappath, MAXPATHLEN, \"%ssnaps\", c->config_path);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn false;\n\tif (dir_exists(snappath)) {\n\t\tret = snprintf(snappath, MAXPATHLEN, \"%ssnaps/%s\", c->config_path, c->name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/*\n\t * Use the new style path\n\t * /var/lib/lxc -> /var/lib/lxc + c->name + /snaps + \\0\n\t */\n\tret = snprintf(snappath, MAXPATHLEN, \"%s/%s/snaps\", c->config_path, c->name);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool get_snappath_dir(struct lxc_container *c, char *snappath);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "snappath",
            "MAXPATHLEN",
            "\"%s/%s/snaps\"",
            "c->config_path",
            "c->name"
          ],
          "line": 3365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "snappath",
            "MAXPATHLEN",
            "\"%ssnaps/%s\"",
            "c->config_path",
            "c->name"
          ],
          "line": 3355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_exists",
          "args": [
            "snappath"
          ],
          "line": 3354
        },
        "resolved": true,
        "details": {
          "function_name": "dir_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1059-1069",
          "snippet": "bool dir_exists(const char *path)\n{\n\tstruct stat sb;\n\tint ret;\n\n\tret = stat(path, &sb);\n\tif (ret < 0)\n\t\t// could be something other than eexist, just say no\n\t\treturn false;\n\treturn S_ISDIR(sb.st_mode);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool btrfs_try_remove_subvol(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nbool dir_exists(const char *path)\n{\n\tstruct stat sb;\n\tint ret;\n\n\tret = stat(path, &sb);\n\tif (ret < 0)\n\t\t// could be something other than eexist, just say no\n\t\treturn false;\n\treturn S_ISDIR(sb.st_mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "snappath",
            "MAXPATHLEN",
            "\"%ssnaps\"",
            "c->config_path"
          ],
          "line": 3351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool get_snappath_dir(struct lxc_container *c, char *snappath);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool get_snappath_dir(struct lxc_container *c, char *snappath)\n{\n\tint ret;\n\t/*\n\t * If the old style snapshot path exists, use it\n\t * /var/lib/lxc -> /var/lib/lxcsnaps\n\t */\n\tret = snprintf(snappath, MAXPATHLEN, \"%ssnaps\", c->config_path);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn false;\n\tif (dir_exists(snappath)) {\n\t\tret = snprintf(snappath, MAXPATHLEN, \"%ssnaps/%s\", c->config_path, c->name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/*\n\t * Use the new style path\n\t * /var/lib/lxc -> /var/lib/lxc + c->name + /snaps + \\0\n\t */\n\tret = snprintf(snappath, MAXPATHLEN, \"%s/%s/snaps\", c->config_path, c->name);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "get_next_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "3328-3342",
    "snippet": "static int get_next_index(const char *lxcpath, char *cname)\n{\n\tchar *fname;\n\tstruct stat sb;\n\tint i = 0, ret;\n\n\tfname = alloca(strlen(lxcpath) + 20);\n\twhile (1) {\n\t\tsprintf(fname, \"%s/snap%d\", lxcpath, i);\n\t\tret = stat(fname, &sb);\n\t\tif (ret != 0)\n\t\t\treturn i;\n\t\ti++;\n\t}\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "fname",
            "&sb"
          ],
          "line": 3337
        },
        "resolved": true,
        "details": {
          "function_name": "freezer_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/freezer.c",
          "lines": "42-51",
          "snippet": "lxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}",
          "includes": [
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"monitor.h\"",
            "#include \"state.h\"",
            "#include \"error.h\"",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxc.h\"\n#include \"log.h\"\n#include \"monitor.h\"\n#include \"state.h\"\n#include \"error.h\"\n#include <sys/param.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nlxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "fname",
            "\"%s/snap%d\"",
            "lxcpath",
            "i"
          ],
          "line": 3336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "strlen(lxcpath) + 20"
          ],
          "line": 3334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "lxcpath"
          ],
          "line": 3334
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic int get_next_index(const char *lxcpath, char *cname)\n{\n\tchar *fname;\n\tstruct stat sb;\n\tint i = 0, ret;\n\n\tfname = alloca(strlen(lxcpath) + 20);\n\twhile (1) {\n\t\tsprintf(fname, \"%s/snap%d\", lxcpath, i);\n\t\tret = stat(fname, &sb);\n\t\tif (ret != 0)\n\t\t\treturn i;\n\t\ti++;\n\t}\n}"
  },
  {
    "function_name": "lxcapi_attach_run_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "3319-3326",
    "snippet": "static int lxcapi_attach_run_wait(struct lxc_container *c, lxc_attach_options_t *options, const char *program, const char * const argv[])\n{\n\tint ret;\n\tcurrent_config = c ? c->lxc_conf : NULL;\n\tret = do_lxcapi_attach_run_wait(c, options, program, argv);\n\tcurrent_config = NULL;\n\treturn ret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_lxcapi_attach_run_wait",
          "args": [
            "c",
            "options",
            "program",
            "argv"
          ],
          "line": 3323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic int lxcapi_attach_run_wait(struct lxc_container *c, lxc_attach_options_t *options, const char *program, const char * const argv[])\n{\n\tint ret;\n\tcurrent_config = c ? c->lxc_conf : NULL;\n\tret = do_lxcapi_attach_run_wait(c, options, program, argv);\n\tcurrent_config = NULL;\n\treturn ret;\n}"
  },
  {
    "function_name": "do_lxcapi_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "3249-3282",
    "snippet": "static bool do_lxcapi_rename(struct lxc_container *c, const char *newname)\n{\n\tstruct bdev *bdev;\n\tstruct lxc_container *newc;\n\n\tif (!c || !c->name || !c->config_path || !c->lxc_conf)\n\t\treturn false;\n\n\tif (has_fs_snapshots(c) || has_snapshots(c)) {\n\t\tERROR(\"Renaming a container with snapshots is not supported\");\n\t\treturn false;\n\t}\n\tbdev = bdev_init(c->lxc_conf, c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);\n\tif (!bdev) {\n\t\tERROR(\"Failed to find original backing store type\");\n\t\treturn false;\n\t}\n\n\tnewc = lxcapi_clone(c, newname, c->config_path, LXC_CLONE_KEEPMACADDR, NULL, bdev->type, 0, NULL);\n\tbdev_put(bdev);\n\tif (!newc) {\n\t\tlxc_container_put(newc);\n\t\treturn false;\n\t}\n\n\tif (newc && lxcapi_is_defined(newc))\n\t\tlxc_container_put(newc);\n\n\tif (!container_destroy(c)) {\n\t\tERROR(\"Could not destroy existing container %s\", c->name);\n\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Could not destroy existing container %s\"",
            "c->name"
          ],
          "line": 3278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_destroy",
          "args": [
            "c"
          ],
          "line": 3277
        },
        "resolved": true,
        "details": {
          "function_name": "container_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2338-2421",
          "snippet": "static bool container_destroy(struct lxc_container *c)\n{\n\tbool bret = false;\n\tint ret = 0;\n\tstruct lxc_conf *conf;\n\n\tif (!c || !do_lxcapi_is_defined(c))\n\t\treturn false;\n\n\tconf = c->lxc_conf;\n\tif (container_disk_lock(c))\n\t\treturn false;\n\n\tif (!is_stopped(c)) {\n\t\t// we should queue some sort of error - in c->error_string?\n\t\tERROR(\"container %s is not stopped\", c->name);\n\t\tgoto out;\n\t}\n\n\tif (conf && !lxc_list_empty(&conf->hooks[LXCHOOK_DESTROY])) {\n\t\t/* Start of environment variable setup for hooks */\n\t\tif (c->name && setenv(\"LXC_NAME\", c->name, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for container name\");\n\t\t}\n\t\tif (conf->rcfile && setenv(\"LXC_CONFIG_FILE\", conf->rcfile, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for config path\");\n\t\t}\n\t\tif (conf->rootfs.mount && setenv(\"LXC_ROOTFS_MOUNT\", conf->rootfs.mount, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for rootfs mount\");\n\t\t}\n\t\tif (conf->rootfs.path && setenv(\"LXC_ROOTFS_PATH\", conf->rootfs.path, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for rootfs mount\");\n\t\t}\n\t\tif (conf->console.path && setenv(\"LXC_CONSOLE\", conf->console.path, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for console path\");\n\t\t}\n\t\tif (conf->console.log_path && setenv(\"LXC_CONSOLE_LOGPATH\", conf->console.log_path, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for console log\");\n\t\t}\n\t\t/* End of environment variable setup for hooks */\n\n\t\tif (run_lxc_hooks(c->name, \"destroy\", conf, c->get_config_path(c), NULL)) {\n\t\t\tERROR(\"Error executing clone hook for %s\", c->name);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (current_config && conf == current_config) {\n\t\tcurrent_config = NULL;\n\t\tif (conf->logfd != -1) {\n\t\t\tclose(conf->logfd);\n\t\t\tconf->logfd = -1;\n\t\t}\n\t}\n\n\tif (conf && conf->rootfs.path && conf->rootfs.mount) {\n\t\tif (!do_destroy_container(conf)) {\n\t\t\tERROR(\"Error destroying rootfs for %s\", c->name);\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Destroyed rootfs for %s\", c->name);\n\t}\n\n\tmod_all_rdeps(c, false);\n\n\tconst char *p1 = do_lxcapi_get_config_path(c);\n\tchar *path = alloca(strlen(p1) + strlen(c->name) + 2);\n\tsprintf(path, \"%s/%s\", p1, c->name);\n\tif (am_unpriv())\n\t\tret = userns_exec_1(conf, lxc_rmdir_onedev_wrapper, path);\n\telse\n\t\tret = lxc_rmdir_onedev(path, \"snaps\");\n\tif (ret < 0) {\n\t\tERROR(\"Error destroying container directory for %s\", c->name);\n\t\tgoto out;\n\t}\n\tINFO(\"Destroyed directory for %s\", c->name);\n\n\tbret = true;\n\nout:\n\tcontainer_disk_unlock(c);\n\treturn bret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool container_destroy(struct lxc_container *c)\n{\n\tbool bret = false;\n\tint ret = 0;\n\tstruct lxc_conf *conf;\n\n\tif (!c || !do_lxcapi_is_defined(c))\n\t\treturn false;\n\n\tconf = c->lxc_conf;\n\tif (container_disk_lock(c))\n\t\treturn false;\n\n\tif (!is_stopped(c)) {\n\t\t// we should queue some sort of error - in c->error_string?\n\t\tERROR(\"container %s is not stopped\", c->name);\n\t\tgoto out;\n\t}\n\n\tif (conf && !lxc_list_empty(&conf->hooks[LXCHOOK_DESTROY])) {\n\t\t/* Start of environment variable setup for hooks */\n\t\tif (c->name && setenv(\"LXC_NAME\", c->name, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for container name\");\n\t\t}\n\t\tif (conf->rcfile && setenv(\"LXC_CONFIG_FILE\", conf->rcfile, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for config path\");\n\t\t}\n\t\tif (conf->rootfs.mount && setenv(\"LXC_ROOTFS_MOUNT\", conf->rootfs.mount, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for rootfs mount\");\n\t\t}\n\t\tif (conf->rootfs.path && setenv(\"LXC_ROOTFS_PATH\", conf->rootfs.path, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for rootfs mount\");\n\t\t}\n\t\tif (conf->console.path && setenv(\"LXC_CONSOLE\", conf->console.path, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for console path\");\n\t\t}\n\t\tif (conf->console.log_path && setenv(\"LXC_CONSOLE_LOGPATH\", conf->console.log_path, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for console log\");\n\t\t}\n\t\t/* End of environment variable setup for hooks */\n\n\t\tif (run_lxc_hooks(c->name, \"destroy\", conf, c->get_config_path(c), NULL)) {\n\t\t\tERROR(\"Error executing clone hook for %s\", c->name);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (current_config && conf == current_config) {\n\t\tcurrent_config = NULL;\n\t\tif (conf->logfd != -1) {\n\t\t\tclose(conf->logfd);\n\t\t\tconf->logfd = -1;\n\t\t}\n\t}\n\n\tif (conf && conf->rootfs.path && conf->rootfs.mount) {\n\t\tif (!do_destroy_container(conf)) {\n\t\t\tERROR(\"Error destroying rootfs for %s\", c->name);\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Destroyed rootfs for %s\", c->name);\n\t}\n\n\tmod_all_rdeps(c, false);\n\n\tconst char *p1 = do_lxcapi_get_config_path(c);\n\tchar *path = alloca(strlen(p1) + strlen(c->name) + 2);\n\tsprintf(path, \"%s/%s\", p1, c->name);\n\tif (am_unpriv())\n\t\tret = userns_exec_1(conf, lxc_rmdir_onedev_wrapper, path);\n\telse\n\t\tret = lxc_rmdir_onedev(path, \"snaps\");\n\tif (ret < 0) {\n\t\tERROR(\"Error destroying container directory for %s\", c->name);\n\t\tgoto out;\n\t}\n\tINFO(\"Destroyed directory for %s\", c->name);\n\n\tbret = true;\n\nout:\n\tcontainer_disk_unlock(c);\n\treturn bret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_container_put",
          "args": [
            "newc"
          ],
          "line": 3275
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "312-325",
          "snippet": "int lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxcapi_is_defined",
          "args": [
            "newc"
          ],
          "line": 3274
        },
        "resolved": true,
        "details": {
          "function_name": "do_lxcapi_is_defined",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "327-348",
          "snippet": "static bool do_lxcapi_is_defined(struct lxc_container *c)\n{\n\tstruct stat statbuf;\n\tbool ret = false;\n\tint statret;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (container_mem_lock(c))\n\t\treturn false;\n\tif (!c->configfile)\n\t\tgoto out;\n\tstatret = stat(c->configfile, &statbuf);\n\tif (statret != 0)\n\t\tgoto out;\n\tret = true;\n\nout:\n\tcontainer_mem_unlock(c);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_is_defined(struct lxc_container *c)\n{\n\tstruct stat statbuf;\n\tbool ret = false;\n\tint statret;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (container_mem_lock(c))\n\t\treturn false;\n\tif (!c->configfile)\n\t\tgoto out;\n\tstatret = stat(c->configfile, &statbuf);\n\tif (statret != 0)\n\t\tgoto out;\n\tret = true;\n\nout:\n\tcontainer_mem_unlock(c);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_put",
          "args": [
            "bdev"
          ],
          "line": 3268
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "579-585",
          "snippet": "void bdev_put(struct bdev *bdev)\n{\n\tfree(bdev->mntopts);\n\tfree(bdev->src);\n\tfree(bdev->dest);\n\tfree(bdev);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);",
            "static char *linkderef(char *path, char *dest);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);\nstatic char *linkderef(char *path, char *dest);\n\nvoid bdev_put(struct bdev *bdev)\n{\n\tfree(bdev->mntopts);\n\tfree(bdev->src);\n\tfree(bdev->dest);\n\tfree(bdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxcapi_clone",
          "args": [
            "c",
            "newname",
            "c->config_path",
            "LXC_CLONE_KEEPMACADDR",
            "NULL",
            "bdev->type",
            "0",
            "NULL"
          ],
          "line": 3267
        },
        "resolved": true,
        "details": {
          "function_name": "lxcapi_clone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "3237-3247",
          "snippet": "static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *newname,\n\t\tconst char *lxcpath, int flags,\n\t\tconst char *bdevtype, const char *bdevdata, uint64_t newsize,\n\t\tchar **hookargs)\n{\n\tstruct lxc_container * ret;\n\tcurrent_config = c ? c->lxc_conf : NULL;\n\tret = do_lxcapi_clone(c, newname, lxcpath, flags, bdevtype, bdevdata, newsize, hookargs);\n\tcurrent_config = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *newname,\n\t\tconst char *lxcpath, int flags,\n\t\tconst char *bdevtype, const char *bdevdata, uint64_t newsize,\n\t\tchar **hookargs)\n{\n\tstruct lxc_container * ret;\n\tcurrent_config = c ? c->lxc_conf : NULL;\n\tret = do_lxcapi_clone(c, newname, lxcpath, flags, bdevtype, bdevdata, newsize, hookargs);\n\tcurrent_config = NULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to find original backing store type\""
          ],
          "line": 3263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_init",
          "args": [
            "c->lxc_conf",
            "c->lxc_conf->rootfs.path",
            "c->lxc_conf->rootfs.mount",
            "NULL"
          ],
          "line": 3261
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "533-565",
          "snippet": "struct bdev *bdev_init(struct lxc_conf *conf, const char *src, const char *dst,\n\t\tconst char *mntopts)\n{\n\tstruct bdev *bdev;\n\tconst struct bdev_type *q;\n\n\tif (!src)\n\t\tsrc = conf->rootfs.path;\n\n\tif (!src)\n\t\treturn NULL;\n\n\tq = bdev_query(conf, src);\n\tif (!q)\n\t\treturn NULL;\n\n\tbdev = malloc(sizeof(struct bdev));\n\tif (!bdev)\n\t\treturn NULL;\n\tmemset(bdev, 0, sizeof(struct bdev));\n\tbdev->ops = q->ops;\n\tbdev->type = q->name;\n\tif (mntopts)\n\t\tbdev->mntopts = strdup(mntopts);\n\tif (src)\n\t\tbdev->src = strdup(src);\n\tif (dst)\n\t\tbdev->dest = strdup(dst);\n\tif (strcmp(bdev->type, \"nbd\") == 0)\n\t\tbdev->nbd_idx = conf->nbd_idx;\n\n\treturn bdev;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);",
            "static struct bdev *bdev_get(const char *type);",
            "static char *linkderef(char *path, char *dest);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);\nstatic struct bdev *bdev_get(const char *type);\nstatic char *linkderef(char *path, char *dest);\n\nstruct bdev *bdev_init(struct lxc_conf *conf, const char *src, const char *dst,\n\t\tconst char *mntopts)\n{\n\tstruct bdev *bdev;\n\tconst struct bdev_type *q;\n\n\tif (!src)\n\t\tsrc = conf->rootfs.path;\n\n\tif (!src)\n\t\treturn NULL;\n\n\tq = bdev_query(conf, src);\n\tif (!q)\n\t\treturn NULL;\n\n\tbdev = malloc(sizeof(struct bdev));\n\tif (!bdev)\n\t\treturn NULL;\n\tmemset(bdev, 0, sizeof(struct bdev));\n\tbdev->ops = q->ops;\n\tbdev->type = q->name;\n\tif (mntopts)\n\t\tbdev->mntopts = strdup(mntopts);\n\tif (src)\n\t\tbdev->src = strdup(src);\n\tif (dst)\n\t\tbdev->dest = strdup(dst);\n\tif (strcmp(bdev->type, \"nbd\") == 0)\n\t\tbdev->nbd_idx = conf->nbd_idx;\n\n\treturn bdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Renaming a container with snapshots is not supported\""
          ],
          "line": 3258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_snapshots",
          "args": [
            "c"
          ],
          "line": 3257
        },
        "resolved": true,
        "details": {
          "function_name": "has_snapshots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2295-2321",
          "snippet": "static bool has_snapshots(struct lxc_container *c)\n{\n\tchar path[MAXPATHLEN];\n\tstruct dirent *direntp;\n\tint count=0;\n\tDIR *dir;\n\n\tif (!get_snappath_dir(c, path))\n\t\treturn false;\n\tdir = opendir(path);\n\tif (!dir)\n\t\treturn false;\n\twhile ((direntp = readdir(dir))) {\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\"))\n\t\t\tcontinue;\n\n\t\tif (!strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tcount++;\n\t\tbreak;\n\t}\n\tclosedir(dir);\n\treturn count > 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool has_snapshots(struct lxc_container *c)\n{\n\tchar path[MAXPATHLEN];\n\tstruct dirent *direntp;\n\tint count=0;\n\tDIR *dir;\n\n\tif (!get_snappath_dir(c, path))\n\t\treturn false;\n\tdir = opendir(path);\n\tif (!dir)\n\t\treturn false;\n\twhile ((direntp = readdir(dir))) {\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\"))\n\t\t\tcontinue;\n\n\t\tif (!strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tcount++;\n\t\tbreak;\n\t}\n\tclosedir(dir);\n\treturn count > 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "has_fs_snapshots",
          "args": [
            "c"
          ],
          "line": 3257
        },
        "resolved": true,
        "details": {
          "function_name": "has_fs_snapshots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2263-2293",
          "snippet": "static bool has_fs_snapshots(struct lxc_container *c)\n{\n\tFILE *f;\n\tchar path[MAXPATHLEN];\n\tint ret, v;\n\tstruct stat fbuf;\n\tbool bret = false;\n\n\tret = snprintf(path, MAXPATHLEN, \"%s/%s/lxc_snapshots\", c->config_path,\n\t\t\tc->name);\n\tif (ret < 0 || ret > MAXPATHLEN)\n\t\tgoto out;\n\t/* If the file doesn't exist there are no snapshots. */\n\tif (stat(path, &fbuf) < 0)\n\t\tgoto out;\n\tv = fbuf.st_size;\n\tif (v != 0) {\n\t\tf = fopen(path, \"r\");\n\t\tif (!f)\n\t\t\tgoto out;\n\t\tret = fscanf(f, \"%d\", &v);\n\t\tfclose(f);\n\t\t// TODO: Figure out what to do with the return value of fscanf.\n\t\tif (ret != 1)\n\t\t\tINFO(\"Container uses new lxc-snapshots format %s\", path);\n\t}\n\tbret = v != 0;\n\nout:\n\treturn bret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool do_lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool do_lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool has_fs_snapshots(struct lxc_container *c)\n{\n\tFILE *f;\n\tchar path[MAXPATHLEN];\n\tint ret, v;\n\tstruct stat fbuf;\n\tbool bret = false;\n\n\tret = snprintf(path, MAXPATHLEN, \"%s/%s/lxc_snapshots\", c->config_path,\n\t\t\tc->name);\n\tif (ret < 0 || ret > MAXPATHLEN)\n\t\tgoto out;\n\t/* If the file doesn't exist there are no snapshots. */\n\tif (stat(path, &fbuf) < 0)\n\t\tgoto out;\n\tv = fbuf.st_size;\n\tif (v != 0) {\n\t\tf = fopen(path, \"r\");\n\t\tif (!f)\n\t\t\tgoto out;\n\t\tret = fscanf(f, \"%d\", &v);\n\t\tfclose(f);\n\t\t// TODO: Figure out what to do with the return value of fscanf.\n\t\tif (ret != 1)\n\t\t\tINFO(\"Container uses new lxc-snapshots format %s\", path);\n\t}\n\tbret = v != 0;\n\nout:\n\treturn bret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_rename(struct lxc_container *c, const char *newname)\n{\n\tstruct bdev *bdev;\n\tstruct lxc_container *newc;\n\n\tif (!c || !c->name || !c->config_path || !c->lxc_conf)\n\t\treturn false;\n\n\tif (has_fs_snapshots(c) || has_snapshots(c)) {\n\t\tERROR(\"Renaming a container with snapshots is not supported\");\n\t\treturn false;\n\t}\n\tbdev = bdev_init(c->lxc_conf, c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);\n\tif (!bdev) {\n\t\tERROR(\"Failed to find original backing store type\");\n\t\treturn false;\n\t}\n\n\tnewc = lxcapi_clone(c, newname, c->config_path, LXC_CLONE_KEEPMACADDR, NULL, bdev->type, 0, NULL);\n\tbdev_put(bdev);\n\tif (!newc) {\n\t\tlxc_container_put(newc);\n\t\treturn false;\n\t}\n\n\tif (newc && lxcapi_is_defined(newc))\n\t\tlxc_container_put(newc);\n\n\tif (!container_destroy(c)) {\n\t\tERROR(\"Could not destroy existing container %s\", c->name);\n\t\treturn false;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "lxcapi_clone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "3237-3247",
    "snippet": "static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *newname,\n\t\tconst char *lxcpath, int flags,\n\t\tconst char *bdevtype, const char *bdevdata, uint64_t newsize,\n\t\tchar **hookargs)\n{\n\tstruct lxc_container * ret;\n\tcurrent_config = c ? c->lxc_conf : NULL;\n\tret = do_lxcapi_clone(c, newname, lxcpath, flags, bdevtype, bdevdata, newsize, hookargs);\n\tcurrent_config = NULL;\n\treturn ret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_lxcapi_clone",
          "args": [
            "c",
            "newname",
            "lxcpath",
            "flags",
            "bdevtype",
            "bdevdata",
            "newsize",
            "hookargs"
          ],
          "line": 3244
        },
        "resolved": true,
        "details": {
          "function_name": "do_lxcapi_clone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "3058-3235",
          "snippet": "static struct lxc_container *do_lxcapi_clone(struct lxc_container *c, const char *newname,\n\t\tconst char *lxcpath, int flags,\n\t\tconst char *bdevtype, const char *bdevdata, uint64_t newsize,\n\t\tchar **hookargs)\n{\n\tstruct lxc_container *c2 = NULL;\n\tchar newpath[MAXPATHLEN];\n\tint ret, storage_copied = 0;\n\tchar *origroot = NULL, *saved_unexp_conf = NULL;\n\tstruct clone_update_data data;\n\tsize_t saved_unexp_len;\n\tFILE *fout;\n\tpid_t pid;\n\n\tif (!c || !do_lxcapi_is_defined(c))\n\t\treturn NULL;\n\n\tif (container_mem_lock(c))\n\t\treturn NULL;\n\n\tif (!is_stopped(c)) {\n\t\tERROR(\"error: Original container (%s) is running\", c->name);\n\t\tgoto out;\n\t}\n\n\t// Make sure the container doesn't yet exist.\n\tif (!newname)\n\t\tnewname = c->name;\n\tif (!lxcpath)\n\t\tlxcpath = do_lxcapi_get_config_path(c);\n\tret = snprintf(newpath, MAXPATHLEN, \"%s/%s/config\", lxcpath, newname);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"clone: failed making config pathname\");\n\t\tgoto out;\n\t}\n\tif (file_exists(newpath)) {\n\t\tERROR(\"error: clone: %s exists\", newpath);\n\t\tgoto out;\n\t}\n\n\tret = create_file_dirname(newpath, c->lxc_conf);\n\tif (ret < 0 && errno != EEXIST) {\n\t\tERROR(\"Error creating container dir for %s\", newpath);\n\t\tgoto out;\n\t}\n\n\t// copy the configuration, tweak it as needed,\n\tif (c->lxc_conf->rootfs.path) {\n\t\torigroot = c->lxc_conf->rootfs.path;\n\t\tc->lxc_conf->rootfs.path = NULL;\n\t}\n\tfout = fopen(newpath, \"w\");\n\tif (!fout) {\n\t\tSYSERROR(\"open %s\", newpath);\n\t\tgoto out;\n\t}\n\n\tsaved_unexp_conf = c->lxc_conf->unexpanded_config;\n\tsaved_unexp_len = c->lxc_conf->unexpanded_len;\n\tc->lxc_conf->unexpanded_config = strdup(saved_unexp_conf);\n\tif (!c->lxc_conf->unexpanded_config) {\n\t\tERROR(\"Out of memory\");\n\t\tfclose(fout);\n\t\tgoto out;\n\t}\n\tclear_unexp_config_line(c->lxc_conf, \"lxc.rootfs\", false);\n\twrite_config(fout, c->lxc_conf);\n\tfclose(fout);\n\tc->lxc_conf->rootfs.path = origroot;\n\tfree(c->lxc_conf->unexpanded_config);\n\tc->lxc_conf->unexpanded_config = saved_unexp_conf;\n\tsaved_unexp_conf = NULL;\n\tc->lxc_conf->unexpanded_len = saved_unexp_len;\n\n\tsprintf(newpath, \"%s/%s/rootfs\", lxcpath, newname);\n\tif (mkdir(newpath, 0755) < 0) {\n\t\tSYSERROR(\"error creating %s\", newpath);\n\t\tgoto out;\n\t}\n\n\tif (am_unpriv()) {\n\t\tif (chown_mapped_root(newpath, c->lxc_conf) < 0) {\n\t\t\tERROR(\"Error chowning %s to container root\", newpath);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tc2 = lxc_container_new(newname, lxcpath);\n\tif (!c2) {\n\t\tERROR(\"clone: failed to create new container (%s %s)\", newname,\n\t\t\t\tlxcpath);\n\t\tgoto out;\n\t}\n\n\t// copy/snapshot rootfs's\n\tret = copy_storage(c, c2, bdevtype, flags, bdevdata, newsize);\n\tif (ret < 0)\n\t\tgoto out;\n\n\n\t// update utsname\n\tif (!(flags & LXC_CLONE_KEEPNAME)) {\n\t\tclear_unexp_config_line(c2->lxc_conf, \"lxc.utsname\", false);\n\n\t\tif (!set_config_item_locked(c2, \"lxc.utsname\", newname)) {\n\t\t\tERROR(\"Error setting new hostname\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t// copy hooks\n\tret = copyhooks(c, c2);\n\tif (ret < 0) {\n\t\tERROR(\"error copying hooks\");\n\t\tgoto out;\n\t}\n\n\tif (copy_fstab(c, c2) < 0) {\n\t\tERROR(\"error copying fstab\");\n\t\tgoto out;\n\t}\n\n\t// update macaddrs\n\tif (!(flags & LXC_CLONE_KEEPMACADDR)) {\n\t\tif (!network_new_hwaddrs(c2->lxc_conf)) {\n\t\t\tERROR(\"Error updating mac addresses\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t// update absolute paths for overlay mount directories\n\tif (ovl_update_abs_paths(c2->lxc_conf, c->config_path, c->name, lxcpath, newname) < 0)\n\t\tgoto out;\n\n\t// We've now successfully created c2's storage, so clear it out if we\n\t// fail after this\n\tstorage_copied = 1;\n\n\tif (!c2->save_config(c2, NULL))\n\t\tgoto out;\n\n\tif ((pid = fork()) < 0) {\n\t\tSYSERROR(\"fork\");\n\t\tgoto out;\n\t}\n\tif (pid > 0) {\n\t\tret = wait_for_pid(pid);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tcontainer_mem_unlock(c);\n\t\treturn c2;\n\t}\n\tdata.c0 = c;\n\tdata.c1 = c2;\n\tdata.flags = flags;\n\tdata.hookargs = hookargs;\n\tif (am_unpriv())\n\t\tret = userns_exec_1(c->lxc_conf, clone_update_rootfs_wrapper,\n\t\t\t\t&data);\n\telse\n\t\tret = clone_update_rootfs(&data);\n\tif (ret < 0)\n\t\texit(1);\n\n\tcontainer_mem_unlock(c);\n\texit(0);\n\nout:\n\tcontainer_mem_unlock(c);\n\tif (c2) {\n\t\tif (!storage_copied)\n\t\t\tc2->lxc_conf->rootfs.path = NULL;\n\t\tc2->destroy(c2);\n\t\tlxc_container_put(c2);\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic struct lxc_container *do_lxcapi_clone(struct lxc_container *c, const char *newname,\n\t\tconst char *lxcpath, int flags,\n\t\tconst char *bdevtype, const char *bdevdata, uint64_t newsize,\n\t\tchar **hookargs)\n{\n\tstruct lxc_container *c2 = NULL;\n\tchar newpath[MAXPATHLEN];\n\tint ret, storage_copied = 0;\n\tchar *origroot = NULL, *saved_unexp_conf = NULL;\n\tstruct clone_update_data data;\n\tsize_t saved_unexp_len;\n\tFILE *fout;\n\tpid_t pid;\n\n\tif (!c || !do_lxcapi_is_defined(c))\n\t\treturn NULL;\n\n\tif (container_mem_lock(c))\n\t\treturn NULL;\n\n\tif (!is_stopped(c)) {\n\t\tERROR(\"error: Original container (%s) is running\", c->name);\n\t\tgoto out;\n\t}\n\n\t// Make sure the container doesn't yet exist.\n\tif (!newname)\n\t\tnewname = c->name;\n\tif (!lxcpath)\n\t\tlxcpath = do_lxcapi_get_config_path(c);\n\tret = snprintf(newpath, MAXPATHLEN, \"%s/%s/config\", lxcpath, newname);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"clone: failed making config pathname\");\n\t\tgoto out;\n\t}\n\tif (file_exists(newpath)) {\n\t\tERROR(\"error: clone: %s exists\", newpath);\n\t\tgoto out;\n\t}\n\n\tret = create_file_dirname(newpath, c->lxc_conf);\n\tif (ret < 0 && errno != EEXIST) {\n\t\tERROR(\"Error creating container dir for %s\", newpath);\n\t\tgoto out;\n\t}\n\n\t// copy the configuration, tweak it as needed,\n\tif (c->lxc_conf->rootfs.path) {\n\t\torigroot = c->lxc_conf->rootfs.path;\n\t\tc->lxc_conf->rootfs.path = NULL;\n\t}\n\tfout = fopen(newpath, \"w\");\n\tif (!fout) {\n\t\tSYSERROR(\"open %s\", newpath);\n\t\tgoto out;\n\t}\n\n\tsaved_unexp_conf = c->lxc_conf->unexpanded_config;\n\tsaved_unexp_len = c->lxc_conf->unexpanded_len;\n\tc->lxc_conf->unexpanded_config = strdup(saved_unexp_conf);\n\tif (!c->lxc_conf->unexpanded_config) {\n\t\tERROR(\"Out of memory\");\n\t\tfclose(fout);\n\t\tgoto out;\n\t}\n\tclear_unexp_config_line(c->lxc_conf, \"lxc.rootfs\", false);\n\twrite_config(fout, c->lxc_conf);\n\tfclose(fout);\n\tc->lxc_conf->rootfs.path = origroot;\n\tfree(c->lxc_conf->unexpanded_config);\n\tc->lxc_conf->unexpanded_config = saved_unexp_conf;\n\tsaved_unexp_conf = NULL;\n\tc->lxc_conf->unexpanded_len = saved_unexp_len;\n\n\tsprintf(newpath, \"%s/%s/rootfs\", lxcpath, newname);\n\tif (mkdir(newpath, 0755) < 0) {\n\t\tSYSERROR(\"error creating %s\", newpath);\n\t\tgoto out;\n\t}\n\n\tif (am_unpriv()) {\n\t\tif (chown_mapped_root(newpath, c->lxc_conf) < 0) {\n\t\t\tERROR(\"Error chowning %s to container root\", newpath);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tc2 = lxc_container_new(newname, lxcpath);\n\tif (!c2) {\n\t\tERROR(\"clone: failed to create new container (%s %s)\", newname,\n\t\t\t\tlxcpath);\n\t\tgoto out;\n\t}\n\n\t// copy/snapshot rootfs's\n\tret = copy_storage(c, c2, bdevtype, flags, bdevdata, newsize);\n\tif (ret < 0)\n\t\tgoto out;\n\n\n\t// update utsname\n\tif (!(flags & LXC_CLONE_KEEPNAME)) {\n\t\tclear_unexp_config_line(c2->lxc_conf, \"lxc.utsname\", false);\n\n\t\tif (!set_config_item_locked(c2, \"lxc.utsname\", newname)) {\n\t\t\tERROR(\"Error setting new hostname\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t// copy hooks\n\tret = copyhooks(c, c2);\n\tif (ret < 0) {\n\t\tERROR(\"error copying hooks\");\n\t\tgoto out;\n\t}\n\n\tif (copy_fstab(c, c2) < 0) {\n\t\tERROR(\"error copying fstab\");\n\t\tgoto out;\n\t}\n\n\t// update macaddrs\n\tif (!(flags & LXC_CLONE_KEEPMACADDR)) {\n\t\tif (!network_new_hwaddrs(c2->lxc_conf)) {\n\t\t\tERROR(\"Error updating mac addresses\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t// update absolute paths for overlay mount directories\n\tif (ovl_update_abs_paths(c2->lxc_conf, c->config_path, c->name, lxcpath, newname) < 0)\n\t\tgoto out;\n\n\t// We've now successfully created c2's storage, so clear it out if we\n\t// fail after this\n\tstorage_copied = 1;\n\n\tif (!c2->save_config(c2, NULL))\n\t\tgoto out;\n\n\tif ((pid = fork()) < 0) {\n\t\tSYSERROR(\"fork\");\n\t\tgoto out;\n\t}\n\tif (pid > 0) {\n\t\tret = wait_for_pid(pid);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tcontainer_mem_unlock(c);\n\t\treturn c2;\n\t}\n\tdata.c0 = c;\n\tdata.c1 = c2;\n\tdata.flags = flags;\n\tdata.hookargs = hookargs;\n\tif (am_unpriv())\n\t\tret = userns_exec_1(c->lxc_conf, clone_update_rootfs_wrapper,\n\t\t\t\t&data);\n\telse\n\t\tret = clone_update_rootfs(&data);\n\tif (ret < 0)\n\t\texit(1);\n\n\tcontainer_mem_unlock(c);\n\texit(0);\n\nout:\n\tcontainer_mem_unlock(c);\n\tif (c2) {\n\t\tif (!storage_copied)\n\t\t\tc2->lxc_conf->rootfs.path = NULL;\n\t\tc2->destroy(c2);\n\t\tlxc_container_put(c2);\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *newname,\n\t\tconst char *lxcpath, int flags,\n\t\tconst char *bdevtype, const char *bdevdata, uint64_t newsize,\n\t\tchar **hookargs)\n{\n\tstruct lxc_container * ret;\n\tcurrent_config = c ? c->lxc_conf : NULL;\n\tret = do_lxcapi_clone(c, newname, lxcpath, flags, bdevtype, bdevdata, newsize, hookargs);\n\tcurrent_config = NULL;\n\treturn ret;\n}"
  },
  {
    "function_name": "do_lxcapi_clone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "3058-3235",
    "snippet": "static struct lxc_container *do_lxcapi_clone(struct lxc_container *c, const char *newname,\n\t\tconst char *lxcpath, int flags,\n\t\tconst char *bdevtype, const char *bdevdata, uint64_t newsize,\n\t\tchar **hookargs)\n{\n\tstruct lxc_container *c2 = NULL;\n\tchar newpath[MAXPATHLEN];\n\tint ret, storage_copied = 0;\n\tchar *origroot = NULL, *saved_unexp_conf = NULL;\n\tstruct clone_update_data data;\n\tsize_t saved_unexp_len;\n\tFILE *fout;\n\tpid_t pid;\n\n\tif (!c || !do_lxcapi_is_defined(c))\n\t\treturn NULL;\n\n\tif (container_mem_lock(c))\n\t\treturn NULL;\n\n\tif (!is_stopped(c)) {\n\t\tERROR(\"error: Original container (%s) is running\", c->name);\n\t\tgoto out;\n\t}\n\n\t// Make sure the container doesn't yet exist.\n\tif (!newname)\n\t\tnewname = c->name;\n\tif (!lxcpath)\n\t\tlxcpath = do_lxcapi_get_config_path(c);\n\tret = snprintf(newpath, MAXPATHLEN, \"%s/%s/config\", lxcpath, newname);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"clone: failed making config pathname\");\n\t\tgoto out;\n\t}\n\tif (file_exists(newpath)) {\n\t\tERROR(\"error: clone: %s exists\", newpath);\n\t\tgoto out;\n\t}\n\n\tret = create_file_dirname(newpath, c->lxc_conf);\n\tif (ret < 0 && errno != EEXIST) {\n\t\tERROR(\"Error creating container dir for %s\", newpath);\n\t\tgoto out;\n\t}\n\n\t// copy the configuration, tweak it as needed,\n\tif (c->lxc_conf->rootfs.path) {\n\t\torigroot = c->lxc_conf->rootfs.path;\n\t\tc->lxc_conf->rootfs.path = NULL;\n\t}\n\tfout = fopen(newpath, \"w\");\n\tif (!fout) {\n\t\tSYSERROR(\"open %s\", newpath);\n\t\tgoto out;\n\t}\n\n\tsaved_unexp_conf = c->lxc_conf->unexpanded_config;\n\tsaved_unexp_len = c->lxc_conf->unexpanded_len;\n\tc->lxc_conf->unexpanded_config = strdup(saved_unexp_conf);\n\tif (!c->lxc_conf->unexpanded_config) {\n\t\tERROR(\"Out of memory\");\n\t\tfclose(fout);\n\t\tgoto out;\n\t}\n\tclear_unexp_config_line(c->lxc_conf, \"lxc.rootfs\", false);\n\twrite_config(fout, c->lxc_conf);\n\tfclose(fout);\n\tc->lxc_conf->rootfs.path = origroot;\n\tfree(c->lxc_conf->unexpanded_config);\n\tc->lxc_conf->unexpanded_config = saved_unexp_conf;\n\tsaved_unexp_conf = NULL;\n\tc->lxc_conf->unexpanded_len = saved_unexp_len;\n\n\tsprintf(newpath, \"%s/%s/rootfs\", lxcpath, newname);\n\tif (mkdir(newpath, 0755) < 0) {\n\t\tSYSERROR(\"error creating %s\", newpath);\n\t\tgoto out;\n\t}\n\n\tif (am_unpriv()) {\n\t\tif (chown_mapped_root(newpath, c->lxc_conf) < 0) {\n\t\t\tERROR(\"Error chowning %s to container root\", newpath);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tc2 = lxc_container_new(newname, lxcpath);\n\tif (!c2) {\n\t\tERROR(\"clone: failed to create new container (%s %s)\", newname,\n\t\t\t\tlxcpath);\n\t\tgoto out;\n\t}\n\n\t// copy/snapshot rootfs's\n\tret = copy_storage(c, c2, bdevtype, flags, bdevdata, newsize);\n\tif (ret < 0)\n\t\tgoto out;\n\n\n\t// update utsname\n\tif (!(flags & LXC_CLONE_KEEPNAME)) {\n\t\tclear_unexp_config_line(c2->lxc_conf, \"lxc.utsname\", false);\n\n\t\tif (!set_config_item_locked(c2, \"lxc.utsname\", newname)) {\n\t\t\tERROR(\"Error setting new hostname\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t// copy hooks\n\tret = copyhooks(c, c2);\n\tif (ret < 0) {\n\t\tERROR(\"error copying hooks\");\n\t\tgoto out;\n\t}\n\n\tif (copy_fstab(c, c2) < 0) {\n\t\tERROR(\"error copying fstab\");\n\t\tgoto out;\n\t}\n\n\t// update macaddrs\n\tif (!(flags & LXC_CLONE_KEEPMACADDR)) {\n\t\tif (!network_new_hwaddrs(c2->lxc_conf)) {\n\t\t\tERROR(\"Error updating mac addresses\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t// update absolute paths for overlay mount directories\n\tif (ovl_update_abs_paths(c2->lxc_conf, c->config_path, c->name, lxcpath, newname) < 0)\n\t\tgoto out;\n\n\t// We've now successfully created c2's storage, so clear it out if we\n\t// fail after this\n\tstorage_copied = 1;\n\n\tif (!c2->save_config(c2, NULL))\n\t\tgoto out;\n\n\tif ((pid = fork()) < 0) {\n\t\tSYSERROR(\"fork\");\n\t\tgoto out;\n\t}\n\tif (pid > 0) {\n\t\tret = wait_for_pid(pid);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tcontainer_mem_unlock(c);\n\t\treturn c2;\n\t}\n\tdata.c0 = c;\n\tdata.c1 = c2;\n\tdata.flags = flags;\n\tdata.hookargs = hookargs;\n\tif (am_unpriv())\n\t\tret = userns_exec_1(c->lxc_conf, clone_update_rootfs_wrapper,\n\t\t\t\t&data);\n\telse\n\t\tret = clone_update_rootfs(&data);\n\tif (ret < 0)\n\t\texit(1);\n\n\tcontainer_mem_unlock(c);\n\texit(0);\n\nout:\n\tcontainer_mem_unlock(c);\n\tif (c2) {\n\t\tif (!storage_copied)\n\t\t\tc2->lxc_conf->rootfs.path = NULL;\n\t\tc2->destroy(c2);\n\t\tlxc_container_put(c2);\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_container_put",
          "args": [
            "c2"
          ],
          "line": 3231
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "312-325",
          "snippet": "int lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "c2->destroy",
          "args": [
            "c2"
          ],
          "line": 3230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_mem_unlock",
          "args": [
            "c"
          ],
          "line": 3226
        },
        "resolved": true,
        "details": {
          "function_name": "container_mem_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "347-350",
          "snippet": "void container_mem_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->privlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nvoid container_mem_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->privlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 3223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 3220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clone_update_rootfs",
          "args": [
            "&data"
          ],
          "line": 3218
        },
        "resolved": true,
        "details": {
          "function_name": "clone_update_rootfs_wrapper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "3027-3031",
          "snippet": "static int clone_update_rootfs_wrapper(void *data)\n{\n\tstruct clone_update_data *arg = (struct clone_update_data *) data;\n\treturn clone_update_rootfs(arg);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic int clone_update_rootfs_wrapper(void *data)\n{\n\tstruct clone_update_data *arg = (struct clone_update_data *) data;\n\treturn clone_update_rootfs(arg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "userns_exec_1",
          "args": [
            "c->lxc_conf",
            "clone_update_rootfs_wrapper",
            "&data"
          ],
          "line": 3215
        },
        "resolved": true,
        "details": {
          "function_name": "userns_exec_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4435-4487",
          "snippet": "int userns_exec_1(struct lxc_conf *conf, int (*fn)(void *), void *data)\n{\n\tint ret, pid;\n\tstruct userns_fn_data d;\n\tchar c = '1';\n\tint p[2];\n\tstruct lxc_list *idmap;\n\n\tret = pipe(p);\n\tif (ret < 0) {\n\t\tSYSERROR(\"opening pipe\");\n\t\treturn -1;\n\t}\n\td.fn = fn;\n\td.arg = data;\n\td.p[0] = p[0];\n\td.p[1] = p[1];\n\tpid = lxc_clone(run_userns_fn, &d, CLONE_NEWUSER);\n\tif (pid < 0)\n\t\tgoto err;\n\tclose(p[0]);\n\tp[0] = -1;\n\n\tif ((idmap = idmap_add_id(conf, geteuid(), getegid())) == NULL) {\n\t\tERROR(\"Error adding self to container uid/gid map\");\n\t\tgoto err;\n\t}\n\n\tret = lxc_map_ids(idmap, pid);\n\tlxc_free_idmap(idmap);\n\tfree(idmap);\n\tif (ret) {\n\t\tERROR(\"Error setting up child mappings\");\n\t\tgoto err;\n\t}\n\n\t// kick the child\n\tif (write(p[1], &c, 1) != 1) {\n\t\tSYSERROR(\"writing to pipe to child\");\n\t\tgoto err;\n\t}\n\n\tret = wait_for_pid(pid);\n\n\tclose(p[1]);\n\treturn ret;\n\nerr:\n\tif (p[0] != -1)\n\t\tclose(p[0]);\n\tclose(p[1]);\n\treturn -1;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint userns_exec_1(struct lxc_conf *conf, int (*fn)(void *), void *data)\n{\n\tint ret, pid;\n\tstruct userns_fn_data d;\n\tchar c = '1';\n\tint p[2];\n\tstruct lxc_list *idmap;\n\n\tret = pipe(p);\n\tif (ret < 0) {\n\t\tSYSERROR(\"opening pipe\");\n\t\treturn -1;\n\t}\n\td.fn = fn;\n\td.arg = data;\n\td.p[0] = p[0];\n\td.p[1] = p[1];\n\tpid = lxc_clone(run_userns_fn, &d, CLONE_NEWUSER);\n\tif (pid < 0)\n\t\tgoto err;\n\tclose(p[0]);\n\tp[0] = -1;\n\n\tif ((idmap = idmap_add_id(conf, geteuid(), getegid())) == NULL) {\n\t\tERROR(\"Error adding self to container uid/gid map\");\n\t\tgoto err;\n\t}\n\n\tret = lxc_map_ids(idmap, pid);\n\tlxc_free_idmap(idmap);\n\tfree(idmap);\n\tif (ret) {\n\t\tERROR(\"Error setting up child mappings\");\n\t\tgoto err;\n\t}\n\n\t// kick the child\n\tif (write(p[1], &c, 1) != 1) {\n\t\tSYSERROR(\"writing to pipe to child\");\n\t\tgoto err;\n\t}\n\n\tret = wait_for_pid(pid);\n\n\tclose(p[1]);\n\treturn ret;\n\nerr:\n\tif (p[0] != -1)\n\t\tclose(p[0]);\n\tclose(p[1]);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "am_unpriv",
          "args": [],
          "line": 3214
        },
        "resolved": true,
        "details": {
          "function_name": "am_unpriv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.h",
          "lines": "288-290",
          "snippet": "inline static bool am_unpriv(void) {\n\treturn geteuid() != 0;\n}",
          "includes": [
            "#include <stdint.h>",
            "#  include <sys/signalfd.h>",
            "#include <../include/getline.h>",
            "#include \"initutils.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#  include <sys/signalfd.h>\n#include <../include/getline.h>\n#include \"initutils.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"config.h\"\n\ninline static bool am_unpriv(void) {\n\treturn geteuid() != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_pid",
          "args": [
            "pid"
          ],
          "line": 3204
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "311-325",
          "snippet": "int lxc_wait_for_pid_status(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\treturn status;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_wait_for_pid_status(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"fork\""
          ],
          "line": 3200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 3199
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "c2->save_config",
          "args": [
            "c2",
            "NULL"
          ],
          "line": 3196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_update_abs_paths",
          "args": [
            "c2->lxc_conf",
            "c->config_path",
            "c->name",
            "lxcpath",
            "newname"
          ],
          "line": 3189
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_update_abs_paths",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcoverlay.c",
          "lines": "572-662",
          "snippet": "int ovl_update_abs_paths(struct lxc_conf *lxc_conf, const char *lxc_path,\n\t\t\t const char *lxc_name, const char *newpath,\n\t\t\t const char *newname)\n{\n\tchar new_upper[MAXPATHLEN];\n\tchar new_work[MAXPATHLEN];\n\tchar old_upper[MAXPATHLEN];\n\tchar old_work[MAXPATHLEN];\n\tchar *cleanpath = NULL;\n\tsize_t i;\n\tint fret = -1;\n\tint ret = 0;\n\tstruct lxc_list *iterator;\n\tconst char *ovl_dirs[] = {\"br\", \"upperdir\", \"workdir\"};\n\n\tcleanpath = strdup(newpath);\n\tif (!cleanpath)\n\t\tgoto err;\n\n\tremove_trailing_slashes(cleanpath);\n\n\t/*\n\t * We have to update lxc_conf->unexpanded_config separately from\n\t * lxc_conf->mount_list.\n\t */\n\tfor (i = 0; i < sizeof(ovl_dirs) / sizeof(ovl_dirs[0]); i++) {\n\t\tif (!clone_update_unexp_ovl_paths(lxc_conf, lxc_path, newpath,\n\t\t\t\t\t\t  lxc_name, newname,\n\t\t\t\t\t\t  ovl_dirs[i]))\n\t\t\tgoto err;\n\t}\n\n\tret = snprintf(old_work, MAXPATHLEN, \"workdir=%s/%s\", lxc_path, lxc_name);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\tgoto err;\n\n\tret = snprintf(new_work, MAXPATHLEN, \"workdir=%s/%s\", cleanpath, newname);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\tgoto err;\n\n\tlxc_list_for_each(iterator, &lxc_conf->mount_list) {\n\t\tchar *mnt_entry = NULL;\n\t\tchar *new_mnt_entry = NULL;\n\t\tchar *tmp = NULL;\n\t\tchar *tmp_mnt_entry = NULL;\n\t\tmnt_entry = iterator->elem;\n\n\t\tif (strstr(mnt_entry, \"overlay\"))\n\t\t\ttmp = \"upperdir\";\n\t\telse if (strstr(mnt_entry, \"aufs\"))\n\t\t\ttmp = \"br\";\n\n\t\tif (!tmp)\n\t\t\tcontinue;\n\n\t\tret = snprintf(old_upper, MAXPATHLEN, \"%s=%s/%s\", tmp, lxc_path, lxc_name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\tgoto err;\n\n\t\tret = snprintf(new_upper, MAXPATHLEN, \"%s=%s/%s\", tmp, cleanpath, newname);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\tgoto err;\n\n\t\tif (strstr(mnt_entry, old_upper)) {\n\t\t\ttmp_mnt_entry = lxc_string_replace(old_upper, new_upper, mnt_entry);\n\t\t}\n\n\t\tif (strstr(mnt_entry, old_work)) {\n\t\t\tif (tmp_mnt_entry)\n\t\t\t\tnew_mnt_entry = lxc_string_replace(old_work, new_work, tmp_mnt_entry);\n\t\t\telse\n\t\t\t\tnew_mnt_entry = lxc_string_replace(old_work, new_work, mnt_entry);\n\t\t}\n\n\t\tif (new_mnt_entry) {\n\t\t\tfree(iterator->elem);\n\t\t\titerator->elem = strdup(new_mnt_entry);\n\t\t} else if (tmp_mnt_entry) {\n\t\t\tfree(iterator->elem);\n\t\t\titerator->elem = strdup(tmp_mnt_entry);\n\t\t}\n\n\t\tfree(new_mnt_entry);\n\t\tfree(tmp_mnt_entry);\n\t}\n\n\tfret = 0;\nerr:\n\tfree(cleanpath);\n\treturn fret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcoverlay.h\"\n#include \"lxccontainer.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nint ovl_update_abs_paths(struct lxc_conf *lxc_conf, const char *lxc_path,\n\t\t\t const char *lxc_name, const char *newpath,\n\t\t\t const char *newname)\n{\n\tchar new_upper[MAXPATHLEN];\n\tchar new_work[MAXPATHLEN];\n\tchar old_upper[MAXPATHLEN];\n\tchar old_work[MAXPATHLEN];\n\tchar *cleanpath = NULL;\n\tsize_t i;\n\tint fret = -1;\n\tint ret = 0;\n\tstruct lxc_list *iterator;\n\tconst char *ovl_dirs[] = {\"br\", \"upperdir\", \"workdir\"};\n\n\tcleanpath = strdup(newpath);\n\tif (!cleanpath)\n\t\tgoto err;\n\n\tremove_trailing_slashes(cleanpath);\n\n\t/*\n\t * We have to update lxc_conf->unexpanded_config separately from\n\t * lxc_conf->mount_list.\n\t */\n\tfor (i = 0; i < sizeof(ovl_dirs) / sizeof(ovl_dirs[0]); i++) {\n\t\tif (!clone_update_unexp_ovl_paths(lxc_conf, lxc_path, newpath,\n\t\t\t\t\t\t  lxc_name, newname,\n\t\t\t\t\t\t  ovl_dirs[i]))\n\t\t\tgoto err;\n\t}\n\n\tret = snprintf(old_work, MAXPATHLEN, \"workdir=%s/%s\", lxc_path, lxc_name);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\tgoto err;\n\n\tret = snprintf(new_work, MAXPATHLEN, \"workdir=%s/%s\", cleanpath, newname);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\tgoto err;\n\n\tlxc_list_for_each(iterator, &lxc_conf->mount_list) {\n\t\tchar *mnt_entry = NULL;\n\t\tchar *new_mnt_entry = NULL;\n\t\tchar *tmp = NULL;\n\t\tchar *tmp_mnt_entry = NULL;\n\t\tmnt_entry = iterator->elem;\n\n\t\tif (strstr(mnt_entry, \"overlay\"))\n\t\t\ttmp = \"upperdir\";\n\t\telse if (strstr(mnt_entry, \"aufs\"))\n\t\t\ttmp = \"br\";\n\n\t\tif (!tmp)\n\t\t\tcontinue;\n\n\t\tret = snprintf(old_upper, MAXPATHLEN, \"%s=%s/%s\", tmp, lxc_path, lxc_name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\tgoto err;\n\n\t\tret = snprintf(new_upper, MAXPATHLEN, \"%s=%s/%s\", tmp, cleanpath, newname);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\tgoto err;\n\n\t\tif (strstr(mnt_entry, old_upper)) {\n\t\t\ttmp_mnt_entry = lxc_string_replace(old_upper, new_upper, mnt_entry);\n\t\t}\n\n\t\tif (strstr(mnt_entry, old_work)) {\n\t\t\tif (tmp_mnt_entry)\n\t\t\t\tnew_mnt_entry = lxc_string_replace(old_work, new_work, tmp_mnt_entry);\n\t\t\telse\n\t\t\t\tnew_mnt_entry = lxc_string_replace(old_work, new_work, mnt_entry);\n\t\t}\n\n\t\tif (new_mnt_entry) {\n\t\t\tfree(iterator->elem);\n\t\t\titerator->elem = strdup(new_mnt_entry);\n\t\t} else if (tmp_mnt_entry) {\n\t\t\tfree(iterator->elem);\n\t\t\titerator->elem = strdup(tmp_mnt_entry);\n\t\t}\n\n\t\tfree(new_mnt_entry);\n\t\tfree(tmp_mnt_entry);\n\t}\n\n\tfret = 0;\nerr:\n\tfree(cleanpath);\n\treturn fret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error updating mac addresses\""
          ],
          "line": 3183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "network_new_hwaddrs",
          "args": [
            "c2->lxc_conf"
          ],
          "line": 3182
        },
        "resolved": true,
        "details": {
          "function_name": "network_new_hwaddrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/confile.c",
          "lines": "2993-3054",
          "snippet": "bool network_new_hwaddrs(struct lxc_conf *conf)\n{\n\tstruct lxc_list *it;\n\n\tconst char *key = \"lxc.network.hwaddr\";\n\tchar *lstart = conf->unexpanded_config, *lend, *p, *p2;\n\n\tif (!conf->unexpanded_config)\n\t\treturn true;\n\n\twhile (*lstart) {\n\t\tchar newhwaddr[18], oldhwaddr[17];\n\n\t\tlend = strchr(lstart, '\\n');\n\t\tif (!lend)\n\t\t\tlend = lstart + strlen(lstart);\n\t\telse\n\t\t\tlend++;\n\n\t\tif (strncmp(lstart, key, strlen(key)) != 0) {\n\t\t\tlstart = lend;\n\t\t\tcontinue;\n\t\t}\n\n\t\tp = strchr(lstart+strlen(key), '=');\n\t\tif (!p) {\n\t\t\tlstart = lend;\n\t\t\tcontinue;\n\t\t}\n\n\t\tp++;\n\t\twhile (isblank(*p))\n\t\t\tp++;\n\t\tif (!*p)\n\t\t\treturn true;\n\n\t\tp2 = p;\n\t\twhile (*p2 && !isblank(*p2) && *p2 != '\\n')\n\t\t\tp2++;\n\t\tif (p2-p != 17) {\n\t\t\tWARN(\"Bad hwaddr entry\");\n\t\t\tlstart = lend;\n\t\t\tcontinue;\n\t\t}\n\n\t\tmemcpy(oldhwaddr, p, 17);\n\n\t\tif (!new_hwaddr(newhwaddr))\n\t\t\treturn false;\n\n\t\tmemcpy(p, newhwaddr, 17);\n\t\tlxc_list_for_each(it, &conf->network) {\n\t\t\tstruct lxc_netdev *n = it->elem;\n\t\t\tif (n->hwaddr && memcmp(oldhwaddr, n->hwaddr, 17) == 0)\n\t\t\t\tmemcpy(n->hwaddr, newhwaddr, 17);\n\t\t}\n\n\t\tlstart = lend;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"network.h\"",
            "#include \"conf.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"confile.h\"",
            "#include \"config.h\"",
            "#include \"parse.h\"",
            "#include \"bdev.h\"",
            "#include <syslog.h>",
            "#include <dirent.h>",
            "#include <time.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int config_personality(const char *, const char *, struct lxc_conf *);",
            "static int config_pts(const char *, const char *, struct lxc_conf *);",
            "static int config_tty(const char *, const char *, struct lxc_conf *);",
            "static int config_ttydir(const char *, const char *, struct lxc_conf *);",
            "static int config_kmsg(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_aa_profile(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_aa_incomplete(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_se_context(const char *, const char *, struct lxc_conf *);",
            "static int config_cgroup(const char *, const char *, struct lxc_conf *);",
            "static int config_idmap(const char *, const char *, struct lxc_conf *);",
            "static int config_loglevel(const char *, const char *, struct lxc_conf *);",
            "static int config_logfile(const char *, const char *, struct lxc_conf *);",
            "static int config_mount(const char *, const char *, struct lxc_conf *);",
            "static int config_mount_auto(const char *, const char *, struct lxc_conf *);",
            "static int config_fstab(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_mount(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_options(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_backend(const char *, const char *, struct lxc_conf *);",
            "static int config_pivotdir(const char *, const char *, struct lxc_conf *);",
            "static int config_utsname(const char *, const char *, struct lxc_conf *);",
            "static int config_hook(const char *, const char *, struct lxc_conf *lxc_conf);",
            "static int config_network(const char *, const char *, struct lxc_conf *);",
            "static int config_network_type(const char *, const char *, struct lxc_conf *);",
            "static int config_network_flags(const char *, const char *, struct lxc_conf *);",
            "static int config_network_link(const char *, const char *, struct lxc_conf *);",
            "static int config_network_name(const char *, const char *, struct lxc_conf *);",
            "static int config_network_veth_pair(const char *, const char *, struct lxc_conf *);",
            "static int config_network_macvlan_mode(const char *, const char *, struct lxc_conf *);",
            "static int config_network_hwaddr(const char *, const char *, struct lxc_conf *);",
            "static int config_network_vlan_id(const char *, const char *, struct lxc_conf *);",
            "static int config_network_mtu(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv4(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv4_gateway(const char *, const char *, struct lxc_conf *);",
            "static int config_network_script_up(const char *, const char *, struct lxc_conf *);",
            "static int config_network_script_down(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv6(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv6_gateway(const char *, const char *, struct lxc_conf *);",
            "static int config_cap_drop(const char *, const char *, struct lxc_conf *);",
            "static int config_cap_keep(const char *, const char *, struct lxc_conf *);",
            "static int config_console(const char *, const char *, struct lxc_conf *);",
            "static int config_console_logfile(const char *, const char *, struct lxc_conf *);",
            "static int config_seccomp(const char *, const char *, struct lxc_conf *);",
            "static int config_includefile(const char *, const char *, struct lxc_conf *);",
            "static int config_network_nic(const char *, const char *, struct lxc_conf *);",
            "static int config_autodev(const char *, const char *, struct lxc_conf *);",
            "static int config_haltsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_rebootsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_stopsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_start(const char *, const char *, struct lxc_conf *);",
            "static int config_syslog(const char *, const char *, struct lxc_conf *);",
            "static int config_monitor(const char *, const char *, struct lxc_conf *);",
            "static int config_group(const char *, const char *, struct lxc_conf *);",
            "static int config_environment(const char *, const char *, struct lxc_conf *);",
            "static int config_init_cmd(const char *, const char *, struct lxc_conf *);",
            "static int config_init_uid(const char *, const char *, struct lxc_conf *);",
            "static int config_init_gid(const char *, const char *, struct lxc_conf *);",
            "static int config_ephemeral(const char *, const char *, struct lxc_conf *);",
            "static int config_no_new_privs(const char *, const char *, struct lxc_conf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"lxcseccomp.h\"\n#include \"network.h\"\n#include \"conf.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"confile.h\"\n#include \"config.h\"\n#include \"parse.h\"\n#include \"bdev.h\"\n#include <syslog.h>\n#include <dirent.h>\n#include <time.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int config_personality(const char *, const char *, struct lxc_conf *);\nstatic int config_pts(const char *, const char *, struct lxc_conf *);\nstatic int config_tty(const char *, const char *, struct lxc_conf *);\nstatic int config_ttydir(const char *, const char *, struct lxc_conf *);\nstatic int config_kmsg(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_aa_profile(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_aa_incomplete(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_se_context(const char *, const char *, struct lxc_conf *);\nstatic int config_cgroup(const char *, const char *, struct lxc_conf *);\nstatic int config_idmap(const char *, const char *, struct lxc_conf *);\nstatic int config_loglevel(const char *, const char *, struct lxc_conf *);\nstatic int config_logfile(const char *, const char *, struct lxc_conf *);\nstatic int config_mount(const char *, const char *, struct lxc_conf *);\nstatic int config_mount_auto(const char *, const char *, struct lxc_conf *);\nstatic int config_fstab(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_mount(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_options(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_backend(const char *, const char *, struct lxc_conf *);\nstatic int config_pivotdir(const char *, const char *, struct lxc_conf *);\nstatic int config_utsname(const char *, const char *, struct lxc_conf *);\nstatic int config_hook(const char *, const char *, struct lxc_conf *lxc_conf);\nstatic int config_network(const char *, const char *, struct lxc_conf *);\nstatic int config_network_type(const char *, const char *, struct lxc_conf *);\nstatic int config_network_flags(const char *, const char *, struct lxc_conf *);\nstatic int config_network_link(const char *, const char *, struct lxc_conf *);\nstatic int config_network_name(const char *, const char *, struct lxc_conf *);\nstatic int config_network_veth_pair(const char *, const char *, struct lxc_conf *);\nstatic int config_network_macvlan_mode(const char *, const char *, struct lxc_conf *);\nstatic int config_network_hwaddr(const char *, const char *, struct lxc_conf *);\nstatic int config_network_vlan_id(const char *, const char *, struct lxc_conf *);\nstatic int config_network_mtu(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv4(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv4_gateway(const char *, const char *, struct lxc_conf *);\nstatic int config_network_script_up(const char *, const char *, struct lxc_conf *);\nstatic int config_network_script_down(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv6(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv6_gateway(const char *, const char *, struct lxc_conf *);\nstatic int config_cap_drop(const char *, const char *, struct lxc_conf *);\nstatic int config_cap_keep(const char *, const char *, struct lxc_conf *);\nstatic int config_console(const char *, const char *, struct lxc_conf *);\nstatic int config_console_logfile(const char *, const char *, struct lxc_conf *);\nstatic int config_seccomp(const char *, const char *, struct lxc_conf *);\nstatic int config_includefile(const char *, const char *, struct lxc_conf *);\nstatic int config_network_nic(const char *, const char *, struct lxc_conf *);\nstatic int config_autodev(const char *, const char *, struct lxc_conf *);\nstatic int config_haltsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_rebootsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_stopsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_start(const char *, const char *, struct lxc_conf *);\nstatic int config_syslog(const char *, const char *, struct lxc_conf *);\nstatic int config_monitor(const char *, const char *, struct lxc_conf *);\nstatic int config_group(const char *, const char *, struct lxc_conf *);\nstatic int config_environment(const char *, const char *, struct lxc_conf *);\nstatic int config_init_cmd(const char *, const char *, struct lxc_conf *);\nstatic int config_init_uid(const char *, const char *, struct lxc_conf *);\nstatic int config_init_gid(const char *, const char *, struct lxc_conf *);\nstatic int config_ephemeral(const char *, const char *, struct lxc_conf *);\nstatic int config_no_new_privs(const char *, const char *, struct lxc_conf *);\n\nbool network_new_hwaddrs(struct lxc_conf *conf)\n{\n\tstruct lxc_list *it;\n\n\tconst char *key = \"lxc.network.hwaddr\";\n\tchar *lstart = conf->unexpanded_config, *lend, *p, *p2;\n\n\tif (!conf->unexpanded_config)\n\t\treturn true;\n\n\twhile (*lstart) {\n\t\tchar newhwaddr[18], oldhwaddr[17];\n\n\t\tlend = strchr(lstart, '\\n');\n\t\tif (!lend)\n\t\t\tlend = lstart + strlen(lstart);\n\t\telse\n\t\t\tlend++;\n\n\t\tif (strncmp(lstart, key, strlen(key)) != 0) {\n\t\t\tlstart = lend;\n\t\t\tcontinue;\n\t\t}\n\n\t\tp = strchr(lstart+strlen(key), '=');\n\t\tif (!p) {\n\t\t\tlstart = lend;\n\t\t\tcontinue;\n\t\t}\n\n\t\tp++;\n\t\twhile (isblank(*p))\n\t\t\tp++;\n\t\tif (!*p)\n\t\t\treturn true;\n\n\t\tp2 = p;\n\t\twhile (*p2 && !isblank(*p2) && *p2 != '\\n')\n\t\t\tp2++;\n\t\tif (p2-p != 17) {\n\t\t\tWARN(\"Bad hwaddr entry\");\n\t\t\tlstart = lend;\n\t\t\tcontinue;\n\t\t}\n\n\t\tmemcpy(oldhwaddr, p, 17);\n\n\t\tif (!new_hwaddr(newhwaddr))\n\t\t\treturn false;\n\n\t\tmemcpy(p, newhwaddr, 17);\n\t\tlxc_list_for_each(it, &conf->network) {\n\t\t\tstruct lxc_netdev *n = it->elem;\n\t\t\tif (n->hwaddr && memcmp(oldhwaddr, n->hwaddr, 17) == 0)\n\t\t\t\tmemcpy(n->hwaddr, newhwaddr, 17);\n\t\t}\n\n\t\tlstart = lend;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"error copying fstab\""
          ],
          "line": 3176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_fstab",
          "args": [
            "c",
            "c2"
          ],
          "line": 3175
        },
        "resolved": true,
        "details": {
          "function_name": "copy_fstab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2739-2780",
          "snippet": "static int copy_fstab(struct lxc_container *oldc, struct lxc_container *c)\n{\n\tchar newpath[MAXPATHLEN];\n\tchar *oldpath = oldc->lxc_conf->fstab;\n\tint ret;\n\n\tif (!oldpath)\n\t\treturn 0;\n\n\tclear_unexp_config_line(c->lxc_conf, \"lxc.mount\", false);\n\n\tchar *p = strrchr(oldpath, '/');\n\tif (!p)\n\t\treturn -1;\n\tret = snprintf(newpath, MAXPATHLEN, \"%s/%s%s\",\n\t\t\tc->config_path, c->name, p);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tERROR(\"error printing new path for %s\", oldpath);\n\t\treturn -1;\n\t}\n\tif (file_exists(newpath)) {\n\t\tERROR(\"error: fstab file %s exists\", newpath);\n\t\treturn -1;\n\t}\n\n\tif (copy_file(oldpath, newpath) < 0) {\n\t\tERROR(\"error: copying %s to %s\", oldpath, newpath);\n\t\treturn -1;\n\t}\n\tfree(c->lxc_conf->fstab);\n\tc->lxc_conf->fstab = strdup(newpath);\n\tif (!c->lxc_conf->fstab) {\n\t\tERROR(\"error: allocating pathname\");\n\t\treturn -1;\n\t}\n\tif (!do_append_unexp_config_line(c->lxc_conf, \"lxc.mount\", newpath)) {\n\t\tERROR(\"error saving new lxctab\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic int copy_fstab(struct lxc_container *oldc, struct lxc_container *c)\n{\n\tchar newpath[MAXPATHLEN];\n\tchar *oldpath = oldc->lxc_conf->fstab;\n\tint ret;\n\n\tif (!oldpath)\n\t\treturn 0;\n\n\tclear_unexp_config_line(c->lxc_conf, \"lxc.mount\", false);\n\n\tchar *p = strrchr(oldpath, '/');\n\tif (!p)\n\t\treturn -1;\n\tret = snprintf(newpath, MAXPATHLEN, \"%s/%s%s\",\n\t\t\tc->config_path, c->name, p);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tERROR(\"error printing new path for %s\", oldpath);\n\t\treturn -1;\n\t}\n\tif (file_exists(newpath)) {\n\t\tERROR(\"error: fstab file %s exists\", newpath);\n\t\treturn -1;\n\t}\n\n\tif (copy_file(oldpath, newpath) < 0) {\n\t\tERROR(\"error: copying %s to %s\", oldpath, newpath);\n\t\treturn -1;\n\t}\n\tfree(c->lxc_conf->fstab);\n\tc->lxc_conf->fstab = strdup(newpath);\n\tif (!c->lxc_conf->fstab) {\n\t\tERROR(\"error: allocating pathname\");\n\t\treturn -1;\n\t}\n\tif (!do_append_unexp_config_line(c->lxc_conf, \"lxc.mount\", newpath)) {\n\t\tERROR(\"error saving new lxctab\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"error copying hooks\""
          ],
          "line": 3171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyhooks",
          "args": [
            "c",
            "c2"
          ],
          "line": 3169
        },
        "resolved": true,
        "details": {
          "function_name": "copyhooks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2689-2736",
          "snippet": "static int copyhooks(struct lxc_container *oldc, struct lxc_container *c)\n{\n\tint i, len, ret;\n\tstruct lxc_list *it;\n\tchar *cpath;\n\n\tlen = strlen(oldc->config_path) + strlen(oldc->name) + 3;\n\tcpath = alloca(len);\n\tret = snprintf(cpath, len, \"%s/%s/\", oldc->config_path, oldc->name);\n\tif (ret < 0 || ret >= len)\n\t\treturn -1;\n\n\tfor (i=0; i<NUM_LXC_HOOKS; i++) {\n\t\tlxc_list_for_each(it, &c->lxc_conf->hooks[i]) {\n\t\t\tchar *hookname = it->elem;\n\t\t\tchar *fname = strrchr(hookname, '/');\n\t\t\tchar tmppath[MAXPATHLEN];\n\t\t\tif (!fname) // relative path - we don't support, but maybe we should\n\t\t\t\treturn 0;\n\t\t\tif (strncmp(hookname, cpath, len - 1) != 0) {\n\t\t\t\t// this hook is public - ignore\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// copy the script, and change the entry in confile\n\t\t\tret = snprintf(tmppath, MAXPATHLEN, \"%s/%s/%s\",\n\t\t\t\t\tc->config_path, c->name, fname+1);\n\t\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\t\treturn -1;\n\t\t\tret = copy_file(it->elem, tmppath);\n\t\t\tif (ret < 0)\n\t\t\t\treturn -1;\n\t\t\tfree(it->elem);\n\t\t\tit->elem = strdup(tmppath);\n\t\t\tif (!it->elem) {\n\t\t\t\tERROR(\"out of memory copying hook path\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!clone_update_unexp_hooks(c->lxc_conf, oldc->config_path,\n\t\t\tc->config_path, oldc->name, c->name)) {\n\t\tERROR(\"Error saving new hooks in clone\");\n\t\treturn -1;\n\t}\n\tdo_lxcapi_save_config(c, NULL);\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic int copyhooks(struct lxc_container *oldc, struct lxc_container *c)\n{\n\tint i, len, ret;\n\tstruct lxc_list *it;\n\tchar *cpath;\n\n\tlen = strlen(oldc->config_path) + strlen(oldc->name) + 3;\n\tcpath = alloca(len);\n\tret = snprintf(cpath, len, \"%s/%s/\", oldc->config_path, oldc->name);\n\tif (ret < 0 || ret >= len)\n\t\treturn -1;\n\n\tfor (i=0; i<NUM_LXC_HOOKS; i++) {\n\t\tlxc_list_for_each(it, &c->lxc_conf->hooks[i]) {\n\t\t\tchar *hookname = it->elem;\n\t\t\tchar *fname = strrchr(hookname, '/');\n\t\t\tchar tmppath[MAXPATHLEN];\n\t\t\tif (!fname) // relative path - we don't support, but maybe we should\n\t\t\t\treturn 0;\n\t\t\tif (strncmp(hookname, cpath, len - 1) != 0) {\n\t\t\t\t// this hook is public - ignore\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// copy the script, and change the entry in confile\n\t\t\tret = snprintf(tmppath, MAXPATHLEN, \"%s/%s/%s\",\n\t\t\t\t\tc->config_path, c->name, fname+1);\n\t\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\t\treturn -1;\n\t\t\tret = copy_file(it->elem, tmppath);\n\t\t\tif (ret < 0)\n\t\t\t\treturn -1;\n\t\t\tfree(it->elem);\n\t\t\tit->elem = strdup(tmppath);\n\t\t\tif (!it->elem) {\n\t\t\t\tERROR(\"out of memory copying hook path\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!clone_update_unexp_hooks(c->lxc_conf, oldc->config_path,\n\t\t\tc->config_path, oldc->name, c->name)) {\n\t\tERROR(\"Error saving new hooks in clone\");\n\t\treturn -1;\n\t}\n\tdo_lxcapi_save_config(c, NULL);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error setting new hostname\""
          ],
          "line": 3163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_config_item_locked",
          "args": [
            "c2",
            "\"lxc.utsname\"",
            "newname"
          ],
          "line": 3162
        },
        "resolved": true,
        "details": {
          "function_name": "set_config_item_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2455-2469",
          "snippet": "static bool set_config_item_locked(struct lxc_container *c, const char *key, const char *v)\n{\n\tstruct lxc_config_t *config;\n\n\tif (!c->lxc_conf)\n\t\tc->lxc_conf = lxc_conf_init();\n\tif (!c->lxc_conf)\n\t\treturn false;\n\tconfig = lxc_getconfig(key);\n\tif (!config)\n\t\treturn false;\n\tif (config->cb(key, v, c->lxc_conf) != 0)\n\t\treturn false;\n\treturn do_append_unexp_config_line(c->lxc_conf, key, v);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool do_lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool do_lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool set_config_item_locked(struct lxc_container *c, const char *key, const char *v)\n{\n\tstruct lxc_config_t *config;\n\n\tif (!c->lxc_conf)\n\t\tc->lxc_conf = lxc_conf_init();\n\tif (!c->lxc_conf)\n\t\treturn false;\n\tconfig = lxc_getconfig(key);\n\tif (!config)\n\t\treturn false;\n\tif (config->cb(key, v, c->lxc_conf) != 0)\n\t\treturn false;\n\treturn do_append_unexp_config_line(c->lxc_conf, key, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_unexp_config_line",
          "args": [
            "c2->lxc_conf",
            "\"lxc.utsname\"",
            "false"
          ],
          "line": 3160
        },
        "resolved": true,
        "details": {
          "function_name": "clear_unexp_config_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/confile.c",
          "lines": "2749-2780",
          "snippet": "void clear_unexp_config_line(struct lxc_conf *conf, const char *key, bool rm_subkeys)\n{\n\tchar *lstart = conf->unexpanded_config, *lend;\n\n\tif (!conf->unexpanded_config)\n\t\treturn;\n\twhile (*lstart) {\n\t\tlend = strchr(lstart, '\\n');\n\t\tchar v;\n\t\tif (!lend)\n\t\t\tlend = lstart + strlen(lstart);\n\t\telse\n\t\t\tlend++;\n\t\tif (strncmp(lstart, key, strlen(key)) != 0) {\n\t\t\tlstart = lend;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!rm_subkeys) {\n\t\t\tv = lstart[strlen(key)];\n\t\t\tif (!isspace(v) && v != '=') {\n\t\t\t\tlstart = lend;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tconf->unexpanded_len -= (lend - lstart);\n\t\tif (*lend == '\\0') {\n\t\t\t*lstart = '\\0';\n\t\t\treturn;\n\t\t}\n\t\tmemmove(lstart, lend, strlen(lend)+1);\n\t}\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"network.h\"",
            "#include \"conf.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"confile.h\"",
            "#include \"config.h\"",
            "#include \"parse.h\"",
            "#include \"bdev.h\"",
            "#include <syslog.h>",
            "#include <dirent.h>",
            "#include <time.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int config_personality(const char *, const char *, struct lxc_conf *);",
            "static int config_pts(const char *, const char *, struct lxc_conf *);",
            "static int config_tty(const char *, const char *, struct lxc_conf *);",
            "static int config_ttydir(const char *, const char *, struct lxc_conf *);",
            "static int config_kmsg(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_aa_profile(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_aa_incomplete(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_se_context(const char *, const char *, struct lxc_conf *);",
            "static int config_cgroup(const char *, const char *, struct lxc_conf *);",
            "static int config_idmap(const char *, const char *, struct lxc_conf *);",
            "static int config_loglevel(const char *, const char *, struct lxc_conf *);",
            "static int config_logfile(const char *, const char *, struct lxc_conf *);",
            "static int config_mount(const char *, const char *, struct lxc_conf *);",
            "static int config_mount_auto(const char *, const char *, struct lxc_conf *);",
            "static int config_fstab(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_mount(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_options(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_backend(const char *, const char *, struct lxc_conf *);",
            "static int config_pivotdir(const char *, const char *, struct lxc_conf *);",
            "static int config_utsname(const char *, const char *, struct lxc_conf *);",
            "static int config_hook(const char *, const char *, struct lxc_conf *lxc_conf);",
            "static int config_network(const char *, const char *, struct lxc_conf *);",
            "static int config_network_type(const char *, const char *, struct lxc_conf *);",
            "static int config_network_flags(const char *, const char *, struct lxc_conf *);",
            "static int config_network_link(const char *, const char *, struct lxc_conf *);",
            "static int config_network_name(const char *, const char *, struct lxc_conf *);",
            "static int config_network_veth_pair(const char *, const char *, struct lxc_conf *);",
            "static int config_network_macvlan_mode(const char *, const char *, struct lxc_conf *);",
            "static int config_network_hwaddr(const char *, const char *, struct lxc_conf *);",
            "static int config_network_vlan_id(const char *, const char *, struct lxc_conf *);",
            "static int config_network_mtu(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv4(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv4_gateway(const char *, const char *, struct lxc_conf *);",
            "static int config_network_script_up(const char *, const char *, struct lxc_conf *);",
            "static int config_network_script_down(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv6(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv6_gateway(const char *, const char *, struct lxc_conf *);",
            "static int config_cap_drop(const char *, const char *, struct lxc_conf *);",
            "static int config_cap_keep(const char *, const char *, struct lxc_conf *);",
            "static int config_console(const char *, const char *, struct lxc_conf *);",
            "static int config_console_logfile(const char *, const char *, struct lxc_conf *);",
            "static int config_seccomp(const char *, const char *, struct lxc_conf *);",
            "static int config_includefile(const char *, const char *, struct lxc_conf *);",
            "static int config_network_nic(const char *, const char *, struct lxc_conf *);",
            "static int config_autodev(const char *, const char *, struct lxc_conf *);",
            "static int config_haltsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_rebootsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_stopsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_start(const char *, const char *, struct lxc_conf *);",
            "static int config_syslog(const char *, const char *, struct lxc_conf *);",
            "static int config_monitor(const char *, const char *, struct lxc_conf *);",
            "static int config_group(const char *, const char *, struct lxc_conf *);",
            "static int config_environment(const char *, const char *, struct lxc_conf *);",
            "static int config_init_cmd(const char *, const char *, struct lxc_conf *);",
            "static int config_init_uid(const char *, const char *, struct lxc_conf *);",
            "static int config_init_gid(const char *, const char *, struct lxc_conf *);",
            "static int config_ephemeral(const char *, const char *, struct lxc_conf *);",
            "static int config_no_new_privs(const char *, const char *, struct lxc_conf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"lxcseccomp.h\"\n#include \"network.h\"\n#include \"conf.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"confile.h\"\n#include \"config.h\"\n#include \"parse.h\"\n#include \"bdev.h\"\n#include <syslog.h>\n#include <dirent.h>\n#include <time.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int config_personality(const char *, const char *, struct lxc_conf *);\nstatic int config_pts(const char *, const char *, struct lxc_conf *);\nstatic int config_tty(const char *, const char *, struct lxc_conf *);\nstatic int config_ttydir(const char *, const char *, struct lxc_conf *);\nstatic int config_kmsg(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_aa_profile(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_aa_incomplete(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_se_context(const char *, const char *, struct lxc_conf *);\nstatic int config_cgroup(const char *, const char *, struct lxc_conf *);\nstatic int config_idmap(const char *, const char *, struct lxc_conf *);\nstatic int config_loglevel(const char *, const char *, struct lxc_conf *);\nstatic int config_logfile(const char *, const char *, struct lxc_conf *);\nstatic int config_mount(const char *, const char *, struct lxc_conf *);\nstatic int config_mount_auto(const char *, const char *, struct lxc_conf *);\nstatic int config_fstab(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_mount(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_options(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_backend(const char *, const char *, struct lxc_conf *);\nstatic int config_pivotdir(const char *, const char *, struct lxc_conf *);\nstatic int config_utsname(const char *, const char *, struct lxc_conf *);\nstatic int config_hook(const char *, const char *, struct lxc_conf *lxc_conf);\nstatic int config_network(const char *, const char *, struct lxc_conf *);\nstatic int config_network_type(const char *, const char *, struct lxc_conf *);\nstatic int config_network_flags(const char *, const char *, struct lxc_conf *);\nstatic int config_network_link(const char *, const char *, struct lxc_conf *);\nstatic int config_network_name(const char *, const char *, struct lxc_conf *);\nstatic int config_network_veth_pair(const char *, const char *, struct lxc_conf *);\nstatic int config_network_macvlan_mode(const char *, const char *, struct lxc_conf *);\nstatic int config_network_hwaddr(const char *, const char *, struct lxc_conf *);\nstatic int config_network_vlan_id(const char *, const char *, struct lxc_conf *);\nstatic int config_network_mtu(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv4(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv4_gateway(const char *, const char *, struct lxc_conf *);\nstatic int config_network_script_up(const char *, const char *, struct lxc_conf *);\nstatic int config_network_script_down(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv6(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv6_gateway(const char *, const char *, struct lxc_conf *);\nstatic int config_cap_drop(const char *, const char *, struct lxc_conf *);\nstatic int config_cap_keep(const char *, const char *, struct lxc_conf *);\nstatic int config_console(const char *, const char *, struct lxc_conf *);\nstatic int config_console_logfile(const char *, const char *, struct lxc_conf *);\nstatic int config_seccomp(const char *, const char *, struct lxc_conf *);\nstatic int config_includefile(const char *, const char *, struct lxc_conf *);\nstatic int config_network_nic(const char *, const char *, struct lxc_conf *);\nstatic int config_autodev(const char *, const char *, struct lxc_conf *);\nstatic int config_haltsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_rebootsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_stopsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_start(const char *, const char *, struct lxc_conf *);\nstatic int config_syslog(const char *, const char *, struct lxc_conf *);\nstatic int config_monitor(const char *, const char *, struct lxc_conf *);\nstatic int config_group(const char *, const char *, struct lxc_conf *);\nstatic int config_environment(const char *, const char *, struct lxc_conf *);\nstatic int config_init_cmd(const char *, const char *, struct lxc_conf *);\nstatic int config_init_uid(const char *, const char *, struct lxc_conf *);\nstatic int config_init_gid(const char *, const char *, struct lxc_conf *);\nstatic int config_ephemeral(const char *, const char *, struct lxc_conf *);\nstatic int config_no_new_privs(const char *, const char *, struct lxc_conf *);\n\nvoid clear_unexp_config_line(struct lxc_conf *conf, const char *key, bool rm_subkeys)\n{\n\tchar *lstart = conf->unexpanded_config, *lend;\n\n\tif (!conf->unexpanded_config)\n\t\treturn;\n\twhile (*lstart) {\n\t\tlend = strchr(lstart, '\\n');\n\t\tchar v;\n\t\tif (!lend)\n\t\t\tlend = lstart + strlen(lstart);\n\t\telse\n\t\t\tlend++;\n\t\tif (strncmp(lstart, key, strlen(key)) != 0) {\n\t\t\tlstart = lend;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!rm_subkeys) {\n\t\t\tv = lstart[strlen(key)];\n\t\t\tif (!isspace(v) && v != '=') {\n\t\t\t\tlstart = lend;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tconf->unexpanded_len -= (lend - lstart);\n\t\tif (*lend == '\\0') {\n\t\t\t*lstart = '\\0';\n\t\t\treturn;\n\t\t}\n\t\tmemmove(lstart, lend, strlen(lend)+1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_storage",
          "args": [
            "c",
            "c2",
            "bdevtype",
            "flags",
            "bdevdata",
            "newsize"
          ],
          "line": 3153
        },
        "resolved": true,
        "details": {
          "function_name": "copy_storage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2854-2916",
          "snippet": "static int copy_storage(struct lxc_container *c0, struct lxc_container *c,\n\t\t\tconst char *newtype, int flags, const char *bdevdata,\n\t\t\tuint64_t newsize)\n{\n\tstruct bdev *bdev;\n\tint need_rdep;\n\n\tif (should_default_to_snapshot(c0, c))\n\t\tflags |= LXC_CLONE_SNAPSHOT;\n\n\tbdev = bdev_copy(c0, c->name, c->config_path, newtype, flags, bdevdata,\n\t\t\t newsize, &need_rdep);\n\tif (!bdev) {\n\t\tERROR(\"Error copying storage.\");\n\t\treturn -1;\n\t}\n\n\t/* Set new rootfs. */\n\tfree(c->lxc_conf->rootfs.path);\n\tc->lxc_conf->rootfs.path = strdup(bdev->src);\n\n\t/* Set new bdev type. */\n\tfree(c->lxc_conf->rootfs.bdev_type);\n\tc->lxc_conf->rootfs.bdev_type = strdup(bdev->type);\n\tbdev_put(bdev);\n\n\tif (!c->lxc_conf->rootfs.path) {\n\t\tERROR(\"Out of memory while setting storage path.\");\n\t\treturn -1;\n\t}\n\tif (!c->lxc_conf->rootfs.bdev_type) {\n\t\tERROR(\"Out of memory while setting rootfs backend.\");\n\t\treturn -1;\n\t}\n\n\t/* Append a new lxc.rootfs entry to the unexpanded config. */\n\tclear_unexp_config_line(c->lxc_conf, \"lxc.rootfs\", false);\n\tif (!do_append_unexp_config_line(c->lxc_conf, \"lxc.rootfs\",\n\t\t\t\t\t c->lxc_conf->rootfs.path)) {\n\t\tERROR(\"Error saving new rootfs to cloned config.\");\n\t\treturn -1;\n\t}\n\n\t/* Append a new lxc.rootfs.backend entry to the unexpanded config. */\n\tclear_unexp_config_line(c->lxc_conf, \"lxc.rootfs.backend\", false);\n\tif (!do_append_unexp_config_line(c->lxc_conf, \"lxc.rootfs.backend\",\n\t\t\t\t\t c->lxc_conf->rootfs.bdev_type)) {\n\t\tERROR(\"Error saving new rootfs backend to cloned config.\");\n\t\treturn -1;\n\t}\n\n\tif (flags & LXC_CLONE_SNAPSHOT)\n\t\tcopy_rdepends(c, c0);\n\tif (need_rdep) {\n\t\tif (!add_rdepends(c, c0))\n\t\t\tWARN(\"Error adding reverse dependency from %s to %s\",\n\t\t\t     c->name, c0->name);\n\t}\n\n\tmod_all_rdeps(c, true);\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic int copy_storage(struct lxc_container *c0, struct lxc_container *c,\n\t\t\tconst char *newtype, int flags, const char *bdevdata,\n\t\t\tuint64_t newsize)\n{\n\tstruct bdev *bdev;\n\tint need_rdep;\n\n\tif (should_default_to_snapshot(c0, c))\n\t\tflags |= LXC_CLONE_SNAPSHOT;\n\n\tbdev = bdev_copy(c0, c->name, c->config_path, newtype, flags, bdevdata,\n\t\t\t newsize, &need_rdep);\n\tif (!bdev) {\n\t\tERROR(\"Error copying storage.\");\n\t\treturn -1;\n\t}\n\n\t/* Set new rootfs. */\n\tfree(c->lxc_conf->rootfs.path);\n\tc->lxc_conf->rootfs.path = strdup(bdev->src);\n\n\t/* Set new bdev type. */\n\tfree(c->lxc_conf->rootfs.bdev_type);\n\tc->lxc_conf->rootfs.bdev_type = strdup(bdev->type);\n\tbdev_put(bdev);\n\n\tif (!c->lxc_conf->rootfs.path) {\n\t\tERROR(\"Out of memory while setting storage path.\");\n\t\treturn -1;\n\t}\n\tif (!c->lxc_conf->rootfs.bdev_type) {\n\t\tERROR(\"Out of memory while setting rootfs backend.\");\n\t\treturn -1;\n\t}\n\n\t/* Append a new lxc.rootfs entry to the unexpanded config. */\n\tclear_unexp_config_line(c->lxc_conf, \"lxc.rootfs\", false);\n\tif (!do_append_unexp_config_line(c->lxc_conf, \"lxc.rootfs\",\n\t\t\t\t\t c->lxc_conf->rootfs.path)) {\n\t\tERROR(\"Error saving new rootfs to cloned config.\");\n\t\treturn -1;\n\t}\n\n\t/* Append a new lxc.rootfs.backend entry to the unexpanded config. */\n\tclear_unexp_config_line(c->lxc_conf, \"lxc.rootfs.backend\", false);\n\tif (!do_append_unexp_config_line(c->lxc_conf, \"lxc.rootfs.backend\",\n\t\t\t\t\t c->lxc_conf->rootfs.bdev_type)) {\n\t\tERROR(\"Error saving new rootfs backend to cloned config.\");\n\t\treturn -1;\n\t}\n\n\tif (flags & LXC_CLONE_SNAPSHOT)\n\t\tcopy_rdepends(c, c0);\n\tif (need_rdep) {\n\t\tif (!add_rdepends(c, c0))\n\t\t\tWARN(\"Error adding reverse dependency from %s to %s\",\n\t\t\t     c->name, c0->name);\n\t}\n\n\tmod_all_rdeps(c, true);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"clone: failed to create new container (%s %s)\"",
            "newname",
            "lxcpath"
          ],
          "line": 3147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_container_new",
          "args": [
            "newname",
            "lxcpath"
          ],
          "line": 3145
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "4099-4218",
          "snippet": "struct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstruct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error chowning %s to container root\"",
            "newpath"
          ],
          "line": 3140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chown_mapped_root",
          "args": [
            "newpath",
            "c->lxc_conf"
          ],
          "line": 3139
        },
        "resolved": true,
        "details": {
          "function_name": "chown_mapped_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3482-3618",
          "snippet": "int chown_mapped_root(char *path, struct lxc_conf *conf)\n{\n\tuid_t rootuid;\n\tgid_t rootgid;\n\tpid_t pid;\n\tunsigned long val;\n\tchar *chownpath = path;\n\n\tif (!get_mapped_rootid(conf, ID_TYPE_UID, &val)) {\n\t\tERROR(\"No mapping for container root\");\n\t\treturn -1;\n\t}\n\trootuid = (uid_t) val;\n\tif (!get_mapped_rootid(conf, ID_TYPE_GID, &val)) {\n\t\tERROR(\"No mapping for container root\");\n\t\treturn -1;\n\t}\n\trootgid = (gid_t) val;\n\n\t/*\n\t * In case of overlay, we want only the writeable layer\n\t * to be chowned\n\t */\n\tif (strncmp(path, \"overlayfs:\", 10) == 0 || strncmp(path, \"aufs:\", 5) == 0) {\n\t\tchownpath = strchr(path, ':');\n\t\tif (!chownpath) {\n\t\t\tERROR(\"Bad overlay path: %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tchownpath = strchr(chownpath+1, ':');\n\t\tif (!chownpath) {\n\t\t\tERROR(\"Bad overlay path: %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tchownpath++;\n\t}\n\tpath = chownpath;\n\tif (geteuid() == 0) {\n\t\tif (chown(path, rootuid, rootgid) < 0) {\n\t\t\tERROR(\"Error chowning %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (rootuid == geteuid()) {\n\t\t// nothing to do\n\t\tINFO(\"%s: container root is our uid;  no need to chown\" ,__func__);\n\t\treturn 0;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"Failed forking\");\n\t\treturn -1;\n\t}\n\tif (!pid) {\n\t\tint hostuid = geteuid(), hostgid = getegid(), ret;\n\t\tstruct stat sb;\n\t\tchar map1[100], map2[100], map3[100], map4[100], map5[100];\n\t\tchar ugid[100];\n\t\tchar *args1[] = { \"lxc-usernsexec\", \"-m\", map1, \"-m\", map2,\n\t\t\t\t\"-m\", map3, \"-m\", map5,\n\t\t\t\t\"--\", \"chown\", ugid, path, NULL };\n\t\tchar *args2[] = { \"lxc-usernsexec\", \"-m\", map1, \"-m\", map2,\n\t\t\t\t\"-m\", map3, \"-m\", map4, \"-m\", map5,\n\t\t\t\t\"--\", \"chown\", ugid, path, NULL };\n\n\t\t// save the current gid of \"path\"\n\t\tif (stat(path, &sb) < 0) {\n\t\t\tERROR(\"Error stat %s\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * A file has to be group-owned by a gid mapped into the\n\t\t * container, or the container won't be privileged over it.\n\t\t */\n\t\tif (sb.st_uid == geteuid() &&\n\t\t\t\tmapped_hostid(sb.st_gid, conf, ID_TYPE_GID) < 0 &&\n\t\t\t\tchown(path, -1, hostgid) < 0) {\n\t\t\tERROR(\"Failed chgrping %s\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"u:0:rootuid:1\"\n\t\tret = snprintf(map1, 100, \"u:0:%d:1\", rootuid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error uid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"u:hostuid:hostuid:1\"\n\t\tret = snprintf(map2, 100, \"u:%d:%d:1\", hostuid, hostuid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error uid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:0:rootgid:1\"\n\t\tret = snprintf(map3, 100, \"g:0:%d:1\", rootgid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:pathgid:rootgid+pathgid:1\"\n\t\tret = snprintf(map4, 100, \"g:%d:%d:1\", (gid_t)sb.st_gid,\n\t\t\t\trootgid + (gid_t)sb.st_gid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:hostgid:hostgid:1\"\n\t\tret = snprintf(map5, 100, \"g:%d:%d:1\", hostgid, hostgid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"0:pathgid\" (chown)\n\t\tret = snprintf(ugid, 100, \"0:%d\", (gid_t)sb.st_gid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error owner printing format string for chown\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (hostgid == sb.st_gid)\n\t\t\tret = execvp(\"lxc-usernsexec\", args1);\n\t\telse\n\t\t\tret = execvp(\"lxc-usernsexec\", args2);\n\t\tSYSERROR(\"Failed executing usernsexec\");\n\t\texit(1);\n\t}\n\treturn wait_for_pid(pid);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint chown_mapped_root(char *path, struct lxc_conf *conf)\n{\n\tuid_t rootuid;\n\tgid_t rootgid;\n\tpid_t pid;\n\tunsigned long val;\n\tchar *chownpath = path;\n\n\tif (!get_mapped_rootid(conf, ID_TYPE_UID, &val)) {\n\t\tERROR(\"No mapping for container root\");\n\t\treturn -1;\n\t}\n\trootuid = (uid_t) val;\n\tif (!get_mapped_rootid(conf, ID_TYPE_GID, &val)) {\n\t\tERROR(\"No mapping for container root\");\n\t\treturn -1;\n\t}\n\trootgid = (gid_t) val;\n\n\t/*\n\t * In case of overlay, we want only the writeable layer\n\t * to be chowned\n\t */\n\tif (strncmp(path, \"overlayfs:\", 10) == 0 || strncmp(path, \"aufs:\", 5) == 0) {\n\t\tchownpath = strchr(path, ':');\n\t\tif (!chownpath) {\n\t\t\tERROR(\"Bad overlay path: %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tchownpath = strchr(chownpath+1, ':');\n\t\tif (!chownpath) {\n\t\t\tERROR(\"Bad overlay path: %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tchownpath++;\n\t}\n\tpath = chownpath;\n\tif (geteuid() == 0) {\n\t\tif (chown(path, rootuid, rootgid) < 0) {\n\t\t\tERROR(\"Error chowning %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (rootuid == geteuid()) {\n\t\t// nothing to do\n\t\tINFO(\"%s: container root is our uid;  no need to chown\" ,__func__);\n\t\treturn 0;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"Failed forking\");\n\t\treturn -1;\n\t}\n\tif (!pid) {\n\t\tint hostuid = geteuid(), hostgid = getegid(), ret;\n\t\tstruct stat sb;\n\t\tchar map1[100], map2[100], map3[100], map4[100], map5[100];\n\t\tchar ugid[100];\n\t\tchar *args1[] = { \"lxc-usernsexec\", \"-m\", map1, \"-m\", map2,\n\t\t\t\t\"-m\", map3, \"-m\", map5,\n\t\t\t\t\"--\", \"chown\", ugid, path, NULL };\n\t\tchar *args2[] = { \"lxc-usernsexec\", \"-m\", map1, \"-m\", map2,\n\t\t\t\t\"-m\", map3, \"-m\", map4, \"-m\", map5,\n\t\t\t\t\"--\", \"chown\", ugid, path, NULL };\n\n\t\t// save the current gid of \"path\"\n\t\tif (stat(path, &sb) < 0) {\n\t\t\tERROR(\"Error stat %s\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * A file has to be group-owned by a gid mapped into the\n\t\t * container, or the container won't be privileged over it.\n\t\t */\n\t\tif (sb.st_uid == geteuid() &&\n\t\t\t\tmapped_hostid(sb.st_gid, conf, ID_TYPE_GID) < 0 &&\n\t\t\t\tchown(path, -1, hostgid) < 0) {\n\t\t\tERROR(\"Failed chgrping %s\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"u:0:rootuid:1\"\n\t\tret = snprintf(map1, 100, \"u:0:%d:1\", rootuid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error uid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"u:hostuid:hostuid:1\"\n\t\tret = snprintf(map2, 100, \"u:%d:%d:1\", hostuid, hostuid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error uid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:0:rootgid:1\"\n\t\tret = snprintf(map3, 100, \"g:0:%d:1\", rootgid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:pathgid:rootgid+pathgid:1\"\n\t\tret = snprintf(map4, 100, \"g:%d:%d:1\", (gid_t)sb.st_gid,\n\t\t\t\trootgid + (gid_t)sb.st_gid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:hostgid:hostgid:1\"\n\t\tret = snprintf(map5, 100, \"g:%d:%d:1\", hostgid, hostgid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"0:pathgid\" (chown)\n\t\tret = snprintf(ugid, 100, \"0:%d\", (gid_t)sb.st_gid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error owner printing format string for chown\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (hostgid == sb.st_gid)\n\t\t\tret = execvp(\"lxc-usernsexec\", args1);\n\t\telse\n\t\t\tret = execvp(\"lxc-usernsexec\", args2);\n\t\tSYSERROR(\"Failed executing usernsexec\");\n\t\texit(1);\n\t}\n\treturn wait_for_pid(pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"error creating %s\"",
            "newpath"
          ],
          "line": 3134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "newpath",
            "0755"
          ],
          "line": 3133
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "241-262",
          "snippet": "extern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "newpath",
            "\"%s/%s/rootfs\"",
            "lxcpath",
            "newname"
          ],
          "line": 3132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "c->lxc_conf->unexpanded_config"
          ],
          "line": 3127
        },
        "resolved": true,
        "details": {
          "function_name": "free_init_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "706-715",
          "snippet": "static void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fout"
          ],
          "line": 3125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_config",
          "args": [
            "fout",
            "c->lxc_conf"
          ],
          "line": 3124
        },
        "resolved": true,
        "details": {
          "function_name": "write_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/confile.c",
          "lines": "2720-2730",
          "snippet": "void write_config(FILE *fout, struct lxc_conf *c)\n{\n\tsize_t len = c->unexpanded_len;\n\tint ret;\n\n\tif (!len)\n\t\treturn;\n\tret = fwrite(c->unexpanded_config, 1, len, fout);\n\tif (ret != len)\n\t\tSYSERROR(\"Error writing configuration file\");\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"network.h\"",
            "#include \"conf.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"confile.h\"",
            "#include \"config.h\"",
            "#include \"parse.h\"",
            "#include \"bdev.h\"",
            "#include <syslog.h>",
            "#include <dirent.h>",
            "#include <time.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int config_personality(const char *, const char *, struct lxc_conf *);",
            "static int config_pts(const char *, const char *, struct lxc_conf *);",
            "static int config_tty(const char *, const char *, struct lxc_conf *);",
            "static int config_ttydir(const char *, const char *, struct lxc_conf *);",
            "static int config_kmsg(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_aa_profile(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_aa_incomplete(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_se_context(const char *, const char *, struct lxc_conf *);",
            "static int config_cgroup(const char *, const char *, struct lxc_conf *);",
            "static int config_idmap(const char *, const char *, struct lxc_conf *);",
            "static int config_loglevel(const char *, const char *, struct lxc_conf *);",
            "static int config_logfile(const char *, const char *, struct lxc_conf *);",
            "static int config_mount(const char *, const char *, struct lxc_conf *);",
            "static int config_mount_auto(const char *, const char *, struct lxc_conf *);",
            "static int config_fstab(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_mount(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_options(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_backend(const char *, const char *, struct lxc_conf *);",
            "static int config_pivotdir(const char *, const char *, struct lxc_conf *);",
            "static int config_utsname(const char *, const char *, struct lxc_conf *);",
            "static int config_hook(const char *, const char *, struct lxc_conf *lxc_conf);",
            "static int config_network(const char *, const char *, struct lxc_conf *);",
            "static int config_network_type(const char *, const char *, struct lxc_conf *);",
            "static int config_network_flags(const char *, const char *, struct lxc_conf *);",
            "static int config_network_link(const char *, const char *, struct lxc_conf *);",
            "static int config_network_name(const char *, const char *, struct lxc_conf *);",
            "static int config_network_veth_pair(const char *, const char *, struct lxc_conf *);",
            "static int config_network_macvlan_mode(const char *, const char *, struct lxc_conf *);",
            "static int config_network_hwaddr(const char *, const char *, struct lxc_conf *);",
            "static int config_network_vlan_id(const char *, const char *, struct lxc_conf *);",
            "static int config_network_mtu(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv4(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv4_gateway(const char *, const char *, struct lxc_conf *);",
            "static int config_network_script_up(const char *, const char *, struct lxc_conf *);",
            "static int config_network_script_down(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv6(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv6_gateway(const char *, const char *, struct lxc_conf *);",
            "static int config_cap_drop(const char *, const char *, struct lxc_conf *);",
            "static int config_cap_keep(const char *, const char *, struct lxc_conf *);",
            "static int config_console(const char *, const char *, struct lxc_conf *);",
            "static int config_console_logfile(const char *, const char *, struct lxc_conf *);",
            "static int config_seccomp(const char *, const char *, struct lxc_conf *);",
            "static int config_includefile(const char *, const char *, struct lxc_conf *);",
            "static int config_network_nic(const char *, const char *, struct lxc_conf *);",
            "static int config_autodev(const char *, const char *, struct lxc_conf *);",
            "static int config_haltsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_rebootsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_stopsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_start(const char *, const char *, struct lxc_conf *);",
            "static int config_syslog(const char *, const char *, struct lxc_conf *);",
            "static int config_monitor(const char *, const char *, struct lxc_conf *);",
            "static int config_group(const char *, const char *, struct lxc_conf *);",
            "static int config_environment(const char *, const char *, struct lxc_conf *);",
            "static int config_init_cmd(const char *, const char *, struct lxc_conf *);",
            "static int config_init_uid(const char *, const char *, struct lxc_conf *);",
            "static int config_init_gid(const char *, const char *, struct lxc_conf *);",
            "static int config_ephemeral(const char *, const char *, struct lxc_conf *);",
            "static int config_no_new_privs(const char *, const char *, struct lxc_conf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"lxcseccomp.h\"\n#include \"network.h\"\n#include \"conf.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"confile.h\"\n#include \"config.h\"\n#include \"parse.h\"\n#include \"bdev.h\"\n#include <syslog.h>\n#include <dirent.h>\n#include <time.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int config_personality(const char *, const char *, struct lxc_conf *);\nstatic int config_pts(const char *, const char *, struct lxc_conf *);\nstatic int config_tty(const char *, const char *, struct lxc_conf *);\nstatic int config_ttydir(const char *, const char *, struct lxc_conf *);\nstatic int config_kmsg(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_aa_profile(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_aa_incomplete(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_se_context(const char *, const char *, struct lxc_conf *);\nstatic int config_cgroup(const char *, const char *, struct lxc_conf *);\nstatic int config_idmap(const char *, const char *, struct lxc_conf *);\nstatic int config_loglevel(const char *, const char *, struct lxc_conf *);\nstatic int config_logfile(const char *, const char *, struct lxc_conf *);\nstatic int config_mount(const char *, const char *, struct lxc_conf *);\nstatic int config_mount_auto(const char *, const char *, struct lxc_conf *);\nstatic int config_fstab(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_mount(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_options(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_backend(const char *, const char *, struct lxc_conf *);\nstatic int config_pivotdir(const char *, const char *, struct lxc_conf *);\nstatic int config_utsname(const char *, const char *, struct lxc_conf *);\nstatic int config_hook(const char *, const char *, struct lxc_conf *lxc_conf);\nstatic int config_network(const char *, const char *, struct lxc_conf *);\nstatic int config_network_type(const char *, const char *, struct lxc_conf *);\nstatic int config_network_flags(const char *, const char *, struct lxc_conf *);\nstatic int config_network_link(const char *, const char *, struct lxc_conf *);\nstatic int config_network_name(const char *, const char *, struct lxc_conf *);\nstatic int config_network_veth_pair(const char *, const char *, struct lxc_conf *);\nstatic int config_network_macvlan_mode(const char *, const char *, struct lxc_conf *);\nstatic int config_network_hwaddr(const char *, const char *, struct lxc_conf *);\nstatic int config_network_vlan_id(const char *, const char *, struct lxc_conf *);\nstatic int config_network_mtu(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv4(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv4_gateway(const char *, const char *, struct lxc_conf *);\nstatic int config_network_script_up(const char *, const char *, struct lxc_conf *);\nstatic int config_network_script_down(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv6(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv6_gateway(const char *, const char *, struct lxc_conf *);\nstatic int config_cap_drop(const char *, const char *, struct lxc_conf *);\nstatic int config_cap_keep(const char *, const char *, struct lxc_conf *);\nstatic int config_console(const char *, const char *, struct lxc_conf *);\nstatic int config_console_logfile(const char *, const char *, struct lxc_conf *);\nstatic int config_seccomp(const char *, const char *, struct lxc_conf *);\nstatic int config_includefile(const char *, const char *, struct lxc_conf *);\nstatic int config_network_nic(const char *, const char *, struct lxc_conf *);\nstatic int config_autodev(const char *, const char *, struct lxc_conf *);\nstatic int config_haltsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_rebootsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_stopsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_start(const char *, const char *, struct lxc_conf *);\nstatic int config_syslog(const char *, const char *, struct lxc_conf *);\nstatic int config_monitor(const char *, const char *, struct lxc_conf *);\nstatic int config_group(const char *, const char *, struct lxc_conf *);\nstatic int config_environment(const char *, const char *, struct lxc_conf *);\nstatic int config_init_cmd(const char *, const char *, struct lxc_conf *);\nstatic int config_init_uid(const char *, const char *, struct lxc_conf *);\nstatic int config_init_gid(const char *, const char *, struct lxc_conf *);\nstatic int config_ephemeral(const char *, const char *, struct lxc_conf *);\nstatic int config_no_new_privs(const char *, const char *, struct lxc_conf *);\n\nvoid write_config(FILE *fout, struct lxc_conf *c)\n{\n\tsize_t len = c->unexpanded_len;\n\tint ret;\n\n\tif (!len)\n\t\treturn;\n\tret = fwrite(c->unexpanded_config, 1, len, fout);\n\tif (ret != len)\n\t\tSYSERROR(\"Error writing configuration file\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fout"
          ],
          "line": 3120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Out of memory\""
          ],
          "line": 3119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "saved_unexp_conf"
          ],
          "line": 3117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"open %s\"",
            "newpath"
          ],
          "line": 3111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "newpath",
            "\"w\""
          ],
          "line": 3109
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error creating container dir for %s\"",
            "newpath"
          ],
          "line": 3100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_file_dirname",
          "args": [
            "newpath",
            "c->lxc_conf"
          ],
          "line": 3098
        },
        "resolved": true,
        "details": {
          "function_name": "create_file_dirname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "3045-3056",
          "snippet": "static int create_file_dirname(char *path, struct lxc_conf *conf)\n{\n\tchar *p = strrchr(path, '/');\n\tint ret = -1;\n\n\tif (!p)\n\t\treturn -1;\n\t*p = '\\0';\n\tret = do_create_container_dir(path, conf);\n\t*p = '/';\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic int create_file_dirname(char *path, struct lxc_conf *conf)\n{\n\tchar *p = strrchr(path, '/');\n\tint ret = -1;\n\n\tif (!p)\n\t\treturn -1;\n\t*p = '\\0';\n\tret = do_create_container_dir(path, conf);\n\t*p = '/';\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"error: clone: %s exists\"",
            "newpath"
          ],
          "line": 3094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_exists",
          "args": [
            "newpath"
          ],
          "line": 3093
        },
        "resolved": true,
        "details": {
          "function_name": "file_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1240-1245",
          "snippet": "bool file_exists(const char *f)\n{\n\tstruct stat statbuf;\n\n\treturn stat(f, &statbuf) == 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool file_exists(const char *f)\n{\n\tstruct stat statbuf;\n\n\treturn stat(f, &statbuf) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"clone: failed making config pathname\""
          ],
          "line": 3090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "newpath",
            "MAXPATHLEN",
            "\"%s/%s/config\"",
            "lxcpath",
            "newname"
          ],
          "line": 3088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_lxcapi_get_config_path",
          "args": [
            "c"
          ],
          "line": 3087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"error: Original container (%s) is running\"",
            "c->name"
          ],
          "line": 3079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_stopped",
          "args": [
            "c"
          ],
          "line": 3078
        },
        "resolved": true,
        "details": {
          "function_name": "is_stopped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "434-441",
          "snippet": "WRAP_API(const char *, lxcapi_state)\n\nstatic bool is_stopped(struct lxc_container *c)\n{\n\tlxc_state_t s;\n\ts = lxc_getstate(c->name, c->config_path);\n\treturn (s == STOPPED);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nWRAP_API(const char *, lxcapi_state)\n\nstatic bool is_stopped(struct lxc_container *c)\n{\n\tlxc_state_t s;\n\ts = lxc_getstate(c->name, c->config_path);\n\treturn (s == STOPPED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_mem_lock",
          "args": [
            "c"
          ],
          "line": 3075
        },
        "resolved": true,
        "details": {
          "function_name": "container_mem_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "342-345",
          "snippet": "int container_mem_lock(struct lxc_container *c)\n{\n\treturn lxclock(c->privlock, 0);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nint container_mem_lock(struct lxc_container *c)\n{\n\treturn lxclock(c->privlock, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_lxcapi_is_defined",
          "args": [
            "c"
          ],
          "line": 3072
        },
        "resolved": true,
        "details": {
          "function_name": "do_lxcapi_is_defined",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "327-348",
          "snippet": "static bool do_lxcapi_is_defined(struct lxc_container *c)\n{\n\tstruct stat statbuf;\n\tbool ret = false;\n\tint statret;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (container_mem_lock(c))\n\t\treturn false;\n\tif (!c->configfile)\n\t\tgoto out;\n\tstatret = stat(c->configfile, &statbuf);\n\tif (statret != 0)\n\t\tgoto out;\n\tret = true;\n\nout:\n\tcontainer_mem_unlock(c);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_is_defined(struct lxc_container *c)\n{\n\tstruct stat statbuf;\n\tbool ret = false;\n\tint statret;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (container_mem_lock(c))\n\t\treturn false;\n\tif (!c->configfile)\n\t\tgoto out;\n\tstatret = stat(c->configfile, &statbuf);\n\tif (statret != 0)\n\t\tgoto out;\n\tret = true;\n\nout:\n\tcontainer_mem_unlock(c);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic struct lxc_container *do_lxcapi_clone(struct lxc_container *c, const char *newname,\n\t\tconst char *lxcpath, int flags,\n\t\tconst char *bdevtype, const char *bdevdata, uint64_t newsize,\n\t\tchar **hookargs)\n{\n\tstruct lxc_container *c2 = NULL;\n\tchar newpath[MAXPATHLEN];\n\tint ret, storage_copied = 0;\n\tchar *origroot = NULL, *saved_unexp_conf = NULL;\n\tstruct clone_update_data data;\n\tsize_t saved_unexp_len;\n\tFILE *fout;\n\tpid_t pid;\n\n\tif (!c || !do_lxcapi_is_defined(c))\n\t\treturn NULL;\n\n\tif (container_mem_lock(c))\n\t\treturn NULL;\n\n\tif (!is_stopped(c)) {\n\t\tERROR(\"error: Original container (%s) is running\", c->name);\n\t\tgoto out;\n\t}\n\n\t// Make sure the container doesn't yet exist.\n\tif (!newname)\n\t\tnewname = c->name;\n\tif (!lxcpath)\n\t\tlxcpath = do_lxcapi_get_config_path(c);\n\tret = snprintf(newpath, MAXPATHLEN, \"%s/%s/config\", lxcpath, newname);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"clone: failed making config pathname\");\n\t\tgoto out;\n\t}\n\tif (file_exists(newpath)) {\n\t\tERROR(\"error: clone: %s exists\", newpath);\n\t\tgoto out;\n\t}\n\n\tret = create_file_dirname(newpath, c->lxc_conf);\n\tif (ret < 0 && errno != EEXIST) {\n\t\tERROR(\"Error creating container dir for %s\", newpath);\n\t\tgoto out;\n\t}\n\n\t// copy the configuration, tweak it as needed,\n\tif (c->lxc_conf->rootfs.path) {\n\t\torigroot = c->lxc_conf->rootfs.path;\n\t\tc->lxc_conf->rootfs.path = NULL;\n\t}\n\tfout = fopen(newpath, \"w\");\n\tif (!fout) {\n\t\tSYSERROR(\"open %s\", newpath);\n\t\tgoto out;\n\t}\n\n\tsaved_unexp_conf = c->lxc_conf->unexpanded_config;\n\tsaved_unexp_len = c->lxc_conf->unexpanded_len;\n\tc->lxc_conf->unexpanded_config = strdup(saved_unexp_conf);\n\tif (!c->lxc_conf->unexpanded_config) {\n\t\tERROR(\"Out of memory\");\n\t\tfclose(fout);\n\t\tgoto out;\n\t}\n\tclear_unexp_config_line(c->lxc_conf, \"lxc.rootfs\", false);\n\twrite_config(fout, c->lxc_conf);\n\tfclose(fout);\n\tc->lxc_conf->rootfs.path = origroot;\n\tfree(c->lxc_conf->unexpanded_config);\n\tc->lxc_conf->unexpanded_config = saved_unexp_conf;\n\tsaved_unexp_conf = NULL;\n\tc->lxc_conf->unexpanded_len = saved_unexp_len;\n\n\tsprintf(newpath, \"%s/%s/rootfs\", lxcpath, newname);\n\tif (mkdir(newpath, 0755) < 0) {\n\t\tSYSERROR(\"error creating %s\", newpath);\n\t\tgoto out;\n\t}\n\n\tif (am_unpriv()) {\n\t\tif (chown_mapped_root(newpath, c->lxc_conf) < 0) {\n\t\t\tERROR(\"Error chowning %s to container root\", newpath);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tc2 = lxc_container_new(newname, lxcpath);\n\tif (!c2) {\n\t\tERROR(\"clone: failed to create new container (%s %s)\", newname,\n\t\t\t\tlxcpath);\n\t\tgoto out;\n\t}\n\n\t// copy/snapshot rootfs's\n\tret = copy_storage(c, c2, bdevtype, flags, bdevdata, newsize);\n\tif (ret < 0)\n\t\tgoto out;\n\n\n\t// update utsname\n\tif (!(flags & LXC_CLONE_KEEPNAME)) {\n\t\tclear_unexp_config_line(c2->lxc_conf, \"lxc.utsname\", false);\n\n\t\tif (!set_config_item_locked(c2, \"lxc.utsname\", newname)) {\n\t\t\tERROR(\"Error setting new hostname\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t// copy hooks\n\tret = copyhooks(c, c2);\n\tif (ret < 0) {\n\t\tERROR(\"error copying hooks\");\n\t\tgoto out;\n\t}\n\n\tif (copy_fstab(c, c2) < 0) {\n\t\tERROR(\"error copying fstab\");\n\t\tgoto out;\n\t}\n\n\t// update macaddrs\n\tif (!(flags & LXC_CLONE_KEEPMACADDR)) {\n\t\tif (!network_new_hwaddrs(c2->lxc_conf)) {\n\t\t\tERROR(\"Error updating mac addresses\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t// update absolute paths for overlay mount directories\n\tif (ovl_update_abs_paths(c2->lxc_conf, c->config_path, c->name, lxcpath, newname) < 0)\n\t\tgoto out;\n\n\t// We've now successfully created c2's storage, so clear it out if we\n\t// fail after this\n\tstorage_copied = 1;\n\n\tif (!c2->save_config(c2, NULL))\n\t\tgoto out;\n\n\tif ((pid = fork()) < 0) {\n\t\tSYSERROR(\"fork\");\n\t\tgoto out;\n\t}\n\tif (pid > 0) {\n\t\tret = wait_for_pid(pid);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tcontainer_mem_unlock(c);\n\t\treturn c2;\n\t}\n\tdata.c0 = c;\n\tdata.c1 = c2;\n\tdata.flags = flags;\n\tdata.hookargs = hookargs;\n\tif (am_unpriv())\n\t\tret = userns_exec_1(c->lxc_conf, clone_update_rootfs_wrapper,\n\t\t\t\t&data);\n\telse\n\t\tret = clone_update_rootfs(&data);\n\tif (ret < 0)\n\t\texit(1);\n\n\tcontainer_mem_unlock(c);\n\texit(0);\n\nout:\n\tcontainer_mem_unlock(c);\n\tif (c2) {\n\t\tif (!storage_copied)\n\t\t\tc2->lxc_conf->rootfs.path = NULL;\n\t\tc2->destroy(c2);\n\t\tlxc_container_put(c2);\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "create_file_dirname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "3045-3056",
    "snippet": "static int create_file_dirname(char *path, struct lxc_conf *conf)\n{\n\tchar *p = strrchr(path, '/');\n\tint ret = -1;\n\n\tif (!p)\n\t\treturn -1;\n\t*p = '\\0';\n\tret = do_create_container_dir(path, conf);\n\t*p = '/';\n\treturn ret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_create_container_dir",
          "args": [
            "path",
            "conf"
          ],
          "line": 3053
        },
        "resolved": true,
        "details": {
          "function_name": "do_create_container_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "966-989",
          "snippet": "static int do_create_container_dir(const char *path, struct lxc_conf *conf)\n{\n\tint ret = -1, lasterr;\n\tchar *p = alloca(strlen(path)+1);\n\tmode_t mask = umask(0002);\n\tret = mkdir(path, 0770);\n\tlasterr = errno;\n\tumask(mask);\n\terrno = lasterr;\n\tif (ret) {\n\t\tif (errno == EEXIST)\n\t\t\tret = 0;\n\t\telse {\n\t\t\tSYSERROR(\"failed to create container path %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tstrcpy(p, path);\n\tif (!lxc_list_empty(&conf->id_map) && chown_mapped_root(p, conf) != 0) {\n\t\tERROR(\"Failed to chown container dir\");\n\t\tret = -1;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic int do_create_container_dir(const char *path, struct lxc_conf *conf)\n{\n\tint ret = -1, lasterr;\n\tchar *p = alloca(strlen(path)+1);\n\tmode_t mask = umask(0002);\n\tret = mkdir(path, 0770);\n\tlasterr = errno;\n\tumask(mask);\n\terrno = lasterr;\n\tif (ret) {\n\t\tif (errno == EEXIST)\n\t\t\tret = 0;\n\t\telse {\n\t\t\tSYSERROR(\"failed to create container path %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tstrcpy(p, path);\n\tif (!lxc_list_empty(&conf->id_map) && chown_mapped_root(p, conf) != 0) {\n\t\tERROR(\"Failed to chown container dir\");\n\t\tret = -1;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "path",
            "'/'"
          ],
          "line": 3047
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic int create_file_dirname(char *path, struct lxc_conf *conf)\n{\n\tchar *p = strrchr(path, '/');\n\tint ret = -1;\n\n\tif (!p)\n\t\treturn -1;\n\t*p = '\\0';\n\tret = do_create_container_dir(path, conf);\n\t*p = '/';\n\treturn ret;\n}"
  },
  {
    "function_name": "clone_update_rootfs_wrapper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "3027-3031",
    "snippet": "static int clone_update_rootfs_wrapper(void *data)\n{\n\tstruct clone_update_data *arg = (struct clone_update_data *) data;\n\treturn clone_update_rootfs(arg);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clone_update_rootfs",
          "args": [
            "arg"
          ],
          "line": 3030
        },
        "resolved": true,
        "details": {
          "function_name": "clone_update_rootfs_wrapper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "3027-3031",
          "snippet": "static int clone_update_rootfs_wrapper(void *data)\n{\n\tstruct clone_update_data *arg = (struct clone_update_data *) data;\n\treturn clone_update_rootfs(arg);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic int clone_update_rootfs_wrapper(void *data)\n{\n\tstruct clone_update_data *arg = (struct clone_update_data *) data;\n\treturn clone_update_rootfs(arg);\n}"
  },
  {
    "function_name": "clone_update_rootfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "2925-3025",
    "snippet": "static int clone_update_rootfs(struct clone_update_data *data)\n{\n\tstruct lxc_container *c0 = data->c0;\n\tstruct lxc_container *c = data->c1;\n\tint flags = data->flags;\n\tchar **hookargs = data->hookargs;\n\tint ret = -1;\n\tchar path[MAXPATHLEN];\n\tstruct bdev *bdev;\n\tFILE *fout;\n\tstruct lxc_conf *conf = c->lxc_conf;\n\n\t/* update hostname in rootfs */\n\t/* we're going to mount, so run in a clean namespace to simplify cleanup */\n\n\tif (setgid(0) < 0) {\n\t\tERROR(\"Failed to setgid to 0\");\n\t\treturn -1;\n\t}\n\tif (setuid(0) < 0) {\n\t\tERROR(\"Failed to setuid to 0\");\n\t\treturn -1;\n\t}\n\tif (setgroups(0, NULL) < 0)\n\t\tWARN(\"Failed to clear groups\");\n\n\tif (unshare(CLONE_NEWNS) < 0)\n\t\treturn -1;\n\tbdev = bdev_init(c->lxc_conf, c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);\n\tif (!bdev)\n\t\treturn -1;\n\tif (strcmp(bdev->type, \"dir\") != 0) {\n\t\tif (unshare(CLONE_NEWNS) < 0) {\n\t\t\tERROR(\"error unsharing mounts\");\n\t\t\tbdev_put(bdev);\n\t\t\treturn -1;\n\t\t}\n\t\tif (detect_shared_rootfs()) {\n\t\t\tif (mount(NULL, \"/\", NULL, MS_SLAVE|MS_REC, NULL)) {\n\t\t\t\tSYSERROR(\"Failed to make / rslave\");\n\t\t\t\tERROR(\"Continuing...\");\n\t\t\t}\n\t\t}\n\t\tif (bdev->ops->mount(bdev) < 0) {\n\t\t\tbdev_put(bdev);\n\t\t\treturn -1;\n\t\t}\n\t} else { // TODO come up with a better way\n\t\tfree(bdev->dest);\n\t\tbdev->dest = strdup(bdev->src);\n\t}\n\n\tif (!lxc_list_empty(&conf->hooks[LXCHOOK_CLONE])) {\n\t\t/* Start of environment variable setup for hooks */\n\t\tif (c0->name && setenv(\"LXC_SRC_NAME\", c0->name, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for source container name\");\n\t\t}\n\t\tif (c->name && setenv(\"LXC_NAME\", c->name, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for container name\");\n\t\t}\n\t\tif (conf->rcfile && setenv(\"LXC_CONFIG_FILE\", conf->rcfile, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for config path\");\n\t\t}\n\t\tif (bdev->dest && setenv(\"LXC_ROOTFS_MOUNT\", bdev->dest, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for rootfs mount\");\n\t\t}\n\t\tif (conf->rootfs.path && setenv(\"LXC_ROOTFS_PATH\", conf->rootfs.path, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for rootfs mount\");\n\t\t}\n\n\t\tif (run_lxc_hooks(c->name, \"clone\", conf, c->get_config_path(c), hookargs)) {\n\t\t\tERROR(\"Error executing clone hook for %s\", c->name);\n\t\t\tbdev_put(bdev);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!(flags & LXC_CLONE_KEEPNAME)) {\n\t\tret = snprintf(path, MAXPATHLEN, \"%s/etc/hostname\", bdev->dest);\n\t\tbdev_put(bdev);\n\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn -1;\n\t\tif (!file_exists(path))\n\t\t\treturn 0;\n\t\tif (!(fout = fopen(path, \"w\"))) {\n\t\t\tSYSERROR(\"unable to open %s: ignoring\", path);\n\t\t\treturn 0;\n\t\t}\n\t\tif (fprintf(fout, \"%s\", c->name) < 0) {\n\t\t\tfclose(fout);\n\t\t\treturn -1;\n\t\t}\n\t\tif (fclose(fout) < 0)\n\t\t\treturn -1;\n\t}\n\telse\n\t\tbdev_put(bdev);\n\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdev_put",
          "args": [
            "bdev"
          ],
          "line": 3022
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "579-585",
          "snippet": "void bdev_put(struct bdev *bdev)\n{\n\tfree(bdev->mntopts);\n\tfree(bdev->src);\n\tfree(bdev->dest);\n\tfree(bdev);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);",
            "static char *linkderef(char *path, char *dest);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);\nstatic char *linkderef(char *path, char *dest);\n\nvoid bdev_put(struct bdev *bdev)\n{\n\tfree(bdev->mntopts);\n\tfree(bdev->src);\n\tfree(bdev->dest);\n\tfree(bdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fout"
          ],
          "line": 3018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fout"
          ],
          "line": 3015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fout",
            "\"%s\"",
            "c->name"
          ],
          "line": 3014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"unable to open %s: ignoring\"",
            "path"
          ],
          "line": 3011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "path",
            "\"w\""
          ],
          "line": 3010
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_exists",
          "args": [
            "path"
          ],
          "line": 3008
        },
        "resolved": true,
        "details": {
          "function_name": "file_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1240-1245",
          "snippet": "bool file_exists(const char *f)\n{\n\tstruct stat statbuf;\n\n\treturn stat(f, &statbuf) == 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool file_exists(const char *f)\n{\n\tstruct stat statbuf;\n\n\treturn stat(f, &statbuf) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "MAXPATHLEN",
            "\"%s/etc/hostname\"",
            "bdev->dest"
          ],
          "line": 3003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error executing clone hook for %s\"",
            "c->name"
          ],
          "line": 2996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run_lxc_hooks",
          "args": [
            "c->name",
            "\"clone\"",
            "conf",
            "c->get_config_path(c)",
            "hookargs"
          ],
          "line": 2995
        },
        "resolved": true,
        "details": {
          "function_name": "run_lxc_hooks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3995-4029",
          "snippet": "int run_lxc_hooks(const char *name, char *hook, struct lxc_conf *conf,\n\t\t  const char *lxcpath, char *argv[])\n{\n\tint which = -1;\n\tstruct lxc_list *it;\n\n\tif (strcmp(hook, \"pre-start\") == 0)\n\t\twhich = LXCHOOK_PRESTART;\n\telse if (strcmp(hook, \"pre-mount\") == 0)\n\t\twhich = LXCHOOK_PREMOUNT;\n\telse if (strcmp(hook, \"mount\") == 0)\n\t\twhich = LXCHOOK_MOUNT;\n\telse if (strcmp(hook, \"autodev\") == 0)\n\t\twhich = LXCHOOK_AUTODEV;\n\telse if (strcmp(hook, \"start\") == 0)\n\t\twhich = LXCHOOK_START;\n\telse if (strcmp(hook, \"stop\") == 0)\n\t\twhich = LXCHOOK_STOP;\n\telse if (strcmp(hook, \"post-stop\") == 0)\n\t\twhich = LXCHOOK_POSTSTOP;\n\telse if (strcmp(hook, \"clone\") == 0)\n\t\twhich = LXCHOOK_CLONE;\n\telse if (strcmp(hook, \"destroy\") == 0)\n\t\twhich = LXCHOOK_DESTROY;\n\telse\n\t\treturn -1;\n\tlxc_list_for_each(it, &conf->hooks[which]) {\n\t\tint ret;\n\t\tchar *hookname = it->elem;\n\t\tret = run_script_argv(name, \"lxc\", hookname, hook, lxcpath, argv);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint run_lxc_hooks(const char *name, char *hook, struct lxc_conf *conf,\n\t\t  const char *lxcpath, char *argv[])\n{\n\tint which = -1;\n\tstruct lxc_list *it;\n\n\tif (strcmp(hook, \"pre-start\") == 0)\n\t\twhich = LXCHOOK_PRESTART;\n\telse if (strcmp(hook, \"pre-mount\") == 0)\n\t\twhich = LXCHOOK_PREMOUNT;\n\telse if (strcmp(hook, \"mount\") == 0)\n\t\twhich = LXCHOOK_MOUNT;\n\telse if (strcmp(hook, \"autodev\") == 0)\n\t\twhich = LXCHOOK_AUTODEV;\n\telse if (strcmp(hook, \"start\") == 0)\n\t\twhich = LXCHOOK_START;\n\telse if (strcmp(hook, \"stop\") == 0)\n\t\twhich = LXCHOOK_STOP;\n\telse if (strcmp(hook, \"post-stop\") == 0)\n\t\twhich = LXCHOOK_POSTSTOP;\n\telse if (strcmp(hook, \"clone\") == 0)\n\t\twhich = LXCHOOK_CLONE;\n\telse if (strcmp(hook, \"destroy\") == 0)\n\t\twhich = LXCHOOK_DESTROY;\n\telse\n\t\treturn -1;\n\tlxc_list_for_each(it, &conf->hooks[which]) {\n\t\tint ret;\n\t\tchar *hookname = it->elem;\n\t\tret = run_script_argv(name, \"lxc\", hookname, hook, lxcpath, argv);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->get_config_path",
          "args": [
            "c"
          ],
          "line": 2995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to set environment variable for rootfs mount\""
          ],
          "line": 2992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"LXC_ROOTFS_PATH\"",
            "conf->rootfs.path",
            "1"
          ],
          "line": 2991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to set environment variable for rootfs mount\""
          ],
          "line": 2989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"LXC_ROOTFS_MOUNT\"",
            "bdev->dest",
            "1"
          ],
          "line": 2988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to set environment variable for config path\""
          ],
          "line": 2986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"LXC_CONFIG_FILE\"",
            "conf->rcfile",
            "1"
          ],
          "line": 2985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to set environment variable for container name\""
          ],
          "line": 2983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"LXC_NAME\"",
            "c->name",
            "1"
          ],
          "line": 2982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to set environment variable for source container name\""
          ],
          "line": 2980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"LXC_SRC_NAME\"",
            "c0->name",
            "1"
          ],
          "line": 2979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_empty",
          "args": [
            "&conf->hooks[LXCHOOK_CLONE]"
          ],
          "line": 2977
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "94-97",
          "snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "bdev->src"
          ],
          "line": 2974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "bdev->dest"
          ],
          "line": 2973
        },
        "resolved": true,
        "details": {
          "function_name": "free_init_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "706-715",
          "snippet": "static void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev->ops->mount",
          "args": [
            "bdev"
          ],
          "line": 2968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Continuing...\""
          ],
          "line": 2965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to make / rslave\""
          ],
          "line": 2964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "NULL",
            "\"/\"",
            "NULL",
            "MS_SLAVE|MS_REC",
            "NULL"
          ],
          "line": 2963
        },
        "resolved": true,
        "details": {
          "function_name": "mount_entry_on_generic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1838-1869",
          "snippet": "static inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "detect_shared_rootfs",
          "args": [],
          "line": 2962
        },
        "resolved": true,
        "details": {
          "function_name": "detect_shared_rootfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1102-1132",
          "snippet": "int detect_shared_rootfs(void)\n{\n\tchar buf[LXC_LINELEN], *p;\n\tFILE *f;\n\tint i;\n\tchar *p2;\n\n\tf = fopen(\"/proc/self/mountinfo\", \"r\");\n\tif (!f)\n\t\treturn 0;\n\twhile (fgets(buf, LXC_LINELEN, f)) {\n\t\tfor (p = buf, i = 0; p && i < 4; i++)\n\t\t\tp = strchr(p + 1, ' ');\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tp2 = strchr(p + 1, ' ');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\t\tif (strcmp(p + 1, \"/\") == 0) {\n\t\t\t// this is '/'.  is it shared?\n\t\t\tp = strchr(p2 + 1, ' ');\n\t\t\tif (p && strstr(p, \"shared:\")) {\n\t\t\t\tfclose(f);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tfclose(f);\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint detect_shared_rootfs(void)\n{\n\tchar buf[LXC_LINELEN], *p;\n\tFILE *f;\n\tint i;\n\tchar *p2;\n\n\tf = fopen(\"/proc/self/mountinfo\", \"r\");\n\tif (!f)\n\t\treturn 0;\n\twhile (fgets(buf, LXC_LINELEN, f)) {\n\t\tfor (p = buf, i = 0; p && i < 4; i++)\n\t\t\tp = strchr(p + 1, ' ');\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tp2 = strchr(p + 1, ' ');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\t\tif (strcmp(p + 1, \"/\") == 0) {\n\t\t\t// this is '/'.  is it shared?\n\t\t\tp = strchr(p2 + 1, ' ');\n\t\t\tif (p && strstr(p, \"shared:\")) {\n\t\t\t\tfclose(f);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tfclose(f);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"error unsharing mounts\""
          ],
          "line": 2958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unshare",
          "args": [
            "CLONE_NEWNS"
          ],
          "line": 2957
        },
        "resolved": true,
        "details": {
          "function_name": "unshare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.h",
          "lines": "73-81",
          "snippet": "static inline int unshare(int flags)\n{\n#ifdef __NR_unshare\n\treturn syscall(__NR_unshare, flags);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}",
          "includes": [
            "#include <stdint.h>",
            "#  include <sys/signalfd.h>",
            "#include <../include/getline.h>",
            "#include \"initutils.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#  include <sys/signalfd.h>\n#include <../include/getline.h>\n#include \"initutils.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic inline int unshare(int flags)\n{\n#ifdef __NR_unshare\n\treturn syscall(__NR_unshare, flags);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "bdev->type",
            "\"dir\""
          ],
          "line": 2956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_init",
          "args": [
            "c->lxc_conf",
            "c->lxc_conf->rootfs.path",
            "c->lxc_conf->rootfs.mount",
            "NULL"
          ],
          "line": 2953
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "533-565",
          "snippet": "struct bdev *bdev_init(struct lxc_conf *conf, const char *src, const char *dst,\n\t\tconst char *mntopts)\n{\n\tstruct bdev *bdev;\n\tconst struct bdev_type *q;\n\n\tif (!src)\n\t\tsrc = conf->rootfs.path;\n\n\tif (!src)\n\t\treturn NULL;\n\n\tq = bdev_query(conf, src);\n\tif (!q)\n\t\treturn NULL;\n\n\tbdev = malloc(sizeof(struct bdev));\n\tif (!bdev)\n\t\treturn NULL;\n\tmemset(bdev, 0, sizeof(struct bdev));\n\tbdev->ops = q->ops;\n\tbdev->type = q->name;\n\tif (mntopts)\n\t\tbdev->mntopts = strdup(mntopts);\n\tif (src)\n\t\tbdev->src = strdup(src);\n\tif (dst)\n\t\tbdev->dest = strdup(dst);\n\tif (strcmp(bdev->type, \"nbd\") == 0)\n\t\tbdev->nbd_idx = conf->nbd_idx;\n\n\treturn bdev;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);",
            "static struct bdev *bdev_get(const char *type);",
            "static char *linkderef(char *path, char *dest);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);\nstatic struct bdev *bdev_get(const char *type);\nstatic char *linkderef(char *path, char *dest);\n\nstruct bdev *bdev_init(struct lxc_conf *conf, const char *src, const char *dst,\n\t\tconst char *mntopts)\n{\n\tstruct bdev *bdev;\n\tconst struct bdev_type *q;\n\n\tif (!src)\n\t\tsrc = conf->rootfs.path;\n\n\tif (!src)\n\t\treturn NULL;\n\n\tq = bdev_query(conf, src);\n\tif (!q)\n\t\treturn NULL;\n\n\tbdev = malloc(sizeof(struct bdev));\n\tif (!bdev)\n\t\treturn NULL;\n\tmemset(bdev, 0, sizeof(struct bdev));\n\tbdev->ops = q->ops;\n\tbdev->type = q->name;\n\tif (mntopts)\n\t\tbdev->mntopts = strdup(mntopts);\n\tif (src)\n\t\tbdev->src = strdup(src);\n\tif (dst)\n\t\tbdev->dest = strdup(dst);\n\tif (strcmp(bdev->type, \"nbd\") == 0)\n\t\tbdev->nbd_idx = conf->nbd_idx;\n\n\treturn bdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to clear groups\""
          ],
          "line": 2949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setgroups",
          "args": [
            "0",
            "NULL"
          ],
          "line": 2948
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_setgroups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "2063-2072",
          "snippet": "int lxc_setgroups(int size, gid_t list[])\n{\n\tif (setgroups(size, list) < 0) {\n\t\tSYSERROR(\"Failed to setgroups().\");\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Dropped additional groups.\");\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_setgroups(int size, gid_t list[])\n{\n\tif (setgroups(size, list) < 0) {\n\t\tSYSERROR(\"Failed to setgroups().\");\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Dropped additional groups.\");\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to setuid to 0\""
          ],
          "line": 2945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setuid",
          "args": [
            "0"
          ],
          "line": 2944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to setgid to 0\""
          ],
          "line": 2941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setgid",
          "args": [
            "0"
          ],
          "line": 2940
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic int clone_update_rootfs(struct clone_update_data *data)\n{\n\tstruct lxc_container *c0 = data->c0;\n\tstruct lxc_container *c = data->c1;\n\tint flags = data->flags;\n\tchar **hookargs = data->hookargs;\n\tint ret = -1;\n\tchar path[MAXPATHLEN];\n\tstruct bdev *bdev;\n\tFILE *fout;\n\tstruct lxc_conf *conf = c->lxc_conf;\n\n\t/* update hostname in rootfs */\n\t/* we're going to mount, so run in a clean namespace to simplify cleanup */\n\n\tif (setgid(0) < 0) {\n\t\tERROR(\"Failed to setgid to 0\");\n\t\treturn -1;\n\t}\n\tif (setuid(0) < 0) {\n\t\tERROR(\"Failed to setuid to 0\");\n\t\treturn -1;\n\t}\n\tif (setgroups(0, NULL) < 0)\n\t\tWARN(\"Failed to clear groups\");\n\n\tif (unshare(CLONE_NEWNS) < 0)\n\t\treturn -1;\n\tbdev = bdev_init(c->lxc_conf, c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);\n\tif (!bdev)\n\t\treturn -1;\n\tif (strcmp(bdev->type, \"dir\") != 0) {\n\t\tif (unshare(CLONE_NEWNS) < 0) {\n\t\t\tERROR(\"error unsharing mounts\");\n\t\t\tbdev_put(bdev);\n\t\t\treturn -1;\n\t\t}\n\t\tif (detect_shared_rootfs()) {\n\t\t\tif (mount(NULL, \"/\", NULL, MS_SLAVE|MS_REC, NULL)) {\n\t\t\t\tSYSERROR(\"Failed to make / rslave\");\n\t\t\t\tERROR(\"Continuing...\");\n\t\t\t}\n\t\t}\n\t\tif (bdev->ops->mount(bdev) < 0) {\n\t\t\tbdev_put(bdev);\n\t\t\treturn -1;\n\t\t}\n\t} else { // TODO come up with a better way\n\t\tfree(bdev->dest);\n\t\tbdev->dest = strdup(bdev->src);\n\t}\n\n\tif (!lxc_list_empty(&conf->hooks[LXCHOOK_CLONE])) {\n\t\t/* Start of environment variable setup for hooks */\n\t\tif (c0->name && setenv(\"LXC_SRC_NAME\", c0->name, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for source container name\");\n\t\t}\n\t\tif (c->name && setenv(\"LXC_NAME\", c->name, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for container name\");\n\t\t}\n\t\tif (conf->rcfile && setenv(\"LXC_CONFIG_FILE\", conf->rcfile, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for config path\");\n\t\t}\n\t\tif (bdev->dest && setenv(\"LXC_ROOTFS_MOUNT\", bdev->dest, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for rootfs mount\");\n\t\t}\n\t\tif (conf->rootfs.path && setenv(\"LXC_ROOTFS_PATH\", conf->rootfs.path, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for rootfs mount\");\n\t\t}\n\n\t\tif (run_lxc_hooks(c->name, \"clone\", conf, c->get_config_path(c), hookargs)) {\n\t\t\tERROR(\"Error executing clone hook for %s\", c->name);\n\t\t\tbdev_put(bdev);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!(flags & LXC_CLONE_KEEPNAME)) {\n\t\tret = snprintf(path, MAXPATHLEN, \"%s/etc/hostname\", bdev->dest);\n\t\tbdev_put(bdev);\n\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn -1;\n\t\tif (!file_exists(path))\n\t\t\treturn 0;\n\t\tif (!(fout = fopen(path, \"w\"))) {\n\t\t\tSYSERROR(\"unable to open %s: ignoring\", path);\n\t\t\treturn 0;\n\t\t}\n\t\tif (fprintf(fout, \"%s\", c->name) < 0) {\n\t\t\tfclose(fout);\n\t\t\treturn -1;\n\t\t}\n\t\tif (fclose(fout) < 0)\n\t\t\treturn -1;\n\t}\n\telse\n\t\tbdev_put(bdev);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "copy_storage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "2854-2916",
    "snippet": "static int copy_storage(struct lxc_container *c0, struct lxc_container *c,\n\t\t\tconst char *newtype, int flags, const char *bdevdata,\n\t\t\tuint64_t newsize)\n{\n\tstruct bdev *bdev;\n\tint need_rdep;\n\n\tif (should_default_to_snapshot(c0, c))\n\t\tflags |= LXC_CLONE_SNAPSHOT;\n\n\tbdev = bdev_copy(c0, c->name, c->config_path, newtype, flags, bdevdata,\n\t\t\t newsize, &need_rdep);\n\tif (!bdev) {\n\t\tERROR(\"Error copying storage.\");\n\t\treturn -1;\n\t}\n\n\t/* Set new rootfs. */\n\tfree(c->lxc_conf->rootfs.path);\n\tc->lxc_conf->rootfs.path = strdup(bdev->src);\n\n\t/* Set new bdev type. */\n\tfree(c->lxc_conf->rootfs.bdev_type);\n\tc->lxc_conf->rootfs.bdev_type = strdup(bdev->type);\n\tbdev_put(bdev);\n\n\tif (!c->lxc_conf->rootfs.path) {\n\t\tERROR(\"Out of memory while setting storage path.\");\n\t\treturn -1;\n\t}\n\tif (!c->lxc_conf->rootfs.bdev_type) {\n\t\tERROR(\"Out of memory while setting rootfs backend.\");\n\t\treturn -1;\n\t}\n\n\t/* Append a new lxc.rootfs entry to the unexpanded config. */\n\tclear_unexp_config_line(c->lxc_conf, \"lxc.rootfs\", false);\n\tif (!do_append_unexp_config_line(c->lxc_conf, \"lxc.rootfs\",\n\t\t\t\t\t c->lxc_conf->rootfs.path)) {\n\t\tERROR(\"Error saving new rootfs to cloned config.\");\n\t\treturn -1;\n\t}\n\n\t/* Append a new lxc.rootfs.backend entry to the unexpanded config. */\n\tclear_unexp_config_line(c->lxc_conf, \"lxc.rootfs.backend\", false);\n\tif (!do_append_unexp_config_line(c->lxc_conf, \"lxc.rootfs.backend\",\n\t\t\t\t\t c->lxc_conf->rootfs.bdev_type)) {\n\t\tERROR(\"Error saving new rootfs backend to cloned config.\");\n\t\treturn -1;\n\t}\n\n\tif (flags & LXC_CLONE_SNAPSHOT)\n\t\tcopy_rdepends(c, c0);\n\tif (need_rdep) {\n\t\tif (!add_rdepends(c, c0))\n\t\t\tWARN(\"Error adding reverse dependency from %s to %s\",\n\t\t\t     c->name, c0->name);\n\t}\n\n\tmod_all_rdeps(c, true);\n\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mod_all_rdeps",
          "args": [
            "c",
            "true"
          ],
          "line": 2913
        },
        "resolved": true,
        "details": {
          "function_name": "mod_all_rdeps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2223-2261",
          "snippet": "void mod_all_rdeps(struct lxc_container *c, bool inc)\n{\n\tstruct lxc_container *p;\n\tchar *lxcpath = NULL, *lxcname = NULL, path[MAXPATHLEN];\n\tsize_t pathlen = 0, namelen = 0;\n\tFILE *f;\n\tint ret;\n\n\tret = snprintf(path, MAXPATHLEN, \"%s/%s/lxc_rdepends\",\n\t\tc->config_path, c->name);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tERROR(\"Path name too long\");\n\t\treturn;\n\t}\n\tf = fopen(path, \"r\");\n\tif (f == NULL)\n\t\treturn;\n\twhile (getline(&lxcpath, &pathlen, f) != -1) {\n\t\tif (getline(&lxcname, &namelen, f) == -1) {\n\t\t\tERROR(\"badly formatted file %s\", path);\n\t\t\tgoto out;\n\t\t}\n\t\tstrip_newline(lxcpath);\n\t\tstrip_newline(lxcname);\n\t\tif ((p = lxc_container_new(lxcname, lxcpath)) == NULL) {\n\t\t\tERROR(\"Unable to find dependent container %s:%s\",\n\t\t\t\tlxcpath, lxcname);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!mod_rdep(p, c, inc))\n\t\t\tERROR(\"Failed to update snapshots file for %s:%s\",\n\t\t\t\tlxcpath, lxcname);\n\t\tlxc_container_put(p);\n\t}\nout:\n\tfree(lxcpath);\n\tfree(lxcname);\n\tfclose(f);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nvoid mod_all_rdeps(struct lxc_container *c, bool inc)\n{\n\tstruct lxc_container *p;\n\tchar *lxcpath = NULL, *lxcname = NULL, path[MAXPATHLEN];\n\tsize_t pathlen = 0, namelen = 0;\n\tFILE *f;\n\tint ret;\n\n\tret = snprintf(path, MAXPATHLEN, \"%s/%s/lxc_rdepends\",\n\t\tc->config_path, c->name);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tERROR(\"Path name too long\");\n\t\treturn;\n\t}\n\tf = fopen(path, \"r\");\n\tif (f == NULL)\n\t\treturn;\n\twhile (getline(&lxcpath, &pathlen, f) != -1) {\n\t\tif (getline(&lxcname, &namelen, f) == -1) {\n\t\t\tERROR(\"badly formatted file %s\", path);\n\t\t\tgoto out;\n\t\t}\n\t\tstrip_newline(lxcpath);\n\t\tstrip_newline(lxcname);\n\t\tif ((p = lxc_container_new(lxcname, lxcpath)) == NULL) {\n\t\t\tERROR(\"Unable to find dependent container %s:%s\",\n\t\t\t\tlxcpath, lxcname);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!mod_rdep(p, c, inc))\n\t\t\tERROR(\"Failed to update snapshots file for %s:%s\",\n\t\t\t\tlxcpath, lxcname);\n\t\tlxc_container_put(p);\n\t}\nout:\n\tfree(lxcpath);\n\tfree(lxcname);\n\tfclose(f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Error adding reverse dependency from %s to %s\"",
            "c->name",
            "c0->name"
          ],
          "line": 2909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_rdepends",
          "args": [
            "c",
            "c0"
          ],
          "line": 2908
        },
        "resolved": true,
        "details": {
          "function_name": "add_rdepends",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2805-2826",
          "snippet": "static bool add_rdepends(struct lxc_container *c, struct lxc_container *c0)\n{\n\tint ret;\n\tchar path[MAXPATHLEN];\n\tFILE *f;\n\tbool bret;\n\n\tret = snprintf(path, MAXPATHLEN, \"%s/%s/lxc_rdepends\", c->config_path,\n\t\tc->name);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn false;\n\tf = fopen(path, \"a\");\n\tif (!f)\n\t\treturn false;\n\tbret = true;\n\t// if anything goes wrong, just return an error\n\tif (fprintf(f, \"%s\\n%s\\n\", c0->config_path, c0->name) < 0)\n\t\tbret = false;\n\tif (fclose(f) != 0)\n\t\tbret = false;\n\treturn bret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool add_rdepends(struct lxc_container *c, struct lxc_container *c0)\n{\n\tint ret;\n\tchar path[MAXPATHLEN];\n\tFILE *f;\n\tbool bret;\n\n\tret = snprintf(path, MAXPATHLEN, \"%s/%s/lxc_rdepends\", c->config_path,\n\t\tc->name);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn false;\n\tf = fopen(path, \"a\");\n\tif (!f)\n\t\treturn false;\n\tbret = true;\n\t// if anything goes wrong, just return an error\n\tif (fprintf(f, \"%s\\n%s\\n\", c0->config_path, c0->name) < 0)\n\t\tbret = false;\n\tif (fclose(f) != 0)\n\t\tbret = false;\n\treturn bret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_rdepends",
          "args": [
            "c",
            "c0"
          ],
          "line": 2906
        },
        "resolved": true,
        "details": {
          "function_name": "copy_rdepends",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2782-2803",
          "snippet": "static void copy_rdepends(struct lxc_container *c, struct lxc_container *c0)\n{\n\tchar path0[MAXPATHLEN], path1[MAXPATHLEN];\n\tint ret;\n\n\tret = snprintf(path0, MAXPATHLEN, \"%s/%s/lxc_rdepends\", c0->config_path,\n\t\tc0->name);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tWARN(\"Error copying reverse dependencies\");\n\t\treturn;\n\t}\n\tret = snprintf(path1, MAXPATHLEN, \"%s/%s/lxc_rdepends\", c->config_path,\n\t\tc->name);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tWARN(\"Error copying reverse dependencies\");\n\t\treturn;\n\t}\n\tif (copy_file(path0, path1) < 0) {\n\t\tINFO(\"Error copying reverse dependencies\");\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic void copy_rdepends(struct lxc_container *c, struct lxc_container *c0)\n{\n\tchar path0[MAXPATHLEN], path1[MAXPATHLEN];\n\tint ret;\n\n\tret = snprintf(path0, MAXPATHLEN, \"%s/%s/lxc_rdepends\", c0->config_path,\n\t\tc0->name);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tWARN(\"Error copying reverse dependencies\");\n\t\treturn;\n\t}\n\tret = snprintf(path1, MAXPATHLEN, \"%s/%s/lxc_rdepends\", c->config_path,\n\t\tc->name);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tWARN(\"Error copying reverse dependencies\");\n\t\treturn;\n\t}\n\tif (copy_file(path0, path1) < 0) {\n\t\tINFO(\"Error copying reverse dependencies\");\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error saving new rootfs backend to cloned config.\""
          ],
          "line": 2901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_append_unexp_config_line",
          "args": [
            "c->lxc_conf",
            "\"lxc.rootfs.backend\"",
            "c->lxc_conf->rootfs.bdev_type"
          ],
          "line": 2899
        },
        "resolved": true,
        "details": {
          "function_name": "do_append_unexp_config_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/confile.c",
          "lines": "2732-2747",
          "snippet": "bool do_append_unexp_config_line(struct lxc_conf *conf, const char *key, const char *v)\n{\n\tint ret;\n\tsize_t len = strlen(key) + strlen(v) + 4;\n\tchar *tmp = alloca(len);\n\n\tret = snprintf(tmp, len, \"%s = %s\", key, v);\n\tif (ret < 0 || ret >= len)\n\t\treturn false;\n\n\t/* Save the line verbatim into unexpanded_conf */\n\tif (append_unexp_config_line(tmp, conf))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"network.h\"",
            "#include \"conf.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"confile.h\"",
            "#include \"config.h\"",
            "#include \"parse.h\"",
            "#include \"bdev.h\"",
            "#include <syslog.h>",
            "#include <dirent.h>",
            "#include <time.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int config_personality(const char *, const char *, struct lxc_conf *);",
            "static int config_pts(const char *, const char *, struct lxc_conf *);",
            "static int config_tty(const char *, const char *, struct lxc_conf *);",
            "static int config_ttydir(const char *, const char *, struct lxc_conf *);",
            "static int config_kmsg(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_aa_profile(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_aa_incomplete(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_se_context(const char *, const char *, struct lxc_conf *);",
            "static int config_cgroup(const char *, const char *, struct lxc_conf *);",
            "static int config_idmap(const char *, const char *, struct lxc_conf *);",
            "static int config_loglevel(const char *, const char *, struct lxc_conf *);",
            "static int config_logfile(const char *, const char *, struct lxc_conf *);",
            "static int config_mount(const char *, const char *, struct lxc_conf *);",
            "static int config_mount_auto(const char *, const char *, struct lxc_conf *);",
            "static int config_fstab(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_mount(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_options(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_backend(const char *, const char *, struct lxc_conf *);",
            "static int config_pivotdir(const char *, const char *, struct lxc_conf *);",
            "static int config_utsname(const char *, const char *, struct lxc_conf *);",
            "static int config_hook(const char *, const char *, struct lxc_conf *lxc_conf);",
            "static int config_network(const char *, const char *, struct lxc_conf *);",
            "static int config_network_type(const char *, const char *, struct lxc_conf *);",
            "static int config_network_flags(const char *, const char *, struct lxc_conf *);",
            "static int config_network_link(const char *, const char *, struct lxc_conf *);",
            "static int config_network_name(const char *, const char *, struct lxc_conf *);",
            "static int config_network_veth_pair(const char *, const char *, struct lxc_conf *);",
            "static int config_network_macvlan_mode(const char *, const char *, struct lxc_conf *);",
            "static int config_network_hwaddr(const char *, const char *, struct lxc_conf *);",
            "static int config_network_vlan_id(const char *, const char *, struct lxc_conf *);",
            "static int config_network_mtu(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv4(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv4_gateway(const char *, const char *, struct lxc_conf *);",
            "static int config_network_script_up(const char *, const char *, struct lxc_conf *);",
            "static int config_network_script_down(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv6(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv6_gateway(const char *, const char *, struct lxc_conf *);",
            "static int config_cap_drop(const char *, const char *, struct lxc_conf *);",
            "static int config_cap_keep(const char *, const char *, struct lxc_conf *);",
            "static int config_console(const char *, const char *, struct lxc_conf *);",
            "static int config_console_logfile(const char *, const char *, struct lxc_conf *);",
            "static int config_seccomp(const char *, const char *, struct lxc_conf *);",
            "static int config_includefile(const char *, const char *, struct lxc_conf *);",
            "static int config_network_nic(const char *, const char *, struct lxc_conf *);",
            "static int config_autodev(const char *, const char *, struct lxc_conf *);",
            "static int config_haltsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_rebootsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_stopsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_start(const char *, const char *, struct lxc_conf *);",
            "static int config_syslog(const char *, const char *, struct lxc_conf *);",
            "static int config_monitor(const char *, const char *, struct lxc_conf *);",
            "static int config_group(const char *, const char *, struct lxc_conf *);",
            "static int config_environment(const char *, const char *, struct lxc_conf *);",
            "static int config_init_cmd(const char *, const char *, struct lxc_conf *);",
            "static int config_init_uid(const char *, const char *, struct lxc_conf *);",
            "static int config_init_gid(const char *, const char *, struct lxc_conf *);",
            "static int config_ephemeral(const char *, const char *, struct lxc_conf *);",
            "static int config_no_new_privs(const char *, const char *, struct lxc_conf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"lxcseccomp.h\"\n#include \"network.h\"\n#include \"conf.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"confile.h\"\n#include \"config.h\"\n#include \"parse.h\"\n#include \"bdev.h\"\n#include <syslog.h>\n#include <dirent.h>\n#include <time.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int config_personality(const char *, const char *, struct lxc_conf *);\nstatic int config_pts(const char *, const char *, struct lxc_conf *);\nstatic int config_tty(const char *, const char *, struct lxc_conf *);\nstatic int config_ttydir(const char *, const char *, struct lxc_conf *);\nstatic int config_kmsg(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_aa_profile(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_aa_incomplete(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_se_context(const char *, const char *, struct lxc_conf *);\nstatic int config_cgroup(const char *, const char *, struct lxc_conf *);\nstatic int config_idmap(const char *, const char *, struct lxc_conf *);\nstatic int config_loglevel(const char *, const char *, struct lxc_conf *);\nstatic int config_logfile(const char *, const char *, struct lxc_conf *);\nstatic int config_mount(const char *, const char *, struct lxc_conf *);\nstatic int config_mount_auto(const char *, const char *, struct lxc_conf *);\nstatic int config_fstab(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_mount(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_options(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_backend(const char *, const char *, struct lxc_conf *);\nstatic int config_pivotdir(const char *, const char *, struct lxc_conf *);\nstatic int config_utsname(const char *, const char *, struct lxc_conf *);\nstatic int config_hook(const char *, const char *, struct lxc_conf *lxc_conf);\nstatic int config_network(const char *, const char *, struct lxc_conf *);\nstatic int config_network_type(const char *, const char *, struct lxc_conf *);\nstatic int config_network_flags(const char *, const char *, struct lxc_conf *);\nstatic int config_network_link(const char *, const char *, struct lxc_conf *);\nstatic int config_network_name(const char *, const char *, struct lxc_conf *);\nstatic int config_network_veth_pair(const char *, const char *, struct lxc_conf *);\nstatic int config_network_macvlan_mode(const char *, const char *, struct lxc_conf *);\nstatic int config_network_hwaddr(const char *, const char *, struct lxc_conf *);\nstatic int config_network_vlan_id(const char *, const char *, struct lxc_conf *);\nstatic int config_network_mtu(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv4(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv4_gateway(const char *, const char *, struct lxc_conf *);\nstatic int config_network_script_up(const char *, const char *, struct lxc_conf *);\nstatic int config_network_script_down(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv6(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv6_gateway(const char *, const char *, struct lxc_conf *);\nstatic int config_cap_drop(const char *, const char *, struct lxc_conf *);\nstatic int config_cap_keep(const char *, const char *, struct lxc_conf *);\nstatic int config_console(const char *, const char *, struct lxc_conf *);\nstatic int config_console_logfile(const char *, const char *, struct lxc_conf *);\nstatic int config_seccomp(const char *, const char *, struct lxc_conf *);\nstatic int config_includefile(const char *, const char *, struct lxc_conf *);\nstatic int config_network_nic(const char *, const char *, struct lxc_conf *);\nstatic int config_autodev(const char *, const char *, struct lxc_conf *);\nstatic int config_haltsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_rebootsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_stopsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_start(const char *, const char *, struct lxc_conf *);\nstatic int config_syslog(const char *, const char *, struct lxc_conf *);\nstatic int config_monitor(const char *, const char *, struct lxc_conf *);\nstatic int config_group(const char *, const char *, struct lxc_conf *);\nstatic int config_environment(const char *, const char *, struct lxc_conf *);\nstatic int config_init_cmd(const char *, const char *, struct lxc_conf *);\nstatic int config_init_uid(const char *, const char *, struct lxc_conf *);\nstatic int config_init_gid(const char *, const char *, struct lxc_conf *);\nstatic int config_ephemeral(const char *, const char *, struct lxc_conf *);\nstatic int config_no_new_privs(const char *, const char *, struct lxc_conf *);\n\nbool do_append_unexp_config_line(struct lxc_conf *conf, const char *key, const char *v)\n{\n\tint ret;\n\tsize_t len = strlen(key) + strlen(v) + 4;\n\tchar *tmp = alloca(len);\n\n\tret = snprintf(tmp, len, \"%s = %s\", key, v);\n\tif (ret < 0 || ret >= len)\n\t\treturn false;\n\n\t/* Save the line verbatim into unexpanded_conf */\n\tif (append_unexp_config_line(tmp, conf))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_unexp_config_line",
          "args": [
            "c->lxc_conf",
            "\"lxc.rootfs.backend\"",
            "false"
          ],
          "line": 2898
        },
        "resolved": true,
        "details": {
          "function_name": "clear_unexp_config_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/confile.c",
          "lines": "2749-2780",
          "snippet": "void clear_unexp_config_line(struct lxc_conf *conf, const char *key, bool rm_subkeys)\n{\n\tchar *lstart = conf->unexpanded_config, *lend;\n\n\tif (!conf->unexpanded_config)\n\t\treturn;\n\twhile (*lstart) {\n\t\tlend = strchr(lstart, '\\n');\n\t\tchar v;\n\t\tif (!lend)\n\t\t\tlend = lstart + strlen(lstart);\n\t\telse\n\t\t\tlend++;\n\t\tif (strncmp(lstart, key, strlen(key)) != 0) {\n\t\t\tlstart = lend;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!rm_subkeys) {\n\t\t\tv = lstart[strlen(key)];\n\t\t\tif (!isspace(v) && v != '=') {\n\t\t\t\tlstart = lend;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tconf->unexpanded_len -= (lend - lstart);\n\t\tif (*lend == '\\0') {\n\t\t\t*lstart = '\\0';\n\t\t\treturn;\n\t\t}\n\t\tmemmove(lstart, lend, strlen(lend)+1);\n\t}\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"network.h\"",
            "#include \"conf.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"confile.h\"",
            "#include \"config.h\"",
            "#include \"parse.h\"",
            "#include \"bdev.h\"",
            "#include <syslog.h>",
            "#include <dirent.h>",
            "#include <time.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int config_personality(const char *, const char *, struct lxc_conf *);",
            "static int config_pts(const char *, const char *, struct lxc_conf *);",
            "static int config_tty(const char *, const char *, struct lxc_conf *);",
            "static int config_ttydir(const char *, const char *, struct lxc_conf *);",
            "static int config_kmsg(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_aa_profile(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_aa_incomplete(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_se_context(const char *, const char *, struct lxc_conf *);",
            "static int config_cgroup(const char *, const char *, struct lxc_conf *);",
            "static int config_idmap(const char *, const char *, struct lxc_conf *);",
            "static int config_loglevel(const char *, const char *, struct lxc_conf *);",
            "static int config_logfile(const char *, const char *, struct lxc_conf *);",
            "static int config_mount(const char *, const char *, struct lxc_conf *);",
            "static int config_mount_auto(const char *, const char *, struct lxc_conf *);",
            "static int config_fstab(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_mount(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_options(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_backend(const char *, const char *, struct lxc_conf *);",
            "static int config_pivotdir(const char *, const char *, struct lxc_conf *);",
            "static int config_utsname(const char *, const char *, struct lxc_conf *);",
            "static int config_hook(const char *, const char *, struct lxc_conf *lxc_conf);",
            "static int config_network(const char *, const char *, struct lxc_conf *);",
            "static int config_network_type(const char *, const char *, struct lxc_conf *);",
            "static int config_network_flags(const char *, const char *, struct lxc_conf *);",
            "static int config_network_link(const char *, const char *, struct lxc_conf *);",
            "static int config_network_name(const char *, const char *, struct lxc_conf *);",
            "static int config_network_veth_pair(const char *, const char *, struct lxc_conf *);",
            "static int config_network_macvlan_mode(const char *, const char *, struct lxc_conf *);",
            "static int config_network_hwaddr(const char *, const char *, struct lxc_conf *);",
            "static int config_network_vlan_id(const char *, const char *, struct lxc_conf *);",
            "static int config_network_mtu(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv4(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv4_gateway(const char *, const char *, struct lxc_conf *);",
            "static int config_network_script_up(const char *, const char *, struct lxc_conf *);",
            "static int config_network_script_down(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv6(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv6_gateway(const char *, const char *, struct lxc_conf *);",
            "static int config_cap_drop(const char *, const char *, struct lxc_conf *);",
            "static int config_cap_keep(const char *, const char *, struct lxc_conf *);",
            "static int config_console(const char *, const char *, struct lxc_conf *);",
            "static int config_console_logfile(const char *, const char *, struct lxc_conf *);",
            "static int config_seccomp(const char *, const char *, struct lxc_conf *);",
            "static int config_includefile(const char *, const char *, struct lxc_conf *);",
            "static int config_network_nic(const char *, const char *, struct lxc_conf *);",
            "static int config_autodev(const char *, const char *, struct lxc_conf *);",
            "static int config_haltsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_rebootsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_stopsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_start(const char *, const char *, struct lxc_conf *);",
            "static int config_syslog(const char *, const char *, struct lxc_conf *);",
            "static int config_monitor(const char *, const char *, struct lxc_conf *);",
            "static int config_group(const char *, const char *, struct lxc_conf *);",
            "static int config_environment(const char *, const char *, struct lxc_conf *);",
            "static int config_init_cmd(const char *, const char *, struct lxc_conf *);",
            "static int config_init_uid(const char *, const char *, struct lxc_conf *);",
            "static int config_init_gid(const char *, const char *, struct lxc_conf *);",
            "static int config_ephemeral(const char *, const char *, struct lxc_conf *);",
            "static int config_no_new_privs(const char *, const char *, struct lxc_conf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"lxcseccomp.h\"\n#include \"network.h\"\n#include \"conf.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"confile.h\"\n#include \"config.h\"\n#include \"parse.h\"\n#include \"bdev.h\"\n#include <syslog.h>\n#include <dirent.h>\n#include <time.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int config_personality(const char *, const char *, struct lxc_conf *);\nstatic int config_pts(const char *, const char *, struct lxc_conf *);\nstatic int config_tty(const char *, const char *, struct lxc_conf *);\nstatic int config_ttydir(const char *, const char *, struct lxc_conf *);\nstatic int config_kmsg(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_aa_profile(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_aa_incomplete(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_se_context(const char *, const char *, struct lxc_conf *);\nstatic int config_cgroup(const char *, const char *, struct lxc_conf *);\nstatic int config_idmap(const char *, const char *, struct lxc_conf *);\nstatic int config_loglevel(const char *, const char *, struct lxc_conf *);\nstatic int config_logfile(const char *, const char *, struct lxc_conf *);\nstatic int config_mount(const char *, const char *, struct lxc_conf *);\nstatic int config_mount_auto(const char *, const char *, struct lxc_conf *);\nstatic int config_fstab(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_mount(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_options(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_backend(const char *, const char *, struct lxc_conf *);\nstatic int config_pivotdir(const char *, const char *, struct lxc_conf *);\nstatic int config_utsname(const char *, const char *, struct lxc_conf *);\nstatic int config_hook(const char *, const char *, struct lxc_conf *lxc_conf);\nstatic int config_network(const char *, const char *, struct lxc_conf *);\nstatic int config_network_type(const char *, const char *, struct lxc_conf *);\nstatic int config_network_flags(const char *, const char *, struct lxc_conf *);\nstatic int config_network_link(const char *, const char *, struct lxc_conf *);\nstatic int config_network_name(const char *, const char *, struct lxc_conf *);\nstatic int config_network_veth_pair(const char *, const char *, struct lxc_conf *);\nstatic int config_network_macvlan_mode(const char *, const char *, struct lxc_conf *);\nstatic int config_network_hwaddr(const char *, const char *, struct lxc_conf *);\nstatic int config_network_vlan_id(const char *, const char *, struct lxc_conf *);\nstatic int config_network_mtu(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv4(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv4_gateway(const char *, const char *, struct lxc_conf *);\nstatic int config_network_script_up(const char *, const char *, struct lxc_conf *);\nstatic int config_network_script_down(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv6(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv6_gateway(const char *, const char *, struct lxc_conf *);\nstatic int config_cap_drop(const char *, const char *, struct lxc_conf *);\nstatic int config_cap_keep(const char *, const char *, struct lxc_conf *);\nstatic int config_console(const char *, const char *, struct lxc_conf *);\nstatic int config_console_logfile(const char *, const char *, struct lxc_conf *);\nstatic int config_seccomp(const char *, const char *, struct lxc_conf *);\nstatic int config_includefile(const char *, const char *, struct lxc_conf *);\nstatic int config_network_nic(const char *, const char *, struct lxc_conf *);\nstatic int config_autodev(const char *, const char *, struct lxc_conf *);\nstatic int config_haltsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_rebootsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_stopsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_start(const char *, const char *, struct lxc_conf *);\nstatic int config_syslog(const char *, const char *, struct lxc_conf *);\nstatic int config_monitor(const char *, const char *, struct lxc_conf *);\nstatic int config_group(const char *, const char *, struct lxc_conf *);\nstatic int config_environment(const char *, const char *, struct lxc_conf *);\nstatic int config_init_cmd(const char *, const char *, struct lxc_conf *);\nstatic int config_init_uid(const char *, const char *, struct lxc_conf *);\nstatic int config_init_gid(const char *, const char *, struct lxc_conf *);\nstatic int config_ephemeral(const char *, const char *, struct lxc_conf *);\nstatic int config_no_new_privs(const char *, const char *, struct lxc_conf *);\n\nvoid clear_unexp_config_line(struct lxc_conf *conf, const char *key, bool rm_subkeys)\n{\n\tchar *lstart = conf->unexpanded_config, *lend;\n\n\tif (!conf->unexpanded_config)\n\t\treturn;\n\twhile (*lstart) {\n\t\tlend = strchr(lstart, '\\n');\n\t\tchar v;\n\t\tif (!lend)\n\t\t\tlend = lstart + strlen(lstart);\n\t\telse\n\t\t\tlend++;\n\t\tif (strncmp(lstart, key, strlen(key)) != 0) {\n\t\t\tlstart = lend;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!rm_subkeys) {\n\t\t\tv = lstart[strlen(key)];\n\t\t\tif (!isspace(v) && v != '=') {\n\t\t\t\tlstart = lend;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tconf->unexpanded_len -= (lend - lstart);\n\t\tif (*lend == '\\0') {\n\t\t\t*lstart = '\\0';\n\t\t\treturn;\n\t\t}\n\t\tmemmove(lstart, lend, strlen(lend)+1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error saving new rootfs to cloned config.\""
          ],
          "line": 2893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Out of memory while setting rootfs backend.\""
          ],
          "line": 2885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Out of memory while setting storage path.\""
          ],
          "line": 2881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_put",
          "args": [
            "bdev"
          ],
          "line": 2878
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "579-585",
          "snippet": "void bdev_put(struct bdev *bdev)\n{\n\tfree(bdev->mntopts);\n\tfree(bdev->src);\n\tfree(bdev->dest);\n\tfree(bdev);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);",
            "static char *linkderef(char *path, char *dest);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);\nstatic char *linkderef(char *path, char *dest);\n\nvoid bdev_put(struct bdev *bdev)\n{\n\tfree(bdev->mntopts);\n\tfree(bdev->src);\n\tfree(bdev->dest);\n\tfree(bdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "bdev->type"
          ],
          "line": 2877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "c->lxc_conf->rootfs.bdev_type"
          ],
          "line": 2876
        },
        "resolved": true,
        "details": {
          "function_name": "free_init_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "706-715",
          "snippet": "static void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "bdev->src"
          ],
          "line": 2873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error copying storage.\""
          ],
          "line": 2867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_copy",
          "args": [
            "c0",
            "c->name",
            "c->config_path",
            "newtype",
            "flags",
            "bdevdata",
            "newsize",
            "&need_rdep"
          ],
          "line": 2864
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "295-450",
          "snippet": "struct bdev *bdev_copy(struct lxc_container *c0, const char *cname,\n\t\tconst char *lxcpath, const char *bdevtype, int flags,\n\t\tconst char *bdevdata, uint64_t newsize, int *needs_rdep)\n{\n\tstruct bdev *orig, *new;\n\tpid_t pid;\n\tint ret;\n\tbool snap = flags & LXC_CLONE_SNAPSHOT;\n\tbool maybe_snap = flags & LXC_CLONE_MAYBE_SNAPSHOT;\n\tbool keepbdevtype = flags & LXC_CLONE_KEEPBDEVTYPE;\n\tconst char *src = c0->lxc_conf->rootfs.path;\n\tconst char *oldname = c0->name;\n\tconst char *oldpath = c0->config_path;\n\tstruct rsync_data data;\n\n\t/* if the container name doesn't show up in the rootfs path, then\n\t * we don't know how to come up with a new name\n\t */\n\tif (strstr(src, oldname) == NULL) {\n\t\tERROR(\"original rootfs path %s doesn't include container name %s\",\n\t\t\tsrc, oldname);\n\t\treturn NULL;\n\t}\n\n\torig = bdev_init(c0->lxc_conf, src, NULL, NULL);\n\tif (!orig) {\n\t\tERROR(\"failed to detect blockdev type for %s\", src);\n\t\treturn NULL;\n\t}\n\n\tif (!orig->dest) {\n\t\tint ret;\n\t\tsize_t len;\n\t\tstruct stat sb;\n\n\t\tlen = strlen(oldpath) + strlen(oldname) + strlen(\"/rootfs\") + 2;\n\t\torig->dest = malloc(len);\n\t\tif (!orig->dest) {\n\t\t\tERROR(\"out of memory\");\n\t\t\tbdev_put(orig);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = snprintf(orig->dest, len, \"%s/%s/rootfs\", oldpath, oldname);\n\t\tif (ret < 0 || (size_t)ret >= len) {\n\t\t\tERROR(\"rootfs path too long\");\n\t\t\tbdev_put(orig);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = stat(orig->dest, &sb);\n\t\tif (ret < 0 && errno == ENOENT)\n\t\t\tif (mkdir_p(orig->dest, 0755) < 0)\n\t\t\t\tWARN(\"Error creating '%s', continuing.\", orig->dest);\n\t}\n\n\t/*\n\t * special case for snapshot - if caller requested maybe_snapshot and\n\t * keepbdevtype and backing store is directory, then proceed with a copy\n\t * clone rather than returning error\n\t */\n\tif (maybe_snap && keepbdevtype && !bdevtype && !orig->ops->can_snapshot)\n\t\tsnap = false;\n\n\t/*\n\t * If newtype is NULL and snapshot is set, then use overlayfs\n\t */\n\tif (!bdevtype && !keepbdevtype && snap && strcmp(orig->type , \"dir\") == 0)\n\t\tbdevtype = \"overlayfs\";\n\n\tif (am_unpriv() && !unpriv_snap_allowed(orig, bdevtype, snap, maybe_snap)) {\n\t\tERROR(\"Unsupported snapshot type for unprivileged users\");\n\t\tbdev_put(orig);\n\t\treturn NULL;\n\t}\n\n\t*needs_rdep = 0;\n\tif (bdevtype && strcmp(orig->type, \"dir\") == 0 &&\n\t\t\t(strcmp(bdevtype, \"aufs\") == 0 ||\n\t\t\t strcmp(bdevtype, \"overlayfs\") == 0)) {\n\t\t*needs_rdep = 1;\n\t} else if (snap && strcmp(orig->type, \"lvm\") == 0 &&\n\t\t\t!lvm_is_thin_volume(orig->src)) {\n\t\t*needs_rdep = 1;\n\t}\n\n\tnew = bdev_get(bdevtype ? bdevtype : orig->type);\n\tif (!new) {\n\t\tERROR(\"no such block device type: %s\", bdevtype ? bdevtype : orig->type);\n\t\tbdev_put(orig);\n\t\treturn NULL;\n\t}\n\n\tif (new->ops->clone_paths(orig, new, oldname, cname, oldpath, lxcpath,\n\t\t\t\tsnap, newsize, c0->lxc_conf) < 0) {\n\t\tERROR(\"failed getting pathnames for cloned storage: %s\", src);\n\t\tgoto err;\n\t}\n\n\tif (am_unpriv() && chown_mapped_root(new->src, c0->lxc_conf) < 0)\n\t\tWARN(\"Failed to update ownership of %s\", new->dest);\n\n\tif (snap)\n\t\treturn new;\n\n\t/*\n\t * https://github.com/lxc/lxc/issues/131\n\t * Use btrfs snapshot feature instead of rsync to restore if both orig and new are btrfs\n\t */\n\tif (bdevtype &&\n\t\t\tstrcmp(orig->type, \"btrfs\") == 0 && strcmp(new->type, \"btrfs\") == 0 &&\n\t\t\tbtrfs_same_fs(orig->dest, new->dest) == 0) {\n\t\tif (btrfs_destroy(new) < 0) {\n\t\t\tERROR(\"Error destroying %s subvolume\", new->dest);\n\t\t\tgoto err;\n\t\t}\n\t\tif (mkdir_p(new->dest, 0755) < 0) {\n\t\t\tERROR(\"Error creating %s directory\", new->dest);\n\t\t\tgoto err;\n\t\t}\n\t\tif (btrfs_snapshot(orig->dest, new->dest) < 0) {\n\t\t\tERROR(\"Error restoring %s to %s\", orig->dest, new->dest);\n\t\t\tgoto err;\n\t\t}\n\t\tbdev_put(orig);\n\t\treturn new;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"fork\");\n\t\tgoto err;\n\t}\n\n\tif (pid > 0) {\n\t\tint ret = wait_for_pid(pid);\n\t\tbdev_put(orig);\n\t\tif (ret < 0) {\n\t\t\tbdev_put(new);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn new;\n\t}\n\n\tdata.orig = orig;\n\tdata.new = new;\n\tif (am_unpriv())\n\t\tret = userns_exec_1(c0->lxc_conf, rsync_rootfs_wrapper, &data);\n\telse\n\t\tret = rsync_rootfs(&data);\n\n\texit(ret == 0 ? 0 : 1);\n\nerr:\n\tbdev_put(orig);\n\tbdev_put(new);\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);",
            "static struct bdev *bdev_get(const char *type);",
            "static int find_fstype_cb(char *buffer, void *data);",
            "static char *linkderef(char *path, char *dest);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);\nstatic struct bdev *bdev_get(const char *type);\nstatic int find_fstype_cb(char *buffer, void *data);\nstatic char *linkderef(char *path, char *dest);\n\nstruct bdev *bdev_copy(struct lxc_container *c0, const char *cname,\n\t\tconst char *lxcpath, const char *bdevtype, int flags,\n\t\tconst char *bdevdata, uint64_t newsize, int *needs_rdep)\n{\n\tstruct bdev *orig, *new;\n\tpid_t pid;\n\tint ret;\n\tbool snap = flags & LXC_CLONE_SNAPSHOT;\n\tbool maybe_snap = flags & LXC_CLONE_MAYBE_SNAPSHOT;\n\tbool keepbdevtype = flags & LXC_CLONE_KEEPBDEVTYPE;\n\tconst char *src = c0->lxc_conf->rootfs.path;\n\tconst char *oldname = c0->name;\n\tconst char *oldpath = c0->config_path;\n\tstruct rsync_data data;\n\n\t/* if the container name doesn't show up in the rootfs path, then\n\t * we don't know how to come up with a new name\n\t */\n\tif (strstr(src, oldname) == NULL) {\n\t\tERROR(\"original rootfs path %s doesn't include container name %s\",\n\t\t\tsrc, oldname);\n\t\treturn NULL;\n\t}\n\n\torig = bdev_init(c0->lxc_conf, src, NULL, NULL);\n\tif (!orig) {\n\t\tERROR(\"failed to detect blockdev type for %s\", src);\n\t\treturn NULL;\n\t}\n\n\tif (!orig->dest) {\n\t\tint ret;\n\t\tsize_t len;\n\t\tstruct stat sb;\n\n\t\tlen = strlen(oldpath) + strlen(oldname) + strlen(\"/rootfs\") + 2;\n\t\torig->dest = malloc(len);\n\t\tif (!orig->dest) {\n\t\t\tERROR(\"out of memory\");\n\t\t\tbdev_put(orig);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = snprintf(orig->dest, len, \"%s/%s/rootfs\", oldpath, oldname);\n\t\tif (ret < 0 || (size_t)ret >= len) {\n\t\t\tERROR(\"rootfs path too long\");\n\t\t\tbdev_put(orig);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = stat(orig->dest, &sb);\n\t\tif (ret < 0 && errno == ENOENT)\n\t\t\tif (mkdir_p(orig->dest, 0755) < 0)\n\t\t\t\tWARN(\"Error creating '%s', continuing.\", orig->dest);\n\t}\n\n\t/*\n\t * special case for snapshot - if caller requested maybe_snapshot and\n\t * keepbdevtype and backing store is directory, then proceed with a copy\n\t * clone rather than returning error\n\t */\n\tif (maybe_snap && keepbdevtype && !bdevtype && !orig->ops->can_snapshot)\n\t\tsnap = false;\n\n\t/*\n\t * If newtype is NULL and snapshot is set, then use overlayfs\n\t */\n\tif (!bdevtype && !keepbdevtype && snap && strcmp(orig->type , \"dir\") == 0)\n\t\tbdevtype = \"overlayfs\";\n\n\tif (am_unpriv() && !unpriv_snap_allowed(orig, bdevtype, snap, maybe_snap)) {\n\t\tERROR(\"Unsupported snapshot type for unprivileged users\");\n\t\tbdev_put(orig);\n\t\treturn NULL;\n\t}\n\n\t*needs_rdep = 0;\n\tif (bdevtype && strcmp(orig->type, \"dir\") == 0 &&\n\t\t\t(strcmp(bdevtype, \"aufs\") == 0 ||\n\t\t\t strcmp(bdevtype, \"overlayfs\") == 0)) {\n\t\t*needs_rdep = 1;\n\t} else if (snap && strcmp(orig->type, \"lvm\") == 0 &&\n\t\t\t!lvm_is_thin_volume(orig->src)) {\n\t\t*needs_rdep = 1;\n\t}\n\n\tnew = bdev_get(bdevtype ? bdevtype : orig->type);\n\tif (!new) {\n\t\tERROR(\"no such block device type: %s\", bdevtype ? bdevtype : orig->type);\n\t\tbdev_put(orig);\n\t\treturn NULL;\n\t}\n\n\tif (new->ops->clone_paths(orig, new, oldname, cname, oldpath, lxcpath,\n\t\t\t\tsnap, newsize, c0->lxc_conf) < 0) {\n\t\tERROR(\"failed getting pathnames for cloned storage: %s\", src);\n\t\tgoto err;\n\t}\n\n\tif (am_unpriv() && chown_mapped_root(new->src, c0->lxc_conf) < 0)\n\t\tWARN(\"Failed to update ownership of %s\", new->dest);\n\n\tif (snap)\n\t\treturn new;\n\n\t/*\n\t * https://github.com/lxc/lxc/issues/131\n\t * Use btrfs snapshot feature instead of rsync to restore if both orig and new are btrfs\n\t */\n\tif (bdevtype &&\n\t\t\tstrcmp(orig->type, \"btrfs\") == 0 && strcmp(new->type, \"btrfs\") == 0 &&\n\t\t\tbtrfs_same_fs(orig->dest, new->dest) == 0) {\n\t\tif (btrfs_destroy(new) < 0) {\n\t\t\tERROR(\"Error destroying %s subvolume\", new->dest);\n\t\t\tgoto err;\n\t\t}\n\t\tif (mkdir_p(new->dest, 0755) < 0) {\n\t\t\tERROR(\"Error creating %s directory\", new->dest);\n\t\t\tgoto err;\n\t\t}\n\t\tif (btrfs_snapshot(orig->dest, new->dest) < 0) {\n\t\t\tERROR(\"Error restoring %s to %s\", orig->dest, new->dest);\n\t\t\tgoto err;\n\t\t}\n\t\tbdev_put(orig);\n\t\treturn new;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"fork\");\n\t\tgoto err;\n\t}\n\n\tif (pid > 0) {\n\t\tint ret = wait_for_pid(pid);\n\t\tbdev_put(orig);\n\t\tif (ret < 0) {\n\t\t\tbdev_put(new);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn new;\n\t}\n\n\tdata.orig = orig;\n\tdata.new = new;\n\tif (am_unpriv())\n\t\tret = userns_exec_1(c0->lxc_conf, rsync_rootfs_wrapper, &data);\n\telse\n\t\tret = rsync_rootfs(&data);\n\n\texit(ret == 0 ? 0 : 1);\n\nerr:\n\tbdev_put(orig);\n\tbdev_put(new);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "should_default_to_snapshot",
          "args": [
            "c0",
            "c"
          ],
          "line": 2861
        },
        "resolved": true,
        "details": {
          "function_name": "should_default_to_snapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2833-2852",
          "snippet": "bool should_default_to_snapshot(struct lxc_container *c0,\n\t\t\t\tstruct lxc_container *c1)\n{\n\tsize_t l0 = strlen(c0->config_path) + strlen(c0->name) + 2;\n\tsize_t l1 = strlen(c1->config_path) + strlen(c1->name) + 2;\n\tchar *p0 = alloca(l0 + 1);\n\tchar *p1 = alloca(l1 + 1);\n\tchar *rootfs = c0->lxc_conf->rootfs.path;\n\n\tsnprintf(p0, l0, \"%s/%s\", c0->config_path, c0->name);\n\tsnprintf(p1, l1, \"%s/%s\", c1->config_path, c1->name);\n\n\tif (!is_btrfs_fs(p0) || !is_btrfs_fs(p1))\n\t\treturn false;\n\n\tif (is_btrfs_subvol(rootfs) <= 0)\n\t\treturn false;\n\n\treturn btrfs_same_fs(p0, p1) == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nbool should_default_to_snapshot(struct lxc_container *c0,\n\t\t\t\tstruct lxc_container *c1)\n{\n\tsize_t l0 = strlen(c0->config_path) + strlen(c0->name) + 2;\n\tsize_t l1 = strlen(c1->config_path) + strlen(c1->name) + 2;\n\tchar *p0 = alloca(l0 + 1);\n\tchar *p1 = alloca(l1 + 1);\n\tchar *rootfs = c0->lxc_conf->rootfs.path;\n\n\tsnprintf(p0, l0, \"%s/%s\", c0->config_path, c0->name);\n\tsnprintf(p1, l1, \"%s/%s\", c1->config_path, c1->name);\n\n\tif (!is_btrfs_fs(p0) || !is_btrfs_fs(p1))\n\t\treturn false;\n\n\tif (is_btrfs_subvol(rootfs) <= 0)\n\t\treturn false;\n\n\treturn btrfs_same_fs(p0, p1) == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic int copy_storage(struct lxc_container *c0, struct lxc_container *c,\n\t\t\tconst char *newtype, int flags, const char *bdevdata,\n\t\t\tuint64_t newsize)\n{\n\tstruct bdev *bdev;\n\tint need_rdep;\n\n\tif (should_default_to_snapshot(c0, c))\n\t\tflags |= LXC_CLONE_SNAPSHOT;\n\n\tbdev = bdev_copy(c0, c->name, c->config_path, newtype, flags, bdevdata,\n\t\t\t newsize, &need_rdep);\n\tif (!bdev) {\n\t\tERROR(\"Error copying storage.\");\n\t\treturn -1;\n\t}\n\n\t/* Set new rootfs. */\n\tfree(c->lxc_conf->rootfs.path);\n\tc->lxc_conf->rootfs.path = strdup(bdev->src);\n\n\t/* Set new bdev type. */\n\tfree(c->lxc_conf->rootfs.bdev_type);\n\tc->lxc_conf->rootfs.bdev_type = strdup(bdev->type);\n\tbdev_put(bdev);\n\n\tif (!c->lxc_conf->rootfs.path) {\n\t\tERROR(\"Out of memory while setting storage path.\");\n\t\treturn -1;\n\t}\n\tif (!c->lxc_conf->rootfs.bdev_type) {\n\t\tERROR(\"Out of memory while setting rootfs backend.\");\n\t\treturn -1;\n\t}\n\n\t/* Append a new lxc.rootfs entry to the unexpanded config. */\n\tclear_unexp_config_line(c->lxc_conf, \"lxc.rootfs\", false);\n\tif (!do_append_unexp_config_line(c->lxc_conf, \"lxc.rootfs\",\n\t\t\t\t\t c->lxc_conf->rootfs.path)) {\n\t\tERROR(\"Error saving new rootfs to cloned config.\");\n\t\treturn -1;\n\t}\n\n\t/* Append a new lxc.rootfs.backend entry to the unexpanded config. */\n\tclear_unexp_config_line(c->lxc_conf, \"lxc.rootfs.backend\", false);\n\tif (!do_append_unexp_config_line(c->lxc_conf, \"lxc.rootfs.backend\",\n\t\t\t\t\t c->lxc_conf->rootfs.bdev_type)) {\n\t\tERROR(\"Error saving new rootfs backend to cloned config.\");\n\t\treturn -1;\n\t}\n\n\tif (flags & LXC_CLONE_SNAPSHOT)\n\t\tcopy_rdepends(c, c0);\n\tif (need_rdep) {\n\t\tif (!add_rdepends(c, c0))\n\t\t\tWARN(\"Error adding reverse dependency from %s to %s\",\n\t\t\t     c->name, c0->name);\n\t}\n\n\tmod_all_rdeps(c, true);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "should_default_to_snapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "2833-2852",
    "snippet": "bool should_default_to_snapshot(struct lxc_container *c0,\n\t\t\t\tstruct lxc_container *c1)\n{\n\tsize_t l0 = strlen(c0->config_path) + strlen(c0->name) + 2;\n\tsize_t l1 = strlen(c1->config_path) + strlen(c1->name) + 2;\n\tchar *p0 = alloca(l0 + 1);\n\tchar *p1 = alloca(l1 + 1);\n\tchar *rootfs = c0->lxc_conf->rootfs.path;\n\n\tsnprintf(p0, l0, \"%s/%s\", c0->config_path, c0->name);\n\tsnprintf(p1, l1, \"%s/%s\", c1->config_path, c1->name);\n\n\tif (!is_btrfs_fs(p0) || !is_btrfs_fs(p1))\n\t\treturn false;\n\n\tif (is_btrfs_subvol(rootfs) <= 0)\n\t\treturn false;\n\n\treturn btrfs_same_fs(p0, p1) == 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_same_fs",
          "args": [
            "p0",
            "p1"
          ],
          "line": 2851
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_same_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "258-297",
          "snippet": "int btrfs_same_fs(const char *orig, const char *new)\n{\n\tint fd_orig = -1, fd_new = -1, ret = -1;\n\tstruct btrfs_ioctl_fs_info_args orig_args, new_args;\n\n\tfd_orig = open(orig, O_RDONLY);\n\tif (fd_orig < 0) {\n\t\tSYSERROR(\"Error opening original rootfs %s\", orig);\n\t\tgoto out;\n\t}\n\tret = ioctl(fd_orig, BTRFS_IOC_FS_INFO, &orig_args);\n\tif (ret < 0) {\n\t\tSYSERROR(\"BTRFS_IOC_FS_INFO %s\", orig);\n\t\tgoto out;\n\t}\n\n\tfd_new = open(new, O_RDONLY);\n\tif (fd_new < 0) {\n\t\tSYSERROR(\"Error opening new container dir %s\", new);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\tret = ioctl(fd_new, BTRFS_IOC_FS_INFO, &new_args);\n\tif (ret < 0) {\n\t\tSYSERROR(\"BTRFS_IOC_FS_INFO %s\", new);\n\t\tgoto out;\n\t}\n\n\tif (strncmp(orig_args.fsid, new_args.fsid, BTRFS_FSID_SIZE) != 0) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tif (fd_new != -1)\n\t\tclose(fd_new);\n\tif (fd_orig != -1)\n\t\tclose(fd_orig);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint btrfs_same_fs(const char *orig, const char *new)\n{\n\tint fd_orig = -1, fd_new = -1, ret = -1;\n\tstruct btrfs_ioctl_fs_info_args orig_args, new_args;\n\n\tfd_orig = open(orig, O_RDONLY);\n\tif (fd_orig < 0) {\n\t\tSYSERROR(\"Error opening original rootfs %s\", orig);\n\t\tgoto out;\n\t}\n\tret = ioctl(fd_orig, BTRFS_IOC_FS_INFO, &orig_args);\n\tif (ret < 0) {\n\t\tSYSERROR(\"BTRFS_IOC_FS_INFO %s\", orig);\n\t\tgoto out;\n\t}\n\n\tfd_new = open(new, O_RDONLY);\n\tif (fd_new < 0) {\n\t\tSYSERROR(\"Error opening new container dir %s\", new);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\tret = ioctl(fd_new, BTRFS_IOC_FS_INFO, &new_args);\n\tif (ret < 0) {\n\t\tSYSERROR(\"BTRFS_IOC_FS_INFO %s\", new);\n\t\tgoto out;\n\t}\n\n\tif (strncmp(orig_args.fsid, new_args.fsid, BTRFS_FSID_SIZE) != 0) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tif (fd_new != -1)\n\t\tclose(fd_new);\n\tif (fd_orig != -1)\n\t\tclose(fd_orig);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_btrfs_subvol",
          "args": [
            "rootfs"
          ],
          "line": 2848
        },
        "resolved": true,
        "details": {
          "function_name": "is_btrfs_subvol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "152-170",
          "snippet": "int is_btrfs_subvol(const char *path)\n{\n\tstruct stat st;\n\tstruct statfs stfs;\n\tint ret;\n\n\tret = stat(path, &st);\n\tif (ret < 0)\n\t\treturn -errno;\n\n\tif (st.st_ino != BTRFS_FIRST_FREE_OBJECTID || !S_ISDIR(st.st_mode))\n\t\treturn 0;\n\n\tret = statfs(path, &stfs);\n\tif (ret < 0)\n\t\treturn -errno;\n\n\treturn stfs.f_type == BTRFS_SUPER_MAGIC;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint is_btrfs_subvol(const char *path)\n{\n\tstruct stat st;\n\tstruct statfs stfs;\n\tint ret;\n\n\tret = stat(path, &st);\n\tif (ret < 0)\n\t\treturn -errno;\n\n\tif (st.st_ino != BTRFS_FIRST_FREE_OBJECTID || !S_ISDIR(st.st_mode))\n\t\treturn 0;\n\n\tret = statfs(path, &stfs);\n\tif (ret < 0)\n\t\treturn -errno;\n\n\treturn stfs.f_type == BTRFS_SUPER_MAGIC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_btrfs_fs",
          "args": [
            "p1"
          ],
          "line": 2845
        },
        "resolved": true,
        "details": {
          "function_name": "is_btrfs_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "127-144",
          "snippet": "bool is_btrfs_fs(const char *path)\n{\n\tint fd, ret;\n\tstruct btrfs_ioctl_space_args sargs;\n\n\t// make sure this is a btrfs filesystem\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn false;\n\tsargs.space_slots = 0;\n\tsargs.total_spaces = 0;\n\tret = ioctl(fd, BTRFS_IOC_SPACE_INFO, &sargs);\n\tclose(fd);\n\tif (ret < 0)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nbool is_btrfs_fs(const char *path)\n{\n\tint fd, ret;\n\tstruct btrfs_ioctl_space_args sargs;\n\n\t// make sure this is a btrfs filesystem\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn false;\n\tsargs.space_slots = 0;\n\tsargs.total_spaces = 0;\n\tret = ioctl(fd, BTRFS_IOC_SPACE_INFO, &sargs);\n\tclose(fd);\n\tif (ret < 0)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "p1",
            "l1",
            "\"%s/%s\"",
            "c1->config_path",
            "c1->name"
          ],
          "line": 2843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "p0",
            "l0",
            "\"%s/%s\"",
            "c0->config_path",
            "c0->name"
          ],
          "line": 2842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "l1 + 1"
          ],
          "line": 2839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "l0 + 1"
          ],
          "line": 2838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "c1->name"
          ],
          "line": 2837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "c1->config_path"
          ],
          "line": 2837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "c0->name"
          ],
          "line": 2836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "c0->config_path"
          ],
          "line": 2836
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nbool should_default_to_snapshot(struct lxc_container *c0,\n\t\t\t\tstruct lxc_container *c1)\n{\n\tsize_t l0 = strlen(c0->config_path) + strlen(c0->name) + 2;\n\tsize_t l1 = strlen(c1->config_path) + strlen(c1->name) + 2;\n\tchar *p0 = alloca(l0 + 1);\n\tchar *p1 = alloca(l1 + 1);\n\tchar *rootfs = c0->lxc_conf->rootfs.path;\n\n\tsnprintf(p0, l0, \"%s/%s\", c0->config_path, c0->name);\n\tsnprintf(p1, l1, \"%s/%s\", c1->config_path, c1->name);\n\n\tif (!is_btrfs_fs(p0) || !is_btrfs_fs(p1))\n\t\treturn false;\n\n\tif (is_btrfs_subvol(rootfs) <= 0)\n\t\treturn false;\n\n\treturn btrfs_same_fs(p0, p1) == 0;\n}"
  },
  {
    "function_name": "add_rdepends",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "2805-2826",
    "snippet": "static bool add_rdepends(struct lxc_container *c, struct lxc_container *c0)\n{\n\tint ret;\n\tchar path[MAXPATHLEN];\n\tFILE *f;\n\tbool bret;\n\n\tret = snprintf(path, MAXPATHLEN, \"%s/%s/lxc_rdepends\", c->config_path,\n\t\tc->name);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn false;\n\tf = fopen(path, \"a\");\n\tif (!f)\n\t\treturn false;\n\tbret = true;\n\t// if anything goes wrong, just return an error\n\tif (fprintf(f, \"%s\\n%s\\n\", c0->config_path, c0->name) < 0)\n\t\tbret = false;\n\tif (fclose(f) != 0)\n\t\tbret = false;\n\treturn bret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 2823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"%s\\n%s\\n\"",
            "c0->config_path",
            "c0->name"
          ],
          "line": 2821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "path",
            "\"a\""
          ],
          "line": 2816
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "MAXPATHLEN",
            "\"%s/%s/lxc_rdepends\"",
            "c->config_path",
            "c->name"
          ],
          "line": 2812
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool add_rdepends(struct lxc_container *c, struct lxc_container *c0)\n{\n\tint ret;\n\tchar path[MAXPATHLEN];\n\tFILE *f;\n\tbool bret;\n\n\tret = snprintf(path, MAXPATHLEN, \"%s/%s/lxc_rdepends\", c->config_path,\n\t\tc->name);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn false;\n\tf = fopen(path, \"a\");\n\tif (!f)\n\t\treturn false;\n\tbret = true;\n\t// if anything goes wrong, just return an error\n\tif (fprintf(f, \"%s\\n%s\\n\", c0->config_path, c0->name) < 0)\n\t\tbret = false;\n\tif (fclose(f) != 0)\n\t\tbret = false;\n\treturn bret;\n}"
  },
  {
    "function_name": "copy_rdepends",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "2782-2803",
    "snippet": "static void copy_rdepends(struct lxc_container *c, struct lxc_container *c0)\n{\n\tchar path0[MAXPATHLEN], path1[MAXPATHLEN];\n\tint ret;\n\n\tret = snprintf(path0, MAXPATHLEN, \"%s/%s/lxc_rdepends\", c0->config_path,\n\t\tc0->name);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tWARN(\"Error copying reverse dependencies\");\n\t\treturn;\n\t}\n\tret = snprintf(path1, MAXPATHLEN, \"%s/%s/lxc_rdepends\", c->config_path,\n\t\tc->name);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tWARN(\"Error copying reverse dependencies\");\n\t\treturn;\n\t}\n\tif (copy_file(path0, path1) < 0) {\n\t\tINFO(\"Error copying reverse dependencies\");\n\t\treturn;\n\t}\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Error copying reverse dependencies\""
          ],
          "line": 2800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_file",
          "args": [
            "path0",
            "path1"
          ],
          "line": 2799
        },
        "resolved": true,
        "details": {
          "function_name": "copy_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2628-2687",
          "snippet": "static int copy_file(const char *old, const char *new)\n{\n\tint in, out;\n\tssize_t len, ret;\n\tchar buf[8096];\n\tstruct stat sbuf;\n\n\tif (file_exists(new)) {\n\t\tERROR(\"copy destination %s exists\", new);\n\t\treturn -1;\n\t}\n\tret = stat(old, &sbuf);\n\tif (ret < 0) {\n\t\tINFO(\"Error stat'ing %s\", old);\n\t\treturn -1;\n\t}\n\n\tin = open(old, O_RDONLY);\n\tif (in < 0) {\n\t\tSYSERROR(\"Error opening original file %s\", old);\n\t\treturn -1;\n\t}\n\tout = open(new, O_CREAT | O_EXCL | O_WRONLY, 0644);\n\tif (out < 0) {\n\t\tSYSERROR(\"Error opening new file %s\", new);\n\t\tclose(in);\n\t\treturn -1;\n\t}\n\n\twhile (1) {\n\t\tlen = read(in, buf, 8096);\n\t\tif (len < 0) {\n\t\t\tSYSERROR(\"Error reading old file %s\", old);\n\t\t\tgoto err;\n\t\t}\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tret = write(out, buf, len);\n\t\tif (ret < len) { // should we retry?\n\t\t\tSYSERROR(\"Error: write to new file %s was interrupted\", new);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tclose(in);\n\tclose(out);\n\n\t// we set mode, but not owner/group\n\tret = chmod(new, sbuf.st_mode);\n\tif (ret) {\n\t\tSYSERROR(\"Error setting mode on %s\", new);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n\nerr:\n\tclose(in);\n\tclose(out);\n\treturn -1;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic int copy_file(const char *old, const char *new)\n{\n\tint in, out;\n\tssize_t len, ret;\n\tchar buf[8096];\n\tstruct stat sbuf;\n\n\tif (file_exists(new)) {\n\t\tERROR(\"copy destination %s exists\", new);\n\t\treturn -1;\n\t}\n\tret = stat(old, &sbuf);\n\tif (ret < 0) {\n\t\tINFO(\"Error stat'ing %s\", old);\n\t\treturn -1;\n\t}\n\n\tin = open(old, O_RDONLY);\n\tif (in < 0) {\n\t\tSYSERROR(\"Error opening original file %s\", old);\n\t\treturn -1;\n\t}\n\tout = open(new, O_CREAT | O_EXCL | O_WRONLY, 0644);\n\tif (out < 0) {\n\t\tSYSERROR(\"Error opening new file %s\", new);\n\t\tclose(in);\n\t\treturn -1;\n\t}\n\n\twhile (1) {\n\t\tlen = read(in, buf, 8096);\n\t\tif (len < 0) {\n\t\t\tSYSERROR(\"Error reading old file %s\", old);\n\t\t\tgoto err;\n\t\t}\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tret = write(out, buf, len);\n\t\tif (ret < len) { // should we retry?\n\t\t\tSYSERROR(\"Error: write to new file %s was interrupted\", new);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tclose(in);\n\tclose(out);\n\n\t// we set mode, but not owner/group\n\tret = chmod(new, sbuf.st_mode);\n\tif (ret) {\n\t\tSYSERROR(\"Error setting mode on %s\", new);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n\nerr:\n\tclose(in);\n\tclose(out);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Error copying reverse dependencies\""
          ],
          "line": 2796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path1",
            "MAXPATHLEN",
            "\"%s/%s/lxc_rdepends\"",
            "c->config_path",
            "c->name"
          ],
          "line": 2793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Error copying reverse dependencies\""
          ],
          "line": 2790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path0",
            "MAXPATHLEN",
            "\"%s/%s/lxc_rdepends\"",
            "c0->config_path",
            "c0->name"
          ],
          "line": 2787
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic void copy_rdepends(struct lxc_container *c, struct lxc_container *c0)\n{\n\tchar path0[MAXPATHLEN], path1[MAXPATHLEN];\n\tint ret;\n\n\tret = snprintf(path0, MAXPATHLEN, \"%s/%s/lxc_rdepends\", c0->config_path,\n\t\tc0->name);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tWARN(\"Error copying reverse dependencies\");\n\t\treturn;\n\t}\n\tret = snprintf(path1, MAXPATHLEN, \"%s/%s/lxc_rdepends\", c->config_path,\n\t\tc->name);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tWARN(\"Error copying reverse dependencies\");\n\t\treturn;\n\t}\n\tif (copy_file(path0, path1) < 0) {\n\t\tINFO(\"Error copying reverse dependencies\");\n\t\treturn;\n\t}\n}"
  },
  {
    "function_name": "copy_fstab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "2739-2780",
    "snippet": "static int copy_fstab(struct lxc_container *oldc, struct lxc_container *c)\n{\n\tchar newpath[MAXPATHLEN];\n\tchar *oldpath = oldc->lxc_conf->fstab;\n\tint ret;\n\n\tif (!oldpath)\n\t\treturn 0;\n\n\tclear_unexp_config_line(c->lxc_conf, \"lxc.mount\", false);\n\n\tchar *p = strrchr(oldpath, '/');\n\tif (!p)\n\t\treturn -1;\n\tret = snprintf(newpath, MAXPATHLEN, \"%s/%s%s\",\n\t\t\tc->config_path, c->name, p);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tERROR(\"error printing new path for %s\", oldpath);\n\t\treturn -1;\n\t}\n\tif (file_exists(newpath)) {\n\t\tERROR(\"error: fstab file %s exists\", newpath);\n\t\treturn -1;\n\t}\n\n\tif (copy_file(oldpath, newpath) < 0) {\n\t\tERROR(\"error: copying %s to %s\", oldpath, newpath);\n\t\treturn -1;\n\t}\n\tfree(c->lxc_conf->fstab);\n\tc->lxc_conf->fstab = strdup(newpath);\n\tif (!c->lxc_conf->fstab) {\n\t\tERROR(\"error: allocating pathname\");\n\t\treturn -1;\n\t}\n\tif (!do_append_unexp_config_line(c->lxc_conf, \"lxc.mount\", newpath)) {\n\t\tERROR(\"error saving new lxctab\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"error saving new lxctab\""
          ],
          "line": 2775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_append_unexp_config_line",
          "args": [
            "c->lxc_conf",
            "\"lxc.mount\"",
            "newpath"
          ],
          "line": 2774
        },
        "resolved": true,
        "details": {
          "function_name": "do_append_unexp_config_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/confile.c",
          "lines": "2732-2747",
          "snippet": "bool do_append_unexp_config_line(struct lxc_conf *conf, const char *key, const char *v)\n{\n\tint ret;\n\tsize_t len = strlen(key) + strlen(v) + 4;\n\tchar *tmp = alloca(len);\n\n\tret = snprintf(tmp, len, \"%s = %s\", key, v);\n\tif (ret < 0 || ret >= len)\n\t\treturn false;\n\n\t/* Save the line verbatim into unexpanded_conf */\n\tif (append_unexp_config_line(tmp, conf))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"network.h\"",
            "#include \"conf.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"confile.h\"",
            "#include \"config.h\"",
            "#include \"parse.h\"",
            "#include \"bdev.h\"",
            "#include <syslog.h>",
            "#include <dirent.h>",
            "#include <time.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int config_personality(const char *, const char *, struct lxc_conf *);",
            "static int config_pts(const char *, const char *, struct lxc_conf *);",
            "static int config_tty(const char *, const char *, struct lxc_conf *);",
            "static int config_ttydir(const char *, const char *, struct lxc_conf *);",
            "static int config_kmsg(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_aa_profile(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_aa_incomplete(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_se_context(const char *, const char *, struct lxc_conf *);",
            "static int config_cgroup(const char *, const char *, struct lxc_conf *);",
            "static int config_idmap(const char *, const char *, struct lxc_conf *);",
            "static int config_loglevel(const char *, const char *, struct lxc_conf *);",
            "static int config_logfile(const char *, const char *, struct lxc_conf *);",
            "static int config_mount(const char *, const char *, struct lxc_conf *);",
            "static int config_mount_auto(const char *, const char *, struct lxc_conf *);",
            "static int config_fstab(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_mount(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_options(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_backend(const char *, const char *, struct lxc_conf *);",
            "static int config_pivotdir(const char *, const char *, struct lxc_conf *);",
            "static int config_utsname(const char *, const char *, struct lxc_conf *);",
            "static int config_hook(const char *, const char *, struct lxc_conf *lxc_conf);",
            "static int config_network(const char *, const char *, struct lxc_conf *);",
            "static int config_network_type(const char *, const char *, struct lxc_conf *);",
            "static int config_network_flags(const char *, const char *, struct lxc_conf *);",
            "static int config_network_link(const char *, const char *, struct lxc_conf *);",
            "static int config_network_name(const char *, const char *, struct lxc_conf *);",
            "static int config_network_veth_pair(const char *, const char *, struct lxc_conf *);",
            "static int config_network_macvlan_mode(const char *, const char *, struct lxc_conf *);",
            "static int config_network_hwaddr(const char *, const char *, struct lxc_conf *);",
            "static int config_network_vlan_id(const char *, const char *, struct lxc_conf *);",
            "static int config_network_mtu(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv4(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv4_gateway(const char *, const char *, struct lxc_conf *);",
            "static int config_network_script_up(const char *, const char *, struct lxc_conf *);",
            "static int config_network_script_down(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv6(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv6_gateway(const char *, const char *, struct lxc_conf *);",
            "static int config_cap_drop(const char *, const char *, struct lxc_conf *);",
            "static int config_cap_keep(const char *, const char *, struct lxc_conf *);",
            "static int config_console(const char *, const char *, struct lxc_conf *);",
            "static int config_console_logfile(const char *, const char *, struct lxc_conf *);",
            "static int config_seccomp(const char *, const char *, struct lxc_conf *);",
            "static int config_includefile(const char *, const char *, struct lxc_conf *);",
            "static int config_network_nic(const char *, const char *, struct lxc_conf *);",
            "static int config_autodev(const char *, const char *, struct lxc_conf *);",
            "static int config_haltsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_rebootsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_stopsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_start(const char *, const char *, struct lxc_conf *);",
            "static int config_syslog(const char *, const char *, struct lxc_conf *);",
            "static int config_monitor(const char *, const char *, struct lxc_conf *);",
            "static int config_group(const char *, const char *, struct lxc_conf *);",
            "static int config_environment(const char *, const char *, struct lxc_conf *);",
            "static int config_init_cmd(const char *, const char *, struct lxc_conf *);",
            "static int config_init_uid(const char *, const char *, struct lxc_conf *);",
            "static int config_init_gid(const char *, const char *, struct lxc_conf *);",
            "static int config_ephemeral(const char *, const char *, struct lxc_conf *);",
            "static int config_no_new_privs(const char *, const char *, struct lxc_conf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"lxcseccomp.h\"\n#include \"network.h\"\n#include \"conf.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"confile.h\"\n#include \"config.h\"\n#include \"parse.h\"\n#include \"bdev.h\"\n#include <syslog.h>\n#include <dirent.h>\n#include <time.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int config_personality(const char *, const char *, struct lxc_conf *);\nstatic int config_pts(const char *, const char *, struct lxc_conf *);\nstatic int config_tty(const char *, const char *, struct lxc_conf *);\nstatic int config_ttydir(const char *, const char *, struct lxc_conf *);\nstatic int config_kmsg(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_aa_profile(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_aa_incomplete(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_se_context(const char *, const char *, struct lxc_conf *);\nstatic int config_cgroup(const char *, const char *, struct lxc_conf *);\nstatic int config_idmap(const char *, const char *, struct lxc_conf *);\nstatic int config_loglevel(const char *, const char *, struct lxc_conf *);\nstatic int config_logfile(const char *, const char *, struct lxc_conf *);\nstatic int config_mount(const char *, const char *, struct lxc_conf *);\nstatic int config_mount_auto(const char *, const char *, struct lxc_conf *);\nstatic int config_fstab(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_mount(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_options(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_backend(const char *, const char *, struct lxc_conf *);\nstatic int config_pivotdir(const char *, const char *, struct lxc_conf *);\nstatic int config_utsname(const char *, const char *, struct lxc_conf *);\nstatic int config_hook(const char *, const char *, struct lxc_conf *lxc_conf);\nstatic int config_network(const char *, const char *, struct lxc_conf *);\nstatic int config_network_type(const char *, const char *, struct lxc_conf *);\nstatic int config_network_flags(const char *, const char *, struct lxc_conf *);\nstatic int config_network_link(const char *, const char *, struct lxc_conf *);\nstatic int config_network_name(const char *, const char *, struct lxc_conf *);\nstatic int config_network_veth_pair(const char *, const char *, struct lxc_conf *);\nstatic int config_network_macvlan_mode(const char *, const char *, struct lxc_conf *);\nstatic int config_network_hwaddr(const char *, const char *, struct lxc_conf *);\nstatic int config_network_vlan_id(const char *, const char *, struct lxc_conf *);\nstatic int config_network_mtu(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv4(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv4_gateway(const char *, const char *, struct lxc_conf *);\nstatic int config_network_script_up(const char *, const char *, struct lxc_conf *);\nstatic int config_network_script_down(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv6(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv6_gateway(const char *, const char *, struct lxc_conf *);\nstatic int config_cap_drop(const char *, const char *, struct lxc_conf *);\nstatic int config_cap_keep(const char *, const char *, struct lxc_conf *);\nstatic int config_console(const char *, const char *, struct lxc_conf *);\nstatic int config_console_logfile(const char *, const char *, struct lxc_conf *);\nstatic int config_seccomp(const char *, const char *, struct lxc_conf *);\nstatic int config_includefile(const char *, const char *, struct lxc_conf *);\nstatic int config_network_nic(const char *, const char *, struct lxc_conf *);\nstatic int config_autodev(const char *, const char *, struct lxc_conf *);\nstatic int config_haltsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_rebootsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_stopsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_start(const char *, const char *, struct lxc_conf *);\nstatic int config_syslog(const char *, const char *, struct lxc_conf *);\nstatic int config_monitor(const char *, const char *, struct lxc_conf *);\nstatic int config_group(const char *, const char *, struct lxc_conf *);\nstatic int config_environment(const char *, const char *, struct lxc_conf *);\nstatic int config_init_cmd(const char *, const char *, struct lxc_conf *);\nstatic int config_init_uid(const char *, const char *, struct lxc_conf *);\nstatic int config_init_gid(const char *, const char *, struct lxc_conf *);\nstatic int config_ephemeral(const char *, const char *, struct lxc_conf *);\nstatic int config_no_new_privs(const char *, const char *, struct lxc_conf *);\n\nbool do_append_unexp_config_line(struct lxc_conf *conf, const char *key, const char *v)\n{\n\tint ret;\n\tsize_t len = strlen(key) + strlen(v) + 4;\n\tchar *tmp = alloca(len);\n\n\tret = snprintf(tmp, len, \"%s = %s\", key, v);\n\tif (ret < 0 || ret >= len)\n\t\treturn false;\n\n\t/* Save the line verbatim into unexpanded_conf */\n\tif (append_unexp_config_line(tmp, conf))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"error: allocating pathname\""
          ],
          "line": 2771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "newpath"
          ],
          "line": 2769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "c->lxc_conf->fstab"
          ],
          "line": 2768
        },
        "resolved": true,
        "details": {
          "function_name": "free_init_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "706-715",
          "snippet": "static void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"error: copying %s to %s\"",
            "oldpath",
            "newpath"
          ],
          "line": 2765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_file",
          "args": [
            "oldpath",
            "newpath"
          ],
          "line": 2764
        },
        "resolved": true,
        "details": {
          "function_name": "copy_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2628-2687",
          "snippet": "static int copy_file(const char *old, const char *new)\n{\n\tint in, out;\n\tssize_t len, ret;\n\tchar buf[8096];\n\tstruct stat sbuf;\n\n\tif (file_exists(new)) {\n\t\tERROR(\"copy destination %s exists\", new);\n\t\treturn -1;\n\t}\n\tret = stat(old, &sbuf);\n\tif (ret < 0) {\n\t\tINFO(\"Error stat'ing %s\", old);\n\t\treturn -1;\n\t}\n\n\tin = open(old, O_RDONLY);\n\tif (in < 0) {\n\t\tSYSERROR(\"Error opening original file %s\", old);\n\t\treturn -1;\n\t}\n\tout = open(new, O_CREAT | O_EXCL | O_WRONLY, 0644);\n\tif (out < 0) {\n\t\tSYSERROR(\"Error opening new file %s\", new);\n\t\tclose(in);\n\t\treturn -1;\n\t}\n\n\twhile (1) {\n\t\tlen = read(in, buf, 8096);\n\t\tif (len < 0) {\n\t\t\tSYSERROR(\"Error reading old file %s\", old);\n\t\t\tgoto err;\n\t\t}\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tret = write(out, buf, len);\n\t\tif (ret < len) { // should we retry?\n\t\t\tSYSERROR(\"Error: write to new file %s was interrupted\", new);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tclose(in);\n\tclose(out);\n\n\t// we set mode, but not owner/group\n\tret = chmod(new, sbuf.st_mode);\n\tif (ret) {\n\t\tSYSERROR(\"Error setting mode on %s\", new);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n\nerr:\n\tclose(in);\n\tclose(out);\n\treturn -1;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic int copy_file(const char *old, const char *new)\n{\n\tint in, out;\n\tssize_t len, ret;\n\tchar buf[8096];\n\tstruct stat sbuf;\n\n\tif (file_exists(new)) {\n\t\tERROR(\"copy destination %s exists\", new);\n\t\treturn -1;\n\t}\n\tret = stat(old, &sbuf);\n\tif (ret < 0) {\n\t\tINFO(\"Error stat'ing %s\", old);\n\t\treturn -1;\n\t}\n\n\tin = open(old, O_RDONLY);\n\tif (in < 0) {\n\t\tSYSERROR(\"Error opening original file %s\", old);\n\t\treturn -1;\n\t}\n\tout = open(new, O_CREAT | O_EXCL | O_WRONLY, 0644);\n\tif (out < 0) {\n\t\tSYSERROR(\"Error opening new file %s\", new);\n\t\tclose(in);\n\t\treturn -1;\n\t}\n\n\twhile (1) {\n\t\tlen = read(in, buf, 8096);\n\t\tif (len < 0) {\n\t\t\tSYSERROR(\"Error reading old file %s\", old);\n\t\t\tgoto err;\n\t\t}\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tret = write(out, buf, len);\n\t\tif (ret < len) { // should we retry?\n\t\t\tSYSERROR(\"Error: write to new file %s was interrupted\", new);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tclose(in);\n\tclose(out);\n\n\t// we set mode, but not owner/group\n\tret = chmod(new, sbuf.st_mode);\n\tif (ret) {\n\t\tSYSERROR(\"Error setting mode on %s\", new);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n\nerr:\n\tclose(in);\n\tclose(out);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"error: fstab file %s exists\"",
            "newpath"
          ],
          "line": 2760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_exists",
          "args": [
            "newpath"
          ],
          "line": 2759
        },
        "resolved": true,
        "details": {
          "function_name": "file_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1240-1245",
          "snippet": "bool file_exists(const char *f)\n{\n\tstruct stat statbuf;\n\n\treturn stat(f, &statbuf) == 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool file_exists(const char *f)\n{\n\tstruct stat statbuf;\n\n\treturn stat(f, &statbuf) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"error printing new path for %s\"",
            "oldpath"
          ],
          "line": 2756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "newpath",
            "MAXPATHLEN",
            "\"%s/%s%s\"",
            "c->config_path",
            "c->name",
            "p"
          ],
          "line": 2753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "oldpath",
            "'/'"
          ],
          "line": 2750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_unexp_config_line",
          "args": [
            "c->lxc_conf",
            "\"lxc.mount\"",
            "false"
          ],
          "line": 2748
        },
        "resolved": true,
        "details": {
          "function_name": "clear_unexp_config_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/confile.c",
          "lines": "2749-2780",
          "snippet": "void clear_unexp_config_line(struct lxc_conf *conf, const char *key, bool rm_subkeys)\n{\n\tchar *lstart = conf->unexpanded_config, *lend;\n\n\tif (!conf->unexpanded_config)\n\t\treturn;\n\twhile (*lstart) {\n\t\tlend = strchr(lstart, '\\n');\n\t\tchar v;\n\t\tif (!lend)\n\t\t\tlend = lstart + strlen(lstart);\n\t\telse\n\t\t\tlend++;\n\t\tif (strncmp(lstart, key, strlen(key)) != 0) {\n\t\t\tlstart = lend;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!rm_subkeys) {\n\t\t\tv = lstart[strlen(key)];\n\t\t\tif (!isspace(v) && v != '=') {\n\t\t\t\tlstart = lend;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tconf->unexpanded_len -= (lend - lstart);\n\t\tif (*lend == '\\0') {\n\t\t\t*lstart = '\\0';\n\t\t\treturn;\n\t\t}\n\t\tmemmove(lstart, lend, strlen(lend)+1);\n\t}\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"network.h\"",
            "#include \"conf.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"confile.h\"",
            "#include \"config.h\"",
            "#include \"parse.h\"",
            "#include \"bdev.h\"",
            "#include <syslog.h>",
            "#include <dirent.h>",
            "#include <time.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int config_personality(const char *, const char *, struct lxc_conf *);",
            "static int config_pts(const char *, const char *, struct lxc_conf *);",
            "static int config_tty(const char *, const char *, struct lxc_conf *);",
            "static int config_ttydir(const char *, const char *, struct lxc_conf *);",
            "static int config_kmsg(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_aa_profile(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_aa_incomplete(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_se_context(const char *, const char *, struct lxc_conf *);",
            "static int config_cgroup(const char *, const char *, struct lxc_conf *);",
            "static int config_idmap(const char *, const char *, struct lxc_conf *);",
            "static int config_loglevel(const char *, const char *, struct lxc_conf *);",
            "static int config_logfile(const char *, const char *, struct lxc_conf *);",
            "static int config_mount(const char *, const char *, struct lxc_conf *);",
            "static int config_mount_auto(const char *, const char *, struct lxc_conf *);",
            "static int config_fstab(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_mount(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_options(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_backend(const char *, const char *, struct lxc_conf *);",
            "static int config_pivotdir(const char *, const char *, struct lxc_conf *);",
            "static int config_utsname(const char *, const char *, struct lxc_conf *);",
            "static int config_hook(const char *, const char *, struct lxc_conf *lxc_conf);",
            "static int config_network(const char *, const char *, struct lxc_conf *);",
            "static int config_network_type(const char *, const char *, struct lxc_conf *);",
            "static int config_network_flags(const char *, const char *, struct lxc_conf *);",
            "static int config_network_link(const char *, const char *, struct lxc_conf *);",
            "static int config_network_name(const char *, const char *, struct lxc_conf *);",
            "static int config_network_veth_pair(const char *, const char *, struct lxc_conf *);",
            "static int config_network_macvlan_mode(const char *, const char *, struct lxc_conf *);",
            "static int config_network_hwaddr(const char *, const char *, struct lxc_conf *);",
            "static int config_network_vlan_id(const char *, const char *, struct lxc_conf *);",
            "static int config_network_mtu(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv4(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv4_gateway(const char *, const char *, struct lxc_conf *);",
            "static int config_network_script_up(const char *, const char *, struct lxc_conf *);",
            "static int config_network_script_down(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv6(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv6_gateway(const char *, const char *, struct lxc_conf *);",
            "static int config_cap_drop(const char *, const char *, struct lxc_conf *);",
            "static int config_cap_keep(const char *, const char *, struct lxc_conf *);",
            "static int config_console(const char *, const char *, struct lxc_conf *);",
            "static int config_console_logfile(const char *, const char *, struct lxc_conf *);",
            "static int config_seccomp(const char *, const char *, struct lxc_conf *);",
            "static int config_includefile(const char *, const char *, struct lxc_conf *);",
            "static int config_network_nic(const char *, const char *, struct lxc_conf *);",
            "static int config_autodev(const char *, const char *, struct lxc_conf *);",
            "static int config_haltsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_rebootsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_stopsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_start(const char *, const char *, struct lxc_conf *);",
            "static int config_syslog(const char *, const char *, struct lxc_conf *);",
            "static int config_monitor(const char *, const char *, struct lxc_conf *);",
            "static int config_group(const char *, const char *, struct lxc_conf *);",
            "static int config_environment(const char *, const char *, struct lxc_conf *);",
            "static int config_init_cmd(const char *, const char *, struct lxc_conf *);",
            "static int config_init_uid(const char *, const char *, struct lxc_conf *);",
            "static int config_init_gid(const char *, const char *, struct lxc_conf *);",
            "static int config_ephemeral(const char *, const char *, struct lxc_conf *);",
            "static int config_no_new_privs(const char *, const char *, struct lxc_conf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"lxcseccomp.h\"\n#include \"network.h\"\n#include \"conf.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"confile.h\"\n#include \"config.h\"\n#include \"parse.h\"\n#include \"bdev.h\"\n#include <syslog.h>\n#include <dirent.h>\n#include <time.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int config_personality(const char *, const char *, struct lxc_conf *);\nstatic int config_pts(const char *, const char *, struct lxc_conf *);\nstatic int config_tty(const char *, const char *, struct lxc_conf *);\nstatic int config_ttydir(const char *, const char *, struct lxc_conf *);\nstatic int config_kmsg(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_aa_profile(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_aa_incomplete(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_se_context(const char *, const char *, struct lxc_conf *);\nstatic int config_cgroup(const char *, const char *, struct lxc_conf *);\nstatic int config_idmap(const char *, const char *, struct lxc_conf *);\nstatic int config_loglevel(const char *, const char *, struct lxc_conf *);\nstatic int config_logfile(const char *, const char *, struct lxc_conf *);\nstatic int config_mount(const char *, const char *, struct lxc_conf *);\nstatic int config_mount_auto(const char *, const char *, struct lxc_conf *);\nstatic int config_fstab(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_mount(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_options(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_backend(const char *, const char *, struct lxc_conf *);\nstatic int config_pivotdir(const char *, const char *, struct lxc_conf *);\nstatic int config_utsname(const char *, const char *, struct lxc_conf *);\nstatic int config_hook(const char *, const char *, struct lxc_conf *lxc_conf);\nstatic int config_network(const char *, const char *, struct lxc_conf *);\nstatic int config_network_type(const char *, const char *, struct lxc_conf *);\nstatic int config_network_flags(const char *, const char *, struct lxc_conf *);\nstatic int config_network_link(const char *, const char *, struct lxc_conf *);\nstatic int config_network_name(const char *, const char *, struct lxc_conf *);\nstatic int config_network_veth_pair(const char *, const char *, struct lxc_conf *);\nstatic int config_network_macvlan_mode(const char *, const char *, struct lxc_conf *);\nstatic int config_network_hwaddr(const char *, const char *, struct lxc_conf *);\nstatic int config_network_vlan_id(const char *, const char *, struct lxc_conf *);\nstatic int config_network_mtu(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv4(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv4_gateway(const char *, const char *, struct lxc_conf *);\nstatic int config_network_script_up(const char *, const char *, struct lxc_conf *);\nstatic int config_network_script_down(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv6(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv6_gateway(const char *, const char *, struct lxc_conf *);\nstatic int config_cap_drop(const char *, const char *, struct lxc_conf *);\nstatic int config_cap_keep(const char *, const char *, struct lxc_conf *);\nstatic int config_console(const char *, const char *, struct lxc_conf *);\nstatic int config_console_logfile(const char *, const char *, struct lxc_conf *);\nstatic int config_seccomp(const char *, const char *, struct lxc_conf *);\nstatic int config_includefile(const char *, const char *, struct lxc_conf *);\nstatic int config_network_nic(const char *, const char *, struct lxc_conf *);\nstatic int config_autodev(const char *, const char *, struct lxc_conf *);\nstatic int config_haltsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_rebootsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_stopsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_start(const char *, const char *, struct lxc_conf *);\nstatic int config_syslog(const char *, const char *, struct lxc_conf *);\nstatic int config_monitor(const char *, const char *, struct lxc_conf *);\nstatic int config_group(const char *, const char *, struct lxc_conf *);\nstatic int config_environment(const char *, const char *, struct lxc_conf *);\nstatic int config_init_cmd(const char *, const char *, struct lxc_conf *);\nstatic int config_init_uid(const char *, const char *, struct lxc_conf *);\nstatic int config_init_gid(const char *, const char *, struct lxc_conf *);\nstatic int config_ephemeral(const char *, const char *, struct lxc_conf *);\nstatic int config_no_new_privs(const char *, const char *, struct lxc_conf *);\n\nvoid clear_unexp_config_line(struct lxc_conf *conf, const char *key, bool rm_subkeys)\n{\n\tchar *lstart = conf->unexpanded_config, *lend;\n\n\tif (!conf->unexpanded_config)\n\t\treturn;\n\twhile (*lstart) {\n\t\tlend = strchr(lstart, '\\n');\n\t\tchar v;\n\t\tif (!lend)\n\t\t\tlend = lstart + strlen(lstart);\n\t\telse\n\t\t\tlend++;\n\t\tif (strncmp(lstart, key, strlen(key)) != 0) {\n\t\t\tlstart = lend;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!rm_subkeys) {\n\t\t\tv = lstart[strlen(key)];\n\t\t\tif (!isspace(v) && v != '=') {\n\t\t\t\tlstart = lend;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tconf->unexpanded_len -= (lend - lstart);\n\t\tif (*lend == '\\0') {\n\t\t\t*lstart = '\\0';\n\t\t\treturn;\n\t\t}\n\t\tmemmove(lstart, lend, strlen(lend)+1);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic int copy_fstab(struct lxc_container *oldc, struct lxc_container *c)\n{\n\tchar newpath[MAXPATHLEN];\n\tchar *oldpath = oldc->lxc_conf->fstab;\n\tint ret;\n\n\tif (!oldpath)\n\t\treturn 0;\n\n\tclear_unexp_config_line(c->lxc_conf, \"lxc.mount\", false);\n\n\tchar *p = strrchr(oldpath, '/');\n\tif (!p)\n\t\treturn -1;\n\tret = snprintf(newpath, MAXPATHLEN, \"%s/%s%s\",\n\t\t\tc->config_path, c->name, p);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tERROR(\"error printing new path for %s\", oldpath);\n\t\treturn -1;\n\t}\n\tif (file_exists(newpath)) {\n\t\tERROR(\"error: fstab file %s exists\", newpath);\n\t\treturn -1;\n\t}\n\n\tif (copy_file(oldpath, newpath) < 0) {\n\t\tERROR(\"error: copying %s to %s\", oldpath, newpath);\n\t\treturn -1;\n\t}\n\tfree(c->lxc_conf->fstab);\n\tc->lxc_conf->fstab = strdup(newpath);\n\tif (!c->lxc_conf->fstab) {\n\t\tERROR(\"error: allocating pathname\");\n\t\treturn -1;\n\t}\n\tif (!do_append_unexp_config_line(c->lxc_conf, \"lxc.mount\", newpath)) {\n\t\tERROR(\"error saving new lxctab\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "copyhooks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "2689-2736",
    "snippet": "static int copyhooks(struct lxc_container *oldc, struct lxc_container *c)\n{\n\tint i, len, ret;\n\tstruct lxc_list *it;\n\tchar *cpath;\n\n\tlen = strlen(oldc->config_path) + strlen(oldc->name) + 3;\n\tcpath = alloca(len);\n\tret = snprintf(cpath, len, \"%s/%s/\", oldc->config_path, oldc->name);\n\tif (ret < 0 || ret >= len)\n\t\treturn -1;\n\n\tfor (i=0; i<NUM_LXC_HOOKS; i++) {\n\t\tlxc_list_for_each(it, &c->lxc_conf->hooks[i]) {\n\t\t\tchar *hookname = it->elem;\n\t\t\tchar *fname = strrchr(hookname, '/');\n\t\t\tchar tmppath[MAXPATHLEN];\n\t\t\tif (!fname) // relative path - we don't support, but maybe we should\n\t\t\t\treturn 0;\n\t\t\tif (strncmp(hookname, cpath, len - 1) != 0) {\n\t\t\t\t// this hook is public - ignore\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// copy the script, and change the entry in confile\n\t\t\tret = snprintf(tmppath, MAXPATHLEN, \"%s/%s/%s\",\n\t\t\t\t\tc->config_path, c->name, fname+1);\n\t\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\t\treturn -1;\n\t\t\tret = copy_file(it->elem, tmppath);\n\t\t\tif (ret < 0)\n\t\t\t\treturn -1;\n\t\t\tfree(it->elem);\n\t\t\tit->elem = strdup(tmppath);\n\t\t\tif (!it->elem) {\n\t\t\t\tERROR(\"out of memory copying hook path\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!clone_update_unexp_hooks(c->lxc_conf, oldc->config_path,\n\t\t\tc->config_path, oldc->name, c->name)) {\n\t\tERROR(\"Error saving new hooks in clone\");\n\t\treturn -1;\n\t}\n\tdo_lxcapi_save_config(c, NULL);\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_lxcapi_save_config",
          "args": [
            "c",
            "NULL"
          ],
          "line": 2734
        },
        "resolved": true,
        "details": {
          "function_name": "do_lxcapi_save_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2040-2091",
          "snippet": "static bool do_lxcapi_save_config(struct lxc_container *c, const char *alt_file)\n{\n\tFILE *fout;\n\tbool ret = false, need_disklock = false;\n\tint lret;\n\n\tif (!alt_file)\n\t\talt_file = c->configfile;\n\tif (!alt_file)\n\t\treturn false; // should we write to stdout if no file is specified?\n\n\t// If we haven't yet loaded a config, load the stock config\n\tif (!c->lxc_conf) {\n\t\tif (!do_lxcapi_load_config(c, lxc_global_config_value(\"lxc.default_config\"))) {\n\t\t\tERROR(\"Error loading default configuration file %s while saving %s\", lxc_global_config_value(\"lxc.default_config\"), c->name);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (!create_container_dir(c))\n\t\treturn false;\n\n\t/*\n\t * If we're writing to the container's config file, take the\n\t * disk lock.  Otherwise just take the memlock to protect the\n\t * struct lxc_container while we're traversing it.\n\t */\n\tif (strcmp(c->configfile, alt_file) == 0)\n\t\tneed_disklock = true;\n\n\tif (need_disklock)\n\t\tlret = container_disk_lock(c);\n\telse\n\t\tlret = container_mem_lock(c);\n\n\tif (lret)\n\t\treturn false;\n\n\tfout = fopen(alt_file, \"w\");\n\tif (!fout)\n\t\tgoto out;\n\twrite_config(fout, c->lxc_conf);\n\tfclose(fout);\n\tret = true;\n\nout:\n\tif (need_disklock)\n\t\tcontainer_disk_unlock(c);\n\telse\n\t\tcontainer_mem_unlock(c);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);",
            "static bool do_lxcapi_save_config(struct lxc_container *c, const char *alt_file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\nstatic bool do_lxcapi_save_config(struct lxc_container *c, const char *alt_file);\n\nstatic bool do_lxcapi_save_config(struct lxc_container *c, const char *alt_file)\n{\n\tFILE *fout;\n\tbool ret = false, need_disklock = false;\n\tint lret;\n\n\tif (!alt_file)\n\t\talt_file = c->configfile;\n\tif (!alt_file)\n\t\treturn false; // should we write to stdout if no file is specified?\n\n\t// If we haven't yet loaded a config, load the stock config\n\tif (!c->lxc_conf) {\n\t\tif (!do_lxcapi_load_config(c, lxc_global_config_value(\"lxc.default_config\"))) {\n\t\t\tERROR(\"Error loading default configuration file %s while saving %s\", lxc_global_config_value(\"lxc.default_config\"), c->name);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (!create_container_dir(c))\n\t\treturn false;\n\n\t/*\n\t * If we're writing to the container's config file, take the\n\t * disk lock.  Otherwise just take the memlock to protect the\n\t * struct lxc_container while we're traversing it.\n\t */\n\tif (strcmp(c->configfile, alt_file) == 0)\n\t\tneed_disklock = true;\n\n\tif (need_disklock)\n\t\tlret = container_disk_lock(c);\n\telse\n\t\tlret = container_mem_lock(c);\n\n\tif (lret)\n\t\treturn false;\n\n\tfout = fopen(alt_file, \"w\");\n\tif (!fout)\n\t\tgoto out;\n\twrite_config(fout, c->lxc_conf);\n\tfclose(fout);\n\tret = true;\n\nout:\n\tif (need_disklock)\n\t\tcontainer_disk_unlock(c);\n\telse\n\t\tcontainer_mem_unlock(c);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error saving new hooks in clone\""
          ],
          "line": 2731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clone_update_unexp_hooks",
          "args": [
            "c->lxc_conf",
            "oldc->config_path",
            "c->config_path",
            "oldc->name",
            "c->name"
          ],
          "line": 2729
        },
        "resolved": true,
        "details": {
          "function_name": "clone_update_unexp_hooks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/confile.c",
          "lines": "2878-2957",
          "snippet": "bool clone_update_unexp_hooks(struct lxc_conf *conf, const char *oldpath,\n\t\t\t      const char *newpath, const char *oldname,\n\t\t\t      const char *newname)\n{\n\tconst char *key = \"lxc.hook\";\n\tint ret;\n\tchar *lstart = conf->unexpanded_config, *lend, *p;\n\tsize_t newdirlen = strlen(newpath) + strlen(newname) + 1;\n\tsize_t olddirlen = strlen(oldpath) + strlen(oldname) + 1;\n\tchar *olddir = alloca(olddirlen + 1);\n\tchar *newdir = alloca(newdirlen + 1);\n\n\tret = snprintf(olddir, olddirlen + 1, \"%s/%s\", oldpath, oldname);\n\tif (ret < 0 || ret >= olddirlen + 1) {\n\t\tERROR(\"Bug in %s\", __func__);\n\t\treturn false;\n\t}\n\tret = snprintf(newdir, newdirlen + 1, \"%s/%s\", newpath, newname);\n\tif (ret < 0 || ret >= newdirlen + 1) {\n\t\tERROR(\"Bug in %s\", __func__);\n\t\treturn false;\n\t}\n\tif (!conf->unexpanded_config)\n\t\treturn true;\n\twhile (*lstart) {\n\t\tlend = strchr(lstart, '\\n');\n\t\tif (!lend)\n\t\t\tlend = lstart + strlen(lstart);\n\t\telse\n\t\t\tlend++;\n\t\tif (strncmp(lstart, key, strlen(key)) != 0)\n                        goto next;\n\t\tp = strchr(lstart + strlen(key), '=');\n\t\tif (!p)\n                        goto next;\n\t\tp++;\n\t\twhile (isblank(*p))\n\t\t\tp++;\n                if (p >= lend)\n                        goto next;\n\t\tif (strncmp(p, olddir, strlen(olddir)) != 0)\n                        goto next;\n\t\t/* replace the olddir with newdir */\n\t\tif (olddirlen >= newdirlen) {\n\t\t\tsize_t diff = olddirlen - newdirlen;\n\t\t\tmemcpy(p, newdir, newdirlen);\n\t\t\tif (olddirlen != newdirlen) {\n\t\t\t\tmemmove(p + newdirlen, p + newdirlen + diff,\n\t\t\t\t\tstrlen(p) - newdirlen - diff + 1);\n\t\t\t\tlend -= diff;\n\t\t\t\tconf->unexpanded_len -= diff;\n\t\t\t}\n\t\t} else {\n\t\t\tchar *new;\n\t\t\tsize_t diff = newdirlen - olddirlen;\n\t\t\tsize_t oldlen = conf->unexpanded_len;\n\t\t\tsize_t newlen = oldlen + diff;\n\t\t\tsize_t poffset = p - conf->unexpanded_config;\n\t\t\tnew = realloc(conf->unexpanded_config, newlen + 1);\n\t\t\tif (!new) {\n\t\t\t\tERROR(\"Out of memory\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tconf->unexpanded_len = newlen;\n\t\t\tconf->unexpanded_alloced = newlen + 1;\n\t\t\tnew[newlen - 1] = '\\0';\n\t\t\tlend = new + (lend - conf->unexpanded_config);\n\t\t\t/* move over the remainder to make room for the newdir */\n\t\t\tmemmove(new + poffset + newdirlen,\n\t\t\t\tnew + poffset + olddirlen,\n\t\t\t\toldlen - poffset - olddirlen + 1);\n\t\t\tconf->unexpanded_config = new;\n\t\t\tmemcpy(new + poffset, newdir, newdirlen);\n\t\t\tlend += diff;\n\t\t}\nnext:\n\t\t\tlstart = lend;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"network.h\"",
            "#include \"conf.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"confile.h\"",
            "#include \"config.h\"",
            "#include \"parse.h\"",
            "#include \"bdev.h\"",
            "#include <syslog.h>",
            "#include <dirent.h>",
            "#include <time.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int config_personality(const char *, const char *, struct lxc_conf *);",
            "static int config_pts(const char *, const char *, struct lxc_conf *);",
            "static int config_tty(const char *, const char *, struct lxc_conf *);",
            "static int config_ttydir(const char *, const char *, struct lxc_conf *);",
            "static int config_kmsg(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_aa_profile(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_aa_incomplete(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_se_context(const char *, const char *, struct lxc_conf *);",
            "static int config_cgroup(const char *, const char *, struct lxc_conf *);",
            "static int config_idmap(const char *, const char *, struct lxc_conf *);",
            "static int config_loglevel(const char *, const char *, struct lxc_conf *);",
            "static int config_logfile(const char *, const char *, struct lxc_conf *);",
            "static int config_mount(const char *, const char *, struct lxc_conf *);",
            "static int config_mount_auto(const char *, const char *, struct lxc_conf *);",
            "static int config_fstab(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_mount(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_options(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_backend(const char *, const char *, struct lxc_conf *);",
            "static int config_pivotdir(const char *, const char *, struct lxc_conf *);",
            "static int config_utsname(const char *, const char *, struct lxc_conf *);",
            "static int config_hook(const char *, const char *, struct lxc_conf *lxc_conf);",
            "static int config_network(const char *, const char *, struct lxc_conf *);",
            "static int config_network_type(const char *, const char *, struct lxc_conf *);",
            "static int config_network_flags(const char *, const char *, struct lxc_conf *);",
            "static int config_network_link(const char *, const char *, struct lxc_conf *);",
            "static int config_network_name(const char *, const char *, struct lxc_conf *);",
            "static int config_network_veth_pair(const char *, const char *, struct lxc_conf *);",
            "static int config_network_macvlan_mode(const char *, const char *, struct lxc_conf *);",
            "static int config_network_hwaddr(const char *, const char *, struct lxc_conf *);",
            "static int config_network_vlan_id(const char *, const char *, struct lxc_conf *);",
            "static int config_network_mtu(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv4(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv4_gateway(const char *, const char *, struct lxc_conf *);",
            "static int config_network_script_up(const char *, const char *, struct lxc_conf *);",
            "static int config_network_script_down(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv6(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv6_gateway(const char *, const char *, struct lxc_conf *);",
            "static int config_cap_drop(const char *, const char *, struct lxc_conf *);",
            "static int config_cap_keep(const char *, const char *, struct lxc_conf *);",
            "static int config_console(const char *, const char *, struct lxc_conf *);",
            "static int config_console_logfile(const char *, const char *, struct lxc_conf *);",
            "static int config_seccomp(const char *, const char *, struct lxc_conf *);",
            "static int config_includefile(const char *, const char *, struct lxc_conf *);",
            "static int config_network_nic(const char *, const char *, struct lxc_conf *);",
            "static int config_autodev(const char *, const char *, struct lxc_conf *);",
            "static int config_haltsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_rebootsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_stopsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_start(const char *, const char *, struct lxc_conf *);",
            "static int config_syslog(const char *, const char *, struct lxc_conf *);",
            "static int config_monitor(const char *, const char *, struct lxc_conf *);",
            "static int config_group(const char *, const char *, struct lxc_conf *);",
            "static int config_environment(const char *, const char *, struct lxc_conf *);",
            "static int config_init_cmd(const char *, const char *, struct lxc_conf *);",
            "static int config_init_uid(const char *, const char *, struct lxc_conf *);",
            "static int config_init_gid(const char *, const char *, struct lxc_conf *);",
            "static int config_ephemeral(const char *, const char *, struct lxc_conf *);",
            "static int config_no_new_privs(const char *, const char *, struct lxc_conf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"lxcseccomp.h\"\n#include \"network.h\"\n#include \"conf.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"confile.h\"\n#include \"config.h\"\n#include \"parse.h\"\n#include \"bdev.h\"\n#include <syslog.h>\n#include <dirent.h>\n#include <time.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int config_personality(const char *, const char *, struct lxc_conf *);\nstatic int config_pts(const char *, const char *, struct lxc_conf *);\nstatic int config_tty(const char *, const char *, struct lxc_conf *);\nstatic int config_ttydir(const char *, const char *, struct lxc_conf *);\nstatic int config_kmsg(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_aa_profile(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_aa_incomplete(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_se_context(const char *, const char *, struct lxc_conf *);\nstatic int config_cgroup(const char *, const char *, struct lxc_conf *);\nstatic int config_idmap(const char *, const char *, struct lxc_conf *);\nstatic int config_loglevel(const char *, const char *, struct lxc_conf *);\nstatic int config_logfile(const char *, const char *, struct lxc_conf *);\nstatic int config_mount(const char *, const char *, struct lxc_conf *);\nstatic int config_mount_auto(const char *, const char *, struct lxc_conf *);\nstatic int config_fstab(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_mount(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_options(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_backend(const char *, const char *, struct lxc_conf *);\nstatic int config_pivotdir(const char *, const char *, struct lxc_conf *);\nstatic int config_utsname(const char *, const char *, struct lxc_conf *);\nstatic int config_hook(const char *, const char *, struct lxc_conf *lxc_conf);\nstatic int config_network(const char *, const char *, struct lxc_conf *);\nstatic int config_network_type(const char *, const char *, struct lxc_conf *);\nstatic int config_network_flags(const char *, const char *, struct lxc_conf *);\nstatic int config_network_link(const char *, const char *, struct lxc_conf *);\nstatic int config_network_name(const char *, const char *, struct lxc_conf *);\nstatic int config_network_veth_pair(const char *, const char *, struct lxc_conf *);\nstatic int config_network_macvlan_mode(const char *, const char *, struct lxc_conf *);\nstatic int config_network_hwaddr(const char *, const char *, struct lxc_conf *);\nstatic int config_network_vlan_id(const char *, const char *, struct lxc_conf *);\nstatic int config_network_mtu(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv4(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv4_gateway(const char *, const char *, struct lxc_conf *);\nstatic int config_network_script_up(const char *, const char *, struct lxc_conf *);\nstatic int config_network_script_down(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv6(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv6_gateway(const char *, const char *, struct lxc_conf *);\nstatic int config_cap_drop(const char *, const char *, struct lxc_conf *);\nstatic int config_cap_keep(const char *, const char *, struct lxc_conf *);\nstatic int config_console(const char *, const char *, struct lxc_conf *);\nstatic int config_console_logfile(const char *, const char *, struct lxc_conf *);\nstatic int config_seccomp(const char *, const char *, struct lxc_conf *);\nstatic int config_includefile(const char *, const char *, struct lxc_conf *);\nstatic int config_network_nic(const char *, const char *, struct lxc_conf *);\nstatic int config_autodev(const char *, const char *, struct lxc_conf *);\nstatic int config_haltsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_rebootsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_stopsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_start(const char *, const char *, struct lxc_conf *);\nstatic int config_syslog(const char *, const char *, struct lxc_conf *);\nstatic int config_monitor(const char *, const char *, struct lxc_conf *);\nstatic int config_group(const char *, const char *, struct lxc_conf *);\nstatic int config_environment(const char *, const char *, struct lxc_conf *);\nstatic int config_init_cmd(const char *, const char *, struct lxc_conf *);\nstatic int config_init_uid(const char *, const char *, struct lxc_conf *);\nstatic int config_init_gid(const char *, const char *, struct lxc_conf *);\nstatic int config_ephemeral(const char *, const char *, struct lxc_conf *);\nstatic int config_no_new_privs(const char *, const char *, struct lxc_conf *);\n\nbool clone_update_unexp_hooks(struct lxc_conf *conf, const char *oldpath,\n\t\t\t      const char *newpath, const char *oldname,\n\t\t\t      const char *newname)\n{\n\tconst char *key = \"lxc.hook\";\n\tint ret;\n\tchar *lstart = conf->unexpanded_config, *lend, *p;\n\tsize_t newdirlen = strlen(newpath) + strlen(newname) + 1;\n\tsize_t olddirlen = strlen(oldpath) + strlen(oldname) + 1;\n\tchar *olddir = alloca(olddirlen + 1);\n\tchar *newdir = alloca(newdirlen + 1);\n\n\tret = snprintf(olddir, olddirlen + 1, \"%s/%s\", oldpath, oldname);\n\tif (ret < 0 || ret >= olddirlen + 1) {\n\t\tERROR(\"Bug in %s\", __func__);\n\t\treturn false;\n\t}\n\tret = snprintf(newdir, newdirlen + 1, \"%s/%s\", newpath, newname);\n\tif (ret < 0 || ret >= newdirlen + 1) {\n\t\tERROR(\"Bug in %s\", __func__);\n\t\treturn false;\n\t}\n\tif (!conf->unexpanded_config)\n\t\treturn true;\n\twhile (*lstart) {\n\t\tlend = strchr(lstart, '\\n');\n\t\tif (!lend)\n\t\t\tlend = lstart + strlen(lstart);\n\t\telse\n\t\t\tlend++;\n\t\tif (strncmp(lstart, key, strlen(key)) != 0)\n                        goto next;\n\t\tp = strchr(lstart + strlen(key), '=');\n\t\tif (!p)\n                        goto next;\n\t\tp++;\n\t\twhile (isblank(*p))\n\t\t\tp++;\n                if (p >= lend)\n                        goto next;\n\t\tif (strncmp(p, olddir, strlen(olddir)) != 0)\n                        goto next;\n\t\t/* replace the olddir with newdir */\n\t\tif (olddirlen >= newdirlen) {\n\t\t\tsize_t diff = olddirlen - newdirlen;\n\t\t\tmemcpy(p, newdir, newdirlen);\n\t\t\tif (olddirlen != newdirlen) {\n\t\t\t\tmemmove(p + newdirlen, p + newdirlen + diff,\n\t\t\t\t\tstrlen(p) - newdirlen - diff + 1);\n\t\t\t\tlend -= diff;\n\t\t\t\tconf->unexpanded_len -= diff;\n\t\t\t}\n\t\t} else {\n\t\t\tchar *new;\n\t\t\tsize_t diff = newdirlen - olddirlen;\n\t\t\tsize_t oldlen = conf->unexpanded_len;\n\t\t\tsize_t newlen = oldlen + diff;\n\t\t\tsize_t poffset = p - conf->unexpanded_config;\n\t\t\tnew = realloc(conf->unexpanded_config, newlen + 1);\n\t\t\tif (!new) {\n\t\t\t\tERROR(\"Out of memory\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tconf->unexpanded_len = newlen;\n\t\t\tconf->unexpanded_alloced = newlen + 1;\n\t\t\tnew[newlen - 1] = '\\0';\n\t\t\tlend = new + (lend - conf->unexpanded_config);\n\t\t\t/* move over the remainder to make room for the newdir */\n\t\t\tmemmove(new + poffset + newdirlen,\n\t\t\t\tnew + poffset + olddirlen,\n\t\t\t\toldlen - poffset - olddirlen + 1);\n\t\t\tconf->unexpanded_config = new;\n\t\t\tmemcpy(new + poffset, newdir, newdirlen);\n\t\t\tlend += diff;\n\t\t}\nnext:\n\t\t\tlstart = lend;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"out of memory copying hook path\""
          ],
          "line": 2723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "tmppath"
          ],
          "line": 2721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "it->elem"
          ],
          "line": 2720
        },
        "resolved": true,
        "details": {
          "function_name": "free_init_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "706-715",
          "snippet": "static void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_file",
          "args": [
            "it->elem",
            "tmppath"
          ],
          "line": 2717
        },
        "resolved": true,
        "details": {
          "function_name": "copy_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2628-2687",
          "snippet": "static int copy_file(const char *old, const char *new)\n{\n\tint in, out;\n\tssize_t len, ret;\n\tchar buf[8096];\n\tstruct stat sbuf;\n\n\tif (file_exists(new)) {\n\t\tERROR(\"copy destination %s exists\", new);\n\t\treturn -1;\n\t}\n\tret = stat(old, &sbuf);\n\tif (ret < 0) {\n\t\tINFO(\"Error stat'ing %s\", old);\n\t\treturn -1;\n\t}\n\n\tin = open(old, O_RDONLY);\n\tif (in < 0) {\n\t\tSYSERROR(\"Error opening original file %s\", old);\n\t\treturn -1;\n\t}\n\tout = open(new, O_CREAT | O_EXCL | O_WRONLY, 0644);\n\tif (out < 0) {\n\t\tSYSERROR(\"Error opening new file %s\", new);\n\t\tclose(in);\n\t\treturn -1;\n\t}\n\n\twhile (1) {\n\t\tlen = read(in, buf, 8096);\n\t\tif (len < 0) {\n\t\t\tSYSERROR(\"Error reading old file %s\", old);\n\t\t\tgoto err;\n\t\t}\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tret = write(out, buf, len);\n\t\tif (ret < len) { // should we retry?\n\t\t\tSYSERROR(\"Error: write to new file %s was interrupted\", new);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tclose(in);\n\tclose(out);\n\n\t// we set mode, but not owner/group\n\tret = chmod(new, sbuf.st_mode);\n\tif (ret) {\n\t\tSYSERROR(\"Error setting mode on %s\", new);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n\nerr:\n\tclose(in);\n\tclose(out);\n\treturn -1;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic int copy_file(const char *old, const char *new)\n{\n\tint in, out;\n\tssize_t len, ret;\n\tchar buf[8096];\n\tstruct stat sbuf;\n\n\tif (file_exists(new)) {\n\t\tERROR(\"copy destination %s exists\", new);\n\t\treturn -1;\n\t}\n\tret = stat(old, &sbuf);\n\tif (ret < 0) {\n\t\tINFO(\"Error stat'ing %s\", old);\n\t\treturn -1;\n\t}\n\n\tin = open(old, O_RDONLY);\n\tif (in < 0) {\n\t\tSYSERROR(\"Error opening original file %s\", old);\n\t\treturn -1;\n\t}\n\tout = open(new, O_CREAT | O_EXCL | O_WRONLY, 0644);\n\tif (out < 0) {\n\t\tSYSERROR(\"Error opening new file %s\", new);\n\t\tclose(in);\n\t\treturn -1;\n\t}\n\n\twhile (1) {\n\t\tlen = read(in, buf, 8096);\n\t\tif (len < 0) {\n\t\t\tSYSERROR(\"Error reading old file %s\", old);\n\t\t\tgoto err;\n\t\t}\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tret = write(out, buf, len);\n\t\tif (ret < len) { // should we retry?\n\t\t\tSYSERROR(\"Error: write to new file %s was interrupted\", new);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tclose(in);\n\tclose(out);\n\n\t// we set mode, but not owner/group\n\tret = chmod(new, sbuf.st_mode);\n\tif (ret) {\n\t\tSYSERROR(\"Error setting mode on %s\", new);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n\nerr:\n\tclose(in);\n\tclose(out);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tmppath",
            "MAXPATHLEN",
            "\"%s/%s/%s\"",
            "c->config_path",
            "c->name",
            "fname+1"
          ],
          "line": 2713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "hookname",
            "cpath",
            "len - 1"
          ],
          "line": 2708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "hookname",
            "'/'"
          ],
          "line": 2704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "it",
            "&c->lxc_conf->hooks[i]"
          ],
          "line": 2702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "cpath",
            "len",
            "\"%s/%s/\"",
            "oldc->config_path",
            "oldc->name"
          ],
          "line": 2697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "len"
          ],
          "line": 2696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "oldc->name"
          ],
          "line": 2695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "oldc->config_path"
          ],
          "line": 2695
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic int copyhooks(struct lxc_container *oldc, struct lxc_container *c)\n{\n\tint i, len, ret;\n\tstruct lxc_list *it;\n\tchar *cpath;\n\n\tlen = strlen(oldc->config_path) + strlen(oldc->name) + 3;\n\tcpath = alloca(len);\n\tret = snprintf(cpath, len, \"%s/%s/\", oldc->config_path, oldc->name);\n\tif (ret < 0 || ret >= len)\n\t\treturn -1;\n\n\tfor (i=0; i<NUM_LXC_HOOKS; i++) {\n\t\tlxc_list_for_each(it, &c->lxc_conf->hooks[i]) {\n\t\t\tchar *hookname = it->elem;\n\t\t\tchar *fname = strrchr(hookname, '/');\n\t\t\tchar tmppath[MAXPATHLEN];\n\t\t\tif (!fname) // relative path - we don't support, but maybe we should\n\t\t\t\treturn 0;\n\t\t\tif (strncmp(hookname, cpath, len - 1) != 0) {\n\t\t\t\t// this hook is public - ignore\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// copy the script, and change the entry in confile\n\t\t\tret = snprintf(tmppath, MAXPATHLEN, \"%s/%s/%s\",\n\t\t\t\t\tc->config_path, c->name, fname+1);\n\t\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\t\treturn -1;\n\t\t\tret = copy_file(it->elem, tmppath);\n\t\t\tif (ret < 0)\n\t\t\t\treturn -1;\n\t\t\tfree(it->elem);\n\t\t\tit->elem = strdup(tmppath);\n\t\t\tif (!it->elem) {\n\t\t\t\tERROR(\"out of memory copying hook path\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!clone_update_unexp_hooks(c->lxc_conf, oldc->config_path,\n\t\t\tc->config_path, oldc->name, c->name)) {\n\t\tERROR(\"Error saving new hooks in clone\");\n\t\treturn -1;\n\t}\n\tdo_lxcapi_save_config(c, NULL);\n\treturn 0;\n}"
  },
  {
    "function_name": "copy_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "2628-2687",
    "snippet": "static int copy_file(const char *old, const char *new)\n{\n\tint in, out;\n\tssize_t len, ret;\n\tchar buf[8096];\n\tstruct stat sbuf;\n\n\tif (file_exists(new)) {\n\t\tERROR(\"copy destination %s exists\", new);\n\t\treturn -1;\n\t}\n\tret = stat(old, &sbuf);\n\tif (ret < 0) {\n\t\tINFO(\"Error stat'ing %s\", old);\n\t\treturn -1;\n\t}\n\n\tin = open(old, O_RDONLY);\n\tif (in < 0) {\n\t\tSYSERROR(\"Error opening original file %s\", old);\n\t\treturn -1;\n\t}\n\tout = open(new, O_CREAT | O_EXCL | O_WRONLY, 0644);\n\tif (out < 0) {\n\t\tSYSERROR(\"Error opening new file %s\", new);\n\t\tclose(in);\n\t\treturn -1;\n\t}\n\n\twhile (1) {\n\t\tlen = read(in, buf, 8096);\n\t\tif (len < 0) {\n\t\t\tSYSERROR(\"Error reading old file %s\", old);\n\t\t\tgoto err;\n\t\t}\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tret = write(out, buf, len);\n\t\tif (ret < len) { // should we retry?\n\t\t\tSYSERROR(\"Error: write to new file %s was interrupted\", new);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tclose(in);\n\tclose(out);\n\n\t// we set mode, but not owner/group\n\tret = chmod(new, sbuf.st_mode);\n\tif (ret) {\n\t\tSYSERROR(\"Error setting mode on %s\", new);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n\nerr:\n\tclose(in);\n\tclose(out);\n\treturn -1;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "out"
          ],
          "line": 2685
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error setting mode on %s\"",
            "new"
          ],
          "line": 2677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "new",
            "sbuf.st_mode"
          ],
          "line": 2675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error: write to new file %s was interrupted\"",
            "new"
          ],
          "line": 2667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "out",
            "buf",
            "len"
          ],
          "line": 2665
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_nointr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "327-335",
          "snippet": "ssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error reading old file %s\"",
            "old"
          ],
          "line": 2660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "in",
            "buf",
            "8096"
          ],
          "line": 2658
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "962-990",
          "snippet": "int lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error opening new file %s\"",
            "new"
          ],
          "line": 2652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "new",
            "O_CREAT | O_EXCL | O_WRONLY",
            "0644"
          ],
          "line": 2650
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "37-82",
          "snippet": "int lxc_abstract_unix_open(const char *path, int type, int flags)\n{\n\tint fd;\n\tsize_t len;\n\tstruct sockaddr_un addr;\n\n\tif (flags & O_TRUNC)\n\t\tunlink(path);\n\n\tfd = socket(PF_UNIX, type, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\n\t/* Clear address structure */\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (!path)\n\t\treturn fd;\n\n\taddr.sun_family = AF_UNIX;\n\n\tlen = strlen(&path[1]) + 1;\n\tif (len >= sizeof(addr.sun_path) - 1) {\n\t\tclose(fd);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\t/* addr.sun_path[0] has already been set to 0 by memset() */\n\tstrncpy(&addr.sun_path[1], &path[1], strlen(&path[1]));\n\n\tif (bind(fd, (struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path) + len)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\tif (type == SOCK_STREAM && listen(fd, 100)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_open(const char *path, int type, int flags)\n{\n\tint fd;\n\tsize_t len;\n\tstruct sockaddr_un addr;\n\n\tif (flags & O_TRUNC)\n\t\tunlink(path);\n\n\tfd = socket(PF_UNIX, type, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\n\t/* Clear address structure */\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (!path)\n\t\treturn fd;\n\n\taddr.sun_family = AF_UNIX;\n\n\tlen = strlen(&path[1]) + 1;\n\tif (len >= sizeof(addr.sun_path) - 1) {\n\t\tclose(fd);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\t/* addr.sun_path[0] has already been set to 0 by memset() */\n\tstrncpy(&addr.sun_path[1], &path[1], strlen(&path[1]));\n\n\tif (bind(fd, (struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path) + len)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\tif (type == SOCK_STREAM && listen(fd, 100)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error opening original file %s\"",
            "old"
          ],
          "line": 2647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "old",
            "O_RDONLY"
          ],
          "line": 2645
        },
        "resolved": true,
        "details": {
          "function_name": "genetlink_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/genl.c",
          "lines": "106-116",
          "snippet": "extern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"genl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/genetlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"genl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Error stat'ing %s\"",
            "old"
          ],
          "line": 2641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "old",
            "&sbuf"
          ],
          "line": 2639
        },
        "resolved": true,
        "details": {
          "function_name": "freezer_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/freezer.c",
          "lines": "42-51",
          "snippet": "lxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}",
          "includes": [
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"monitor.h\"",
            "#include \"state.h\"",
            "#include \"error.h\"",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxc.h\"\n#include \"log.h\"\n#include \"monitor.h\"\n#include \"state.h\"\n#include \"error.h\"\n#include <sys/param.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nlxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"copy destination %s exists\"",
            "new"
          ],
          "line": 2636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_exists",
          "args": [
            "new"
          ],
          "line": 2635
        },
        "resolved": true,
        "details": {
          "function_name": "file_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1240-1245",
          "snippet": "bool file_exists(const char *f)\n{\n\tstruct stat statbuf;\n\n\treturn stat(f, &statbuf) == 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool file_exists(const char *f)\n{\n\tstruct stat statbuf;\n\n\treturn stat(f, &statbuf) == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic int copy_file(const char *old, const char *new)\n{\n\tint in, out;\n\tssize_t len, ret;\n\tchar buf[8096];\n\tstruct stat sbuf;\n\n\tif (file_exists(new)) {\n\t\tERROR(\"copy destination %s exists\", new);\n\t\treturn -1;\n\t}\n\tret = stat(old, &sbuf);\n\tif (ret < 0) {\n\t\tINFO(\"Error stat'ing %s\", old);\n\t\treturn -1;\n\t}\n\n\tin = open(old, O_RDONLY);\n\tif (in < 0) {\n\t\tSYSERROR(\"Error opening original file %s\", old);\n\t\treturn -1;\n\t}\n\tout = open(new, O_CREAT | O_EXCL | O_WRONLY, 0644);\n\tif (out < 0) {\n\t\tSYSERROR(\"Error opening new file %s\", new);\n\t\tclose(in);\n\t\treturn -1;\n\t}\n\n\twhile (1) {\n\t\tlen = read(in, buf, 8096);\n\t\tif (len < 0) {\n\t\t\tSYSERROR(\"Error reading old file %s\", old);\n\t\t\tgoto err;\n\t\t}\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tret = write(out, buf, len);\n\t\tif (ret < len) { // should we retry?\n\t\t\tSYSERROR(\"Error: write to new file %s was interrupted\", new);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tclose(in);\n\tclose(out);\n\n\t// we set mode, but not owner/group\n\tret = chmod(new, sbuf.st_mode);\n\tif (ret) {\n\t\tSYSERROR(\"Error setting mode on %s\", new);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n\nerr:\n\tclose(in);\n\tclose(out);\n\treturn -1;\n}"
  },
  {
    "function_name": "lxc_get_version",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "2623-2626",
    "snippet": "const char *lxc_get_version(void)\n{\n\treturn LXC_VERSION;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nconst char *lxc_get_version(void)\n{\n\treturn LXC_VERSION;\n}"
  },
  {
    "function_name": "lxc_get_global_config_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "2618-2621",
    "snippet": "const char *lxc_get_global_config_item(const char *key)\n{\n\treturn lxc_global_config_value(key);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_global_config_value",
          "args": [
            "key"
          ],
          "line": 2620
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_global_config_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "88-247",
          "snippet": "const char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nconst char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nconst char *lxc_get_global_config_item(const char *key)\n{\n\treturn lxc_global_config_value(key);\n}"
  },
  {
    "function_name": "do_lxcapi_set_config_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "2536-2572",
    "snippet": "static bool do_lxcapi_set_config_path(struct lxc_container *c, const char *path)\n{\n\tchar *p;\n\tbool b = false;\n\tchar *oldpath = NULL;\n\n\tif (!c)\n\t\treturn b;\n\n\tif (container_mem_lock(c))\n\t\treturn b;\n\n\tp = strdup(path);\n\tif (!p) {\n\t\tERROR(\"Out of memory setting new lxc path\");\n\t\tgoto err;\n\t}\n\n\tb = true;\n\tif (c->config_path)\n\t\toldpath = c->config_path;\n\tc->config_path = p;\n\n\t/* Since we've changed the config path, we have to change the\n\t * config file name too */\n\tif (!set_config_filename(c)) {\n\t\tERROR(\"Out of memory setting new config filename\");\n\t\tb = false;\n\t\tfree(c->config_path);\n\t\tc->config_path = oldpath;\n\t\toldpath = NULL;\n\t}\nerr:\n\tfree(oldpath);\n\tcontainer_mem_unlock(c);\n\treturn b;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_mem_unlock",
          "args": [
            "c"
          ],
          "line": 2570
        },
        "resolved": true,
        "details": {
          "function_name": "container_mem_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "347-350",
          "snippet": "void container_mem_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->privlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nvoid container_mem_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->privlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "oldpath"
          ],
          "line": 2569
        },
        "resolved": true,
        "details": {
          "function_name": "free_init_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "706-715",
          "snippet": "static void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Out of memory setting new config filename\""
          ],
          "line": 2562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_config_filename",
          "args": [
            "c"
          ],
          "line": 2561
        },
        "resolved": true,
        "details": {
          "function_name": "set_config_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2509-2534",
          "snippet": "static bool set_config_filename(struct lxc_container *c)\n{\n\tchar *newpath;\n\tint len, ret;\n\n\tif (!c->config_path)\n\t\treturn false;\n\n\t/* $lxc_path + \"/\" + c->name + \"/\" + \"config\" + '\\0' */\n\tlen = strlen(c->config_path) + strlen(c->name) + strlen(\"config\") + 3;\n\tnewpath = malloc(len);\n\tif (!newpath)\n\t\treturn false;\n\n\tret = snprintf(newpath, len, \"%s/%s/config\", c->config_path, c->name);\n\tif (ret < 0 || ret >= len) {\n\t\tfprintf(stderr, \"Error printing out config file name\\n\");\n\t\tfree(newpath);\n\t\treturn false;\n\t}\n\n\tfree(c->configfile);\n\tc->configfile = newpath;\n\n\treturn true;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool set_config_filename(struct lxc_container *c)\n{\n\tchar *newpath;\n\tint len, ret;\n\n\tif (!c->config_path)\n\t\treturn false;\n\n\t/* $lxc_path + \"/\" + c->name + \"/\" + \"config\" + '\\0' */\n\tlen = strlen(c->config_path) + strlen(c->name) + strlen(\"config\") + 3;\n\tnewpath = malloc(len);\n\tif (!newpath)\n\t\treturn false;\n\n\tret = snprintf(newpath, len, \"%s/%s/config\", c->config_path, c->name);\n\tif (ret < 0 || ret >= len) {\n\t\tfprintf(stderr, \"Error printing out config file name\\n\");\n\t\tfree(newpath);\n\t\treturn false;\n\t}\n\n\tfree(c->configfile);\n\tc->configfile = newpath;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Out of memory setting new lxc path\""
          ],
          "line": 2550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "path"
          ],
          "line": 2548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_mem_lock",
          "args": [
            "c"
          ],
          "line": 2545
        },
        "resolved": true,
        "details": {
          "function_name": "container_mem_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "342-345",
          "snippet": "int container_mem_lock(struct lxc_container *c)\n{\n\treturn lxclock(c->privlock, 0);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nint container_mem_lock(struct lxc_container *c)\n{\n\treturn lxclock(c->privlock, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_set_config_path(struct lxc_container *c, const char *path)\n{\n\tchar *p;\n\tbool b = false;\n\tchar *oldpath = NULL;\n\n\tif (!c)\n\t\treturn b;\n\n\tif (container_mem_lock(c))\n\t\treturn b;\n\n\tp = strdup(path);\n\tif (!p) {\n\t\tERROR(\"Out of memory setting new lxc path\");\n\t\tgoto err;\n\t}\n\n\tb = true;\n\tif (c->config_path)\n\t\toldpath = c->config_path;\n\tc->config_path = p;\n\n\t/* Since we've changed the config path, we have to change the\n\t * config file name too */\n\tif (!set_config_filename(c)) {\n\t\tERROR(\"Out of memory setting new config filename\");\n\t\tb = false;\n\t\tfree(c->config_path);\n\t\tc->config_path = oldpath;\n\t\toldpath = NULL;\n\t}\nerr:\n\tfree(oldpath);\n\tcontainer_mem_unlock(c);\n\treturn b;\n}"
  },
  {
    "function_name": "set_config_filename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "2509-2534",
    "snippet": "static bool set_config_filename(struct lxc_container *c)\n{\n\tchar *newpath;\n\tint len, ret;\n\n\tif (!c->config_path)\n\t\treturn false;\n\n\t/* $lxc_path + \"/\" + c->name + \"/\" + \"config\" + '\\0' */\n\tlen = strlen(c->config_path) + strlen(c->name) + strlen(\"config\") + 3;\n\tnewpath = malloc(len);\n\tif (!newpath)\n\t\treturn false;\n\n\tret = snprintf(newpath, len, \"%s/%s/config\", c->config_path, c->name);\n\tif (ret < 0 || ret >= len) {\n\t\tfprintf(stderr, \"Error printing out config file name\\n\");\n\t\tfree(newpath);\n\t\treturn false;\n\t}\n\n\tfree(c->configfile);\n\tc->configfile = newpath;\n\n\treturn true;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "c->configfile"
          ],
          "line": 2530
        },
        "resolved": true,
        "details": {
          "function_name": "free_init_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "706-715",
          "snippet": "static void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error printing out config file name\\n\""
          ],
          "line": 2525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "newpath",
            "len",
            "\"%s/%s/config\"",
            "c->config_path",
            "c->name"
          ],
          "line": 2523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 2519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"config\""
          ],
          "line": 2518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "c->name"
          ],
          "line": 2518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "c->config_path"
          ],
          "line": 2518
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool set_config_filename(struct lxc_container *c)\n{\n\tchar *newpath;\n\tint len, ret;\n\n\tif (!c->config_path)\n\t\treturn false;\n\n\t/* $lxc_path + \"/\" + c->name + \"/\" + \"config\" + '\\0' */\n\tlen = strlen(c->config_path) + strlen(c->name) + strlen(\"config\") + 3;\n\tnewpath = malloc(len);\n\tif (!newpath)\n\t\treturn false;\n\n\tret = snprintf(newpath, len, \"%s/%s/config\", c->config_path, c->name);\n\tif (ret < 0 || ret >= len) {\n\t\tfprintf(stderr, \"Error printing out config file name\\n\");\n\t\tfree(newpath);\n\t\treturn false;\n\t}\n\n\tfree(c->configfile);\n\tc->configfile = newpath;\n\n\treturn true;\n}"
  },
  {
    "function_name": "do_lxcapi_set_config_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "2471-2485",
    "snippet": "static bool do_lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v)\n{\n\tbool b = false;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (container_mem_lock(c))\n\t\treturn false;\n\n\tb = set_config_item_locked(c, key, v);\n\n\tcontainer_mem_unlock(c);\n\treturn b;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool do_lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_mem_unlock",
          "args": [
            "c"
          ],
          "line": 2483
        },
        "resolved": true,
        "details": {
          "function_name": "container_mem_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "347-350",
          "snippet": "void container_mem_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->privlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nvoid container_mem_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->privlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_config_item_locked",
          "args": [
            "c",
            "key",
            "v"
          ],
          "line": 2481
        },
        "resolved": true,
        "details": {
          "function_name": "set_config_item_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2455-2469",
          "snippet": "static bool set_config_item_locked(struct lxc_container *c, const char *key, const char *v)\n{\n\tstruct lxc_config_t *config;\n\n\tif (!c->lxc_conf)\n\t\tc->lxc_conf = lxc_conf_init();\n\tif (!c->lxc_conf)\n\t\treturn false;\n\tconfig = lxc_getconfig(key);\n\tif (!config)\n\t\treturn false;\n\tif (config->cb(key, v, c->lxc_conf) != 0)\n\t\treturn false;\n\treturn do_append_unexp_config_line(c->lxc_conf, key, v);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool do_lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool do_lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool set_config_item_locked(struct lxc_container *c, const char *key, const char *v)\n{\n\tstruct lxc_config_t *config;\n\n\tif (!c->lxc_conf)\n\t\tc->lxc_conf = lxc_conf_init();\n\tif (!c->lxc_conf)\n\t\treturn false;\n\tconfig = lxc_getconfig(key);\n\tif (!config)\n\t\treturn false;\n\tif (config->cb(key, v, c->lxc_conf) != 0)\n\t\treturn false;\n\treturn do_append_unexp_config_line(c->lxc_conf, key, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_mem_lock",
          "args": [
            "c"
          ],
          "line": 2478
        },
        "resolved": true,
        "details": {
          "function_name": "container_mem_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "342-345",
          "snippet": "int container_mem_lock(struct lxc_container *c)\n{\n\treturn lxclock(c->privlock, 0);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nint container_mem_lock(struct lxc_container *c)\n{\n\treturn lxclock(c->privlock, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool do_lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v)\n{\n\tbool b = false;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (container_mem_lock(c))\n\t\treturn false;\n\n\tb = set_config_item_locked(c, key, v);\n\n\tcontainer_mem_unlock(c);\n\treturn b;\n}"
  },
  {
    "function_name": "set_config_item_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "2455-2469",
    "snippet": "static bool set_config_item_locked(struct lxc_container *c, const char *key, const char *v)\n{\n\tstruct lxc_config_t *config;\n\n\tif (!c->lxc_conf)\n\t\tc->lxc_conf = lxc_conf_init();\n\tif (!c->lxc_conf)\n\t\treturn false;\n\tconfig = lxc_getconfig(key);\n\tif (!config)\n\t\treturn false;\n\tif (config->cb(key, v, c->lxc_conf) != 0)\n\t\treturn false;\n\treturn do_append_unexp_config_line(c->lxc_conf, key, v);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool do_lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_append_unexp_config_line",
          "args": [
            "c->lxc_conf",
            "key",
            "v"
          ],
          "line": 2468
        },
        "resolved": true,
        "details": {
          "function_name": "do_append_unexp_config_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/confile.c",
          "lines": "2732-2747",
          "snippet": "bool do_append_unexp_config_line(struct lxc_conf *conf, const char *key, const char *v)\n{\n\tint ret;\n\tsize_t len = strlen(key) + strlen(v) + 4;\n\tchar *tmp = alloca(len);\n\n\tret = snprintf(tmp, len, \"%s = %s\", key, v);\n\tif (ret < 0 || ret >= len)\n\t\treturn false;\n\n\t/* Save the line verbatim into unexpanded_conf */\n\tif (append_unexp_config_line(tmp, conf))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"network.h\"",
            "#include \"conf.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"confile.h\"",
            "#include \"config.h\"",
            "#include \"parse.h\"",
            "#include \"bdev.h\"",
            "#include <syslog.h>",
            "#include <dirent.h>",
            "#include <time.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int config_personality(const char *, const char *, struct lxc_conf *);",
            "static int config_pts(const char *, const char *, struct lxc_conf *);",
            "static int config_tty(const char *, const char *, struct lxc_conf *);",
            "static int config_ttydir(const char *, const char *, struct lxc_conf *);",
            "static int config_kmsg(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_aa_profile(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_aa_incomplete(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_se_context(const char *, const char *, struct lxc_conf *);",
            "static int config_cgroup(const char *, const char *, struct lxc_conf *);",
            "static int config_idmap(const char *, const char *, struct lxc_conf *);",
            "static int config_loglevel(const char *, const char *, struct lxc_conf *);",
            "static int config_logfile(const char *, const char *, struct lxc_conf *);",
            "static int config_mount(const char *, const char *, struct lxc_conf *);",
            "static int config_mount_auto(const char *, const char *, struct lxc_conf *);",
            "static int config_fstab(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_mount(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_options(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_backend(const char *, const char *, struct lxc_conf *);",
            "static int config_pivotdir(const char *, const char *, struct lxc_conf *);",
            "static int config_utsname(const char *, const char *, struct lxc_conf *);",
            "static int config_hook(const char *, const char *, struct lxc_conf *lxc_conf);",
            "static int config_network(const char *, const char *, struct lxc_conf *);",
            "static int config_network_type(const char *, const char *, struct lxc_conf *);",
            "static int config_network_flags(const char *, const char *, struct lxc_conf *);",
            "static int config_network_link(const char *, const char *, struct lxc_conf *);",
            "static int config_network_name(const char *, const char *, struct lxc_conf *);",
            "static int config_network_veth_pair(const char *, const char *, struct lxc_conf *);",
            "static int config_network_macvlan_mode(const char *, const char *, struct lxc_conf *);",
            "static int config_network_hwaddr(const char *, const char *, struct lxc_conf *);",
            "static int config_network_vlan_id(const char *, const char *, struct lxc_conf *);",
            "static int config_network_mtu(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv4(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv4_gateway(const char *, const char *, struct lxc_conf *);",
            "static int config_network_script_up(const char *, const char *, struct lxc_conf *);",
            "static int config_network_script_down(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv6(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv6_gateway(const char *, const char *, struct lxc_conf *);",
            "static int config_cap_drop(const char *, const char *, struct lxc_conf *);",
            "static int config_cap_keep(const char *, const char *, struct lxc_conf *);",
            "static int config_console(const char *, const char *, struct lxc_conf *);",
            "static int config_console_logfile(const char *, const char *, struct lxc_conf *);",
            "static int config_seccomp(const char *, const char *, struct lxc_conf *);",
            "static int config_includefile(const char *, const char *, struct lxc_conf *);",
            "static int config_network_nic(const char *, const char *, struct lxc_conf *);",
            "static int config_autodev(const char *, const char *, struct lxc_conf *);",
            "static int config_haltsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_rebootsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_stopsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_start(const char *, const char *, struct lxc_conf *);",
            "static int config_syslog(const char *, const char *, struct lxc_conf *);",
            "static int config_monitor(const char *, const char *, struct lxc_conf *);",
            "static int config_group(const char *, const char *, struct lxc_conf *);",
            "static int config_environment(const char *, const char *, struct lxc_conf *);",
            "static int config_init_cmd(const char *, const char *, struct lxc_conf *);",
            "static int config_init_uid(const char *, const char *, struct lxc_conf *);",
            "static int config_init_gid(const char *, const char *, struct lxc_conf *);",
            "static int config_ephemeral(const char *, const char *, struct lxc_conf *);",
            "static int config_no_new_privs(const char *, const char *, struct lxc_conf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"lxcseccomp.h\"\n#include \"network.h\"\n#include \"conf.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"confile.h\"\n#include \"config.h\"\n#include \"parse.h\"\n#include \"bdev.h\"\n#include <syslog.h>\n#include <dirent.h>\n#include <time.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int config_personality(const char *, const char *, struct lxc_conf *);\nstatic int config_pts(const char *, const char *, struct lxc_conf *);\nstatic int config_tty(const char *, const char *, struct lxc_conf *);\nstatic int config_ttydir(const char *, const char *, struct lxc_conf *);\nstatic int config_kmsg(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_aa_profile(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_aa_incomplete(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_se_context(const char *, const char *, struct lxc_conf *);\nstatic int config_cgroup(const char *, const char *, struct lxc_conf *);\nstatic int config_idmap(const char *, const char *, struct lxc_conf *);\nstatic int config_loglevel(const char *, const char *, struct lxc_conf *);\nstatic int config_logfile(const char *, const char *, struct lxc_conf *);\nstatic int config_mount(const char *, const char *, struct lxc_conf *);\nstatic int config_mount_auto(const char *, const char *, struct lxc_conf *);\nstatic int config_fstab(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_mount(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_options(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_backend(const char *, const char *, struct lxc_conf *);\nstatic int config_pivotdir(const char *, const char *, struct lxc_conf *);\nstatic int config_utsname(const char *, const char *, struct lxc_conf *);\nstatic int config_hook(const char *, const char *, struct lxc_conf *lxc_conf);\nstatic int config_network(const char *, const char *, struct lxc_conf *);\nstatic int config_network_type(const char *, const char *, struct lxc_conf *);\nstatic int config_network_flags(const char *, const char *, struct lxc_conf *);\nstatic int config_network_link(const char *, const char *, struct lxc_conf *);\nstatic int config_network_name(const char *, const char *, struct lxc_conf *);\nstatic int config_network_veth_pair(const char *, const char *, struct lxc_conf *);\nstatic int config_network_macvlan_mode(const char *, const char *, struct lxc_conf *);\nstatic int config_network_hwaddr(const char *, const char *, struct lxc_conf *);\nstatic int config_network_vlan_id(const char *, const char *, struct lxc_conf *);\nstatic int config_network_mtu(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv4(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv4_gateway(const char *, const char *, struct lxc_conf *);\nstatic int config_network_script_up(const char *, const char *, struct lxc_conf *);\nstatic int config_network_script_down(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv6(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv6_gateway(const char *, const char *, struct lxc_conf *);\nstatic int config_cap_drop(const char *, const char *, struct lxc_conf *);\nstatic int config_cap_keep(const char *, const char *, struct lxc_conf *);\nstatic int config_console(const char *, const char *, struct lxc_conf *);\nstatic int config_console_logfile(const char *, const char *, struct lxc_conf *);\nstatic int config_seccomp(const char *, const char *, struct lxc_conf *);\nstatic int config_includefile(const char *, const char *, struct lxc_conf *);\nstatic int config_network_nic(const char *, const char *, struct lxc_conf *);\nstatic int config_autodev(const char *, const char *, struct lxc_conf *);\nstatic int config_haltsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_rebootsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_stopsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_start(const char *, const char *, struct lxc_conf *);\nstatic int config_syslog(const char *, const char *, struct lxc_conf *);\nstatic int config_monitor(const char *, const char *, struct lxc_conf *);\nstatic int config_group(const char *, const char *, struct lxc_conf *);\nstatic int config_environment(const char *, const char *, struct lxc_conf *);\nstatic int config_init_cmd(const char *, const char *, struct lxc_conf *);\nstatic int config_init_uid(const char *, const char *, struct lxc_conf *);\nstatic int config_init_gid(const char *, const char *, struct lxc_conf *);\nstatic int config_ephemeral(const char *, const char *, struct lxc_conf *);\nstatic int config_no_new_privs(const char *, const char *, struct lxc_conf *);\n\nbool do_append_unexp_config_line(struct lxc_conf *conf, const char *key, const char *v)\n{\n\tint ret;\n\tsize_t len = strlen(key) + strlen(v) + 4;\n\tchar *tmp = alloca(len);\n\n\tret = snprintf(tmp, len, \"%s = %s\", key, v);\n\tif (ret < 0 || ret >= len)\n\t\treturn false;\n\n\t/* Save the line verbatim into unexpanded_conf */\n\tif (append_unexp_config_line(tmp, conf))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "config->cb",
          "args": [
            "key",
            "v",
            "c->lxc_conf"
          ],
          "line": 2466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_getconfig",
          "args": [
            "key"
          ],
          "line": 2463
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_getconfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/confile.c",
          "lines": "286-295",
          "snippet": "extern struct lxc_config_t *lxc_getconfig(const char *key)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < config_size; i++)\n\t\tif (!strncmp(config[i].name, key,\n\t\t\t     strlen(config[i].name)))\n\t\t\treturn &config[i];\n\treturn NULL;\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"network.h\"",
            "#include \"conf.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"confile.h\"",
            "#include \"config.h\"",
            "#include \"parse.h\"",
            "#include \"bdev.h\"",
            "#include <syslog.h>",
            "#include <dirent.h>",
            "#include <time.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lxc_config_t config[] = {\n\n\t{ \"lxc.arch\",                 config_personality          },\n\t{ \"lxc.pts\",                  config_pts                  },\n\t{ \"lxc.tty\",                  config_tty                  },\n\t{ \"lxc.devttydir\",            config_ttydir               },\n\t{ \"lxc.kmsg\",                 config_kmsg                 },\n\t{ \"lxc.aa_profile\",           config_lsm_aa_profile       },\n\t{ \"lxc.aa_allow_incomplete\",  config_lsm_aa_incomplete    },\n\t{ \"lxc.se_context\",           config_lsm_se_context       },\n\t{ \"lxc.cgroup\",               config_cgroup               },\n\t{ \"lxc.id_map\",               config_idmap                },\n\t{ \"lxc.loglevel\",             config_loglevel             },\n\t{ \"lxc.logfile\",              config_logfile              },\n\t{ \"lxc.mount.entry\",          config_mount                },\n\t{ \"lxc.mount.auto\",           config_mount_auto           },\n\t{ \"lxc.mount\",                config_fstab                },\n\t{ \"lxc.rootfs.mount\",         config_rootfs_mount         },\n\t{ \"lxc.rootfs.options\",       config_rootfs_options       },\n\t{ \"lxc.rootfs.backend\",       config_rootfs_backend       },\n\t{ \"lxc.rootfs\",               config_rootfs               },\n\t{ \"lxc.pivotdir\",             config_pivotdir             },\n\t{ \"lxc.utsname\",              config_utsname              },\n\t{ \"lxc.hook.pre-start\",       config_hook                 },\n\t{ \"lxc.hook.pre-mount\",       config_hook                 },\n\t{ \"lxc.hook.mount\",           config_hook                 },\n\t{ \"lxc.hook.autodev\",         config_hook                 },\n\t{ \"lxc.hook.start\",           config_hook                 },\n\t{ \"lxc.hook.stop\",            config_hook                 },\n\t{ \"lxc.hook.post-stop\",       config_hook                 },\n\t{ \"lxc.hook.clone\",           config_hook                 },\n\t{ \"lxc.hook.destroy\",         config_hook                 },\n\t{ \"lxc.hook\",                 config_hook                 },\n\t{ \"lxc.network.type\",         config_network_type         },\n\t{ \"lxc.network.flags\",        config_network_flags        },\n\t{ \"lxc.network.link\",         config_network_link         },\n\t{ \"lxc.network.name\",         config_network_name         },\n\t{ \"lxc.network.macvlan.mode\", config_network_macvlan_mode },\n\t{ \"lxc.network.veth.pair\",    config_network_veth_pair    },\n\t{ \"lxc.network.script.up\",    config_network_script_up    },\n\t{ \"lxc.network.script.down\",  config_network_script_down  },\n\t{ \"lxc.network.hwaddr\",       config_network_hwaddr       },\n\t{ \"lxc.network.mtu\",          config_network_mtu          },\n\t{ \"lxc.network.vlan.id\",      config_network_vlan_id      },\n\t{ \"lxc.network.ipv4.gateway\", config_network_ipv4_gateway },\n\t{ \"lxc.network.ipv4\",         config_network_ipv4         },\n\t{ \"lxc.network.ipv6.gateway\", config_network_ipv6_gateway },\n\t{ \"lxc.network.ipv6\",         config_network_ipv6         },\n\t/* config_network_nic must come after all other 'lxc.network.*' entries */\n\t{ \"lxc.network.\",             config_network_nic          },\n\t{ \"lxc.network\",              config_network              },\n\t{ \"lxc.cap.drop\",             config_cap_drop             },\n\t{ \"lxc.cap.keep\",             config_cap_keep             },\n\t{ \"lxc.console.logfile\",      config_console_logfile      },\n\t{ \"lxc.console\",              config_console              },\n\t{ \"lxc.seccomp\",              config_seccomp              },\n\t{ \"lxc.include\",              config_includefile          },\n\t{ \"lxc.autodev\",              config_autodev              },\n\t{ \"lxc.haltsignal\",           config_haltsignal           },\n\t{ \"lxc.rebootsignal\",         config_rebootsignal         },\n\t{ \"lxc.stopsignal\",           config_stopsignal           },\n\t{ \"lxc.start.auto\",           config_start                },\n\t{ \"lxc.start.delay\",          config_start                },\n\t{ \"lxc.start.order\",          config_start                },\n\t{ \"lxc.monitor.unshare\",      config_monitor              },\n\t{ \"lxc.group\",                config_group                },\n\t{ \"lxc.environment\",          config_environment          },\n\t{ \"lxc.init_cmd\",             config_init_cmd             },\n\t{ \"lxc.init_uid\",             config_init_uid             },\n\t{ \"lxc.init_gid\",             config_init_gid             },\n\t{ \"lxc.ephemeral\",            config_ephemeral            },\n\t{ \"lxc.syslog\",               config_syslog               },\n\t{ \"lxc.no_new_privs\",\t      config_no_new_privs\t  },\n};",
            "static const size_t config_size = sizeof(config)/sizeof(struct lxc_config_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"lxcseccomp.h\"\n#include \"network.h\"\n#include \"conf.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"confile.h\"\n#include \"config.h\"\n#include \"parse.h\"\n#include \"bdev.h\"\n#include <syslog.h>\n#include <dirent.h>\n#include <time.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic struct lxc_config_t config[] = {\n\n\t{ \"lxc.arch\",                 config_personality          },\n\t{ \"lxc.pts\",                  config_pts                  },\n\t{ \"lxc.tty\",                  config_tty                  },\n\t{ \"lxc.devttydir\",            config_ttydir               },\n\t{ \"lxc.kmsg\",                 config_kmsg                 },\n\t{ \"lxc.aa_profile\",           config_lsm_aa_profile       },\n\t{ \"lxc.aa_allow_incomplete\",  config_lsm_aa_incomplete    },\n\t{ \"lxc.se_context\",           config_lsm_se_context       },\n\t{ \"lxc.cgroup\",               config_cgroup               },\n\t{ \"lxc.id_map\",               config_idmap                },\n\t{ \"lxc.loglevel\",             config_loglevel             },\n\t{ \"lxc.logfile\",              config_logfile              },\n\t{ \"lxc.mount.entry\",          config_mount                },\n\t{ \"lxc.mount.auto\",           config_mount_auto           },\n\t{ \"lxc.mount\",                config_fstab                },\n\t{ \"lxc.rootfs.mount\",         config_rootfs_mount         },\n\t{ \"lxc.rootfs.options\",       config_rootfs_options       },\n\t{ \"lxc.rootfs.backend\",       config_rootfs_backend       },\n\t{ \"lxc.rootfs\",               config_rootfs               },\n\t{ \"lxc.pivotdir\",             config_pivotdir             },\n\t{ \"lxc.utsname\",              config_utsname              },\n\t{ \"lxc.hook.pre-start\",       config_hook                 },\n\t{ \"lxc.hook.pre-mount\",       config_hook                 },\n\t{ \"lxc.hook.mount\",           config_hook                 },\n\t{ \"lxc.hook.autodev\",         config_hook                 },\n\t{ \"lxc.hook.start\",           config_hook                 },\n\t{ \"lxc.hook.stop\",            config_hook                 },\n\t{ \"lxc.hook.post-stop\",       config_hook                 },\n\t{ \"lxc.hook.clone\",           config_hook                 },\n\t{ \"lxc.hook.destroy\",         config_hook                 },\n\t{ \"lxc.hook\",                 config_hook                 },\n\t{ \"lxc.network.type\",         config_network_type         },\n\t{ \"lxc.network.flags\",        config_network_flags        },\n\t{ \"lxc.network.link\",         config_network_link         },\n\t{ \"lxc.network.name\",         config_network_name         },\n\t{ \"lxc.network.macvlan.mode\", config_network_macvlan_mode },\n\t{ \"lxc.network.veth.pair\",    config_network_veth_pair    },\n\t{ \"lxc.network.script.up\",    config_network_script_up    },\n\t{ \"lxc.network.script.down\",  config_network_script_down  },\n\t{ \"lxc.network.hwaddr\",       config_network_hwaddr       },\n\t{ \"lxc.network.mtu\",          config_network_mtu          },\n\t{ \"lxc.network.vlan.id\",      config_network_vlan_id      },\n\t{ \"lxc.network.ipv4.gateway\", config_network_ipv4_gateway },\n\t{ \"lxc.network.ipv4\",         config_network_ipv4         },\n\t{ \"lxc.network.ipv6.gateway\", config_network_ipv6_gateway },\n\t{ \"lxc.network.ipv6\",         config_network_ipv6         },\n\t/* config_network_nic must come after all other 'lxc.network.*' entries */\n\t{ \"lxc.network.\",             config_network_nic          },\n\t{ \"lxc.network\",              config_network              },\n\t{ \"lxc.cap.drop\",             config_cap_drop             },\n\t{ \"lxc.cap.keep\",             config_cap_keep             },\n\t{ \"lxc.console.logfile\",      config_console_logfile      },\n\t{ \"lxc.console\",              config_console              },\n\t{ \"lxc.seccomp\",              config_seccomp              },\n\t{ \"lxc.include\",              config_includefile          },\n\t{ \"lxc.autodev\",              config_autodev              },\n\t{ \"lxc.haltsignal\",           config_haltsignal           },\n\t{ \"lxc.rebootsignal\",         config_rebootsignal         },\n\t{ \"lxc.stopsignal\",           config_stopsignal           },\n\t{ \"lxc.start.auto\",           config_start                },\n\t{ \"lxc.start.delay\",          config_start                },\n\t{ \"lxc.start.order\",          config_start                },\n\t{ \"lxc.monitor.unshare\",      config_monitor              },\n\t{ \"lxc.group\",                config_group                },\n\t{ \"lxc.environment\",          config_environment          },\n\t{ \"lxc.init_cmd\",             config_init_cmd             },\n\t{ \"lxc.init_uid\",             config_init_uid             },\n\t{ \"lxc.init_gid\",             config_init_gid             },\n\t{ \"lxc.ephemeral\",            config_ephemeral            },\n\t{ \"lxc.syslog\",               config_syslog               },\n\t{ \"lxc.no_new_privs\",\t      config_no_new_privs\t  },\n};\nstatic const size_t config_size = sizeof(config)/sizeof(struct lxc_config_t);\n\nextern struct lxc_config_t *lxc_getconfig(const char *key)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < config_size; i++)\n\t\tif (!strncmp(config[i].name, key,\n\t\t\t     strlen(config[i].name)))\n\t\t\treturn &config[i];\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_conf_init",
          "args": [],
          "line": 2460
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_conf_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "2520-2580",
          "snippet": "struct lxc_conf *lxc_conf_init(void)\n{\n\tstruct lxc_conf *new;\n\tint i;\n\n\tnew = \tmalloc(sizeof(*new));\n\tif (!new) {\n\t\tERROR(\"lxc_conf_init : %m\");\n\t\treturn NULL;\n\t}\n\tmemset(new, 0, sizeof(*new));\n\n\tnew->loglevel = LXC_LOG_PRIORITY_NOTSET;\n\tnew->personality = -1;\n\tnew->autodev = 1;\n\tnew->console.log_path = NULL;\n\tnew->console.log_fd = -1;\n\tnew->console.path = NULL;\n\tnew->console.peer = -1;\n\tnew->console.peerpty.busy = -1;\n\tnew->console.peerpty.master = -1;\n\tnew->console.peerpty.slave = -1;\n\tnew->console.master = -1;\n\tnew->console.slave = -1;\n\tnew->console.name[0] = '\\0';\n\tnew->maincmd_fd = -1;\n\tnew->nbd_idx = -1;\n\tnew->rootfs.mount = strdup(default_rootfs_mount);\n\tif (!new->rootfs.mount) {\n\t\tERROR(\"lxc_conf_init : %m\");\n\t\tfree(new);\n\t\treturn NULL;\n\t}\n\tnew->kmsg = 0;\n\tnew->logfd = -1;\n\tlxc_list_init(&new->cgroup);\n\tlxc_list_init(&new->network);\n\tlxc_list_init(&new->mount_list);\n\tlxc_list_init(&new->caps);\n\tlxc_list_init(&new->keepcaps);\n\tlxc_list_init(&new->id_map);\n\tlxc_list_init(&new->includes);\n\tlxc_list_init(&new->aliens);\n\tlxc_list_init(&new->environment);\n\tfor (i=0; i<NUM_LXC_HOOKS; i++)\n\t\tlxc_list_init(&new->hooks[i]);\n\tlxc_list_init(&new->groups);\n\tnew->lsm_aa_profile = NULL;\n\tnew->lsm_se_context = NULL;\n\tnew->tmp_umount_proc = 0;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++)\n\t\tnew->inherit_ns_fd[i] = -1;\n\n\t/* if running in a new user namespace, init and COMMAND\n\t * default to running as UID/GID 0 when using lxc-execute */\n\tnew->init_uid = 0;\n\tnew->init_gid = 0;\n\n\treturn new;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int in_caplist(int cap, struct lxc_list *caps);",
            "static char *default_rootfs_mount = LXCROOTFSMOUNT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int in_caplist(int cap, struct lxc_list *caps);\nstatic char *default_rootfs_mount = LXCROOTFSMOUNT;\n\nstruct lxc_conf *lxc_conf_init(void)\n{\n\tstruct lxc_conf *new;\n\tint i;\n\n\tnew = \tmalloc(sizeof(*new));\n\tif (!new) {\n\t\tERROR(\"lxc_conf_init : %m\");\n\t\treturn NULL;\n\t}\n\tmemset(new, 0, sizeof(*new));\n\n\tnew->loglevel = LXC_LOG_PRIORITY_NOTSET;\n\tnew->personality = -1;\n\tnew->autodev = 1;\n\tnew->console.log_path = NULL;\n\tnew->console.log_fd = -1;\n\tnew->console.path = NULL;\n\tnew->console.peer = -1;\n\tnew->console.peerpty.busy = -1;\n\tnew->console.peerpty.master = -1;\n\tnew->console.peerpty.slave = -1;\n\tnew->console.master = -1;\n\tnew->console.slave = -1;\n\tnew->console.name[0] = '\\0';\n\tnew->maincmd_fd = -1;\n\tnew->nbd_idx = -1;\n\tnew->rootfs.mount = strdup(default_rootfs_mount);\n\tif (!new->rootfs.mount) {\n\t\tERROR(\"lxc_conf_init : %m\");\n\t\tfree(new);\n\t\treturn NULL;\n\t}\n\tnew->kmsg = 0;\n\tnew->logfd = -1;\n\tlxc_list_init(&new->cgroup);\n\tlxc_list_init(&new->network);\n\tlxc_list_init(&new->mount_list);\n\tlxc_list_init(&new->caps);\n\tlxc_list_init(&new->keepcaps);\n\tlxc_list_init(&new->id_map);\n\tlxc_list_init(&new->includes);\n\tlxc_list_init(&new->aliens);\n\tlxc_list_init(&new->environment);\n\tfor (i=0; i<NUM_LXC_HOOKS; i++)\n\t\tlxc_list_init(&new->hooks[i]);\n\tlxc_list_init(&new->groups);\n\tnew->lsm_aa_profile = NULL;\n\tnew->lsm_se_context = NULL;\n\tnew->tmp_umount_proc = 0;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++)\n\t\tnew->inherit_ns_fd[i] = -1;\n\n\t/* if running in a new user namespace, init and COMMAND\n\t * default to running as UID/GID 0 when using lxc-execute */\n\tnew->init_uid = 0;\n\tnew->init_gid = 0;\n\n\treturn new;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool do_lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool set_config_item_locked(struct lxc_container *c, const char *key, const char *v)\n{\n\tstruct lxc_config_t *config;\n\n\tif (!c->lxc_conf)\n\t\tc->lxc_conf = lxc_conf_init();\n\tif (!c->lxc_conf)\n\t\treturn false;\n\tconfig = lxc_getconfig(key);\n\tif (!config)\n\t\treturn false;\n\tif (config->cb(key, v, c->lxc_conf) != 0)\n\t\treturn false;\n\treturn do_append_unexp_config_line(c->lxc_conf, key, v);\n}"
  },
  {
    "function_name": "do_lxcapi_destroy_with_snapshots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "2442-2451",
    "snippet": "static bool do_lxcapi_destroy_with_snapshots(struct lxc_container *c)\n{\n\tif (!c || !lxcapi_is_defined(c))\n\t\treturn false;\n\tif (!lxcapi_snapshot_destroy_all(c)) {\n\t\tERROR(\"Error deleting all snapshots\");\n\t\treturn false;\n\t}\n\treturn lxcapi_destroy(c);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxcapi_destroy",
          "args": [
            "c"
          ],
          "line": 2450
        },
        "resolved": true,
        "details": {
          "function_name": "do_lxcapi_destroy_with_snapshots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2442-2451",
          "snippet": "static bool do_lxcapi_destroy_with_snapshots(struct lxc_container *c)\n{\n\tif (!c || !lxcapi_is_defined(c))\n\t\treturn false;\n\tif (!lxcapi_snapshot_destroy_all(c)) {\n\t\tERROR(\"Error deleting all snapshots\");\n\t\treturn false;\n\t}\n\treturn lxcapi_destroy(c);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error deleting all snapshots\""
          ],
          "line": 2447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxcapi_snapshot_destroy_all",
          "args": [
            "c"
          ],
          "line": 2446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxcapi_is_defined",
          "args": [
            "c"
          ],
          "line": 2444
        },
        "resolved": true,
        "details": {
          "function_name": "do_lxcapi_is_defined",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "327-348",
          "snippet": "static bool do_lxcapi_is_defined(struct lxc_container *c)\n{\n\tstruct stat statbuf;\n\tbool ret = false;\n\tint statret;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (container_mem_lock(c))\n\t\treturn false;\n\tif (!c->configfile)\n\t\tgoto out;\n\tstatret = stat(c->configfile, &statbuf);\n\tif (statret != 0)\n\t\tgoto out;\n\tret = true;\n\nout:\n\tcontainer_mem_unlock(c);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_is_defined(struct lxc_container *c)\n{\n\tstruct stat statbuf;\n\tbool ret = false;\n\tint statret;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (container_mem_lock(c))\n\t\treturn false;\n\tif (!c->configfile)\n\t\tgoto out;\n\tstatret = stat(c->configfile, &statbuf);\n\tif (statret != 0)\n\t\tgoto out;\n\tret = true;\n\nout:\n\tcontainer_mem_unlock(c);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_destroy_with_snapshots(struct lxc_container *c)\n{\n\tif (!c || !lxcapi_is_defined(c))\n\t\treturn false;\n\tif (!lxcapi_snapshot_destroy_all(c)) {\n\t\tERROR(\"Error deleting all snapshots\");\n\t\treturn false;\n\t}\n\treturn lxcapi_destroy(c);\n}"
  },
  {
    "function_name": "do_lxcapi_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "2423-2438",
    "snippet": "static bool do_lxcapi_destroy(struct lxc_container *c)\n{\n\tif (!c || !lxcapi_is_defined(c))\n\t\treturn false;\n\tif (has_snapshots(c)) {\n\t\tERROR(\"Container %s has snapshots;  not removing\", c->name);\n\t\treturn false;\n\t}\n\n\tif (has_fs_snapshots(c)) {\n\t\tERROR(\"container %s has snapshots on its rootfs\", c->name);\n\t\treturn false;\n\t}\n\n\treturn container_destroy(c);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_destroy",
          "args": [
            "c"
          ],
          "line": 2437
        },
        "resolved": true,
        "details": {
          "function_name": "container_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2338-2421",
          "snippet": "static bool container_destroy(struct lxc_container *c)\n{\n\tbool bret = false;\n\tint ret = 0;\n\tstruct lxc_conf *conf;\n\n\tif (!c || !do_lxcapi_is_defined(c))\n\t\treturn false;\n\n\tconf = c->lxc_conf;\n\tif (container_disk_lock(c))\n\t\treturn false;\n\n\tif (!is_stopped(c)) {\n\t\t// we should queue some sort of error - in c->error_string?\n\t\tERROR(\"container %s is not stopped\", c->name);\n\t\tgoto out;\n\t}\n\n\tif (conf && !lxc_list_empty(&conf->hooks[LXCHOOK_DESTROY])) {\n\t\t/* Start of environment variable setup for hooks */\n\t\tif (c->name && setenv(\"LXC_NAME\", c->name, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for container name\");\n\t\t}\n\t\tif (conf->rcfile && setenv(\"LXC_CONFIG_FILE\", conf->rcfile, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for config path\");\n\t\t}\n\t\tif (conf->rootfs.mount && setenv(\"LXC_ROOTFS_MOUNT\", conf->rootfs.mount, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for rootfs mount\");\n\t\t}\n\t\tif (conf->rootfs.path && setenv(\"LXC_ROOTFS_PATH\", conf->rootfs.path, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for rootfs mount\");\n\t\t}\n\t\tif (conf->console.path && setenv(\"LXC_CONSOLE\", conf->console.path, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for console path\");\n\t\t}\n\t\tif (conf->console.log_path && setenv(\"LXC_CONSOLE_LOGPATH\", conf->console.log_path, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for console log\");\n\t\t}\n\t\t/* End of environment variable setup for hooks */\n\n\t\tif (run_lxc_hooks(c->name, \"destroy\", conf, c->get_config_path(c), NULL)) {\n\t\t\tERROR(\"Error executing clone hook for %s\", c->name);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (current_config && conf == current_config) {\n\t\tcurrent_config = NULL;\n\t\tif (conf->logfd != -1) {\n\t\t\tclose(conf->logfd);\n\t\t\tconf->logfd = -1;\n\t\t}\n\t}\n\n\tif (conf && conf->rootfs.path && conf->rootfs.mount) {\n\t\tif (!do_destroy_container(conf)) {\n\t\t\tERROR(\"Error destroying rootfs for %s\", c->name);\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Destroyed rootfs for %s\", c->name);\n\t}\n\n\tmod_all_rdeps(c, false);\n\n\tconst char *p1 = do_lxcapi_get_config_path(c);\n\tchar *path = alloca(strlen(p1) + strlen(c->name) + 2);\n\tsprintf(path, \"%s/%s\", p1, c->name);\n\tif (am_unpriv())\n\t\tret = userns_exec_1(conf, lxc_rmdir_onedev_wrapper, path);\n\telse\n\t\tret = lxc_rmdir_onedev(path, \"snaps\");\n\tif (ret < 0) {\n\t\tERROR(\"Error destroying container directory for %s\", c->name);\n\t\tgoto out;\n\t}\n\tINFO(\"Destroyed directory for %s\", c->name);\n\n\tbret = true;\n\nout:\n\tcontainer_disk_unlock(c);\n\treturn bret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool container_destroy(struct lxc_container *c)\n{\n\tbool bret = false;\n\tint ret = 0;\n\tstruct lxc_conf *conf;\n\n\tif (!c || !do_lxcapi_is_defined(c))\n\t\treturn false;\n\n\tconf = c->lxc_conf;\n\tif (container_disk_lock(c))\n\t\treturn false;\n\n\tif (!is_stopped(c)) {\n\t\t// we should queue some sort of error - in c->error_string?\n\t\tERROR(\"container %s is not stopped\", c->name);\n\t\tgoto out;\n\t}\n\n\tif (conf && !lxc_list_empty(&conf->hooks[LXCHOOK_DESTROY])) {\n\t\t/* Start of environment variable setup for hooks */\n\t\tif (c->name && setenv(\"LXC_NAME\", c->name, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for container name\");\n\t\t}\n\t\tif (conf->rcfile && setenv(\"LXC_CONFIG_FILE\", conf->rcfile, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for config path\");\n\t\t}\n\t\tif (conf->rootfs.mount && setenv(\"LXC_ROOTFS_MOUNT\", conf->rootfs.mount, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for rootfs mount\");\n\t\t}\n\t\tif (conf->rootfs.path && setenv(\"LXC_ROOTFS_PATH\", conf->rootfs.path, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for rootfs mount\");\n\t\t}\n\t\tif (conf->console.path && setenv(\"LXC_CONSOLE\", conf->console.path, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for console path\");\n\t\t}\n\t\tif (conf->console.log_path && setenv(\"LXC_CONSOLE_LOGPATH\", conf->console.log_path, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for console log\");\n\t\t}\n\t\t/* End of environment variable setup for hooks */\n\n\t\tif (run_lxc_hooks(c->name, \"destroy\", conf, c->get_config_path(c), NULL)) {\n\t\t\tERROR(\"Error executing clone hook for %s\", c->name);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (current_config && conf == current_config) {\n\t\tcurrent_config = NULL;\n\t\tif (conf->logfd != -1) {\n\t\t\tclose(conf->logfd);\n\t\t\tconf->logfd = -1;\n\t\t}\n\t}\n\n\tif (conf && conf->rootfs.path && conf->rootfs.mount) {\n\t\tif (!do_destroy_container(conf)) {\n\t\t\tERROR(\"Error destroying rootfs for %s\", c->name);\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Destroyed rootfs for %s\", c->name);\n\t}\n\n\tmod_all_rdeps(c, false);\n\n\tconst char *p1 = do_lxcapi_get_config_path(c);\n\tchar *path = alloca(strlen(p1) + strlen(c->name) + 2);\n\tsprintf(path, \"%s/%s\", p1, c->name);\n\tif (am_unpriv())\n\t\tret = userns_exec_1(conf, lxc_rmdir_onedev_wrapper, path);\n\telse\n\t\tret = lxc_rmdir_onedev(path, \"snaps\");\n\tif (ret < 0) {\n\t\tERROR(\"Error destroying container directory for %s\", c->name);\n\t\tgoto out;\n\t}\n\tINFO(\"Destroyed directory for %s\", c->name);\n\n\tbret = true;\n\nout:\n\tcontainer_disk_unlock(c);\n\treturn bret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"container %s has snapshots on its rootfs\"",
            "c->name"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_fs_snapshots",
          "args": [
            "c"
          ],
          "line": 2432
        },
        "resolved": true,
        "details": {
          "function_name": "has_fs_snapshots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2263-2293",
          "snippet": "static bool has_fs_snapshots(struct lxc_container *c)\n{\n\tFILE *f;\n\tchar path[MAXPATHLEN];\n\tint ret, v;\n\tstruct stat fbuf;\n\tbool bret = false;\n\n\tret = snprintf(path, MAXPATHLEN, \"%s/%s/lxc_snapshots\", c->config_path,\n\t\t\tc->name);\n\tif (ret < 0 || ret > MAXPATHLEN)\n\t\tgoto out;\n\t/* If the file doesn't exist there are no snapshots. */\n\tif (stat(path, &fbuf) < 0)\n\t\tgoto out;\n\tv = fbuf.st_size;\n\tif (v != 0) {\n\t\tf = fopen(path, \"r\");\n\t\tif (!f)\n\t\t\tgoto out;\n\t\tret = fscanf(f, \"%d\", &v);\n\t\tfclose(f);\n\t\t// TODO: Figure out what to do with the return value of fscanf.\n\t\tif (ret != 1)\n\t\t\tINFO(\"Container uses new lxc-snapshots format %s\", path);\n\t}\n\tbret = v != 0;\n\nout:\n\treturn bret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool do_lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool do_lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool has_fs_snapshots(struct lxc_container *c)\n{\n\tFILE *f;\n\tchar path[MAXPATHLEN];\n\tint ret, v;\n\tstruct stat fbuf;\n\tbool bret = false;\n\n\tret = snprintf(path, MAXPATHLEN, \"%s/%s/lxc_snapshots\", c->config_path,\n\t\t\tc->name);\n\tif (ret < 0 || ret > MAXPATHLEN)\n\t\tgoto out;\n\t/* If the file doesn't exist there are no snapshots. */\n\tif (stat(path, &fbuf) < 0)\n\t\tgoto out;\n\tv = fbuf.st_size;\n\tif (v != 0) {\n\t\tf = fopen(path, \"r\");\n\t\tif (!f)\n\t\t\tgoto out;\n\t\tret = fscanf(f, \"%d\", &v);\n\t\tfclose(f);\n\t\t// TODO: Figure out what to do with the return value of fscanf.\n\t\tif (ret != 1)\n\t\t\tINFO(\"Container uses new lxc-snapshots format %s\", path);\n\t}\n\tbret = v != 0;\n\nout:\n\treturn bret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Container %s has snapshots;  not removing\"",
            "c->name"
          ],
          "line": 2428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_snapshots",
          "args": [
            "c"
          ],
          "line": 2427
        },
        "resolved": true,
        "details": {
          "function_name": "has_snapshots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2295-2321",
          "snippet": "static bool has_snapshots(struct lxc_container *c)\n{\n\tchar path[MAXPATHLEN];\n\tstruct dirent *direntp;\n\tint count=0;\n\tDIR *dir;\n\n\tif (!get_snappath_dir(c, path))\n\t\treturn false;\n\tdir = opendir(path);\n\tif (!dir)\n\t\treturn false;\n\twhile ((direntp = readdir(dir))) {\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\"))\n\t\t\tcontinue;\n\n\t\tif (!strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tcount++;\n\t\tbreak;\n\t}\n\tclosedir(dir);\n\treturn count > 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool has_snapshots(struct lxc_container *c)\n{\n\tchar path[MAXPATHLEN];\n\tstruct dirent *direntp;\n\tint count=0;\n\tDIR *dir;\n\n\tif (!get_snappath_dir(c, path))\n\t\treturn false;\n\tdir = opendir(path);\n\tif (!dir)\n\t\treturn false;\n\twhile ((direntp = readdir(dir))) {\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\"))\n\t\t\tcontinue;\n\n\t\tif (!strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tcount++;\n\t\tbreak;\n\t}\n\tclosedir(dir);\n\treturn count > 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxcapi_is_defined",
          "args": [
            "c"
          ],
          "line": 2425
        },
        "resolved": true,
        "details": {
          "function_name": "do_lxcapi_is_defined",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "327-348",
          "snippet": "static bool do_lxcapi_is_defined(struct lxc_container *c)\n{\n\tstruct stat statbuf;\n\tbool ret = false;\n\tint statret;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (container_mem_lock(c))\n\t\treturn false;\n\tif (!c->configfile)\n\t\tgoto out;\n\tstatret = stat(c->configfile, &statbuf);\n\tif (statret != 0)\n\t\tgoto out;\n\tret = true;\n\nout:\n\tcontainer_mem_unlock(c);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_is_defined(struct lxc_container *c)\n{\n\tstruct stat statbuf;\n\tbool ret = false;\n\tint statret;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (container_mem_lock(c))\n\t\treturn false;\n\tif (!c->configfile)\n\t\tgoto out;\n\tstatret = stat(c->configfile, &statbuf);\n\tif (statret != 0)\n\t\tgoto out;\n\tret = true;\n\nout:\n\tcontainer_mem_unlock(c);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c)\n{\n\tif (!c || !lxcapi_is_defined(c))\n\t\treturn false;\n\tif (has_snapshots(c)) {\n\t\tERROR(\"Container %s has snapshots;  not removing\", c->name);\n\t\treturn false;\n\t}\n\n\tif (has_fs_snapshots(c)) {\n\t\tERROR(\"container %s has snapshots on its rootfs\", c->name);\n\t\treturn false;\n\t}\n\n\treturn container_destroy(c);\n}"
  },
  {
    "function_name": "container_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "2338-2421",
    "snippet": "static bool container_destroy(struct lxc_container *c)\n{\n\tbool bret = false;\n\tint ret = 0;\n\tstruct lxc_conf *conf;\n\n\tif (!c || !do_lxcapi_is_defined(c))\n\t\treturn false;\n\n\tconf = c->lxc_conf;\n\tif (container_disk_lock(c))\n\t\treturn false;\n\n\tif (!is_stopped(c)) {\n\t\t// we should queue some sort of error - in c->error_string?\n\t\tERROR(\"container %s is not stopped\", c->name);\n\t\tgoto out;\n\t}\n\n\tif (conf && !lxc_list_empty(&conf->hooks[LXCHOOK_DESTROY])) {\n\t\t/* Start of environment variable setup for hooks */\n\t\tif (c->name && setenv(\"LXC_NAME\", c->name, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for container name\");\n\t\t}\n\t\tif (conf->rcfile && setenv(\"LXC_CONFIG_FILE\", conf->rcfile, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for config path\");\n\t\t}\n\t\tif (conf->rootfs.mount && setenv(\"LXC_ROOTFS_MOUNT\", conf->rootfs.mount, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for rootfs mount\");\n\t\t}\n\t\tif (conf->rootfs.path && setenv(\"LXC_ROOTFS_PATH\", conf->rootfs.path, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for rootfs mount\");\n\t\t}\n\t\tif (conf->console.path && setenv(\"LXC_CONSOLE\", conf->console.path, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for console path\");\n\t\t}\n\t\tif (conf->console.log_path && setenv(\"LXC_CONSOLE_LOGPATH\", conf->console.log_path, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for console log\");\n\t\t}\n\t\t/* End of environment variable setup for hooks */\n\n\t\tif (run_lxc_hooks(c->name, \"destroy\", conf, c->get_config_path(c), NULL)) {\n\t\t\tERROR(\"Error executing clone hook for %s\", c->name);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (current_config && conf == current_config) {\n\t\tcurrent_config = NULL;\n\t\tif (conf->logfd != -1) {\n\t\t\tclose(conf->logfd);\n\t\t\tconf->logfd = -1;\n\t\t}\n\t}\n\n\tif (conf && conf->rootfs.path && conf->rootfs.mount) {\n\t\tif (!do_destroy_container(conf)) {\n\t\t\tERROR(\"Error destroying rootfs for %s\", c->name);\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Destroyed rootfs for %s\", c->name);\n\t}\n\n\tmod_all_rdeps(c, false);\n\n\tconst char *p1 = do_lxcapi_get_config_path(c);\n\tchar *path = alloca(strlen(p1) + strlen(c->name) + 2);\n\tsprintf(path, \"%s/%s\", p1, c->name);\n\tif (am_unpriv())\n\t\tret = userns_exec_1(conf, lxc_rmdir_onedev_wrapper, path);\n\telse\n\t\tret = lxc_rmdir_onedev(path, \"snaps\");\n\tif (ret < 0) {\n\t\tERROR(\"Error destroying container directory for %s\", c->name);\n\t\tgoto out;\n\t}\n\tINFO(\"Destroyed directory for %s\", c->name);\n\n\tbret = true;\n\nout:\n\tcontainer_disk_unlock(c);\n\treturn bret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_disk_unlock",
          "args": [
            "c"
          ],
          "line": 2419
        },
        "resolved": true,
        "details": {
          "function_name": "container_disk_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "365-369",
          "snippet": "void container_disk_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->slock);\n\tlxcunlock(c->privlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nvoid container_disk_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->slock);\n\tlxcunlock(c->privlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Destroyed directory for %s\"",
            "c->name"
          ],
          "line": 2414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error destroying container directory for %s\"",
            "c->name"
          ],
          "line": 2411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_rmdir_onedev",
          "args": [
            "path",
            "\"snaps\""
          ],
          "line": 2409
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_rmdir_onedev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "203-220",
          "snippet": "extern int lxc_rmdir_onedev(char *path, const char *exclude)\n{\n\tstruct stat mystat;\n\tbool onedev = true;\n\n\tif (is_native_overlayfs(path)) {\n\t\tonedev = false;\n\t}\n\n\tif (lstat(path, &mystat) < 0) {\n\t\tif (errno == ENOENT)\n\t\t\treturn 0;\n\t\tERROR(\"%s: failed to stat %s\", __func__, path);\n\t\treturn -1;\n\t}\n\n\treturn _recursive_rmdir(path, mystat.st_dev, exclude, 0, onedev);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool btrfs_try_remove_subvol(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nextern int lxc_rmdir_onedev(char *path, const char *exclude)\n{\n\tstruct stat mystat;\n\tbool onedev = true;\n\n\tif (is_native_overlayfs(path)) {\n\t\tonedev = false;\n\t}\n\n\tif (lstat(path, &mystat) < 0) {\n\t\tif (errno == ENOENT)\n\t\t\treturn 0;\n\t\tERROR(\"%s: failed to stat %s\", __func__, path);\n\t\treturn -1;\n\t}\n\n\treturn _recursive_rmdir(path, mystat.st_dev, exclude, 0, onedev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "userns_exec_1",
          "args": [
            "conf",
            "lxc_rmdir_onedev_wrapper",
            "path"
          ],
          "line": 2407
        },
        "resolved": true,
        "details": {
          "function_name": "userns_exec_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4435-4487",
          "snippet": "int userns_exec_1(struct lxc_conf *conf, int (*fn)(void *), void *data)\n{\n\tint ret, pid;\n\tstruct userns_fn_data d;\n\tchar c = '1';\n\tint p[2];\n\tstruct lxc_list *idmap;\n\n\tret = pipe(p);\n\tif (ret < 0) {\n\t\tSYSERROR(\"opening pipe\");\n\t\treturn -1;\n\t}\n\td.fn = fn;\n\td.arg = data;\n\td.p[0] = p[0];\n\td.p[1] = p[1];\n\tpid = lxc_clone(run_userns_fn, &d, CLONE_NEWUSER);\n\tif (pid < 0)\n\t\tgoto err;\n\tclose(p[0]);\n\tp[0] = -1;\n\n\tif ((idmap = idmap_add_id(conf, geteuid(), getegid())) == NULL) {\n\t\tERROR(\"Error adding self to container uid/gid map\");\n\t\tgoto err;\n\t}\n\n\tret = lxc_map_ids(idmap, pid);\n\tlxc_free_idmap(idmap);\n\tfree(idmap);\n\tif (ret) {\n\t\tERROR(\"Error setting up child mappings\");\n\t\tgoto err;\n\t}\n\n\t// kick the child\n\tif (write(p[1], &c, 1) != 1) {\n\t\tSYSERROR(\"writing to pipe to child\");\n\t\tgoto err;\n\t}\n\n\tret = wait_for_pid(pid);\n\n\tclose(p[1]);\n\treturn ret;\n\nerr:\n\tif (p[0] != -1)\n\t\tclose(p[0]);\n\tclose(p[1]);\n\treturn -1;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint userns_exec_1(struct lxc_conf *conf, int (*fn)(void *), void *data)\n{\n\tint ret, pid;\n\tstruct userns_fn_data d;\n\tchar c = '1';\n\tint p[2];\n\tstruct lxc_list *idmap;\n\n\tret = pipe(p);\n\tif (ret < 0) {\n\t\tSYSERROR(\"opening pipe\");\n\t\treturn -1;\n\t}\n\td.fn = fn;\n\td.arg = data;\n\td.p[0] = p[0];\n\td.p[1] = p[1];\n\tpid = lxc_clone(run_userns_fn, &d, CLONE_NEWUSER);\n\tif (pid < 0)\n\t\tgoto err;\n\tclose(p[0]);\n\tp[0] = -1;\n\n\tif ((idmap = idmap_add_id(conf, geteuid(), getegid())) == NULL) {\n\t\tERROR(\"Error adding self to container uid/gid map\");\n\t\tgoto err;\n\t}\n\n\tret = lxc_map_ids(idmap, pid);\n\tlxc_free_idmap(idmap);\n\tfree(idmap);\n\tif (ret) {\n\t\tERROR(\"Error setting up child mappings\");\n\t\tgoto err;\n\t}\n\n\t// kick the child\n\tif (write(p[1], &c, 1) != 1) {\n\t\tSYSERROR(\"writing to pipe to child\");\n\t\tgoto err;\n\t}\n\n\tret = wait_for_pid(pid);\n\n\tclose(p[1]);\n\treturn ret;\n\nerr:\n\tif (p[0] != -1)\n\t\tclose(p[0]);\n\tclose(p[1]);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "am_unpriv",
          "args": [],
          "line": 2406
        },
        "resolved": true,
        "details": {
          "function_name": "am_unpriv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.h",
          "lines": "288-290",
          "snippet": "inline static bool am_unpriv(void) {\n\treturn geteuid() != 0;\n}",
          "includes": [
            "#include <stdint.h>",
            "#  include <sys/signalfd.h>",
            "#include <../include/getline.h>",
            "#include \"initutils.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#  include <sys/signalfd.h>\n#include <../include/getline.h>\n#include \"initutils.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"config.h\"\n\ninline static bool am_unpriv(void) {\n\treturn geteuid() != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "path",
            "\"%s/%s\"",
            "p1",
            "c->name"
          ],
          "line": 2405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "strlen(p1) + strlen(c->name) + 2"
          ],
          "line": 2404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "c->name"
          ],
          "line": 2404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p1"
          ],
          "line": 2404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_lxcapi_get_config_path",
          "args": [
            "c"
          ],
          "line": 2403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mod_all_rdeps",
          "args": [
            "c",
            "false"
          ],
          "line": 2401
        },
        "resolved": true,
        "details": {
          "function_name": "mod_all_rdeps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2223-2261",
          "snippet": "void mod_all_rdeps(struct lxc_container *c, bool inc)\n{\n\tstruct lxc_container *p;\n\tchar *lxcpath = NULL, *lxcname = NULL, path[MAXPATHLEN];\n\tsize_t pathlen = 0, namelen = 0;\n\tFILE *f;\n\tint ret;\n\n\tret = snprintf(path, MAXPATHLEN, \"%s/%s/lxc_rdepends\",\n\t\tc->config_path, c->name);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tERROR(\"Path name too long\");\n\t\treturn;\n\t}\n\tf = fopen(path, \"r\");\n\tif (f == NULL)\n\t\treturn;\n\twhile (getline(&lxcpath, &pathlen, f) != -1) {\n\t\tif (getline(&lxcname, &namelen, f) == -1) {\n\t\t\tERROR(\"badly formatted file %s\", path);\n\t\t\tgoto out;\n\t\t}\n\t\tstrip_newline(lxcpath);\n\t\tstrip_newline(lxcname);\n\t\tif ((p = lxc_container_new(lxcname, lxcpath)) == NULL) {\n\t\t\tERROR(\"Unable to find dependent container %s:%s\",\n\t\t\t\tlxcpath, lxcname);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!mod_rdep(p, c, inc))\n\t\t\tERROR(\"Failed to update snapshots file for %s:%s\",\n\t\t\t\tlxcpath, lxcname);\n\t\tlxc_container_put(p);\n\t}\nout:\n\tfree(lxcpath);\n\tfree(lxcname);\n\tfclose(f);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nvoid mod_all_rdeps(struct lxc_container *c, bool inc)\n{\n\tstruct lxc_container *p;\n\tchar *lxcpath = NULL, *lxcname = NULL, path[MAXPATHLEN];\n\tsize_t pathlen = 0, namelen = 0;\n\tFILE *f;\n\tint ret;\n\n\tret = snprintf(path, MAXPATHLEN, \"%s/%s/lxc_rdepends\",\n\t\tc->config_path, c->name);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tERROR(\"Path name too long\");\n\t\treturn;\n\t}\n\tf = fopen(path, \"r\");\n\tif (f == NULL)\n\t\treturn;\n\twhile (getline(&lxcpath, &pathlen, f) != -1) {\n\t\tif (getline(&lxcname, &namelen, f) == -1) {\n\t\t\tERROR(\"badly formatted file %s\", path);\n\t\t\tgoto out;\n\t\t}\n\t\tstrip_newline(lxcpath);\n\t\tstrip_newline(lxcname);\n\t\tif ((p = lxc_container_new(lxcname, lxcpath)) == NULL) {\n\t\t\tERROR(\"Unable to find dependent container %s:%s\",\n\t\t\t\tlxcpath, lxcname);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!mod_rdep(p, c, inc))\n\t\t\tERROR(\"Failed to update snapshots file for %s:%s\",\n\t\t\t\tlxcpath, lxcname);\n\t\tlxc_container_put(p);\n\t}\nout:\n\tfree(lxcpath);\n\tfree(lxcname);\n\tfclose(f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Destroyed rootfs for %s\"",
            "c->name"
          ],
          "line": 2398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error destroying rootfs for %s\"",
            "c->name"
          ],
          "line": 2395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_destroy_container",
          "args": [
            "conf"
          ],
          "line": 2394
        },
        "resolved": true,
        "details": {
          "function_name": "do_destroy_container",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2323-2330",
          "snippet": "static bool do_destroy_container(struct lxc_conf *conf) {\n\tif (am_unpriv()) {\n\t\tif (userns_exec_1(conf, bdev_destroy_wrapper, conf) < 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\treturn bdev_destroy(conf);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_destroy_container(struct lxc_conf *conf) {\n\tif (am_unpriv()) {\n\t\tif (userns_exec_1(conf, bdev_destroy_wrapper, conf) < 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\treturn bdev_destroy(conf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "conf->logfd"
          ],
          "line": 2388
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error executing clone hook for %s\"",
            "c->name"
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run_lxc_hooks",
          "args": [
            "c->name",
            "\"destroy\"",
            "conf",
            "c->get_config_path(c)",
            "NULL"
          ],
          "line": 2379
        },
        "resolved": true,
        "details": {
          "function_name": "run_lxc_hooks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3995-4029",
          "snippet": "int run_lxc_hooks(const char *name, char *hook, struct lxc_conf *conf,\n\t\t  const char *lxcpath, char *argv[])\n{\n\tint which = -1;\n\tstruct lxc_list *it;\n\n\tif (strcmp(hook, \"pre-start\") == 0)\n\t\twhich = LXCHOOK_PRESTART;\n\telse if (strcmp(hook, \"pre-mount\") == 0)\n\t\twhich = LXCHOOK_PREMOUNT;\n\telse if (strcmp(hook, \"mount\") == 0)\n\t\twhich = LXCHOOK_MOUNT;\n\telse if (strcmp(hook, \"autodev\") == 0)\n\t\twhich = LXCHOOK_AUTODEV;\n\telse if (strcmp(hook, \"start\") == 0)\n\t\twhich = LXCHOOK_START;\n\telse if (strcmp(hook, \"stop\") == 0)\n\t\twhich = LXCHOOK_STOP;\n\telse if (strcmp(hook, \"post-stop\") == 0)\n\t\twhich = LXCHOOK_POSTSTOP;\n\telse if (strcmp(hook, \"clone\") == 0)\n\t\twhich = LXCHOOK_CLONE;\n\telse if (strcmp(hook, \"destroy\") == 0)\n\t\twhich = LXCHOOK_DESTROY;\n\telse\n\t\treturn -1;\n\tlxc_list_for_each(it, &conf->hooks[which]) {\n\t\tint ret;\n\t\tchar *hookname = it->elem;\n\t\tret = run_script_argv(name, \"lxc\", hookname, hook, lxcpath, argv);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint run_lxc_hooks(const char *name, char *hook, struct lxc_conf *conf,\n\t\t  const char *lxcpath, char *argv[])\n{\n\tint which = -1;\n\tstruct lxc_list *it;\n\n\tif (strcmp(hook, \"pre-start\") == 0)\n\t\twhich = LXCHOOK_PRESTART;\n\telse if (strcmp(hook, \"pre-mount\") == 0)\n\t\twhich = LXCHOOK_PREMOUNT;\n\telse if (strcmp(hook, \"mount\") == 0)\n\t\twhich = LXCHOOK_MOUNT;\n\telse if (strcmp(hook, \"autodev\") == 0)\n\t\twhich = LXCHOOK_AUTODEV;\n\telse if (strcmp(hook, \"start\") == 0)\n\t\twhich = LXCHOOK_START;\n\telse if (strcmp(hook, \"stop\") == 0)\n\t\twhich = LXCHOOK_STOP;\n\telse if (strcmp(hook, \"post-stop\") == 0)\n\t\twhich = LXCHOOK_POSTSTOP;\n\telse if (strcmp(hook, \"clone\") == 0)\n\t\twhich = LXCHOOK_CLONE;\n\telse if (strcmp(hook, \"destroy\") == 0)\n\t\twhich = LXCHOOK_DESTROY;\n\telse\n\t\treturn -1;\n\tlxc_list_for_each(it, &conf->hooks[which]) {\n\t\tint ret;\n\t\tchar *hookname = it->elem;\n\t\tret = run_script_argv(name, \"lxc\", hookname, hook, lxcpath, argv);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->get_config_path",
          "args": [
            "c"
          ],
          "line": 2379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to set environment variable for console log\""
          ],
          "line": 2375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"LXC_CONSOLE_LOGPATH\"",
            "conf->console.log_path",
            "1"
          ],
          "line": 2374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to set environment variable for console path\""
          ],
          "line": 2372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"LXC_CONSOLE\"",
            "conf->console.path",
            "1"
          ],
          "line": 2371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to set environment variable for rootfs mount\""
          ],
          "line": 2369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"LXC_ROOTFS_PATH\"",
            "conf->rootfs.path",
            "1"
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to set environment variable for rootfs mount\""
          ],
          "line": 2366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"LXC_ROOTFS_MOUNT\"",
            "conf->rootfs.mount",
            "1"
          ],
          "line": 2365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to set environment variable for config path\""
          ],
          "line": 2363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"LXC_CONFIG_FILE\"",
            "conf->rcfile",
            "1"
          ],
          "line": 2362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to set environment variable for container name\""
          ],
          "line": 2360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"LXC_NAME\"",
            "c->name",
            "1"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_empty",
          "args": [
            "&conf->hooks[LXCHOOK_DESTROY]"
          ],
          "line": 2357
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "94-97",
          "snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"container %s is not stopped\"",
            "c->name"
          ],
          "line": 2353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_stopped",
          "args": [
            "c"
          ],
          "line": 2351
        },
        "resolved": true,
        "details": {
          "function_name": "is_stopped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "434-441",
          "snippet": "WRAP_API(const char *, lxcapi_state)\n\nstatic bool is_stopped(struct lxc_container *c)\n{\n\tlxc_state_t s;\n\ts = lxc_getstate(c->name, c->config_path);\n\treturn (s == STOPPED);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nWRAP_API(const char *, lxcapi_state)\n\nstatic bool is_stopped(struct lxc_container *c)\n{\n\tlxc_state_t s;\n\ts = lxc_getstate(c->name, c->config_path);\n\treturn (s == STOPPED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_disk_lock",
          "args": [
            "c"
          ],
          "line": 2348
        },
        "resolved": true,
        "details": {
          "function_name": "container_disk_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "352-363",
          "snippet": "int container_disk_lock(struct lxc_container *c)\n{\n\tint ret;\n\n\tif ((ret = lxclock(c->privlock, 0)))\n\t\treturn ret;\n\tif ((ret = lxclock(c->slock, 0))) {\n\t\tlxcunlock(c->privlock);\n\t\treturn ret;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nint container_disk_lock(struct lxc_container *c)\n{\n\tint ret;\n\n\tif ((ret = lxclock(c->privlock, 0)))\n\t\treturn ret;\n\tif ((ret = lxclock(c->slock, 0))) {\n\t\tlxcunlock(c->privlock);\n\t\treturn ret;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_lxcapi_is_defined",
          "args": [
            "c"
          ],
          "line": 2344
        },
        "resolved": true,
        "details": {
          "function_name": "do_lxcapi_is_defined",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "327-348",
          "snippet": "static bool do_lxcapi_is_defined(struct lxc_container *c)\n{\n\tstruct stat statbuf;\n\tbool ret = false;\n\tint statret;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (container_mem_lock(c))\n\t\treturn false;\n\tif (!c->configfile)\n\t\tgoto out;\n\tstatret = stat(c->configfile, &statbuf);\n\tif (statret != 0)\n\t\tgoto out;\n\tret = true;\n\nout:\n\tcontainer_mem_unlock(c);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_is_defined(struct lxc_container *c)\n{\n\tstruct stat statbuf;\n\tbool ret = false;\n\tint statret;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (container_mem_lock(c))\n\t\treturn false;\n\tif (!c->configfile)\n\t\tgoto out;\n\tstatret = stat(c->configfile, &statbuf);\n\tif (statret != 0)\n\t\tgoto out;\n\tret = true;\n\nout:\n\tcontainer_mem_unlock(c);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool container_destroy(struct lxc_container *c)\n{\n\tbool bret = false;\n\tint ret = 0;\n\tstruct lxc_conf *conf;\n\n\tif (!c || !do_lxcapi_is_defined(c))\n\t\treturn false;\n\n\tconf = c->lxc_conf;\n\tif (container_disk_lock(c))\n\t\treturn false;\n\n\tif (!is_stopped(c)) {\n\t\t// we should queue some sort of error - in c->error_string?\n\t\tERROR(\"container %s is not stopped\", c->name);\n\t\tgoto out;\n\t}\n\n\tif (conf && !lxc_list_empty(&conf->hooks[LXCHOOK_DESTROY])) {\n\t\t/* Start of environment variable setup for hooks */\n\t\tif (c->name && setenv(\"LXC_NAME\", c->name, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for container name\");\n\t\t}\n\t\tif (conf->rcfile && setenv(\"LXC_CONFIG_FILE\", conf->rcfile, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for config path\");\n\t\t}\n\t\tif (conf->rootfs.mount && setenv(\"LXC_ROOTFS_MOUNT\", conf->rootfs.mount, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for rootfs mount\");\n\t\t}\n\t\tif (conf->rootfs.path && setenv(\"LXC_ROOTFS_PATH\", conf->rootfs.path, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for rootfs mount\");\n\t\t}\n\t\tif (conf->console.path && setenv(\"LXC_CONSOLE\", conf->console.path, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for console path\");\n\t\t}\n\t\tif (conf->console.log_path && setenv(\"LXC_CONSOLE_LOGPATH\", conf->console.log_path, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for console log\");\n\t\t}\n\t\t/* End of environment variable setup for hooks */\n\n\t\tif (run_lxc_hooks(c->name, \"destroy\", conf, c->get_config_path(c), NULL)) {\n\t\t\tERROR(\"Error executing clone hook for %s\", c->name);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (current_config && conf == current_config) {\n\t\tcurrent_config = NULL;\n\t\tif (conf->logfd != -1) {\n\t\t\tclose(conf->logfd);\n\t\t\tconf->logfd = -1;\n\t\t}\n\t}\n\n\tif (conf && conf->rootfs.path && conf->rootfs.mount) {\n\t\tif (!do_destroy_container(conf)) {\n\t\t\tERROR(\"Error destroying rootfs for %s\", c->name);\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Destroyed rootfs for %s\", c->name);\n\t}\n\n\tmod_all_rdeps(c, false);\n\n\tconst char *p1 = do_lxcapi_get_config_path(c);\n\tchar *path = alloca(strlen(p1) + strlen(c->name) + 2);\n\tsprintf(path, \"%s/%s\", p1, c->name);\n\tif (am_unpriv())\n\t\tret = userns_exec_1(conf, lxc_rmdir_onedev_wrapper, path);\n\telse\n\t\tret = lxc_rmdir_onedev(path, \"snaps\");\n\tif (ret < 0) {\n\t\tERROR(\"Error destroying container directory for %s\", c->name);\n\t\tgoto out;\n\t}\n\tINFO(\"Destroyed directory for %s\", c->name);\n\n\tbret = true;\n\nout:\n\tcontainer_disk_unlock(c);\n\treturn bret;\n}"
  },
  {
    "function_name": "lxc_rmdir_onedev_wrapper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "2332-2336",
    "snippet": "static int lxc_rmdir_onedev_wrapper(void *data)\n{\n\tchar *arg = (char *) data;\n\treturn lxc_rmdir_onedev(arg, \"snaps\");\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_rmdir_onedev",
          "args": [
            "arg",
            "\"snaps\""
          ],
          "line": 2335
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_rmdir_onedev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "203-220",
          "snippet": "extern int lxc_rmdir_onedev(char *path, const char *exclude)\n{\n\tstruct stat mystat;\n\tbool onedev = true;\n\n\tif (is_native_overlayfs(path)) {\n\t\tonedev = false;\n\t}\n\n\tif (lstat(path, &mystat) < 0) {\n\t\tif (errno == ENOENT)\n\t\t\treturn 0;\n\t\tERROR(\"%s: failed to stat %s\", __func__, path);\n\t\treturn -1;\n\t}\n\n\treturn _recursive_rmdir(path, mystat.st_dev, exclude, 0, onedev);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool btrfs_try_remove_subvol(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nextern int lxc_rmdir_onedev(char *path, const char *exclude)\n{\n\tstruct stat mystat;\n\tbool onedev = true;\n\n\tif (is_native_overlayfs(path)) {\n\t\tonedev = false;\n\t}\n\n\tif (lstat(path, &mystat) < 0) {\n\t\tif (errno == ENOENT)\n\t\t\treturn 0;\n\t\tERROR(\"%s: failed to stat %s\", __func__, path);\n\t\treturn -1;\n\t}\n\n\treturn _recursive_rmdir(path, mystat.st_dev, exclude, 0, onedev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic int lxc_rmdir_onedev_wrapper(void *data)\n{\n\tchar *arg = (char *) data;\n\treturn lxc_rmdir_onedev(arg, \"snaps\");\n}"
  },
  {
    "function_name": "do_destroy_container",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "2323-2330",
    "snippet": "static bool do_destroy_container(struct lxc_conf *conf) {\n\tif (am_unpriv()) {\n\t\tif (userns_exec_1(conf, bdev_destroy_wrapper, conf) < 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\treturn bdev_destroy(conf);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdev_destroy",
          "args": [
            "conf"
          ],
          "line": 2329
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_destroy_wrapper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "513-531",
          "snippet": "int bdev_destroy_wrapper(void *data)\n{\n\tstruct lxc_conf *conf = data;\n\n\tif (setgid(0) < 0) {\n\t\tERROR(\"Failed to setgid to 0\");\n\t\treturn -1;\n\t}\n\tif (setgroups(0, NULL) < 0)\n\t\tWARN(\"Failed to clear groups\");\n\tif (setuid(0) < 0) {\n\t\tERROR(\"Failed to setuid to 0\");\n\t\treturn -1;\n\t}\n\tif (!bdev_destroy(conf))\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int find_fstype_cb(char *buffer, void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic int find_fstype_cb(char *buffer, void *data);\n\nint bdev_destroy_wrapper(void *data)\n{\n\tstruct lxc_conf *conf = data;\n\n\tif (setgid(0) < 0) {\n\t\tERROR(\"Failed to setgid to 0\");\n\t\treturn -1;\n\t}\n\tif (setgroups(0, NULL) < 0)\n\t\tWARN(\"Failed to clear groups\");\n\tif (setuid(0) < 0) {\n\t\tERROR(\"Failed to setuid to 0\");\n\t\treturn -1;\n\t}\n\tif (!bdev_destroy(conf))\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "userns_exec_1",
          "args": [
            "conf",
            "bdev_destroy_wrapper",
            "conf"
          ],
          "line": 2325
        },
        "resolved": true,
        "details": {
          "function_name": "userns_exec_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4435-4487",
          "snippet": "int userns_exec_1(struct lxc_conf *conf, int (*fn)(void *), void *data)\n{\n\tint ret, pid;\n\tstruct userns_fn_data d;\n\tchar c = '1';\n\tint p[2];\n\tstruct lxc_list *idmap;\n\n\tret = pipe(p);\n\tif (ret < 0) {\n\t\tSYSERROR(\"opening pipe\");\n\t\treturn -1;\n\t}\n\td.fn = fn;\n\td.arg = data;\n\td.p[0] = p[0];\n\td.p[1] = p[1];\n\tpid = lxc_clone(run_userns_fn, &d, CLONE_NEWUSER);\n\tif (pid < 0)\n\t\tgoto err;\n\tclose(p[0]);\n\tp[0] = -1;\n\n\tif ((idmap = idmap_add_id(conf, geteuid(), getegid())) == NULL) {\n\t\tERROR(\"Error adding self to container uid/gid map\");\n\t\tgoto err;\n\t}\n\n\tret = lxc_map_ids(idmap, pid);\n\tlxc_free_idmap(idmap);\n\tfree(idmap);\n\tif (ret) {\n\t\tERROR(\"Error setting up child mappings\");\n\t\tgoto err;\n\t}\n\n\t// kick the child\n\tif (write(p[1], &c, 1) != 1) {\n\t\tSYSERROR(\"writing to pipe to child\");\n\t\tgoto err;\n\t}\n\n\tret = wait_for_pid(pid);\n\n\tclose(p[1]);\n\treturn ret;\n\nerr:\n\tif (p[0] != -1)\n\t\tclose(p[0]);\n\tclose(p[1]);\n\treturn -1;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint userns_exec_1(struct lxc_conf *conf, int (*fn)(void *), void *data)\n{\n\tint ret, pid;\n\tstruct userns_fn_data d;\n\tchar c = '1';\n\tint p[2];\n\tstruct lxc_list *idmap;\n\n\tret = pipe(p);\n\tif (ret < 0) {\n\t\tSYSERROR(\"opening pipe\");\n\t\treturn -1;\n\t}\n\td.fn = fn;\n\td.arg = data;\n\td.p[0] = p[0];\n\td.p[1] = p[1];\n\tpid = lxc_clone(run_userns_fn, &d, CLONE_NEWUSER);\n\tif (pid < 0)\n\t\tgoto err;\n\tclose(p[0]);\n\tp[0] = -1;\n\n\tif ((idmap = idmap_add_id(conf, geteuid(), getegid())) == NULL) {\n\t\tERROR(\"Error adding self to container uid/gid map\");\n\t\tgoto err;\n\t}\n\n\tret = lxc_map_ids(idmap, pid);\n\tlxc_free_idmap(idmap);\n\tfree(idmap);\n\tif (ret) {\n\t\tERROR(\"Error setting up child mappings\");\n\t\tgoto err;\n\t}\n\n\t// kick the child\n\tif (write(p[1], &c, 1) != 1) {\n\t\tSYSERROR(\"writing to pipe to child\");\n\t\tgoto err;\n\t}\n\n\tret = wait_for_pid(pid);\n\n\tclose(p[1]);\n\treturn ret;\n\nerr:\n\tif (p[0] != -1)\n\t\tclose(p[0]);\n\tclose(p[1]);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "am_unpriv",
          "args": [],
          "line": 2324
        },
        "resolved": true,
        "details": {
          "function_name": "am_unpriv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.h",
          "lines": "288-290",
          "snippet": "inline static bool am_unpriv(void) {\n\treturn geteuid() != 0;\n}",
          "includes": [
            "#include <stdint.h>",
            "#  include <sys/signalfd.h>",
            "#include <../include/getline.h>",
            "#include \"initutils.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#  include <sys/signalfd.h>\n#include <../include/getline.h>\n#include \"initutils.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"config.h\"\n\ninline static bool am_unpriv(void) {\n\treturn geteuid() != 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_destroy_container(struct lxc_conf *conf) {\n\tif (am_unpriv()) {\n\t\tif (userns_exec_1(conf, bdev_destroy_wrapper, conf) < 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\treturn bdev_destroy(conf);\n}"
  },
  {
    "function_name": "has_snapshots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "2295-2321",
    "snippet": "static bool has_snapshots(struct lxc_container *c)\n{\n\tchar path[MAXPATHLEN];\n\tstruct dirent *direntp;\n\tint count=0;\n\tDIR *dir;\n\n\tif (!get_snappath_dir(c, path))\n\t\treturn false;\n\tdir = opendir(path);\n\tif (!dir)\n\t\treturn false;\n\twhile ((direntp = readdir(dir))) {\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\"))\n\t\t\tcontinue;\n\n\t\tif (!strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tcount++;\n\t\tbreak;\n\t}\n\tclosedir(dir);\n\treturn count > 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dir"
          ],
          "line": 2319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "direntp->d_name",
            "\"..\""
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "direntp->d_name",
            "\".\""
          ],
          "line": 2311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "dir"
          ],
          "line": 2307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "path"
          ],
          "line": 2304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_snappath_dir",
          "args": [
            "c",
            "path"
          ],
          "line": 2302
        },
        "resolved": true,
        "details": {
          "function_name": "get_snappath_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "3344-3369",
          "snippet": "static bool get_snappath_dir(struct lxc_container *c, char *snappath)\n{\n\tint ret;\n\t/*\n\t * If the old style snapshot path exists, use it\n\t * /var/lib/lxc -> /var/lib/lxcsnaps\n\t */\n\tret = snprintf(snappath, MAXPATHLEN, \"%ssnaps\", c->config_path);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn false;\n\tif (dir_exists(snappath)) {\n\t\tret = snprintf(snappath, MAXPATHLEN, \"%ssnaps/%s\", c->config_path, c->name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/*\n\t * Use the new style path\n\t * /var/lib/lxc -> /var/lib/lxc + c->name + /snaps + \\0\n\t */\n\tret = snprintf(snappath, MAXPATHLEN, \"%s/%s/snaps\", c->config_path, c->name);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool get_snappath_dir(struct lxc_container *c, char *snappath);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool get_snappath_dir(struct lxc_container *c, char *snappath);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool get_snappath_dir(struct lxc_container *c, char *snappath)\n{\n\tint ret;\n\t/*\n\t * If the old style snapshot path exists, use it\n\t * /var/lib/lxc -> /var/lib/lxcsnaps\n\t */\n\tret = snprintf(snappath, MAXPATHLEN, \"%ssnaps\", c->config_path);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn false;\n\tif (dir_exists(snappath)) {\n\t\tret = snprintf(snappath, MAXPATHLEN, \"%ssnaps/%s\", c->config_path, c->name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/*\n\t * Use the new style path\n\t * /var/lib/lxc -> /var/lib/lxc + c->name + /snaps + \\0\n\t */\n\tret = snprintf(snappath, MAXPATHLEN, \"%s/%s/snaps\", c->config_path, c->name);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn false;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool has_snapshots(struct lxc_container *c)\n{\n\tchar path[MAXPATHLEN];\n\tstruct dirent *direntp;\n\tint count=0;\n\tDIR *dir;\n\n\tif (!get_snappath_dir(c, path))\n\t\treturn false;\n\tdir = opendir(path);\n\tif (!dir)\n\t\treturn false;\n\twhile ((direntp = readdir(dir))) {\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\"))\n\t\t\tcontinue;\n\n\t\tif (!strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tcount++;\n\t\tbreak;\n\t}\n\tclosedir(dir);\n\treturn count > 0;\n}"
  },
  {
    "function_name": "has_fs_snapshots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "2263-2293",
    "snippet": "static bool has_fs_snapshots(struct lxc_container *c)\n{\n\tFILE *f;\n\tchar path[MAXPATHLEN];\n\tint ret, v;\n\tstruct stat fbuf;\n\tbool bret = false;\n\n\tret = snprintf(path, MAXPATHLEN, \"%s/%s/lxc_snapshots\", c->config_path,\n\t\t\tc->name);\n\tif (ret < 0 || ret > MAXPATHLEN)\n\t\tgoto out;\n\t/* If the file doesn't exist there are no snapshots. */\n\tif (stat(path, &fbuf) < 0)\n\t\tgoto out;\n\tv = fbuf.st_size;\n\tif (v != 0) {\n\t\tf = fopen(path, \"r\");\n\t\tif (!f)\n\t\t\tgoto out;\n\t\tret = fscanf(f, \"%d\", &v);\n\t\tfclose(f);\n\t\t// TODO: Figure out what to do with the return value of fscanf.\n\t\tif (ret != 1)\n\t\t\tINFO(\"Container uses new lxc-snapshots format %s\", path);\n\t}\n\tbret = v != 0;\n\nout:\n\treturn bret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool do_lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Container uses new lxc-snapshots format %s\"",
            "path"
          ],
          "line": 2287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 2284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "f",
            "\"%d\"",
            "&v"
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "path",
            "\"r\""
          ],
          "line": 2280
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "path",
            "&fbuf"
          ],
          "line": 2276
        },
        "resolved": true,
        "details": {
          "function_name": "freezer_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/freezer.c",
          "lines": "42-51",
          "snippet": "lxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}",
          "includes": [
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"monitor.h\"",
            "#include \"state.h\"",
            "#include \"error.h\"",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxc.h\"\n#include \"log.h\"\n#include \"monitor.h\"\n#include \"state.h\"\n#include \"error.h\"\n#include <sys/param.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nlxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "MAXPATHLEN",
            "\"%s/%s/lxc_snapshots\"",
            "c->config_path",
            "c->name"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool do_lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool has_fs_snapshots(struct lxc_container *c)\n{\n\tFILE *f;\n\tchar path[MAXPATHLEN];\n\tint ret, v;\n\tstruct stat fbuf;\n\tbool bret = false;\n\n\tret = snprintf(path, MAXPATHLEN, \"%s/%s/lxc_snapshots\", c->config_path,\n\t\t\tc->name);\n\tif (ret < 0 || ret > MAXPATHLEN)\n\t\tgoto out;\n\t/* If the file doesn't exist there are no snapshots. */\n\tif (stat(path, &fbuf) < 0)\n\t\tgoto out;\n\tv = fbuf.st_size;\n\tif (v != 0) {\n\t\tf = fopen(path, \"r\");\n\t\tif (!f)\n\t\t\tgoto out;\n\t\tret = fscanf(f, \"%d\", &v);\n\t\tfclose(f);\n\t\t// TODO: Figure out what to do with the return value of fscanf.\n\t\tif (ret != 1)\n\t\t\tINFO(\"Container uses new lxc-snapshots format %s\", path);\n\t}\n\tbret = v != 0;\n\nout:\n\treturn bret;\n}"
  },
  {
    "function_name": "mod_all_rdeps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "2223-2261",
    "snippet": "void mod_all_rdeps(struct lxc_container *c, bool inc)\n{\n\tstruct lxc_container *p;\n\tchar *lxcpath = NULL, *lxcname = NULL, path[MAXPATHLEN];\n\tsize_t pathlen = 0, namelen = 0;\n\tFILE *f;\n\tint ret;\n\n\tret = snprintf(path, MAXPATHLEN, \"%s/%s/lxc_rdepends\",\n\t\tc->config_path, c->name);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tERROR(\"Path name too long\");\n\t\treturn;\n\t}\n\tf = fopen(path, \"r\");\n\tif (f == NULL)\n\t\treturn;\n\twhile (getline(&lxcpath, &pathlen, f) != -1) {\n\t\tif (getline(&lxcname, &namelen, f) == -1) {\n\t\t\tERROR(\"badly formatted file %s\", path);\n\t\t\tgoto out;\n\t\t}\n\t\tstrip_newline(lxcpath);\n\t\tstrip_newline(lxcname);\n\t\tif ((p = lxc_container_new(lxcname, lxcpath)) == NULL) {\n\t\t\tERROR(\"Unable to find dependent container %s:%s\",\n\t\t\t\tlxcpath, lxcname);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!mod_rdep(p, c, inc))\n\t\t\tERROR(\"Failed to update snapshots file for %s:%s\",\n\t\t\t\tlxcpath, lxcname);\n\t\tlxc_container_put(p);\n\t}\nout:\n\tfree(lxcpath);\n\tfree(lxcname);\n\tfclose(f);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 2260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "lxcname"
          ],
          "line": 2259
        },
        "resolved": true,
        "details": {
          "function_name": "free_init_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "706-715",
          "snippet": "static void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_container_put",
          "args": [
            "p"
          ],
          "line": 2255
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "312-325",
          "snippet": "int lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to update snapshots file for %s:%s\"",
            "lxcpath",
            "lxcname"
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mod_rdep",
          "args": [
            "p",
            "c",
            "inc"
          ],
          "line": 2252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Unable to find dependent container %s:%s\"",
            "lxcpath",
            "lxcname"
          ],
          "line": 2248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_container_new",
          "args": [
            "lxcname",
            "lxcpath"
          ],
          "line": 2247
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "4099-4218",
          "snippet": "struct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstruct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strip_newline",
          "args": [
            "lxcname"
          ],
          "line": 2246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strip_newline",
          "args": [
            "lxcpath"
          ],
          "line": 2245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"badly formatted file %s\"",
            "path"
          ],
          "line": 2242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&lxcname",
            "&namelen",
            "f"
          ],
          "line": 2241
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getline.c",
          "lines": "39-60",
          "snippet": "ssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "path",
            "\"r\""
          ],
          "line": 2237
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Path name too long\""
          ],
          "line": 2234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "MAXPATHLEN",
            "\"%s/%s/lxc_rdepends\"",
            "c->config_path",
            "c->name"
          ],
          "line": 2231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nvoid mod_all_rdeps(struct lxc_container *c, bool inc)\n{\n\tstruct lxc_container *p;\n\tchar *lxcpath = NULL, *lxcname = NULL, path[MAXPATHLEN];\n\tsize_t pathlen = 0, namelen = 0;\n\tFILE *f;\n\tint ret;\n\n\tret = snprintf(path, MAXPATHLEN, \"%s/%s/lxc_rdepends\",\n\t\tc->config_path, c->name);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tERROR(\"Path name too long\");\n\t\treturn;\n\t}\n\tf = fopen(path, \"r\");\n\tif (f == NULL)\n\t\treturn;\n\twhile (getline(&lxcpath, &pathlen, f) != -1) {\n\t\tif (getline(&lxcname, &namelen, f) == -1) {\n\t\t\tERROR(\"badly formatted file %s\", path);\n\t\t\tgoto out;\n\t\t}\n\t\tstrip_newline(lxcpath);\n\t\tstrip_newline(lxcname);\n\t\tif ((p = lxc_container_new(lxcname, lxcpath)) == NULL) {\n\t\t\tERROR(\"Unable to find dependent container %s:%s\",\n\t\t\t\tlxcpath, lxcname);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!mod_rdep(p, c, inc))\n\t\t\tERROR(\"Failed to update snapshots file for %s:%s\",\n\t\t\t\tlxcpath, lxcname);\n\t\tlxc_container_put(p);\n\t}\nout:\n\tfree(lxcpath);\n\tfree(lxcname);\n\tfclose(f);\n}"
  },
  {
    "function_name": "do_lxcapi_save_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "2040-2091",
    "snippet": "static bool do_lxcapi_save_config(struct lxc_container *c, const char *alt_file)\n{\n\tFILE *fout;\n\tbool ret = false, need_disklock = false;\n\tint lret;\n\n\tif (!alt_file)\n\t\talt_file = c->configfile;\n\tif (!alt_file)\n\t\treturn false; // should we write to stdout if no file is specified?\n\n\t// If we haven't yet loaded a config, load the stock config\n\tif (!c->lxc_conf) {\n\t\tif (!do_lxcapi_load_config(c, lxc_global_config_value(\"lxc.default_config\"))) {\n\t\t\tERROR(\"Error loading default configuration file %s while saving %s\", lxc_global_config_value(\"lxc.default_config\"), c->name);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (!create_container_dir(c))\n\t\treturn false;\n\n\t/*\n\t * If we're writing to the container's config file, take the\n\t * disk lock.  Otherwise just take the memlock to protect the\n\t * struct lxc_container while we're traversing it.\n\t */\n\tif (strcmp(c->configfile, alt_file) == 0)\n\t\tneed_disklock = true;\n\n\tif (need_disklock)\n\t\tlret = container_disk_lock(c);\n\telse\n\t\tlret = container_mem_lock(c);\n\n\tif (lret)\n\t\treturn false;\n\n\tfout = fopen(alt_file, \"w\");\n\tif (!fout)\n\t\tgoto out;\n\twrite_config(fout, c->lxc_conf);\n\tfclose(fout);\n\tret = true;\n\nout:\n\tif (need_disklock)\n\t\tcontainer_disk_unlock(c);\n\telse\n\t\tcontainer_mem_unlock(c);\n\treturn ret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);",
      "static bool do_lxcapi_save_config(struct lxc_container *c, const char *alt_file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_mem_unlock",
          "args": [
            "c"
          ],
          "line": 2089
        },
        "resolved": true,
        "details": {
          "function_name": "container_mem_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "347-350",
          "snippet": "void container_mem_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->privlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nvoid container_mem_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->privlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_disk_unlock",
          "args": [
            "c"
          ],
          "line": 2087
        },
        "resolved": true,
        "details": {
          "function_name": "container_disk_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "365-369",
          "snippet": "void container_disk_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->slock);\n\tlxcunlock(c->privlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nvoid container_disk_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->slock);\n\tlxcunlock(c->privlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fout"
          ],
          "line": 2082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_config",
          "args": [
            "fout",
            "c->lxc_conf"
          ],
          "line": 2081
        },
        "resolved": true,
        "details": {
          "function_name": "write_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/confile.c",
          "lines": "2720-2730",
          "snippet": "void write_config(FILE *fout, struct lxc_conf *c)\n{\n\tsize_t len = c->unexpanded_len;\n\tint ret;\n\n\tif (!len)\n\t\treturn;\n\tret = fwrite(c->unexpanded_config, 1, len, fout);\n\tif (ret != len)\n\t\tSYSERROR(\"Error writing configuration file\");\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"network.h\"",
            "#include \"conf.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"confile.h\"",
            "#include \"config.h\"",
            "#include \"parse.h\"",
            "#include \"bdev.h\"",
            "#include <syslog.h>",
            "#include <dirent.h>",
            "#include <time.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int config_personality(const char *, const char *, struct lxc_conf *);",
            "static int config_pts(const char *, const char *, struct lxc_conf *);",
            "static int config_tty(const char *, const char *, struct lxc_conf *);",
            "static int config_ttydir(const char *, const char *, struct lxc_conf *);",
            "static int config_kmsg(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_aa_profile(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_aa_incomplete(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_se_context(const char *, const char *, struct lxc_conf *);",
            "static int config_cgroup(const char *, const char *, struct lxc_conf *);",
            "static int config_idmap(const char *, const char *, struct lxc_conf *);",
            "static int config_loglevel(const char *, const char *, struct lxc_conf *);",
            "static int config_logfile(const char *, const char *, struct lxc_conf *);",
            "static int config_mount(const char *, const char *, struct lxc_conf *);",
            "static int config_mount_auto(const char *, const char *, struct lxc_conf *);",
            "static int config_fstab(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_mount(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_options(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_backend(const char *, const char *, struct lxc_conf *);",
            "static int config_pivotdir(const char *, const char *, struct lxc_conf *);",
            "static int config_utsname(const char *, const char *, struct lxc_conf *);",
            "static int config_hook(const char *, const char *, struct lxc_conf *lxc_conf);",
            "static int config_network(const char *, const char *, struct lxc_conf *);",
            "static int config_network_type(const char *, const char *, struct lxc_conf *);",
            "static int config_network_flags(const char *, const char *, struct lxc_conf *);",
            "static int config_network_link(const char *, const char *, struct lxc_conf *);",
            "static int config_network_name(const char *, const char *, struct lxc_conf *);",
            "static int config_network_veth_pair(const char *, const char *, struct lxc_conf *);",
            "static int config_network_macvlan_mode(const char *, const char *, struct lxc_conf *);",
            "static int config_network_hwaddr(const char *, const char *, struct lxc_conf *);",
            "static int config_network_vlan_id(const char *, const char *, struct lxc_conf *);",
            "static int config_network_mtu(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv4(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv4_gateway(const char *, const char *, struct lxc_conf *);",
            "static int config_network_script_up(const char *, const char *, struct lxc_conf *);",
            "static int config_network_script_down(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv6(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv6_gateway(const char *, const char *, struct lxc_conf *);",
            "static int config_cap_drop(const char *, const char *, struct lxc_conf *);",
            "static int config_cap_keep(const char *, const char *, struct lxc_conf *);",
            "static int config_console(const char *, const char *, struct lxc_conf *);",
            "static int config_console_logfile(const char *, const char *, struct lxc_conf *);",
            "static int config_seccomp(const char *, const char *, struct lxc_conf *);",
            "static int config_includefile(const char *, const char *, struct lxc_conf *);",
            "static int config_network_nic(const char *, const char *, struct lxc_conf *);",
            "static int config_autodev(const char *, const char *, struct lxc_conf *);",
            "static int config_haltsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_rebootsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_stopsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_start(const char *, const char *, struct lxc_conf *);",
            "static int config_syslog(const char *, const char *, struct lxc_conf *);",
            "static int config_monitor(const char *, const char *, struct lxc_conf *);",
            "static int config_group(const char *, const char *, struct lxc_conf *);",
            "static int config_environment(const char *, const char *, struct lxc_conf *);",
            "static int config_init_cmd(const char *, const char *, struct lxc_conf *);",
            "static int config_init_uid(const char *, const char *, struct lxc_conf *);",
            "static int config_init_gid(const char *, const char *, struct lxc_conf *);",
            "static int config_ephemeral(const char *, const char *, struct lxc_conf *);",
            "static int config_no_new_privs(const char *, const char *, struct lxc_conf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"lxcseccomp.h\"\n#include \"network.h\"\n#include \"conf.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"confile.h\"\n#include \"config.h\"\n#include \"parse.h\"\n#include \"bdev.h\"\n#include <syslog.h>\n#include <dirent.h>\n#include <time.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int config_personality(const char *, const char *, struct lxc_conf *);\nstatic int config_pts(const char *, const char *, struct lxc_conf *);\nstatic int config_tty(const char *, const char *, struct lxc_conf *);\nstatic int config_ttydir(const char *, const char *, struct lxc_conf *);\nstatic int config_kmsg(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_aa_profile(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_aa_incomplete(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_se_context(const char *, const char *, struct lxc_conf *);\nstatic int config_cgroup(const char *, const char *, struct lxc_conf *);\nstatic int config_idmap(const char *, const char *, struct lxc_conf *);\nstatic int config_loglevel(const char *, const char *, struct lxc_conf *);\nstatic int config_logfile(const char *, const char *, struct lxc_conf *);\nstatic int config_mount(const char *, const char *, struct lxc_conf *);\nstatic int config_mount_auto(const char *, const char *, struct lxc_conf *);\nstatic int config_fstab(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_mount(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_options(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_backend(const char *, const char *, struct lxc_conf *);\nstatic int config_pivotdir(const char *, const char *, struct lxc_conf *);\nstatic int config_utsname(const char *, const char *, struct lxc_conf *);\nstatic int config_hook(const char *, const char *, struct lxc_conf *lxc_conf);\nstatic int config_network(const char *, const char *, struct lxc_conf *);\nstatic int config_network_type(const char *, const char *, struct lxc_conf *);\nstatic int config_network_flags(const char *, const char *, struct lxc_conf *);\nstatic int config_network_link(const char *, const char *, struct lxc_conf *);\nstatic int config_network_name(const char *, const char *, struct lxc_conf *);\nstatic int config_network_veth_pair(const char *, const char *, struct lxc_conf *);\nstatic int config_network_macvlan_mode(const char *, const char *, struct lxc_conf *);\nstatic int config_network_hwaddr(const char *, const char *, struct lxc_conf *);\nstatic int config_network_vlan_id(const char *, const char *, struct lxc_conf *);\nstatic int config_network_mtu(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv4(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv4_gateway(const char *, const char *, struct lxc_conf *);\nstatic int config_network_script_up(const char *, const char *, struct lxc_conf *);\nstatic int config_network_script_down(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv6(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv6_gateway(const char *, const char *, struct lxc_conf *);\nstatic int config_cap_drop(const char *, const char *, struct lxc_conf *);\nstatic int config_cap_keep(const char *, const char *, struct lxc_conf *);\nstatic int config_console(const char *, const char *, struct lxc_conf *);\nstatic int config_console_logfile(const char *, const char *, struct lxc_conf *);\nstatic int config_seccomp(const char *, const char *, struct lxc_conf *);\nstatic int config_includefile(const char *, const char *, struct lxc_conf *);\nstatic int config_network_nic(const char *, const char *, struct lxc_conf *);\nstatic int config_autodev(const char *, const char *, struct lxc_conf *);\nstatic int config_haltsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_rebootsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_stopsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_start(const char *, const char *, struct lxc_conf *);\nstatic int config_syslog(const char *, const char *, struct lxc_conf *);\nstatic int config_monitor(const char *, const char *, struct lxc_conf *);\nstatic int config_group(const char *, const char *, struct lxc_conf *);\nstatic int config_environment(const char *, const char *, struct lxc_conf *);\nstatic int config_init_cmd(const char *, const char *, struct lxc_conf *);\nstatic int config_init_uid(const char *, const char *, struct lxc_conf *);\nstatic int config_init_gid(const char *, const char *, struct lxc_conf *);\nstatic int config_ephemeral(const char *, const char *, struct lxc_conf *);\nstatic int config_no_new_privs(const char *, const char *, struct lxc_conf *);\n\nvoid write_config(FILE *fout, struct lxc_conf *c)\n{\n\tsize_t len = c->unexpanded_len;\n\tint ret;\n\n\tif (!len)\n\t\treturn;\n\tret = fwrite(c->unexpanded_config, 1, len, fout);\n\tif (ret != len)\n\t\tSYSERROR(\"Error writing configuration file\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "alt_file",
            "\"w\""
          ],
          "line": 2078
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_mem_lock",
          "args": [
            "c"
          ],
          "line": 2073
        },
        "resolved": true,
        "details": {
          "function_name": "container_mem_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "342-345",
          "snippet": "int container_mem_lock(struct lxc_container *c)\n{\n\treturn lxclock(c->privlock, 0);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nint container_mem_lock(struct lxc_container *c)\n{\n\treturn lxclock(c->privlock, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_disk_lock",
          "args": [
            "c"
          ],
          "line": 2071
        },
        "resolved": true,
        "details": {
          "function_name": "container_disk_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "352-363",
          "snippet": "int container_disk_lock(struct lxc_container *c)\n{\n\tint ret;\n\n\tif ((ret = lxclock(c->privlock, 0)))\n\t\treturn ret;\n\tif ((ret = lxclock(c->slock, 0))) {\n\t\tlxcunlock(c->privlock);\n\t\treturn ret;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nint container_disk_lock(struct lxc_container *c)\n{\n\tint ret;\n\n\tif ((ret = lxclock(c->privlock, 0)))\n\t\treturn ret;\n\tif ((ret = lxclock(c->slock, 0))) {\n\t\tlxcunlock(c->privlock);\n\t\treturn ret;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "c->configfile",
            "alt_file"
          ],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_container_dir",
          "args": [
            "c"
          ],
          "line": 2059
        },
        "resolved": true,
        "details": {
          "function_name": "create_container_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "994-1011",
          "snippet": "static bool create_container_dir(struct lxc_container *c)\n{\n\tchar *s;\n\tint len, ret;\n\n\tlen = strlen(c->config_path) + strlen(c->name) + 2;\n\ts = malloc(len);\n\tif (!s)\n\t\treturn false;\n\tret = snprintf(s, len, \"%s/%s\", c->config_path, c->name);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(s);\n\t\treturn false;\n\t}\n\tret = do_create_container_dir(s, c->lxc_conf);\n\tfree(s);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool create_container_dir(struct lxc_container *c)\n{\n\tchar *s;\n\tint len, ret;\n\n\tlen = strlen(c->config_path) + strlen(c->name) + 2;\n\ts = malloc(len);\n\tif (!s)\n\t\treturn false;\n\tret = snprintf(s, len, \"%s/%s\", c->config_path, c->name);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(s);\n\t\treturn false;\n\t}\n\tret = do_create_container_dir(s, c->lxc_conf);\n\tfree(s);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error loading default configuration file %s while saving %s\"",
            "lxc_global_config_value(\"lxc.default_config\")",
            "c->name"
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_global_config_value",
          "args": [
            "\"lxc.default_config\""
          ],
          "line": 2054
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_global_config_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "88-247",
          "snippet": "const char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nconst char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_lxcapi_load_config",
          "args": [
            "c",
            "lxc_global_config_value(\"lxc.default_config\")"
          ],
          "line": 2053
        },
        "resolved": true,
        "details": {
          "function_name": "do_lxcapi_load_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "532-567",
          "snippet": "static bool do_lxcapi_load_config(struct lxc_container *c, const char *alt_file)\n{\n\tbool ret = false, need_disklock = false;\n\tint lret;\n\tconst char *fname;\n\tif (!c)\n\t\treturn false;\n\n\tfname = c->configfile;\n\tif (alt_file)\n\t\tfname = alt_file;\n\tif (!fname)\n\t\treturn false;\n\t/*\n\t * If we're reading something other than the container's config,\n\t * we only need to lock the in-memory container.  If loading the\n\t * container's config file, take the disk lock.\n\t */\n\tif (strcmp(fname, c->configfile) == 0)\n\t\tneed_disklock = true;\n\n\tif (need_disklock)\n\t\tlret = container_disk_lock(c);\n\telse\n\t\tlret = container_mem_lock(c);\n\tif (lret)\n\t\treturn false;\n\n\tret = load_config_locked(c, fname);\n\n\tif (need_disklock)\n\t\tcontainer_disk_unlock(c);\n\telse\n\t\tcontainer_mem_unlock(c);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);",
            "static bool do_lxcapi_save_config(struct lxc_container *c, const char *alt_file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\nstatic bool do_lxcapi_save_config(struct lxc_container *c, const char *alt_file);\n\nstatic bool do_lxcapi_load_config(struct lxc_container *c, const char *alt_file)\n{\n\tbool ret = false, need_disklock = false;\n\tint lret;\n\tconst char *fname;\n\tif (!c)\n\t\treturn false;\n\n\tfname = c->configfile;\n\tif (alt_file)\n\t\tfname = alt_file;\n\tif (!fname)\n\t\treturn false;\n\t/*\n\t * If we're reading something other than the container's config,\n\t * we only need to lock the in-memory container.  If loading the\n\t * container's config file, take the disk lock.\n\t */\n\tif (strcmp(fname, c->configfile) == 0)\n\t\tneed_disklock = true;\n\n\tif (need_disklock)\n\t\tlret = container_disk_lock(c);\n\telse\n\t\tlret = container_mem_lock(c);\n\tif (lret)\n\t\treturn false;\n\n\tret = load_config_locked(c, fname);\n\n\tif (need_disklock)\n\t\tcontainer_disk_unlock(c);\n\telse\n\t\tcontainer_mem_unlock(c);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\nstatic bool do_lxcapi_save_config(struct lxc_container *c, const char *alt_file);\n\nstatic bool do_lxcapi_save_config(struct lxc_container *c, const char *alt_file)\n{\n\tFILE *fout;\n\tbool ret = false, need_disklock = false;\n\tint lret;\n\n\tif (!alt_file)\n\t\talt_file = c->configfile;\n\tif (!alt_file)\n\t\treturn false; // should we write to stdout if no file is specified?\n\n\t// If we haven't yet loaded a config, load the stock config\n\tif (!c->lxc_conf) {\n\t\tif (!do_lxcapi_load_config(c, lxc_global_config_value(\"lxc.default_config\"))) {\n\t\t\tERROR(\"Error loading default configuration file %s while saving %s\", lxc_global_config_value(\"lxc.default_config\"), c->name);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (!create_container_dir(c))\n\t\treturn false;\n\n\t/*\n\t * If we're writing to the container's config file, take the\n\t * disk lock.  Otherwise just take the memlock to protect the\n\t * struct lxc_container while we're traversing it.\n\t */\n\tif (strcmp(c->configfile, alt_file) == 0)\n\t\tneed_disklock = true;\n\n\tif (need_disklock)\n\t\tlret = container_disk_lock(c);\n\telse\n\t\tlret = container_mem_lock(c);\n\n\tif (lret)\n\t\treturn false;\n\n\tfout = fopen(alt_file, \"w\");\n\tif (!fout)\n\t\tgoto out;\n\twrite_config(fout, c->lxc_conf);\n\tfclose(fout);\n\tret = true;\n\nout:\n\tif (need_disklock)\n\t\tcontainer_disk_unlock(c);\n\telse\n\t\tcontainer_mem_unlock(c);\n\treturn ret;\n}"
  },
  {
    "function_name": "do_lxcapi_get_keys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "2016-2036",
    "snippet": "WRAP_API_1(char *, lxcapi_get_running_config_item, const char *)\n\nstatic int do_lxcapi_get_keys(struct lxc_container *c, const char *key, char *retv, int inlen)\n{\n\tif (!key)\n\t\treturn lxc_listconfigs(retv, inlen);\n\t/*\n\t * Support 'lxc.network.<idx>', i.e. 'lxc.network.0'\n\t * This is an intelligent result to show which keys are valid given\n\t * the type of nic it is\n\t */\n\tif (!c || !c->lxc_conf)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tint ret = -1;\n\tif (strncmp(key, \"lxc.network.\", 12) == 0)\n\t\tret = lxc_list_nicconfigs(c->lxc_conf, key, retv, inlen);\n\tcontainer_mem_unlock(c);\n\treturn ret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_mem_unlock",
          "args": [
            "c"
          ],
          "line": 2034
        },
        "resolved": true,
        "details": {
          "function_name": "container_mem_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "347-350",
          "snippet": "void container_mem_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->privlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nvoid container_mem_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->privlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_nicconfigs",
          "args": [
            "c->lxc_conf",
            "key",
            "retv",
            "inlen"
          ],
          "line": 2033
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_nicconfigs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/confile.c",
          "lines": "520-563",
          "snippet": "extern int lxc_list_nicconfigs(struct lxc_conf *c, const char *key,\n\t\t\t       char *retv, int inlen)\n{\n\tstruct lxc_netdev *netdev;\n\tint fulllen = 0, len;\n\n\tnetdev = get_netdev_from_key(key+12, &c->network);\n\tif (!netdev)\n\t\treturn -1;\n\n\tif (!retv)\n\t\tinlen = 0;\n\telse\n\t\tmemset(retv, 0, inlen);\n\n\tstrprint(retv, inlen, \"type\\n\");\n\tstrprint(retv, inlen, \"script.up\\n\");\n\tstrprint(retv, inlen, \"script.down\\n\");\n\tif (netdev->type != LXC_NET_EMPTY) {\n\t\tstrprint(retv, inlen, \"flags\\n\");\n\t\tstrprint(retv, inlen, \"link\\n\");\n\t\tstrprint(retv, inlen, \"name\\n\");\n\t\tstrprint(retv, inlen, \"hwaddr\\n\");\n\t\tstrprint(retv, inlen, \"mtu\\n\");\n\t\tstrprint(retv, inlen, \"ipv6\\n\");\n\t\tstrprint(retv, inlen, \"ipv6.gateway\\n\");\n\t\tstrprint(retv, inlen, \"ipv4\\n\");\n\t\tstrprint(retv, inlen, \"ipv4.gateway\\n\");\n\t}\n\tswitch(netdev->type) {\n\tcase LXC_NET_VETH:\n\t\tstrprint(retv, inlen, \"veth.pair\\n\");\n\t\tbreak;\n\tcase LXC_NET_MACVLAN:\n\t\tstrprint(retv, inlen, \"macvlan.mode\\n\");\n\t\tbreak;\n\tcase LXC_NET_VLAN:\n\t\tstrprint(retv, inlen, \"vlan.id\\n\");\n\t\tbreak;\n\tcase LXC_NET_PHYS:\n\t\tbreak;\n\t}\n\treturn fulllen;\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"network.h\"",
            "#include \"conf.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"confile.h\"",
            "#include \"config.h\"",
            "#include \"parse.h\"",
            "#include \"bdev.h\"",
            "#include <syslog.h>",
            "#include <dirent.h>",
            "#include <time.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int config_personality(const char *, const char *, struct lxc_conf *);",
            "static int config_pts(const char *, const char *, struct lxc_conf *);",
            "static int config_tty(const char *, const char *, struct lxc_conf *);",
            "static int config_ttydir(const char *, const char *, struct lxc_conf *);",
            "static int config_kmsg(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_aa_profile(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_aa_incomplete(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_se_context(const char *, const char *, struct lxc_conf *);",
            "static int config_cgroup(const char *, const char *, struct lxc_conf *);",
            "static int config_idmap(const char *, const char *, struct lxc_conf *);",
            "static int config_loglevel(const char *, const char *, struct lxc_conf *);",
            "static int config_logfile(const char *, const char *, struct lxc_conf *);",
            "static int config_mount(const char *, const char *, struct lxc_conf *);",
            "static int config_mount_auto(const char *, const char *, struct lxc_conf *);",
            "static int config_fstab(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_mount(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_options(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_backend(const char *, const char *, struct lxc_conf *);",
            "static int config_pivotdir(const char *, const char *, struct lxc_conf *);",
            "static int config_utsname(const char *, const char *, struct lxc_conf *);",
            "static int config_hook(const char *, const char *, struct lxc_conf *lxc_conf);",
            "static int config_network(const char *, const char *, struct lxc_conf *);",
            "static int config_network_type(const char *, const char *, struct lxc_conf *);",
            "static int config_network_flags(const char *, const char *, struct lxc_conf *);",
            "static int config_network_link(const char *, const char *, struct lxc_conf *);",
            "static int config_network_name(const char *, const char *, struct lxc_conf *);",
            "static int config_network_veth_pair(const char *, const char *, struct lxc_conf *);",
            "static int config_network_macvlan_mode(const char *, const char *, struct lxc_conf *);",
            "static int config_network_hwaddr(const char *, const char *, struct lxc_conf *);",
            "static int config_network_vlan_id(const char *, const char *, struct lxc_conf *);",
            "static int config_network_mtu(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv4(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv4_gateway(const char *, const char *, struct lxc_conf *);",
            "static int config_network_script_up(const char *, const char *, struct lxc_conf *);",
            "static int config_network_script_down(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv6(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv6_gateway(const char *, const char *, struct lxc_conf *);",
            "static int config_cap_drop(const char *, const char *, struct lxc_conf *);",
            "static int config_cap_keep(const char *, const char *, struct lxc_conf *);",
            "static int config_console(const char *, const char *, struct lxc_conf *);",
            "static int config_console_logfile(const char *, const char *, struct lxc_conf *);",
            "static int config_seccomp(const char *, const char *, struct lxc_conf *);",
            "static int config_includefile(const char *, const char *, struct lxc_conf *);",
            "static int config_network_nic(const char *, const char *, struct lxc_conf *);",
            "static int config_autodev(const char *, const char *, struct lxc_conf *);",
            "static int config_haltsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_rebootsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_stopsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_start(const char *, const char *, struct lxc_conf *);",
            "static int config_syslog(const char *, const char *, struct lxc_conf *);",
            "static int config_monitor(const char *, const char *, struct lxc_conf *);",
            "static int config_group(const char *, const char *, struct lxc_conf *);",
            "static int config_environment(const char *, const char *, struct lxc_conf *);",
            "static int config_init_cmd(const char *, const char *, struct lxc_conf *);",
            "static int config_init_uid(const char *, const char *, struct lxc_conf *);",
            "static int config_init_gid(const char *, const char *, struct lxc_conf *);",
            "static int config_ephemeral(const char *, const char *, struct lxc_conf *);",
            "static int config_no_new_privs(const char *, const char *, struct lxc_conf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"lxcseccomp.h\"\n#include \"network.h\"\n#include \"conf.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"confile.h\"\n#include \"config.h\"\n#include \"parse.h\"\n#include \"bdev.h\"\n#include <syslog.h>\n#include <dirent.h>\n#include <time.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int config_personality(const char *, const char *, struct lxc_conf *);\nstatic int config_pts(const char *, const char *, struct lxc_conf *);\nstatic int config_tty(const char *, const char *, struct lxc_conf *);\nstatic int config_ttydir(const char *, const char *, struct lxc_conf *);\nstatic int config_kmsg(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_aa_profile(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_aa_incomplete(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_se_context(const char *, const char *, struct lxc_conf *);\nstatic int config_cgroup(const char *, const char *, struct lxc_conf *);\nstatic int config_idmap(const char *, const char *, struct lxc_conf *);\nstatic int config_loglevel(const char *, const char *, struct lxc_conf *);\nstatic int config_logfile(const char *, const char *, struct lxc_conf *);\nstatic int config_mount(const char *, const char *, struct lxc_conf *);\nstatic int config_mount_auto(const char *, const char *, struct lxc_conf *);\nstatic int config_fstab(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_mount(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_options(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_backend(const char *, const char *, struct lxc_conf *);\nstatic int config_pivotdir(const char *, const char *, struct lxc_conf *);\nstatic int config_utsname(const char *, const char *, struct lxc_conf *);\nstatic int config_hook(const char *, const char *, struct lxc_conf *lxc_conf);\nstatic int config_network(const char *, const char *, struct lxc_conf *);\nstatic int config_network_type(const char *, const char *, struct lxc_conf *);\nstatic int config_network_flags(const char *, const char *, struct lxc_conf *);\nstatic int config_network_link(const char *, const char *, struct lxc_conf *);\nstatic int config_network_name(const char *, const char *, struct lxc_conf *);\nstatic int config_network_veth_pair(const char *, const char *, struct lxc_conf *);\nstatic int config_network_macvlan_mode(const char *, const char *, struct lxc_conf *);\nstatic int config_network_hwaddr(const char *, const char *, struct lxc_conf *);\nstatic int config_network_vlan_id(const char *, const char *, struct lxc_conf *);\nstatic int config_network_mtu(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv4(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv4_gateway(const char *, const char *, struct lxc_conf *);\nstatic int config_network_script_up(const char *, const char *, struct lxc_conf *);\nstatic int config_network_script_down(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv6(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv6_gateway(const char *, const char *, struct lxc_conf *);\nstatic int config_cap_drop(const char *, const char *, struct lxc_conf *);\nstatic int config_cap_keep(const char *, const char *, struct lxc_conf *);\nstatic int config_console(const char *, const char *, struct lxc_conf *);\nstatic int config_console_logfile(const char *, const char *, struct lxc_conf *);\nstatic int config_seccomp(const char *, const char *, struct lxc_conf *);\nstatic int config_includefile(const char *, const char *, struct lxc_conf *);\nstatic int config_network_nic(const char *, const char *, struct lxc_conf *);\nstatic int config_autodev(const char *, const char *, struct lxc_conf *);\nstatic int config_haltsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_rebootsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_stopsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_start(const char *, const char *, struct lxc_conf *);\nstatic int config_syslog(const char *, const char *, struct lxc_conf *);\nstatic int config_monitor(const char *, const char *, struct lxc_conf *);\nstatic int config_group(const char *, const char *, struct lxc_conf *);\nstatic int config_environment(const char *, const char *, struct lxc_conf *);\nstatic int config_init_cmd(const char *, const char *, struct lxc_conf *);\nstatic int config_init_uid(const char *, const char *, struct lxc_conf *);\nstatic int config_init_gid(const char *, const char *, struct lxc_conf *);\nstatic int config_ephemeral(const char *, const char *, struct lxc_conf *);\nstatic int config_no_new_privs(const char *, const char *, struct lxc_conf *);\n\nextern int lxc_list_nicconfigs(struct lxc_conf *c, const char *key,\n\t\t\t       char *retv, int inlen)\n{\n\tstruct lxc_netdev *netdev;\n\tint fulllen = 0, len;\n\n\tnetdev = get_netdev_from_key(key+12, &c->network);\n\tif (!netdev)\n\t\treturn -1;\n\n\tif (!retv)\n\t\tinlen = 0;\n\telse\n\t\tmemset(retv, 0, inlen);\n\n\tstrprint(retv, inlen, \"type\\n\");\n\tstrprint(retv, inlen, \"script.up\\n\");\n\tstrprint(retv, inlen, \"script.down\\n\");\n\tif (netdev->type != LXC_NET_EMPTY) {\n\t\tstrprint(retv, inlen, \"flags\\n\");\n\t\tstrprint(retv, inlen, \"link\\n\");\n\t\tstrprint(retv, inlen, \"name\\n\");\n\t\tstrprint(retv, inlen, \"hwaddr\\n\");\n\t\tstrprint(retv, inlen, \"mtu\\n\");\n\t\tstrprint(retv, inlen, \"ipv6\\n\");\n\t\tstrprint(retv, inlen, \"ipv6.gateway\\n\");\n\t\tstrprint(retv, inlen, \"ipv4\\n\");\n\t\tstrprint(retv, inlen, \"ipv4.gateway\\n\");\n\t}\n\tswitch(netdev->type) {\n\tcase LXC_NET_VETH:\n\t\tstrprint(retv, inlen, \"veth.pair\\n\");\n\t\tbreak;\n\tcase LXC_NET_MACVLAN:\n\t\tstrprint(retv, inlen, \"macvlan.mode\\n\");\n\t\tbreak;\n\tcase LXC_NET_VLAN:\n\t\tstrprint(retv, inlen, \"vlan.id\\n\");\n\t\tbreak;\n\tcase LXC_NET_PHYS:\n\t\tbreak;\n\t}\n\treturn fulllen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "key",
            "\"lxc.network.\"",
            "12"
          ],
          "line": 2032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_mem_lock",
          "args": [
            "c"
          ],
          "line": 2029
        },
        "resolved": true,
        "details": {
          "function_name": "container_mem_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "342-345",
          "snippet": "int container_mem_lock(struct lxc_container *c)\n{\n\treturn lxclock(c->privlock, 0);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nint container_mem_lock(struct lxc_container *c)\n{\n\treturn lxclock(c->privlock, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_listconfigs",
          "args": [
            "retv",
            "inlen"
          ],
          "line": 2021
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_listconfigs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/confile.c",
          "lines": "309-325",
          "snippet": "int lxc_listconfigs(char *retv, int inlen)\n{\n\tsize_t i;\n\tint fulllen = 0, len;\n\n\tif (!retv)\n\t\tinlen = 0;\n\telse\n\t\tmemset(retv, 0, inlen);\n\tfor (i = 0; i < config_size; i++) {\n\t\tchar *s = config[i].name;\n\t\tif (s[strlen(s)-1] == '.')\n\t\t\tcontinue;\n\t\tstrprint(retv, inlen, \"%s\\n\", s);\n\t}\n\treturn fulllen;\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"network.h\"",
            "#include \"conf.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"confile.h\"",
            "#include \"config.h\"",
            "#include \"parse.h\"",
            "#include \"bdev.h\"",
            "#include <syslog.h>",
            "#include <dirent.h>",
            "#include <time.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lxc_config_t config[] = {\n\n\t{ \"lxc.arch\",                 config_personality          },\n\t{ \"lxc.pts\",                  config_pts                  },\n\t{ \"lxc.tty\",                  config_tty                  },\n\t{ \"lxc.devttydir\",            config_ttydir               },\n\t{ \"lxc.kmsg\",                 config_kmsg                 },\n\t{ \"lxc.aa_profile\",           config_lsm_aa_profile       },\n\t{ \"lxc.aa_allow_incomplete\",  config_lsm_aa_incomplete    },\n\t{ \"lxc.se_context\",           config_lsm_se_context       },\n\t{ \"lxc.cgroup\",               config_cgroup               },\n\t{ \"lxc.id_map\",               config_idmap                },\n\t{ \"lxc.loglevel\",             config_loglevel             },\n\t{ \"lxc.logfile\",              config_logfile              },\n\t{ \"lxc.mount.entry\",          config_mount                },\n\t{ \"lxc.mount.auto\",           config_mount_auto           },\n\t{ \"lxc.mount\",                config_fstab                },\n\t{ \"lxc.rootfs.mount\",         config_rootfs_mount         },\n\t{ \"lxc.rootfs.options\",       config_rootfs_options       },\n\t{ \"lxc.rootfs.backend\",       config_rootfs_backend       },\n\t{ \"lxc.rootfs\",               config_rootfs               },\n\t{ \"lxc.pivotdir\",             config_pivotdir             },\n\t{ \"lxc.utsname\",              config_utsname              },\n\t{ \"lxc.hook.pre-start\",       config_hook                 },\n\t{ \"lxc.hook.pre-mount\",       config_hook                 },\n\t{ \"lxc.hook.mount\",           config_hook                 },\n\t{ \"lxc.hook.autodev\",         config_hook                 },\n\t{ \"lxc.hook.start\",           config_hook                 },\n\t{ \"lxc.hook.stop\",            config_hook                 },\n\t{ \"lxc.hook.post-stop\",       config_hook                 },\n\t{ \"lxc.hook.clone\",           config_hook                 },\n\t{ \"lxc.hook.destroy\",         config_hook                 },\n\t{ \"lxc.hook\",                 config_hook                 },\n\t{ \"lxc.network.type\",         config_network_type         },\n\t{ \"lxc.network.flags\",        config_network_flags        },\n\t{ \"lxc.network.link\",         config_network_link         },\n\t{ \"lxc.network.name\",         config_network_name         },\n\t{ \"lxc.network.macvlan.mode\", config_network_macvlan_mode },\n\t{ \"lxc.network.veth.pair\",    config_network_veth_pair    },\n\t{ \"lxc.network.script.up\",    config_network_script_up    },\n\t{ \"lxc.network.script.down\",  config_network_script_down  },\n\t{ \"lxc.network.hwaddr\",       config_network_hwaddr       },\n\t{ \"lxc.network.mtu\",          config_network_mtu          },\n\t{ \"lxc.network.vlan.id\",      config_network_vlan_id      },\n\t{ \"lxc.network.ipv4.gateway\", config_network_ipv4_gateway },\n\t{ \"lxc.network.ipv4\",         config_network_ipv4         },\n\t{ \"lxc.network.ipv6.gateway\", config_network_ipv6_gateway },\n\t{ \"lxc.network.ipv6\",         config_network_ipv6         },\n\t/* config_network_nic must come after all other 'lxc.network.*' entries */\n\t{ \"lxc.network.\",             config_network_nic          },\n\t{ \"lxc.network\",              config_network              },\n\t{ \"lxc.cap.drop\",             config_cap_drop             },\n\t{ \"lxc.cap.keep\",             config_cap_keep             },\n\t{ \"lxc.console.logfile\",      config_console_logfile      },\n\t{ \"lxc.console\",              config_console              },\n\t{ \"lxc.seccomp\",              config_seccomp              },\n\t{ \"lxc.include\",              config_includefile          },\n\t{ \"lxc.autodev\",              config_autodev              },\n\t{ \"lxc.haltsignal\",           config_haltsignal           },\n\t{ \"lxc.rebootsignal\",         config_rebootsignal         },\n\t{ \"lxc.stopsignal\",           config_stopsignal           },\n\t{ \"lxc.start.auto\",           config_start                },\n\t{ \"lxc.start.delay\",          config_start                },\n\t{ \"lxc.start.order\",          config_start                },\n\t{ \"lxc.monitor.unshare\",      config_monitor              },\n\t{ \"lxc.group\",                config_group                },\n\t{ \"lxc.environment\",          config_environment          },\n\t{ \"lxc.init_cmd\",             config_init_cmd             },\n\t{ \"lxc.init_uid\",             config_init_uid             },\n\t{ \"lxc.init_gid\",             config_init_gid             },\n\t{ \"lxc.ephemeral\",            config_ephemeral            },\n\t{ \"lxc.syslog\",               config_syslog               },\n\t{ \"lxc.no_new_privs\",\t      config_no_new_privs\t  },\n};",
            "static const size_t config_size = sizeof(config)/sizeof(struct lxc_config_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"lxcseccomp.h\"\n#include \"network.h\"\n#include \"conf.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"confile.h\"\n#include \"config.h\"\n#include \"parse.h\"\n#include \"bdev.h\"\n#include <syslog.h>\n#include <dirent.h>\n#include <time.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic struct lxc_config_t config[] = {\n\n\t{ \"lxc.arch\",                 config_personality          },\n\t{ \"lxc.pts\",                  config_pts                  },\n\t{ \"lxc.tty\",                  config_tty                  },\n\t{ \"lxc.devttydir\",            config_ttydir               },\n\t{ \"lxc.kmsg\",                 config_kmsg                 },\n\t{ \"lxc.aa_profile\",           config_lsm_aa_profile       },\n\t{ \"lxc.aa_allow_incomplete\",  config_lsm_aa_incomplete    },\n\t{ \"lxc.se_context\",           config_lsm_se_context       },\n\t{ \"lxc.cgroup\",               config_cgroup               },\n\t{ \"lxc.id_map\",               config_idmap                },\n\t{ \"lxc.loglevel\",             config_loglevel             },\n\t{ \"lxc.logfile\",              config_logfile              },\n\t{ \"lxc.mount.entry\",          config_mount                },\n\t{ \"lxc.mount.auto\",           config_mount_auto           },\n\t{ \"lxc.mount\",                config_fstab                },\n\t{ \"lxc.rootfs.mount\",         config_rootfs_mount         },\n\t{ \"lxc.rootfs.options\",       config_rootfs_options       },\n\t{ \"lxc.rootfs.backend\",       config_rootfs_backend       },\n\t{ \"lxc.rootfs\",               config_rootfs               },\n\t{ \"lxc.pivotdir\",             config_pivotdir             },\n\t{ \"lxc.utsname\",              config_utsname              },\n\t{ \"lxc.hook.pre-start\",       config_hook                 },\n\t{ \"lxc.hook.pre-mount\",       config_hook                 },\n\t{ \"lxc.hook.mount\",           config_hook                 },\n\t{ \"lxc.hook.autodev\",         config_hook                 },\n\t{ \"lxc.hook.start\",           config_hook                 },\n\t{ \"lxc.hook.stop\",            config_hook                 },\n\t{ \"lxc.hook.post-stop\",       config_hook                 },\n\t{ \"lxc.hook.clone\",           config_hook                 },\n\t{ \"lxc.hook.destroy\",         config_hook                 },\n\t{ \"lxc.hook\",                 config_hook                 },\n\t{ \"lxc.network.type\",         config_network_type         },\n\t{ \"lxc.network.flags\",        config_network_flags        },\n\t{ \"lxc.network.link\",         config_network_link         },\n\t{ \"lxc.network.name\",         config_network_name         },\n\t{ \"lxc.network.macvlan.mode\", config_network_macvlan_mode },\n\t{ \"lxc.network.veth.pair\",    config_network_veth_pair    },\n\t{ \"lxc.network.script.up\",    config_network_script_up    },\n\t{ \"lxc.network.script.down\",  config_network_script_down  },\n\t{ \"lxc.network.hwaddr\",       config_network_hwaddr       },\n\t{ \"lxc.network.mtu\",          config_network_mtu          },\n\t{ \"lxc.network.vlan.id\",      config_network_vlan_id      },\n\t{ \"lxc.network.ipv4.gateway\", config_network_ipv4_gateway },\n\t{ \"lxc.network.ipv4\",         config_network_ipv4         },\n\t{ \"lxc.network.ipv6.gateway\", config_network_ipv6_gateway },\n\t{ \"lxc.network.ipv6\",         config_network_ipv6         },\n\t/* config_network_nic must come after all other 'lxc.network.*' entries */\n\t{ \"lxc.network.\",             config_network_nic          },\n\t{ \"lxc.network\",              config_network              },\n\t{ \"lxc.cap.drop\",             config_cap_drop             },\n\t{ \"lxc.cap.keep\",             config_cap_keep             },\n\t{ \"lxc.console.logfile\",      config_console_logfile      },\n\t{ \"lxc.console\",              config_console              },\n\t{ \"lxc.seccomp\",              config_seccomp              },\n\t{ \"lxc.include\",              config_includefile          },\n\t{ \"lxc.autodev\",              config_autodev              },\n\t{ \"lxc.haltsignal\",           config_haltsignal           },\n\t{ \"lxc.rebootsignal\",         config_rebootsignal         },\n\t{ \"lxc.stopsignal\",           config_stopsignal           },\n\t{ \"lxc.start.auto\",           config_start                },\n\t{ \"lxc.start.delay\",          config_start                },\n\t{ \"lxc.start.order\",          config_start                },\n\t{ \"lxc.monitor.unshare\",      config_monitor              },\n\t{ \"lxc.group\",                config_group                },\n\t{ \"lxc.environment\",          config_environment          },\n\t{ \"lxc.init_cmd\",             config_init_cmd             },\n\t{ \"lxc.init_uid\",             config_init_uid             },\n\t{ \"lxc.init_gid\",             config_init_gid             },\n\t{ \"lxc.ephemeral\",            config_ephemeral            },\n\t{ \"lxc.syslog\",               config_syslog               },\n\t{ \"lxc.no_new_privs\",\t      config_no_new_privs\t  },\n};\nstatic const size_t config_size = sizeof(config)/sizeof(struct lxc_config_t);\n\nint lxc_listconfigs(char *retv, int inlen)\n{\n\tsize_t i;\n\tint fulllen = 0, len;\n\n\tif (!retv)\n\t\tinlen = 0;\n\telse\n\t\tmemset(retv, 0, inlen);\n\tfor (i = 0; i < config_size; i++) {\n\t\tchar *s = config[i].name;\n\t\tif (s[strlen(s)-1] == '.')\n\t\t\tcontinue;\n\t\tstrprint(retv, inlen, \"%s\\n\", s);\n\t}\n\treturn fulllen;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nWRAP_API_1(char *, lxcapi_get_running_config_item, const char *)\n\nstatic int do_lxcapi_get_keys(struct lxc_container *c, const char *key, char *retv, int inlen)\n{\n\tif (!key)\n\t\treturn lxc_listconfigs(retv, inlen);\n\t/*\n\t * Support 'lxc.network.<idx>', i.e. 'lxc.network.0'\n\t * This is an intelligent result to show which keys are valid given\n\t * the type of nic it is\n\t */\n\tif (!c || !c->lxc_conf)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tint ret = -1;\n\tif (strncmp(key, \"lxc.network.\", 12) == 0)\n\t\tret = lxc_list_nicconfigs(c->lxc_conf, key, retv, inlen);\n\tcontainer_mem_unlock(c);\n\treturn ret;\n}"
  },
  {
    "function_name": "do_lxcapi_get_running_config_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "2003-2014",
    "snippet": "static char* do_lxcapi_get_running_config_item(struct lxc_container *c, const char *key)\n{\n\tchar *ret;\n\n\tif (!c || !c->lxc_conf)\n\t\treturn NULL;\n\tif (container_mem_lock(c))\n\t\treturn NULL;\n\tret = lxc_cmd_get_config_item(c->name, key, do_lxcapi_get_config_path(c));\n\tcontainer_mem_unlock(c);\n\treturn ret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_mem_unlock",
          "args": [
            "c"
          ],
          "line": 2012
        },
        "resolved": true,
        "details": {
          "function_name": "container_mem_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "347-350",
          "snippet": "void container_mem_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->privlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nvoid container_mem_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->privlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cmd_get_config_item",
          "args": [
            "c->name",
            "key",
            "do_lxcapi_get_config_path(c)"
          ],
          "line": 2011
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_get_config_item_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "523-548",
          "snippet": "static int lxc_cmd_get_config_item_callback(int fd, struct lxc_cmd_req *req,\n\t\t\t\t\t    struct lxc_handler *handler)\n{\n\tint cilen;\n\tstruct lxc_cmd_rsp rsp;\n\tchar *cidata;\n\n\tmemset(&rsp, 0, sizeof(rsp));\n\tcilen = lxc_get_config_item(handler->conf, req->data, NULL, 0);\n\tif (cilen <= 0)\n\t\tgoto err1;\n\n\tcidata = alloca(cilen + 1);\n\tif (lxc_get_config_item(handler->conf, req->data, cidata, cilen + 1) != cilen)\n\t\tgoto err1;\n\tcidata[cilen] = '\\0';\n\trsp.data = cidata;\n\trsp.datalen = cilen + 1;\n\trsp.ret = 0;\n\tgoto out;\n\nerr1:\n\trsp.ret = -1;\nout:\n\treturn lxc_cmd_rsp_send(fd, &rsp);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd_get_config_item_callback(int fd, struct lxc_cmd_req *req,\n\t\t\t\t\t    struct lxc_handler *handler)\n{\n\tint cilen;\n\tstruct lxc_cmd_rsp rsp;\n\tchar *cidata;\n\n\tmemset(&rsp, 0, sizeof(rsp));\n\tcilen = lxc_get_config_item(handler->conf, req->data, NULL, 0);\n\tif (cilen <= 0)\n\t\tgoto err1;\n\n\tcidata = alloca(cilen + 1);\n\tif (lxc_get_config_item(handler->conf, req->data, cidata, cilen + 1) != cilen)\n\t\tgoto err1;\n\tcidata[cilen] = '\\0';\n\trsp.data = cidata;\n\trsp.datalen = cilen + 1;\n\trsp.ret = 0;\n\tgoto out;\n\nerr1:\n\trsp.ret = -1;\nout:\n\treturn lxc_cmd_rsp_send(fd, &rsp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_lxcapi_get_config_path",
          "args": [
            "c"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_mem_lock",
          "args": [
            "c"
          ],
          "line": 2009
        },
        "resolved": true,
        "details": {
          "function_name": "container_mem_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "342-345",
          "snippet": "int container_mem_lock(struct lxc_container *c)\n{\n\treturn lxclock(c->privlock, 0);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nint container_mem_lock(struct lxc_container *c)\n{\n\treturn lxclock(c->privlock, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic char* do_lxcapi_get_running_config_item(struct lxc_container *c, const char *key)\n{\n\tchar *ret;\n\n\tif (!c || !c->lxc_conf)\n\t\treturn NULL;\n\tif (container_mem_lock(c))\n\t\treturn NULL;\n\tret = lxc_cmd_get_config_item(c->name, key, do_lxcapi_get_config_path(c));\n\tcontainer_mem_unlock(c);\n\treturn ret;\n}"
  },
  {
    "function_name": "do_lxcapi_get_config_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "1986-1999",
    "snippet": "WRAP_API_3(char **, lxcapi_get_ips, const char *, const char *, int)\n\nstatic int do_lxcapi_get_config_item(struct lxc_container *c, const char *key, char *retv, int inlen)\n{\n\tint ret;\n\n\tif (!c || !c->lxc_conf)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tret = lxc_get_config_item(c->lxc_conf, key, retv, inlen);\n\tcontainer_mem_unlock(c);\n\treturn ret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_mem_unlock",
          "args": [
            "c"
          ],
          "line": 1997
        },
        "resolved": true,
        "details": {
          "function_name": "container_mem_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "347-350",
          "snippet": "void container_mem_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->privlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nvoid container_mem_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->privlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_get_config_item",
          "args": [
            "c->lxc_conf",
            "key",
            "retv",
            "inlen"
          ],
          "line": 1996
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_get_config_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/confile.c",
          "lines": "2598-2688",
          "snippet": "int lxc_get_config_item(struct lxc_conf *c, const char *key, char *retv,\n\t\t\tint inlen)\n{\n\tconst char *v = NULL;\n\n\tif (strcmp(key, \"lxc.mount.entry\") == 0)\n\t\treturn lxc_get_mount_entries(c, retv, inlen);\n\telse if (strcmp(key, \"lxc.mount.auto\") == 0)\n\t\treturn lxc_get_auto_mounts(c, retv, inlen);\n\telse if (strcmp(key, \"lxc.mount\") == 0)\n\t\tv = c->fstab;\n\telse if (strcmp(key, \"lxc.tty\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->tty);\n\telse if (strcmp(key, \"lxc.pts\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->pts);\n\telse if (strcmp(key, \"lxc.devttydir\") == 0)\n\t\tv = c->ttydir;\n\telse if (strcmp(key, \"lxc.arch\") == 0)\n\t\treturn lxc_get_arch_entry(c, retv, inlen);\n\telse if (strcmp(key, \"lxc.aa_profile\") == 0)\n\t\tv = c->lsm_aa_profile;\n\telse if (strcmp(key, \"lxc.aa_allow_incomplete\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->lsm_aa_allow_incomplete);\n\telse if (strcmp(key, \"lxc.se_context\") == 0)\n\t\tv = c->lsm_se_context;\n\telse if (strcmp(key, \"lxc.logfile\") == 0)\n\t\tv = c->logfile;\n\telse if (strcmp(key, \"lxc.loglevel\") == 0)\n\t\tv = lxc_log_priority_to_string(c->loglevel);\n\telse if (strcmp(key, \"lxc.cgroup\") == 0) // all cgroup info\n\t\treturn lxc_get_cgroup_entry(c, retv, inlen, \"all\");\n\telse if (strncmp(key, \"lxc.cgroup.\", 11) == 0) // specific cgroup info\n\t\treturn lxc_get_cgroup_entry(c, retv, inlen, key + 11);\n\telse if (strcmp(key, \"lxc.utsname\") == 0)\n\t\tv = c->utsname ? c->utsname->nodename : NULL;\n\telse if (strcmp(key, \"lxc.console.logfile\") == 0)\n\t\tv = c->console.log_path;\n\telse if (strcmp(key, \"lxc.console\") == 0)\n\t\tv = c->console.path;\n\telse if (strcmp(key, \"lxc.rootfs.mount\") == 0)\n\t\tv = c->rootfs.mount;\n\telse if (strcmp(key, \"lxc.rootfs.backend\") == 0)\n\t\tv = c->rootfs.bdev_type;\n\telse if (strcmp(key, \"lxc.rootfs.options\") == 0)\n\t\tv = c->rootfs.options;\n\telse if (strcmp(key, \"lxc.rootfs\") == 0)\n\t\tv = c->rootfs.path;\n\telse if (strcmp(key, \"lxc.cap.drop\") == 0)\n\t\treturn lxc_get_item_cap_drop(c, retv, inlen);\n\telse if (strcmp(key, \"lxc.cap.keep\") == 0)\n\t\treturn lxc_get_item_cap_keep(c, retv, inlen);\n\telse if (strncmp(key, \"lxc.hook\", 8) == 0)\n\t\treturn lxc_get_item_hooks(c, retv, inlen, key);\n\telse if (strcmp(key, \"lxc.network\") == 0)\n\t\treturn lxc_get_item_network(c, retv, inlen);\n\telse if (strncmp(key, \"lxc.network.\", 12) == 0)\n\t\treturn lxc_get_item_nic(c, retv, inlen, key + 12);\n\telse if (strcmp(key, \"lxc.start.auto\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->start_auto);\n\telse if (strcmp(key, \"lxc.start.delay\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->start_delay);\n\telse if (strcmp(key, \"lxc.start.order\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->start_order);\n\telse if (strcmp(key, \"lxc.monitor.unshare\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->monitor_unshare);\n\telse if (strcmp(key, \"lxc.group\") == 0)\n\t\treturn lxc_get_item_groups(c, retv, inlen);\n\telse if (strcmp(key, \"lxc.seccomp\") == 0)\n\t\tv = c->seccomp;\n\telse if (strcmp(key, \"lxc.environment\") == 0)\n\t\treturn lxc_get_item_environment(c, retv, inlen);\n\telse if (strcmp(key, \"lxc.init_cmd\") == 0)\n\t\tv = c->init_cmd;\n\telse if (strcmp(key, \"lxc.init_uid\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->init_uid);\n\telse if (strcmp(key, \"lxc.init_gid\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->init_gid);\n\telse if (strcmp(key, \"lxc.ephemeral\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->ephemeral);\n\telse if (strcmp(key, \"lxc.syslog\") == 0)\n\t\tv = c->syslog;\n\telse if (strcmp(key, \"lxc.no_new_privs\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->no_new_privs);\n\telse return -1;\n\n\tif (!v)\n\t\treturn 0;\n\tif (retv && inlen >= strlen(v) + 1)\n\t\tstrncpy(retv, v, strlen(v)+1);\n\treturn strlen(v);\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"network.h\"",
            "#include \"conf.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"confile.h\"",
            "#include \"config.h\"",
            "#include \"parse.h\"",
            "#include \"bdev.h\"",
            "#include <syslog.h>",
            "#include <dirent.h>",
            "#include <time.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int config_personality(const char *, const char *, struct lxc_conf *);",
            "static int config_pts(const char *, const char *, struct lxc_conf *);",
            "static int config_tty(const char *, const char *, struct lxc_conf *);",
            "static int config_ttydir(const char *, const char *, struct lxc_conf *);",
            "static int config_kmsg(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_aa_profile(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_aa_incomplete(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_se_context(const char *, const char *, struct lxc_conf *);",
            "static int config_cgroup(const char *, const char *, struct lxc_conf *);",
            "static int config_idmap(const char *, const char *, struct lxc_conf *);",
            "static int config_loglevel(const char *, const char *, struct lxc_conf *);",
            "static int config_logfile(const char *, const char *, struct lxc_conf *);",
            "static int config_mount(const char *, const char *, struct lxc_conf *);",
            "static int config_mount_auto(const char *, const char *, struct lxc_conf *);",
            "static int config_fstab(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_mount(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_options(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_backend(const char *, const char *, struct lxc_conf *);",
            "static int config_pivotdir(const char *, const char *, struct lxc_conf *);",
            "static int config_utsname(const char *, const char *, struct lxc_conf *);",
            "static int config_hook(const char *, const char *, struct lxc_conf *lxc_conf);",
            "static int config_network(const char *, const char *, struct lxc_conf *);",
            "static int config_network_type(const char *, const char *, struct lxc_conf *);",
            "static int config_network_flags(const char *, const char *, struct lxc_conf *);",
            "static int config_network_link(const char *, const char *, struct lxc_conf *);",
            "static int config_network_name(const char *, const char *, struct lxc_conf *);",
            "static int config_network_veth_pair(const char *, const char *, struct lxc_conf *);",
            "static int config_network_macvlan_mode(const char *, const char *, struct lxc_conf *);",
            "static int config_network_hwaddr(const char *, const char *, struct lxc_conf *);",
            "static int config_network_vlan_id(const char *, const char *, struct lxc_conf *);",
            "static int config_network_mtu(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv4(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv4_gateway(const char *, const char *, struct lxc_conf *);",
            "static int config_network_script_up(const char *, const char *, struct lxc_conf *);",
            "static int config_network_script_down(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv6(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv6_gateway(const char *, const char *, struct lxc_conf *);",
            "static int config_cap_drop(const char *, const char *, struct lxc_conf *);",
            "static int config_cap_keep(const char *, const char *, struct lxc_conf *);",
            "static int config_console(const char *, const char *, struct lxc_conf *);",
            "static int config_console_logfile(const char *, const char *, struct lxc_conf *);",
            "static int config_seccomp(const char *, const char *, struct lxc_conf *);",
            "static int config_includefile(const char *, const char *, struct lxc_conf *);",
            "static int config_network_nic(const char *, const char *, struct lxc_conf *);",
            "static int config_autodev(const char *, const char *, struct lxc_conf *);",
            "static int config_haltsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_rebootsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_stopsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_start(const char *, const char *, struct lxc_conf *);",
            "static int config_syslog(const char *, const char *, struct lxc_conf *);",
            "static int config_monitor(const char *, const char *, struct lxc_conf *);",
            "static int config_group(const char *, const char *, struct lxc_conf *);",
            "static int config_environment(const char *, const char *, struct lxc_conf *);",
            "static int config_init_cmd(const char *, const char *, struct lxc_conf *);",
            "static int config_init_uid(const char *, const char *, struct lxc_conf *);",
            "static int config_init_gid(const char *, const char *, struct lxc_conf *);",
            "static int config_ephemeral(const char *, const char *, struct lxc_conf *);",
            "static int config_no_new_privs(const char *, const char *, struct lxc_conf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"lxcseccomp.h\"\n#include \"network.h\"\n#include \"conf.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"confile.h\"\n#include \"config.h\"\n#include \"parse.h\"\n#include \"bdev.h\"\n#include <syslog.h>\n#include <dirent.h>\n#include <time.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int config_personality(const char *, const char *, struct lxc_conf *);\nstatic int config_pts(const char *, const char *, struct lxc_conf *);\nstatic int config_tty(const char *, const char *, struct lxc_conf *);\nstatic int config_ttydir(const char *, const char *, struct lxc_conf *);\nstatic int config_kmsg(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_aa_profile(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_aa_incomplete(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_se_context(const char *, const char *, struct lxc_conf *);\nstatic int config_cgroup(const char *, const char *, struct lxc_conf *);\nstatic int config_idmap(const char *, const char *, struct lxc_conf *);\nstatic int config_loglevel(const char *, const char *, struct lxc_conf *);\nstatic int config_logfile(const char *, const char *, struct lxc_conf *);\nstatic int config_mount(const char *, const char *, struct lxc_conf *);\nstatic int config_mount_auto(const char *, const char *, struct lxc_conf *);\nstatic int config_fstab(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_mount(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_options(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_backend(const char *, const char *, struct lxc_conf *);\nstatic int config_pivotdir(const char *, const char *, struct lxc_conf *);\nstatic int config_utsname(const char *, const char *, struct lxc_conf *);\nstatic int config_hook(const char *, const char *, struct lxc_conf *lxc_conf);\nstatic int config_network(const char *, const char *, struct lxc_conf *);\nstatic int config_network_type(const char *, const char *, struct lxc_conf *);\nstatic int config_network_flags(const char *, const char *, struct lxc_conf *);\nstatic int config_network_link(const char *, const char *, struct lxc_conf *);\nstatic int config_network_name(const char *, const char *, struct lxc_conf *);\nstatic int config_network_veth_pair(const char *, const char *, struct lxc_conf *);\nstatic int config_network_macvlan_mode(const char *, const char *, struct lxc_conf *);\nstatic int config_network_hwaddr(const char *, const char *, struct lxc_conf *);\nstatic int config_network_vlan_id(const char *, const char *, struct lxc_conf *);\nstatic int config_network_mtu(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv4(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv4_gateway(const char *, const char *, struct lxc_conf *);\nstatic int config_network_script_up(const char *, const char *, struct lxc_conf *);\nstatic int config_network_script_down(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv6(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv6_gateway(const char *, const char *, struct lxc_conf *);\nstatic int config_cap_drop(const char *, const char *, struct lxc_conf *);\nstatic int config_cap_keep(const char *, const char *, struct lxc_conf *);\nstatic int config_console(const char *, const char *, struct lxc_conf *);\nstatic int config_console_logfile(const char *, const char *, struct lxc_conf *);\nstatic int config_seccomp(const char *, const char *, struct lxc_conf *);\nstatic int config_includefile(const char *, const char *, struct lxc_conf *);\nstatic int config_network_nic(const char *, const char *, struct lxc_conf *);\nstatic int config_autodev(const char *, const char *, struct lxc_conf *);\nstatic int config_haltsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_rebootsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_stopsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_start(const char *, const char *, struct lxc_conf *);\nstatic int config_syslog(const char *, const char *, struct lxc_conf *);\nstatic int config_monitor(const char *, const char *, struct lxc_conf *);\nstatic int config_group(const char *, const char *, struct lxc_conf *);\nstatic int config_environment(const char *, const char *, struct lxc_conf *);\nstatic int config_init_cmd(const char *, const char *, struct lxc_conf *);\nstatic int config_init_uid(const char *, const char *, struct lxc_conf *);\nstatic int config_init_gid(const char *, const char *, struct lxc_conf *);\nstatic int config_ephemeral(const char *, const char *, struct lxc_conf *);\nstatic int config_no_new_privs(const char *, const char *, struct lxc_conf *);\n\nint lxc_get_config_item(struct lxc_conf *c, const char *key, char *retv,\n\t\t\tint inlen)\n{\n\tconst char *v = NULL;\n\n\tif (strcmp(key, \"lxc.mount.entry\") == 0)\n\t\treturn lxc_get_mount_entries(c, retv, inlen);\n\telse if (strcmp(key, \"lxc.mount.auto\") == 0)\n\t\treturn lxc_get_auto_mounts(c, retv, inlen);\n\telse if (strcmp(key, \"lxc.mount\") == 0)\n\t\tv = c->fstab;\n\telse if (strcmp(key, \"lxc.tty\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->tty);\n\telse if (strcmp(key, \"lxc.pts\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->pts);\n\telse if (strcmp(key, \"lxc.devttydir\") == 0)\n\t\tv = c->ttydir;\n\telse if (strcmp(key, \"lxc.arch\") == 0)\n\t\treturn lxc_get_arch_entry(c, retv, inlen);\n\telse if (strcmp(key, \"lxc.aa_profile\") == 0)\n\t\tv = c->lsm_aa_profile;\n\telse if (strcmp(key, \"lxc.aa_allow_incomplete\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->lsm_aa_allow_incomplete);\n\telse if (strcmp(key, \"lxc.se_context\") == 0)\n\t\tv = c->lsm_se_context;\n\telse if (strcmp(key, \"lxc.logfile\") == 0)\n\t\tv = c->logfile;\n\telse if (strcmp(key, \"lxc.loglevel\") == 0)\n\t\tv = lxc_log_priority_to_string(c->loglevel);\n\telse if (strcmp(key, \"lxc.cgroup\") == 0) // all cgroup info\n\t\treturn lxc_get_cgroup_entry(c, retv, inlen, \"all\");\n\telse if (strncmp(key, \"lxc.cgroup.\", 11) == 0) // specific cgroup info\n\t\treturn lxc_get_cgroup_entry(c, retv, inlen, key + 11);\n\telse if (strcmp(key, \"lxc.utsname\") == 0)\n\t\tv = c->utsname ? c->utsname->nodename : NULL;\n\telse if (strcmp(key, \"lxc.console.logfile\") == 0)\n\t\tv = c->console.log_path;\n\telse if (strcmp(key, \"lxc.console\") == 0)\n\t\tv = c->console.path;\n\telse if (strcmp(key, \"lxc.rootfs.mount\") == 0)\n\t\tv = c->rootfs.mount;\n\telse if (strcmp(key, \"lxc.rootfs.backend\") == 0)\n\t\tv = c->rootfs.bdev_type;\n\telse if (strcmp(key, \"lxc.rootfs.options\") == 0)\n\t\tv = c->rootfs.options;\n\telse if (strcmp(key, \"lxc.rootfs\") == 0)\n\t\tv = c->rootfs.path;\n\telse if (strcmp(key, \"lxc.cap.drop\") == 0)\n\t\treturn lxc_get_item_cap_drop(c, retv, inlen);\n\telse if (strcmp(key, \"lxc.cap.keep\") == 0)\n\t\treturn lxc_get_item_cap_keep(c, retv, inlen);\n\telse if (strncmp(key, \"lxc.hook\", 8) == 0)\n\t\treturn lxc_get_item_hooks(c, retv, inlen, key);\n\telse if (strcmp(key, \"lxc.network\") == 0)\n\t\treturn lxc_get_item_network(c, retv, inlen);\n\telse if (strncmp(key, \"lxc.network.\", 12) == 0)\n\t\treturn lxc_get_item_nic(c, retv, inlen, key + 12);\n\telse if (strcmp(key, \"lxc.start.auto\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->start_auto);\n\telse if (strcmp(key, \"lxc.start.delay\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->start_delay);\n\telse if (strcmp(key, \"lxc.start.order\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->start_order);\n\telse if (strcmp(key, \"lxc.monitor.unshare\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->monitor_unshare);\n\telse if (strcmp(key, \"lxc.group\") == 0)\n\t\treturn lxc_get_item_groups(c, retv, inlen);\n\telse if (strcmp(key, \"lxc.seccomp\") == 0)\n\t\tv = c->seccomp;\n\telse if (strcmp(key, \"lxc.environment\") == 0)\n\t\treturn lxc_get_item_environment(c, retv, inlen);\n\telse if (strcmp(key, \"lxc.init_cmd\") == 0)\n\t\tv = c->init_cmd;\n\telse if (strcmp(key, \"lxc.init_uid\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->init_uid);\n\telse if (strcmp(key, \"lxc.init_gid\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->init_gid);\n\telse if (strcmp(key, \"lxc.ephemeral\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->ephemeral);\n\telse if (strcmp(key, \"lxc.syslog\") == 0)\n\t\tv = c->syslog;\n\telse if (strcmp(key, \"lxc.no_new_privs\") == 0)\n\t\treturn lxc_get_conf_int(c, retv, inlen, c->no_new_privs);\n\telse return -1;\n\n\tif (!v)\n\t\treturn 0;\n\tif (retv && inlen >= strlen(v) + 1)\n\t\tstrncpy(retv, v, strlen(v)+1);\n\treturn strlen(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_mem_lock",
          "args": [
            "c"
          ],
          "line": 1994
        },
        "resolved": true,
        "details": {
          "function_name": "container_mem_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "342-345",
          "snippet": "int container_mem_lock(struct lxc_container *c)\n{\n\treturn lxclock(c->privlock, 0);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nint container_mem_lock(struct lxc_container *c)\n{\n\treturn lxclock(c->privlock, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nWRAP_API_3(char **, lxcapi_get_ips, const char *, const char *, int)\n\nstatic int do_lxcapi_get_config_item(struct lxc_container *c, const char *key, char *retv, int inlen)\n{\n\tint ret;\n\n\tif (!c || !c->lxc_conf)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tret = lxc_get_config_item(c->lxc_conf, key, retv, inlen);\n\tcontainer_mem_unlock(c);\n\treturn ret;\n}"
  },
  {
    "function_name": "do_lxcapi_get_ips",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "1867-1984",
    "snippet": "WRAP_API(char **, lxcapi_get_interfaces)\n\nstatic char** do_lxcapi_get_ips(struct lxc_container *c, const char* interface, const char* family, int scope)\n{\n\tpid_t pid;\n\tint i, count = 0, pipefd[2];\n\tchar **addresses = NULL;\n\tchar address[INET6_ADDRSTRLEN];\n\n\tif(pipe(pipefd) < 0) {\n\t\tSYSERROR(\"pipe failed\");\n\t\treturn NULL;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"failed to fork task to get container ips\");\n\t\tclose(pipefd[0]);\n\t\tclose(pipefd[1]);\n\t\treturn NULL;\n\t}\n\n\tif (pid == 0) { // child\n\t\tint ret = 1, nbytes;\n\t\tstruct ifaddrs *interfaceArray = NULL, *tempIfAddr = NULL;\n\t\tchar addressOutputBuffer[INET6_ADDRSTRLEN];\n\t\tvoid *tempAddrPtr = NULL;\n\t\tchar *address = NULL;\n\n\t\t/* close the read-end of the pipe */\n\t\tclose(pipefd[0]);\n\n\t\tif (!enter_net_ns(c)) {\n\t\t\tSYSERROR(\"failed to enter namespace\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Grab the list of interfaces */\n\t\tif (getifaddrs(&interfaceArray)) {\n\t\t\tSYSERROR(\"failed to get interfaces list\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Iterate through the interfaces */\n\t\tfor (tempIfAddr = interfaceArray; tempIfAddr != NULL; tempIfAddr = tempIfAddr->ifa_next) {\n\t\t\tif (tempIfAddr->ifa_addr == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tif(tempIfAddr->ifa_addr->sa_family == AF_INET) {\n\t\t\t\tif (family && strcmp(family, \"inet\"))\n\t\t\t\t\tcontinue;\n\t\t\t\ttempAddrPtr = &((struct sockaddr_in *)tempIfAddr->ifa_addr)->sin_addr;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (family && strcmp(family, \"inet6\"))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (((struct sockaddr_in6 *)tempIfAddr->ifa_addr)->sin6_scope_id != scope)\n\t\t\t\t\tcontinue;\n\n\t\t\t\ttempAddrPtr = &((struct sockaddr_in6 *)tempIfAddr->ifa_addr)->sin6_addr;\n\t\t\t}\n\n\t\t\tif (interface && strcmp(interface, tempIfAddr->ifa_name))\n\t\t\t\tcontinue;\n\t\t\telse if (!interface && strcmp(\"lo\", tempIfAddr->ifa_name) == 0)\n\t\t\t\tcontinue;\n\n\t\t\taddress = (char *)inet_ntop(tempIfAddr->ifa_addr->sa_family,\n\t\t\t\t\t\ttempAddrPtr,\n\t\t\t\t\t\taddressOutputBuffer,\n\t\t\t\t\t\tsizeof(addressOutputBuffer));\n\t\t\tif (!address)\n\t\t\t\t\tcontinue;\n\n\t\t\tnbytes = write(pipefd[1], address, INET6_ADDRSTRLEN);\n\t\t\tif (nbytes < 0) {\n\t\t\t\tERROR(\"write failed\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\tret = 0;\n\n\tout:\n\t\tif(interfaceArray)\n\t\t\tfreeifaddrs(interfaceArray);\n\n\t\t/* close the write-end of the pipe, thus sending EOF to the reader */\n\t\tclose(pipefd[1]);\n\t\texit(ret);\n\t}\n\n\t/* close the write-end of the pipe */\n\tclose(pipefd[1]);\n\n\twhile (read(pipefd[0], &address, INET6_ADDRSTRLEN) == INET6_ADDRSTRLEN) {\n\t\tif(!add_to_array(&addresses, address, count))\n\t\t\tERROR(\"PARENT: add_to_array failed\");\n\t\tcount++;\n\t}\n\n\tif (wait_for_pid(pid) != 0) {\n\t\tfor(i=0;i<count;i++)\n\t\t\tfree(addresses[i]);\n\t\tfree(addresses);\n\t\taddresses = NULL;\n\t}\n\n\t/* close the read-end of the pipe */\n\tclose(pipefd[0]);\n\n\t/* Append NULL to the array */\n\tif(addresses)\n\t\taddresses = (char **)lxc_append_null_to_array((void **)addresses, count);\n\n\treturn addresses;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_append_null_to_array",
          "args": [
            "(void **)addresses",
            "count"
          ],
          "line": 1981
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_append_null_to_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "992-1010",
          "snippet": "void **lxc_append_null_to_array(void **array, size_t count)\n{\n\tvoid **temp;\n\n\t/* Append NULL to the array */\n\tif (count) {\n\t\ttemp = realloc(array, (count + 1) * sizeof(*array));\n\t\tif (!temp) {\n\t\t\tsize_t i;\n\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\tfree(array[i]);\n\t\t\tfree(array);\n\t\t\treturn NULL;\n\t\t}\n\t\tarray = temp;\n\t\tarray[count] = NULL;\n\t}\n\treturn array;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid **lxc_append_null_to_array(void **array, size_t count)\n{\n\tvoid **temp;\n\n\t/* Append NULL to the array */\n\tif (count) {\n\t\ttemp = realloc(array, (count + 1) * sizeof(*array));\n\t\tif (!temp) {\n\t\t\tsize_t i;\n\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\tfree(array[i]);\n\t\t\tfree(array);\n\t\t\treturn NULL;\n\t\t}\n\t\tarray = temp;\n\t\tarray[count] = NULL;\n\t}\n\treturn array;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "pipefd[0]"
          ],
          "line": 1977
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "addresses"
          ],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "free_init_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "706-715",
          "snippet": "static void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_pid",
          "args": [
            "pid"
          ],
          "line": 1969
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "311-325",
          "snippet": "int lxc_wait_for_pid_status(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\treturn status;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_wait_for_pid_status(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"PARENT: add_to_array failed\""
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_to_array",
          "args": [
            "&addresses",
            "address",
            "count"
          ],
          "line": 1964
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "1721-1738",
          "snippet": "static bool add_to_array(char ***names, char *cname, int pos)\n{\n\tchar **newnames = realloc(*names, (pos+1) * sizeof(char *));\n\tif (!newnames) {\n\t\tERROR(\"Out of memory\");\n\t\treturn false;\n\t}\n\n\t*names = newnames;\n\tnewnames[pos] = strdup(cname);\n\tif (!newnames[pos])\n\t\treturn false;\n\n\t// sort the arrray as we will use binary search on it\n\tqsort(newnames, pos + 1, sizeof(char *), (int (*)(const void *,const void *))string_cmp);\n\n\treturn true;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool add_to_array(char ***names, char *cname, int pos)\n{\n\tchar **newnames = realloc(*names, (pos+1) * sizeof(char *));\n\tif (!newnames) {\n\t\tERROR(\"Out of memory\");\n\t\treturn false;\n\t}\n\n\t*names = newnames;\n\tnewnames[pos] = strdup(cname);\n\tif (!newnames[pos])\n\t\treturn false;\n\n\t// sort the arrray as we will use binary search on it\n\tqsort(newnames, pos + 1, sizeof(char *), (int (*)(const void *,const void *))string_cmp);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "pipefd[0]",
            "&address",
            "INET6_ADDRSTRLEN"
          ],
          "line": 1963
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "962-990",
          "snippet": "int lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "ret"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeifaddrs",
          "args": [
            "interfaceArray"
          ],
          "line": 1953
        },
        "resolved": true,
        "details": {
          "function_name": "freeifaddrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
          "lines": "590-599",
          "snippet": "void freeifaddrs(struct ifaddrs *ifa)\n{\n    struct ifaddrs *l_cur;\n    while(ifa)\n    {\n        l_cur = ifa;\n        ifa = ifa->ifa_next;\n        free(l_cur);\n    }\n}",
          "includes": [
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"ifaddrs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nvoid freeifaddrs(struct ifaddrs *ifa)\n{\n    struct ifaddrs *l_cur;\n    while(ifa)\n    {\n        l_cur = ifa;\n        ifa = ifa->ifa_next;\n        free(l_cur);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"write failed\""
          ],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "pipefd[1]",
            "address",
            "INET6_ADDRSTRLEN"
          ],
          "line": 1942
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_nointr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "327-335",
          "snippet": "ssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inet_ntop",
          "args": [
            "tempIfAddr->ifa_addr->sa_family",
            "tempAddrPtr",
            "addressOutputBuffer",
            "sizeof(addressOutputBuffer)"
          ],
          "line": 1935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"lo\"",
            "tempIfAddr->ifa_name"
          ],
          "line": 1932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "interface",
            "tempIfAddr->ifa_name"
          ],
          "line": 1930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "family",
            "\"inet6\""
          ],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "family",
            "\"inet\""
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to get interfaces list\""
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getifaddrs",
          "args": [
            "&interfaceArray"
          ],
          "line": 1905
        },
        "resolved": true,
        "details": {
          "function_name": "getifaddrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
          "lines": "548-588",
          "snippet": "int getifaddrs(struct ifaddrs **ifap)\n{\n    if(!ifap)\n    {\n        return -1;\n    }\n    *ifap = NULL;\n\n    int l_socket = netlink_socket();\n    if(l_socket < 0)\n    {\n        return -1;\n    }\n\n    NetlinkList *l_linkResults = getResultList(l_socket, RTM_GETLINK);\n    if(!l_linkResults)\n    {\n        close(l_socket);\n        return -1;\n    }\n\n    NetlinkList *l_addrResults = getResultList(l_socket, RTM_GETADDR);\n    if(!l_addrResults)\n    {\n        close(l_socket);\n        freeResultList(l_linkResults);\n        return -1;\n    }\n\n    unsigned l_numLinks = countLinks(l_socket, l_linkResults) + countLinks(l_socket, l_addrResults);\n    struct ifaddrs *l_links[l_numLinks];\n    memset(l_links, 0, l_numLinks * sizeof(struct ifaddrs *));\n\n    interpret(l_socket, l_linkResults, l_links, ifap);\n    interpret(l_socket, l_addrResults, l_links, ifap);\n\n    freeResultList(l_linkResults);\n    freeResultList(l_addrResults);\n    close(l_socket);\n    return 0;\n}",
          "includes": [
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"ifaddrs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nint getifaddrs(struct ifaddrs **ifap)\n{\n    if(!ifap)\n    {\n        return -1;\n    }\n    *ifap = NULL;\n\n    int l_socket = netlink_socket();\n    if(l_socket < 0)\n    {\n        return -1;\n    }\n\n    NetlinkList *l_linkResults = getResultList(l_socket, RTM_GETLINK);\n    if(!l_linkResults)\n    {\n        close(l_socket);\n        return -1;\n    }\n\n    NetlinkList *l_addrResults = getResultList(l_socket, RTM_GETADDR);\n    if(!l_addrResults)\n    {\n        close(l_socket);\n        freeResultList(l_linkResults);\n        return -1;\n    }\n\n    unsigned l_numLinks = countLinks(l_socket, l_linkResults) + countLinks(l_socket, l_addrResults);\n    struct ifaddrs *l_links[l_numLinks];\n    memset(l_links, 0, l_numLinks * sizeof(struct ifaddrs *));\n\n    interpret(l_socket, l_linkResults, l_links, ifap);\n    interpret(l_socket, l_addrResults, l_links, ifap);\n\n    freeResultList(l_linkResults);\n    freeResultList(l_addrResults);\n    close(l_socket);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to enter namespace\""
          ],
          "line": 1900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enter_net_ns",
          "args": [
            "c"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to fork task to get container ips\""
          ],
          "line": 1883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 1881
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"pipe failed\""
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "pipefd"
          ],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nWRAP_API(char **, lxcapi_get_interfaces)\n\nstatic char** do_lxcapi_get_ips(struct lxc_container *c, const char* interface, const char* family, int scope)\n{\n\tpid_t pid;\n\tint i, count = 0, pipefd[2];\n\tchar **addresses = NULL;\n\tchar address[INET6_ADDRSTRLEN];\n\n\tif(pipe(pipefd) < 0) {\n\t\tSYSERROR(\"pipe failed\");\n\t\treturn NULL;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"failed to fork task to get container ips\");\n\t\tclose(pipefd[0]);\n\t\tclose(pipefd[1]);\n\t\treturn NULL;\n\t}\n\n\tif (pid == 0) { // child\n\t\tint ret = 1, nbytes;\n\t\tstruct ifaddrs *interfaceArray = NULL, *tempIfAddr = NULL;\n\t\tchar addressOutputBuffer[INET6_ADDRSTRLEN];\n\t\tvoid *tempAddrPtr = NULL;\n\t\tchar *address = NULL;\n\n\t\t/* close the read-end of the pipe */\n\t\tclose(pipefd[0]);\n\n\t\tif (!enter_net_ns(c)) {\n\t\t\tSYSERROR(\"failed to enter namespace\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Grab the list of interfaces */\n\t\tif (getifaddrs(&interfaceArray)) {\n\t\t\tSYSERROR(\"failed to get interfaces list\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Iterate through the interfaces */\n\t\tfor (tempIfAddr = interfaceArray; tempIfAddr != NULL; tempIfAddr = tempIfAddr->ifa_next) {\n\t\t\tif (tempIfAddr->ifa_addr == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tif(tempIfAddr->ifa_addr->sa_family == AF_INET) {\n\t\t\t\tif (family && strcmp(family, \"inet\"))\n\t\t\t\t\tcontinue;\n\t\t\t\ttempAddrPtr = &((struct sockaddr_in *)tempIfAddr->ifa_addr)->sin_addr;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (family && strcmp(family, \"inet6\"))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (((struct sockaddr_in6 *)tempIfAddr->ifa_addr)->sin6_scope_id != scope)\n\t\t\t\t\tcontinue;\n\n\t\t\t\ttempAddrPtr = &((struct sockaddr_in6 *)tempIfAddr->ifa_addr)->sin6_addr;\n\t\t\t}\n\n\t\t\tif (interface && strcmp(interface, tempIfAddr->ifa_name))\n\t\t\t\tcontinue;\n\t\t\telse if (!interface && strcmp(\"lo\", tempIfAddr->ifa_name) == 0)\n\t\t\t\tcontinue;\n\n\t\t\taddress = (char *)inet_ntop(tempIfAddr->ifa_addr->sa_family,\n\t\t\t\t\t\ttempAddrPtr,\n\t\t\t\t\t\taddressOutputBuffer,\n\t\t\t\t\t\tsizeof(addressOutputBuffer));\n\t\t\tif (!address)\n\t\t\t\t\tcontinue;\n\n\t\t\tnbytes = write(pipefd[1], address, INET6_ADDRSTRLEN);\n\t\t\tif (nbytes < 0) {\n\t\t\t\tERROR(\"write failed\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\tret = 0;\n\n\tout:\n\t\tif(interfaceArray)\n\t\t\tfreeifaddrs(interfaceArray);\n\n\t\t/* close the write-end of the pipe, thus sending EOF to the reader */\n\t\tclose(pipefd[1]);\n\t\texit(ret);\n\t}\n\n\t/* close the write-end of the pipe */\n\tclose(pipefd[1]);\n\n\twhile (read(pipefd[0], &address, INET6_ADDRSTRLEN) == INET6_ADDRSTRLEN) {\n\t\tif(!add_to_array(&addresses, address, count))\n\t\t\tERROR(\"PARENT: add_to_array failed\");\n\t\tcount++;\n\t}\n\n\tif (wait_for_pid(pid) != 0) {\n\t\tfor(i=0;i<count;i++)\n\t\t\tfree(addresses[i]);\n\t\tfree(addresses);\n\t\taddresses = NULL;\n\t}\n\n\t/* close the read-end of the pipe */\n\tclose(pipefd[0]);\n\n\t/* Append NULL to the array */\n\tif(addresses)\n\t\taddresses = (char **)lxc_append_null_to_array((void **)addresses, count);\n\n\treturn addresses;\n}"
  },
  {
    "function_name": "do_lxcapi_get_interfaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "1780-1865",
    "snippet": "static char ** do_lxcapi_get_interfaces(struct lxc_container *c)\n{\n\tpid_t pid;\n\tint i, count = 0, pipefd[2];\n\tchar **interfaces = NULL;\n\tchar interface[IFNAMSIZ];\n\n\tif(pipe(pipefd) < 0) {\n\t\tSYSERROR(\"pipe failed\");\n\t\treturn NULL;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"failed to fork task to get interfaces information\");\n\t\tclose(pipefd[0]);\n\t\tclose(pipefd[1]);\n\t\treturn NULL;\n\t}\n\n\tif (pid == 0) { // child\n\t\tint ret = 1, nbytes;\n\t\tstruct ifaddrs *interfaceArray = NULL, *tempIfAddr = NULL;\n\n\t\t/* close the read-end of the pipe */\n\t\tclose(pipefd[0]);\n\n\t\tif (!enter_net_ns(c)) {\n\t\t\tSYSERROR(\"failed to enter namespace\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Grab the list of interfaces */\n\t\tif (getifaddrs(&interfaceArray)) {\n\t\t\tSYSERROR(\"failed to get interfaces list\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Iterate through the interfaces */\n\t\tfor (tempIfAddr = interfaceArray; tempIfAddr != NULL; tempIfAddr = tempIfAddr->ifa_next) {\n\t\t\tnbytes = write(pipefd[1], tempIfAddr->ifa_name, IFNAMSIZ);\n\t\t\tif (nbytes < 0) {\n\t\t\t\tERROR(\"write failed\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\tret = 0;\n\n\tout:\n\t\tif (interfaceArray)\n\t\t\tfreeifaddrs(interfaceArray);\n\n\t\t/* close the write-end of the pipe, thus sending EOF to the reader */\n\t\tclose(pipefd[1]);\n\t\texit(ret);\n\t}\n\n\t/* close the write-end of the pipe */\n\tclose(pipefd[1]);\n\n\twhile (read(pipefd[0], &interface, IFNAMSIZ) == IFNAMSIZ) {\n\t\tif (array_contains(&interfaces, interface, count))\n\t\t\t\tcontinue;\n\n\t\tif(!add_to_array(&interfaces, interface, count))\n\t\t\tERROR(\"PARENT: add_to_array failed\");\n\t\tcount++;\n\t}\n\n\tif (wait_for_pid(pid) != 0) {\n\t\tfor(i=0;i<count;i++)\n\t\t\tfree(interfaces[i]);\n\t\tfree(interfaces);\n\t\tinterfaces = NULL;\n\t}\n\n\t/* close the read-end of the pipe */\n\tclose(pipefd[0]);\n\n\t/* Append NULL to the array */\n\tif(interfaces)\n\t\tinterfaces = (char **)lxc_append_null_to_array((void **)interfaces, count);\n\n\treturn interfaces;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_append_null_to_array",
          "args": [
            "(void **)interfaces",
            "count"
          ],
          "line": 1862
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_append_null_to_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "992-1010",
          "snippet": "void **lxc_append_null_to_array(void **array, size_t count)\n{\n\tvoid **temp;\n\n\t/* Append NULL to the array */\n\tif (count) {\n\t\ttemp = realloc(array, (count + 1) * sizeof(*array));\n\t\tif (!temp) {\n\t\t\tsize_t i;\n\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\tfree(array[i]);\n\t\t\tfree(array);\n\t\t\treturn NULL;\n\t\t}\n\t\tarray = temp;\n\t\tarray[count] = NULL;\n\t}\n\treturn array;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid **lxc_append_null_to_array(void **array, size_t count)\n{\n\tvoid **temp;\n\n\t/* Append NULL to the array */\n\tif (count) {\n\t\ttemp = realloc(array, (count + 1) * sizeof(*array));\n\t\tif (!temp) {\n\t\t\tsize_t i;\n\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\tfree(array[i]);\n\t\t\tfree(array);\n\t\t\treturn NULL;\n\t\t}\n\t\tarray = temp;\n\t\tarray[count] = NULL;\n\t}\n\treturn array;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "pipefd[0]"
          ],
          "line": 1858
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "interfaces"
          ],
          "line": 1853
        },
        "resolved": true,
        "details": {
          "function_name": "free_init_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "706-715",
          "snippet": "static void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_pid",
          "args": [
            "pid"
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "311-325",
          "snippet": "int lxc_wait_for_pid_status(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\treturn status;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_wait_for_pid_status(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"PARENT: add_to_array failed\""
          ],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_to_array",
          "args": [
            "&interfaces",
            "interface",
            "count"
          ],
          "line": 1845
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "1721-1738",
          "snippet": "static bool add_to_array(char ***names, char *cname, int pos)\n{\n\tchar **newnames = realloc(*names, (pos+1) * sizeof(char *));\n\tif (!newnames) {\n\t\tERROR(\"Out of memory\");\n\t\treturn false;\n\t}\n\n\t*names = newnames;\n\tnewnames[pos] = strdup(cname);\n\tif (!newnames[pos])\n\t\treturn false;\n\n\t// sort the arrray as we will use binary search on it\n\tqsort(newnames, pos + 1, sizeof(char *), (int (*)(const void *,const void *))string_cmp);\n\n\treturn true;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool add_to_array(char ***names, char *cname, int pos)\n{\n\tchar **newnames = realloc(*names, (pos+1) * sizeof(char *));\n\tif (!newnames) {\n\t\tERROR(\"Out of memory\");\n\t\treturn false;\n\t}\n\n\t*names = newnames;\n\tnewnames[pos] = strdup(cname);\n\tif (!newnames[pos])\n\t\treturn false;\n\n\t// sort the arrray as we will use binary search on it\n\tqsort(newnames, pos + 1, sizeof(char *), (int (*)(const void *,const void *))string_cmp);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_contains",
          "args": [
            "&interfaces",
            "interface",
            "count"
          ],
          "line": 1842
        },
        "resolved": true,
        "details": {
          "function_name": "array_contains",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "1764-1768",
          "snippet": "static bool array_contains(char ***names, char *cname, int size) {\n\tif(get_from_array(names, cname, size) != NULL)\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool array_contains(char ***names, char *cname, int size) {\n\tif(get_from_array(names, cname, size) != NULL)\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "pipefd[0]",
            "&interface",
            "IFNAMSIZ"
          ],
          "line": 1841
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "962-990",
          "snippet": "int lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "ret"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeifaddrs",
          "args": [
            "interfaceArray"
          ],
          "line": 1831
        },
        "resolved": true,
        "details": {
          "function_name": "freeifaddrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
          "lines": "590-599",
          "snippet": "void freeifaddrs(struct ifaddrs *ifa)\n{\n    struct ifaddrs *l_cur;\n    while(ifa)\n    {\n        l_cur = ifa;\n        ifa = ifa->ifa_next;\n        free(l_cur);\n    }\n}",
          "includes": [
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"ifaddrs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nvoid freeifaddrs(struct ifaddrs *ifa)\n{\n    struct ifaddrs *l_cur;\n    while(ifa)\n    {\n        l_cur = ifa;\n        ifa = ifa->ifa_next;\n        free(l_cur);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"write failed\""
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "pipefd[1]",
            "tempIfAddr->ifa_name",
            "IFNAMSIZ"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_nointr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "327-335",
          "snippet": "ssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to get interfaces list\""
          ],
          "line": 1814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getifaddrs",
          "args": [
            "&interfaceArray"
          ],
          "line": 1813
        },
        "resolved": true,
        "details": {
          "function_name": "getifaddrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
          "lines": "548-588",
          "snippet": "int getifaddrs(struct ifaddrs **ifap)\n{\n    if(!ifap)\n    {\n        return -1;\n    }\n    *ifap = NULL;\n\n    int l_socket = netlink_socket();\n    if(l_socket < 0)\n    {\n        return -1;\n    }\n\n    NetlinkList *l_linkResults = getResultList(l_socket, RTM_GETLINK);\n    if(!l_linkResults)\n    {\n        close(l_socket);\n        return -1;\n    }\n\n    NetlinkList *l_addrResults = getResultList(l_socket, RTM_GETADDR);\n    if(!l_addrResults)\n    {\n        close(l_socket);\n        freeResultList(l_linkResults);\n        return -1;\n    }\n\n    unsigned l_numLinks = countLinks(l_socket, l_linkResults) + countLinks(l_socket, l_addrResults);\n    struct ifaddrs *l_links[l_numLinks];\n    memset(l_links, 0, l_numLinks * sizeof(struct ifaddrs *));\n\n    interpret(l_socket, l_linkResults, l_links, ifap);\n    interpret(l_socket, l_addrResults, l_links, ifap);\n\n    freeResultList(l_linkResults);\n    freeResultList(l_addrResults);\n    close(l_socket);\n    return 0;\n}",
          "includes": [
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"ifaddrs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nint getifaddrs(struct ifaddrs **ifap)\n{\n    if(!ifap)\n    {\n        return -1;\n    }\n    *ifap = NULL;\n\n    int l_socket = netlink_socket();\n    if(l_socket < 0)\n    {\n        return -1;\n    }\n\n    NetlinkList *l_linkResults = getResultList(l_socket, RTM_GETLINK);\n    if(!l_linkResults)\n    {\n        close(l_socket);\n        return -1;\n    }\n\n    NetlinkList *l_addrResults = getResultList(l_socket, RTM_GETADDR);\n    if(!l_addrResults)\n    {\n        close(l_socket);\n        freeResultList(l_linkResults);\n        return -1;\n    }\n\n    unsigned l_numLinks = countLinks(l_socket, l_linkResults) + countLinks(l_socket, l_addrResults);\n    struct ifaddrs *l_links[l_numLinks];\n    memset(l_links, 0, l_numLinks * sizeof(struct ifaddrs *));\n\n    interpret(l_socket, l_linkResults, l_links, ifap);\n    interpret(l_socket, l_addrResults, l_links, ifap);\n\n    freeResultList(l_linkResults);\n    freeResultList(l_addrResults);\n    close(l_socket);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to enter namespace\""
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enter_net_ns",
          "args": [
            "c"
          ],
          "line": 1807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to fork task to get interfaces information\""
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 1792
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"pipe failed\""
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "pipefd"
          ],
          "line": 1787
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic char ** do_lxcapi_get_interfaces(struct lxc_container *c)\n{\n\tpid_t pid;\n\tint i, count = 0, pipefd[2];\n\tchar **interfaces = NULL;\n\tchar interface[IFNAMSIZ];\n\n\tif(pipe(pipefd) < 0) {\n\t\tSYSERROR(\"pipe failed\");\n\t\treturn NULL;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"failed to fork task to get interfaces information\");\n\t\tclose(pipefd[0]);\n\t\tclose(pipefd[1]);\n\t\treturn NULL;\n\t}\n\n\tif (pid == 0) { // child\n\t\tint ret = 1, nbytes;\n\t\tstruct ifaddrs *interfaceArray = NULL, *tempIfAddr = NULL;\n\n\t\t/* close the read-end of the pipe */\n\t\tclose(pipefd[0]);\n\n\t\tif (!enter_net_ns(c)) {\n\t\t\tSYSERROR(\"failed to enter namespace\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Grab the list of interfaces */\n\t\tif (getifaddrs(&interfaceArray)) {\n\t\t\tSYSERROR(\"failed to get interfaces list\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Iterate through the interfaces */\n\t\tfor (tempIfAddr = interfaceArray; tempIfAddr != NULL; tempIfAddr = tempIfAddr->ifa_next) {\n\t\t\tnbytes = write(pipefd[1], tempIfAddr->ifa_name, IFNAMSIZ);\n\t\t\tif (nbytes < 0) {\n\t\t\t\tERROR(\"write failed\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\tret = 0;\n\n\tout:\n\t\tif (interfaceArray)\n\t\t\tfreeifaddrs(interfaceArray);\n\n\t\t/* close the write-end of the pipe, thus sending EOF to the reader */\n\t\tclose(pipefd[1]);\n\t\texit(ret);\n\t}\n\n\t/* close the write-end of the pipe */\n\tclose(pipefd[1]);\n\n\twhile (read(pipefd[0], &interface, IFNAMSIZ) == IFNAMSIZ) {\n\t\tif (array_contains(&interfaces, interface, count))\n\t\t\t\tcontinue;\n\n\t\tif(!add_to_array(&interfaces, interface, count))\n\t\t\tERROR(\"PARENT: add_to_array failed\");\n\t\tcount++;\n\t}\n\n\tif (wait_for_pid(pid) != 0) {\n\t\tfor(i=0;i<count;i++)\n\t\t\tfree(interfaces[i]);\n\t\tfree(interfaces);\n\t\tinterfaces = NULL;\n\t}\n\n\t/* close the read-end of the pipe */\n\tclose(pipefd[0]);\n\n\t/* Append NULL to the array */\n\tif(interfaces)\n\t\tinterfaces = (char **)lxc_append_null_to_array((void **)interfaces, count);\n\n\treturn interfaces;\n}"
  },
  {
    "function_name": "remove_from_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "1770-1778",
    "snippet": "static bool remove_from_array(char ***names, char *cname, int size)\n{\n\tchar **result = get_from_array(names, cname, size);\n\tif (result != NULL) {\n\t\tfree(result);\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "result"
          ],
          "line": 1774
        },
        "resolved": true,
        "details": {
          "function_name": "free_init_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "706-715",
          "snippet": "static void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_from_array",
          "args": [
            "names",
            "cname",
            "size"
          ],
          "line": 1772
        },
        "resolved": true,
        "details": {
          "function_name": "get_from_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "1758-1761",
          "snippet": "static char** get_from_array(char ***names, char *cname, int size)\n{\n\treturn (char **)bsearch(&cname, *names, size, sizeof(char *), (int (*)(const void *, const void *))string_cmp);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic char** get_from_array(char ***names, char *cname, int size)\n{\n\treturn (char **)bsearch(&cname, *names, size, sizeof(char *), (int (*)(const void *, const void *))string_cmp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool remove_from_array(char ***names, char *cname, int size)\n{\n\tchar **result = get_from_array(names, cname, size);\n\tif (result != NULL) {\n\t\tfree(result);\n\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "array_contains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "1764-1768",
    "snippet": "static bool array_contains(char ***names, char *cname, int size) {\n\tif(get_from_array(names, cname, size) != NULL)\n\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_from_array",
          "args": [
            "names",
            "cname",
            "size"
          ],
          "line": 1765
        },
        "resolved": true,
        "details": {
          "function_name": "get_from_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "1758-1761",
          "snippet": "static char** get_from_array(char ***names, char *cname, int size)\n{\n\treturn (char **)bsearch(&cname, *names, size, sizeof(char *), (int (*)(const void *, const void *))string_cmp);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic char** get_from_array(char ***names, char *cname, int size)\n{\n\treturn (char **)bsearch(&cname, *names, size, sizeof(char *), (int (*)(const void *, const void *))string_cmp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool array_contains(char ***names, char *cname, int size) {\n\tif(get_from_array(names, cname, size) != NULL)\n\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "get_from_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "1758-1761",
    "snippet": "static char** get_from_array(char ***names, char *cname, int size)\n{\n\treturn (char **)bsearch(&cname, *names, size, sizeof(char *), (int (*)(const void *, const void *))string_cmp);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bsearch",
          "args": [
            "&cname",
            "*names",
            "size",
            "sizeof(char *)",
            "(int (*)(const void *, const void *))string_cmp"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic char** get_from_array(char ***names, char *cname, int size)\n{\n\treturn (char **)bsearch(&cname, *names, size, sizeof(char *), (int (*)(const void *, const void *))string_cmp);\n}"
  },
  {
    "function_name": "add_to_clist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "1740-1756",
    "snippet": "static bool add_to_clist(struct lxc_container ***list, struct lxc_container *c, int pos, bool sort)\n{\n\tstruct lxc_container **newlist = realloc(*list, (pos+1) * sizeof(struct lxc_container *));\n\tif (!newlist) {\n\t\tERROR(\"Out of memory\");\n\t\treturn false;\n\t}\n\n\t*list = newlist;\n\tnewlist[pos] = c;\n\n\t// sort the arrray as we will use binary search on it\n\tif (sort)\n\t\tqsort(newlist, pos + 1, sizeof(struct lxc_container *), (int (*)(const void *,const void *))container_cmp);\n\n\treturn true;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "newlist",
            "pos + 1",
            "sizeof(struct lxc_container *)",
            "(int (*)(const void *,const void *))container_cmp"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Out of memory\""
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "*list",
            "(pos+1) * sizeof(struct lxc_container *)"
          ],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "must_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "116-124",
          "snippet": "static void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool add_to_clist(struct lxc_container ***list, struct lxc_container *c, int pos, bool sort)\n{\n\tstruct lxc_container **newlist = realloc(*list, (pos+1) * sizeof(struct lxc_container *));\n\tif (!newlist) {\n\t\tERROR(\"Out of memory\");\n\t\treturn false;\n\t}\n\n\t*list = newlist;\n\tnewlist[pos] = c;\n\n\t// sort the arrray as we will use binary search on it\n\tif (sort)\n\t\tqsort(newlist, pos + 1, sizeof(struct lxc_container *), (int (*)(const void *,const void *))container_cmp);\n\n\treturn true;\n}"
  },
  {
    "function_name": "add_to_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "1721-1738",
    "snippet": "static bool add_to_array(char ***names, char *cname, int pos)\n{\n\tchar **newnames = realloc(*names, (pos+1) * sizeof(char *));\n\tif (!newnames) {\n\t\tERROR(\"Out of memory\");\n\t\treturn false;\n\t}\n\n\t*names = newnames;\n\tnewnames[pos] = strdup(cname);\n\tif (!newnames[pos])\n\t\treturn false;\n\n\t// sort the arrray as we will use binary search on it\n\tqsort(newnames, pos + 1, sizeof(char *), (int (*)(const void *,const void *))string_cmp);\n\n\treturn true;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "newnames",
            "pos + 1",
            "sizeof(char *)",
            "(int (*)(const void *,const void *))string_cmp"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "cname"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Out of memory\""
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "*names",
            "(pos+1) * sizeof(char *)"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "must_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "116-124",
          "snippet": "static void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool add_to_array(char ***names, char *cname, int pos)\n{\n\tchar **newnames = realloc(*names, (pos+1) * sizeof(char *));\n\tif (!newnames) {\n\t\tERROR(\"Out of memory\");\n\t\treturn false;\n\t}\n\n\t*names = newnames;\n\tnewnames[pos] = strdup(cname);\n\tif (!newnames[pos])\n\t\treturn false;\n\n\t// sort the arrray as we will use binary search on it\n\tqsort(newnames, pos + 1, sizeof(char *), (int (*)(const void *,const void *))string_cmp);\n\n\treturn true;\n}"
  },
  {
    "function_name": "container_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "1716-1719",
    "snippet": "static inline int container_cmp(struct lxc_container **first, struct lxc_container **second)\n{\n\treturn strcmp((*first)->name, (*second)->name);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "(*first)->name",
            "(*second)->name"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic inline int container_cmp(struct lxc_container **first, struct lxc_container **second)\n{\n\treturn strcmp((*first)->name, (*second)->name);\n}"
  },
  {
    "function_name": "do_lxcapi_clear_config_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "1681-1694",
    "snippet": "static bool do_lxcapi_clear_config_item(struct lxc_container *c, const char *key)\n{\n\tint ret;\n\n\tif (!c || !c->lxc_conf)\n\t\treturn false;\n\tif (container_mem_lock(c))\n\t\treturn false;\n\tret = lxc_clear_config_item(c->lxc_conf, key);\n\tif (!ret)\n\t\tdo_clear_unexp_config_line(c->lxc_conf, key);\n\tcontainer_mem_unlock(c);\n\treturn ret == 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_mem_unlock",
          "args": [
            "c"
          ],
          "line": 1692
        },
        "resolved": true,
        "details": {
          "function_name": "container_mem_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "347-350",
          "snippet": "void container_mem_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->privlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nvoid container_mem_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->privlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_clear_unexp_config_line",
          "args": [
            "c->lxc_conf",
            "key"
          ],
          "line": 1691
        },
        "resolved": true,
        "details": {
          "function_name": "do_clear_unexp_config_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "1667-1679",
          "snippet": "static void do_clear_unexp_config_line(struct lxc_conf *conf, const char *key)\n{\n\tif (strcmp(key, \"lxc.cgroup\") == 0)\n\t\tclear_unexp_config_line(conf, key, true);\n\telse if (strcmp(key, \"lxc.network\") == 0)\n\t\tclear_unexp_config_line(conf, key, true);\n\telse if (strcmp(key, \"lxc.hook\") == 0)\n\t\tclear_unexp_config_line(conf, key, true);\n\telse\n\t\tclear_unexp_config_line(conf, key, false);\n\tif (!do_append_unexp_config_line(conf, key, \"\"))\n\t\tWARN(\"Error clearing configuration for %s\", key);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic void do_clear_unexp_config_line(struct lxc_conf *conf, const char *key)\n{\n\tif (strcmp(key, \"lxc.cgroup\") == 0)\n\t\tclear_unexp_config_line(conf, key, true);\n\telse if (strcmp(key, \"lxc.network\") == 0)\n\t\tclear_unexp_config_line(conf, key, true);\n\telse if (strcmp(key, \"lxc.hook\") == 0)\n\t\tclear_unexp_config_line(conf, key, true);\n\telse\n\t\tclear_unexp_config_line(conf, key, false);\n\tif (!do_append_unexp_config_line(conf, key, \"\"))\n\t\tWARN(\"Error clearing configuration for %s\", key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_clear_config_item",
          "args": [
            "c->lxc_conf",
            "key"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_clear_config_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/confile.c",
          "lines": "2690-2715",
          "snippet": "int lxc_clear_config_item(struct lxc_conf *c, const char *key)\n{\n\tif (strcmp(key, \"lxc.network\") == 0)\n\t\treturn lxc_clear_config_network(c);\n\telse if (strncmp(key, \"lxc.network.\", 12) == 0)\n\t\treturn lxc_clear_nic(c, key + 12);\n\telse if (strcmp(key, \"lxc.cap.drop\") == 0)\n\t\treturn lxc_clear_config_caps(c);\n\telse if (strcmp(key, \"lxc.cap.keep\") == 0)\n\t\treturn lxc_clear_config_keepcaps(c);\n\telse if (strncmp(key, \"lxc.cgroup\", 10) == 0)\n\t\treturn lxc_clear_cgroups(c, key);\n\telse if (strcmp(key, \"lxc.mount.entry\") == 0)\n\t\treturn lxc_clear_mount_entries(c);\n\telse if (strcmp(key, \"lxc.mount.auto\") == 0)\n\t\treturn lxc_clear_automounts(c);\n\telse if (strncmp(key, \"lxc.hook\", 8) == 0)\n\t\treturn lxc_clear_hooks(c, key);\n\telse if (strncmp(key, \"lxc.group\", 9) == 0)\n\t\treturn lxc_clear_groups(c);\n\telse if (strncmp(key, \"lxc.environment\", 15) == 0)\n\t\treturn lxc_clear_environment(c);\n\telse if (strncmp(key, \"lxc.id_map\", 10) == 0)\n\t\treturn lxc_clear_idmaps(c);\n\treturn -1;\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"network.h\"",
            "#include \"conf.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"confile.h\"",
            "#include \"config.h\"",
            "#include \"parse.h\"",
            "#include \"bdev.h\"",
            "#include <syslog.h>",
            "#include <dirent.h>",
            "#include <time.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int config_personality(const char *, const char *, struct lxc_conf *);",
            "static int config_pts(const char *, const char *, struct lxc_conf *);",
            "static int config_tty(const char *, const char *, struct lxc_conf *);",
            "static int config_ttydir(const char *, const char *, struct lxc_conf *);",
            "static int config_kmsg(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_aa_profile(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_aa_incomplete(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_se_context(const char *, const char *, struct lxc_conf *);",
            "static int config_cgroup(const char *, const char *, struct lxc_conf *);",
            "static int config_idmap(const char *, const char *, struct lxc_conf *);",
            "static int config_loglevel(const char *, const char *, struct lxc_conf *);",
            "static int config_logfile(const char *, const char *, struct lxc_conf *);",
            "static int config_mount(const char *, const char *, struct lxc_conf *);",
            "static int config_mount_auto(const char *, const char *, struct lxc_conf *);",
            "static int config_fstab(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_mount(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_options(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_backend(const char *, const char *, struct lxc_conf *);",
            "static int config_pivotdir(const char *, const char *, struct lxc_conf *);",
            "static int config_utsname(const char *, const char *, struct lxc_conf *);",
            "static int config_hook(const char *, const char *, struct lxc_conf *lxc_conf);",
            "static int config_network(const char *, const char *, struct lxc_conf *);",
            "static int config_network_type(const char *, const char *, struct lxc_conf *);",
            "static int config_network_flags(const char *, const char *, struct lxc_conf *);",
            "static int config_network_link(const char *, const char *, struct lxc_conf *);",
            "static int config_network_name(const char *, const char *, struct lxc_conf *);",
            "static int config_network_veth_pair(const char *, const char *, struct lxc_conf *);",
            "static int config_network_macvlan_mode(const char *, const char *, struct lxc_conf *);",
            "static int config_network_hwaddr(const char *, const char *, struct lxc_conf *);",
            "static int config_network_vlan_id(const char *, const char *, struct lxc_conf *);",
            "static int config_network_mtu(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv4(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv4_gateway(const char *, const char *, struct lxc_conf *);",
            "static int config_network_script_up(const char *, const char *, struct lxc_conf *);",
            "static int config_network_script_down(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv6(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv6_gateway(const char *, const char *, struct lxc_conf *);",
            "static int config_cap_drop(const char *, const char *, struct lxc_conf *);",
            "static int config_cap_keep(const char *, const char *, struct lxc_conf *);",
            "static int config_console(const char *, const char *, struct lxc_conf *);",
            "static int config_console_logfile(const char *, const char *, struct lxc_conf *);",
            "static int config_seccomp(const char *, const char *, struct lxc_conf *);",
            "static int config_includefile(const char *, const char *, struct lxc_conf *);",
            "static int config_network_nic(const char *, const char *, struct lxc_conf *);",
            "static int config_autodev(const char *, const char *, struct lxc_conf *);",
            "static int config_haltsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_rebootsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_stopsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_start(const char *, const char *, struct lxc_conf *);",
            "static int config_syslog(const char *, const char *, struct lxc_conf *);",
            "static int config_monitor(const char *, const char *, struct lxc_conf *);",
            "static int config_group(const char *, const char *, struct lxc_conf *);",
            "static int config_environment(const char *, const char *, struct lxc_conf *);",
            "static int config_init_cmd(const char *, const char *, struct lxc_conf *);",
            "static int config_init_uid(const char *, const char *, struct lxc_conf *);",
            "static int config_init_gid(const char *, const char *, struct lxc_conf *);",
            "static int config_ephemeral(const char *, const char *, struct lxc_conf *);",
            "static int config_no_new_privs(const char *, const char *, struct lxc_conf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"lxcseccomp.h\"\n#include \"network.h\"\n#include \"conf.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"confile.h\"\n#include \"config.h\"\n#include \"parse.h\"\n#include \"bdev.h\"\n#include <syslog.h>\n#include <dirent.h>\n#include <time.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int config_personality(const char *, const char *, struct lxc_conf *);\nstatic int config_pts(const char *, const char *, struct lxc_conf *);\nstatic int config_tty(const char *, const char *, struct lxc_conf *);\nstatic int config_ttydir(const char *, const char *, struct lxc_conf *);\nstatic int config_kmsg(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_aa_profile(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_aa_incomplete(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_se_context(const char *, const char *, struct lxc_conf *);\nstatic int config_cgroup(const char *, const char *, struct lxc_conf *);\nstatic int config_idmap(const char *, const char *, struct lxc_conf *);\nstatic int config_loglevel(const char *, const char *, struct lxc_conf *);\nstatic int config_logfile(const char *, const char *, struct lxc_conf *);\nstatic int config_mount(const char *, const char *, struct lxc_conf *);\nstatic int config_mount_auto(const char *, const char *, struct lxc_conf *);\nstatic int config_fstab(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_mount(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_options(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_backend(const char *, const char *, struct lxc_conf *);\nstatic int config_pivotdir(const char *, const char *, struct lxc_conf *);\nstatic int config_utsname(const char *, const char *, struct lxc_conf *);\nstatic int config_hook(const char *, const char *, struct lxc_conf *lxc_conf);\nstatic int config_network(const char *, const char *, struct lxc_conf *);\nstatic int config_network_type(const char *, const char *, struct lxc_conf *);\nstatic int config_network_flags(const char *, const char *, struct lxc_conf *);\nstatic int config_network_link(const char *, const char *, struct lxc_conf *);\nstatic int config_network_name(const char *, const char *, struct lxc_conf *);\nstatic int config_network_veth_pair(const char *, const char *, struct lxc_conf *);\nstatic int config_network_macvlan_mode(const char *, const char *, struct lxc_conf *);\nstatic int config_network_hwaddr(const char *, const char *, struct lxc_conf *);\nstatic int config_network_vlan_id(const char *, const char *, struct lxc_conf *);\nstatic int config_network_mtu(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv4(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv4_gateway(const char *, const char *, struct lxc_conf *);\nstatic int config_network_script_up(const char *, const char *, struct lxc_conf *);\nstatic int config_network_script_down(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv6(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv6_gateway(const char *, const char *, struct lxc_conf *);\nstatic int config_cap_drop(const char *, const char *, struct lxc_conf *);\nstatic int config_cap_keep(const char *, const char *, struct lxc_conf *);\nstatic int config_console(const char *, const char *, struct lxc_conf *);\nstatic int config_console_logfile(const char *, const char *, struct lxc_conf *);\nstatic int config_seccomp(const char *, const char *, struct lxc_conf *);\nstatic int config_includefile(const char *, const char *, struct lxc_conf *);\nstatic int config_network_nic(const char *, const char *, struct lxc_conf *);\nstatic int config_autodev(const char *, const char *, struct lxc_conf *);\nstatic int config_haltsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_rebootsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_stopsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_start(const char *, const char *, struct lxc_conf *);\nstatic int config_syslog(const char *, const char *, struct lxc_conf *);\nstatic int config_monitor(const char *, const char *, struct lxc_conf *);\nstatic int config_group(const char *, const char *, struct lxc_conf *);\nstatic int config_environment(const char *, const char *, struct lxc_conf *);\nstatic int config_init_cmd(const char *, const char *, struct lxc_conf *);\nstatic int config_init_uid(const char *, const char *, struct lxc_conf *);\nstatic int config_init_gid(const char *, const char *, struct lxc_conf *);\nstatic int config_ephemeral(const char *, const char *, struct lxc_conf *);\nstatic int config_no_new_privs(const char *, const char *, struct lxc_conf *);\n\nint lxc_clear_config_item(struct lxc_conf *c, const char *key)\n{\n\tif (strcmp(key, \"lxc.network\") == 0)\n\t\treturn lxc_clear_config_network(c);\n\telse if (strncmp(key, \"lxc.network.\", 12) == 0)\n\t\treturn lxc_clear_nic(c, key + 12);\n\telse if (strcmp(key, \"lxc.cap.drop\") == 0)\n\t\treturn lxc_clear_config_caps(c);\n\telse if (strcmp(key, \"lxc.cap.keep\") == 0)\n\t\treturn lxc_clear_config_keepcaps(c);\n\telse if (strncmp(key, \"lxc.cgroup\", 10) == 0)\n\t\treturn lxc_clear_cgroups(c, key);\n\telse if (strcmp(key, \"lxc.mount.entry\") == 0)\n\t\treturn lxc_clear_mount_entries(c);\n\telse if (strcmp(key, \"lxc.mount.auto\") == 0)\n\t\treturn lxc_clear_automounts(c);\n\telse if (strncmp(key, \"lxc.hook\", 8) == 0)\n\t\treturn lxc_clear_hooks(c, key);\n\telse if (strncmp(key, \"lxc.group\", 9) == 0)\n\t\treturn lxc_clear_groups(c);\n\telse if (strncmp(key, \"lxc.environment\", 15) == 0)\n\t\treturn lxc_clear_environment(c);\n\telse if (strncmp(key, \"lxc.id_map\", 10) == 0)\n\t\treturn lxc_clear_idmaps(c);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_mem_lock",
          "args": [
            "c"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "container_mem_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "342-345",
          "snippet": "int container_mem_lock(struct lxc_container *c)\n{\n\treturn lxclock(c->privlock, 0);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nint container_mem_lock(struct lxc_container *c)\n{\n\treturn lxclock(c->privlock, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_clear_config_item(struct lxc_container *c, const char *key)\n{\n\tint ret;\n\n\tif (!c || !c->lxc_conf)\n\t\treturn false;\n\tif (container_mem_lock(c))\n\t\treturn false;\n\tret = lxc_clear_config_item(c->lxc_conf, key);\n\tif (!ret)\n\t\tdo_clear_unexp_config_line(c->lxc_conf, key);\n\tcontainer_mem_unlock(c);\n\treturn ret == 0;\n}"
  },
  {
    "function_name": "do_clear_unexp_config_line",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "1667-1679",
    "snippet": "static void do_clear_unexp_config_line(struct lxc_conf *conf, const char *key)\n{\n\tif (strcmp(key, \"lxc.cgroup\") == 0)\n\t\tclear_unexp_config_line(conf, key, true);\n\telse if (strcmp(key, \"lxc.network\") == 0)\n\t\tclear_unexp_config_line(conf, key, true);\n\telse if (strcmp(key, \"lxc.hook\") == 0)\n\t\tclear_unexp_config_line(conf, key, true);\n\telse\n\t\tclear_unexp_config_line(conf, key, false);\n\tif (!do_append_unexp_config_line(conf, key, \"\"))\n\t\tWARN(\"Error clearing configuration for %s\", key);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Error clearing configuration for %s\"",
            "key"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_append_unexp_config_line",
          "args": [
            "conf",
            "key",
            "\"\""
          ],
          "line": 1677
        },
        "resolved": true,
        "details": {
          "function_name": "do_append_unexp_config_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/confile.c",
          "lines": "2732-2747",
          "snippet": "bool do_append_unexp_config_line(struct lxc_conf *conf, const char *key, const char *v)\n{\n\tint ret;\n\tsize_t len = strlen(key) + strlen(v) + 4;\n\tchar *tmp = alloca(len);\n\n\tret = snprintf(tmp, len, \"%s = %s\", key, v);\n\tif (ret < 0 || ret >= len)\n\t\treturn false;\n\n\t/* Save the line verbatim into unexpanded_conf */\n\tif (append_unexp_config_line(tmp, conf))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"network.h\"",
            "#include \"conf.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"confile.h\"",
            "#include \"config.h\"",
            "#include \"parse.h\"",
            "#include \"bdev.h\"",
            "#include <syslog.h>",
            "#include <dirent.h>",
            "#include <time.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int config_personality(const char *, const char *, struct lxc_conf *);",
            "static int config_pts(const char *, const char *, struct lxc_conf *);",
            "static int config_tty(const char *, const char *, struct lxc_conf *);",
            "static int config_ttydir(const char *, const char *, struct lxc_conf *);",
            "static int config_kmsg(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_aa_profile(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_aa_incomplete(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_se_context(const char *, const char *, struct lxc_conf *);",
            "static int config_cgroup(const char *, const char *, struct lxc_conf *);",
            "static int config_idmap(const char *, const char *, struct lxc_conf *);",
            "static int config_loglevel(const char *, const char *, struct lxc_conf *);",
            "static int config_logfile(const char *, const char *, struct lxc_conf *);",
            "static int config_mount(const char *, const char *, struct lxc_conf *);",
            "static int config_mount_auto(const char *, const char *, struct lxc_conf *);",
            "static int config_fstab(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_mount(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_options(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_backend(const char *, const char *, struct lxc_conf *);",
            "static int config_pivotdir(const char *, const char *, struct lxc_conf *);",
            "static int config_utsname(const char *, const char *, struct lxc_conf *);",
            "static int config_hook(const char *, const char *, struct lxc_conf *lxc_conf);",
            "static int config_network(const char *, const char *, struct lxc_conf *);",
            "static int config_network_type(const char *, const char *, struct lxc_conf *);",
            "static int config_network_flags(const char *, const char *, struct lxc_conf *);",
            "static int config_network_link(const char *, const char *, struct lxc_conf *);",
            "static int config_network_name(const char *, const char *, struct lxc_conf *);",
            "static int config_network_veth_pair(const char *, const char *, struct lxc_conf *);",
            "static int config_network_macvlan_mode(const char *, const char *, struct lxc_conf *);",
            "static int config_network_hwaddr(const char *, const char *, struct lxc_conf *);",
            "static int config_network_vlan_id(const char *, const char *, struct lxc_conf *);",
            "static int config_network_mtu(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv4(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv4_gateway(const char *, const char *, struct lxc_conf *);",
            "static int config_network_script_up(const char *, const char *, struct lxc_conf *);",
            "static int config_network_script_down(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv6(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv6_gateway(const char *, const char *, struct lxc_conf *);",
            "static int config_cap_drop(const char *, const char *, struct lxc_conf *);",
            "static int config_cap_keep(const char *, const char *, struct lxc_conf *);",
            "static int config_console(const char *, const char *, struct lxc_conf *);",
            "static int config_console_logfile(const char *, const char *, struct lxc_conf *);",
            "static int config_seccomp(const char *, const char *, struct lxc_conf *);",
            "static int config_includefile(const char *, const char *, struct lxc_conf *);",
            "static int config_network_nic(const char *, const char *, struct lxc_conf *);",
            "static int config_autodev(const char *, const char *, struct lxc_conf *);",
            "static int config_haltsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_rebootsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_stopsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_start(const char *, const char *, struct lxc_conf *);",
            "static int config_syslog(const char *, const char *, struct lxc_conf *);",
            "static int config_monitor(const char *, const char *, struct lxc_conf *);",
            "static int config_group(const char *, const char *, struct lxc_conf *);",
            "static int config_environment(const char *, const char *, struct lxc_conf *);",
            "static int config_init_cmd(const char *, const char *, struct lxc_conf *);",
            "static int config_init_uid(const char *, const char *, struct lxc_conf *);",
            "static int config_init_gid(const char *, const char *, struct lxc_conf *);",
            "static int config_ephemeral(const char *, const char *, struct lxc_conf *);",
            "static int config_no_new_privs(const char *, const char *, struct lxc_conf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"lxcseccomp.h\"\n#include \"network.h\"\n#include \"conf.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"confile.h\"\n#include \"config.h\"\n#include \"parse.h\"\n#include \"bdev.h\"\n#include <syslog.h>\n#include <dirent.h>\n#include <time.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int config_personality(const char *, const char *, struct lxc_conf *);\nstatic int config_pts(const char *, const char *, struct lxc_conf *);\nstatic int config_tty(const char *, const char *, struct lxc_conf *);\nstatic int config_ttydir(const char *, const char *, struct lxc_conf *);\nstatic int config_kmsg(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_aa_profile(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_aa_incomplete(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_se_context(const char *, const char *, struct lxc_conf *);\nstatic int config_cgroup(const char *, const char *, struct lxc_conf *);\nstatic int config_idmap(const char *, const char *, struct lxc_conf *);\nstatic int config_loglevel(const char *, const char *, struct lxc_conf *);\nstatic int config_logfile(const char *, const char *, struct lxc_conf *);\nstatic int config_mount(const char *, const char *, struct lxc_conf *);\nstatic int config_mount_auto(const char *, const char *, struct lxc_conf *);\nstatic int config_fstab(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_mount(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_options(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_backend(const char *, const char *, struct lxc_conf *);\nstatic int config_pivotdir(const char *, const char *, struct lxc_conf *);\nstatic int config_utsname(const char *, const char *, struct lxc_conf *);\nstatic int config_hook(const char *, const char *, struct lxc_conf *lxc_conf);\nstatic int config_network(const char *, const char *, struct lxc_conf *);\nstatic int config_network_type(const char *, const char *, struct lxc_conf *);\nstatic int config_network_flags(const char *, const char *, struct lxc_conf *);\nstatic int config_network_link(const char *, const char *, struct lxc_conf *);\nstatic int config_network_name(const char *, const char *, struct lxc_conf *);\nstatic int config_network_veth_pair(const char *, const char *, struct lxc_conf *);\nstatic int config_network_macvlan_mode(const char *, const char *, struct lxc_conf *);\nstatic int config_network_hwaddr(const char *, const char *, struct lxc_conf *);\nstatic int config_network_vlan_id(const char *, const char *, struct lxc_conf *);\nstatic int config_network_mtu(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv4(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv4_gateway(const char *, const char *, struct lxc_conf *);\nstatic int config_network_script_up(const char *, const char *, struct lxc_conf *);\nstatic int config_network_script_down(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv6(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv6_gateway(const char *, const char *, struct lxc_conf *);\nstatic int config_cap_drop(const char *, const char *, struct lxc_conf *);\nstatic int config_cap_keep(const char *, const char *, struct lxc_conf *);\nstatic int config_console(const char *, const char *, struct lxc_conf *);\nstatic int config_console_logfile(const char *, const char *, struct lxc_conf *);\nstatic int config_seccomp(const char *, const char *, struct lxc_conf *);\nstatic int config_includefile(const char *, const char *, struct lxc_conf *);\nstatic int config_network_nic(const char *, const char *, struct lxc_conf *);\nstatic int config_autodev(const char *, const char *, struct lxc_conf *);\nstatic int config_haltsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_rebootsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_stopsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_start(const char *, const char *, struct lxc_conf *);\nstatic int config_syslog(const char *, const char *, struct lxc_conf *);\nstatic int config_monitor(const char *, const char *, struct lxc_conf *);\nstatic int config_group(const char *, const char *, struct lxc_conf *);\nstatic int config_environment(const char *, const char *, struct lxc_conf *);\nstatic int config_init_cmd(const char *, const char *, struct lxc_conf *);\nstatic int config_init_uid(const char *, const char *, struct lxc_conf *);\nstatic int config_init_gid(const char *, const char *, struct lxc_conf *);\nstatic int config_ephemeral(const char *, const char *, struct lxc_conf *);\nstatic int config_no_new_privs(const char *, const char *, struct lxc_conf *);\n\nbool do_append_unexp_config_line(struct lxc_conf *conf, const char *key, const char *v)\n{\n\tint ret;\n\tsize_t len = strlen(key) + strlen(v) + 4;\n\tchar *tmp = alloca(len);\n\n\tret = snprintf(tmp, len, \"%s = %s\", key, v);\n\tif (ret < 0 || ret >= len)\n\t\treturn false;\n\n\t/* Save the line verbatim into unexpanded_conf */\n\tif (append_unexp_config_line(tmp, conf))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_unexp_config_line",
          "args": [
            "conf",
            "key",
            "false"
          ],
          "line": 1676
        },
        "resolved": true,
        "details": {
          "function_name": "clear_unexp_config_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/confile.c",
          "lines": "2749-2780",
          "snippet": "void clear_unexp_config_line(struct lxc_conf *conf, const char *key, bool rm_subkeys)\n{\n\tchar *lstart = conf->unexpanded_config, *lend;\n\n\tif (!conf->unexpanded_config)\n\t\treturn;\n\twhile (*lstart) {\n\t\tlend = strchr(lstart, '\\n');\n\t\tchar v;\n\t\tif (!lend)\n\t\t\tlend = lstart + strlen(lstart);\n\t\telse\n\t\t\tlend++;\n\t\tif (strncmp(lstart, key, strlen(key)) != 0) {\n\t\t\tlstart = lend;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!rm_subkeys) {\n\t\t\tv = lstart[strlen(key)];\n\t\t\tif (!isspace(v) && v != '=') {\n\t\t\t\tlstart = lend;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tconf->unexpanded_len -= (lend - lstart);\n\t\tif (*lend == '\\0') {\n\t\t\t*lstart = '\\0';\n\t\t\treturn;\n\t\t}\n\t\tmemmove(lstart, lend, strlen(lend)+1);\n\t}\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"network.h\"",
            "#include \"conf.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"confile.h\"",
            "#include \"config.h\"",
            "#include \"parse.h\"",
            "#include \"bdev.h\"",
            "#include <syslog.h>",
            "#include <dirent.h>",
            "#include <time.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int config_personality(const char *, const char *, struct lxc_conf *);",
            "static int config_pts(const char *, const char *, struct lxc_conf *);",
            "static int config_tty(const char *, const char *, struct lxc_conf *);",
            "static int config_ttydir(const char *, const char *, struct lxc_conf *);",
            "static int config_kmsg(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_aa_profile(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_aa_incomplete(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_se_context(const char *, const char *, struct lxc_conf *);",
            "static int config_cgroup(const char *, const char *, struct lxc_conf *);",
            "static int config_idmap(const char *, const char *, struct lxc_conf *);",
            "static int config_loglevel(const char *, const char *, struct lxc_conf *);",
            "static int config_logfile(const char *, const char *, struct lxc_conf *);",
            "static int config_mount(const char *, const char *, struct lxc_conf *);",
            "static int config_mount_auto(const char *, const char *, struct lxc_conf *);",
            "static int config_fstab(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_mount(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_options(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_backend(const char *, const char *, struct lxc_conf *);",
            "static int config_pivotdir(const char *, const char *, struct lxc_conf *);",
            "static int config_utsname(const char *, const char *, struct lxc_conf *);",
            "static int config_hook(const char *, const char *, struct lxc_conf *lxc_conf);",
            "static int config_network(const char *, const char *, struct lxc_conf *);",
            "static int config_network_type(const char *, const char *, struct lxc_conf *);",
            "static int config_network_flags(const char *, const char *, struct lxc_conf *);",
            "static int config_network_link(const char *, const char *, struct lxc_conf *);",
            "static int config_network_name(const char *, const char *, struct lxc_conf *);",
            "static int config_network_veth_pair(const char *, const char *, struct lxc_conf *);",
            "static int config_network_macvlan_mode(const char *, const char *, struct lxc_conf *);",
            "static int config_network_hwaddr(const char *, const char *, struct lxc_conf *);",
            "static int config_network_vlan_id(const char *, const char *, struct lxc_conf *);",
            "static int config_network_mtu(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv4(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv4_gateway(const char *, const char *, struct lxc_conf *);",
            "static int config_network_script_up(const char *, const char *, struct lxc_conf *);",
            "static int config_network_script_down(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv6(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv6_gateway(const char *, const char *, struct lxc_conf *);",
            "static int config_cap_drop(const char *, const char *, struct lxc_conf *);",
            "static int config_cap_keep(const char *, const char *, struct lxc_conf *);",
            "static int config_console(const char *, const char *, struct lxc_conf *);",
            "static int config_console_logfile(const char *, const char *, struct lxc_conf *);",
            "static int config_seccomp(const char *, const char *, struct lxc_conf *);",
            "static int config_includefile(const char *, const char *, struct lxc_conf *);",
            "static int config_network_nic(const char *, const char *, struct lxc_conf *);",
            "static int config_autodev(const char *, const char *, struct lxc_conf *);",
            "static int config_haltsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_rebootsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_stopsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_start(const char *, const char *, struct lxc_conf *);",
            "static int config_syslog(const char *, const char *, struct lxc_conf *);",
            "static int config_monitor(const char *, const char *, struct lxc_conf *);",
            "static int config_group(const char *, const char *, struct lxc_conf *);",
            "static int config_environment(const char *, const char *, struct lxc_conf *);",
            "static int config_init_cmd(const char *, const char *, struct lxc_conf *);",
            "static int config_init_uid(const char *, const char *, struct lxc_conf *);",
            "static int config_init_gid(const char *, const char *, struct lxc_conf *);",
            "static int config_ephemeral(const char *, const char *, struct lxc_conf *);",
            "static int config_no_new_privs(const char *, const char *, struct lxc_conf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"lxcseccomp.h\"\n#include \"network.h\"\n#include \"conf.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"confile.h\"\n#include \"config.h\"\n#include \"parse.h\"\n#include \"bdev.h\"\n#include <syslog.h>\n#include <dirent.h>\n#include <time.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int config_personality(const char *, const char *, struct lxc_conf *);\nstatic int config_pts(const char *, const char *, struct lxc_conf *);\nstatic int config_tty(const char *, const char *, struct lxc_conf *);\nstatic int config_ttydir(const char *, const char *, struct lxc_conf *);\nstatic int config_kmsg(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_aa_profile(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_aa_incomplete(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_se_context(const char *, const char *, struct lxc_conf *);\nstatic int config_cgroup(const char *, const char *, struct lxc_conf *);\nstatic int config_idmap(const char *, const char *, struct lxc_conf *);\nstatic int config_loglevel(const char *, const char *, struct lxc_conf *);\nstatic int config_logfile(const char *, const char *, struct lxc_conf *);\nstatic int config_mount(const char *, const char *, struct lxc_conf *);\nstatic int config_mount_auto(const char *, const char *, struct lxc_conf *);\nstatic int config_fstab(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_mount(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_options(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_backend(const char *, const char *, struct lxc_conf *);\nstatic int config_pivotdir(const char *, const char *, struct lxc_conf *);\nstatic int config_utsname(const char *, const char *, struct lxc_conf *);\nstatic int config_hook(const char *, const char *, struct lxc_conf *lxc_conf);\nstatic int config_network(const char *, const char *, struct lxc_conf *);\nstatic int config_network_type(const char *, const char *, struct lxc_conf *);\nstatic int config_network_flags(const char *, const char *, struct lxc_conf *);\nstatic int config_network_link(const char *, const char *, struct lxc_conf *);\nstatic int config_network_name(const char *, const char *, struct lxc_conf *);\nstatic int config_network_veth_pair(const char *, const char *, struct lxc_conf *);\nstatic int config_network_macvlan_mode(const char *, const char *, struct lxc_conf *);\nstatic int config_network_hwaddr(const char *, const char *, struct lxc_conf *);\nstatic int config_network_vlan_id(const char *, const char *, struct lxc_conf *);\nstatic int config_network_mtu(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv4(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv4_gateway(const char *, const char *, struct lxc_conf *);\nstatic int config_network_script_up(const char *, const char *, struct lxc_conf *);\nstatic int config_network_script_down(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv6(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv6_gateway(const char *, const char *, struct lxc_conf *);\nstatic int config_cap_drop(const char *, const char *, struct lxc_conf *);\nstatic int config_cap_keep(const char *, const char *, struct lxc_conf *);\nstatic int config_console(const char *, const char *, struct lxc_conf *);\nstatic int config_console_logfile(const char *, const char *, struct lxc_conf *);\nstatic int config_seccomp(const char *, const char *, struct lxc_conf *);\nstatic int config_includefile(const char *, const char *, struct lxc_conf *);\nstatic int config_network_nic(const char *, const char *, struct lxc_conf *);\nstatic int config_autodev(const char *, const char *, struct lxc_conf *);\nstatic int config_haltsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_rebootsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_stopsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_start(const char *, const char *, struct lxc_conf *);\nstatic int config_syslog(const char *, const char *, struct lxc_conf *);\nstatic int config_monitor(const char *, const char *, struct lxc_conf *);\nstatic int config_group(const char *, const char *, struct lxc_conf *);\nstatic int config_environment(const char *, const char *, struct lxc_conf *);\nstatic int config_init_cmd(const char *, const char *, struct lxc_conf *);\nstatic int config_init_uid(const char *, const char *, struct lxc_conf *);\nstatic int config_init_gid(const char *, const char *, struct lxc_conf *);\nstatic int config_ephemeral(const char *, const char *, struct lxc_conf *);\nstatic int config_no_new_privs(const char *, const char *, struct lxc_conf *);\n\nvoid clear_unexp_config_line(struct lxc_conf *conf, const char *key, bool rm_subkeys)\n{\n\tchar *lstart = conf->unexpanded_config, *lend;\n\n\tif (!conf->unexpanded_config)\n\t\treturn;\n\twhile (*lstart) {\n\t\tlend = strchr(lstart, '\\n');\n\t\tchar v;\n\t\tif (!lend)\n\t\t\tlend = lstart + strlen(lstart);\n\t\telse\n\t\t\tlend++;\n\t\tif (strncmp(lstart, key, strlen(key)) != 0) {\n\t\t\tlstart = lend;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!rm_subkeys) {\n\t\t\tv = lstart[strlen(key)];\n\t\t\tif (!isspace(v) && v != '=') {\n\t\t\t\tlstart = lend;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tconf->unexpanded_len -= (lend - lstart);\n\t\tif (*lend == '\\0') {\n\t\t\t*lstart = '\\0';\n\t\t\treturn;\n\t\t}\n\t\tmemmove(lstart, lend, strlen(lend)+1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "key",
            "\"lxc.hook\""
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "key",
            "\"lxc.network\""
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "key",
            "\"lxc.cgroup\""
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic void do_clear_unexp_config_line(struct lxc_conf *conf, const char *key)\n{\n\tif (strcmp(key, \"lxc.cgroup\") == 0)\n\t\tclear_unexp_config_line(conf, key, true);\n\telse if (strcmp(key, \"lxc.network\") == 0)\n\t\tclear_unexp_config_line(conf, key, true);\n\telse if (strcmp(key, \"lxc.hook\") == 0)\n\t\tclear_unexp_config_line(conf, key, true);\n\telse\n\t\tclear_unexp_config_line(conf, key, false);\n\tif (!do_append_unexp_config_line(conf, key, \"\"))\n\t\tWARN(\"Error clearing configuration for %s\", key);\n}"
  },
  {
    "function_name": "lxcapi_createl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "1635-1665",
    "snippet": "static bool lxcapi_createl(struct lxc_container *c, const char *t,\n\t\tconst char *bdevtype, struct bdev_specs *specs, int flags, ...)\n{\n\tbool bret = false;\n\tchar **args = NULL;\n\tva_list ap;\n\n\tif (!c)\n\t\treturn false;\n\n\tcurrent_config = c->lxc_conf;\n\n\t/*\n\t * since we're going to wait for create to finish, I don't think we\n\t * need to get a copy of the arguments.\n\t */\n\tva_start(ap, flags);\n\targs = lxc_va_arg_list_to_argv(ap, 0, 0);\n\tva_end(ap);\n\tif (!args) {\n\t\tERROR(\"Memory allocation error.\");\n\t\tgoto out;\n\t}\n\n\tbret = do_lxcapi_create(c, t, bdevtype, specs, flags, args);\n\nout:\n\tfree(args);\n\tcurrent_config = NULL;\n\treturn bret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "args"
          ],
          "line": 1662
        },
        "resolved": true,
        "details": {
          "function_name": "free_init_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "706-715",
          "snippet": "static void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_lxcapi_create",
          "args": [
            "c",
            "t",
            "bdevtype",
            "specs",
            "flags",
            "args"
          ],
          "line": 1659
        },
        "resolved": true,
        "details": {
          "function_name": "do_lxcapi_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "1427-1565",
          "snippet": "static bool do_lxcapi_create(struct lxc_container *c, const char *t,\n\t\tconst char *bdevtype, struct bdev_specs *specs, int flags,\n\t\tchar *const argv[])\n{\n\tbool ret = false;\n\tpid_t pid;\n\tchar *tpath = NULL;\n\tint partial_fd;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (t) {\n\t\ttpath = get_template_path(t);\n\t\tif (!tpath) {\n\t\t\tERROR(\"bad template: %s\", t);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * If a template is passed in, and the rootfs already is defined in\n\t * the container config and exists, then * caller is trying to create\n\t * an existing container.  Return an error, but do NOT delete the\n\t * container.\n\t */\n\tif (do_lxcapi_is_defined(c) && c->lxc_conf && c->lxc_conf->rootfs.path &&\n\t\t\taccess(c->lxc_conf->rootfs.path, F_OK) == 0 && tpath) {\n\t\tERROR(\"Container %s:%s already exists\", c->config_path, c->name);\n\t\tgoto free_tpath;\n\t}\n\n\tif (!c->lxc_conf) {\n\t\tif (!do_lxcapi_load_config(c, lxc_global_config_value(\"lxc.default_config\"))) {\n\t\t\tERROR(\"Error loading default configuration file %s\", lxc_global_config_value(\"lxc.default_config\"));\n\t\t\tgoto free_tpath;\n\t\t}\n\t}\n\n\tif (!create_container_dir(c))\n\t\tgoto free_tpath;\n\n\t/*\n\t * if both template and rootfs.path are set, template is setup as rootfs.path.\n\t * container is already created if we have a config and rootfs.path is accessible\n\t */\n\tif (!c->lxc_conf->rootfs.path && !tpath) {\n\t\t/* no template passed in and rootfs does not exist */\n\t\tif (!c->save_config(c, NULL)) {\n\t\t\tERROR(\"failed to save starting configuration for %s\\n\", c->name);\n\t\t\tgoto out;\n\t\t}\n\t\tret = true;\n\t\tgoto out;\n\t}\n\tif (c->lxc_conf->rootfs.path && access(c->lxc_conf->rootfs.path, F_OK) != 0)\n\t\t/* rootfs passed into configuration, but does not exist: error */\n\t\tgoto out;\n\tif (do_lxcapi_is_defined(c) && c->lxc_conf->rootfs.path && !tpath) {\n\t\t/* Rootfs already existed, user just wanted to save the\n\t\t * loaded configuration */\n\t\tif (!c->save_config(c, NULL))\n\t\t\tERROR(\"failed to save starting configuration for %s\\n\", c->name);\n\t\tret = true;\n\t\tgoto out;\n\t}\n\n\t/* Mark that this container is being created */\n\tif ((partial_fd = create_partial(c)) < 0)\n\t\tgoto out;\n\n\t/* no need to get disk lock bc we have the partial locked */\n\n\t/*\n\t * Create the backing store\n\t * Note we can't do this in the same task as we use to execute the\n\t * template because of the way zfs works.\n\t * After you 'zfs create', zfs mounts the fs only in the initial\n\t * namespace.\n\t */\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"failed to fork task for container creation template\");\n\t\tgoto out_unlock;\n\t}\n\n\tif (pid == 0) { // child\n\t\tstruct bdev *bdev = NULL;\n\n\t\tif (!(bdev = do_bdev_create(c, bdevtype, specs))) {\n\t\t\tERROR(\"Error creating backing store type %s for %s\",\n\t\t\t\tbdevtype ? bdevtype : \"(none)\", c->name);\n\t\t\texit(1);\n\t\t}\n\n\t\t/* save config file again to store the new rootfs location */\n\t\tif (!do_lxcapi_save_config(c, NULL)) {\n\t\t\tERROR(\"failed to save starting configuration for %s\", c->name);\n\t\t\t// parent task won't see bdev in config so we delete it\n\t\t\tbdev->ops->umount(bdev);\n\t\t\tbdev->ops->destroy(bdev);\n\t\t\texit(1);\n\t\t}\n\t\texit(0);\n\t}\n\tif (wait_for_pid(pid) != 0)\n\t\tgoto out_unlock;\n\n\t/* reload config to get the rootfs */\n\tlxc_conf_free(c->lxc_conf);\n\tc->lxc_conf = NULL;\n\tif (!load_config_locked(c, c->configfile))\n\t\tgoto out_unlock;\n\n\tif (!create_run_template(c, tpath, !!(flags & LXC_CREATE_QUIET), argv))\n\t\tgoto out_unlock;\n\n\t// now clear out the lxc_conf we have, reload from the created\n\t// container\n\tdo_lxcapi_clear_config(c);\n\n\tif (t) {\n\t\tif (!prepend_lxc_header(c->configfile, tpath, argv)) {\n\t\t\tERROR(\"Error prepending header to configuration file\");\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\tret = load_config_locked(c, c->configfile);\n\nout_unlock:\n\tif (partial_fd >= 0)\n\t\tremove_partial(c, partial_fd);\nout:\n\tif (!ret)\n\t\tcontainer_destroy(c);\nfree_tpath:\n\tfree(tpath);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_create(struct lxc_container *c, const char *t,\n\t\tconst char *bdevtype, struct bdev_specs *specs, int flags,\n\t\tchar *const argv[])\n{\n\tbool ret = false;\n\tpid_t pid;\n\tchar *tpath = NULL;\n\tint partial_fd;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (t) {\n\t\ttpath = get_template_path(t);\n\t\tif (!tpath) {\n\t\t\tERROR(\"bad template: %s\", t);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * If a template is passed in, and the rootfs already is defined in\n\t * the container config and exists, then * caller is trying to create\n\t * an existing container.  Return an error, but do NOT delete the\n\t * container.\n\t */\n\tif (do_lxcapi_is_defined(c) && c->lxc_conf && c->lxc_conf->rootfs.path &&\n\t\t\taccess(c->lxc_conf->rootfs.path, F_OK) == 0 && tpath) {\n\t\tERROR(\"Container %s:%s already exists\", c->config_path, c->name);\n\t\tgoto free_tpath;\n\t}\n\n\tif (!c->lxc_conf) {\n\t\tif (!do_lxcapi_load_config(c, lxc_global_config_value(\"lxc.default_config\"))) {\n\t\t\tERROR(\"Error loading default configuration file %s\", lxc_global_config_value(\"lxc.default_config\"));\n\t\t\tgoto free_tpath;\n\t\t}\n\t}\n\n\tif (!create_container_dir(c))\n\t\tgoto free_tpath;\n\n\t/*\n\t * if both template and rootfs.path are set, template is setup as rootfs.path.\n\t * container is already created if we have a config and rootfs.path is accessible\n\t */\n\tif (!c->lxc_conf->rootfs.path && !tpath) {\n\t\t/* no template passed in and rootfs does not exist */\n\t\tif (!c->save_config(c, NULL)) {\n\t\t\tERROR(\"failed to save starting configuration for %s\\n\", c->name);\n\t\t\tgoto out;\n\t\t}\n\t\tret = true;\n\t\tgoto out;\n\t}\n\tif (c->lxc_conf->rootfs.path && access(c->lxc_conf->rootfs.path, F_OK) != 0)\n\t\t/* rootfs passed into configuration, but does not exist: error */\n\t\tgoto out;\n\tif (do_lxcapi_is_defined(c) && c->lxc_conf->rootfs.path && !tpath) {\n\t\t/* Rootfs already existed, user just wanted to save the\n\t\t * loaded configuration */\n\t\tif (!c->save_config(c, NULL))\n\t\t\tERROR(\"failed to save starting configuration for %s\\n\", c->name);\n\t\tret = true;\n\t\tgoto out;\n\t}\n\n\t/* Mark that this container is being created */\n\tif ((partial_fd = create_partial(c)) < 0)\n\t\tgoto out;\n\n\t/* no need to get disk lock bc we have the partial locked */\n\n\t/*\n\t * Create the backing store\n\t * Note we can't do this in the same task as we use to execute the\n\t * template because of the way zfs works.\n\t * After you 'zfs create', zfs mounts the fs only in the initial\n\t * namespace.\n\t */\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"failed to fork task for container creation template\");\n\t\tgoto out_unlock;\n\t}\n\n\tif (pid == 0) { // child\n\t\tstruct bdev *bdev = NULL;\n\n\t\tif (!(bdev = do_bdev_create(c, bdevtype, specs))) {\n\t\t\tERROR(\"Error creating backing store type %s for %s\",\n\t\t\t\tbdevtype ? bdevtype : \"(none)\", c->name);\n\t\t\texit(1);\n\t\t}\n\n\t\t/* save config file again to store the new rootfs location */\n\t\tif (!do_lxcapi_save_config(c, NULL)) {\n\t\t\tERROR(\"failed to save starting configuration for %s\", c->name);\n\t\t\t// parent task won't see bdev in config so we delete it\n\t\t\tbdev->ops->umount(bdev);\n\t\t\tbdev->ops->destroy(bdev);\n\t\t\texit(1);\n\t\t}\n\t\texit(0);\n\t}\n\tif (wait_for_pid(pid) != 0)\n\t\tgoto out_unlock;\n\n\t/* reload config to get the rootfs */\n\tlxc_conf_free(c->lxc_conf);\n\tc->lxc_conf = NULL;\n\tif (!load_config_locked(c, c->configfile))\n\t\tgoto out_unlock;\n\n\tif (!create_run_template(c, tpath, !!(flags & LXC_CREATE_QUIET), argv))\n\t\tgoto out_unlock;\n\n\t// now clear out the lxc_conf we have, reload from the created\n\t// container\n\tdo_lxcapi_clear_config(c);\n\n\tif (t) {\n\t\tif (!prepend_lxc_header(c->configfile, tpath, argv)) {\n\t\t\tERROR(\"Error prepending header to configuration file\");\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\tret = load_config_locked(c, c->configfile);\n\nout_unlock:\n\tif (partial_fd >= 0)\n\t\tremove_partial(c, partial_fd);\nout:\n\tif (!ret)\n\t\tcontainer_destroy(c);\nfree_tpath:\n\tfree(tpath);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Memory allocation error.\""
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ap"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_va_arg_list_to_argv",
          "args": [
            "ap",
            "0",
            "0"
          ],
          "line": 1652
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_va_arg_list_to_argv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "424-462",
          "snippet": "char** lxc_va_arg_list_to_argv(va_list ap, size_t skip, int do_strdup)\n{\n\tva_list ap2;\n\tsize_t count = 1 + skip;\n\tchar **result;\n\n\t/* first determine size of argument list, we don't want to reallocate\n\t * constantly...\n\t */\n\tva_copy(ap2, ap);\n\twhile (1) {\n\t\tchar* arg = va_arg(ap2, char*);\n\t\tif (!arg)\n\t\t\tbreak;\n\t\tcount++;\n\t}\n\tva_end(ap2);\n\n\tresult = calloc(count, sizeof(char*));\n\tif (!result)\n\t\treturn NULL;\n\tcount = skip;\n\twhile (1) {\n\t\tchar* arg = va_arg(ap, char*);\n\t\tif (!arg)\n\t\t\tbreak;\n\t\targ = do_strdup ? strdup(arg) : arg;\n\t\tif (!arg)\n\t\t\tgoto oom;\n\t\tresult[count++] = arg;\n\t}\n\n\t/* calloc has already set last element to NULL*/\n\treturn result;\n\noom:\n\tfree(result);\n\treturn NULL;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar** lxc_va_arg_list_to_argv(va_list ap, size_t skip, int do_strdup)\n{\n\tva_list ap2;\n\tsize_t count = 1 + skip;\n\tchar **result;\n\n\t/* first determine size of argument list, we don't want to reallocate\n\t * constantly...\n\t */\n\tva_copy(ap2, ap);\n\twhile (1) {\n\t\tchar* arg = va_arg(ap2, char*);\n\t\tif (!arg)\n\t\t\tbreak;\n\t\tcount++;\n\t}\n\tva_end(ap2);\n\n\tresult = calloc(count, sizeof(char*));\n\tif (!result)\n\t\treturn NULL;\n\tcount = skip;\n\twhile (1) {\n\t\tchar* arg = va_arg(ap, char*);\n\t\tif (!arg)\n\t\t\tbreak;\n\t\targ = do_strdup ? strdup(arg) : arg;\n\t\tif (!arg)\n\t\t\tgoto oom;\n\t\tresult[count++] = arg;\n\t}\n\n\t/* calloc has already set last element to NULL*/\n\treturn result;\n\noom:\n\tfree(result);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "ap",
            "flags"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool lxcapi_createl(struct lxc_container *c, const char *t,\n\t\tconst char *bdevtype, struct bdev_specs *specs, int flags, ...)\n{\n\tbool bret = false;\n\tchar **args = NULL;\n\tva_list ap;\n\n\tif (!c)\n\t\treturn false;\n\n\tcurrent_config = c->lxc_conf;\n\n\t/*\n\t * since we're going to wait for create to finish, I don't think we\n\t * need to get a copy of the arguments.\n\t */\n\tva_start(ap, flags);\n\targs = lxc_va_arg_list_to_argv(ap, 0, 0);\n\tva_end(ap);\n\tif (!args) {\n\t\tERROR(\"Memory allocation error.\");\n\t\tgoto out;\n\t}\n\n\tbret = do_lxcapi_create(c, t, bdevtype, specs, flags, args);\n\nout:\n\tfree(args);\n\tcurrent_config = NULL;\n\treturn bret;\n}"
  },
  {
    "function_name": "do_lxcapi_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "1602-1631",
    "snippet": "static bool do_lxcapi_shutdown(struct lxc_container *c, int timeout)\n{\n\tbool retv;\n\tpid_t pid;\n\tint haltsignal = SIGPWR;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (!do_lxcapi_is_running(c))\n\t\treturn true;\n\tpid = do_lxcapi_init_pid(c);\n\tif (pid <= 0)\n\t\treturn true;\n\n\t/* Detect whether we should send SIGRTMIN + 3 (e.g. systemd). */\n\tif (task_blocking_signal(pid, (SIGRTMIN + 3)))\n\t\thaltsignal = (SIGRTMIN + 3);\n\n\tif (c->lxc_conf && c->lxc_conf->haltsignal)\n\t\thaltsignal = c->lxc_conf->haltsignal;\n\n\tINFO(\"Using signal number '%d' as halt signal.\", haltsignal);\n\n\tif (kill(pid, haltsignal) < 0)\n\t\tWARN(\"Could not send signal %d to pid %d.\", haltsignal, pid);\n\n\tretv = do_lxcapi_wait(c, \"STOPPED\", timeout);\n\treturn retv;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_lxcapi_wait",
          "args": [
            "c",
            "\"STOPPED\"",
            "timeout"
          ],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "do_lxcapi_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "601-610",
          "snippet": "static bool do_lxcapi_wait(struct lxc_container *c, const char *state, int timeout)\n{\n\tint ret;\n\n\tif (!c)\n\t\treturn false;\n\n\tret = lxc_wait(c->name, state, timeout, c->config_path);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_wait(struct lxc_container *c, const char *state, int timeout)\n{\n\tint ret;\n\n\tif (!c)\n\t\treturn false;\n\n\tret = lxc_wait(c->name, state, timeout, c->config_path);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Could not send signal %d to pid %d.\"",
            "haltsignal",
            "pid"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "pid",
            "haltsignal"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Using signal number '%d' as halt signal.\"",
            "haltsignal"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_blocking_signal",
          "args": [
            "pid",
            "(SIGRTMIN + 3)"
          ],
          "line": 1618
        },
        "resolved": true,
        "details": {
          "function_name": "task_blocking_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1893-1925",
          "snippet": "bool task_blocking_signal(pid_t pid, int signal)\n{\n\tbool bret = false;\n\tchar *line = NULL;\n\tlong unsigned int sigblk = 0;\n\tsize_t n = 0;\n\tint ret;\n\tFILE *f;\n\n\tchar status[__PROC_STATUS_LEN];\n\n\tret = snprintf(status, __PROC_STATUS_LEN, \"/proc/%d/status\", pid);\n\tif (ret < 0 || ret >= __PROC_STATUS_LEN)\n\t\treturn bret;\n\n\tf = fopen(status, \"r\");\n\tif (!f)\n\t\treturn bret;\n\n\twhile (getline(&line, &n, f) != -1) {\n\t\tif (!strncmp(line, \"SigBlk:\\t\", 8))\n\t\t\tif (sscanf(line + 8, \"%lx\", &sigblk) != 1)\n\t\t\t\tgoto out;\n\t}\n\n\tif (sigblk & signal)\n\t\tbret = true;\n\nout:\n\tfree(line);\n\tfclose(f);\n\treturn bret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define __PROC_STATUS_LEN (5 + (LXC_NUMSTRLEN64) + 7 + 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\n#define __PROC_STATUS_LEN (5 + (LXC_NUMSTRLEN64) + 7 + 1)\n\nbool task_blocking_signal(pid_t pid, int signal)\n{\n\tbool bret = false;\n\tchar *line = NULL;\n\tlong unsigned int sigblk = 0;\n\tsize_t n = 0;\n\tint ret;\n\tFILE *f;\n\n\tchar status[__PROC_STATUS_LEN];\n\n\tret = snprintf(status, __PROC_STATUS_LEN, \"/proc/%d/status\", pid);\n\tif (ret < 0 || ret >= __PROC_STATUS_LEN)\n\t\treturn bret;\n\n\tf = fopen(status, \"r\");\n\tif (!f)\n\t\treturn bret;\n\n\twhile (getline(&line, &n, f) != -1) {\n\t\tif (!strncmp(line, \"SigBlk:\\t\", 8))\n\t\t\tif (sscanf(line + 8, \"%lx\", &sigblk) != 1)\n\t\t\t\tgoto out;\n\t}\n\n\tif (sigblk & signal)\n\t\tbret = true;\n\nout:\n\tfree(line);\n\tfclose(f);\n\treturn bret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_lxcapi_init_pid",
          "args": [
            "c"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_lxcapi_is_running",
          "args": [
            "c"
          ],
          "line": 1611
        },
        "resolved": true,
        "details": {
          "function_name": "do_lxcapi_is_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "443-453",
          "snippet": "static bool do_lxcapi_is_running(struct lxc_container *c)\n{\n\tconst char *s;\n\n\tif (!c)\n\t\treturn false;\n\ts = do_lxcapi_state(c);\n\tif (!s || strcmp(s, \"STOPPED\") == 0)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_is_running(struct lxc_container *c)\n{\n\tconst char *s;\n\n\tif (!c)\n\t\treturn false;\n\ts = do_lxcapi_state(c);\n\tif (!s || strcmp(s, \"STOPPED\") == 0)\n\t\treturn false;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_shutdown(struct lxc_container *c, int timeout)\n{\n\tbool retv;\n\tpid_t pid;\n\tint haltsignal = SIGPWR;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (!do_lxcapi_is_running(c))\n\t\treturn true;\n\tpid = do_lxcapi_init_pid(c);\n\tif (pid <= 0)\n\t\treturn true;\n\n\t/* Detect whether we should send SIGRTMIN + 3 (e.g. systemd). */\n\tif (task_blocking_signal(pid, (SIGRTMIN + 3)))\n\t\thaltsignal = (SIGRTMIN + 3);\n\n\tif (c->lxc_conf && c->lxc_conf->haltsignal)\n\t\thaltsignal = c->lxc_conf->haltsignal;\n\n\tINFO(\"Using signal number '%d' as halt signal.\", haltsignal);\n\n\tif (kill(pid, haltsignal) < 0)\n\t\tWARN(\"Could not send signal %d to pid %d.\", haltsignal, pid);\n\n\tretv = do_lxcapi_wait(c, \"STOPPED\", timeout);\n\treturn retv;\n}"
  },
  {
    "function_name": "do_lxcapi_reboot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "1578-1598",
    "snippet": "static bool do_lxcapi_reboot(struct lxc_container *c)\n{\n\tpid_t pid;\n\tint rebootsignal = SIGINT;\n\n\tif (!c)\n\t\treturn false;\n\tif (!do_lxcapi_is_running(c))\n\t\treturn false;\n\tpid = do_lxcapi_init_pid(c);\n\tif (pid <= 0)\n\t\treturn false;\n\tif (c->lxc_conf && c->lxc_conf->rebootsignal)\n\t\trebootsignal = c->lxc_conf->rebootsignal;\n\tif (kill(pid, rebootsignal) < 0) {\n\t\tWARN(\"Could not send signal %d to pid %d.\", rebootsignal, pid);\n\t\treturn false;\n\t}\n\treturn true;\n\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Could not send signal %d to pid %d.\"",
            "rebootsignal",
            "pid"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "pid",
            "rebootsignal"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_lxcapi_init_pid",
          "args": [
            "c"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_lxcapi_is_running",
          "args": [
            "c"
          ],
          "line": 1585
        },
        "resolved": true,
        "details": {
          "function_name": "do_lxcapi_is_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "443-453",
          "snippet": "static bool do_lxcapi_is_running(struct lxc_container *c)\n{\n\tconst char *s;\n\n\tif (!c)\n\t\treturn false;\n\ts = do_lxcapi_state(c);\n\tif (!s || strcmp(s, \"STOPPED\") == 0)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_is_running(struct lxc_container *c)\n{\n\tconst char *s;\n\n\tif (!c)\n\t\treturn false;\n\ts = do_lxcapi_state(c);\n\tif (!s || strcmp(s, \"STOPPED\") == 0)\n\t\treturn false;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_reboot(struct lxc_container *c)\n{\n\tpid_t pid;\n\tint rebootsignal = SIGINT;\n\n\tif (!c)\n\t\treturn false;\n\tif (!do_lxcapi_is_running(c))\n\t\treturn false;\n\tpid = do_lxcapi_init_pid(c);\n\tif (pid <= 0)\n\t\treturn false;\n\tif (c->lxc_conf && c->lxc_conf->rebootsignal)\n\t\trebootsignal = c->lxc_conf->rebootsignal;\n\tif (kill(pid, rebootsignal) < 0) {\n\t\tWARN(\"Could not send signal %d to pid %d.\", rebootsignal, pid);\n\t\treturn false;\n\t}\n\treturn true;\n\n}"
  },
  {
    "function_name": "lxcapi_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "1567-1576",
    "snippet": "static bool lxcapi_create(struct lxc_container *c, const char *t,\n\t\tconst char *bdevtype, struct bdev_specs *specs, int flags,\n\t\tchar *const argv[])\n{\n\tbool ret;\n\tcurrent_config = c ? c->lxc_conf : NULL;\n\tret = do_lxcapi_create(c, t, bdevtype, specs, flags, argv);\n\tcurrent_config = NULL;\n\treturn ret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_lxcapi_create",
          "args": [
            "c",
            "t",
            "bdevtype",
            "specs",
            "flags",
            "argv"
          ],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "do_lxcapi_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "1427-1565",
          "snippet": "static bool do_lxcapi_create(struct lxc_container *c, const char *t,\n\t\tconst char *bdevtype, struct bdev_specs *specs, int flags,\n\t\tchar *const argv[])\n{\n\tbool ret = false;\n\tpid_t pid;\n\tchar *tpath = NULL;\n\tint partial_fd;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (t) {\n\t\ttpath = get_template_path(t);\n\t\tif (!tpath) {\n\t\t\tERROR(\"bad template: %s\", t);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * If a template is passed in, and the rootfs already is defined in\n\t * the container config and exists, then * caller is trying to create\n\t * an existing container.  Return an error, but do NOT delete the\n\t * container.\n\t */\n\tif (do_lxcapi_is_defined(c) && c->lxc_conf && c->lxc_conf->rootfs.path &&\n\t\t\taccess(c->lxc_conf->rootfs.path, F_OK) == 0 && tpath) {\n\t\tERROR(\"Container %s:%s already exists\", c->config_path, c->name);\n\t\tgoto free_tpath;\n\t}\n\n\tif (!c->lxc_conf) {\n\t\tif (!do_lxcapi_load_config(c, lxc_global_config_value(\"lxc.default_config\"))) {\n\t\t\tERROR(\"Error loading default configuration file %s\", lxc_global_config_value(\"lxc.default_config\"));\n\t\t\tgoto free_tpath;\n\t\t}\n\t}\n\n\tif (!create_container_dir(c))\n\t\tgoto free_tpath;\n\n\t/*\n\t * if both template and rootfs.path are set, template is setup as rootfs.path.\n\t * container is already created if we have a config and rootfs.path is accessible\n\t */\n\tif (!c->lxc_conf->rootfs.path && !tpath) {\n\t\t/* no template passed in and rootfs does not exist */\n\t\tif (!c->save_config(c, NULL)) {\n\t\t\tERROR(\"failed to save starting configuration for %s\\n\", c->name);\n\t\t\tgoto out;\n\t\t}\n\t\tret = true;\n\t\tgoto out;\n\t}\n\tif (c->lxc_conf->rootfs.path && access(c->lxc_conf->rootfs.path, F_OK) != 0)\n\t\t/* rootfs passed into configuration, but does not exist: error */\n\t\tgoto out;\n\tif (do_lxcapi_is_defined(c) && c->lxc_conf->rootfs.path && !tpath) {\n\t\t/* Rootfs already existed, user just wanted to save the\n\t\t * loaded configuration */\n\t\tif (!c->save_config(c, NULL))\n\t\t\tERROR(\"failed to save starting configuration for %s\\n\", c->name);\n\t\tret = true;\n\t\tgoto out;\n\t}\n\n\t/* Mark that this container is being created */\n\tif ((partial_fd = create_partial(c)) < 0)\n\t\tgoto out;\n\n\t/* no need to get disk lock bc we have the partial locked */\n\n\t/*\n\t * Create the backing store\n\t * Note we can't do this in the same task as we use to execute the\n\t * template because of the way zfs works.\n\t * After you 'zfs create', zfs mounts the fs only in the initial\n\t * namespace.\n\t */\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"failed to fork task for container creation template\");\n\t\tgoto out_unlock;\n\t}\n\n\tif (pid == 0) { // child\n\t\tstruct bdev *bdev = NULL;\n\n\t\tif (!(bdev = do_bdev_create(c, bdevtype, specs))) {\n\t\t\tERROR(\"Error creating backing store type %s for %s\",\n\t\t\t\tbdevtype ? bdevtype : \"(none)\", c->name);\n\t\t\texit(1);\n\t\t}\n\n\t\t/* save config file again to store the new rootfs location */\n\t\tif (!do_lxcapi_save_config(c, NULL)) {\n\t\t\tERROR(\"failed to save starting configuration for %s\", c->name);\n\t\t\t// parent task won't see bdev in config so we delete it\n\t\t\tbdev->ops->umount(bdev);\n\t\t\tbdev->ops->destroy(bdev);\n\t\t\texit(1);\n\t\t}\n\t\texit(0);\n\t}\n\tif (wait_for_pid(pid) != 0)\n\t\tgoto out_unlock;\n\n\t/* reload config to get the rootfs */\n\tlxc_conf_free(c->lxc_conf);\n\tc->lxc_conf = NULL;\n\tif (!load_config_locked(c, c->configfile))\n\t\tgoto out_unlock;\n\n\tif (!create_run_template(c, tpath, !!(flags & LXC_CREATE_QUIET), argv))\n\t\tgoto out_unlock;\n\n\t// now clear out the lxc_conf we have, reload from the created\n\t// container\n\tdo_lxcapi_clear_config(c);\n\n\tif (t) {\n\t\tif (!prepend_lxc_header(c->configfile, tpath, argv)) {\n\t\t\tERROR(\"Error prepending header to configuration file\");\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\tret = load_config_locked(c, c->configfile);\n\nout_unlock:\n\tif (partial_fd >= 0)\n\t\tremove_partial(c, partial_fd);\nout:\n\tif (!ret)\n\t\tcontainer_destroy(c);\nfree_tpath:\n\tfree(tpath);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_create(struct lxc_container *c, const char *t,\n\t\tconst char *bdevtype, struct bdev_specs *specs, int flags,\n\t\tchar *const argv[])\n{\n\tbool ret = false;\n\tpid_t pid;\n\tchar *tpath = NULL;\n\tint partial_fd;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (t) {\n\t\ttpath = get_template_path(t);\n\t\tif (!tpath) {\n\t\t\tERROR(\"bad template: %s\", t);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * If a template is passed in, and the rootfs already is defined in\n\t * the container config and exists, then * caller is trying to create\n\t * an existing container.  Return an error, but do NOT delete the\n\t * container.\n\t */\n\tif (do_lxcapi_is_defined(c) && c->lxc_conf && c->lxc_conf->rootfs.path &&\n\t\t\taccess(c->lxc_conf->rootfs.path, F_OK) == 0 && tpath) {\n\t\tERROR(\"Container %s:%s already exists\", c->config_path, c->name);\n\t\tgoto free_tpath;\n\t}\n\n\tif (!c->lxc_conf) {\n\t\tif (!do_lxcapi_load_config(c, lxc_global_config_value(\"lxc.default_config\"))) {\n\t\t\tERROR(\"Error loading default configuration file %s\", lxc_global_config_value(\"lxc.default_config\"));\n\t\t\tgoto free_tpath;\n\t\t}\n\t}\n\n\tif (!create_container_dir(c))\n\t\tgoto free_tpath;\n\n\t/*\n\t * if both template and rootfs.path are set, template is setup as rootfs.path.\n\t * container is already created if we have a config and rootfs.path is accessible\n\t */\n\tif (!c->lxc_conf->rootfs.path && !tpath) {\n\t\t/* no template passed in and rootfs does not exist */\n\t\tif (!c->save_config(c, NULL)) {\n\t\t\tERROR(\"failed to save starting configuration for %s\\n\", c->name);\n\t\t\tgoto out;\n\t\t}\n\t\tret = true;\n\t\tgoto out;\n\t}\n\tif (c->lxc_conf->rootfs.path && access(c->lxc_conf->rootfs.path, F_OK) != 0)\n\t\t/* rootfs passed into configuration, but does not exist: error */\n\t\tgoto out;\n\tif (do_lxcapi_is_defined(c) && c->lxc_conf->rootfs.path && !tpath) {\n\t\t/* Rootfs already existed, user just wanted to save the\n\t\t * loaded configuration */\n\t\tif (!c->save_config(c, NULL))\n\t\t\tERROR(\"failed to save starting configuration for %s\\n\", c->name);\n\t\tret = true;\n\t\tgoto out;\n\t}\n\n\t/* Mark that this container is being created */\n\tif ((partial_fd = create_partial(c)) < 0)\n\t\tgoto out;\n\n\t/* no need to get disk lock bc we have the partial locked */\n\n\t/*\n\t * Create the backing store\n\t * Note we can't do this in the same task as we use to execute the\n\t * template because of the way zfs works.\n\t * After you 'zfs create', zfs mounts the fs only in the initial\n\t * namespace.\n\t */\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"failed to fork task for container creation template\");\n\t\tgoto out_unlock;\n\t}\n\n\tif (pid == 0) { // child\n\t\tstruct bdev *bdev = NULL;\n\n\t\tif (!(bdev = do_bdev_create(c, bdevtype, specs))) {\n\t\t\tERROR(\"Error creating backing store type %s for %s\",\n\t\t\t\tbdevtype ? bdevtype : \"(none)\", c->name);\n\t\t\texit(1);\n\t\t}\n\n\t\t/* save config file again to store the new rootfs location */\n\t\tif (!do_lxcapi_save_config(c, NULL)) {\n\t\t\tERROR(\"failed to save starting configuration for %s\", c->name);\n\t\t\t// parent task won't see bdev in config so we delete it\n\t\t\tbdev->ops->umount(bdev);\n\t\t\tbdev->ops->destroy(bdev);\n\t\t\texit(1);\n\t\t}\n\t\texit(0);\n\t}\n\tif (wait_for_pid(pid) != 0)\n\t\tgoto out_unlock;\n\n\t/* reload config to get the rootfs */\n\tlxc_conf_free(c->lxc_conf);\n\tc->lxc_conf = NULL;\n\tif (!load_config_locked(c, c->configfile))\n\t\tgoto out_unlock;\n\n\tif (!create_run_template(c, tpath, !!(flags & LXC_CREATE_QUIET), argv))\n\t\tgoto out_unlock;\n\n\t// now clear out the lxc_conf we have, reload from the created\n\t// container\n\tdo_lxcapi_clear_config(c);\n\n\tif (t) {\n\t\tif (!prepend_lxc_header(c->configfile, tpath, argv)) {\n\t\t\tERROR(\"Error prepending header to configuration file\");\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\tret = load_config_locked(c, c->configfile);\n\nout_unlock:\n\tif (partial_fd >= 0)\n\t\tremove_partial(c, partial_fd);\nout:\n\tif (!ret)\n\t\tcontainer_destroy(c);\nfree_tpath:\n\tfree(tpath);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool lxcapi_create(struct lxc_container *c, const char *t,\n\t\tconst char *bdevtype, struct bdev_specs *specs, int flags,\n\t\tchar *const argv[])\n{\n\tbool ret;\n\tcurrent_config = c ? c->lxc_conf : NULL;\n\tret = do_lxcapi_create(c, t, bdevtype, specs, flags, argv);\n\tcurrent_config = NULL;\n\treturn ret;\n}"
  },
  {
    "function_name": "do_lxcapi_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "1427-1565",
    "snippet": "static bool do_lxcapi_create(struct lxc_container *c, const char *t,\n\t\tconst char *bdevtype, struct bdev_specs *specs, int flags,\n\t\tchar *const argv[])\n{\n\tbool ret = false;\n\tpid_t pid;\n\tchar *tpath = NULL;\n\tint partial_fd;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (t) {\n\t\ttpath = get_template_path(t);\n\t\tif (!tpath) {\n\t\t\tERROR(\"bad template: %s\", t);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * If a template is passed in, and the rootfs already is defined in\n\t * the container config and exists, then * caller is trying to create\n\t * an existing container.  Return an error, but do NOT delete the\n\t * container.\n\t */\n\tif (do_lxcapi_is_defined(c) && c->lxc_conf && c->lxc_conf->rootfs.path &&\n\t\t\taccess(c->lxc_conf->rootfs.path, F_OK) == 0 && tpath) {\n\t\tERROR(\"Container %s:%s already exists\", c->config_path, c->name);\n\t\tgoto free_tpath;\n\t}\n\n\tif (!c->lxc_conf) {\n\t\tif (!do_lxcapi_load_config(c, lxc_global_config_value(\"lxc.default_config\"))) {\n\t\t\tERROR(\"Error loading default configuration file %s\", lxc_global_config_value(\"lxc.default_config\"));\n\t\t\tgoto free_tpath;\n\t\t}\n\t}\n\n\tif (!create_container_dir(c))\n\t\tgoto free_tpath;\n\n\t/*\n\t * if both template and rootfs.path are set, template is setup as rootfs.path.\n\t * container is already created if we have a config and rootfs.path is accessible\n\t */\n\tif (!c->lxc_conf->rootfs.path && !tpath) {\n\t\t/* no template passed in and rootfs does not exist */\n\t\tif (!c->save_config(c, NULL)) {\n\t\t\tERROR(\"failed to save starting configuration for %s\\n\", c->name);\n\t\t\tgoto out;\n\t\t}\n\t\tret = true;\n\t\tgoto out;\n\t}\n\tif (c->lxc_conf->rootfs.path && access(c->lxc_conf->rootfs.path, F_OK) != 0)\n\t\t/* rootfs passed into configuration, but does not exist: error */\n\t\tgoto out;\n\tif (do_lxcapi_is_defined(c) && c->lxc_conf->rootfs.path && !tpath) {\n\t\t/* Rootfs already existed, user just wanted to save the\n\t\t * loaded configuration */\n\t\tif (!c->save_config(c, NULL))\n\t\t\tERROR(\"failed to save starting configuration for %s\\n\", c->name);\n\t\tret = true;\n\t\tgoto out;\n\t}\n\n\t/* Mark that this container is being created */\n\tif ((partial_fd = create_partial(c)) < 0)\n\t\tgoto out;\n\n\t/* no need to get disk lock bc we have the partial locked */\n\n\t/*\n\t * Create the backing store\n\t * Note we can't do this in the same task as we use to execute the\n\t * template because of the way zfs works.\n\t * After you 'zfs create', zfs mounts the fs only in the initial\n\t * namespace.\n\t */\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"failed to fork task for container creation template\");\n\t\tgoto out_unlock;\n\t}\n\n\tif (pid == 0) { // child\n\t\tstruct bdev *bdev = NULL;\n\n\t\tif (!(bdev = do_bdev_create(c, bdevtype, specs))) {\n\t\t\tERROR(\"Error creating backing store type %s for %s\",\n\t\t\t\tbdevtype ? bdevtype : \"(none)\", c->name);\n\t\t\texit(1);\n\t\t}\n\n\t\t/* save config file again to store the new rootfs location */\n\t\tif (!do_lxcapi_save_config(c, NULL)) {\n\t\t\tERROR(\"failed to save starting configuration for %s\", c->name);\n\t\t\t// parent task won't see bdev in config so we delete it\n\t\t\tbdev->ops->umount(bdev);\n\t\t\tbdev->ops->destroy(bdev);\n\t\t\texit(1);\n\t\t}\n\t\texit(0);\n\t}\n\tif (wait_for_pid(pid) != 0)\n\t\tgoto out_unlock;\n\n\t/* reload config to get the rootfs */\n\tlxc_conf_free(c->lxc_conf);\n\tc->lxc_conf = NULL;\n\tif (!load_config_locked(c, c->configfile))\n\t\tgoto out_unlock;\n\n\tif (!create_run_template(c, tpath, !!(flags & LXC_CREATE_QUIET), argv))\n\t\tgoto out_unlock;\n\n\t// now clear out the lxc_conf we have, reload from the created\n\t// container\n\tdo_lxcapi_clear_config(c);\n\n\tif (t) {\n\t\tif (!prepend_lxc_header(c->configfile, tpath, argv)) {\n\t\t\tERROR(\"Error prepending header to configuration file\");\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\tret = load_config_locked(c, c->configfile);\n\nout_unlock:\n\tif (partial_fd >= 0)\n\t\tremove_partial(c, partial_fd);\nout:\n\tif (!ret)\n\t\tcontainer_destroy(c);\nfree_tpath:\n\tfree(tpath);\n\treturn ret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tpath"
          ],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "free_init_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "706-715",
          "snippet": "static void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_destroy",
          "args": [
            "c"
          ],
          "line": 1561
        },
        "resolved": true,
        "details": {
          "function_name": "container_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2338-2421",
          "snippet": "static bool container_destroy(struct lxc_container *c)\n{\n\tbool bret = false;\n\tint ret = 0;\n\tstruct lxc_conf *conf;\n\n\tif (!c || !do_lxcapi_is_defined(c))\n\t\treturn false;\n\n\tconf = c->lxc_conf;\n\tif (container_disk_lock(c))\n\t\treturn false;\n\n\tif (!is_stopped(c)) {\n\t\t// we should queue some sort of error - in c->error_string?\n\t\tERROR(\"container %s is not stopped\", c->name);\n\t\tgoto out;\n\t}\n\n\tif (conf && !lxc_list_empty(&conf->hooks[LXCHOOK_DESTROY])) {\n\t\t/* Start of environment variable setup for hooks */\n\t\tif (c->name && setenv(\"LXC_NAME\", c->name, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for container name\");\n\t\t}\n\t\tif (conf->rcfile && setenv(\"LXC_CONFIG_FILE\", conf->rcfile, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for config path\");\n\t\t}\n\t\tif (conf->rootfs.mount && setenv(\"LXC_ROOTFS_MOUNT\", conf->rootfs.mount, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for rootfs mount\");\n\t\t}\n\t\tif (conf->rootfs.path && setenv(\"LXC_ROOTFS_PATH\", conf->rootfs.path, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for rootfs mount\");\n\t\t}\n\t\tif (conf->console.path && setenv(\"LXC_CONSOLE\", conf->console.path, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for console path\");\n\t\t}\n\t\tif (conf->console.log_path && setenv(\"LXC_CONSOLE_LOGPATH\", conf->console.log_path, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for console log\");\n\t\t}\n\t\t/* End of environment variable setup for hooks */\n\n\t\tif (run_lxc_hooks(c->name, \"destroy\", conf, c->get_config_path(c), NULL)) {\n\t\t\tERROR(\"Error executing clone hook for %s\", c->name);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (current_config && conf == current_config) {\n\t\tcurrent_config = NULL;\n\t\tif (conf->logfd != -1) {\n\t\t\tclose(conf->logfd);\n\t\t\tconf->logfd = -1;\n\t\t}\n\t}\n\n\tif (conf && conf->rootfs.path && conf->rootfs.mount) {\n\t\tif (!do_destroy_container(conf)) {\n\t\t\tERROR(\"Error destroying rootfs for %s\", c->name);\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Destroyed rootfs for %s\", c->name);\n\t}\n\n\tmod_all_rdeps(c, false);\n\n\tconst char *p1 = do_lxcapi_get_config_path(c);\n\tchar *path = alloca(strlen(p1) + strlen(c->name) + 2);\n\tsprintf(path, \"%s/%s\", p1, c->name);\n\tif (am_unpriv())\n\t\tret = userns_exec_1(conf, lxc_rmdir_onedev_wrapper, path);\n\telse\n\t\tret = lxc_rmdir_onedev(path, \"snaps\");\n\tif (ret < 0) {\n\t\tERROR(\"Error destroying container directory for %s\", c->name);\n\t\tgoto out;\n\t}\n\tINFO(\"Destroyed directory for %s\", c->name);\n\n\tbret = true;\n\nout:\n\tcontainer_disk_unlock(c);\n\treturn bret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool container_destroy(struct lxc_container *c)\n{\n\tbool bret = false;\n\tint ret = 0;\n\tstruct lxc_conf *conf;\n\n\tif (!c || !do_lxcapi_is_defined(c))\n\t\treturn false;\n\n\tconf = c->lxc_conf;\n\tif (container_disk_lock(c))\n\t\treturn false;\n\n\tif (!is_stopped(c)) {\n\t\t// we should queue some sort of error - in c->error_string?\n\t\tERROR(\"container %s is not stopped\", c->name);\n\t\tgoto out;\n\t}\n\n\tif (conf && !lxc_list_empty(&conf->hooks[LXCHOOK_DESTROY])) {\n\t\t/* Start of environment variable setup for hooks */\n\t\tif (c->name && setenv(\"LXC_NAME\", c->name, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for container name\");\n\t\t}\n\t\tif (conf->rcfile && setenv(\"LXC_CONFIG_FILE\", conf->rcfile, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for config path\");\n\t\t}\n\t\tif (conf->rootfs.mount && setenv(\"LXC_ROOTFS_MOUNT\", conf->rootfs.mount, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for rootfs mount\");\n\t\t}\n\t\tif (conf->rootfs.path && setenv(\"LXC_ROOTFS_PATH\", conf->rootfs.path, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for rootfs mount\");\n\t\t}\n\t\tif (conf->console.path && setenv(\"LXC_CONSOLE\", conf->console.path, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for console path\");\n\t\t}\n\t\tif (conf->console.log_path && setenv(\"LXC_CONSOLE_LOGPATH\", conf->console.log_path, 1)) {\n\t\t\tSYSERROR(\"failed to set environment variable for console log\");\n\t\t}\n\t\t/* End of environment variable setup for hooks */\n\n\t\tif (run_lxc_hooks(c->name, \"destroy\", conf, c->get_config_path(c), NULL)) {\n\t\t\tERROR(\"Error executing clone hook for %s\", c->name);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (current_config && conf == current_config) {\n\t\tcurrent_config = NULL;\n\t\tif (conf->logfd != -1) {\n\t\t\tclose(conf->logfd);\n\t\t\tconf->logfd = -1;\n\t\t}\n\t}\n\n\tif (conf && conf->rootfs.path && conf->rootfs.mount) {\n\t\tif (!do_destroy_container(conf)) {\n\t\t\tERROR(\"Error destroying rootfs for %s\", c->name);\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Destroyed rootfs for %s\", c->name);\n\t}\n\n\tmod_all_rdeps(c, false);\n\n\tconst char *p1 = do_lxcapi_get_config_path(c);\n\tchar *path = alloca(strlen(p1) + strlen(c->name) + 2);\n\tsprintf(path, \"%s/%s\", p1, c->name);\n\tif (am_unpriv())\n\t\tret = userns_exec_1(conf, lxc_rmdir_onedev_wrapper, path);\n\telse\n\t\tret = lxc_rmdir_onedev(path, \"snaps\");\n\tif (ret < 0) {\n\t\tERROR(\"Error destroying container directory for %s\", c->name);\n\t\tgoto out;\n\t}\n\tINFO(\"Destroyed directory for %s\", c->name);\n\n\tbret = true;\n\nout:\n\tcontainer_disk_unlock(c);\n\treturn bret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_partial",
          "args": [
            "c",
            "partial_fd"
          ],
          "line": 1558
        },
        "resolved": true,
        "details": {
          "function_name": "remove_partial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "199-214",
          "snippet": "static void remove_partial(struct lxc_container *c, int fd)\n{\n\t// $lxcpath + '/' + $name + '/partial' + \\0\n\tint len = strlen(c->config_path) + strlen(c->name) + 10;\n\tchar *path = alloca(len);\n\tint ret;\n\n\tclose(fd);\n\tret = snprintf(path, len, \"%s/%s/partial\", c->config_path, c->name);\n\tif (ret < 0 || ret >= len) {\n\t\tERROR(\"Error writing partial pathname\");\n\t\treturn;\n\t}\n\tif (unlink(path) < 0)\n\t\tSYSERROR(\"Error unlink partial file %s\", path);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic void remove_partial(struct lxc_container *c, int fd)\n{\n\t// $lxcpath + '/' + $name + '/partial' + \\0\n\tint len = strlen(c->config_path) + strlen(c->name) + 10;\n\tchar *path = alloca(len);\n\tint ret;\n\n\tclose(fd);\n\tret = snprintf(path, len, \"%s/%s/partial\", c->config_path, c->name);\n\tif (ret < 0 || ret >= len) {\n\t\tERROR(\"Error writing partial pathname\");\n\t\treturn;\n\t}\n\tif (unlink(path) < 0)\n\t\tSYSERROR(\"Error unlink partial file %s\", path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_config_locked",
          "args": [
            "c",
            "c->configfile"
          ],
          "line": 1554
        },
        "resolved": true,
        "details": {
          "function_name": "load_config_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "521-530",
          "snippet": "static bool load_config_locked(struct lxc_container *c, const char *fname)\n{\n\tif (!c->lxc_conf)\n\t\tc->lxc_conf = lxc_conf_init();\n\tif (!c->lxc_conf)\n\t\treturn false;\n\tif (lxc_config_read(fname, c->lxc_conf, false) != 0)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool load_config_locked(struct lxc_container *c, const char *fname)\n{\n\tif (!c->lxc_conf)\n\t\tc->lxc_conf = lxc_conf_init();\n\tif (!c->lxc_conf)\n\t\treturn false;\n\tif (lxc_config_read(fname, c->lxc_conf, false) != 0)\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error prepending header to configuration file\""
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepend_lxc_header",
          "args": [
            "c->configfile",
            "tpath",
            "argv"
          ],
          "line": 1549
        },
        "resolved": true,
        "details": {
          "function_name": "prepend_lxc_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "1304-1399",
          "snippet": "static bool prepend_lxc_header(char *path, const char *t, char *const argv[])\n{\n\tlong flen;\n\tchar *contents;\n\tFILE *f;\n\tint ret = -1;\n#if HAVE_LIBGNUTLS\n\tint i;\n\tunsigned char md_value[SHA_DIGEST_LENGTH];\n\tchar *tpath;\n#endif\n\n\tf = fopen(path, \"r\");\n\tif (f == NULL)\n\t\treturn false;\n\n\tif (fseek(f, 0, SEEK_END) < 0)\n\t\tgoto out_error;\n\tif ((flen = ftell(f)) < 0)\n\t\tgoto out_error;\n\tif (fseek(f, 0, SEEK_SET) < 0)\n\t\tgoto out_error;\n\tif ((contents = malloc(flen + 1)) == NULL)\n\t\tgoto out_error;\n\tif (fread(contents, 1, flen, f) != flen)\n\t\tgoto out_free_contents;\n\n\tcontents[flen] = '\\0';\n\tret = fclose(f);\n\tf = NULL;\n\tif (ret < 0)\n\t\tgoto out_free_contents;\n\n#if HAVE_LIBGNUTLS\n\ttpath = get_template_path(t);\n\tif (!tpath) {\n\t\tERROR(\"bad template: %s\", t);\n\t\tgoto out_free_contents;\n\t}\n\n\tret = sha1sum_file(tpath, md_value);\n\tif (ret < 0) {\n\t\tERROR(\"Error getting sha1sum of %s\", tpath);\n\t\tfree(tpath);\n\t\tgoto out_free_contents;\n\t}\n\tfree(tpath);\n#endif\n\n\tf = fopen(path, \"w\");\n\tif (f == NULL) {\n\t\tSYSERROR(\"reopening config for writing\");\n\t\tfree(contents);\n\t\treturn false;\n\t}\n\tfprintf(f, \"# Template used to create this container: %s\\n\", t);\n\tif (argv) {\n\t\tfprintf(f, \"# Parameters passed to the template:\");\n\t\twhile (*argv) {\n\t\t\tfprintf(f, \" %s\", *argv);\n\t\t\targv++;\n\t\t}\n\t\tfprintf(f, \"\\n\");\n\t}\n#if HAVE_LIBGNUTLS\n\tfprintf(f, \"# Template script checksum (SHA-1): \");\n\tfor (i=0; i<SHA_DIGEST_LENGTH; i++)\n\t\tfprintf(f, \"%02x\", md_value[i]);\n\tfprintf(f, \"\\n\");\n#endif\n\tfprintf(f, \"# For additional config options, please look at lxc.container.conf(5)\\n\");\n\tfprintf(f, \"\\n# Uncomment the following line to support nesting containers:\\n\");\n\tfprintf(f, \"#lxc.include = \" LXCTEMPLATECONFIG \"/nesting.conf\\n\");\n\tfprintf(f, \"# (Be aware this has security implications)\\n\\n\");\n\tif (fwrite(contents, 1, flen, f) != flen) {\n\t\tSYSERROR(\"Writing original contents\");\n\t\tfree(contents);\n\t\tfclose(f);\n\t\treturn false;\n\t}\n\tret = 0;\nout_free_contents:\n\tfree(contents);\nout_error:\n\tif (f) {\n\t\tint newret;\n\t\tnewret = fclose(f);\n\t\tif (ret == 0)\n\t\t\tret = newret;\n\t}\n\tif (ret < 0) {\n\t\tSYSERROR(\"Error prepending header\");\n\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool prepend_lxc_header(char *path, const char *t, char *const argv[])\n{\n\tlong flen;\n\tchar *contents;\n\tFILE *f;\n\tint ret = -1;\n#if HAVE_LIBGNUTLS\n\tint i;\n\tunsigned char md_value[SHA_DIGEST_LENGTH];\n\tchar *tpath;\n#endif\n\n\tf = fopen(path, \"r\");\n\tif (f == NULL)\n\t\treturn false;\n\n\tif (fseek(f, 0, SEEK_END) < 0)\n\t\tgoto out_error;\n\tif ((flen = ftell(f)) < 0)\n\t\tgoto out_error;\n\tif (fseek(f, 0, SEEK_SET) < 0)\n\t\tgoto out_error;\n\tif ((contents = malloc(flen + 1)) == NULL)\n\t\tgoto out_error;\n\tif (fread(contents, 1, flen, f) != flen)\n\t\tgoto out_free_contents;\n\n\tcontents[flen] = '\\0';\n\tret = fclose(f);\n\tf = NULL;\n\tif (ret < 0)\n\t\tgoto out_free_contents;\n\n#if HAVE_LIBGNUTLS\n\ttpath = get_template_path(t);\n\tif (!tpath) {\n\t\tERROR(\"bad template: %s\", t);\n\t\tgoto out_free_contents;\n\t}\n\n\tret = sha1sum_file(tpath, md_value);\n\tif (ret < 0) {\n\t\tERROR(\"Error getting sha1sum of %s\", tpath);\n\t\tfree(tpath);\n\t\tgoto out_free_contents;\n\t}\n\tfree(tpath);\n#endif\n\n\tf = fopen(path, \"w\");\n\tif (f == NULL) {\n\t\tSYSERROR(\"reopening config for writing\");\n\t\tfree(contents);\n\t\treturn false;\n\t}\n\tfprintf(f, \"# Template used to create this container: %s\\n\", t);\n\tif (argv) {\n\t\tfprintf(f, \"# Parameters passed to the template:\");\n\t\twhile (*argv) {\n\t\t\tfprintf(f, \" %s\", *argv);\n\t\t\targv++;\n\t\t}\n\t\tfprintf(f, \"\\n\");\n\t}\n#if HAVE_LIBGNUTLS\n\tfprintf(f, \"# Template script checksum (SHA-1): \");\n\tfor (i=0; i<SHA_DIGEST_LENGTH; i++)\n\t\tfprintf(f, \"%02x\", md_value[i]);\n\tfprintf(f, \"\\n\");\n#endif\n\tfprintf(f, \"# For additional config options, please look at lxc.container.conf(5)\\n\");\n\tfprintf(f, \"\\n# Uncomment the following line to support nesting containers:\\n\");\n\tfprintf(f, \"#lxc.include = \" LXCTEMPLATECONFIG \"/nesting.conf\\n\");\n\tfprintf(f, \"# (Be aware this has security implications)\\n\\n\");\n\tif (fwrite(contents, 1, flen, f) != flen) {\n\t\tSYSERROR(\"Writing original contents\");\n\t\tfree(contents);\n\t\tfclose(f);\n\t\treturn false;\n\t}\n\tret = 0;\nout_free_contents:\n\tfree(contents);\nout_error:\n\tif (f) {\n\t\tint newret;\n\t\tnewret = fclose(f);\n\t\tif (ret == 0)\n\t\t\tret = newret;\n\t}\n\tif (ret < 0) {\n\t\tSYSERROR(\"Error prepending header\");\n\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_lxcapi_clear_config",
          "args": [
            "c"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_run_template",
          "args": [
            "c",
            "tpath",
            "!!(flags & LXC_CREATE_QUIET)",
            "argv"
          ],
          "line": 1541
        },
        "resolved": true,
        "details": {
          "function_name": "create_run_template",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "1072-1302",
          "snippet": "static bool create_run_template(struct lxc_container *c, char *tpath, bool need_null_stdfds,\n\t\t\t\tchar *const argv[])\n{\n\tpid_t pid;\n\n\tif (!tpath)\n\t\treturn true;\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"failed to fork task for container creation template\");\n\t\treturn false;\n\t}\n\n\tif (pid == 0) { // child\n\t\tchar *patharg, *namearg, *rootfsarg;\n\t\tstruct bdev *bdev = NULL;\n\t\tint i;\n\t\tint ret, len, nargs = 0;\n\t\tchar **newargv;\n\t\tstruct lxc_conf *conf = c->lxc_conf;\n\n\t\tif (need_null_stdfds && null_stdfds() < 0) {\n\t\t\texit(1);\n\t\t}\n\n\t\tbdev = bdev_init(c->lxc_conf, c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);\n\t\tif (!bdev) {\n\t\t\tERROR(\"Error opening rootfs\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (geteuid() == 0) {\n\t\t\tif (unshare(CLONE_NEWNS) < 0) {\n\t\t\t\tERROR(\"error unsharing mounts\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (detect_shared_rootfs()) {\n\t\t\t\tif (mount(NULL, \"/\", NULL, MS_SLAVE|MS_REC, NULL)) {\n\t\t\t\t\tSYSERROR(\"Failed to make / rslave to run template\");\n\t\t\t\t\tERROR(\"Continuing...\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (strcmp(bdev->type, \"dir\") && strcmp(bdev->type, \"btrfs\")) {\n\t\t\tif (geteuid() != 0) {\n\t\t\t\tERROR(\"non-root users can only create btrfs and directory-backed containers\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (bdev->ops->mount(bdev) < 0) {\n\t\t\t\tERROR(\"Error mounting rootfs\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t} else { // TODO come up with a better way here!\n\t\t\tfree(bdev->dest);\n\t\t\tbdev->dest = strdup(bdev->src);\n\t\t}\n\n\t\t/*\n\t\t * create our new array, pre-pend the template name and\n\t\t * base args\n\t\t */\n\t\tif (argv)\n\t\t\tfor (nargs = 0; argv[nargs]; nargs++) ;\n\t\tnargs += 4; // template, path, rootfs and name args\n\n\t\tnewargv = malloc(nargs * sizeof(*newargv));\n\t\tif (!newargv)\n\t\t\texit(1);\n\t\tnewargv[0] = lxcbasename(tpath);\n\n\t\tlen = strlen(c->config_path) + strlen(c->name) + strlen(\"--path=\") + 2;\n\t\tpatharg = malloc(len);\n\t\tif (!patharg)\n\t\t\texit(1);\n\t\tret = snprintf(patharg, len, \"--path=%s/%s\", c->config_path, c->name);\n\t\tif (ret < 0 || ret >= len)\n\t\t\texit(1);\n\t\tnewargv[1] = patharg;\n\t\tlen = strlen(\"--name=\") + strlen(c->name) + 1;\n\t\tnamearg = malloc(len);\n\t\tif (!namearg)\n\t\t\texit(1);\n\t\tret = snprintf(namearg, len, \"--name=%s\", c->name);\n\t\tif (ret < 0 || ret >= len)\n\t\t\texit(1);\n\t\tnewargv[2] = namearg;\n\n\t\tlen = strlen(\"--rootfs=\") + 1 + strlen(bdev->dest);\n\t\trootfsarg = malloc(len);\n\t\tif (!rootfsarg)\n\t\t\texit(1);\n\t\tret = snprintf(rootfsarg, len, \"--rootfs=%s\", bdev->dest);\n\t\tif (ret < 0 || ret >= len)\n\t\t\texit(1);\n\t\tnewargv[3] = rootfsarg;\n\n\t\t/* add passed-in args */\n\t\tif (argv)\n\t\t\tfor (i = 4; i < nargs; i++)\n\t\t\t\tnewargv[i] = argv[i-4];\n\n\t\t/* add trailing NULL */\n\t\tnargs++;\n\t\tnewargv = realloc(newargv, nargs * sizeof(*newargv));\n\t\tif (!newargv)\n\t\t\texit(1);\n\t\tnewargv[nargs - 1] = NULL;\n\n\t\t/*\n\t\t * If we're running the template in a mapped userns, then\n\t\t * we prepend the template command with:\n\t\t * lxc-usernsexec <-m map1> ... <-m mapn> --\n\t\t * and we append \"--mapped-uid x\", where x is the mapped uid\n\t\t * for our geteuid()\n\t\t */\n\t\tif (!lxc_list_empty(&conf->id_map)) {\n\t\t\tint n2args = 1;\n\t\t\tchar txtuid[20];\n\t\t\tchar txtgid[20];\n\t\t\tchar **n2 = malloc(n2args * sizeof(*n2));\n\t\t\tstruct lxc_list *it;\n\t\t\tstruct id_map *map;\n\n\t\t\tif (!n2) {\n\t\t\t\tSYSERROR(\"out of memory\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tnewargv[0] = tpath;\n\t\t\ttpath = \"lxc-usernsexec\";\n\t\t\tn2[0] = \"lxc-usernsexec\";\n\t\t\tlxc_list_for_each(it, &conf->id_map) {\n\t\t\t\tmap = it->elem;\n\t\t\t\tn2args += 2;\n\t\t\t\tn2 = realloc(n2, n2args * sizeof(char *));\n\t\t\t\tif (!n2)\n\t\t\t\t\texit(1);\n\t\t\t\tn2[n2args-2] = \"-m\";\n\t\t\t\tn2[n2args-1] = malloc(200);\n\t\t\t\tif (!n2[n2args-1])\n\t\t\t\t\texit(1);\n\t\t\t\tret = snprintf(n2[n2args-1], 200, \"%c:%lu:%lu:%lu\",\n\t\t\t\t\tmap->idtype == ID_TYPE_UID ? 'u' : 'g',\n\t\t\t\t\tmap->nsid, map->hostid, map->range);\n\t\t\t\tif (ret < 0 || ret >= 200)\n\t\t\t\t\texit(1);\n\t\t\t}\n\t\t\tint hostid_mapped = mapped_hostid(geteuid(), conf, ID_TYPE_UID);\n\t\t\tint extraargs = hostid_mapped >= 0 ? 1 : 3;\n\t\t\tn2 = realloc(n2, (nargs + n2args + extraargs) * sizeof(char *));\n\t\t\tif (!n2)\n\t\t\t\texit(1);\n\t\t\tif (hostid_mapped < 0) {\n\t\t\t\thostid_mapped = find_unmapped_nsuid(conf, ID_TYPE_UID);\n\t\t\t\tn2[n2args++] = \"-m\";\n\t\t\t\tif (hostid_mapped < 0) {\n\t\t\t\t\tERROR(\"Could not find free uid to map\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tn2[n2args++] = malloc(200);\n\t\t\t\tif (!n2[n2args-1]) {\n\t\t\t\t\tSYSERROR(\"out of memory\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tret = snprintf(n2[n2args-1], 200, \"u:%d:%d:1\",\n\t\t\t\t\thostid_mapped, geteuid());\n\t\t\t\tif (ret < 0 || ret >= 200) {\n\t\t\t\t\tERROR(\"string too long\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint hostgid_mapped = mapped_hostid(getegid(), conf, ID_TYPE_GID);\n\t\t\textraargs = hostgid_mapped >= 0 ? 1 : 3;\n\t\t\tn2 = realloc(n2, (nargs + n2args + extraargs) * sizeof(char *));\n\t\t\tif (!n2)\n\t\t\t\texit(1);\n\t\t\tif (hostgid_mapped < 0) {\n\t\t\t\thostgid_mapped = find_unmapped_nsuid(conf, ID_TYPE_GID);\n\t\t\t\tn2[n2args++] = \"-m\";\n\t\t\t\tif (hostgid_mapped < 0) {\n\t\t\t\t\tERROR(\"Could not find free uid to map\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tn2[n2args++] = malloc(200);\n\t\t\t\tif (!n2[n2args-1]) {\n\t\t\t\t\tSYSERROR(\"out of memory\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tret = snprintf(n2[n2args-1], 200, \"g:%d:%d:1\",\n\t\t\t\t\thostgid_mapped, getegid());\n\t\t\t\tif (ret < 0 || ret >= 200) {\n\t\t\t\t\tERROR(\"string too long\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tn2[n2args++] = \"--\";\n\t\t\tfor (i = 0; i < nargs; i++)\n\t\t\t\tn2[i + n2args] = newargv[i];\n\t\t\tn2args += nargs;\n\t\t\t// Finally add \"--mapped-uid $uid\" to tell template what to chown\n\t\t\t// cached images to\n\t\t\tn2args += 4;\n\t\t\tn2 = realloc(n2, n2args * sizeof(char *));\n\t\t\tif (!n2) {\n\t\t\t\tSYSERROR(\"out of memory\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t// note n2[n2args-1] is NULL\n\t\t\tn2[n2args-5] = \"--mapped-uid\";\n\t\t\tsnprintf(txtuid, 20, \"%d\", hostid_mapped);\n\t\t\tn2[n2args-4] = txtuid;\n\t\t\tn2[n2args-3] = \"--mapped-gid\";\n\t\t\tsnprintf(txtgid, 20, \"%d\", hostgid_mapped);\n\t\t\tn2[n2args-2] = txtgid;\n\t\t\tn2[n2args-1] = NULL;\n\t\t\tfree(newargv);\n\t\t\tnewargv = n2;\n\t\t}\n\t\t/* execute */\n\t\texecvp(tpath, newargv);\n\t\tSYSERROR(\"failed to execute template %s\", tpath);\n\t\texit(1);\n\t}\n\n\tif (wait_for_pid(pid) != 0) {\n\t\tERROR(\"container creation template for %s failed\", c->name);\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool create_run_template(struct lxc_container *c, char *tpath, bool need_null_stdfds,\n\t\t\t\tchar *const argv[])\n{\n\tpid_t pid;\n\n\tif (!tpath)\n\t\treturn true;\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"failed to fork task for container creation template\");\n\t\treturn false;\n\t}\n\n\tif (pid == 0) { // child\n\t\tchar *patharg, *namearg, *rootfsarg;\n\t\tstruct bdev *bdev = NULL;\n\t\tint i;\n\t\tint ret, len, nargs = 0;\n\t\tchar **newargv;\n\t\tstruct lxc_conf *conf = c->lxc_conf;\n\n\t\tif (need_null_stdfds && null_stdfds() < 0) {\n\t\t\texit(1);\n\t\t}\n\n\t\tbdev = bdev_init(c->lxc_conf, c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);\n\t\tif (!bdev) {\n\t\t\tERROR(\"Error opening rootfs\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (geteuid() == 0) {\n\t\t\tif (unshare(CLONE_NEWNS) < 0) {\n\t\t\t\tERROR(\"error unsharing mounts\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (detect_shared_rootfs()) {\n\t\t\t\tif (mount(NULL, \"/\", NULL, MS_SLAVE|MS_REC, NULL)) {\n\t\t\t\t\tSYSERROR(\"Failed to make / rslave to run template\");\n\t\t\t\t\tERROR(\"Continuing...\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (strcmp(bdev->type, \"dir\") && strcmp(bdev->type, \"btrfs\")) {\n\t\t\tif (geteuid() != 0) {\n\t\t\t\tERROR(\"non-root users can only create btrfs and directory-backed containers\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (bdev->ops->mount(bdev) < 0) {\n\t\t\t\tERROR(\"Error mounting rootfs\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t} else { // TODO come up with a better way here!\n\t\t\tfree(bdev->dest);\n\t\t\tbdev->dest = strdup(bdev->src);\n\t\t}\n\n\t\t/*\n\t\t * create our new array, pre-pend the template name and\n\t\t * base args\n\t\t */\n\t\tif (argv)\n\t\t\tfor (nargs = 0; argv[nargs]; nargs++) ;\n\t\tnargs += 4; // template, path, rootfs and name args\n\n\t\tnewargv = malloc(nargs * sizeof(*newargv));\n\t\tif (!newargv)\n\t\t\texit(1);\n\t\tnewargv[0] = lxcbasename(tpath);\n\n\t\tlen = strlen(c->config_path) + strlen(c->name) + strlen(\"--path=\") + 2;\n\t\tpatharg = malloc(len);\n\t\tif (!patharg)\n\t\t\texit(1);\n\t\tret = snprintf(patharg, len, \"--path=%s/%s\", c->config_path, c->name);\n\t\tif (ret < 0 || ret >= len)\n\t\t\texit(1);\n\t\tnewargv[1] = patharg;\n\t\tlen = strlen(\"--name=\") + strlen(c->name) + 1;\n\t\tnamearg = malloc(len);\n\t\tif (!namearg)\n\t\t\texit(1);\n\t\tret = snprintf(namearg, len, \"--name=%s\", c->name);\n\t\tif (ret < 0 || ret >= len)\n\t\t\texit(1);\n\t\tnewargv[2] = namearg;\n\n\t\tlen = strlen(\"--rootfs=\") + 1 + strlen(bdev->dest);\n\t\trootfsarg = malloc(len);\n\t\tif (!rootfsarg)\n\t\t\texit(1);\n\t\tret = snprintf(rootfsarg, len, \"--rootfs=%s\", bdev->dest);\n\t\tif (ret < 0 || ret >= len)\n\t\t\texit(1);\n\t\tnewargv[3] = rootfsarg;\n\n\t\t/* add passed-in args */\n\t\tif (argv)\n\t\t\tfor (i = 4; i < nargs; i++)\n\t\t\t\tnewargv[i] = argv[i-4];\n\n\t\t/* add trailing NULL */\n\t\tnargs++;\n\t\tnewargv = realloc(newargv, nargs * sizeof(*newargv));\n\t\tif (!newargv)\n\t\t\texit(1);\n\t\tnewargv[nargs - 1] = NULL;\n\n\t\t/*\n\t\t * If we're running the template in a mapped userns, then\n\t\t * we prepend the template command with:\n\t\t * lxc-usernsexec <-m map1> ... <-m mapn> --\n\t\t * and we append \"--mapped-uid x\", where x is the mapped uid\n\t\t * for our geteuid()\n\t\t */\n\t\tif (!lxc_list_empty(&conf->id_map)) {\n\t\t\tint n2args = 1;\n\t\t\tchar txtuid[20];\n\t\t\tchar txtgid[20];\n\t\t\tchar **n2 = malloc(n2args * sizeof(*n2));\n\t\t\tstruct lxc_list *it;\n\t\t\tstruct id_map *map;\n\n\t\t\tif (!n2) {\n\t\t\t\tSYSERROR(\"out of memory\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tnewargv[0] = tpath;\n\t\t\ttpath = \"lxc-usernsexec\";\n\t\t\tn2[0] = \"lxc-usernsexec\";\n\t\t\tlxc_list_for_each(it, &conf->id_map) {\n\t\t\t\tmap = it->elem;\n\t\t\t\tn2args += 2;\n\t\t\t\tn2 = realloc(n2, n2args * sizeof(char *));\n\t\t\t\tif (!n2)\n\t\t\t\t\texit(1);\n\t\t\t\tn2[n2args-2] = \"-m\";\n\t\t\t\tn2[n2args-1] = malloc(200);\n\t\t\t\tif (!n2[n2args-1])\n\t\t\t\t\texit(1);\n\t\t\t\tret = snprintf(n2[n2args-1], 200, \"%c:%lu:%lu:%lu\",\n\t\t\t\t\tmap->idtype == ID_TYPE_UID ? 'u' : 'g',\n\t\t\t\t\tmap->nsid, map->hostid, map->range);\n\t\t\t\tif (ret < 0 || ret >= 200)\n\t\t\t\t\texit(1);\n\t\t\t}\n\t\t\tint hostid_mapped = mapped_hostid(geteuid(), conf, ID_TYPE_UID);\n\t\t\tint extraargs = hostid_mapped >= 0 ? 1 : 3;\n\t\t\tn2 = realloc(n2, (nargs + n2args + extraargs) * sizeof(char *));\n\t\t\tif (!n2)\n\t\t\t\texit(1);\n\t\t\tif (hostid_mapped < 0) {\n\t\t\t\thostid_mapped = find_unmapped_nsuid(conf, ID_TYPE_UID);\n\t\t\t\tn2[n2args++] = \"-m\";\n\t\t\t\tif (hostid_mapped < 0) {\n\t\t\t\t\tERROR(\"Could not find free uid to map\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tn2[n2args++] = malloc(200);\n\t\t\t\tif (!n2[n2args-1]) {\n\t\t\t\t\tSYSERROR(\"out of memory\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tret = snprintf(n2[n2args-1], 200, \"u:%d:%d:1\",\n\t\t\t\t\thostid_mapped, geteuid());\n\t\t\t\tif (ret < 0 || ret >= 200) {\n\t\t\t\t\tERROR(\"string too long\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint hostgid_mapped = mapped_hostid(getegid(), conf, ID_TYPE_GID);\n\t\t\textraargs = hostgid_mapped >= 0 ? 1 : 3;\n\t\t\tn2 = realloc(n2, (nargs + n2args + extraargs) * sizeof(char *));\n\t\t\tif (!n2)\n\t\t\t\texit(1);\n\t\t\tif (hostgid_mapped < 0) {\n\t\t\t\thostgid_mapped = find_unmapped_nsuid(conf, ID_TYPE_GID);\n\t\t\t\tn2[n2args++] = \"-m\";\n\t\t\t\tif (hostgid_mapped < 0) {\n\t\t\t\t\tERROR(\"Could not find free uid to map\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tn2[n2args++] = malloc(200);\n\t\t\t\tif (!n2[n2args-1]) {\n\t\t\t\t\tSYSERROR(\"out of memory\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tret = snprintf(n2[n2args-1], 200, \"g:%d:%d:1\",\n\t\t\t\t\thostgid_mapped, getegid());\n\t\t\t\tif (ret < 0 || ret >= 200) {\n\t\t\t\t\tERROR(\"string too long\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tn2[n2args++] = \"--\";\n\t\t\tfor (i = 0; i < nargs; i++)\n\t\t\t\tn2[i + n2args] = newargv[i];\n\t\t\tn2args += nargs;\n\t\t\t// Finally add \"--mapped-uid $uid\" to tell template what to chown\n\t\t\t// cached images to\n\t\t\tn2args += 4;\n\t\t\tn2 = realloc(n2, n2args * sizeof(char *));\n\t\t\tif (!n2) {\n\t\t\t\tSYSERROR(\"out of memory\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t// note n2[n2args-1] is NULL\n\t\t\tn2[n2args-5] = \"--mapped-uid\";\n\t\t\tsnprintf(txtuid, 20, \"%d\", hostid_mapped);\n\t\t\tn2[n2args-4] = txtuid;\n\t\t\tn2[n2args-3] = \"--mapped-gid\";\n\t\t\tsnprintf(txtgid, 20, \"%d\", hostgid_mapped);\n\t\t\tn2[n2args-2] = txtgid;\n\t\t\tn2[n2args-1] = NULL;\n\t\t\tfree(newargv);\n\t\t\tnewargv = n2;\n\t\t}\n\t\t/* execute */\n\t\texecvp(tpath, newargv);\n\t\tSYSERROR(\"failed to execute template %s\", tpath);\n\t\texit(1);\n\t}\n\n\tif (wait_for_pid(pid) != 0) {\n\t\tERROR(\"container creation template for %s failed\", c->name);\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_conf_free",
          "args": [
            "c->lxc_conf"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_conf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4289-4328",
          "snippet": "void lxc_conf_free(struct lxc_conf *conf)\n{\n\tif (!conf)\n\t\treturn;\n\tif (current_config == conf)\n\t\tcurrent_config = NULL;\n\tfree(conf->console.log_path);\n\tfree(conf->console.path);\n\tfree(conf->rootfs.mount);\n\tfree(conf->rootfs.bdev_type);\n\tfree(conf->rootfs.options);\n\tfree(conf->rootfs.path);\n\tfree(conf->logfile);\n\tif (conf->logfd != -1)\n\t\tclose(conf->logfd);\n\tfree(conf->utsname);\n\tfree(conf->ttydir);\n\tfree(conf->fstab);\n\tfree(conf->rcfile);\n\tfree(conf->init_cmd);\n\tfree(conf->unexpanded_config);\n\tfree(conf->pty_names);\n\tfree(conf->syslog);\n\tlxc_clear_config_network(conf);\n\tfree(conf->lsm_aa_profile);\n\tfree(conf->lsm_se_context);\n\tlxc_seccomp_free(conf);\n\tlxc_clear_config_caps(conf);\n\tlxc_clear_config_keepcaps(conf);\n\tlxc_clear_cgroups(conf, \"lxc.cgroup\");\n\tlxc_clear_hooks(conf, \"lxc.hook\");\n\tlxc_clear_mount_entries(conf);\n\tlxc_clear_saved_nics(conf);\n\tlxc_clear_idmaps(conf);\n\tlxc_clear_groups(conf);\n\tlxc_clear_includes(conf);\n\tlxc_clear_aliens(conf);\n\tlxc_clear_environment(conf);\n\tfree(conf);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid lxc_conf_free(struct lxc_conf *conf)\n{\n\tif (!conf)\n\t\treturn;\n\tif (current_config == conf)\n\t\tcurrent_config = NULL;\n\tfree(conf->console.log_path);\n\tfree(conf->console.path);\n\tfree(conf->rootfs.mount);\n\tfree(conf->rootfs.bdev_type);\n\tfree(conf->rootfs.options);\n\tfree(conf->rootfs.path);\n\tfree(conf->logfile);\n\tif (conf->logfd != -1)\n\t\tclose(conf->logfd);\n\tfree(conf->utsname);\n\tfree(conf->ttydir);\n\tfree(conf->fstab);\n\tfree(conf->rcfile);\n\tfree(conf->init_cmd);\n\tfree(conf->unexpanded_config);\n\tfree(conf->pty_names);\n\tfree(conf->syslog);\n\tlxc_clear_config_network(conf);\n\tfree(conf->lsm_aa_profile);\n\tfree(conf->lsm_se_context);\n\tlxc_seccomp_free(conf);\n\tlxc_clear_config_caps(conf);\n\tlxc_clear_config_keepcaps(conf);\n\tlxc_clear_cgroups(conf, \"lxc.cgroup\");\n\tlxc_clear_hooks(conf, \"lxc.hook\");\n\tlxc_clear_mount_entries(conf);\n\tlxc_clear_saved_nics(conf);\n\tlxc_clear_idmaps(conf);\n\tlxc_clear_groups(conf);\n\tlxc_clear_includes(conf);\n\tlxc_clear_aliens(conf);\n\tlxc_clear_environment(conf);\n\tfree(conf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_pid",
          "args": [
            "pid"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "311-325",
          "snippet": "int lxc_wait_for_pid_status(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\treturn status;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_wait_for_pid_status(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev->ops->destroy",
          "args": [
            "bdev"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev->ops->umount",
          "args": [
            "bdev"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to save starting configuration for %s\"",
            "c->name"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_lxcapi_save_config",
          "args": [
            "c",
            "NULL"
          ],
          "line": 1523
        },
        "resolved": true,
        "details": {
          "function_name": "do_lxcapi_save_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2040-2091",
          "snippet": "static bool do_lxcapi_save_config(struct lxc_container *c, const char *alt_file)\n{\n\tFILE *fout;\n\tbool ret = false, need_disklock = false;\n\tint lret;\n\n\tif (!alt_file)\n\t\talt_file = c->configfile;\n\tif (!alt_file)\n\t\treturn false; // should we write to stdout if no file is specified?\n\n\t// If we haven't yet loaded a config, load the stock config\n\tif (!c->lxc_conf) {\n\t\tif (!do_lxcapi_load_config(c, lxc_global_config_value(\"lxc.default_config\"))) {\n\t\t\tERROR(\"Error loading default configuration file %s while saving %s\", lxc_global_config_value(\"lxc.default_config\"), c->name);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (!create_container_dir(c))\n\t\treturn false;\n\n\t/*\n\t * If we're writing to the container's config file, take the\n\t * disk lock.  Otherwise just take the memlock to protect the\n\t * struct lxc_container while we're traversing it.\n\t */\n\tif (strcmp(c->configfile, alt_file) == 0)\n\t\tneed_disklock = true;\n\n\tif (need_disklock)\n\t\tlret = container_disk_lock(c);\n\telse\n\t\tlret = container_mem_lock(c);\n\n\tif (lret)\n\t\treturn false;\n\n\tfout = fopen(alt_file, \"w\");\n\tif (!fout)\n\t\tgoto out;\n\twrite_config(fout, c->lxc_conf);\n\tfclose(fout);\n\tret = true;\n\nout:\n\tif (need_disklock)\n\t\tcontainer_disk_unlock(c);\n\telse\n\t\tcontainer_mem_unlock(c);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);",
            "static bool do_lxcapi_save_config(struct lxc_container *c, const char *alt_file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\nstatic bool do_lxcapi_save_config(struct lxc_container *c, const char *alt_file);\n\nstatic bool do_lxcapi_save_config(struct lxc_container *c, const char *alt_file)\n{\n\tFILE *fout;\n\tbool ret = false, need_disklock = false;\n\tint lret;\n\n\tif (!alt_file)\n\t\talt_file = c->configfile;\n\tif (!alt_file)\n\t\treturn false; // should we write to stdout if no file is specified?\n\n\t// If we haven't yet loaded a config, load the stock config\n\tif (!c->lxc_conf) {\n\t\tif (!do_lxcapi_load_config(c, lxc_global_config_value(\"lxc.default_config\"))) {\n\t\t\tERROR(\"Error loading default configuration file %s while saving %s\", lxc_global_config_value(\"lxc.default_config\"), c->name);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (!create_container_dir(c))\n\t\treturn false;\n\n\t/*\n\t * If we're writing to the container's config file, take the\n\t * disk lock.  Otherwise just take the memlock to protect the\n\t * struct lxc_container while we're traversing it.\n\t */\n\tif (strcmp(c->configfile, alt_file) == 0)\n\t\tneed_disklock = true;\n\n\tif (need_disklock)\n\t\tlret = container_disk_lock(c);\n\telse\n\t\tlret = container_mem_lock(c);\n\n\tif (lret)\n\t\treturn false;\n\n\tfout = fopen(alt_file, \"w\");\n\tif (!fout)\n\t\tgoto out;\n\twrite_config(fout, c->lxc_conf);\n\tfclose(fout);\n\tret = true;\n\nout:\n\tif (need_disklock)\n\t\tcontainer_disk_unlock(c);\n\telse\n\t\tcontainer_mem_unlock(c);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error creating backing store type %s for %s\"",
            "bdevtype ? bdevtype : \"(none)\"",
            "c->name"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_bdev_create",
          "args": [
            "c",
            "bdevtype",
            "specs"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "do_bdev_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "1017-1062",
          "snippet": "static struct bdev *do_bdev_create(struct lxc_container *c, const char *type,\n\t\t\t struct bdev_specs *specs)\n{\n\tchar *dest;\n\tsize_t len;\n\tstruct bdev *bdev;\n\tint ret;\n\n\t/* rootfs.path or lxcpath/lxcname/rootfs */\n\tif (c->lxc_conf->rootfs.path && access(c->lxc_conf->rootfs.path, F_OK) == 0) {\n\t\tconst char *rpath = c->lxc_conf->rootfs.path;\n\t\tlen = strlen(rpath) + 1;\n\t\tdest = alloca(len);\n\t\tret = snprintf(dest, len, \"%s\", rpath);\n\t} else {\n\t\tconst char *lxcpath = do_lxcapi_get_config_path(c);\n\t\tlen = strlen(c->name) + strlen(lxcpath) + 9;\n\t\tdest = alloca(len);\n\t\tret = snprintf(dest, len, \"%s/%s/rootfs\", lxcpath, c->name);\n\t}\n\tif (ret < 0 || ret >= len)\n\t\treturn NULL;\n\n\tbdev = bdev_create(dest, type, c->name, specs);\n\tif (!bdev) {\n\t\tERROR(\"Failed to create backing store type %s\", type);\n\t\treturn NULL;\n\t}\n\n\tdo_lxcapi_set_config_item(c, \"lxc.rootfs\", bdev->src);\n\tdo_lxcapi_set_config_item(c, \"lxc.rootfs.backend\", bdev->type);\n\n\t/* if we are not root, chown the rootfs dir to root in the\n\t * target uidmap */\n\n\tif (geteuid() != 0 || (c->lxc_conf && !lxc_list_empty(&c->lxc_conf->id_map))) {\n\t\tif (chown_mapped_root(bdev->dest, c->lxc_conf) < 0) {\n\t\t\tERROR(\"Error chowning %s to container root\", bdev->dest);\n\t\t\tsuggest_default_idmap();\n\t\t\tbdev_put(bdev);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn bdev;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic struct bdev *do_bdev_create(struct lxc_container *c, const char *type,\n\t\t\t struct bdev_specs *specs)\n{\n\tchar *dest;\n\tsize_t len;\n\tstruct bdev *bdev;\n\tint ret;\n\n\t/* rootfs.path or lxcpath/lxcname/rootfs */\n\tif (c->lxc_conf->rootfs.path && access(c->lxc_conf->rootfs.path, F_OK) == 0) {\n\t\tconst char *rpath = c->lxc_conf->rootfs.path;\n\t\tlen = strlen(rpath) + 1;\n\t\tdest = alloca(len);\n\t\tret = snprintf(dest, len, \"%s\", rpath);\n\t} else {\n\t\tconst char *lxcpath = do_lxcapi_get_config_path(c);\n\t\tlen = strlen(c->name) + strlen(lxcpath) + 9;\n\t\tdest = alloca(len);\n\t\tret = snprintf(dest, len, \"%s/%s/rootfs\", lxcpath, c->name);\n\t}\n\tif (ret < 0 || ret >= len)\n\t\treturn NULL;\n\n\tbdev = bdev_create(dest, type, c->name, specs);\n\tif (!bdev) {\n\t\tERROR(\"Failed to create backing store type %s\", type);\n\t\treturn NULL;\n\t}\n\n\tdo_lxcapi_set_config_item(c, \"lxc.rootfs\", bdev->src);\n\tdo_lxcapi_set_config_item(c, \"lxc.rootfs.backend\", bdev->type);\n\n\t/* if we are not root, chown the rootfs dir to root in the\n\t * target uidmap */\n\n\tif (geteuid() != 0 || (c->lxc_conf && !lxc_list_empty(&c->lxc_conf->id_map))) {\n\t\tif (chown_mapped_root(bdev->dest, c->lxc_conf) < 0) {\n\t\t\tERROR(\"Error chowning %s to container root\", bdev->dest);\n\t\t\tsuggest_default_idmap();\n\t\t\tbdev_put(bdev);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn bdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to fork task for container creation template\""
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_partial",
          "args": [
            "c"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "create_partial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "169-197",
          "snippet": "static int create_partial(struct lxc_container *c)\n{\n\t// $lxcpath + '/' + $name + '/partial' + \\0\n\tint len = strlen(c->config_path) + strlen(c->name) + 10;\n\tchar *path = alloca(len);\n\tint fd, ret;\n\tstruct flock lk;\n\n\tret = snprintf(path, len, \"%s/%s/partial\", c->config_path, c->name);\n\tif (ret < 0 || ret >= len) {\n\t\tERROR(\"Error writing partial pathname\");\n\t\treturn -1;\n\t}\n\tif ((fd=open(path, O_RDWR | O_CREAT | O_EXCL, 0755)) < 0) {\n\t\tSYSERROR(\"Error creating partial file\");\n\t\treturn -1;\n\t}\n\tlk.l_type = F_WRLCK;\n\tlk.l_whence = SEEK_SET;\n\tlk.l_start = 0;\n\tlk.l_len = 0;\n\tif (fcntl(fd, F_SETLKW, &lk) < 0) {\n\t\tSYSERROR(\"Error locking partial file %s\", path);\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic int create_partial(struct lxc_container *c)\n{\n\t// $lxcpath + '/' + $name + '/partial' + \\0\n\tint len = strlen(c->config_path) + strlen(c->name) + 10;\n\tchar *path = alloca(len);\n\tint fd, ret;\n\tstruct flock lk;\n\n\tret = snprintf(path, len, \"%s/%s/partial\", c->config_path, c->name);\n\tif (ret < 0 || ret >= len) {\n\t\tERROR(\"Error writing partial pathname\");\n\t\treturn -1;\n\t}\n\tif ((fd=open(path, O_RDWR | O_CREAT | O_EXCL, 0755)) < 0) {\n\t\tSYSERROR(\"Error creating partial file\");\n\t\treturn -1;\n\t}\n\tlk.l_type = F_WRLCK;\n\tlk.l_whence = SEEK_SET;\n\tlk.l_start = 0;\n\tlk.l_len = 0;\n\tif (fcntl(fd, F_SETLKW, &lk) < 0) {\n\t\tSYSERROR(\"Error locking partial file %s\", path);\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to save starting configuration for %s\\n\"",
            "c->name"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->save_config",
          "args": [
            "c",
            "NULL"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_lxcapi_is_defined",
          "args": [
            "c"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "do_lxcapi_is_defined",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "327-348",
          "snippet": "static bool do_lxcapi_is_defined(struct lxc_container *c)\n{\n\tstruct stat statbuf;\n\tbool ret = false;\n\tint statret;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (container_mem_lock(c))\n\t\treturn false;\n\tif (!c->configfile)\n\t\tgoto out;\n\tstatret = stat(c->configfile, &statbuf);\n\tif (statret != 0)\n\t\tgoto out;\n\tret = true;\n\nout:\n\tcontainer_mem_unlock(c);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_is_defined(struct lxc_container *c)\n{\n\tstruct stat statbuf;\n\tbool ret = false;\n\tint statret;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (container_mem_lock(c))\n\t\treturn false;\n\tif (!c->configfile)\n\t\tgoto out;\n\tstatret = stat(c->configfile, &statbuf);\n\tif (statret != 0)\n\t\tgoto out;\n\tret = true;\n\nout:\n\tcontainer_mem_unlock(c);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "c->lxc_conf->rootfs.path",
            "F_OK"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to save starting configuration for %s\\n\"",
            "c->name"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->save_config",
          "args": [
            "c",
            "NULL"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_container_dir",
          "args": [
            "c"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "create_container_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "994-1011",
          "snippet": "static bool create_container_dir(struct lxc_container *c)\n{\n\tchar *s;\n\tint len, ret;\n\n\tlen = strlen(c->config_path) + strlen(c->name) + 2;\n\ts = malloc(len);\n\tif (!s)\n\t\treturn false;\n\tret = snprintf(s, len, \"%s/%s\", c->config_path, c->name);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(s);\n\t\treturn false;\n\t}\n\tret = do_create_container_dir(s, c->lxc_conf);\n\tfree(s);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool create_container_dir(struct lxc_container *c)\n{\n\tchar *s;\n\tint len, ret;\n\n\tlen = strlen(c->config_path) + strlen(c->name) + 2;\n\ts = malloc(len);\n\tif (!s)\n\t\treturn false;\n\tret = snprintf(s, len, \"%s/%s\", c->config_path, c->name);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(s);\n\t\treturn false;\n\t}\n\tret = do_create_container_dir(s, c->lxc_conf);\n\tfree(s);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error loading default configuration file %s\"",
            "lxc_global_config_value(\"lxc.default_config\")"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_global_config_value",
          "args": [
            "\"lxc.default_config\""
          ],
          "line": 1461
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_global_config_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "88-247",
          "snippet": "const char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nconst char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_lxcapi_load_config",
          "args": [
            "c",
            "lxc_global_config_value(\"lxc.default_config\")"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "do_lxcapi_load_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "532-567",
          "snippet": "static bool do_lxcapi_load_config(struct lxc_container *c, const char *alt_file)\n{\n\tbool ret = false, need_disklock = false;\n\tint lret;\n\tconst char *fname;\n\tif (!c)\n\t\treturn false;\n\n\tfname = c->configfile;\n\tif (alt_file)\n\t\tfname = alt_file;\n\tif (!fname)\n\t\treturn false;\n\t/*\n\t * If we're reading something other than the container's config,\n\t * we only need to lock the in-memory container.  If loading the\n\t * container's config file, take the disk lock.\n\t */\n\tif (strcmp(fname, c->configfile) == 0)\n\t\tneed_disklock = true;\n\n\tif (need_disklock)\n\t\tlret = container_disk_lock(c);\n\telse\n\t\tlret = container_mem_lock(c);\n\tif (lret)\n\t\treturn false;\n\n\tret = load_config_locked(c, fname);\n\n\tif (need_disklock)\n\t\tcontainer_disk_unlock(c);\n\telse\n\t\tcontainer_mem_unlock(c);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);",
            "static bool do_lxcapi_save_config(struct lxc_container *c, const char *alt_file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\nstatic bool do_lxcapi_save_config(struct lxc_container *c, const char *alt_file);\n\nstatic bool do_lxcapi_load_config(struct lxc_container *c, const char *alt_file)\n{\n\tbool ret = false, need_disklock = false;\n\tint lret;\n\tconst char *fname;\n\tif (!c)\n\t\treturn false;\n\n\tfname = c->configfile;\n\tif (alt_file)\n\t\tfname = alt_file;\n\tif (!fname)\n\t\treturn false;\n\t/*\n\t * If we're reading something other than the container's config,\n\t * we only need to lock the in-memory container.  If loading the\n\t * container's config file, take the disk lock.\n\t */\n\tif (strcmp(fname, c->configfile) == 0)\n\t\tneed_disklock = true;\n\n\tif (need_disklock)\n\t\tlret = container_disk_lock(c);\n\telse\n\t\tlret = container_mem_lock(c);\n\tif (lret)\n\t\treturn false;\n\n\tret = load_config_locked(c, fname);\n\n\tif (need_disklock)\n\t\tcontainer_disk_unlock(c);\n\telse\n\t\tcontainer_mem_unlock(c);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Container %s:%s already exists\"",
            "c->config_path",
            "c->name"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "c->lxc_conf->rootfs.path",
            "F_OK"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"bad template: %s\"",
            "t"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_template_path",
          "args": [
            "t"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "get_template_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1379-1405",
          "snippet": "char *get_template_path(const char *t)\n{\n\tint ret, len;\n\tchar *tpath;\n\n\tif (t[0] == '/' && access(t, X_OK) == 0) {\n\t\ttpath = strdup(t);\n\t\treturn tpath;\n\t}\n\n\tlen = strlen(LXCTEMPLATEDIR) + strlen(t) + strlen(\"/lxc-\") + 1;\n\ttpath = malloc(len);\n\tif (!tpath)\n\t\treturn NULL;\n\tret = snprintf(tpath, len, \"%s/lxc-%s\", LXCTEMPLATEDIR, t);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(tpath);\n\t\treturn NULL;\n\t}\n\tif (access(tpath, X_OK) < 0) {\n\t\tSYSERROR(\"bad template: %s\", t);\n\t\tfree(tpath);\n\t\treturn NULL;\n\t}\n\n\treturn tpath;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *get_template_path(const char *t)\n{\n\tint ret, len;\n\tchar *tpath;\n\n\tif (t[0] == '/' && access(t, X_OK) == 0) {\n\t\ttpath = strdup(t);\n\t\treturn tpath;\n\t}\n\n\tlen = strlen(LXCTEMPLATEDIR) + strlen(t) + strlen(\"/lxc-\") + 1;\n\ttpath = malloc(len);\n\tif (!tpath)\n\t\treturn NULL;\n\tret = snprintf(tpath, len, \"%s/lxc-%s\", LXCTEMPLATEDIR, t);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(tpath);\n\t\treturn NULL;\n\t}\n\tif (access(tpath, X_OK) < 0) {\n\t\tSYSERROR(\"bad template: %s\", t);\n\t\tfree(tpath);\n\t\treturn NULL;\n\t}\n\n\treturn tpath;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_create(struct lxc_container *c, const char *t,\n\t\tconst char *bdevtype, struct bdev_specs *specs, int flags,\n\t\tchar *const argv[])\n{\n\tbool ret = false;\n\tpid_t pid;\n\tchar *tpath = NULL;\n\tint partial_fd;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (t) {\n\t\ttpath = get_template_path(t);\n\t\tif (!tpath) {\n\t\t\tERROR(\"bad template: %s\", t);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * If a template is passed in, and the rootfs already is defined in\n\t * the container config and exists, then * caller is trying to create\n\t * an existing container.  Return an error, but do NOT delete the\n\t * container.\n\t */\n\tif (do_lxcapi_is_defined(c) && c->lxc_conf && c->lxc_conf->rootfs.path &&\n\t\t\taccess(c->lxc_conf->rootfs.path, F_OK) == 0 && tpath) {\n\t\tERROR(\"Container %s:%s already exists\", c->config_path, c->name);\n\t\tgoto free_tpath;\n\t}\n\n\tif (!c->lxc_conf) {\n\t\tif (!do_lxcapi_load_config(c, lxc_global_config_value(\"lxc.default_config\"))) {\n\t\t\tERROR(\"Error loading default configuration file %s\", lxc_global_config_value(\"lxc.default_config\"));\n\t\t\tgoto free_tpath;\n\t\t}\n\t}\n\n\tif (!create_container_dir(c))\n\t\tgoto free_tpath;\n\n\t/*\n\t * if both template and rootfs.path are set, template is setup as rootfs.path.\n\t * container is already created if we have a config and rootfs.path is accessible\n\t */\n\tif (!c->lxc_conf->rootfs.path && !tpath) {\n\t\t/* no template passed in and rootfs does not exist */\n\t\tif (!c->save_config(c, NULL)) {\n\t\t\tERROR(\"failed to save starting configuration for %s\\n\", c->name);\n\t\t\tgoto out;\n\t\t}\n\t\tret = true;\n\t\tgoto out;\n\t}\n\tif (c->lxc_conf->rootfs.path && access(c->lxc_conf->rootfs.path, F_OK) != 0)\n\t\t/* rootfs passed into configuration, but does not exist: error */\n\t\tgoto out;\n\tif (do_lxcapi_is_defined(c) && c->lxc_conf->rootfs.path && !tpath) {\n\t\t/* Rootfs already existed, user just wanted to save the\n\t\t * loaded configuration */\n\t\tif (!c->save_config(c, NULL))\n\t\t\tERROR(\"failed to save starting configuration for %s\\n\", c->name);\n\t\tret = true;\n\t\tgoto out;\n\t}\n\n\t/* Mark that this container is being created */\n\tif ((partial_fd = create_partial(c)) < 0)\n\t\tgoto out;\n\n\t/* no need to get disk lock bc we have the partial locked */\n\n\t/*\n\t * Create the backing store\n\t * Note we can't do this in the same task as we use to execute the\n\t * template because of the way zfs works.\n\t * After you 'zfs create', zfs mounts the fs only in the initial\n\t * namespace.\n\t */\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"failed to fork task for container creation template\");\n\t\tgoto out_unlock;\n\t}\n\n\tif (pid == 0) { // child\n\t\tstruct bdev *bdev = NULL;\n\n\t\tif (!(bdev = do_bdev_create(c, bdevtype, specs))) {\n\t\t\tERROR(\"Error creating backing store type %s for %s\",\n\t\t\t\tbdevtype ? bdevtype : \"(none)\", c->name);\n\t\t\texit(1);\n\t\t}\n\n\t\t/* save config file again to store the new rootfs location */\n\t\tif (!do_lxcapi_save_config(c, NULL)) {\n\t\t\tERROR(\"failed to save starting configuration for %s\", c->name);\n\t\t\t// parent task won't see bdev in config so we delete it\n\t\t\tbdev->ops->umount(bdev);\n\t\t\tbdev->ops->destroy(bdev);\n\t\t\texit(1);\n\t\t}\n\t\texit(0);\n\t}\n\tif (wait_for_pid(pid) != 0)\n\t\tgoto out_unlock;\n\n\t/* reload config to get the rootfs */\n\tlxc_conf_free(c->lxc_conf);\n\tc->lxc_conf = NULL;\n\tif (!load_config_locked(c, c->configfile))\n\t\tgoto out_unlock;\n\n\tif (!create_run_template(c, tpath, !!(flags & LXC_CREATE_QUIET), argv))\n\t\tgoto out_unlock;\n\n\t// now clear out the lxc_conf we have, reload from the created\n\t// container\n\tdo_lxcapi_clear_config(c);\n\n\tif (t) {\n\t\tif (!prepend_lxc_header(c->configfile, tpath, argv)) {\n\t\t\tERROR(\"Error prepending header to configuration file\");\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\tret = load_config_locked(c, c->configfile);\n\nout_unlock:\n\tif (partial_fd >= 0)\n\t\tremove_partial(c, partial_fd);\nout:\n\tif (!ret)\n\t\tcontainer_destroy(c);\nfree_tpath:\n\tfree(tpath);\n\treturn ret;\n}"
  },
  {
    "function_name": "lxcapi_clear_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "1401-1409",
    "snippet": "static void lxcapi_clear_config(struct lxc_container *c)\n{\n\tif (c) {\n\t\tif (c->lxc_conf) {\n\t\t\tlxc_conf_free(c->lxc_conf);\n\t\t\tc->lxc_conf = NULL;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_conf_free",
          "args": [
            "c->lxc_conf"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_conf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4289-4328",
          "snippet": "void lxc_conf_free(struct lxc_conf *conf)\n{\n\tif (!conf)\n\t\treturn;\n\tif (current_config == conf)\n\t\tcurrent_config = NULL;\n\tfree(conf->console.log_path);\n\tfree(conf->console.path);\n\tfree(conf->rootfs.mount);\n\tfree(conf->rootfs.bdev_type);\n\tfree(conf->rootfs.options);\n\tfree(conf->rootfs.path);\n\tfree(conf->logfile);\n\tif (conf->logfd != -1)\n\t\tclose(conf->logfd);\n\tfree(conf->utsname);\n\tfree(conf->ttydir);\n\tfree(conf->fstab);\n\tfree(conf->rcfile);\n\tfree(conf->init_cmd);\n\tfree(conf->unexpanded_config);\n\tfree(conf->pty_names);\n\tfree(conf->syslog);\n\tlxc_clear_config_network(conf);\n\tfree(conf->lsm_aa_profile);\n\tfree(conf->lsm_se_context);\n\tlxc_seccomp_free(conf);\n\tlxc_clear_config_caps(conf);\n\tlxc_clear_config_keepcaps(conf);\n\tlxc_clear_cgroups(conf, \"lxc.cgroup\");\n\tlxc_clear_hooks(conf, \"lxc.hook\");\n\tlxc_clear_mount_entries(conf);\n\tlxc_clear_saved_nics(conf);\n\tlxc_clear_idmaps(conf);\n\tlxc_clear_groups(conf);\n\tlxc_clear_includes(conf);\n\tlxc_clear_aliens(conf);\n\tlxc_clear_environment(conf);\n\tfree(conf);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid lxc_conf_free(struct lxc_conf *conf)\n{\n\tif (!conf)\n\t\treturn;\n\tif (current_config == conf)\n\t\tcurrent_config = NULL;\n\tfree(conf->console.log_path);\n\tfree(conf->console.path);\n\tfree(conf->rootfs.mount);\n\tfree(conf->rootfs.bdev_type);\n\tfree(conf->rootfs.options);\n\tfree(conf->rootfs.path);\n\tfree(conf->logfile);\n\tif (conf->logfd != -1)\n\t\tclose(conf->logfd);\n\tfree(conf->utsname);\n\tfree(conf->ttydir);\n\tfree(conf->fstab);\n\tfree(conf->rcfile);\n\tfree(conf->init_cmd);\n\tfree(conf->unexpanded_config);\n\tfree(conf->pty_names);\n\tfree(conf->syslog);\n\tlxc_clear_config_network(conf);\n\tfree(conf->lsm_aa_profile);\n\tfree(conf->lsm_se_context);\n\tlxc_seccomp_free(conf);\n\tlxc_clear_config_caps(conf);\n\tlxc_clear_config_keepcaps(conf);\n\tlxc_clear_cgroups(conf, \"lxc.cgroup\");\n\tlxc_clear_hooks(conf, \"lxc.hook\");\n\tlxc_clear_mount_entries(conf);\n\tlxc_clear_saved_nics(conf);\n\tlxc_clear_idmaps(conf);\n\tlxc_clear_groups(conf);\n\tlxc_clear_includes(conf);\n\tlxc_clear_aliens(conf);\n\tlxc_clear_environment(conf);\n\tfree(conf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic void lxcapi_clear_config(struct lxc_container *c)\n{\n\tif (c) {\n\t\tif (c->lxc_conf) {\n\t\t\tlxc_conf_free(c->lxc_conf);\n\t\t\tc->lxc_conf = NULL;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "prepend_lxc_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "1304-1399",
    "snippet": "static bool prepend_lxc_header(char *path, const char *t, char *const argv[])\n{\n\tlong flen;\n\tchar *contents;\n\tFILE *f;\n\tint ret = -1;\n#if HAVE_LIBGNUTLS\n\tint i;\n\tunsigned char md_value[SHA_DIGEST_LENGTH];\n\tchar *tpath;\n#endif\n\n\tf = fopen(path, \"r\");\n\tif (f == NULL)\n\t\treturn false;\n\n\tif (fseek(f, 0, SEEK_END) < 0)\n\t\tgoto out_error;\n\tif ((flen = ftell(f)) < 0)\n\t\tgoto out_error;\n\tif (fseek(f, 0, SEEK_SET) < 0)\n\t\tgoto out_error;\n\tif ((contents = malloc(flen + 1)) == NULL)\n\t\tgoto out_error;\n\tif (fread(contents, 1, flen, f) != flen)\n\t\tgoto out_free_contents;\n\n\tcontents[flen] = '\\0';\n\tret = fclose(f);\n\tf = NULL;\n\tif (ret < 0)\n\t\tgoto out_free_contents;\n\n#if HAVE_LIBGNUTLS\n\ttpath = get_template_path(t);\n\tif (!tpath) {\n\t\tERROR(\"bad template: %s\", t);\n\t\tgoto out_free_contents;\n\t}\n\n\tret = sha1sum_file(tpath, md_value);\n\tif (ret < 0) {\n\t\tERROR(\"Error getting sha1sum of %s\", tpath);\n\t\tfree(tpath);\n\t\tgoto out_free_contents;\n\t}\n\tfree(tpath);\n#endif\n\n\tf = fopen(path, \"w\");\n\tif (f == NULL) {\n\t\tSYSERROR(\"reopening config for writing\");\n\t\tfree(contents);\n\t\treturn false;\n\t}\n\tfprintf(f, \"# Template used to create this container: %s\\n\", t);\n\tif (argv) {\n\t\tfprintf(f, \"# Parameters passed to the template:\");\n\t\twhile (*argv) {\n\t\t\tfprintf(f, \" %s\", *argv);\n\t\t\targv++;\n\t\t}\n\t\tfprintf(f, \"\\n\");\n\t}\n#if HAVE_LIBGNUTLS\n\tfprintf(f, \"# Template script checksum (SHA-1): \");\n\tfor (i=0; i<SHA_DIGEST_LENGTH; i++)\n\t\tfprintf(f, \"%02x\", md_value[i]);\n\tfprintf(f, \"\\n\");\n#endif\n\tfprintf(f, \"# For additional config options, please look at lxc.container.conf(5)\\n\");\n\tfprintf(f, \"\\n# Uncomment the following line to support nesting containers:\\n\");\n\tfprintf(f, \"#lxc.include = \" LXCTEMPLATECONFIG \"/nesting.conf\\n\");\n\tfprintf(f, \"# (Be aware this has security implications)\\n\\n\");\n\tif (fwrite(contents, 1, flen, f) != flen) {\n\t\tSYSERROR(\"Writing original contents\");\n\t\tfree(contents);\n\t\tfclose(f);\n\t\treturn false;\n\t}\n\tret = 0;\nout_free_contents:\n\tfree(contents);\nout_error:\n\tif (f) {\n\t\tint newret;\n\t\tnewret = fclose(f);\n\t\tif (ret == 0)\n\t\t\tret = newret;\n\t}\n\tif (ret < 0) {\n\t\tSYSERROR(\"Error prepending header\");\n\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error prepending header\""
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "contents"
          ],
          "line": 1386
        },
        "resolved": true,
        "details": {
          "function_name": "free_init_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "706-715",
          "snippet": "static void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Writing original contents\""
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fwrite",
          "args": [
            "contents",
            "1",
            "flen",
            "f"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"# (Be aware this has security implications)\\n\\n\""
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"#lxc.include = \" LXCTEMPLATECONFIG \"/nesting.conf\\n\""
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"\\n# Uncomment the following line to support nesting containers:\\n\""
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"# For additional config options, please look at lxc.container.conf(5)\\n\""
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"\\n\""
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"%02x\"",
            "md_value[i]"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"# Template script checksum (SHA-1): \""
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"\\n\""
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\" %s\"",
            "*argv"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"# Parameters passed to the template:\""
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"# Template used to create this container: %s\\n\"",
            "t"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"reopening config for writing\""
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "path",
            "\"w\""
          ],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error getting sha1sum of %s\"",
            "tpath"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sha1sum_file",
          "args": [
            "tpath",
            "md_value"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "sha1sum_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "372-421",
          "snippet": "int sha1sum_file(char *fnam, unsigned char *digest)\n{\n\tchar *buf;\n\tint ret;\n\tFILE *f;\n\tlong flen;\n\n\tif (!fnam)\n\t\treturn -1;\n\tf = fopen_cloexec(fnam, \"r\");\n\tif (!f) {\n\t\tSYSERROR(\"Error opening template\");\n\t\treturn -1;\n\t}\n\tif (fseek(f, 0, SEEK_END) < 0) {\n\t\tSYSERROR(\"Error seeking to end of template\");\n\t\tfclose(f);\n\t\treturn -1;\n\t}\n\tif ((flen = ftell(f)) < 0) {\n\t\tSYSERROR(\"Error telling size of template\");\n\t\tfclose(f);\n\t\treturn -1;\n\t}\n\tif (fseek(f, 0, SEEK_SET) < 0) {\n\t\tSYSERROR(\"Error seeking to start of template\");\n\t\tfclose(f);\n\t\treturn -1;\n\t}\n\tif ((buf = malloc(flen+1)) == NULL) {\n\t\tSYSERROR(\"Out of memory\");\n\t\tfclose(f);\n\t\treturn -1;\n\t}\n\tif (fread(buf, 1, flen, f) != flen) {\n\t\tSYSERROR(\"Failure reading template\");\n\t\tfree(buf);\n\t\tfclose(f);\n\t\treturn -1;\n\t}\n\tif (fclose(f) < 0) {\n\t\tSYSERROR(\"Failre closing template\");\n\t\tfree(buf);\n\t\treturn -1;\n\t}\n\tbuf[flen] = '\\0';\n\tret = gnutls_hash_fast(GNUTLS_DIG_SHA1, buf, flen, (void *)digest);\n\tfree(buf);\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint sha1sum_file(char *fnam, unsigned char *digest)\n{\n\tchar *buf;\n\tint ret;\n\tFILE *f;\n\tlong flen;\n\n\tif (!fnam)\n\t\treturn -1;\n\tf = fopen_cloexec(fnam, \"r\");\n\tif (!f) {\n\t\tSYSERROR(\"Error opening template\");\n\t\treturn -1;\n\t}\n\tif (fseek(f, 0, SEEK_END) < 0) {\n\t\tSYSERROR(\"Error seeking to end of template\");\n\t\tfclose(f);\n\t\treturn -1;\n\t}\n\tif ((flen = ftell(f)) < 0) {\n\t\tSYSERROR(\"Error telling size of template\");\n\t\tfclose(f);\n\t\treturn -1;\n\t}\n\tif (fseek(f, 0, SEEK_SET) < 0) {\n\t\tSYSERROR(\"Error seeking to start of template\");\n\t\tfclose(f);\n\t\treturn -1;\n\t}\n\tif ((buf = malloc(flen+1)) == NULL) {\n\t\tSYSERROR(\"Out of memory\");\n\t\tfclose(f);\n\t\treturn -1;\n\t}\n\tif (fread(buf, 1, flen, f) != flen) {\n\t\tSYSERROR(\"Failure reading template\");\n\t\tfree(buf);\n\t\tfclose(f);\n\t\treturn -1;\n\t}\n\tif (fclose(f) < 0) {\n\t\tSYSERROR(\"Failre closing template\");\n\t\tfree(buf);\n\t\treturn -1;\n\t}\n\tbuf[flen] = '\\0';\n\tret = gnutls_hash_fast(GNUTLS_DIG_SHA1, buf, flen, (void *)digest);\n\tfree(buf);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"bad template: %s\"",
            "t"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_template_path",
          "args": [
            "t"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "get_template_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1379-1405",
          "snippet": "char *get_template_path(const char *t)\n{\n\tint ret, len;\n\tchar *tpath;\n\n\tif (t[0] == '/' && access(t, X_OK) == 0) {\n\t\ttpath = strdup(t);\n\t\treturn tpath;\n\t}\n\n\tlen = strlen(LXCTEMPLATEDIR) + strlen(t) + strlen(\"/lxc-\") + 1;\n\ttpath = malloc(len);\n\tif (!tpath)\n\t\treturn NULL;\n\tret = snprintf(tpath, len, \"%s/lxc-%s\", LXCTEMPLATEDIR, t);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(tpath);\n\t\treturn NULL;\n\t}\n\tif (access(tpath, X_OK) < 0) {\n\t\tSYSERROR(\"bad template: %s\", t);\n\t\tfree(tpath);\n\t\treturn NULL;\n\t}\n\n\treturn tpath;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *get_template_path(const char *t)\n{\n\tint ret, len;\n\tchar *tpath;\n\n\tif (t[0] == '/' && access(t, X_OK) == 0) {\n\t\ttpath = strdup(t);\n\t\treturn tpath;\n\t}\n\n\tlen = strlen(LXCTEMPLATEDIR) + strlen(t) + strlen(\"/lxc-\") + 1;\n\ttpath = malloc(len);\n\tif (!tpath)\n\t\treturn NULL;\n\tret = snprintf(tpath, len, \"%s/lxc-%s\", LXCTEMPLATEDIR, t);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(tpath);\n\t\treturn NULL;\n\t}\n\tif (access(tpath, X_OK) < 0) {\n\t\tSYSERROR(\"bad template: %s\", t);\n\t\tfree(tpath);\n\t\treturn NULL;\n\t}\n\n\treturn tpath;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "contents",
            "1",
            "flen",
            "f"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "flen + 1"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fseek",
          "args": [
            "f",
            "0",
            "SEEK_SET"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftell",
          "args": [
            "f"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fseek",
          "args": [
            "f",
            "0",
            "SEEK_END"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool prepend_lxc_header(char *path, const char *t, char *const argv[])\n{\n\tlong flen;\n\tchar *contents;\n\tFILE *f;\n\tint ret = -1;\n#if HAVE_LIBGNUTLS\n\tint i;\n\tunsigned char md_value[SHA_DIGEST_LENGTH];\n\tchar *tpath;\n#endif\n\n\tf = fopen(path, \"r\");\n\tif (f == NULL)\n\t\treturn false;\n\n\tif (fseek(f, 0, SEEK_END) < 0)\n\t\tgoto out_error;\n\tif ((flen = ftell(f)) < 0)\n\t\tgoto out_error;\n\tif (fseek(f, 0, SEEK_SET) < 0)\n\t\tgoto out_error;\n\tif ((contents = malloc(flen + 1)) == NULL)\n\t\tgoto out_error;\n\tif (fread(contents, 1, flen, f) != flen)\n\t\tgoto out_free_contents;\n\n\tcontents[flen] = '\\0';\n\tret = fclose(f);\n\tf = NULL;\n\tif (ret < 0)\n\t\tgoto out_free_contents;\n\n#if HAVE_LIBGNUTLS\n\ttpath = get_template_path(t);\n\tif (!tpath) {\n\t\tERROR(\"bad template: %s\", t);\n\t\tgoto out_free_contents;\n\t}\n\n\tret = sha1sum_file(tpath, md_value);\n\tif (ret < 0) {\n\t\tERROR(\"Error getting sha1sum of %s\", tpath);\n\t\tfree(tpath);\n\t\tgoto out_free_contents;\n\t}\n\tfree(tpath);\n#endif\n\n\tf = fopen(path, \"w\");\n\tif (f == NULL) {\n\t\tSYSERROR(\"reopening config for writing\");\n\t\tfree(contents);\n\t\treturn false;\n\t}\n\tfprintf(f, \"# Template used to create this container: %s\\n\", t);\n\tif (argv) {\n\t\tfprintf(f, \"# Parameters passed to the template:\");\n\t\twhile (*argv) {\n\t\t\tfprintf(f, \" %s\", *argv);\n\t\t\targv++;\n\t\t}\n\t\tfprintf(f, \"\\n\");\n\t}\n#if HAVE_LIBGNUTLS\n\tfprintf(f, \"# Template script checksum (SHA-1): \");\n\tfor (i=0; i<SHA_DIGEST_LENGTH; i++)\n\t\tfprintf(f, \"%02x\", md_value[i]);\n\tfprintf(f, \"\\n\");\n#endif\n\tfprintf(f, \"# For additional config options, please look at lxc.container.conf(5)\\n\");\n\tfprintf(f, \"\\n# Uncomment the following line to support nesting containers:\\n\");\n\tfprintf(f, \"#lxc.include = \" LXCTEMPLATECONFIG \"/nesting.conf\\n\");\n\tfprintf(f, \"# (Be aware this has security implications)\\n\\n\");\n\tif (fwrite(contents, 1, flen, f) != flen) {\n\t\tSYSERROR(\"Writing original contents\");\n\t\tfree(contents);\n\t\tfclose(f);\n\t\treturn false;\n\t}\n\tret = 0;\nout_free_contents:\n\tfree(contents);\nout_error:\n\tif (f) {\n\t\tint newret;\n\t\tnewret = fclose(f);\n\t\tif (ret == 0)\n\t\t\tret = newret;\n\t}\n\tif (ret < 0) {\n\t\tSYSERROR(\"Error prepending header\");\n\t\treturn false;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "create_run_template",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "1072-1302",
    "snippet": "static bool create_run_template(struct lxc_container *c, char *tpath, bool need_null_stdfds,\n\t\t\t\tchar *const argv[])\n{\n\tpid_t pid;\n\n\tif (!tpath)\n\t\treturn true;\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"failed to fork task for container creation template\");\n\t\treturn false;\n\t}\n\n\tif (pid == 0) { // child\n\t\tchar *patharg, *namearg, *rootfsarg;\n\t\tstruct bdev *bdev = NULL;\n\t\tint i;\n\t\tint ret, len, nargs = 0;\n\t\tchar **newargv;\n\t\tstruct lxc_conf *conf = c->lxc_conf;\n\n\t\tif (need_null_stdfds && null_stdfds() < 0) {\n\t\t\texit(1);\n\t\t}\n\n\t\tbdev = bdev_init(c->lxc_conf, c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);\n\t\tif (!bdev) {\n\t\t\tERROR(\"Error opening rootfs\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (geteuid() == 0) {\n\t\t\tif (unshare(CLONE_NEWNS) < 0) {\n\t\t\t\tERROR(\"error unsharing mounts\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (detect_shared_rootfs()) {\n\t\t\t\tif (mount(NULL, \"/\", NULL, MS_SLAVE|MS_REC, NULL)) {\n\t\t\t\t\tSYSERROR(\"Failed to make / rslave to run template\");\n\t\t\t\t\tERROR(\"Continuing...\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (strcmp(bdev->type, \"dir\") && strcmp(bdev->type, \"btrfs\")) {\n\t\t\tif (geteuid() != 0) {\n\t\t\t\tERROR(\"non-root users can only create btrfs and directory-backed containers\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (bdev->ops->mount(bdev) < 0) {\n\t\t\t\tERROR(\"Error mounting rootfs\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t} else { // TODO come up with a better way here!\n\t\t\tfree(bdev->dest);\n\t\t\tbdev->dest = strdup(bdev->src);\n\t\t}\n\n\t\t/*\n\t\t * create our new array, pre-pend the template name and\n\t\t * base args\n\t\t */\n\t\tif (argv)\n\t\t\tfor (nargs = 0; argv[nargs]; nargs++) ;\n\t\tnargs += 4; // template, path, rootfs and name args\n\n\t\tnewargv = malloc(nargs * sizeof(*newargv));\n\t\tif (!newargv)\n\t\t\texit(1);\n\t\tnewargv[0] = lxcbasename(tpath);\n\n\t\tlen = strlen(c->config_path) + strlen(c->name) + strlen(\"--path=\") + 2;\n\t\tpatharg = malloc(len);\n\t\tif (!patharg)\n\t\t\texit(1);\n\t\tret = snprintf(patharg, len, \"--path=%s/%s\", c->config_path, c->name);\n\t\tif (ret < 0 || ret >= len)\n\t\t\texit(1);\n\t\tnewargv[1] = patharg;\n\t\tlen = strlen(\"--name=\") + strlen(c->name) + 1;\n\t\tnamearg = malloc(len);\n\t\tif (!namearg)\n\t\t\texit(1);\n\t\tret = snprintf(namearg, len, \"--name=%s\", c->name);\n\t\tif (ret < 0 || ret >= len)\n\t\t\texit(1);\n\t\tnewargv[2] = namearg;\n\n\t\tlen = strlen(\"--rootfs=\") + 1 + strlen(bdev->dest);\n\t\trootfsarg = malloc(len);\n\t\tif (!rootfsarg)\n\t\t\texit(1);\n\t\tret = snprintf(rootfsarg, len, \"--rootfs=%s\", bdev->dest);\n\t\tif (ret < 0 || ret >= len)\n\t\t\texit(1);\n\t\tnewargv[3] = rootfsarg;\n\n\t\t/* add passed-in args */\n\t\tif (argv)\n\t\t\tfor (i = 4; i < nargs; i++)\n\t\t\t\tnewargv[i] = argv[i-4];\n\n\t\t/* add trailing NULL */\n\t\tnargs++;\n\t\tnewargv = realloc(newargv, nargs * sizeof(*newargv));\n\t\tif (!newargv)\n\t\t\texit(1);\n\t\tnewargv[nargs - 1] = NULL;\n\n\t\t/*\n\t\t * If we're running the template in a mapped userns, then\n\t\t * we prepend the template command with:\n\t\t * lxc-usernsexec <-m map1> ... <-m mapn> --\n\t\t * and we append \"--mapped-uid x\", where x is the mapped uid\n\t\t * for our geteuid()\n\t\t */\n\t\tif (!lxc_list_empty(&conf->id_map)) {\n\t\t\tint n2args = 1;\n\t\t\tchar txtuid[20];\n\t\t\tchar txtgid[20];\n\t\t\tchar **n2 = malloc(n2args * sizeof(*n2));\n\t\t\tstruct lxc_list *it;\n\t\t\tstruct id_map *map;\n\n\t\t\tif (!n2) {\n\t\t\t\tSYSERROR(\"out of memory\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tnewargv[0] = tpath;\n\t\t\ttpath = \"lxc-usernsexec\";\n\t\t\tn2[0] = \"lxc-usernsexec\";\n\t\t\tlxc_list_for_each(it, &conf->id_map) {\n\t\t\t\tmap = it->elem;\n\t\t\t\tn2args += 2;\n\t\t\t\tn2 = realloc(n2, n2args * sizeof(char *));\n\t\t\t\tif (!n2)\n\t\t\t\t\texit(1);\n\t\t\t\tn2[n2args-2] = \"-m\";\n\t\t\t\tn2[n2args-1] = malloc(200);\n\t\t\t\tif (!n2[n2args-1])\n\t\t\t\t\texit(1);\n\t\t\t\tret = snprintf(n2[n2args-1], 200, \"%c:%lu:%lu:%lu\",\n\t\t\t\t\tmap->idtype == ID_TYPE_UID ? 'u' : 'g',\n\t\t\t\t\tmap->nsid, map->hostid, map->range);\n\t\t\t\tif (ret < 0 || ret >= 200)\n\t\t\t\t\texit(1);\n\t\t\t}\n\t\t\tint hostid_mapped = mapped_hostid(geteuid(), conf, ID_TYPE_UID);\n\t\t\tint extraargs = hostid_mapped >= 0 ? 1 : 3;\n\t\t\tn2 = realloc(n2, (nargs + n2args + extraargs) * sizeof(char *));\n\t\t\tif (!n2)\n\t\t\t\texit(1);\n\t\t\tif (hostid_mapped < 0) {\n\t\t\t\thostid_mapped = find_unmapped_nsuid(conf, ID_TYPE_UID);\n\t\t\t\tn2[n2args++] = \"-m\";\n\t\t\t\tif (hostid_mapped < 0) {\n\t\t\t\t\tERROR(\"Could not find free uid to map\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tn2[n2args++] = malloc(200);\n\t\t\t\tif (!n2[n2args-1]) {\n\t\t\t\t\tSYSERROR(\"out of memory\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tret = snprintf(n2[n2args-1], 200, \"u:%d:%d:1\",\n\t\t\t\t\thostid_mapped, geteuid());\n\t\t\t\tif (ret < 0 || ret >= 200) {\n\t\t\t\t\tERROR(\"string too long\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint hostgid_mapped = mapped_hostid(getegid(), conf, ID_TYPE_GID);\n\t\t\textraargs = hostgid_mapped >= 0 ? 1 : 3;\n\t\t\tn2 = realloc(n2, (nargs + n2args + extraargs) * sizeof(char *));\n\t\t\tif (!n2)\n\t\t\t\texit(1);\n\t\t\tif (hostgid_mapped < 0) {\n\t\t\t\thostgid_mapped = find_unmapped_nsuid(conf, ID_TYPE_GID);\n\t\t\t\tn2[n2args++] = \"-m\";\n\t\t\t\tif (hostgid_mapped < 0) {\n\t\t\t\t\tERROR(\"Could not find free uid to map\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tn2[n2args++] = malloc(200);\n\t\t\t\tif (!n2[n2args-1]) {\n\t\t\t\t\tSYSERROR(\"out of memory\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tret = snprintf(n2[n2args-1], 200, \"g:%d:%d:1\",\n\t\t\t\t\thostgid_mapped, getegid());\n\t\t\t\tif (ret < 0 || ret >= 200) {\n\t\t\t\t\tERROR(\"string too long\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tn2[n2args++] = \"--\";\n\t\t\tfor (i = 0; i < nargs; i++)\n\t\t\t\tn2[i + n2args] = newargv[i];\n\t\t\tn2args += nargs;\n\t\t\t// Finally add \"--mapped-uid $uid\" to tell template what to chown\n\t\t\t// cached images to\n\t\t\tn2args += 4;\n\t\t\tn2 = realloc(n2, n2args * sizeof(char *));\n\t\t\tif (!n2) {\n\t\t\t\tSYSERROR(\"out of memory\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t// note n2[n2args-1] is NULL\n\t\t\tn2[n2args-5] = \"--mapped-uid\";\n\t\t\tsnprintf(txtuid, 20, \"%d\", hostid_mapped);\n\t\t\tn2[n2args-4] = txtuid;\n\t\t\tn2[n2args-3] = \"--mapped-gid\";\n\t\t\tsnprintf(txtgid, 20, \"%d\", hostgid_mapped);\n\t\t\tn2[n2args-2] = txtgid;\n\t\t\tn2[n2args-1] = NULL;\n\t\t\tfree(newargv);\n\t\t\tnewargv = n2;\n\t\t}\n\t\t/* execute */\n\t\texecvp(tpath, newargv);\n\t\tSYSERROR(\"failed to execute template %s\", tpath);\n\t\texit(1);\n\t}\n\n\tif (wait_for_pid(pid) != 0) {\n\t\tERROR(\"container creation template for %s failed\", c->name);\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"container creation template for %s failed\"",
            "c->name"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_pid",
          "args": [
            "pid"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "311-325",
          "snippet": "int lxc_wait_for_pid_status(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\treturn status;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_wait_for_pid_status(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to execute template %s\"",
            "tpath"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "tpath",
            "newargv"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "newargv"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "free_init_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "706-715",
          "snippet": "static void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "txtgid",
            "20",
            "\"%d\"",
            "hostgid_mapped"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "txtuid",
            "20",
            "\"%d\"",
            "hostid_mapped"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"out of memory\""
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "n2",
            "n2args * sizeof(char *)"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "must_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "116-124",
          "snippet": "static void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"string too long\""
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "n2[n2args-1]",
            "200",
            "\"g:%d:%d:1\"",
            "hostgid_mapped",
            "getegid()"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getegid",
          "args": [],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"out of memory\""
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "200"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Could not find free uid to map\""
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_unmapped_nsuid",
          "args": [
            "conf",
            "ID_TYPE_GID"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "find_unmapped_nsuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3344-3360",
          "snippet": "int find_unmapped_nsuid(struct lxc_conf *conf, enum idtype idtype)\n{\n\tstruct lxc_list *it;\n\tstruct id_map *map;\n\tunsigned int freeid = 0;\nagain:\n\tlxc_list_for_each(it, &conf->id_map) {\n\t\tmap = it->elem;\n\t\tif (map->idtype != idtype)\n\t\t\tcontinue;\n\t\tif (freeid >= map->nsid && freeid < map->nsid + map->range) {\n\t\t\tfreeid = map->nsid + map->range;\n\t\t\tgoto again;\n\t\t}\n\t}\n\treturn freeid;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint find_unmapped_nsuid(struct lxc_conf *conf, enum idtype idtype)\n{\n\tstruct lxc_list *it;\n\tstruct id_map *map;\n\tunsigned int freeid = 0;\nagain:\n\tlxc_list_for_each(it, &conf->id_map) {\n\t\tmap = it->elem;\n\t\tif (map->idtype != idtype)\n\t\t\tcontinue;\n\t\tif (freeid >= map->nsid && freeid < map->nsid + map->range) {\n\t\t\tfreeid = map->nsid + map->range;\n\t\t\tgoto again;\n\t\t}\n\t}\n\treturn freeid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapped_hostid",
          "args": [
            "getegid()",
            "conf",
            "ID_TYPE_GID"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "mapped_hostid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3330-3342",
          "snippet": "int mapped_hostid(unsigned id, struct lxc_conf *conf, enum idtype idtype)\n{\n\tstruct lxc_list *it;\n\tstruct id_map *map;\n\tlxc_list_for_each(it, &conf->id_map) {\n\t\tmap = it->elem;\n\t\tif (map->idtype != idtype)\n\t\t\tcontinue;\n\t\tif (id >= map->hostid && id < map->hostid + map->range)\n\t\t\treturn (id - map->hostid) + map->nsid;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint mapped_hostid(unsigned id, struct lxc_conf *conf, enum idtype idtype)\n{\n\tstruct lxc_list *it;\n\tstruct id_map *map;\n\tlxc_list_for_each(it, &conf->id_map) {\n\t\tmap = it->elem;\n\t\tif (map->idtype != idtype)\n\t\t\tcontinue;\n\t\tif (id >= map->hostid && id < map->hostid + map->range)\n\t\t\treturn (id - map->hostid) + map->nsid;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getegid",
          "args": [],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"string too long\""
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "n2[n2args-1]",
            "200",
            "\"u:%d:%d:1\"",
            "hostid_mapped",
            "geteuid()"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"out of memory\""
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "200"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Could not find free uid to map\""
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "n2[n2args-1]",
            "200",
            "\"%c:%lu:%lu:%lu\"",
            "map->idtype == ID_TYPE_UID ? 'u' : 'g'",
            "map->nsid",
            "map->hostid",
            "map->range"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "200"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "it",
            "&conf->id_map"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"out of memory\""
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "n2args * sizeof(*n2)"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_empty",
          "args": [
            "&conf->id_map"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "94-97",
          "snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "rootfsarg",
            "len",
            "\"--rootfs=%s\"",
            "bdev->dest"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "bdev->dest"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"--rootfs=\""
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "namearg",
            "len",
            "\"--name=%s\"",
            "c->name"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "c->name"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"--name=\""
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "patharg",
            "len",
            "\"--path=%s/%s\"",
            "c->config_path",
            "c->name"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"--path=\""
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "c->name"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "c->config_path"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxcbasename",
          "args": [
            "tpath"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "lxcbasename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "1064-1070",
          "snippet": "static char *lxcbasename(char *path)\n{\n\tchar *p = path + strlen(path) - 1;\n\twhile (*p != '/' && p > path)\n\t\tp--;\n\treturn p;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic char *lxcbasename(char *path)\n{\n\tchar *p = path + strlen(path) - 1;\n\twhile (*p != '/' && p > path)\n\t\tp--;\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "nargs * sizeof(*newargv)"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "bdev->src"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error mounting rootfs\""
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev->ops->mount",
          "args": [
            "bdev"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"non-root users can only create btrfs and directory-backed containers\""
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "bdev->type",
            "\"btrfs\""
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "bdev->type",
            "\"dir\""
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Continuing...\""
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to make / rslave to run template\""
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "NULL",
            "\"/\"",
            "NULL",
            "MS_SLAVE|MS_REC",
            "NULL"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "mount_entry_on_generic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1838-1869",
          "snippet": "static inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "detect_shared_rootfs",
          "args": [],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "detect_shared_rootfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1102-1132",
          "snippet": "int detect_shared_rootfs(void)\n{\n\tchar buf[LXC_LINELEN], *p;\n\tFILE *f;\n\tint i;\n\tchar *p2;\n\n\tf = fopen(\"/proc/self/mountinfo\", \"r\");\n\tif (!f)\n\t\treturn 0;\n\twhile (fgets(buf, LXC_LINELEN, f)) {\n\t\tfor (p = buf, i = 0; p && i < 4; i++)\n\t\t\tp = strchr(p + 1, ' ');\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tp2 = strchr(p + 1, ' ');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\t\tif (strcmp(p + 1, \"/\") == 0) {\n\t\t\t// this is '/'.  is it shared?\n\t\t\tp = strchr(p2 + 1, ' ');\n\t\t\tif (p && strstr(p, \"shared:\")) {\n\t\t\t\tfclose(f);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tfclose(f);\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint detect_shared_rootfs(void)\n{\n\tchar buf[LXC_LINELEN], *p;\n\tFILE *f;\n\tint i;\n\tchar *p2;\n\n\tf = fopen(\"/proc/self/mountinfo\", \"r\");\n\tif (!f)\n\t\treturn 0;\n\twhile (fgets(buf, LXC_LINELEN, f)) {\n\t\tfor (p = buf, i = 0; p && i < 4; i++)\n\t\t\tp = strchr(p + 1, ' ');\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tp2 = strchr(p + 1, ' ');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\t\tif (strcmp(p + 1, \"/\") == 0) {\n\t\t\t// this is '/'.  is it shared?\n\t\t\tp = strchr(p2 + 1, ' ');\n\t\t\tif (p && strstr(p, \"shared:\")) {\n\t\t\t\tfclose(f);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tfclose(f);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"error unsharing mounts\""
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unshare",
          "args": [
            "CLONE_NEWNS"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "unshare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.h",
          "lines": "73-81",
          "snippet": "static inline int unshare(int flags)\n{\n#ifdef __NR_unshare\n\treturn syscall(__NR_unshare, flags);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}",
          "includes": [
            "#include <stdint.h>",
            "#  include <sys/signalfd.h>",
            "#include <../include/getline.h>",
            "#include \"initutils.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#  include <sys/signalfd.h>\n#include <../include/getline.h>\n#include \"initutils.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic inline int unshare(int flags)\n{\n#ifdef __NR_unshare\n\treturn syscall(__NR_unshare, flags);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error opening rootfs\""
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_init",
          "args": [
            "c->lxc_conf",
            "c->lxc_conf->rootfs.path",
            "c->lxc_conf->rootfs.mount",
            "NULL"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "533-565",
          "snippet": "struct bdev *bdev_init(struct lxc_conf *conf, const char *src, const char *dst,\n\t\tconst char *mntopts)\n{\n\tstruct bdev *bdev;\n\tconst struct bdev_type *q;\n\n\tif (!src)\n\t\tsrc = conf->rootfs.path;\n\n\tif (!src)\n\t\treturn NULL;\n\n\tq = bdev_query(conf, src);\n\tif (!q)\n\t\treturn NULL;\n\n\tbdev = malloc(sizeof(struct bdev));\n\tif (!bdev)\n\t\treturn NULL;\n\tmemset(bdev, 0, sizeof(struct bdev));\n\tbdev->ops = q->ops;\n\tbdev->type = q->name;\n\tif (mntopts)\n\t\tbdev->mntopts = strdup(mntopts);\n\tif (src)\n\t\tbdev->src = strdup(src);\n\tif (dst)\n\t\tbdev->dest = strdup(dst);\n\tif (strcmp(bdev->type, \"nbd\") == 0)\n\t\tbdev->nbd_idx = conf->nbd_idx;\n\n\treturn bdev;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);",
            "static struct bdev *bdev_get(const char *type);",
            "static char *linkderef(char *path, char *dest);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);\nstatic struct bdev *bdev_get(const char *type);\nstatic char *linkderef(char *path, char *dest);\n\nstruct bdev *bdev_init(struct lxc_conf *conf, const char *src, const char *dst,\n\t\tconst char *mntopts)\n{\n\tstruct bdev *bdev;\n\tconst struct bdev_type *q;\n\n\tif (!src)\n\t\tsrc = conf->rootfs.path;\n\n\tif (!src)\n\t\treturn NULL;\n\n\tq = bdev_query(conf, src);\n\tif (!q)\n\t\treturn NULL;\n\n\tbdev = malloc(sizeof(struct bdev));\n\tif (!bdev)\n\t\treturn NULL;\n\tmemset(bdev, 0, sizeof(struct bdev));\n\tbdev->ops = q->ops;\n\tbdev->type = q->name;\n\tif (mntopts)\n\t\tbdev->mntopts = strdup(mntopts);\n\tif (src)\n\t\tbdev->src = strdup(src);\n\tif (dst)\n\t\tbdev->dest = strdup(dst);\n\tif (strcmp(bdev->type, \"nbd\") == 0)\n\t\tbdev->nbd_idx = conf->nbd_idx;\n\n\treturn bdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "null_stdfds",
          "args": [],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "null_stdfds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1828-1839",
          "snippet": "int null_stdfds(void)\n{\n\tint ret = -1;\n\tint fd = open_devnull();\n\n\tif (fd >= 0) {\n\t\tret = set_stdfds(fd);\n\t\tclose(fd);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint null_stdfds(void)\n{\n\tint ret = -1;\n\tint fd = open_devnull();\n\n\tif (fd >= 0) {\n\t\tret = set_stdfds(fd);\n\t\tclose(fd);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to fork task for container creation template\""
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool create_run_template(struct lxc_container *c, char *tpath, bool need_null_stdfds,\n\t\t\t\tchar *const argv[])\n{\n\tpid_t pid;\n\n\tif (!tpath)\n\t\treturn true;\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"failed to fork task for container creation template\");\n\t\treturn false;\n\t}\n\n\tif (pid == 0) { // child\n\t\tchar *patharg, *namearg, *rootfsarg;\n\t\tstruct bdev *bdev = NULL;\n\t\tint i;\n\t\tint ret, len, nargs = 0;\n\t\tchar **newargv;\n\t\tstruct lxc_conf *conf = c->lxc_conf;\n\n\t\tif (need_null_stdfds && null_stdfds() < 0) {\n\t\t\texit(1);\n\t\t}\n\n\t\tbdev = bdev_init(c->lxc_conf, c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);\n\t\tif (!bdev) {\n\t\t\tERROR(\"Error opening rootfs\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (geteuid() == 0) {\n\t\t\tif (unshare(CLONE_NEWNS) < 0) {\n\t\t\t\tERROR(\"error unsharing mounts\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (detect_shared_rootfs()) {\n\t\t\t\tif (mount(NULL, \"/\", NULL, MS_SLAVE|MS_REC, NULL)) {\n\t\t\t\t\tSYSERROR(\"Failed to make / rslave to run template\");\n\t\t\t\t\tERROR(\"Continuing...\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (strcmp(bdev->type, \"dir\") && strcmp(bdev->type, \"btrfs\")) {\n\t\t\tif (geteuid() != 0) {\n\t\t\t\tERROR(\"non-root users can only create btrfs and directory-backed containers\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (bdev->ops->mount(bdev) < 0) {\n\t\t\t\tERROR(\"Error mounting rootfs\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t} else { // TODO come up with a better way here!\n\t\t\tfree(bdev->dest);\n\t\t\tbdev->dest = strdup(bdev->src);\n\t\t}\n\n\t\t/*\n\t\t * create our new array, pre-pend the template name and\n\t\t * base args\n\t\t */\n\t\tif (argv)\n\t\t\tfor (nargs = 0; argv[nargs]; nargs++) ;\n\t\tnargs += 4; // template, path, rootfs and name args\n\n\t\tnewargv = malloc(nargs * sizeof(*newargv));\n\t\tif (!newargv)\n\t\t\texit(1);\n\t\tnewargv[0] = lxcbasename(tpath);\n\n\t\tlen = strlen(c->config_path) + strlen(c->name) + strlen(\"--path=\") + 2;\n\t\tpatharg = malloc(len);\n\t\tif (!patharg)\n\t\t\texit(1);\n\t\tret = snprintf(patharg, len, \"--path=%s/%s\", c->config_path, c->name);\n\t\tif (ret < 0 || ret >= len)\n\t\t\texit(1);\n\t\tnewargv[1] = patharg;\n\t\tlen = strlen(\"--name=\") + strlen(c->name) + 1;\n\t\tnamearg = malloc(len);\n\t\tif (!namearg)\n\t\t\texit(1);\n\t\tret = snprintf(namearg, len, \"--name=%s\", c->name);\n\t\tif (ret < 0 || ret >= len)\n\t\t\texit(1);\n\t\tnewargv[2] = namearg;\n\n\t\tlen = strlen(\"--rootfs=\") + 1 + strlen(bdev->dest);\n\t\trootfsarg = malloc(len);\n\t\tif (!rootfsarg)\n\t\t\texit(1);\n\t\tret = snprintf(rootfsarg, len, \"--rootfs=%s\", bdev->dest);\n\t\tif (ret < 0 || ret >= len)\n\t\t\texit(1);\n\t\tnewargv[3] = rootfsarg;\n\n\t\t/* add passed-in args */\n\t\tif (argv)\n\t\t\tfor (i = 4; i < nargs; i++)\n\t\t\t\tnewargv[i] = argv[i-4];\n\n\t\t/* add trailing NULL */\n\t\tnargs++;\n\t\tnewargv = realloc(newargv, nargs * sizeof(*newargv));\n\t\tif (!newargv)\n\t\t\texit(1);\n\t\tnewargv[nargs - 1] = NULL;\n\n\t\t/*\n\t\t * If we're running the template in a mapped userns, then\n\t\t * we prepend the template command with:\n\t\t * lxc-usernsexec <-m map1> ... <-m mapn> --\n\t\t * and we append \"--mapped-uid x\", where x is the mapped uid\n\t\t * for our geteuid()\n\t\t */\n\t\tif (!lxc_list_empty(&conf->id_map)) {\n\t\t\tint n2args = 1;\n\t\t\tchar txtuid[20];\n\t\t\tchar txtgid[20];\n\t\t\tchar **n2 = malloc(n2args * sizeof(*n2));\n\t\t\tstruct lxc_list *it;\n\t\t\tstruct id_map *map;\n\n\t\t\tif (!n2) {\n\t\t\t\tSYSERROR(\"out of memory\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tnewargv[0] = tpath;\n\t\t\ttpath = \"lxc-usernsexec\";\n\t\t\tn2[0] = \"lxc-usernsexec\";\n\t\t\tlxc_list_for_each(it, &conf->id_map) {\n\t\t\t\tmap = it->elem;\n\t\t\t\tn2args += 2;\n\t\t\t\tn2 = realloc(n2, n2args * sizeof(char *));\n\t\t\t\tif (!n2)\n\t\t\t\t\texit(1);\n\t\t\t\tn2[n2args-2] = \"-m\";\n\t\t\t\tn2[n2args-1] = malloc(200);\n\t\t\t\tif (!n2[n2args-1])\n\t\t\t\t\texit(1);\n\t\t\t\tret = snprintf(n2[n2args-1], 200, \"%c:%lu:%lu:%lu\",\n\t\t\t\t\tmap->idtype == ID_TYPE_UID ? 'u' : 'g',\n\t\t\t\t\tmap->nsid, map->hostid, map->range);\n\t\t\t\tif (ret < 0 || ret >= 200)\n\t\t\t\t\texit(1);\n\t\t\t}\n\t\t\tint hostid_mapped = mapped_hostid(geteuid(), conf, ID_TYPE_UID);\n\t\t\tint extraargs = hostid_mapped >= 0 ? 1 : 3;\n\t\t\tn2 = realloc(n2, (nargs + n2args + extraargs) * sizeof(char *));\n\t\t\tif (!n2)\n\t\t\t\texit(1);\n\t\t\tif (hostid_mapped < 0) {\n\t\t\t\thostid_mapped = find_unmapped_nsuid(conf, ID_TYPE_UID);\n\t\t\t\tn2[n2args++] = \"-m\";\n\t\t\t\tif (hostid_mapped < 0) {\n\t\t\t\t\tERROR(\"Could not find free uid to map\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tn2[n2args++] = malloc(200);\n\t\t\t\tif (!n2[n2args-1]) {\n\t\t\t\t\tSYSERROR(\"out of memory\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tret = snprintf(n2[n2args-1], 200, \"u:%d:%d:1\",\n\t\t\t\t\thostid_mapped, geteuid());\n\t\t\t\tif (ret < 0 || ret >= 200) {\n\t\t\t\t\tERROR(\"string too long\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint hostgid_mapped = mapped_hostid(getegid(), conf, ID_TYPE_GID);\n\t\t\textraargs = hostgid_mapped >= 0 ? 1 : 3;\n\t\t\tn2 = realloc(n2, (nargs + n2args + extraargs) * sizeof(char *));\n\t\t\tif (!n2)\n\t\t\t\texit(1);\n\t\t\tif (hostgid_mapped < 0) {\n\t\t\t\thostgid_mapped = find_unmapped_nsuid(conf, ID_TYPE_GID);\n\t\t\t\tn2[n2args++] = \"-m\";\n\t\t\t\tif (hostgid_mapped < 0) {\n\t\t\t\t\tERROR(\"Could not find free uid to map\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tn2[n2args++] = malloc(200);\n\t\t\t\tif (!n2[n2args-1]) {\n\t\t\t\t\tSYSERROR(\"out of memory\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tret = snprintf(n2[n2args-1], 200, \"g:%d:%d:1\",\n\t\t\t\t\thostgid_mapped, getegid());\n\t\t\t\tif (ret < 0 || ret >= 200) {\n\t\t\t\t\tERROR(\"string too long\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tn2[n2args++] = \"--\";\n\t\t\tfor (i = 0; i < nargs; i++)\n\t\t\t\tn2[i + n2args] = newargv[i];\n\t\t\tn2args += nargs;\n\t\t\t// Finally add \"--mapped-uid $uid\" to tell template what to chown\n\t\t\t// cached images to\n\t\t\tn2args += 4;\n\t\t\tn2 = realloc(n2, n2args * sizeof(char *));\n\t\t\tif (!n2) {\n\t\t\t\tSYSERROR(\"out of memory\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t// note n2[n2args-1] is NULL\n\t\t\tn2[n2args-5] = \"--mapped-uid\";\n\t\t\tsnprintf(txtuid, 20, \"%d\", hostid_mapped);\n\t\t\tn2[n2args-4] = txtuid;\n\t\t\tn2[n2args-3] = \"--mapped-gid\";\n\t\t\tsnprintf(txtgid, 20, \"%d\", hostgid_mapped);\n\t\t\tn2[n2args-2] = txtgid;\n\t\t\tn2[n2args-1] = NULL;\n\t\t\tfree(newargv);\n\t\t\tnewargv = n2;\n\t\t}\n\t\t/* execute */\n\t\texecvp(tpath, newargv);\n\t\tSYSERROR(\"failed to execute template %s\", tpath);\n\t\texit(1);\n\t}\n\n\tif (wait_for_pid(pid) != 0) {\n\t\tERROR(\"container creation template for %s failed\", c->name);\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "lxcbasename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "1064-1070",
    "snippet": "static char *lxcbasename(char *path)\n{\n\tchar *p = path + strlen(path) - 1;\n\twhile (*p != '/' && p > path)\n\t\tp--;\n\treturn p;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic char *lxcbasename(char *path)\n{\n\tchar *p = path + strlen(path) - 1;\n\twhile (*p != '/' && p > path)\n\t\tp--;\n\treturn p;\n}"
  },
  {
    "function_name": "do_bdev_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "1017-1062",
    "snippet": "static struct bdev *do_bdev_create(struct lxc_container *c, const char *type,\n\t\t\t struct bdev_specs *specs)\n{\n\tchar *dest;\n\tsize_t len;\n\tstruct bdev *bdev;\n\tint ret;\n\n\t/* rootfs.path or lxcpath/lxcname/rootfs */\n\tif (c->lxc_conf->rootfs.path && access(c->lxc_conf->rootfs.path, F_OK) == 0) {\n\t\tconst char *rpath = c->lxc_conf->rootfs.path;\n\t\tlen = strlen(rpath) + 1;\n\t\tdest = alloca(len);\n\t\tret = snprintf(dest, len, \"%s\", rpath);\n\t} else {\n\t\tconst char *lxcpath = do_lxcapi_get_config_path(c);\n\t\tlen = strlen(c->name) + strlen(lxcpath) + 9;\n\t\tdest = alloca(len);\n\t\tret = snprintf(dest, len, \"%s/%s/rootfs\", lxcpath, c->name);\n\t}\n\tif (ret < 0 || ret >= len)\n\t\treturn NULL;\n\n\tbdev = bdev_create(dest, type, c->name, specs);\n\tif (!bdev) {\n\t\tERROR(\"Failed to create backing store type %s\", type);\n\t\treturn NULL;\n\t}\n\n\tdo_lxcapi_set_config_item(c, \"lxc.rootfs\", bdev->src);\n\tdo_lxcapi_set_config_item(c, \"lxc.rootfs.backend\", bdev->type);\n\n\t/* if we are not root, chown the rootfs dir to root in the\n\t * target uidmap */\n\n\tif (geteuid() != 0 || (c->lxc_conf && !lxc_list_empty(&c->lxc_conf->id_map))) {\n\t\tif (chown_mapped_root(bdev->dest, c->lxc_conf) < 0) {\n\t\t\tERROR(\"Error chowning %s to container root\", bdev->dest);\n\t\t\tsuggest_default_idmap();\n\t\t\tbdev_put(bdev);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn bdev;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdev_put",
          "args": [
            "bdev"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "579-585",
          "snippet": "void bdev_put(struct bdev *bdev)\n{\n\tfree(bdev->mntopts);\n\tfree(bdev->src);\n\tfree(bdev->dest);\n\tfree(bdev);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);",
            "static char *linkderef(char *path, char *dest);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);\nstatic char *linkderef(char *path, char *dest);\n\nvoid bdev_put(struct bdev *bdev)\n{\n\tfree(bdev->mntopts);\n\tfree(bdev->src);\n\tfree(bdev->dest);\n\tfree(bdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "suggest_default_idmap",
          "args": [],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "suggest_default_idmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4514-4617",
          "snippet": "void suggest_default_idmap(void)\n{\n\tFILE *f;\n\tunsigned int uid = 0, urange = 0, gid = 0, grange = 0;\n\tchar *line = NULL;\n\tchar *uname, *gname;\n\tsize_t len = 0;\n\n\tif (!(uname = getuname()))\n\t\treturn;\n\n\tif (!(gname = getgname())) {\n\t\tfree(uname);\n\t\treturn;\n\t}\n\n\tf = fopen(subuidfile, \"r\");\n\tif (!f) {\n\t\tERROR(\"Your system is not configured with subuids\");\n\t\tfree(gname);\n\t\tfree(uname);\n\t\treturn;\n\t}\n\twhile (getline(&line, &len, f) != -1) {\n\t\tsize_t no_newline = 0;\n\t\tchar *p = strchr(line, ':'), *p2;\n\t\tif (*line == '#')\n\t\t\tcontinue;\n\t\tif (!p)\n\t\t\tcontinue;\n\t\t*p = '\\0';\n\t\tp++;\n\t\tif (strcmp(line, uname))\n\t\t\tcontinue;\n\t\tp2 = strchr(p, ':');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\t\tp2++;\n\t\tif (!*p2)\n\t\t\tcontinue;\n\t\tno_newline = strcspn(p2, \"\\n\");\n\t\tp2[no_newline] = '\\0';\n\n\t\tif (lxc_safe_uint(p, &uid) < 0)\n\t\t\tWARN(\"Could not parse UID.\");\n\t\tif (lxc_safe_uint(p2, &urange) < 0)\n\t\t\tWARN(\"Could not parse UID range.\");\n\t}\n\tfclose(f);\n\n\tf = fopen(subuidfile, \"r\");\n\tif (!f) {\n\t\tERROR(\"Your system is not configured with subgids\");\n\t\tfree(gname);\n\t\tfree(uname);\n\t\treturn;\n\t}\n\twhile (getline(&line, &len, f) != -1) {\n\t\tsize_t no_newline = 0;\n\t\tchar *p = strchr(line, ':'), *p2;\n\t\tif (*line == '#')\n\t\t\tcontinue;\n\t\tif (!p)\n\t\t\tcontinue;\n\t\t*p = '\\0';\n\t\tp++;\n\t\tif (strcmp(line, uname))\n\t\t\tcontinue;\n\t\tp2 = strchr(p, ':');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\t\tp2++;\n\t\tif (!*p2)\n\t\t\tcontinue;\n\t\tno_newline = strcspn(p2, \"\\n\");\n\t\tp2[no_newline] = '\\0';\n\n\t\tif (lxc_safe_uint(p, &gid) < 0)\n\t\t\tWARN(\"Could not parse GID.\");\n\t\tif (lxc_safe_uint(p2, &grange) < 0)\n\t\t\tWARN(\"Could not parse GID range.\");\n\t}\n\tfclose(f);\n\n\tfree(line);\n\n\tif (!urange || !grange) {\n\t\tERROR(\"You do not have subuids or subgids allocated\");\n\t\tERROR(\"Unprivileged containers require subuids and subgids\");\n\t\treturn;\n\t}\n\n\tERROR(\"You must either run as root, or define uid mappings\");\n\tERROR(\"To pass uid mappings to lxc-create, you could create\");\n\tERROR(\"~/.config/lxc/default.conf:\");\n\tERROR(\"lxc.include = %s\", LXC_DEFAULT_CONFIG);\n\tERROR(\"lxc.id_map = u 0 %u %u\", uid, urange);\n\tERROR(\"lxc.id_map = g 0 %u %u\", gid, grange);\n\n\tfree(gname);\n\tfree(uname);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid suggest_default_idmap(void)\n{\n\tFILE *f;\n\tunsigned int uid = 0, urange = 0, gid = 0, grange = 0;\n\tchar *line = NULL;\n\tchar *uname, *gname;\n\tsize_t len = 0;\n\n\tif (!(uname = getuname()))\n\t\treturn;\n\n\tif (!(gname = getgname())) {\n\t\tfree(uname);\n\t\treturn;\n\t}\n\n\tf = fopen(subuidfile, \"r\");\n\tif (!f) {\n\t\tERROR(\"Your system is not configured with subuids\");\n\t\tfree(gname);\n\t\tfree(uname);\n\t\treturn;\n\t}\n\twhile (getline(&line, &len, f) != -1) {\n\t\tsize_t no_newline = 0;\n\t\tchar *p = strchr(line, ':'), *p2;\n\t\tif (*line == '#')\n\t\t\tcontinue;\n\t\tif (!p)\n\t\t\tcontinue;\n\t\t*p = '\\0';\n\t\tp++;\n\t\tif (strcmp(line, uname))\n\t\t\tcontinue;\n\t\tp2 = strchr(p, ':');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\t\tp2++;\n\t\tif (!*p2)\n\t\t\tcontinue;\n\t\tno_newline = strcspn(p2, \"\\n\");\n\t\tp2[no_newline] = '\\0';\n\n\t\tif (lxc_safe_uint(p, &uid) < 0)\n\t\t\tWARN(\"Could not parse UID.\");\n\t\tif (lxc_safe_uint(p2, &urange) < 0)\n\t\t\tWARN(\"Could not parse UID range.\");\n\t}\n\tfclose(f);\n\n\tf = fopen(subuidfile, \"r\");\n\tif (!f) {\n\t\tERROR(\"Your system is not configured with subgids\");\n\t\tfree(gname);\n\t\tfree(uname);\n\t\treturn;\n\t}\n\twhile (getline(&line, &len, f) != -1) {\n\t\tsize_t no_newline = 0;\n\t\tchar *p = strchr(line, ':'), *p2;\n\t\tif (*line == '#')\n\t\t\tcontinue;\n\t\tif (!p)\n\t\t\tcontinue;\n\t\t*p = '\\0';\n\t\tp++;\n\t\tif (strcmp(line, uname))\n\t\t\tcontinue;\n\t\tp2 = strchr(p, ':');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\t\tp2++;\n\t\tif (!*p2)\n\t\t\tcontinue;\n\t\tno_newline = strcspn(p2, \"\\n\");\n\t\tp2[no_newline] = '\\0';\n\n\t\tif (lxc_safe_uint(p, &gid) < 0)\n\t\t\tWARN(\"Could not parse GID.\");\n\t\tif (lxc_safe_uint(p2, &grange) < 0)\n\t\t\tWARN(\"Could not parse GID range.\");\n\t}\n\tfclose(f);\n\n\tfree(line);\n\n\tif (!urange || !grange) {\n\t\tERROR(\"You do not have subuids or subgids allocated\");\n\t\tERROR(\"Unprivileged containers require subuids and subgids\");\n\t\treturn;\n\t}\n\n\tERROR(\"You must either run as root, or define uid mappings\");\n\tERROR(\"To pass uid mappings to lxc-create, you could create\");\n\tERROR(\"~/.config/lxc/default.conf:\");\n\tERROR(\"lxc.include = %s\", LXC_DEFAULT_CONFIG);\n\tERROR(\"lxc.id_map = u 0 %u %u\", uid, urange);\n\tERROR(\"lxc.id_map = g 0 %u %u\", gid, grange);\n\n\tfree(gname);\n\tfree(uname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error chowning %s to container root\"",
            "bdev->dest"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chown_mapped_root",
          "args": [
            "bdev->dest",
            "c->lxc_conf"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "chown_mapped_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3482-3618",
          "snippet": "int chown_mapped_root(char *path, struct lxc_conf *conf)\n{\n\tuid_t rootuid;\n\tgid_t rootgid;\n\tpid_t pid;\n\tunsigned long val;\n\tchar *chownpath = path;\n\n\tif (!get_mapped_rootid(conf, ID_TYPE_UID, &val)) {\n\t\tERROR(\"No mapping for container root\");\n\t\treturn -1;\n\t}\n\trootuid = (uid_t) val;\n\tif (!get_mapped_rootid(conf, ID_TYPE_GID, &val)) {\n\t\tERROR(\"No mapping for container root\");\n\t\treturn -1;\n\t}\n\trootgid = (gid_t) val;\n\n\t/*\n\t * In case of overlay, we want only the writeable layer\n\t * to be chowned\n\t */\n\tif (strncmp(path, \"overlayfs:\", 10) == 0 || strncmp(path, \"aufs:\", 5) == 0) {\n\t\tchownpath = strchr(path, ':');\n\t\tif (!chownpath) {\n\t\t\tERROR(\"Bad overlay path: %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tchownpath = strchr(chownpath+1, ':');\n\t\tif (!chownpath) {\n\t\t\tERROR(\"Bad overlay path: %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tchownpath++;\n\t}\n\tpath = chownpath;\n\tif (geteuid() == 0) {\n\t\tif (chown(path, rootuid, rootgid) < 0) {\n\t\t\tERROR(\"Error chowning %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (rootuid == geteuid()) {\n\t\t// nothing to do\n\t\tINFO(\"%s: container root is our uid;  no need to chown\" ,__func__);\n\t\treturn 0;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"Failed forking\");\n\t\treturn -1;\n\t}\n\tif (!pid) {\n\t\tint hostuid = geteuid(), hostgid = getegid(), ret;\n\t\tstruct stat sb;\n\t\tchar map1[100], map2[100], map3[100], map4[100], map5[100];\n\t\tchar ugid[100];\n\t\tchar *args1[] = { \"lxc-usernsexec\", \"-m\", map1, \"-m\", map2,\n\t\t\t\t\"-m\", map3, \"-m\", map5,\n\t\t\t\t\"--\", \"chown\", ugid, path, NULL };\n\t\tchar *args2[] = { \"lxc-usernsexec\", \"-m\", map1, \"-m\", map2,\n\t\t\t\t\"-m\", map3, \"-m\", map4, \"-m\", map5,\n\t\t\t\t\"--\", \"chown\", ugid, path, NULL };\n\n\t\t// save the current gid of \"path\"\n\t\tif (stat(path, &sb) < 0) {\n\t\t\tERROR(\"Error stat %s\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * A file has to be group-owned by a gid mapped into the\n\t\t * container, or the container won't be privileged over it.\n\t\t */\n\t\tif (sb.st_uid == geteuid() &&\n\t\t\t\tmapped_hostid(sb.st_gid, conf, ID_TYPE_GID) < 0 &&\n\t\t\t\tchown(path, -1, hostgid) < 0) {\n\t\t\tERROR(\"Failed chgrping %s\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"u:0:rootuid:1\"\n\t\tret = snprintf(map1, 100, \"u:0:%d:1\", rootuid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error uid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"u:hostuid:hostuid:1\"\n\t\tret = snprintf(map2, 100, \"u:%d:%d:1\", hostuid, hostuid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error uid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:0:rootgid:1\"\n\t\tret = snprintf(map3, 100, \"g:0:%d:1\", rootgid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:pathgid:rootgid+pathgid:1\"\n\t\tret = snprintf(map4, 100, \"g:%d:%d:1\", (gid_t)sb.st_gid,\n\t\t\t\trootgid + (gid_t)sb.st_gid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:hostgid:hostgid:1\"\n\t\tret = snprintf(map5, 100, \"g:%d:%d:1\", hostgid, hostgid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"0:pathgid\" (chown)\n\t\tret = snprintf(ugid, 100, \"0:%d\", (gid_t)sb.st_gid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error owner printing format string for chown\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (hostgid == sb.st_gid)\n\t\t\tret = execvp(\"lxc-usernsexec\", args1);\n\t\telse\n\t\t\tret = execvp(\"lxc-usernsexec\", args2);\n\t\tSYSERROR(\"Failed executing usernsexec\");\n\t\texit(1);\n\t}\n\treturn wait_for_pid(pid);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint chown_mapped_root(char *path, struct lxc_conf *conf)\n{\n\tuid_t rootuid;\n\tgid_t rootgid;\n\tpid_t pid;\n\tunsigned long val;\n\tchar *chownpath = path;\n\n\tif (!get_mapped_rootid(conf, ID_TYPE_UID, &val)) {\n\t\tERROR(\"No mapping for container root\");\n\t\treturn -1;\n\t}\n\trootuid = (uid_t) val;\n\tif (!get_mapped_rootid(conf, ID_TYPE_GID, &val)) {\n\t\tERROR(\"No mapping for container root\");\n\t\treturn -1;\n\t}\n\trootgid = (gid_t) val;\n\n\t/*\n\t * In case of overlay, we want only the writeable layer\n\t * to be chowned\n\t */\n\tif (strncmp(path, \"overlayfs:\", 10) == 0 || strncmp(path, \"aufs:\", 5) == 0) {\n\t\tchownpath = strchr(path, ':');\n\t\tif (!chownpath) {\n\t\t\tERROR(\"Bad overlay path: %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tchownpath = strchr(chownpath+1, ':');\n\t\tif (!chownpath) {\n\t\t\tERROR(\"Bad overlay path: %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tchownpath++;\n\t}\n\tpath = chownpath;\n\tif (geteuid() == 0) {\n\t\tif (chown(path, rootuid, rootgid) < 0) {\n\t\t\tERROR(\"Error chowning %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (rootuid == geteuid()) {\n\t\t// nothing to do\n\t\tINFO(\"%s: container root is our uid;  no need to chown\" ,__func__);\n\t\treturn 0;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"Failed forking\");\n\t\treturn -1;\n\t}\n\tif (!pid) {\n\t\tint hostuid = geteuid(), hostgid = getegid(), ret;\n\t\tstruct stat sb;\n\t\tchar map1[100], map2[100], map3[100], map4[100], map5[100];\n\t\tchar ugid[100];\n\t\tchar *args1[] = { \"lxc-usernsexec\", \"-m\", map1, \"-m\", map2,\n\t\t\t\t\"-m\", map3, \"-m\", map5,\n\t\t\t\t\"--\", \"chown\", ugid, path, NULL };\n\t\tchar *args2[] = { \"lxc-usernsexec\", \"-m\", map1, \"-m\", map2,\n\t\t\t\t\"-m\", map3, \"-m\", map4, \"-m\", map5,\n\t\t\t\t\"--\", \"chown\", ugid, path, NULL };\n\n\t\t// save the current gid of \"path\"\n\t\tif (stat(path, &sb) < 0) {\n\t\t\tERROR(\"Error stat %s\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * A file has to be group-owned by a gid mapped into the\n\t\t * container, or the container won't be privileged over it.\n\t\t */\n\t\tif (sb.st_uid == geteuid() &&\n\t\t\t\tmapped_hostid(sb.st_gid, conf, ID_TYPE_GID) < 0 &&\n\t\t\t\tchown(path, -1, hostgid) < 0) {\n\t\t\tERROR(\"Failed chgrping %s\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"u:0:rootuid:1\"\n\t\tret = snprintf(map1, 100, \"u:0:%d:1\", rootuid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error uid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"u:hostuid:hostuid:1\"\n\t\tret = snprintf(map2, 100, \"u:%d:%d:1\", hostuid, hostuid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error uid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:0:rootgid:1\"\n\t\tret = snprintf(map3, 100, \"g:0:%d:1\", rootgid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:pathgid:rootgid+pathgid:1\"\n\t\tret = snprintf(map4, 100, \"g:%d:%d:1\", (gid_t)sb.st_gid,\n\t\t\t\trootgid + (gid_t)sb.st_gid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:hostgid:hostgid:1\"\n\t\tret = snprintf(map5, 100, \"g:%d:%d:1\", hostgid, hostgid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"0:pathgid\" (chown)\n\t\tret = snprintf(ugid, 100, \"0:%d\", (gid_t)sb.st_gid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error owner printing format string for chown\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (hostgid == sb.st_gid)\n\t\t\tret = execvp(\"lxc-usernsexec\", args1);\n\t\telse\n\t\t\tret = execvp(\"lxc-usernsexec\", args2);\n\t\tSYSERROR(\"Failed executing usernsexec\");\n\t\texit(1);\n\t}\n\treturn wait_for_pid(pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_empty",
          "args": [
            "&c->lxc_conf->id_map"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "94-97",
          "snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_lxcapi_set_config_item",
          "args": [
            "c",
            "\"lxc.rootfs.backend\"",
            "bdev->type"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "do_lxcapi_set_config_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2471-2485",
          "snippet": "static bool do_lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v)\n{\n\tbool b = false;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (container_mem_lock(c))\n\t\treturn false;\n\n\tb = set_config_item_locked(c, key, v);\n\n\tcontainer_mem_unlock(c);\n\treturn b;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool do_lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool do_lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v)\n{\n\tbool b = false;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (container_mem_lock(c))\n\t\treturn false;\n\n\tb = set_config_item_locked(c, key, v);\n\n\tcontainer_mem_unlock(c);\n\treturn b;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to create backing store type %s\"",
            "type"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_create",
          "args": [
            "dest",
            "type",
            "c->name",
            "specs"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "do_bdev_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "807-822",
          "snippet": "static struct bdev *do_bdev_create(const char *dest, const char *type,\n\t\tconst char *cname, struct bdev_specs *specs)\n{\n\n\tstruct bdev *bdev = bdev_get(type);\n\tif (!bdev) {\n\t\treturn NULL;\n\t}\n\n\tif (bdev->ops->create(bdev, dest, cname, specs) < 0) {\n\t\t bdev_put(bdev);\n\t\t return NULL;\n\t}\n\n\treturn bdev;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "dest",
            "len",
            "\"%s/%s/rootfs\"",
            "lxcpath",
            "c->name"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "len"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "lxcpath"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "c->name"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_lxcapi_get_config_path",
          "args": [
            "c"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "dest",
            "len",
            "\"%s\"",
            "rpath"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "len"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "rpath"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "c->lxc_conf->rootfs.path",
            "F_OK"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic struct bdev *do_bdev_create(struct lxc_container *c, const char *type,\n\t\t\t struct bdev_specs *specs)\n{\n\tchar *dest;\n\tsize_t len;\n\tstruct bdev *bdev;\n\tint ret;\n\n\t/* rootfs.path or lxcpath/lxcname/rootfs */\n\tif (c->lxc_conf->rootfs.path && access(c->lxc_conf->rootfs.path, F_OK) == 0) {\n\t\tconst char *rpath = c->lxc_conf->rootfs.path;\n\t\tlen = strlen(rpath) + 1;\n\t\tdest = alloca(len);\n\t\tret = snprintf(dest, len, \"%s\", rpath);\n\t} else {\n\t\tconst char *lxcpath = do_lxcapi_get_config_path(c);\n\t\tlen = strlen(c->name) + strlen(lxcpath) + 9;\n\t\tdest = alloca(len);\n\t\tret = snprintf(dest, len, \"%s/%s/rootfs\", lxcpath, c->name);\n\t}\n\tif (ret < 0 || ret >= len)\n\t\treturn NULL;\n\n\tbdev = bdev_create(dest, type, c->name, specs);\n\tif (!bdev) {\n\t\tERROR(\"Failed to create backing store type %s\", type);\n\t\treturn NULL;\n\t}\n\n\tdo_lxcapi_set_config_item(c, \"lxc.rootfs\", bdev->src);\n\tdo_lxcapi_set_config_item(c, \"lxc.rootfs.backend\", bdev->type);\n\n\t/* if we are not root, chown the rootfs dir to root in the\n\t * target uidmap */\n\n\tif (geteuid() != 0 || (c->lxc_conf && !lxc_list_empty(&c->lxc_conf->id_map))) {\n\t\tif (chown_mapped_root(bdev->dest, c->lxc_conf) < 0) {\n\t\t\tERROR(\"Error chowning %s to container root\", bdev->dest);\n\t\t\tsuggest_default_idmap();\n\t\t\tbdev_put(bdev);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn bdev;\n}"
  },
  {
    "function_name": "create_container_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "994-1011",
    "snippet": "static bool create_container_dir(struct lxc_container *c)\n{\n\tchar *s;\n\tint len, ret;\n\n\tlen = strlen(c->config_path) + strlen(c->name) + 2;\n\ts = malloc(len);\n\tif (!s)\n\t\treturn false;\n\tret = snprintf(s, len, \"%s/%s\", c->config_path, c->name);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(s);\n\t\treturn false;\n\t}\n\tret = do_create_container_dir(s, c->lxc_conf);\n\tfree(s);\n\treturn ret == 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "s"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "free_init_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "706-715",
          "snippet": "static void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_create_container_dir",
          "args": [
            "s",
            "c->lxc_conf"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "do_create_container_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "966-989",
          "snippet": "static int do_create_container_dir(const char *path, struct lxc_conf *conf)\n{\n\tint ret = -1, lasterr;\n\tchar *p = alloca(strlen(path)+1);\n\tmode_t mask = umask(0002);\n\tret = mkdir(path, 0770);\n\tlasterr = errno;\n\tumask(mask);\n\terrno = lasterr;\n\tif (ret) {\n\t\tif (errno == EEXIST)\n\t\t\tret = 0;\n\t\telse {\n\t\t\tSYSERROR(\"failed to create container path %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tstrcpy(p, path);\n\tif (!lxc_list_empty(&conf->id_map) && chown_mapped_root(p, conf) != 0) {\n\t\tERROR(\"Failed to chown container dir\");\n\t\tret = -1;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic int do_create_container_dir(const char *path, struct lxc_conf *conf)\n{\n\tint ret = -1, lasterr;\n\tchar *p = alloca(strlen(path)+1);\n\tmode_t mask = umask(0002);\n\tret = mkdir(path, 0770);\n\tlasterr = errno;\n\tumask(mask);\n\terrno = lasterr;\n\tif (ret) {\n\t\tif (errno == EEXIST)\n\t\t\tret = 0;\n\t\telse {\n\t\t\tSYSERROR(\"failed to create container path %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tstrcpy(p, path);\n\tif (!lxc_list_empty(&conf->id_map) && chown_mapped_root(p, conf) != 0) {\n\t\tERROR(\"Failed to chown container dir\");\n\t\tret = -1;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "s",
            "len",
            "\"%s/%s\"",
            "c->config_path",
            "c->name"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "c->name"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "c->config_path"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool create_container_dir(struct lxc_container *c)\n{\n\tchar *s;\n\tint len, ret;\n\n\tlen = strlen(c->config_path) + strlen(c->name) + 2;\n\ts = malloc(len);\n\tif (!s)\n\t\treturn false;\n\tret = snprintf(s, len, \"%s/%s\", c->config_path, c->name);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(s);\n\t\treturn false;\n\t}\n\tret = do_create_container_dir(s, c->lxc_conf);\n\tfree(s);\n\treturn ret == 0;\n}"
  },
  {
    "function_name": "do_create_container_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "966-989",
    "snippet": "static int do_create_container_dir(const char *path, struct lxc_conf *conf)\n{\n\tint ret = -1, lasterr;\n\tchar *p = alloca(strlen(path)+1);\n\tmode_t mask = umask(0002);\n\tret = mkdir(path, 0770);\n\tlasterr = errno;\n\tumask(mask);\n\terrno = lasterr;\n\tif (ret) {\n\t\tif (errno == EEXIST)\n\t\t\tret = 0;\n\t\telse {\n\t\t\tSYSERROR(\"failed to create container path %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tstrcpy(p, path);\n\tif (!lxc_list_empty(&conf->id_map) && chown_mapped_root(p, conf) != 0) {\n\t\tERROR(\"Failed to chown container dir\");\n\t\tret = -1;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to chown container dir\""
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chown_mapped_root",
          "args": [
            "p",
            "conf"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "chown_mapped_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3482-3618",
          "snippet": "int chown_mapped_root(char *path, struct lxc_conf *conf)\n{\n\tuid_t rootuid;\n\tgid_t rootgid;\n\tpid_t pid;\n\tunsigned long val;\n\tchar *chownpath = path;\n\n\tif (!get_mapped_rootid(conf, ID_TYPE_UID, &val)) {\n\t\tERROR(\"No mapping for container root\");\n\t\treturn -1;\n\t}\n\trootuid = (uid_t) val;\n\tif (!get_mapped_rootid(conf, ID_TYPE_GID, &val)) {\n\t\tERROR(\"No mapping for container root\");\n\t\treturn -1;\n\t}\n\trootgid = (gid_t) val;\n\n\t/*\n\t * In case of overlay, we want only the writeable layer\n\t * to be chowned\n\t */\n\tif (strncmp(path, \"overlayfs:\", 10) == 0 || strncmp(path, \"aufs:\", 5) == 0) {\n\t\tchownpath = strchr(path, ':');\n\t\tif (!chownpath) {\n\t\t\tERROR(\"Bad overlay path: %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tchownpath = strchr(chownpath+1, ':');\n\t\tif (!chownpath) {\n\t\t\tERROR(\"Bad overlay path: %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tchownpath++;\n\t}\n\tpath = chownpath;\n\tif (geteuid() == 0) {\n\t\tif (chown(path, rootuid, rootgid) < 0) {\n\t\t\tERROR(\"Error chowning %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (rootuid == geteuid()) {\n\t\t// nothing to do\n\t\tINFO(\"%s: container root is our uid;  no need to chown\" ,__func__);\n\t\treturn 0;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"Failed forking\");\n\t\treturn -1;\n\t}\n\tif (!pid) {\n\t\tint hostuid = geteuid(), hostgid = getegid(), ret;\n\t\tstruct stat sb;\n\t\tchar map1[100], map2[100], map3[100], map4[100], map5[100];\n\t\tchar ugid[100];\n\t\tchar *args1[] = { \"lxc-usernsexec\", \"-m\", map1, \"-m\", map2,\n\t\t\t\t\"-m\", map3, \"-m\", map5,\n\t\t\t\t\"--\", \"chown\", ugid, path, NULL };\n\t\tchar *args2[] = { \"lxc-usernsexec\", \"-m\", map1, \"-m\", map2,\n\t\t\t\t\"-m\", map3, \"-m\", map4, \"-m\", map5,\n\t\t\t\t\"--\", \"chown\", ugid, path, NULL };\n\n\t\t// save the current gid of \"path\"\n\t\tif (stat(path, &sb) < 0) {\n\t\t\tERROR(\"Error stat %s\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * A file has to be group-owned by a gid mapped into the\n\t\t * container, or the container won't be privileged over it.\n\t\t */\n\t\tif (sb.st_uid == geteuid() &&\n\t\t\t\tmapped_hostid(sb.st_gid, conf, ID_TYPE_GID) < 0 &&\n\t\t\t\tchown(path, -1, hostgid) < 0) {\n\t\t\tERROR(\"Failed chgrping %s\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"u:0:rootuid:1\"\n\t\tret = snprintf(map1, 100, \"u:0:%d:1\", rootuid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error uid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"u:hostuid:hostuid:1\"\n\t\tret = snprintf(map2, 100, \"u:%d:%d:1\", hostuid, hostuid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error uid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:0:rootgid:1\"\n\t\tret = snprintf(map3, 100, \"g:0:%d:1\", rootgid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:pathgid:rootgid+pathgid:1\"\n\t\tret = snprintf(map4, 100, \"g:%d:%d:1\", (gid_t)sb.st_gid,\n\t\t\t\trootgid + (gid_t)sb.st_gid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:hostgid:hostgid:1\"\n\t\tret = snprintf(map5, 100, \"g:%d:%d:1\", hostgid, hostgid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"0:pathgid\" (chown)\n\t\tret = snprintf(ugid, 100, \"0:%d\", (gid_t)sb.st_gid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error owner printing format string for chown\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (hostgid == sb.st_gid)\n\t\t\tret = execvp(\"lxc-usernsexec\", args1);\n\t\telse\n\t\t\tret = execvp(\"lxc-usernsexec\", args2);\n\t\tSYSERROR(\"Failed executing usernsexec\");\n\t\texit(1);\n\t}\n\treturn wait_for_pid(pid);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint chown_mapped_root(char *path, struct lxc_conf *conf)\n{\n\tuid_t rootuid;\n\tgid_t rootgid;\n\tpid_t pid;\n\tunsigned long val;\n\tchar *chownpath = path;\n\n\tif (!get_mapped_rootid(conf, ID_TYPE_UID, &val)) {\n\t\tERROR(\"No mapping for container root\");\n\t\treturn -1;\n\t}\n\trootuid = (uid_t) val;\n\tif (!get_mapped_rootid(conf, ID_TYPE_GID, &val)) {\n\t\tERROR(\"No mapping for container root\");\n\t\treturn -1;\n\t}\n\trootgid = (gid_t) val;\n\n\t/*\n\t * In case of overlay, we want only the writeable layer\n\t * to be chowned\n\t */\n\tif (strncmp(path, \"overlayfs:\", 10) == 0 || strncmp(path, \"aufs:\", 5) == 0) {\n\t\tchownpath = strchr(path, ':');\n\t\tif (!chownpath) {\n\t\t\tERROR(\"Bad overlay path: %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tchownpath = strchr(chownpath+1, ':');\n\t\tif (!chownpath) {\n\t\t\tERROR(\"Bad overlay path: %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tchownpath++;\n\t}\n\tpath = chownpath;\n\tif (geteuid() == 0) {\n\t\tif (chown(path, rootuid, rootgid) < 0) {\n\t\t\tERROR(\"Error chowning %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (rootuid == geteuid()) {\n\t\t// nothing to do\n\t\tINFO(\"%s: container root is our uid;  no need to chown\" ,__func__);\n\t\treturn 0;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"Failed forking\");\n\t\treturn -1;\n\t}\n\tif (!pid) {\n\t\tint hostuid = geteuid(), hostgid = getegid(), ret;\n\t\tstruct stat sb;\n\t\tchar map1[100], map2[100], map3[100], map4[100], map5[100];\n\t\tchar ugid[100];\n\t\tchar *args1[] = { \"lxc-usernsexec\", \"-m\", map1, \"-m\", map2,\n\t\t\t\t\"-m\", map3, \"-m\", map5,\n\t\t\t\t\"--\", \"chown\", ugid, path, NULL };\n\t\tchar *args2[] = { \"lxc-usernsexec\", \"-m\", map1, \"-m\", map2,\n\t\t\t\t\"-m\", map3, \"-m\", map4, \"-m\", map5,\n\t\t\t\t\"--\", \"chown\", ugid, path, NULL };\n\n\t\t// save the current gid of \"path\"\n\t\tif (stat(path, &sb) < 0) {\n\t\t\tERROR(\"Error stat %s\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * A file has to be group-owned by a gid mapped into the\n\t\t * container, or the container won't be privileged over it.\n\t\t */\n\t\tif (sb.st_uid == geteuid() &&\n\t\t\t\tmapped_hostid(sb.st_gid, conf, ID_TYPE_GID) < 0 &&\n\t\t\t\tchown(path, -1, hostgid) < 0) {\n\t\t\tERROR(\"Failed chgrping %s\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"u:0:rootuid:1\"\n\t\tret = snprintf(map1, 100, \"u:0:%d:1\", rootuid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error uid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"u:hostuid:hostuid:1\"\n\t\tret = snprintf(map2, 100, \"u:%d:%d:1\", hostuid, hostuid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error uid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:0:rootgid:1\"\n\t\tret = snprintf(map3, 100, \"g:0:%d:1\", rootgid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:pathgid:rootgid+pathgid:1\"\n\t\tret = snprintf(map4, 100, \"g:%d:%d:1\", (gid_t)sb.st_gid,\n\t\t\t\trootgid + (gid_t)sb.st_gid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:hostgid:hostgid:1\"\n\t\tret = snprintf(map5, 100, \"g:%d:%d:1\", hostgid, hostgid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"0:pathgid\" (chown)\n\t\tret = snprintf(ugid, 100, \"0:%d\", (gid_t)sb.st_gid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error owner printing format string for chown\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (hostgid == sb.st_gid)\n\t\t\tret = execvp(\"lxc-usernsexec\", args1);\n\t\telse\n\t\t\tret = execvp(\"lxc-usernsexec\", args2);\n\t\tSYSERROR(\"Failed executing usernsexec\");\n\t\texit(1);\n\t}\n\treturn wait_for_pid(pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_empty",
          "args": [
            "&conf->id_map"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "94-97",
          "snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "p",
            "path"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to create container path %s\"",
            "path"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "mask"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "path",
            "0770"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "241-262",
          "snippet": "extern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "0002"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "strlen(path)+1"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic int do_create_container_dir(const char *path, struct lxc_conf *conf)\n{\n\tint ret = -1, lasterr;\n\tchar *p = alloca(strlen(path)+1);\n\tmode_t mask = umask(0002);\n\tret = mkdir(path, 0770);\n\tlasterr = errno;\n\tumask(mask);\n\terrno = lasterr;\n\tif (ret) {\n\t\tif (errno == EEXIST)\n\t\t\tret = 0;\n\t\telse {\n\t\t\tSYSERROR(\"failed to create container path %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tstrcpy(p, path);\n\tif (!lxc_list_empty(&conf->id_map) && chown_mapped_root(p, conf) != 0) {\n\t\tERROR(\"Failed to chown container dir\");\n\t\tret = -1;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "do_lxcapi_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "952-962",
    "snippet": "static bool do_lxcapi_stop(struct lxc_container *c)\n{\n\tint ret;\n\n\tif (!c)\n\t\treturn false;\n\n\tret = lxc_cmd_stop(c->name, c->config_path);\n\n\treturn ret == 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_cmd_stop",
          "args": [
            "c->name",
            "c->config_path"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "599-626",
          "snippet": "int lxc_cmd_stop(const char *name, const char *lxcpath)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_STOP },\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0) {\n\t\tif (stopped) {\n\t\t\tINFO(\"Container \\\"%s\\\" is already stopped.\", name);\n\t\t\treturn 0;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/* we do not expect any answer, because we wait for the connection to be\n\t * closed\n\t */\n\tif (ret > 0) {\n\t\tERROR(\"Failed to stop container \\\"%s\\\": %s.\", name,\n\t\t      strerror(-cmd.rsp.ret));\n\t\treturn -1;\n\t}\n\n\tINFO(\"Container \\\"%s\\\" has stopped.\", name);\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nint lxc_cmd_stop(const char *name, const char *lxcpath)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_STOP },\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0) {\n\t\tif (stopped) {\n\t\t\tINFO(\"Container \\\"%s\\\" is already stopped.\", name);\n\t\t\treturn 0;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/* we do not expect any answer, because we wait for the connection to be\n\t * closed\n\t */\n\tif (ret > 0) {\n\t\tERROR(\"Failed to stop container \\\"%s\\\": %s.\", name,\n\t\t      strerror(-cmd.rsp.ret));\n\t\treturn -1;\n\t}\n\n\tINFO(\"Container \\\"%s\\\" has stopped.\", name);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_stop(struct lxc_container *c)\n{\n\tint ret;\n\n\tif (!c)\n\t\treturn false;\n\n\tret = lxc_cmd_stop(c->name, c->config_path);\n\n\treturn ret == 0;\n}"
  },
  {
    "function_name": "lxcapi_startl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "916-950",
    "snippet": "static bool lxcapi_startl(struct lxc_container *c, int useinit, ...)\n{\n\tva_list ap;\n\tchar **inargs = NULL;\n\tbool bret = false;\n\n\t/* container exists */\n\tif (!c)\n\t\treturn false;\n\n\tcurrent_config = c->lxc_conf;\n\n\tva_start(ap, useinit);\n\tinargs = lxc_va_arg_list_to_argv(ap, 0, 1);\n\tva_end(ap);\n\n\tif (!inargs) {\n\t\tERROR(\"Memory allocation error.\");\n\t\tgoto out;\n\t}\n\n\t/* pass NULL if no arguments were supplied */\n\tbret = do_lxcapi_start(c, useinit, *inargs ? inargs : NULL);\n\nout:\n\tif (inargs) {\n\t\tchar **arg;\n\t\tfor (arg = inargs; *arg; arg++)\n\t\t\tfree(*arg);\n\t\tfree(inargs);\n\t}\n\n\tcurrent_config = NULL;\n\treturn bret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "inargs"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "free_init_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "706-715",
          "snippet": "static void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_lxcapi_start",
          "args": [
            "c",
            "useinit",
            "*inargs ? inargs : NULL"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "do_lxcapi_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "717-902",
          "snippet": "static bool do_lxcapi_start(struct lxc_container *c, int useinit, char * const argv[])\n{\n\tint ret;\n\tstruct lxc_conf *conf;\n\tbool daemonize = false;\n\tFILE *pid_fp = NULL;\n\tchar *default_args[] = {\n\t\t\"/sbin/init\",\n\t\tNULL,\n\t};\n\tchar **init_cmd = NULL;\n\n\t/* container exists */\n\tif (!c)\n\t\treturn false;\n\n\t/* If anything fails before we set error_num, we want an error in there */\n\tc->error_num = 1;\n\n\t/* container has been setup */\n\tif (!c->lxc_conf)\n\t\treturn false;\n\n\tif ((ret = ongoing_create(c)) < 0) {\n\t\tERROR(\"Error checking for incomplete creation\");\n\t\treturn false;\n\t}\n\tif (ret == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tdo_lxcapi_destroy(c);\n\t\treturn false;\n\t} else if (ret == 1) {\n\t\tERROR(\"Error: creation of %s is ongoing\", c->name);\n\t\treturn false;\n\t}\n\n\t/* is this app meant to be run through lxcinit, as in lxc-execute? */\n\tif (useinit && !argv)\n\t\treturn false;\n\n\tif (container_mem_lock(c))\n\t\treturn false;\n\tconf = c->lxc_conf;\n\tdaemonize = c->daemonize;\n\tcontainer_mem_unlock(c);\n\n\tif (useinit) {\n\t\tret = lxc_execute(c->name, argv, 1, conf, c->config_path, daemonize);\n\t\treturn ret == 0 ? true : false;\n\t}\n\n\t/* if no argv was passed in, use lxc.init_cmd if provided in\n\t * configuration */\n\tif (!argv)\n\t\targv = init_cmd = split_init_cmd(conf->init_cmd);\n\n\t/* ... and otherwise use default_args */\n\tif (!argv)\n\t\targv = default_args;\n\n\t/*\n\t* say, I'm not sure - what locks do we want here?  Any?\n\t* Is liblxc's locking enough here to protect the on disk\n\t* container?  We don't want to exclude things like lxc_info\n\t* while container is running...\n\t*/\n\tif (daemonize) {\n\t\tchar title[2048];\n\t\tlxc_monitord_spawn(c->config_path);\n\n\t\tpid_t pid = fork();\n\t\tif (pid < 0)\n\t\t\treturn false;\n\n\t\tif (pid != 0) {\n\t\t\t/* Set to NULL because we don't want father unlink\n\t\t\t * the PID file, child will do the free and unlink.\n\t\t\t */\n\t\t\tc->pidfile = NULL;\n\t\t\treturn wait_on_daemonized_start(c, pid);\n\t\t}\n\n\t\t/* We don't really care if this doesn't print all the\n\t\t * characters; all that it means is that the proctitle will be\n\t\t * ugly. Similarly, we also don't care if setproctitle()\n\t\t * fails. */\n\t\tsnprintf(title, sizeof(title), \"[lxc monitor] %s %s\", c->config_path, c->name);\n\t\tINFO(\"Attempting to set proc title to %s\", title);\n\t\tsetproctitle(title);\n\n\t\t/* second fork to be reparented by init */\n\t\tpid = fork();\n\t\tif (pid < 0) {\n\t\t\tSYSERROR(\"Error doing dual-fork\");\n\t\t\texit(1);\n\t\t}\n\t\tif (pid != 0)\n\t\t\texit(0);\n\t\t/* like daemon(), chdir to / and redirect 0,1,2 to /dev/null */\n\t\tif (chdir(\"/\")) {\n\t\t\tSYSERROR(\"Error chdir()ing to /.\");\n\t\t\texit(1);\n\t\t}\n\t\tlxc_check_inherited(conf, true, -1);\n\t\tif (null_stdfds() < 0) {\n\t\t\tERROR(\"failed to close fds\");\n\t\t\texit(1);\n\t\t}\n\t\tsetsid();\n\t} else {\n\t\tif (!am_single_threaded()) {\n\t\t\tERROR(\"Cannot start non-daemonized container when threaded\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/* We need to write PID file after daeminize, so we always\n\t * write the right PID.\n\t */\n\tif (c->pidfile) {\n\t\tpid_fp = fopen(c->pidfile, \"w\");\n\t\tif (pid_fp == NULL) {\n\t\t\tSYSERROR(\"Failed to create pidfile '%s' for '%s'\",\n\t\t\t\t c->pidfile, c->name);\n\t\t\tif (daemonize)\n\t\t\t\texit(1);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (fprintf(pid_fp, \"%d\\n\", getpid()) < 0) {\n\t\t\tSYSERROR(\"Failed to write '%s'\", c->pidfile);\n\t\t\tfclose(pid_fp);\n\t\t\tpid_fp = NULL;\n\t\t\tif (daemonize)\n\t\t\t\texit(1);\n\t\t\treturn false;\n\t\t}\n\n\t\tfclose(pid_fp);\n\t\tpid_fp = NULL;\n\t}\n\n\tconf->reboot = 0;\n\n\t/* Unshare the mount namespace if requested */\n\tif (conf->monitor_unshare) {\n\t\tif (unshare(CLONE_NEWNS)) {\n\t\t\tSYSERROR(\"failed to unshare mount namespace\");\n\t\t\treturn false;\n\t\t}\n\t\tif (mount(NULL, \"/\", NULL, MS_SLAVE|MS_REC, NULL)) {\n\t\t\tSYSERROR(\"Failed to make / rslave at startup\");\n\t\t\treturn false;\n\t\t}\n\t}\n\nreboot:\n\tif (lxc_check_inherited(conf, daemonize, -1)) {\n\t\tERROR(\"Inherited fds found\");\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tret = lxc_start(c->name, argv, conf, c->config_path, daemonize);\n\tc->error_num = ret;\n\n\tif (conf->reboot == 1) {\n\t\tINFO(\"container requested reboot\");\n\t\tconf->reboot = 2;\n\t\tgoto reboot;\n\t}\n\nout:\n\tif (c->pidfile) {\n\t\tunlink(c->pidfile);\n\t\tfree(c->pidfile);\n\t\tc->pidfile = NULL;\n\t}\n\n\tfree_init_cmd(init_cmd);\n\n\tif (daemonize)\n\t\texit (ret == 0 ? true : false);\n\telse\n\t\treturn (ret == 0 ? true : false);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_start(struct lxc_container *c, int useinit, char * const argv[])\n{\n\tint ret;\n\tstruct lxc_conf *conf;\n\tbool daemonize = false;\n\tFILE *pid_fp = NULL;\n\tchar *default_args[] = {\n\t\t\"/sbin/init\",\n\t\tNULL,\n\t};\n\tchar **init_cmd = NULL;\n\n\t/* container exists */\n\tif (!c)\n\t\treturn false;\n\n\t/* If anything fails before we set error_num, we want an error in there */\n\tc->error_num = 1;\n\n\t/* container has been setup */\n\tif (!c->lxc_conf)\n\t\treturn false;\n\n\tif ((ret = ongoing_create(c)) < 0) {\n\t\tERROR(\"Error checking for incomplete creation\");\n\t\treturn false;\n\t}\n\tif (ret == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tdo_lxcapi_destroy(c);\n\t\treturn false;\n\t} else if (ret == 1) {\n\t\tERROR(\"Error: creation of %s is ongoing\", c->name);\n\t\treturn false;\n\t}\n\n\t/* is this app meant to be run through lxcinit, as in lxc-execute? */\n\tif (useinit && !argv)\n\t\treturn false;\n\n\tif (container_mem_lock(c))\n\t\treturn false;\n\tconf = c->lxc_conf;\n\tdaemonize = c->daemonize;\n\tcontainer_mem_unlock(c);\n\n\tif (useinit) {\n\t\tret = lxc_execute(c->name, argv, 1, conf, c->config_path, daemonize);\n\t\treturn ret == 0 ? true : false;\n\t}\n\n\t/* if no argv was passed in, use lxc.init_cmd if provided in\n\t * configuration */\n\tif (!argv)\n\t\targv = init_cmd = split_init_cmd(conf->init_cmd);\n\n\t/* ... and otherwise use default_args */\n\tif (!argv)\n\t\targv = default_args;\n\n\t/*\n\t* say, I'm not sure - what locks do we want here?  Any?\n\t* Is liblxc's locking enough here to protect the on disk\n\t* container?  We don't want to exclude things like lxc_info\n\t* while container is running...\n\t*/\n\tif (daemonize) {\n\t\tchar title[2048];\n\t\tlxc_monitord_spawn(c->config_path);\n\n\t\tpid_t pid = fork();\n\t\tif (pid < 0)\n\t\t\treturn false;\n\n\t\tif (pid != 0) {\n\t\t\t/* Set to NULL because we don't want father unlink\n\t\t\t * the PID file, child will do the free and unlink.\n\t\t\t */\n\t\t\tc->pidfile = NULL;\n\t\t\treturn wait_on_daemonized_start(c, pid);\n\t\t}\n\n\t\t/* We don't really care if this doesn't print all the\n\t\t * characters; all that it means is that the proctitle will be\n\t\t * ugly. Similarly, we also don't care if setproctitle()\n\t\t * fails. */\n\t\tsnprintf(title, sizeof(title), \"[lxc monitor] %s %s\", c->config_path, c->name);\n\t\tINFO(\"Attempting to set proc title to %s\", title);\n\t\tsetproctitle(title);\n\n\t\t/* second fork to be reparented by init */\n\t\tpid = fork();\n\t\tif (pid < 0) {\n\t\t\tSYSERROR(\"Error doing dual-fork\");\n\t\t\texit(1);\n\t\t}\n\t\tif (pid != 0)\n\t\t\texit(0);\n\t\t/* like daemon(), chdir to / and redirect 0,1,2 to /dev/null */\n\t\tif (chdir(\"/\")) {\n\t\t\tSYSERROR(\"Error chdir()ing to /.\");\n\t\t\texit(1);\n\t\t}\n\t\tlxc_check_inherited(conf, true, -1);\n\t\tif (null_stdfds() < 0) {\n\t\t\tERROR(\"failed to close fds\");\n\t\t\texit(1);\n\t\t}\n\t\tsetsid();\n\t} else {\n\t\tif (!am_single_threaded()) {\n\t\t\tERROR(\"Cannot start non-daemonized container when threaded\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/* We need to write PID file after daeminize, so we always\n\t * write the right PID.\n\t */\n\tif (c->pidfile) {\n\t\tpid_fp = fopen(c->pidfile, \"w\");\n\t\tif (pid_fp == NULL) {\n\t\t\tSYSERROR(\"Failed to create pidfile '%s' for '%s'\",\n\t\t\t\t c->pidfile, c->name);\n\t\t\tif (daemonize)\n\t\t\t\texit(1);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (fprintf(pid_fp, \"%d\\n\", getpid()) < 0) {\n\t\t\tSYSERROR(\"Failed to write '%s'\", c->pidfile);\n\t\t\tfclose(pid_fp);\n\t\t\tpid_fp = NULL;\n\t\t\tif (daemonize)\n\t\t\t\texit(1);\n\t\t\treturn false;\n\t\t}\n\n\t\tfclose(pid_fp);\n\t\tpid_fp = NULL;\n\t}\n\n\tconf->reboot = 0;\n\n\t/* Unshare the mount namespace if requested */\n\tif (conf->monitor_unshare) {\n\t\tif (unshare(CLONE_NEWNS)) {\n\t\t\tSYSERROR(\"failed to unshare mount namespace\");\n\t\t\treturn false;\n\t\t}\n\t\tif (mount(NULL, \"/\", NULL, MS_SLAVE|MS_REC, NULL)) {\n\t\t\tSYSERROR(\"Failed to make / rslave at startup\");\n\t\t\treturn false;\n\t\t}\n\t}\n\nreboot:\n\tif (lxc_check_inherited(conf, daemonize, -1)) {\n\t\tERROR(\"Inherited fds found\");\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tret = lxc_start(c->name, argv, conf, c->config_path, daemonize);\n\tc->error_num = ret;\n\n\tif (conf->reboot == 1) {\n\t\tINFO(\"container requested reboot\");\n\t\tconf->reboot = 2;\n\t\tgoto reboot;\n\t}\n\nout:\n\tif (c->pidfile) {\n\t\tunlink(c->pidfile);\n\t\tfree(c->pidfile);\n\t\tc->pidfile = NULL;\n\t}\n\n\tfree_init_cmd(init_cmd);\n\n\tif (daemonize)\n\t\texit (ret == 0 ? true : false);\n\telse\n\t\treturn (ret == 0 ? true : false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Memory allocation error.\""
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ap"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_va_arg_list_to_argv",
          "args": [
            "ap",
            "0",
            "1"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_va_arg_list_to_argv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "424-462",
          "snippet": "char** lxc_va_arg_list_to_argv(va_list ap, size_t skip, int do_strdup)\n{\n\tva_list ap2;\n\tsize_t count = 1 + skip;\n\tchar **result;\n\n\t/* first determine size of argument list, we don't want to reallocate\n\t * constantly...\n\t */\n\tva_copy(ap2, ap);\n\twhile (1) {\n\t\tchar* arg = va_arg(ap2, char*);\n\t\tif (!arg)\n\t\t\tbreak;\n\t\tcount++;\n\t}\n\tva_end(ap2);\n\n\tresult = calloc(count, sizeof(char*));\n\tif (!result)\n\t\treturn NULL;\n\tcount = skip;\n\twhile (1) {\n\t\tchar* arg = va_arg(ap, char*);\n\t\tif (!arg)\n\t\t\tbreak;\n\t\targ = do_strdup ? strdup(arg) : arg;\n\t\tif (!arg)\n\t\t\tgoto oom;\n\t\tresult[count++] = arg;\n\t}\n\n\t/* calloc has already set last element to NULL*/\n\treturn result;\n\noom:\n\tfree(result);\n\treturn NULL;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar** lxc_va_arg_list_to_argv(va_list ap, size_t skip, int do_strdup)\n{\n\tva_list ap2;\n\tsize_t count = 1 + skip;\n\tchar **result;\n\n\t/* first determine size of argument list, we don't want to reallocate\n\t * constantly...\n\t */\n\tva_copy(ap2, ap);\n\twhile (1) {\n\t\tchar* arg = va_arg(ap2, char*);\n\t\tif (!arg)\n\t\t\tbreak;\n\t\tcount++;\n\t}\n\tva_end(ap2);\n\n\tresult = calloc(count, sizeof(char*));\n\tif (!result)\n\t\treturn NULL;\n\tcount = skip;\n\twhile (1) {\n\t\tchar* arg = va_arg(ap, char*);\n\t\tif (!arg)\n\t\t\tbreak;\n\t\targ = do_strdup ? strdup(arg) : arg;\n\t\tif (!arg)\n\t\t\tgoto oom;\n\t\tresult[count++] = arg;\n\t}\n\n\t/* calloc has already set last element to NULL*/\n\treturn result;\n\noom:\n\tfree(result);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "ap",
            "useinit"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool lxcapi_startl(struct lxc_container *c, int useinit, ...)\n{\n\tva_list ap;\n\tchar **inargs = NULL;\n\tbool bret = false;\n\n\t/* container exists */\n\tif (!c)\n\t\treturn false;\n\n\tcurrent_config = c->lxc_conf;\n\n\tva_start(ap, useinit);\n\tinargs = lxc_va_arg_list_to_argv(ap, 0, 1);\n\tva_end(ap);\n\n\tif (!inargs) {\n\t\tERROR(\"Memory allocation error.\");\n\t\tgoto out;\n\t}\n\n\t/* pass NULL if no arguments were supplied */\n\tbret = do_lxcapi_start(c, useinit, *inargs ? inargs : NULL);\n\nout:\n\tif (inargs) {\n\t\tchar **arg;\n\t\tfor (arg = inargs; *arg; arg++)\n\t\t\tfree(*arg);\n\t\tfree(inargs);\n\t}\n\n\tcurrent_config = NULL;\n\treturn bret;\n}"
  },
  {
    "function_name": "lxcapi_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "904-911",
    "snippet": "static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv[])\n{\n\tbool ret;\n\tcurrent_config = c ? c->lxc_conf : NULL;\n\tret = do_lxcapi_start(c, useinit, argv);\n\tcurrent_config = NULL;\n\treturn ret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_lxcapi_start",
          "args": [
            "c",
            "useinit",
            "argv"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "do_lxcapi_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "717-902",
          "snippet": "static bool do_lxcapi_start(struct lxc_container *c, int useinit, char * const argv[])\n{\n\tint ret;\n\tstruct lxc_conf *conf;\n\tbool daemonize = false;\n\tFILE *pid_fp = NULL;\n\tchar *default_args[] = {\n\t\t\"/sbin/init\",\n\t\tNULL,\n\t};\n\tchar **init_cmd = NULL;\n\n\t/* container exists */\n\tif (!c)\n\t\treturn false;\n\n\t/* If anything fails before we set error_num, we want an error in there */\n\tc->error_num = 1;\n\n\t/* container has been setup */\n\tif (!c->lxc_conf)\n\t\treturn false;\n\n\tif ((ret = ongoing_create(c)) < 0) {\n\t\tERROR(\"Error checking for incomplete creation\");\n\t\treturn false;\n\t}\n\tif (ret == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tdo_lxcapi_destroy(c);\n\t\treturn false;\n\t} else if (ret == 1) {\n\t\tERROR(\"Error: creation of %s is ongoing\", c->name);\n\t\treturn false;\n\t}\n\n\t/* is this app meant to be run through lxcinit, as in lxc-execute? */\n\tif (useinit && !argv)\n\t\treturn false;\n\n\tif (container_mem_lock(c))\n\t\treturn false;\n\tconf = c->lxc_conf;\n\tdaemonize = c->daemonize;\n\tcontainer_mem_unlock(c);\n\n\tif (useinit) {\n\t\tret = lxc_execute(c->name, argv, 1, conf, c->config_path, daemonize);\n\t\treturn ret == 0 ? true : false;\n\t}\n\n\t/* if no argv was passed in, use lxc.init_cmd if provided in\n\t * configuration */\n\tif (!argv)\n\t\targv = init_cmd = split_init_cmd(conf->init_cmd);\n\n\t/* ... and otherwise use default_args */\n\tif (!argv)\n\t\targv = default_args;\n\n\t/*\n\t* say, I'm not sure - what locks do we want here?  Any?\n\t* Is liblxc's locking enough here to protect the on disk\n\t* container?  We don't want to exclude things like lxc_info\n\t* while container is running...\n\t*/\n\tif (daemonize) {\n\t\tchar title[2048];\n\t\tlxc_monitord_spawn(c->config_path);\n\n\t\tpid_t pid = fork();\n\t\tif (pid < 0)\n\t\t\treturn false;\n\n\t\tif (pid != 0) {\n\t\t\t/* Set to NULL because we don't want father unlink\n\t\t\t * the PID file, child will do the free and unlink.\n\t\t\t */\n\t\t\tc->pidfile = NULL;\n\t\t\treturn wait_on_daemonized_start(c, pid);\n\t\t}\n\n\t\t/* We don't really care if this doesn't print all the\n\t\t * characters; all that it means is that the proctitle will be\n\t\t * ugly. Similarly, we also don't care if setproctitle()\n\t\t * fails. */\n\t\tsnprintf(title, sizeof(title), \"[lxc monitor] %s %s\", c->config_path, c->name);\n\t\tINFO(\"Attempting to set proc title to %s\", title);\n\t\tsetproctitle(title);\n\n\t\t/* second fork to be reparented by init */\n\t\tpid = fork();\n\t\tif (pid < 0) {\n\t\t\tSYSERROR(\"Error doing dual-fork\");\n\t\t\texit(1);\n\t\t}\n\t\tif (pid != 0)\n\t\t\texit(0);\n\t\t/* like daemon(), chdir to / and redirect 0,1,2 to /dev/null */\n\t\tif (chdir(\"/\")) {\n\t\t\tSYSERROR(\"Error chdir()ing to /.\");\n\t\t\texit(1);\n\t\t}\n\t\tlxc_check_inherited(conf, true, -1);\n\t\tif (null_stdfds() < 0) {\n\t\t\tERROR(\"failed to close fds\");\n\t\t\texit(1);\n\t\t}\n\t\tsetsid();\n\t} else {\n\t\tif (!am_single_threaded()) {\n\t\t\tERROR(\"Cannot start non-daemonized container when threaded\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/* We need to write PID file after daeminize, so we always\n\t * write the right PID.\n\t */\n\tif (c->pidfile) {\n\t\tpid_fp = fopen(c->pidfile, \"w\");\n\t\tif (pid_fp == NULL) {\n\t\t\tSYSERROR(\"Failed to create pidfile '%s' for '%s'\",\n\t\t\t\t c->pidfile, c->name);\n\t\t\tif (daemonize)\n\t\t\t\texit(1);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (fprintf(pid_fp, \"%d\\n\", getpid()) < 0) {\n\t\t\tSYSERROR(\"Failed to write '%s'\", c->pidfile);\n\t\t\tfclose(pid_fp);\n\t\t\tpid_fp = NULL;\n\t\t\tif (daemonize)\n\t\t\t\texit(1);\n\t\t\treturn false;\n\t\t}\n\n\t\tfclose(pid_fp);\n\t\tpid_fp = NULL;\n\t}\n\n\tconf->reboot = 0;\n\n\t/* Unshare the mount namespace if requested */\n\tif (conf->monitor_unshare) {\n\t\tif (unshare(CLONE_NEWNS)) {\n\t\t\tSYSERROR(\"failed to unshare mount namespace\");\n\t\t\treturn false;\n\t\t}\n\t\tif (mount(NULL, \"/\", NULL, MS_SLAVE|MS_REC, NULL)) {\n\t\t\tSYSERROR(\"Failed to make / rslave at startup\");\n\t\t\treturn false;\n\t\t}\n\t}\n\nreboot:\n\tif (lxc_check_inherited(conf, daemonize, -1)) {\n\t\tERROR(\"Inherited fds found\");\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tret = lxc_start(c->name, argv, conf, c->config_path, daemonize);\n\tc->error_num = ret;\n\n\tif (conf->reboot == 1) {\n\t\tINFO(\"container requested reboot\");\n\t\tconf->reboot = 2;\n\t\tgoto reboot;\n\t}\n\nout:\n\tif (c->pidfile) {\n\t\tunlink(c->pidfile);\n\t\tfree(c->pidfile);\n\t\tc->pidfile = NULL;\n\t}\n\n\tfree_init_cmd(init_cmd);\n\n\tif (daemonize)\n\t\texit (ret == 0 ? true : false);\n\telse\n\t\treturn (ret == 0 ? true : false);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_start(struct lxc_container *c, int useinit, char * const argv[])\n{\n\tint ret;\n\tstruct lxc_conf *conf;\n\tbool daemonize = false;\n\tFILE *pid_fp = NULL;\n\tchar *default_args[] = {\n\t\t\"/sbin/init\",\n\t\tNULL,\n\t};\n\tchar **init_cmd = NULL;\n\n\t/* container exists */\n\tif (!c)\n\t\treturn false;\n\n\t/* If anything fails before we set error_num, we want an error in there */\n\tc->error_num = 1;\n\n\t/* container has been setup */\n\tif (!c->lxc_conf)\n\t\treturn false;\n\n\tif ((ret = ongoing_create(c)) < 0) {\n\t\tERROR(\"Error checking for incomplete creation\");\n\t\treturn false;\n\t}\n\tif (ret == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tdo_lxcapi_destroy(c);\n\t\treturn false;\n\t} else if (ret == 1) {\n\t\tERROR(\"Error: creation of %s is ongoing\", c->name);\n\t\treturn false;\n\t}\n\n\t/* is this app meant to be run through lxcinit, as in lxc-execute? */\n\tif (useinit && !argv)\n\t\treturn false;\n\n\tif (container_mem_lock(c))\n\t\treturn false;\n\tconf = c->lxc_conf;\n\tdaemonize = c->daemonize;\n\tcontainer_mem_unlock(c);\n\n\tif (useinit) {\n\t\tret = lxc_execute(c->name, argv, 1, conf, c->config_path, daemonize);\n\t\treturn ret == 0 ? true : false;\n\t}\n\n\t/* if no argv was passed in, use lxc.init_cmd if provided in\n\t * configuration */\n\tif (!argv)\n\t\targv = init_cmd = split_init_cmd(conf->init_cmd);\n\n\t/* ... and otherwise use default_args */\n\tif (!argv)\n\t\targv = default_args;\n\n\t/*\n\t* say, I'm not sure - what locks do we want here?  Any?\n\t* Is liblxc's locking enough here to protect the on disk\n\t* container?  We don't want to exclude things like lxc_info\n\t* while container is running...\n\t*/\n\tif (daemonize) {\n\t\tchar title[2048];\n\t\tlxc_monitord_spawn(c->config_path);\n\n\t\tpid_t pid = fork();\n\t\tif (pid < 0)\n\t\t\treturn false;\n\n\t\tif (pid != 0) {\n\t\t\t/* Set to NULL because we don't want father unlink\n\t\t\t * the PID file, child will do the free and unlink.\n\t\t\t */\n\t\t\tc->pidfile = NULL;\n\t\t\treturn wait_on_daemonized_start(c, pid);\n\t\t}\n\n\t\t/* We don't really care if this doesn't print all the\n\t\t * characters; all that it means is that the proctitle will be\n\t\t * ugly. Similarly, we also don't care if setproctitle()\n\t\t * fails. */\n\t\tsnprintf(title, sizeof(title), \"[lxc monitor] %s %s\", c->config_path, c->name);\n\t\tINFO(\"Attempting to set proc title to %s\", title);\n\t\tsetproctitle(title);\n\n\t\t/* second fork to be reparented by init */\n\t\tpid = fork();\n\t\tif (pid < 0) {\n\t\t\tSYSERROR(\"Error doing dual-fork\");\n\t\t\texit(1);\n\t\t}\n\t\tif (pid != 0)\n\t\t\texit(0);\n\t\t/* like daemon(), chdir to / and redirect 0,1,2 to /dev/null */\n\t\tif (chdir(\"/\")) {\n\t\t\tSYSERROR(\"Error chdir()ing to /.\");\n\t\t\texit(1);\n\t\t}\n\t\tlxc_check_inherited(conf, true, -1);\n\t\tif (null_stdfds() < 0) {\n\t\t\tERROR(\"failed to close fds\");\n\t\t\texit(1);\n\t\t}\n\t\tsetsid();\n\t} else {\n\t\tif (!am_single_threaded()) {\n\t\t\tERROR(\"Cannot start non-daemonized container when threaded\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/* We need to write PID file after daeminize, so we always\n\t * write the right PID.\n\t */\n\tif (c->pidfile) {\n\t\tpid_fp = fopen(c->pidfile, \"w\");\n\t\tif (pid_fp == NULL) {\n\t\t\tSYSERROR(\"Failed to create pidfile '%s' for '%s'\",\n\t\t\t\t c->pidfile, c->name);\n\t\t\tif (daemonize)\n\t\t\t\texit(1);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (fprintf(pid_fp, \"%d\\n\", getpid()) < 0) {\n\t\t\tSYSERROR(\"Failed to write '%s'\", c->pidfile);\n\t\t\tfclose(pid_fp);\n\t\t\tpid_fp = NULL;\n\t\t\tif (daemonize)\n\t\t\t\texit(1);\n\t\t\treturn false;\n\t\t}\n\n\t\tfclose(pid_fp);\n\t\tpid_fp = NULL;\n\t}\n\n\tconf->reboot = 0;\n\n\t/* Unshare the mount namespace if requested */\n\tif (conf->monitor_unshare) {\n\t\tif (unshare(CLONE_NEWNS)) {\n\t\t\tSYSERROR(\"failed to unshare mount namespace\");\n\t\t\treturn false;\n\t\t}\n\t\tif (mount(NULL, \"/\", NULL, MS_SLAVE|MS_REC, NULL)) {\n\t\t\tSYSERROR(\"Failed to make / rslave at startup\");\n\t\t\treturn false;\n\t\t}\n\t}\n\nreboot:\n\tif (lxc_check_inherited(conf, daemonize, -1)) {\n\t\tERROR(\"Inherited fds found\");\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tret = lxc_start(c->name, argv, conf, c->config_path, daemonize);\n\tc->error_num = ret;\n\n\tif (conf->reboot == 1) {\n\t\tINFO(\"container requested reboot\");\n\t\tconf->reboot = 2;\n\t\tgoto reboot;\n\t}\n\nout:\n\tif (c->pidfile) {\n\t\tunlink(c->pidfile);\n\t\tfree(c->pidfile);\n\t\tc->pidfile = NULL;\n\t}\n\n\tfree_init_cmd(init_cmd);\n\n\tif (daemonize)\n\t\texit (ret == 0 ? true : false);\n\telse\n\t\treturn (ret == 0 ? true : false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv[])\n{\n\tbool ret;\n\tcurrent_config = c ? c->lxc_conf : NULL;\n\tret = do_lxcapi_start(c, useinit, argv);\n\tcurrent_config = NULL;\n\treturn ret;\n}"
  },
  {
    "function_name": "do_lxcapi_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "717-902",
    "snippet": "static bool do_lxcapi_start(struct lxc_container *c, int useinit, char * const argv[])\n{\n\tint ret;\n\tstruct lxc_conf *conf;\n\tbool daemonize = false;\n\tFILE *pid_fp = NULL;\n\tchar *default_args[] = {\n\t\t\"/sbin/init\",\n\t\tNULL,\n\t};\n\tchar **init_cmd = NULL;\n\n\t/* container exists */\n\tif (!c)\n\t\treturn false;\n\n\t/* If anything fails before we set error_num, we want an error in there */\n\tc->error_num = 1;\n\n\t/* container has been setup */\n\tif (!c->lxc_conf)\n\t\treturn false;\n\n\tif ((ret = ongoing_create(c)) < 0) {\n\t\tERROR(\"Error checking for incomplete creation\");\n\t\treturn false;\n\t}\n\tif (ret == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tdo_lxcapi_destroy(c);\n\t\treturn false;\n\t} else if (ret == 1) {\n\t\tERROR(\"Error: creation of %s is ongoing\", c->name);\n\t\treturn false;\n\t}\n\n\t/* is this app meant to be run through lxcinit, as in lxc-execute? */\n\tif (useinit && !argv)\n\t\treturn false;\n\n\tif (container_mem_lock(c))\n\t\treturn false;\n\tconf = c->lxc_conf;\n\tdaemonize = c->daemonize;\n\tcontainer_mem_unlock(c);\n\n\tif (useinit) {\n\t\tret = lxc_execute(c->name, argv, 1, conf, c->config_path, daemonize);\n\t\treturn ret == 0 ? true : false;\n\t}\n\n\t/* if no argv was passed in, use lxc.init_cmd if provided in\n\t * configuration */\n\tif (!argv)\n\t\targv = init_cmd = split_init_cmd(conf->init_cmd);\n\n\t/* ... and otherwise use default_args */\n\tif (!argv)\n\t\targv = default_args;\n\n\t/*\n\t* say, I'm not sure - what locks do we want here?  Any?\n\t* Is liblxc's locking enough here to protect the on disk\n\t* container?  We don't want to exclude things like lxc_info\n\t* while container is running...\n\t*/\n\tif (daemonize) {\n\t\tchar title[2048];\n\t\tlxc_monitord_spawn(c->config_path);\n\n\t\tpid_t pid = fork();\n\t\tif (pid < 0)\n\t\t\treturn false;\n\n\t\tif (pid != 0) {\n\t\t\t/* Set to NULL because we don't want father unlink\n\t\t\t * the PID file, child will do the free and unlink.\n\t\t\t */\n\t\t\tc->pidfile = NULL;\n\t\t\treturn wait_on_daemonized_start(c, pid);\n\t\t}\n\n\t\t/* We don't really care if this doesn't print all the\n\t\t * characters; all that it means is that the proctitle will be\n\t\t * ugly. Similarly, we also don't care if setproctitle()\n\t\t * fails. */\n\t\tsnprintf(title, sizeof(title), \"[lxc monitor] %s %s\", c->config_path, c->name);\n\t\tINFO(\"Attempting to set proc title to %s\", title);\n\t\tsetproctitle(title);\n\n\t\t/* second fork to be reparented by init */\n\t\tpid = fork();\n\t\tif (pid < 0) {\n\t\t\tSYSERROR(\"Error doing dual-fork\");\n\t\t\texit(1);\n\t\t}\n\t\tif (pid != 0)\n\t\t\texit(0);\n\t\t/* like daemon(), chdir to / and redirect 0,1,2 to /dev/null */\n\t\tif (chdir(\"/\")) {\n\t\t\tSYSERROR(\"Error chdir()ing to /.\");\n\t\t\texit(1);\n\t\t}\n\t\tlxc_check_inherited(conf, true, -1);\n\t\tif (null_stdfds() < 0) {\n\t\t\tERROR(\"failed to close fds\");\n\t\t\texit(1);\n\t\t}\n\t\tsetsid();\n\t} else {\n\t\tif (!am_single_threaded()) {\n\t\t\tERROR(\"Cannot start non-daemonized container when threaded\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/* We need to write PID file after daeminize, so we always\n\t * write the right PID.\n\t */\n\tif (c->pidfile) {\n\t\tpid_fp = fopen(c->pidfile, \"w\");\n\t\tif (pid_fp == NULL) {\n\t\t\tSYSERROR(\"Failed to create pidfile '%s' for '%s'\",\n\t\t\t\t c->pidfile, c->name);\n\t\t\tif (daemonize)\n\t\t\t\texit(1);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (fprintf(pid_fp, \"%d\\n\", getpid()) < 0) {\n\t\t\tSYSERROR(\"Failed to write '%s'\", c->pidfile);\n\t\t\tfclose(pid_fp);\n\t\t\tpid_fp = NULL;\n\t\t\tif (daemonize)\n\t\t\t\texit(1);\n\t\t\treturn false;\n\t\t}\n\n\t\tfclose(pid_fp);\n\t\tpid_fp = NULL;\n\t}\n\n\tconf->reboot = 0;\n\n\t/* Unshare the mount namespace if requested */\n\tif (conf->monitor_unshare) {\n\t\tif (unshare(CLONE_NEWNS)) {\n\t\t\tSYSERROR(\"failed to unshare mount namespace\");\n\t\t\treturn false;\n\t\t}\n\t\tif (mount(NULL, \"/\", NULL, MS_SLAVE|MS_REC, NULL)) {\n\t\t\tSYSERROR(\"Failed to make / rslave at startup\");\n\t\t\treturn false;\n\t\t}\n\t}\n\nreboot:\n\tif (lxc_check_inherited(conf, daemonize, -1)) {\n\t\tERROR(\"Inherited fds found\");\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tret = lxc_start(c->name, argv, conf, c->config_path, daemonize);\n\tc->error_num = ret;\n\n\tif (conf->reboot == 1) {\n\t\tINFO(\"container requested reboot\");\n\t\tconf->reboot = 2;\n\t\tgoto reboot;\n\t}\n\nout:\n\tif (c->pidfile) {\n\t\tunlink(c->pidfile);\n\t\tfree(c->pidfile);\n\t\tc->pidfile = NULL;\n\t}\n\n\tfree_init_cmd(init_cmd);\n\n\tif (daemonize)\n\t\texit (ret == 0 ? true : false);\n\telse\n\t\treturn (ret == 0 ? true : false);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "ret == 0 ? true : false"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_init_cmd",
          "args": [
            "init_cmd"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "free_init_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "706-715",
          "snippet": "static void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "c->pidfile"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"container requested reboot\""
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_start",
          "args": [
            "c->name",
            "argv",
            "conf",
            "c->config_path",
            "daemonize"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "1477-1486",
          "snippet": "int lxc_start(const char *name, char *const argv[], struct lxc_conf *conf,\n\t      const char *lxcpath, bool backgrounded)\n{\n\tstruct start_args start_arg = {\n\t\t.argv = argv,\n\t};\n\n\tconf->need_utmp_watch = 1;\n\treturn __lxc_start(name, conf, &start_ops, &start_arg, lxcpath, backgrounded);\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_destroy_container(struct lxc_conf *conf);",
            "static void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);",
            "static struct lxc_operations start_ops = {\n\t.start = start,\n\t.post_start = post_start\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic bool do_destroy_container(struct lxc_conf *conf);\nstatic void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);\nstatic struct lxc_operations start_ops = {\n\t.start = start,\n\t.post_start = post_start\n};\n\nint lxc_start(const char *name, char *const argv[], struct lxc_conf *conf,\n\t      const char *lxcpath, bool backgrounded)\n{\n\tstruct start_args start_arg = {\n\t\t.argv = argv,\n\t};\n\n\tconf->need_utmp_watch = 1;\n\treturn __lxc_start(name, conf, &start_ops, &start_arg, lxcpath, backgrounded);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Inherited fds found\""
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_check_inherited",
          "args": [
            "conf",
            "daemonize",
            "-1"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_check_inherited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "198-257",
          "snippet": "int lxc_check_inherited(struct lxc_conf *conf, bool closeall, int fd_to_ignore)\n{\n\tstruct dirent *direntp;\n\tint fd, fddir;\n\tDIR *dir;\n\n\tif (conf && conf->close_all_fds)\n\t\tcloseall = true;\n\nrestart:\n\tdir = opendir(\"/proc/self/fd\");\n\tif (!dir) {\n\t\tWARN(\"Failed to open directory: %m.\");\n\t\treturn -1;\n\t}\n\n\tfddir = dirfd(dir);\n\n\twhile ((direntp = readdir(dir))) {\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\"))\n\t\t\tcontinue;\n\n\t\tif (!strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\tif (lxc_safe_int(direntp->d_name, &fd) < 0) {\n\t\t\tINFO(\"Could not parse file descriptor for: %s\", direntp->d_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fd == fddir || fd == lxc_log_fd || fd == fd_to_ignore)\n\t\t\tcontinue;\n\n\t\tif (current_config && fd == current_config->logfd)\n\t\t\tcontinue;\n\n\t\tif (match_fd(fd))\n\t\t\tcontinue;\n\n\t\tif (closeall) {\n\t\t\tclose(fd);\n\t\t\tclosedir(dir);\n\t\t\tINFO(\"Closed inherited fd: %d.\", fd);\n\t\t\tgoto restart;\n\t\t}\n\t\tWARN(\"Inherited fd: %d.\", fd);\n\t}\n\n\t/* Only enable syslog at this point to avoid the above logging function\n\t * to open a new fd and make the check_inherited function enter an\n\t * infinite loop.\n\t */\n\tlxc_log_enable_syslog();\n\n\tclosedir(dir); /* cannot fail */\n\treturn 0;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_destroy_container(struct lxc_conf *conf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic bool do_destroy_container(struct lxc_conf *conf);\n\nint lxc_check_inherited(struct lxc_conf *conf, bool closeall, int fd_to_ignore)\n{\n\tstruct dirent *direntp;\n\tint fd, fddir;\n\tDIR *dir;\n\n\tif (conf && conf->close_all_fds)\n\t\tcloseall = true;\n\nrestart:\n\tdir = opendir(\"/proc/self/fd\");\n\tif (!dir) {\n\t\tWARN(\"Failed to open directory: %m.\");\n\t\treturn -1;\n\t}\n\n\tfddir = dirfd(dir);\n\n\twhile ((direntp = readdir(dir))) {\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\"))\n\t\t\tcontinue;\n\n\t\tif (!strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\tif (lxc_safe_int(direntp->d_name, &fd) < 0) {\n\t\t\tINFO(\"Could not parse file descriptor for: %s\", direntp->d_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fd == fddir || fd == lxc_log_fd || fd == fd_to_ignore)\n\t\t\tcontinue;\n\n\t\tif (current_config && fd == current_config->logfd)\n\t\t\tcontinue;\n\n\t\tif (match_fd(fd))\n\t\t\tcontinue;\n\n\t\tif (closeall) {\n\t\t\tclose(fd);\n\t\t\tclosedir(dir);\n\t\t\tINFO(\"Closed inherited fd: %d.\", fd);\n\t\t\tgoto restart;\n\t\t}\n\t\tWARN(\"Inherited fd: %d.\", fd);\n\t}\n\n\t/* Only enable syslog at this point to avoid the above logging function\n\t * to open a new fd and make the check_inherited function enter an\n\t * infinite loop.\n\t */\n\tlxc_log_enable_syslog();\n\n\tclosedir(dir); /* cannot fail */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to make / rslave at startup\""
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "NULL",
            "\"/\"",
            "NULL",
            "MS_SLAVE|MS_REC",
            "NULL"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "mount_entry_on_generic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1838-1869",
          "snippet": "static inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to unshare mount namespace\""
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unshare",
          "args": [
            "CLONE_NEWNS"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "unshare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.h",
          "lines": "73-81",
          "snippet": "static inline int unshare(int flags)\n{\n#ifdef __NR_unshare\n\treturn syscall(__NR_unshare, flags);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}",
          "includes": [
            "#include <stdint.h>",
            "#  include <sys/signalfd.h>",
            "#include <../include/getline.h>",
            "#include \"initutils.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#  include <sys/signalfd.h>\n#include <../include/getline.h>\n#include \"initutils.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic inline int unshare(int flags)\n{\n#ifdef __NR_unshare\n\treturn syscall(__NR_unshare, flags);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "pid_fp"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "pid_fp"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to write '%s'\"",
            "c->pidfile"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "pid_fp",
            "\"%d\\n\"",
            "getpid()"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to create pidfile '%s' for '%s'\"",
            "c->pidfile",
            "c->name"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "c->pidfile",
            "\"w\""
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Cannot start non-daemonized container when threaded\""
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "am_single_threaded",
          "args": [],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "am_single_threaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "631-657",
          "snippet": "static bool am_single_threaded(void)\n{\n\tstruct dirent *direntp;\n\tDIR *dir;\n\tint count=0;\n\n\tdir = opendir(\"/proc/self/task\");\n\tif (!dir) {\n\t\tINFO(\"failed to open /proc/self/task\");\n\t\treturn false;\n\t}\n\n\twhile ((direntp = readdir(dir))) {\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\"))\n\t\t\tcontinue;\n\n\t\tif (!strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tif (++count > 1)\n\t\t\tbreak;\n\t}\n\tclosedir(dir);\n\treturn count == 1;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool am_single_threaded(void)\n{\n\tstruct dirent *direntp;\n\tDIR *dir;\n\tint count=0;\n\n\tdir = opendir(\"/proc/self/task\");\n\tif (!dir) {\n\t\tINFO(\"failed to open /proc/self/task\");\n\t\treturn false;\n\t}\n\n\twhile ((direntp = readdir(dir))) {\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\"))\n\t\t\tcontinue;\n\n\t\tif (!strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tif (++count > 1)\n\t\t\tbreak;\n\t}\n\tclosedir(dir);\n\treturn count == 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setsid",
          "args": [],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to close fds\""
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "null_stdfds",
          "args": [],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "null_stdfds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1828-1839",
          "snippet": "int null_stdfds(void)\n{\n\tint ret = -1;\n\tint fd = open_devnull();\n\n\tif (fd >= 0) {\n\t\tret = set_stdfds(fd);\n\t\tclose(fd);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint null_stdfds(void)\n{\n\tint ret = -1;\n\tint fd = open_devnull();\n\n\tif (fd >= 0) {\n\t\tret = set_stdfds(fd);\n\t\tclose(fd);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error chdir()ing to /.\""
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "\"/\""
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error doing dual-fork\""
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setproctitle",
          "args": [
            "title"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "setproctitle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1411-1509",
          "snippet": "int setproctitle(char *title)\n{\n\tstatic char *proctitle = NULL;\n\tchar buf[2048], *tmp;\n\tFILE *f;\n\tint i, len, ret = 0;\n\n\t/* We don't really need to know all of this stuff, but unfortunately\n\t * PR_SET_MM_MAP requires us to set it all at once, so we have to\n\t * figure it out anyway.\n\t */\n\tunsigned long start_data, end_data, start_brk, start_code, end_code,\n\t\t\tstart_stack, arg_start, arg_end, env_start, env_end,\n\t\t\tbrk_val;\n\tstruct prctl_mm_map prctl_map;\n\n\tf = fopen_cloexec(\"/proc/self/stat\", \"r\");\n\tif (!f) {\n\t\treturn -1;\n\t}\n\n\ttmp = fgets(buf, sizeof(buf), f);\n\tfclose(f);\n\tif (!tmp) {\n\t\treturn -1;\n\t}\n\n\t/* Skip the first 25 fields, column 26-28 are start_code, end_code,\n\t * and start_stack */\n\ttmp = strchr(buf, ' ');\n\tfor (i = 0; i < 24; i++) {\n\t\tif (!tmp)\n\t\t\treturn -1;\n\t\ttmp = strchr(tmp+1, ' ');\n\t}\n\tif (!tmp)\n\t\treturn -1;\n\n\ti = sscanf(tmp, \"%lu %lu %lu\", &start_code, &end_code, &start_stack);\n\tif (i != 3)\n\t\treturn -1;\n\n\t/* Skip the next 19 fields, column 45-51 are start_data to arg_end */\n\tfor (i = 0; i < 19; i++) {\n\t\tif (!tmp)\n\t\t\treturn -1;\n\t\ttmp = strchr(tmp+1, ' ');\n\t}\n\n\tif (!tmp)\n\t\treturn -1;\n\n\ti = sscanf(tmp, \"%lu %lu %lu %*u %*u %lu %lu\",\n\t\t&start_data,\n\t\t&end_data,\n\t\t&start_brk,\n\t\t&env_start,\n\t\t&env_end);\n\tif (i != 5)\n\t\treturn -1;\n\n\t/* Include the null byte here, because in the calculations below we\n\t * want to have room for it. */\n\tlen = strlen(title) + 1;\n\n\tproctitle = realloc(proctitle, len);\n\tif (!proctitle)\n\t\treturn -1;\n\n\targ_start = (unsigned long) proctitle;\n\targ_end = arg_start + len;\n\n\tbrk_val = syscall(__NR_brk, 0);\n\n\tprctl_map = (struct prctl_mm_map) {\n\t\t.start_code = start_code,\n\t\t.end_code = end_code,\n\t\t.start_stack = start_stack,\n\t\t.start_data = start_data,\n\t\t.end_data = end_data,\n\t\t.start_brk = start_brk,\n\t\t.brk = brk_val,\n\t\t.arg_start = arg_start,\n\t\t.arg_end = arg_end,\n\t\t.env_start = env_start,\n\t\t.env_end = env_end,\n\t\t.auxv = NULL,\n\t\t.auxv_size = 0,\n\t\t.exe_fd = -1,\n\t};\n\n\tret = prctl(PR_SET_MM, PR_SET_MM_MAP, (long) &prctl_map, sizeof(prctl_map), 0);\n\tif (ret == 0)\n\t\tstrcpy((char*)arg_start, title);\n\telse\n\t\tINFO(\"setting cmdline failed - %s\", strerror(errno));\n\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PR_SET_MM_MAP 14",
            "#define PR_SET_MM 35"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\n#define PR_SET_MM_MAP 14\n#define PR_SET_MM 35\n\nint setproctitle(char *title)\n{\n\tstatic char *proctitle = NULL;\n\tchar buf[2048], *tmp;\n\tFILE *f;\n\tint i, len, ret = 0;\n\n\t/* We don't really need to know all of this stuff, but unfortunately\n\t * PR_SET_MM_MAP requires us to set it all at once, so we have to\n\t * figure it out anyway.\n\t */\n\tunsigned long start_data, end_data, start_brk, start_code, end_code,\n\t\t\tstart_stack, arg_start, arg_end, env_start, env_end,\n\t\t\tbrk_val;\n\tstruct prctl_mm_map prctl_map;\n\n\tf = fopen_cloexec(\"/proc/self/stat\", \"r\");\n\tif (!f) {\n\t\treturn -1;\n\t}\n\n\ttmp = fgets(buf, sizeof(buf), f);\n\tfclose(f);\n\tif (!tmp) {\n\t\treturn -1;\n\t}\n\n\t/* Skip the first 25 fields, column 26-28 are start_code, end_code,\n\t * and start_stack */\n\ttmp = strchr(buf, ' ');\n\tfor (i = 0; i < 24; i++) {\n\t\tif (!tmp)\n\t\t\treturn -1;\n\t\ttmp = strchr(tmp+1, ' ');\n\t}\n\tif (!tmp)\n\t\treturn -1;\n\n\ti = sscanf(tmp, \"%lu %lu %lu\", &start_code, &end_code, &start_stack);\n\tif (i != 3)\n\t\treturn -1;\n\n\t/* Skip the next 19 fields, column 45-51 are start_data to arg_end */\n\tfor (i = 0; i < 19; i++) {\n\t\tif (!tmp)\n\t\t\treturn -1;\n\t\ttmp = strchr(tmp+1, ' ');\n\t}\n\n\tif (!tmp)\n\t\treturn -1;\n\n\ti = sscanf(tmp, \"%lu %lu %lu %*u %*u %lu %lu\",\n\t\t&start_data,\n\t\t&end_data,\n\t\t&start_brk,\n\t\t&env_start,\n\t\t&env_end);\n\tif (i != 5)\n\t\treturn -1;\n\n\t/* Include the null byte here, because in the calculations below we\n\t * want to have room for it. */\n\tlen = strlen(title) + 1;\n\n\tproctitle = realloc(proctitle, len);\n\tif (!proctitle)\n\t\treturn -1;\n\n\targ_start = (unsigned long) proctitle;\n\targ_end = arg_start + len;\n\n\tbrk_val = syscall(__NR_brk, 0);\n\n\tprctl_map = (struct prctl_mm_map) {\n\t\t.start_code = start_code,\n\t\t.end_code = end_code,\n\t\t.start_stack = start_stack,\n\t\t.start_data = start_data,\n\t\t.end_data = end_data,\n\t\t.start_brk = start_brk,\n\t\t.brk = brk_val,\n\t\t.arg_start = arg_start,\n\t\t.arg_end = arg_end,\n\t\t.env_start = env_start,\n\t\t.env_end = env_end,\n\t\t.auxv = NULL,\n\t\t.auxv_size = 0,\n\t\t.exe_fd = -1,\n\t};\n\n\tret = prctl(PR_SET_MM, PR_SET_MM_MAP, (long) &prctl_map, sizeof(prctl_map), 0);\n\tif (ret == 0)\n\t\tstrcpy((char*)arg_start, title);\n\telse\n\t\tINFO(\"setting cmdline failed - %s\", strerror(errno));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Attempting to set proc title to %s\"",
            "title"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "title",
            "sizeof(title)",
            "\"[lxc monitor] %s %s\"",
            "c->config_path",
            "c->name"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_daemonized_start",
          "args": [
            "c",
            "pid"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "do_wait_on_daemonized_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "614-627",
          "snippet": "static bool do_wait_on_daemonized_start(struct lxc_container *c, int pid)\n{\n\t/* we'll probably want to make this timeout configurable? */\n\tint timeout = 5, ret, status;\n\n\t/*\n\t * our child is going to fork again, then exit.  reap the\n\t * child\n\t */\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1 || !WIFEXITED(status) || WEXITSTATUS(status) != 0)\n\t\tDEBUG(\"failed waiting for first dual-fork child\");\n\treturn do_lxcapi_wait(c, \"RUNNING\", timeout);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_wait_on_daemonized_start(struct lxc_container *c, int pid)\n{\n\t/* we'll probably want to make this timeout configurable? */\n\tint timeout = 5, ret, status;\n\n\t/*\n\t * our child is going to fork again, then exit.  reap the\n\t * child\n\t */\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1 || !WIFEXITED(status) || WEXITSTATUS(status) != 0)\n\t\tDEBUG(\"failed waiting for first dual-fork child\");\n\treturn do_lxcapi_wait(c, \"RUNNING\", timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_monitord_spawn",
          "args": [
            "c->config_path"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_monitord_spawn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/monitor.c",
          "lines": "287-372",
          "snippet": "int lxc_monitord_spawn(const char *lxcpath)\n{\n\tint ret;\n\tint pipefd[2];\n\tchar pipefd_str[LXC_NUMSTRLEN64];\n\tpid_t pid1, pid2;\n\n\tchar *const args[] = {\n\t    LXC_MONITORD_PATH,\n\t    (char *)lxcpath,\n\t    pipefd_str,\n\t    NULL,\n\t};\n\n\t/* double fork to avoid zombies when monitord exits */\n\tpid1 = fork();\n\tif (pid1 < 0) {\n\t\tSYSERROR(\"Failed to fork().\");\n\t\treturn -1;\n\t}\n\n\tif (pid1) {\n\t\tDEBUG(\"Going to wait for pid %d.\", pid1);\n\t\tif (waitpid(pid1, NULL, 0) != pid1)\n\t\t\treturn -1;\n\t\tDEBUG(\"Finished waiting on pid %d.\", pid1);\n\t\treturn 0;\n\t}\n\n\tif (pipe(pipefd) < 0) {\n\t\tSYSERROR(\"Failed to create pipe.\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tpid2 = fork();\n\tif (pid2 < 0) {\n\t\tSYSERROR(\"Failed to fork().\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (pid2) {\n\t\tDEBUG(\"Trying to sync with child process.\");\n\t\tchar c;\n\t\t/* Wait for daemon to create socket. */\n\t\tclose(pipefd[1]);\n\n\t\t/* Sync with child, we're ignoring the return from read\n\t\t * because regardless if it works or not, either way we've\n\t\t * synced with the child process. the if-empty-statement\n\t\t * construct is to quiet the warn-unused-result warning.\n\t\t */\n\t\tif (read(pipefd[0], &c, 1))\n\t\t\t;\n\n\t\tclose(pipefd[0]);\n\n\t\tDEBUG(\"Successfully synced with child process.\");\n\t\texit(EXIT_SUCCESS);\n\t}\n\n\tif (setsid() < 0) {\n\t\tSYSERROR(\"Failed to setsid().\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tlxc_check_inherited(NULL, true, pipefd[1]);\n\tif (null_stdfds() < 0) {\n\t\tSYSERROR(\"Failed to dup2() standard file descriptors to /dev/null.\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tclose(pipefd[0]);\n\n\tret = snprintf(pipefd_str, LXC_NUMSTRLEN64, \"%d\", pipefd[1]);\n\tif (ret < 0 || ret >= LXC_NUMSTRLEN64) {\n\t\tERROR(\"Failed to create pid argument to pass to monitord.\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tDEBUG(\"Using pipe file descriptor %d for monitord.\", pipefd[1]);\n\n\texecvp(args[0], args);\n\tERROR(\"Failed to exec lxc-monitord.\");\n\n\texit(EXIT_FAILURE);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"af_unix.h\"",
            "#include \"config.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include <poll.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [
            "#define LXC_MONITORD_PATH LIBEXECDIR \"/lxc/lxc-monitord\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"state.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"af_unix.h\"\n#include \"config.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define LXC_MONITORD_PATH LIBEXECDIR \"/lxc/lxc-monitord\"\n\nint lxc_monitord_spawn(const char *lxcpath)\n{\n\tint ret;\n\tint pipefd[2];\n\tchar pipefd_str[LXC_NUMSTRLEN64];\n\tpid_t pid1, pid2;\n\n\tchar *const args[] = {\n\t    LXC_MONITORD_PATH,\n\t    (char *)lxcpath,\n\t    pipefd_str,\n\t    NULL,\n\t};\n\n\t/* double fork to avoid zombies when monitord exits */\n\tpid1 = fork();\n\tif (pid1 < 0) {\n\t\tSYSERROR(\"Failed to fork().\");\n\t\treturn -1;\n\t}\n\n\tif (pid1) {\n\t\tDEBUG(\"Going to wait for pid %d.\", pid1);\n\t\tif (waitpid(pid1, NULL, 0) != pid1)\n\t\t\treturn -1;\n\t\tDEBUG(\"Finished waiting on pid %d.\", pid1);\n\t\treturn 0;\n\t}\n\n\tif (pipe(pipefd) < 0) {\n\t\tSYSERROR(\"Failed to create pipe.\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tpid2 = fork();\n\tif (pid2 < 0) {\n\t\tSYSERROR(\"Failed to fork().\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (pid2) {\n\t\tDEBUG(\"Trying to sync with child process.\");\n\t\tchar c;\n\t\t/* Wait for daemon to create socket. */\n\t\tclose(pipefd[1]);\n\n\t\t/* Sync with child, we're ignoring the return from read\n\t\t * because regardless if it works or not, either way we've\n\t\t * synced with the child process. the if-empty-statement\n\t\t * construct is to quiet the warn-unused-result warning.\n\t\t */\n\t\tif (read(pipefd[0], &c, 1))\n\t\t\t;\n\n\t\tclose(pipefd[0]);\n\n\t\tDEBUG(\"Successfully synced with child process.\");\n\t\texit(EXIT_SUCCESS);\n\t}\n\n\tif (setsid() < 0) {\n\t\tSYSERROR(\"Failed to setsid().\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tlxc_check_inherited(NULL, true, pipefd[1]);\n\tif (null_stdfds() < 0) {\n\t\tSYSERROR(\"Failed to dup2() standard file descriptors to /dev/null.\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tclose(pipefd[0]);\n\n\tret = snprintf(pipefd_str, LXC_NUMSTRLEN64, \"%d\", pipefd[1]);\n\tif (ret < 0 || ret >= LXC_NUMSTRLEN64) {\n\t\tERROR(\"Failed to create pid argument to pass to monitord.\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tDEBUG(\"Using pipe file descriptor %d for monitord.\", pipefd[1]);\n\n\texecvp(args[0], args);\n\tERROR(\"Failed to exec lxc-monitord.\");\n\n\texit(EXIT_FAILURE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "split_init_cmd",
          "args": [
            "conf->init_cmd"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "split_init_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "676-704",
          "snippet": "static char **split_init_cmd(const char *incmd)\n{\n\tsize_t len;\n\tint nargs = 0;\n\tchar *copy, *p, *saveptr = NULL;\n\tchar **argv;\n\n\tif (!incmd)\n\t\treturn NULL;\n\n\tlen = strlen(incmd) + 1;\n\tcopy = alloca(len);\n\tstrncpy(copy, incmd, len);\n\tcopy[len-1] = '\\0';\n\n\tdo {\n\t\targv = malloc(sizeof(char *));\n\t} while (!argv);\n\targv[0] = NULL;\n\tfor (p = strtok_r(copy, \" \", &saveptr); p != NULL;\n\t\t\tp = strtok_r(NULL, \" \", &saveptr))\n\t\tpush_arg(&argv, p, &nargs);\n\n\tif (nargs == 0) {\n\t\tfree(argv);\n\t\treturn NULL;\n\t}\n\treturn argv;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic char **split_init_cmd(const char *incmd)\n{\n\tsize_t len;\n\tint nargs = 0;\n\tchar *copy, *p, *saveptr = NULL;\n\tchar **argv;\n\n\tif (!incmd)\n\t\treturn NULL;\n\n\tlen = strlen(incmd) + 1;\n\tcopy = alloca(len);\n\tstrncpy(copy, incmd, len);\n\tcopy[len-1] = '\\0';\n\n\tdo {\n\t\targv = malloc(sizeof(char *));\n\t} while (!argv);\n\targv[0] = NULL;\n\tfor (p = strtok_r(copy, \" \", &saveptr); p != NULL;\n\t\t\tp = strtok_r(NULL, \" \", &saveptr))\n\t\tpush_arg(&argv, p, &nargs);\n\n\tif (nargs == 0) {\n\t\tfree(argv);\n\t\treturn NULL;\n\t}\n\treturn argv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_execute",
          "args": [
            "c->name",
            "argv",
            "1",
            "conf",
            "c->config_path",
            "daemonize"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_execute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/execute.c",
          "lines": "113-126",
          "snippet": "int lxc_execute(const char *name, char *const argv[], int quiet,\n\t\tstruct lxc_conf *conf, const char *lxcpath, bool backgrounded)\n{\n\tstruct execute_args args = {\n\t\t.argv = argv,\n\t\t.quiet = quiet\n\t};\n\n\tif (lxc_check_inherited(conf, false, -1))\n\t\treturn -1;\n\n\tconf->is_execute = 1;\n\treturn __lxc_start(name, conf, &execute_start_ops, &args, lxcpath, backgrounded);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"start.h\"",
            "#include \"log.h\"",
            "#include \"conf.h\"",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lxc_operations execute_start_ops = {\n\t.start = execute_start,\n\t.post_start = execute_post_start\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"start.h\"\n#include \"log.h\"\n#include \"conf.h\"\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic struct lxc_operations execute_start_ops = {\n\t.start = execute_start,\n\t.post_start = execute_post_start\n};\n\nint lxc_execute(const char *name, char *const argv[], int quiet,\n\t\tstruct lxc_conf *conf, const char *lxcpath, bool backgrounded)\n{\n\tstruct execute_args args = {\n\t\t.argv = argv,\n\t\t.quiet = quiet\n\t};\n\n\tif (lxc_check_inherited(conf, false, -1))\n\t\treturn -1;\n\n\tconf->is_execute = 1;\n\treturn __lxc_start(name, conf, &execute_start_ops, &args, lxcpath, backgrounded);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_mem_unlock",
          "args": [
            "c"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "container_mem_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "347-350",
          "snippet": "void container_mem_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->privlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nvoid container_mem_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->privlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_mem_lock",
          "args": [
            "c"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "container_mem_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "342-345",
          "snippet": "int container_mem_lock(struct lxc_container *c)\n{\n\treturn lxclock(c->privlock, 0);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nint container_mem_lock(struct lxc_container *c)\n{\n\treturn lxclock(c->privlock, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error: creation of %s is ongoing\"",
            "c->name"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_lxcapi_destroy",
          "args": [
            "c"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "do_lxcapi_destroy_with_snapshots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2442-2451",
          "snippet": "static bool do_lxcapi_destroy_with_snapshots(struct lxc_container *c)\n{\n\tif (!c || !lxcapi_is_defined(c))\n\t\treturn false;\n\tif (!lxcapi_snapshot_destroy_all(c)) {\n\t\tERROR(\"Error deleting all snapshots\");\n\t\treturn false;\n\t}\n\treturn lxcapi_destroy(c);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_destroy_with_snapshots(struct lxc_container *c)\n{\n\tif (!c || !lxcapi_is_defined(c))\n\t\treturn false;\n\tif (!lxcapi_snapshot_destroy_all(c)) {\n\t\tERROR(\"Error deleting all snapshots\");\n\t\treturn false;\n\t}\n\treturn lxcapi_destroy(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error: %s creation was not completed\"",
            "c->name"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error checking for incomplete creation\""
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ongoing_create",
          "args": [
            "c"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "ongoing_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "133-167",
          "snippet": "static int ongoing_create(struct lxc_container *c)\n{\n\tint len = strlen(c->config_path) + strlen(c->name) + 10;\n\tchar *path = alloca(len);\n\tint fd, ret;\n\tstruct flock lk;\n\n\tret = snprintf(path, len, \"%s/%s/partial\", c->config_path, c->name);\n\tif (ret < 0 || ret >= len) {\n\t\tERROR(\"Error writing partial pathname\");\n\t\treturn -1;\n\t}\n\n\tif (!file_exists(path))\n\t\treturn 0;\n\tfd = open(path, O_RDWR);\n\tif (fd < 0) {\n\t\t// give benefit of the doubt\n\t\tSYSERROR(\"Error opening partial file\");\n\t\treturn 0;\n\t}\n\tlk.l_type = F_WRLCK;\n\tlk.l_whence = SEEK_SET;\n\tlk.l_start = 0;\n\tlk.l_len = 0;\n\tlk.l_pid = -1;\n\tif (fcntl(fd, F_GETLK, &lk) == 0 && lk.l_pid != -1) {\n\t\t// create is still ongoing\n\t\tclose(fd);\n\t\treturn 1;\n\t}\n\t// create completed but partial is still there.\n\tclose(fd);\n\treturn 2;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic int ongoing_create(struct lxc_container *c)\n{\n\tint len = strlen(c->config_path) + strlen(c->name) + 10;\n\tchar *path = alloca(len);\n\tint fd, ret;\n\tstruct flock lk;\n\n\tret = snprintf(path, len, \"%s/%s/partial\", c->config_path, c->name);\n\tif (ret < 0 || ret >= len) {\n\t\tERROR(\"Error writing partial pathname\");\n\t\treturn -1;\n\t}\n\n\tif (!file_exists(path))\n\t\treturn 0;\n\tfd = open(path, O_RDWR);\n\tif (fd < 0) {\n\t\t// give benefit of the doubt\n\t\tSYSERROR(\"Error opening partial file\");\n\t\treturn 0;\n\t}\n\tlk.l_type = F_WRLCK;\n\tlk.l_whence = SEEK_SET;\n\tlk.l_start = 0;\n\tlk.l_len = 0;\n\tlk.l_pid = -1;\n\tif (fcntl(fd, F_GETLK, &lk) == 0 && lk.l_pid != -1) {\n\t\t// create is still ongoing\n\t\tclose(fd);\n\t\treturn 1;\n\t}\n\t// create completed but partial is still there.\n\tclose(fd);\n\treturn 2;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_start(struct lxc_container *c, int useinit, char * const argv[])\n{\n\tint ret;\n\tstruct lxc_conf *conf;\n\tbool daemonize = false;\n\tFILE *pid_fp = NULL;\n\tchar *default_args[] = {\n\t\t\"/sbin/init\",\n\t\tNULL,\n\t};\n\tchar **init_cmd = NULL;\n\n\t/* container exists */\n\tif (!c)\n\t\treturn false;\n\n\t/* If anything fails before we set error_num, we want an error in there */\n\tc->error_num = 1;\n\n\t/* container has been setup */\n\tif (!c->lxc_conf)\n\t\treturn false;\n\n\tif ((ret = ongoing_create(c)) < 0) {\n\t\tERROR(\"Error checking for incomplete creation\");\n\t\treturn false;\n\t}\n\tif (ret == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tdo_lxcapi_destroy(c);\n\t\treturn false;\n\t} else if (ret == 1) {\n\t\tERROR(\"Error: creation of %s is ongoing\", c->name);\n\t\treturn false;\n\t}\n\n\t/* is this app meant to be run through lxcinit, as in lxc-execute? */\n\tif (useinit && !argv)\n\t\treturn false;\n\n\tif (container_mem_lock(c))\n\t\treturn false;\n\tconf = c->lxc_conf;\n\tdaemonize = c->daemonize;\n\tcontainer_mem_unlock(c);\n\n\tif (useinit) {\n\t\tret = lxc_execute(c->name, argv, 1, conf, c->config_path, daemonize);\n\t\treturn ret == 0 ? true : false;\n\t}\n\n\t/* if no argv was passed in, use lxc.init_cmd if provided in\n\t * configuration */\n\tif (!argv)\n\t\targv = init_cmd = split_init_cmd(conf->init_cmd);\n\n\t/* ... and otherwise use default_args */\n\tif (!argv)\n\t\targv = default_args;\n\n\t/*\n\t* say, I'm not sure - what locks do we want here?  Any?\n\t* Is liblxc's locking enough here to protect the on disk\n\t* container?  We don't want to exclude things like lxc_info\n\t* while container is running...\n\t*/\n\tif (daemonize) {\n\t\tchar title[2048];\n\t\tlxc_monitord_spawn(c->config_path);\n\n\t\tpid_t pid = fork();\n\t\tif (pid < 0)\n\t\t\treturn false;\n\n\t\tif (pid != 0) {\n\t\t\t/* Set to NULL because we don't want father unlink\n\t\t\t * the PID file, child will do the free and unlink.\n\t\t\t */\n\t\t\tc->pidfile = NULL;\n\t\t\treturn wait_on_daemonized_start(c, pid);\n\t\t}\n\n\t\t/* We don't really care if this doesn't print all the\n\t\t * characters; all that it means is that the proctitle will be\n\t\t * ugly. Similarly, we also don't care if setproctitle()\n\t\t * fails. */\n\t\tsnprintf(title, sizeof(title), \"[lxc monitor] %s %s\", c->config_path, c->name);\n\t\tINFO(\"Attempting to set proc title to %s\", title);\n\t\tsetproctitle(title);\n\n\t\t/* second fork to be reparented by init */\n\t\tpid = fork();\n\t\tif (pid < 0) {\n\t\t\tSYSERROR(\"Error doing dual-fork\");\n\t\t\texit(1);\n\t\t}\n\t\tif (pid != 0)\n\t\t\texit(0);\n\t\t/* like daemon(), chdir to / and redirect 0,1,2 to /dev/null */\n\t\tif (chdir(\"/\")) {\n\t\t\tSYSERROR(\"Error chdir()ing to /.\");\n\t\t\texit(1);\n\t\t}\n\t\tlxc_check_inherited(conf, true, -1);\n\t\tif (null_stdfds() < 0) {\n\t\t\tERROR(\"failed to close fds\");\n\t\t\texit(1);\n\t\t}\n\t\tsetsid();\n\t} else {\n\t\tif (!am_single_threaded()) {\n\t\t\tERROR(\"Cannot start non-daemonized container when threaded\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/* We need to write PID file after daeminize, so we always\n\t * write the right PID.\n\t */\n\tif (c->pidfile) {\n\t\tpid_fp = fopen(c->pidfile, \"w\");\n\t\tif (pid_fp == NULL) {\n\t\t\tSYSERROR(\"Failed to create pidfile '%s' for '%s'\",\n\t\t\t\t c->pidfile, c->name);\n\t\t\tif (daemonize)\n\t\t\t\texit(1);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (fprintf(pid_fp, \"%d\\n\", getpid()) < 0) {\n\t\t\tSYSERROR(\"Failed to write '%s'\", c->pidfile);\n\t\t\tfclose(pid_fp);\n\t\t\tpid_fp = NULL;\n\t\t\tif (daemonize)\n\t\t\t\texit(1);\n\t\t\treturn false;\n\t\t}\n\n\t\tfclose(pid_fp);\n\t\tpid_fp = NULL;\n\t}\n\n\tconf->reboot = 0;\n\n\t/* Unshare the mount namespace if requested */\n\tif (conf->monitor_unshare) {\n\t\tif (unshare(CLONE_NEWNS)) {\n\t\t\tSYSERROR(\"failed to unshare mount namespace\");\n\t\t\treturn false;\n\t\t}\n\t\tif (mount(NULL, \"/\", NULL, MS_SLAVE|MS_REC, NULL)) {\n\t\t\tSYSERROR(\"Failed to make / rslave at startup\");\n\t\t\treturn false;\n\t\t}\n\t}\n\nreboot:\n\tif (lxc_check_inherited(conf, daemonize, -1)) {\n\t\tERROR(\"Inherited fds found\");\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tret = lxc_start(c->name, argv, conf, c->config_path, daemonize);\n\tc->error_num = ret;\n\n\tif (conf->reboot == 1) {\n\t\tINFO(\"container requested reboot\");\n\t\tconf->reboot = 2;\n\t\tgoto reboot;\n\t}\n\nout:\n\tif (c->pidfile) {\n\t\tunlink(c->pidfile);\n\t\tfree(c->pidfile);\n\t\tc->pidfile = NULL;\n\t}\n\n\tfree_init_cmd(init_cmd);\n\n\tif (daemonize)\n\t\texit (ret == 0 ? true : false);\n\telse\n\t\treturn (ret == 0 ? true : false);\n}"
  },
  {
    "function_name": "free_init_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "706-715",
    "snippet": "static void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "argv"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "free_init_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "706-715",
          "snippet": "static void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}"
  },
  {
    "function_name": "split_init_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "676-704",
    "snippet": "static char **split_init_cmd(const char *incmd)\n{\n\tsize_t len;\n\tint nargs = 0;\n\tchar *copy, *p, *saveptr = NULL;\n\tchar **argv;\n\n\tif (!incmd)\n\t\treturn NULL;\n\n\tlen = strlen(incmd) + 1;\n\tcopy = alloca(len);\n\tstrncpy(copy, incmd, len);\n\tcopy[len-1] = '\\0';\n\n\tdo {\n\t\targv = malloc(sizeof(char *));\n\t} while (!argv);\n\targv[0] = NULL;\n\tfor (p = strtok_r(copy, \" \", &saveptr); p != NULL;\n\t\t\tp = strtok_r(NULL, \" \", &saveptr))\n\t\tpush_arg(&argv, p, &nargs);\n\n\tif (nargs == 0) {\n\t\tfree(argv);\n\t\treturn NULL;\n\t}\n\treturn argv;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "argv"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "free_init_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "706-715",
          "snippet": "static void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "push_arg",
          "args": [
            "&argv",
            "p",
            "&nargs"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "push_arg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "659-674",
          "snippet": "static void push_arg(char ***argp, char *arg, int *nargs)\n{\n\tchar **argv;\n\tchar *copy;\n\n\tdo {\n\t\tcopy = strdup(arg);\n\t} while (!copy);\n\tdo {\n\t\targv = realloc(*argp, (*nargs + 2) * sizeof(char *));\n\t} while (!argv);\n\t*argp = argv;\n\targv[*nargs] = copy;\n\t(*nargs)++;\n\targv[*nargs] = NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic void push_arg(char ***argp, char *arg, int *nargs)\n{\n\tchar **argv;\n\tchar *copy;\n\n\tdo {\n\t\tcopy = strdup(arg);\n\t} while (!copy);\n\tdo {\n\t\targv = realloc(*argp, (*nargs + 2) * sizeof(char *));\n\t} while (!argv);\n\t*argp = argv;\n\targv[*nargs] = copy;\n\t(*nargs)++;\n\targv[*nargs] = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "NULL",
            "\" \"",
            "&saveptr"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "copy",
            "\" \"",
            "&saveptr"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(char *)"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "copy",
            "incmd",
            "len"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "len"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "incmd"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic char **split_init_cmd(const char *incmd)\n{\n\tsize_t len;\n\tint nargs = 0;\n\tchar *copy, *p, *saveptr = NULL;\n\tchar **argv;\n\n\tif (!incmd)\n\t\treturn NULL;\n\n\tlen = strlen(incmd) + 1;\n\tcopy = alloca(len);\n\tstrncpy(copy, incmd, len);\n\tcopy[len-1] = '\\0';\n\n\tdo {\n\t\targv = malloc(sizeof(char *));\n\t} while (!argv);\n\targv[0] = NULL;\n\tfor (p = strtok_r(copy, \" \", &saveptr); p != NULL;\n\t\t\tp = strtok_r(NULL, \" \", &saveptr))\n\t\tpush_arg(&argv, p, &nargs);\n\n\tif (nargs == 0) {\n\t\tfree(argv);\n\t\treturn NULL;\n\t}\n\treturn argv;\n}"
  },
  {
    "function_name": "push_arg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "659-674",
    "snippet": "static void push_arg(char ***argp, char *arg, int *nargs)\n{\n\tchar **argv;\n\tchar *copy;\n\n\tdo {\n\t\tcopy = strdup(arg);\n\t} while (!copy);\n\tdo {\n\t\targv = realloc(*argp, (*nargs + 2) * sizeof(char *));\n\t} while (!argv);\n\t*argp = argv;\n\targv[*nargs] = copy;\n\t(*nargs)++;\n\targv[*nargs] = NULL;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "*argp",
            "(*nargs + 2) * sizeof(char *)"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "must_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "116-124",
          "snippet": "static void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "arg"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic void push_arg(char ***argp, char *arg, int *nargs)\n{\n\tchar **argv;\n\tchar *copy;\n\n\tdo {\n\t\tcopy = strdup(arg);\n\t} while (!copy);\n\tdo {\n\t\targv = realloc(*argp, (*nargs + 2) * sizeof(char *));\n\t} while (!argv);\n\t*argp = argv;\n\targv[*nargs] = copy;\n\t(*nargs)++;\n\targv[*nargs] = NULL;\n}"
  },
  {
    "function_name": "am_single_threaded",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "631-657",
    "snippet": "static bool am_single_threaded(void)\n{\n\tstruct dirent *direntp;\n\tDIR *dir;\n\tint count=0;\n\n\tdir = opendir(\"/proc/self/task\");\n\tif (!dir) {\n\t\tINFO(\"failed to open /proc/self/task\");\n\t\treturn false;\n\t}\n\n\twhile ((direntp = readdir(dir))) {\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\"))\n\t\t\tcontinue;\n\n\t\tif (!strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tif (++count > 1)\n\t\t\tbreak;\n\t}\n\tclosedir(dir);\n\treturn count == 1;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dir"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "direntp->d_name",
            "\"..\""
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "direntp->d_name",
            "\".\""
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "dir"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"failed to open /proc/self/task\""
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "\"/proc/self/task\""
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool am_single_threaded(void)\n{\n\tstruct dirent *direntp;\n\tDIR *dir;\n\tint count=0;\n\n\tdir = opendir(\"/proc/self/task\");\n\tif (!dir) {\n\t\tINFO(\"failed to open /proc/self/task\");\n\t\treturn false;\n\t}\n\n\twhile ((direntp = readdir(dir))) {\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\"))\n\t\t\tcontinue;\n\n\t\tif (!strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tif (++count > 1)\n\t\t\tbreak;\n\t}\n\tclosedir(dir);\n\treturn count == 1;\n}"
  },
  {
    "function_name": "do_wait_on_daemonized_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "614-627",
    "snippet": "static bool do_wait_on_daemonized_start(struct lxc_container *c, int pid)\n{\n\t/* we'll probably want to make this timeout configurable? */\n\tint timeout = 5, ret, status;\n\n\t/*\n\t * our child is going to fork again, then exit.  reap the\n\t * child\n\t */\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1 || !WIFEXITED(status) || WEXITSTATUS(status) != 0)\n\t\tDEBUG(\"failed waiting for first dual-fork child\");\n\treturn do_lxcapi_wait(c, \"RUNNING\", timeout);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_lxcapi_wait",
          "args": [
            "c",
            "\"RUNNING\"",
            "timeout"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "do_lxcapi_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "601-610",
          "snippet": "static bool do_lxcapi_wait(struct lxc_container *c, const char *state, int timeout)\n{\n\tint ret;\n\n\tif (!c)\n\t\treturn false;\n\n\tret = lxc_wait(c->name, state, timeout, c->config_path);\n\treturn ret == 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_wait(struct lxc_container *c, const char *state, int timeout)\n{\n\tint ret;\n\n\tif (!c)\n\t\treturn false;\n\n\tret = lxc_wait(c->name, state, timeout, c->config_path);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"failed waiting for first dual-fork child\""
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "0"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_wait_on_daemonized_start(struct lxc_container *c, int pid)\n{\n\t/* we'll probably want to make this timeout configurable? */\n\tint timeout = 5, ret, status;\n\n\t/*\n\t * our child is going to fork again, then exit.  reap the\n\t * child\n\t */\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1 || !WIFEXITED(status) || WEXITSTATUS(status) != 0)\n\t\tDEBUG(\"failed waiting for first dual-fork child\");\n\treturn do_lxcapi_wait(c, \"RUNNING\", timeout);\n}"
  },
  {
    "function_name": "do_lxcapi_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "601-610",
    "snippet": "static bool do_lxcapi_wait(struct lxc_container *c, const char *state, int timeout)\n{\n\tint ret;\n\n\tif (!c)\n\t\treturn false;\n\n\tret = lxc_wait(c->name, state, timeout, c->config_path);\n\treturn ret == 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_wait",
          "args": [
            "c->name",
            "state",
            "timeout",
            "c->config_path"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/state.c",
          "lines": "108-197",
          "snippet": "extern int lxc_wait(const char *lxcname, const char *states, int timeout,\n\t\t    const char *lxcpath)\n{\n\tstruct lxc_msg msg;\n\tint state, ret;\n\tint s[MAX_STATE] = {0}, fd;\n\n\tif (fillwaitedstates(states, s))\n\t\treturn -1;\n\n\tif (lxc_monitord_spawn(lxcpath))\n\t\treturn -1;\n\n\tfd = lxc_monitor_open(lxcpath);\n\tif (fd < 0)\n\t\treturn -1;\n\n\t/*\n\t * if container present,\n\t * then check if already in requested state\n\t */\n\tret = -1;\n\tstate = lxc_getstate(lxcname, lxcpath);\n\tif (state < 0) {\n\t\tgoto out_close;\n\t} else if ((state >= 0) && (s[state])) {\n\t\tret = 0;\n\t\tgoto out_close;\n\t}\n\n\tfor (;;) {\n\t\tint64_t elapsed_time, curtime = 0;\n\t\tstruct timespec tspec;\n\t\tint stop = 0;\n\t\tint retval;\n\n\t\tif (timeout != -1) {\n\t\t\tretval = clock_gettime(CLOCK_REALTIME, &tspec);\n\t\t\tif (retval)\n\t\t\t\tgoto out_close;\n\t\t\tcurtime = tspec.tv_sec;\n\t\t}\n\t\tif (lxc_monitor_read_timeout(fd, &msg, timeout) < 0) {\n\t\t\t/* try again if select interrupted by signal */\n\t\t\tif (errno != EINTR)\n\t\t\t\tgoto out_close;\n\t\t}\n\n\t\tif (timeout != -1) {\n\t\t\tretval = clock_gettime(CLOCK_REALTIME, &tspec);\n\t\t\tif (retval)\n\t\t\t\tgoto out_close;\n\t\t\telapsed_time = tspec.tv_sec - curtime;\n\t\t\tif (timeout - elapsed_time <= 0)\n\t\t\t\tstop = 1;\n\t\t\ttimeout -= elapsed_time;\n\t\t}\n\n\t\tif (strcmp(lxcname, msg.name)) {\n\t\t\tif (stop) {\n\t\t\t\tret = -2;\n\t\t\t\tgoto out_close;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (msg.type) {\n\t\tcase lxc_msg_state:\n\t\t\tif (msg.value < 0 || msg.value >= MAX_STATE)\n\t\t\t\tgoto out_close;\n\n\t\t\tif (s[msg.value]) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto out_close;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (stop) {\n\t\t\t\tret = -2;\n\t\t\t\tgoto out_close;\n\t\t\t}\n\t\t\t/* just ignore garbage */\n\t\t\tbreak;\n\t\t}\n\t}\n\nout_close:\n\tlxc_monitor_close(fd);\n\treturn ret;\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"monitor.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"monitor.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n\nextern int lxc_wait(const char *lxcname, const char *states, int timeout,\n\t\t    const char *lxcpath)\n{\n\tstruct lxc_msg msg;\n\tint state, ret;\n\tint s[MAX_STATE] = {0}, fd;\n\n\tif (fillwaitedstates(states, s))\n\t\treturn -1;\n\n\tif (lxc_monitord_spawn(lxcpath))\n\t\treturn -1;\n\n\tfd = lxc_monitor_open(lxcpath);\n\tif (fd < 0)\n\t\treturn -1;\n\n\t/*\n\t * if container present,\n\t * then check if already in requested state\n\t */\n\tret = -1;\n\tstate = lxc_getstate(lxcname, lxcpath);\n\tif (state < 0) {\n\t\tgoto out_close;\n\t} else if ((state >= 0) && (s[state])) {\n\t\tret = 0;\n\t\tgoto out_close;\n\t}\n\n\tfor (;;) {\n\t\tint64_t elapsed_time, curtime = 0;\n\t\tstruct timespec tspec;\n\t\tint stop = 0;\n\t\tint retval;\n\n\t\tif (timeout != -1) {\n\t\t\tretval = clock_gettime(CLOCK_REALTIME, &tspec);\n\t\t\tif (retval)\n\t\t\t\tgoto out_close;\n\t\t\tcurtime = tspec.tv_sec;\n\t\t}\n\t\tif (lxc_monitor_read_timeout(fd, &msg, timeout) < 0) {\n\t\t\t/* try again if select interrupted by signal */\n\t\t\tif (errno != EINTR)\n\t\t\t\tgoto out_close;\n\t\t}\n\n\t\tif (timeout != -1) {\n\t\t\tretval = clock_gettime(CLOCK_REALTIME, &tspec);\n\t\t\tif (retval)\n\t\t\t\tgoto out_close;\n\t\t\telapsed_time = tspec.tv_sec - curtime;\n\t\t\tif (timeout - elapsed_time <= 0)\n\t\t\t\tstop = 1;\n\t\t\ttimeout -= elapsed_time;\n\t\t}\n\n\t\tif (strcmp(lxcname, msg.name)) {\n\t\t\tif (stop) {\n\t\t\t\tret = -2;\n\t\t\t\tgoto out_close;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (msg.type) {\n\t\tcase lxc_msg_state:\n\t\t\tif (msg.value < 0 || msg.value >= MAX_STATE)\n\t\t\t\tgoto out_close;\n\n\t\t\tif (s[msg.value]) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto out_close;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (stop) {\n\t\t\t\tret = -2;\n\t\t\t\tgoto out_close;\n\t\t\t}\n\t\t\t/* just ignore garbage */\n\t\t\tbreak;\n\t\t}\n\t}\n\nout_close:\n\tlxc_monitor_close(fd);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_wait(struct lxc_container *c, const char *state, int timeout)\n{\n\tint ret;\n\n\tif (!c)\n\t\treturn false;\n\n\tret = lxc_wait(c->name, state, timeout, c->config_path);\n\treturn ret == 0;\n}"
  },
  {
    "function_name": "do_lxcapi_want_close_all_fds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "586-597",
    "snippet": "static bool do_lxcapi_want_close_all_fds(struct lxc_container *c, bool state)\n{\n\tif (!c || !c->lxc_conf)\n\t\treturn false;\n\tif (container_mem_lock(c)) {\n\t\tERROR(\"Error getting mem lock\");\n\t\treturn false;\n\t}\n\tc->lxc_conf->close_all_fds = state;\n\tcontainer_mem_unlock(c);\n\treturn true;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_mem_unlock",
          "args": [
            "c"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "container_mem_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "347-350",
          "snippet": "void container_mem_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->privlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nvoid container_mem_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->privlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error getting mem lock\""
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_mem_lock",
          "args": [
            "c"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "container_mem_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "342-345",
          "snippet": "int container_mem_lock(struct lxc_container *c)\n{\n\treturn lxclock(c->privlock, 0);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nint container_mem_lock(struct lxc_container *c)\n{\n\treturn lxclock(c->privlock, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_want_close_all_fds(struct lxc_container *c, bool state)\n{\n\tif (!c || !c->lxc_conf)\n\t\treturn false;\n\tif (container_mem_lock(c)) {\n\t\tERROR(\"Error getting mem lock\");\n\t\treturn false;\n\t}\n\tc->lxc_conf->close_all_fds = state;\n\tcontainer_mem_unlock(c);\n\treturn true;\n}"
  },
  {
    "function_name": "do_lxcapi_load_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "532-567",
    "snippet": "static bool do_lxcapi_load_config(struct lxc_container *c, const char *alt_file)\n{\n\tbool ret = false, need_disklock = false;\n\tint lret;\n\tconst char *fname;\n\tif (!c)\n\t\treturn false;\n\n\tfname = c->configfile;\n\tif (alt_file)\n\t\tfname = alt_file;\n\tif (!fname)\n\t\treturn false;\n\t/*\n\t * If we're reading something other than the container's config,\n\t * we only need to lock the in-memory container.  If loading the\n\t * container's config file, take the disk lock.\n\t */\n\tif (strcmp(fname, c->configfile) == 0)\n\t\tneed_disklock = true;\n\n\tif (need_disklock)\n\t\tlret = container_disk_lock(c);\n\telse\n\t\tlret = container_mem_lock(c);\n\tif (lret)\n\t\treturn false;\n\n\tret = load_config_locked(c, fname);\n\n\tif (need_disklock)\n\t\tcontainer_disk_unlock(c);\n\telse\n\t\tcontainer_mem_unlock(c);\n\treturn ret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);",
      "static bool do_lxcapi_save_config(struct lxc_container *c, const char *alt_file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_mem_unlock",
          "args": [
            "c"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "container_mem_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "347-350",
          "snippet": "void container_mem_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->privlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nvoid container_mem_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->privlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_disk_unlock",
          "args": [
            "c"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "container_disk_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "365-369",
          "snippet": "void container_disk_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->slock);\n\tlxcunlock(c->privlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nvoid container_disk_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->slock);\n\tlxcunlock(c->privlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_config_locked",
          "args": [
            "c",
            "fname"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "load_config_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "521-530",
          "snippet": "static bool load_config_locked(struct lxc_container *c, const char *fname)\n{\n\tif (!c->lxc_conf)\n\t\tc->lxc_conf = lxc_conf_init();\n\tif (!c->lxc_conf)\n\t\treturn false;\n\tif (lxc_config_read(fname, c->lxc_conf, false) != 0)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool load_config_locked(struct lxc_container *c, const char *fname)\n{\n\tif (!c->lxc_conf)\n\t\tc->lxc_conf = lxc_conf_init();\n\tif (!c->lxc_conf)\n\t\treturn false;\n\tif (lxc_config_read(fname, c->lxc_conf, false) != 0)\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_mem_lock",
          "args": [
            "c"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "container_mem_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "342-345",
          "snippet": "int container_mem_lock(struct lxc_container *c)\n{\n\treturn lxclock(c->privlock, 0);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nint container_mem_lock(struct lxc_container *c)\n{\n\treturn lxclock(c->privlock, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_disk_lock",
          "args": [
            "c"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "container_disk_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "352-363",
          "snippet": "int container_disk_lock(struct lxc_container *c)\n{\n\tint ret;\n\n\tif ((ret = lxclock(c->privlock, 0)))\n\t\treturn ret;\n\tif ((ret = lxclock(c->slock, 0))) {\n\t\tlxcunlock(c->privlock);\n\t\treturn ret;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nint container_disk_lock(struct lxc_container *c)\n{\n\tint ret;\n\n\tif ((ret = lxclock(c->privlock, 0)))\n\t\treturn ret;\n\tif ((ret = lxclock(c->slock, 0))) {\n\t\tlxcunlock(c->privlock);\n\t\treturn ret;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "fname",
            "c->configfile"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\nstatic bool do_lxcapi_save_config(struct lxc_container *c, const char *alt_file);\n\nstatic bool do_lxcapi_load_config(struct lxc_container *c, const char *alt_file)\n{\n\tbool ret = false, need_disklock = false;\n\tint lret;\n\tconst char *fname;\n\tif (!c)\n\t\treturn false;\n\n\tfname = c->configfile;\n\tif (alt_file)\n\t\tfname = alt_file;\n\tif (!fname)\n\t\treturn false;\n\t/*\n\t * If we're reading something other than the container's config,\n\t * we only need to lock the in-memory container.  If loading the\n\t * container's config file, take the disk lock.\n\t */\n\tif (strcmp(fname, c->configfile) == 0)\n\t\tneed_disklock = true;\n\n\tif (need_disklock)\n\t\tlret = container_disk_lock(c);\n\telse\n\t\tlret = container_mem_lock(c);\n\tif (lret)\n\t\treturn false;\n\n\tret = load_config_locked(c, fname);\n\n\tif (need_disklock)\n\t\tcontainer_disk_unlock(c);\n\telse\n\t\tcontainer_mem_unlock(c);\n\treturn ret;\n}"
  },
  {
    "function_name": "load_config_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "521-530",
    "snippet": "static bool load_config_locked(struct lxc_container *c, const char *fname)\n{\n\tif (!c->lxc_conf)\n\t\tc->lxc_conf = lxc_conf_init();\n\tif (!c->lxc_conf)\n\t\treturn false;\n\tif (lxc_config_read(fname, c->lxc_conf, false) != 0)\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_config_read",
          "args": [
            "fname",
            "c->lxc_conf",
            "false"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_config_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/confile.c",
          "lines": "2115-2131",
          "snippet": "int lxc_config_read(const char *file, struct lxc_conf *conf, bool from_include)\n{\n\tstruct parse_line_conf c;\n\n\tc.conf = conf;\n\tc.from_include = from_include;\n\n\tif( access(file, R_OK) == -1 ) {\n\t\treturn -1;\n\t}\n\n\t/* Catch only the top level config file name in the structure */\n\tif(!conf->rcfile)\n\t\tconf->rcfile = strdup(file);\n\n\treturn lxc_file_for_each_line(file, parse_line, &c);\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"network.h\"",
            "#include \"conf.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"confile.h\"",
            "#include \"config.h\"",
            "#include \"parse.h\"",
            "#include \"bdev.h\"",
            "#include <syslog.h>",
            "#include <dirent.h>",
            "#include <time.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int config_personality(const char *, const char *, struct lxc_conf *);",
            "static int config_pts(const char *, const char *, struct lxc_conf *);",
            "static int config_tty(const char *, const char *, struct lxc_conf *);",
            "static int config_ttydir(const char *, const char *, struct lxc_conf *);",
            "static int config_kmsg(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_aa_profile(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_aa_incomplete(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_se_context(const char *, const char *, struct lxc_conf *);",
            "static int config_cgroup(const char *, const char *, struct lxc_conf *);",
            "static int config_idmap(const char *, const char *, struct lxc_conf *);",
            "static int config_loglevel(const char *, const char *, struct lxc_conf *);",
            "static int config_logfile(const char *, const char *, struct lxc_conf *);",
            "static int config_mount(const char *, const char *, struct lxc_conf *);",
            "static int config_mount_auto(const char *, const char *, struct lxc_conf *);",
            "static int config_fstab(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_mount(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_options(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_backend(const char *, const char *, struct lxc_conf *);",
            "static int config_pivotdir(const char *, const char *, struct lxc_conf *);",
            "static int config_utsname(const char *, const char *, struct lxc_conf *);",
            "static int config_hook(const char *, const char *, struct lxc_conf *lxc_conf);",
            "static int config_network(const char *, const char *, struct lxc_conf *);",
            "static int config_network_type(const char *, const char *, struct lxc_conf *);",
            "static int config_network_flags(const char *, const char *, struct lxc_conf *);",
            "static int config_network_link(const char *, const char *, struct lxc_conf *);",
            "static int config_network_name(const char *, const char *, struct lxc_conf *);",
            "static int config_network_veth_pair(const char *, const char *, struct lxc_conf *);",
            "static int config_network_macvlan_mode(const char *, const char *, struct lxc_conf *);",
            "static int config_network_hwaddr(const char *, const char *, struct lxc_conf *);",
            "static int config_network_vlan_id(const char *, const char *, struct lxc_conf *);",
            "static int config_network_mtu(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv4(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv4_gateway(const char *, const char *, struct lxc_conf *);",
            "static int config_network_script_up(const char *, const char *, struct lxc_conf *);",
            "static int config_network_script_down(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv6(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv6_gateway(const char *, const char *, struct lxc_conf *);",
            "static int config_cap_drop(const char *, const char *, struct lxc_conf *);",
            "static int config_cap_keep(const char *, const char *, struct lxc_conf *);",
            "static int config_console(const char *, const char *, struct lxc_conf *);",
            "static int config_console_logfile(const char *, const char *, struct lxc_conf *);",
            "static int config_seccomp(const char *, const char *, struct lxc_conf *);",
            "static int config_includefile(const char *, const char *, struct lxc_conf *);",
            "static int config_network_nic(const char *, const char *, struct lxc_conf *);",
            "static int config_autodev(const char *, const char *, struct lxc_conf *);",
            "static int config_haltsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_rebootsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_stopsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_start(const char *, const char *, struct lxc_conf *);",
            "static int config_syslog(const char *, const char *, struct lxc_conf *);",
            "static int config_monitor(const char *, const char *, struct lxc_conf *);",
            "static int config_group(const char *, const char *, struct lxc_conf *);",
            "static int config_environment(const char *, const char *, struct lxc_conf *);",
            "static int config_init_cmd(const char *, const char *, struct lxc_conf *);",
            "static int config_init_uid(const char *, const char *, struct lxc_conf *);",
            "static int config_init_gid(const char *, const char *, struct lxc_conf *);",
            "static int config_ephemeral(const char *, const char *, struct lxc_conf *);",
            "static int config_no_new_privs(const char *, const char *, struct lxc_conf *);",
            "static struct lxc_config_t config[] = {\n\n\t{ \"lxc.arch\",                 config_personality          },\n\t{ \"lxc.pts\",                  config_pts                  },\n\t{ \"lxc.tty\",                  config_tty                  },\n\t{ \"lxc.devttydir\",            config_ttydir               },\n\t{ \"lxc.kmsg\",                 config_kmsg                 },\n\t{ \"lxc.aa_profile\",           config_lsm_aa_profile       },\n\t{ \"lxc.aa_allow_incomplete\",  config_lsm_aa_incomplete    },\n\t{ \"lxc.se_context\",           config_lsm_se_context       },\n\t{ \"lxc.cgroup\",               config_cgroup               },\n\t{ \"lxc.id_map\",               config_idmap                },\n\t{ \"lxc.loglevel\",             config_loglevel             },\n\t{ \"lxc.logfile\",              config_logfile              },\n\t{ \"lxc.mount.entry\",          config_mount                },\n\t{ \"lxc.mount.auto\",           config_mount_auto           },\n\t{ \"lxc.mount\",                config_fstab                },\n\t{ \"lxc.rootfs.mount\",         config_rootfs_mount         },\n\t{ \"lxc.rootfs.options\",       config_rootfs_options       },\n\t{ \"lxc.rootfs.backend\",       config_rootfs_backend       },\n\t{ \"lxc.rootfs\",               config_rootfs               },\n\t{ \"lxc.pivotdir\",             config_pivotdir             },\n\t{ \"lxc.utsname\",              config_utsname              },\n\t{ \"lxc.hook.pre-start\",       config_hook                 },\n\t{ \"lxc.hook.pre-mount\",       config_hook                 },\n\t{ \"lxc.hook.mount\",           config_hook                 },\n\t{ \"lxc.hook.autodev\",         config_hook                 },\n\t{ \"lxc.hook.start\",           config_hook                 },\n\t{ \"lxc.hook.stop\",            config_hook                 },\n\t{ \"lxc.hook.post-stop\",       config_hook                 },\n\t{ \"lxc.hook.clone\",           config_hook                 },\n\t{ \"lxc.hook.destroy\",         config_hook                 },\n\t{ \"lxc.hook\",                 config_hook                 },\n\t{ \"lxc.network.type\",         config_network_type         },\n\t{ \"lxc.network.flags\",        config_network_flags        },\n\t{ \"lxc.network.link\",         config_network_link         },\n\t{ \"lxc.network.name\",         config_network_name         },\n\t{ \"lxc.network.macvlan.mode\", config_network_macvlan_mode },\n\t{ \"lxc.network.veth.pair\",    config_network_veth_pair    },\n\t{ \"lxc.network.script.up\",    config_network_script_up    },\n\t{ \"lxc.network.script.down\",  config_network_script_down  },\n\t{ \"lxc.network.hwaddr\",       config_network_hwaddr       },\n\t{ \"lxc.network.mtu\",          config_network_mtu          },\n\t{ \"lxc.network.vlan.id\",      config_network_vlan_id      },\n\t{ \"lxc.network.ipv4.gateway\", config_network_ipv4_gateway },\n\t{ \"lxc.network.ipv4\",         config_network_ipv4         },\n\t{ \"lxc.network.ipv6.gateway\", config_network_ipv6_gateway },\n\t{ \"lxc.network.ipv6\",         config_network_ipv6         },\n\t/* config_network_nic must come after all other 'lxc.network.*' entries */\n\t{ \"lxc.network.\",             config_network_nic          },\n\t{ \"lxc.network\",              config_network              },\n\t{ \"lxc.cap.drop\",             config_cap_drop             },\n\t{ \"lxc.cap.keep\",             config_cap_keep             },\n\t{ \"lxc.console.logfile\",      config_console_logfile      },\n\t{ \"lxc.console\",              config_console              },\n\t{ \"lxc.seccomp\",              config_seccomp              },\n\t{ \"lxc.include\",              config_includefile          },\n\t{ \"lxc.autodev\",              config_autodev              },\n\t{ \"lxc.haltsignal\",           config_haltsignal           },\n\t{ \"lxc.rebootsignal\",         config_rebootsignal         },\n\t{ \"lxc.stopsignal\",           config_stopsignal           },\n\t{ \"lxc.start.auto\",           config_start                },\n\t{ \"lxc.start.delay\",          config_start                },\n\t{ \"lxc.start.order\",          config_start                },\n\t{ \"lxc.monitor.unshare\",      config_monitor              },\n\t{ \"lxc.group\",                config_group                },\n\t{ \"lxc.environment\",          config_environment          },\n\t{ \"lxc.init_cmd\",             config_init_cmd             },\n\t{ \"lxc.init_uid\",             config_init_uid             },\n\t{ \"lxc.init_gid\",             config_init_gid             },\n\t{ \"lxc.ephemeral\",            config_ephemeral            },\n\t{ \"lxc.syslog\",               config_syslog               },\n\t{ \"lxc.no_new_privs\",\t      config_no_new_privs\t  },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"lxcseccomp.h\"\n#include \"network.h\"\n#include \"conf.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"confile.h\"\n#include \"config.h\"\n#include \"parse.h\"\n#include \"bdev.h\"\n#include <syslog.h>\n#include <dirent.h>\n#include <time.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int config_personality(const char *, const char *, struct lxc_conf *);\nstatic int config_pts(const char *, const char *, struct lxc_conf *);\nstatic int config_tty(const char *, const char *, struct lxc_conf *);\nstatic int config_ttydir(const char *, const char *, struct lxc_conf *);\nstatic int config_kmsg(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_aa_profile(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_aa_incomplete(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_se_context(const char *, const char *, struct lxc_conf *);\nstatic int config_cgroup(const char *, const char *, struct lxc_conf *);\nstatic int config_idmap(const char *, const char *, struct lxc_conf *);\nstatic int config_loglevel(const char *, const char *, struct lxc_conf *);\nstatic int config_logfile(const char *, const char *, struct lxc_conf *);\nstatic int config_mount(const char *, const char *, struct lxc_conf *);\nstatic int config_mount_auto(const char *, const char *, struct lxc_conf *);\nstatic int config_fstab(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_mount(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_options(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_backend(const char *, const char *, struct lxc_conf *);\nstatic int config_pivotdir(const char *, const char *, struct lxc_conf *);\nstatic int config_utsname(const char *, const char *, struct lxc_conf *);\nstatic int config_hook(const char *, const char *, struct lxc_conf *lxc_conf);\nstatic int config_network(const char *, const char *, struct lxc_conf *);\nstatic int config_network_type(const char *, const char *, struct lxc_conf *);\nstatic int config_network_flags(const char *, const char *, struct lxc_conf *);\nstatic int config_network_link(const char *, const char *, struct lxc_conf *);\nstatic int config_network_name(const char *, const char *, struct lxc_conf *);\nstatic int config_network_veth_pair(const char *, const char *, struct lxc_conf *);\nstatic int config_network_macvlan_mode(const char *, const char *, struct lxc_conf *);\nstatic int config_network_hwaddr(const char *, const char *, struct lxc_conf *);\nstatic int config_network_vlan_id(const char *, const char *, struct lxc_conf *);\nstatic int config_network_mtu(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv4(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv4_gateway(const char *, const char *, struct lxc_conf *);\nstatic int config_network_script_up(const char *, const char *, struct lxc_conf *);\nstatic int config_network_script_down(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv6(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv6_gateway(const char *, const char *, struct lxc_conf *);\nstatic int config_cap_drop(const char *, const char *, struct lxc_conf *);\nstatic int config_cap_keep(const char *, const char *, struct lxc_conf *);\nstatic int config_console(const char *, const char *, struct lxc_conf *);\nstatic int config_console_logfile(const char *, const char *, struct lxc_conf *);\nstatic int config_seccomp(const char *, const char *, struct lxc_conf *);\nstatic int config_includefile(const char *, const char *, struct lxc_conf *);\nstatic int config_network_nic(const char *, const char *, struct lxc_conf *);\nstatic int config_autodev(const char *, const char *, struct lxc_conf *);\nstatic int config_haltsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_rebootsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_stopsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_start(const char *, const char *, struct lxc_conf *);\nstatic int config_syslog(const char *, const char *, struct lxc_conf *);\nstatic int config_monitor(const char *, const char *, struct lxc_conf *);\nstatic int config_group(const char *, const char *, struct lxc_conf *);\nstatic int config_environment(const char *, const char *, struct lxc_conf *);\nstatic int config_init_cmd(const char *, const char *, struct lxc_conf *);\nstatic int config_init_uid(const char *, const char *, struct lxc_conf *);\nstatic int config_init_gid(const char *, const char *, struct lxc_conf *);\nstatic int config_ephemeral(const char *, const char *, struct lxc_conf *);\nstatic int config_no_new_privs(const char *, const char *, struct lxc_conf *);\nstatic struct lxc_config_t config[] = {\n\n\t{ \"lxc.arch\",                 config_personality          },\n\t{ \"lxc.pts\",                  config_pts                  },\n\t{ \"lxc.tty\",                  config_tty                  },\n\t{ \"lxc.devttydir\",            config_ttydir               },\n\t{ \"lxc.kmsg\",                 config_kmsg                 },\n\t{ \"lxc.aa_profile\",           config_lsm_aa_profile       },\n\t{ \"lxc.aa_allow_incomplete\",  config_lsm_aa_incomplete    },\n\t{ \"lxc.se_context\",           config_lsm_se_context       },\n\t{ \"lxc.cgroup\",               config_cgroup               },\n\t{ \"lxc.id_map\",               config_idmap                },\n\t{ \"lxc.loglevel\",             config_loglevel             },\n\t{ \"lxc.logfile\",              config_logfile              },\n\t{ \"lxc.mount.entry\",          config_mount                },\n\t{ \"lxc.mount.auto\",           config_mount_auto           },\n\t{ \"lxc.mount\",                config_fstab                },\n\t{ \"lxc.rootfs.mount\",         config_rootfs_mount         },\n\t{ \"lxc.rootfs.options\",       config_rootfs_options       },\n\t{ \"lxc.rootfs.backend\",       config_rootfs_backend       },\n\t{ \"lxc.rootfs\",               config_rootfs               },\n\t{ \"lxc.pivotdir\",             config_pivotdir             },\n\t{ \"lxc.utsname\",              config_utsname              },\n\t{ \"lxc.hook.pre-start\",       config_hook                 },\n\t{ \"lxc.hook.pre-mount\",       config_hook                 },\n\t{ \"lxc.hook.mount\",           config_hook                 },\n\t{ \"lxc.hook.autodev\",         config_hook                 },\n\t{ \"lxc.hook.start\",           config_hook                 },\n\t{ \"lxc.hook.stop\",            config_hook                 },\n\t{ \"lxc.hook.post-stop\",       config_hook                 },\n\t{ \"lxc.hook.clone\",           config_hook                 },\n\t{ \"lxc.hook.destroy\",         config_hook                 },\n\t{ \"lxc.hook\",                 config_hook                 },\n\t{ \"lxc.network.type\",         config_network_type         },\n\t{ \"lxc.network.flags\",        config_network_flags        },\n\t{ \"lxc.network.link\",         config_network_link         },\n\t{ \"lxc.network.name\",         config_network_name         },\n\t{ \"lxc.network.macvlan.mode\", config_network_macvlan_mode },\n\t{ \"lxc.network.veth.pair\",    config_network_veth_pair    },\n\t{ \"lxc.network.script.up\",    config_network_script_up    },\n\t{ \"lxc.network.script.down\",  config_network_script_down  },\n\t{ \"lxc.network.hwaddr\",       config_network_hwaddr       },\n\t{ \"lxc.network.mtu\",          config_network_mtu          },\n\t{ \"lxc.network.vlan.id\",      config_network_vlan_id      },\n\t{ \"lxc.network.ipv4.gateway\", config_network_ipv4_gateway },\n\t{ \"lxc.network.ipv4\",         config_network_ipv4         },\n\t{ \"lxc.network.ipv6.gateway\", config_network_ipv6_gateway },\n\t{ \"lxc.network.ipv6\",         config_network_ipv6         },\n\t/* config_network_nic must come after all other 'lxc.network.*' entries */\n\t{ \"lxc.network.\",             config_network_nic          },\n\t{ \"lxc.network\",              config_network              },\n\t{ \"lxc.cap.drop\",             config_cap_drop             },\n\t{ \"lxc.cap.keep\",             config_cap_keep             },\n\t{ \"lxc.console.logfile\",      config_console_logfile      },\n\t{ \"lxc.console\",              config_console              },\n\t{ \"lxc.seccomp\",              config_seccomp              },\n\t{ \"lxc.include\",              config_includefile          },\n\t{ \"lxc.autodev\",              config_autodev              },\n\t{ \"lxc.haltsignal\",           config_haltsignal           },\n\t{ \"lxc.rebootsignal\",         config_rebootsignal         },\n\t{ \"lxc.stopsignal\",           config_stopsignal           },\n\t{ \"lxc.start.auto\",           config_start                },\n\t{ \"lxc.start.delay\",          config_start                },\n\t{ \"lxc.start.order\",          config_start                },\n\t{ \"lxc.monitor.unshare\",      config_monitor              },\n\t{ \"lxc.group\",                config_group                },\n\t{ \"lxc.environment\",          config_environment          },\n\t{ \"lxc.init_cmd\",             config_init_cmd             },\n\t{ \"lxc.init_uid\",             config_init_uid             },\n\t{ \"lxc.init_gid\",             config_init_gid             },\n\t{ \"lxc.ephemeral\",            config_ephemeral            },\n\t{ \"lxc.syslog\",               config_syslog               },\n\t{ \"lxc.no_new_privs\",\t      config_no_new_privs\t  },\n};\n\nint lxc_config_read(const char *file, struct lxc_conf *conf, bool from_include)\n{\n\tstruct parse_line_conf c;\n\n\tc.conf = conf;\n\tc.from_include = from_include;\n\n\tif( access(file, R_OK) == -1 ) {\n\t\treturn -1;\n\t}\n\n\t/* Catch only the top level config file name in the structure */\n\tif(!conf->rcfile)\n\t\tconf->rcfile = strdup(file);\n\n\treturn lxc_file_for_each_line(file, parse_line, &c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_conf_init",
          "args": [],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_conf_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "2520-2580",
          "snippet": "struct lxc_conf *lxc_conf_init(void)\n{\n\tstruct lxc_conf *new;\n\tint i;\n\n\tnew = \tmalloc(sizeof(*new));\n\tif (!new) {\n\t\tERROR(\"lxc_conf_init : %m\");\n\t\treturn NULL;\n\t}\n\tmemset(new, 0, sizeof(*new));\n\n\tnew->loglevel = LXC_LOG_PRIORITY_NOTSET;\n\tnew->personality = -1;\n\tnew->autodev = 1;\n\tnew->console.log_path = NULL;\n\tnew->console.log_fd = -1;\n\tnew->console.path = NULL;\n\tnew->console.peer = -1;\n\tnew->console.peerpty.busy = -1;\n\tnew->console.peerpty.master = -1;\n\tnew->console.peerpty.slave = -1;\n\tnew->console.master = -1;\n\tnew->console.slave = -1;\n\tnew->console.name[0] = '\\0';\n\tnew->maincmd_fd = -1;\n\tnew->nbd_idx = -1;\n\tnew->rootfs.mount = strdup(default_rootfs_mount);\n\tif (!new->rootfs.mount) {\n\t\tERROR(\"lxc_conf_init : %m\");\n\t\tfree(new);\n\t\treturn NULL;\n\t}\n\tnew->kmsg = 0;\n\tnew->logfd = -1;\n\tlxc_list_init(&new->cgroup);\n\tlxc_list_init(&new->network);\n\tlxc_list_init(&new->mount_list);\n\tlxc_list_init(&new->caps);\n\tlxc_list_init(&new->keepcaps);\n\tlxc_list_init(&new->id_map);\n\tlxc_list_init(&new->includes);\n\tlxc_list_init(&new->aliens);\n\tlxc_list_init(&new->environment);\n\tfor (i=0; i<NUM_LXC_HOOKS; i++)\n\t\tlxc_list_init(&new->hooks[i]);\n\tlxc_list_init(&new->groups);\n\tnew->lsm_aa_profile = NULL;\n\tnew->lsm_se_context = NULL;\n\tnew->tmp_umount_proc = 0;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++)\n\t\tnew->inherit_ns_fd[i] = -1;\n\n\t/* if running in a new user namespace, init and COMMAND\n\t * default to running as UID/GID 0 when using lxc-execute */\n\tnew->init_uid = 0;\n\tnew->init_gid = 0;\n\n\treturn new;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int in_caplist(int cap, struct lxc_list *caps);",
            "static char *default_rootfs_mount = LXCROOTFSMOUNT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int in_caplist(int cap, struct lxc_list *caps);\nstatic char *default_rootfs_mount = LXCROOTFSMOUNT;\n\nstruct lxc_conf *lxc_conf_init(void)\n{\n\tstruct lxc_conf *new;\n\tint i;\n\n\tnew = \tmalloc(sizeof(*new));\n\tif (!new) {\n\t\tERROR(\"lxc_conf_init : %m\");\n\t\treturn NULL;\n\t}\n\tmemset(new, 0, sizeof(*new));\n\n\tnew->loglevel = LXC_LOG_PRIORITY_NOTSET;\n\tnew->personality = -1;\n\tnew->autodev = 1;\n\tnew->console.log_path = NULL;\n\tnew->console.log_fd = -1;\n\tnew->console.path = NULL;\n\tnew->console.peer = -1;\n\tnew->console.peerpty.busy = -1;\n\tnew->console.peerpty.master = -1;\n\tnew->console.peerpty.slave = -1;\n\tnew->console.master = -1;\n\tnew->console.slave = -1;\n\tnew->console.name[0] = '\\0';\n\tnew->maincmd_fd = -1;\n\tnew->nbd_idx = -1;\n\tnew->rootfs.mount = strdup(default_rootfs_mount);\n\tif (!new->rootfs.mount) {\n\t\tERROR(\"lxc_conf_init : %m\");\n\t\tfree(new);\n\t\treturn NULL;\n\t}\n\tnew->kmsg = 0;\n\tnew->logfd = -1;\n\tlxc_list_init(&new->cgroup);\n\tlxc_list_init(&new->network);\n\tlxc_list_init(&new->mount_list);\n\tlxc_list_init(&new->caps);\n\tlxc_list_init(&new->keepcaps);\n\tlxc_list_init(&new->id_map);\n\tlxc_list_init(&new->includes);\n\tlxc_list_init(&new->aliens);\n\tlxc_list_init(&new->environment);\n\tfor (i=0; i<NUM_LXC_HOOKS; i++)\n\t\tlxc_list_init(&new->hooks[i]);\n\tlxc_list_init(&new->groups);\n\tnew->lsm_aa_profile = NULL;\n\tnew->lsm_se_context = NULL;\n\tnew->tmp_umount_proc = 0;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++)\n\t\tnew->inherit_ns_fd[i] = -1;\n\n\t/* if running in a new user namespace, init and COMMAND\n\t * default to running as UID/GID 0 when using lxc-execute */\n\tnew->init_uid = 0;\n\tnew->init_gid = 0;\n\n\treturn new;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool load_config_locked(struct lxc_container *c, const char *fname)\n{\n\tif (!c->lxc_conf)\n\t\tc->lxc_conf = lxc_conf_init();\n\tif (!c->lxc_conf)\n\t\treturn false;\n\tif (lxc_config_read(fname, c->lxc_conf, false) != 0)\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "do_lxcapi_console_getfd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "485-493",
    "snippet": "static int do_lxcapi_console_getfd(struct lxc_container *c, int *ttynum, int *masterfd)\n{\n\tint ttyfd;\n\tif (!c)\n\t\treturn -1;\n\n\tttyfd = lxc_console_getfd(c, ttynum, masterfd);\n\treturn ttyfd;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_console_getfd",
          "args": [
            "c",
            "ttynum",
            "masterfd"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_console_getfd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
          "lines": "637-640",
          "snippet": "int lxc_console_getfd(struct lxc_container *c, int *ttynum, int *masterfd)\n{\n\treturn lxc_cmd_console(c->name, ttynum, masterfd, c->config_path);\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"start.h\" \t/* for struct lxc_handler */",
            "#include \"mainloop.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"caps.h\"",
            "#include \"af_unix.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_console_getfd(struct lxc_container *c, int *ttynum, int *masterfd)\n{\n\treturn lxc_cmd_console(c->name, ttynum, masterfd, c->config_path);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic int do_lxcapi_console_getfd(struct lxc_container *c, int *ttynum, int *masterfd)\n{\n\tint ttyfd;\n\tif (!c)\n\t\treturn -1;\n\n\tttyfd = lxc_console_getfd(c, ttynum, masterfd);\n\treturn ttyfd;\n}"
  },
  {
    "function_name": "do_lxcapi_unfreeze",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "471-481",
    "snippet": "static bool do_lxcapi_unfreeze(struct lxc_container *c)\n{\n\tint ret;\n\tif (!c)\n\t\treturn false;\n\n\tret = lxc_unfreeze(c->name, c->config_path);\n\tif (ret)\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_unfreeze",
          "args": [
            "c->name",
            "c->config_path"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/freezer.c",
          "lines": "84-87",
          "snippet": "int lxc_unfreeze(const char *name, const char *lxcpath)\n{\n\treturn do_freeze_thaw(0, name, lxcpath);\n}",
          "includes": [
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"monitor.h\"",
            "#include \"state.h\"",
            "#include \"error.h\"",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxc.h\"\n#include \"log.h\"\n#include \"monitor.h\"\n#include \"state.h\"\n#include \"error.h\"\n#include <sys/param.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nint lxc_unfreeze(const char *name, const char *lxcpath)\n{\n\treturn do_freeze_thaw(0, name, lxcpath);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_unfreeze(struct lxc_container *c)\n{\n\tint ret;\n\tif (!c)\n\t\treturn false;\n\n\tret = lxc_unfreeze(c->name, c->config_path);\n\tif (ret)\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "do_lxcapi_freeze",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "457-467",
    "snippet": "static bool do_lxcapi_freeze(struct lxc_container *c)\n{\n\tint ret;\n\tif (!c)\n\t\treturn false;\n\n\tret = lxc_freeze(c->name, c->config_path);\n\tif (ret)\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_freeze",
          "args": [
            "c->name",
            "c->config_path"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/freezer.c",
          "lines": "78-82",
          "snippet": "int lxc_freeze(const char *name, const char *lxcpath)\n{\n\tlxc_monitor_send_state(name, FREEZING, lxcpath);\n\treturn do_freeze_thaw(1, name, lxcpath);\n}",
          "includes": [
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"monitor.h\"",
            "#include \"state.h\"",
            "#include \"error.h\"",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxc.h\"\n#include \"log.h\"\n#include \"monitor.h\"\n#include \"state.h\"\n#include \"error.h\"\n#include <sys/param.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nint lxc_freeze(const char *name, const char *lxcpath)\n{\n\tlxc_monitor_send_state(name, FREEZING, lxcpath);\n\treturn do_freeze_thaw(1, name, lxcpath);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_freeze(struct lxc_container *c)\n{\n\tint ret;\n\tif (!c)\n\t\treturn false;\n\n\tret = lxc_freeze(c->name, c->config_path);\n\tif (ret)\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "do_lxcapi_is_running",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "443-453",
    "snippet": "static bool do_lxcapi_is_running(struct lxc_container *c)\n{\n\tconst char *s;\n\n\tif (!c)\n\t\treturn false;\n\ts = do_lxcapi_state(c);\n\tif (!s || strcmp(s, \"STOPPED\") == 0)\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"STOPPED\""
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_lxcapi_state",
          "args": [
            "c"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "do_lxcapi_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "424-432",
          "snippet": "static const char *do_lxcapi_state(struct lxc_container *c)\n{\n\tlxc_state_t s;\n\n\tif (!c)\n\t\treturn NULL;\n\ts = lxc_getstate(c->name, c->config_path);\n\treturn lxc_state2str(s);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic const char *do_lxcapi_state(struct lxc_container *c)\n{\n\tlxc_state_t s;\n\n\tif (!c)\n\t\treturn NULL;\n\ts = lxc_getstate(c->name, c->config_path);\n\treturn lxc_state2str(s);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_is_running(struct lxc_container *c)\n{\n\tconst char *s;\n\n\tif (!c)\n\t\treturn false;\n\ts = do_lxcapi_state(c);\n\tif (!s || strcmp(s, \"STOPPED\") == 0)\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "is_stopped",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "434-441",
    "snippet": "WRAP_API(const char *, lxcapi_state)\n\nstatic bool is_stopped(struct lxc_container *c)\n{\n\tlxc_state_t s;\n\ts = lxc_getstate(c->name, c->config_path);\n\treturn (s == STOPPED);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_getstate",
          "args": [
            "c->name",
            "c->config_path"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_getstate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/state.c",
          "lines": "72-80",
          "snippet": "lxc_state_t lxc_getstate(const char *name, const char *lxcpath)\n{\n\textern lxc_state_t freezer_state(const char *name, const char *lxcpath);\n\n\tlxc_state_t state = freezer_state(name, lxcpath);\n\tif (state != FROZEN && state != FREEZING)\n\t\tstate = lxc_cmd_get_state(name, lxcpath);\n\treturn state;\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"monitor.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"monitor.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n\nlxc_state_t lxc_getstate(const char *name, const char *lxcpath)\n{\n\textern lxc_state_t freezer_state(const char *name, const char *lxcpath);\n\n\tlxc_state_t state = freezer_state(name, lxcpath);\n\tif (state != FROZEN && state != FREEZING)\n\t\tstate = lxc_cmd_get_state(name, lxcpath);\n\treturn state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nWRAP_API(const char *, lxcapi_state)\n\nstatic bool is_stopped(struct lxc_container *c)\n{\n\tlxc_state_t s;\n\ts = lxc_getstate(c->name, c->config_path);\n\treturn (s == STOPPED);\n}"
  },
  {
    "function_name": "do_lxcapi_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "424-432",
    "snippet": "static const char *do_lxcapi_state(struct lxc_container *c)\n{\n\tlxc_state_t s;\n\n\tif (!c)\n\t\treturn NULL;\n\ts = lxc_getstate(c->name, c->config_path);\n\treturn lxc_state2str(s);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_state2str",
          "args": [
            "s"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_state2str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/state.c",
          "lines": "52-57",
          "snippet": "const char *lxc_state2str(lxc_state_t state)\n{\n\tif (state < STOPPED || state > MAX_STATE - 1)\n\t\treturn NULL;\n\treturn strstate[state];\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"monitor.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const strstate[] = {\n\t\"STOPPED\", \"STARTING\", \"RUNNING\", \"STOPPING\",\n\t\"ABORTING\", \"FREEZING\", \"FROZEN\", \"THAWED\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"monitor.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic const char * const strstate[] = {\n\t\"STOPPED\", \"STARTING\", \"RUNNING\", \"STOPPING\",\n\t\"ABORTING\", \"FREEZING\", \"FROZEN\", \"THAWED\",\n};\n\nconst char *lxc_state2str(lxc_state_t state)\n{\n\tif (state < STOPPED || state > MAX_STATE - 1)\n\t\treturn NULL;\n\treturn strstate[state];\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_getstate",
          "args": [
            "c->name",
            "c->config_path"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_getstate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/state.c",
          "lines": "72-80",
          "snippet": "lxc_state_t lxc_getstate(const char *name, const char *lxcpath)\n{\n\textern lxc_state_t freezer_state(const char *name, const char *lxcpath);\n\n\tlxc_state_t state = freezer_state(name, lxcpath);\n\tif (state != FROZEN && state != FREEZING)\n\t\tstate = lxc_cmd_get_state(name, lxcpath);\n\treturn state;\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"monitor.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"monitor.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n\nlxc_state_t lxc_getstate(const char *name, const char *lxcpath)\n{\n\textern lxc_state_t freezer_state(const char *name, const char *lxcpath);\n\n\tlxc_state_t state = freezer_state(name, lxcpath);\n\tif (state != FROZEN && state != FREEZING)\n\t\tstate = lxc_cmd_get_state(name, lxcpath);\n\treturn state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic const char *do_lxcapi_state(struct lxc_container *c)\n{\n\tlxc_state_t s;\n\n\tif (!c)\n\t\treturn NULL;\n\ts = lxc_getstate(c->name, c->config_path);\n\treturn lxc_state2str(s);\n}"
  },
  {
    "function_name": "do_lxcapi_is_defined",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "327-348",
    "snippet": "static bool do_lxcapi_is_defined(struct lxc_container *c)\n{\n\tstruct stat statbuf;\n\tbool ret = false;\n\tint statret;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (container_mem_lock(c))\n\t\treturn false;\n\tif (!c->configfile)\n\t\tgoto out;\n\tstatret = stat(c->configfile, &statbuf);\n\tif (statret != 0)\n\t\tgoto out;\n\tret = true;\n\nout:\n\tcontainer_mem_unlock(c);\n\treturn ret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_mem_unlock",
          "args": [
            "c"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "container_mem_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "347-350",
          "snippet": "void container_mem_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->privlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nvoid container_mem_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->privlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "c->configfile",
            "&statbuf"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "freezer_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/freezer.c",
          "lines": "42-51",
          "snippet": "lxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}",
          "includes": [
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"monitor.h\"",
            "#include \"state.h\"",
            "#include \"error.h\"",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxc.h\"\n#include \"log.h\"\n#include \"monitor.h\"\n#include \"state.h\"\n#include \"error.h\"\n#include <sys/param.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nlxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_mem_lock",
          "args": [
            "c"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "container_mem_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "342-345",
          "snippet": "int container_mem_lock(struct lxc_container *c)\n{\n\treturn lxclock(c->privlock, 0);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nint container_mem_lock(struct lxc_container *c)\n{\n\treturn lxclock(c->privlock, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_is_defined(struct lxc_container *c)\n{\n\tstruct stat statbuf;\n\tbool ret = false;\n\tint statret;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (container_mem_lock(c))\n\t\treturn false;\n\tif (!c->configfile)\n\t\tgoto out;\n\tstatret = stat(c->configfile, &statbuf);\n\tif (statret != 0)\n\t\tgoto out;\n\tret = true;\n\nout:\n\tcontainer_mem_unlock(c);\n\treturn ret;\n}"
  },
  {
    "function_name": "lxc_container_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "312-325",
    "snippet": "int lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_mem_unlock",
          "args": [
            "c"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "container_mem_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "347-350",
          "snippet": "void container_mem_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->privlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nvoid container_mem_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->privlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_container_free",
          "args": [
            "c"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "238-265",
          "snippet": "static void lxc_container_free(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn;\n\n\tfree(c->configfile);\n\tc->configfile = NULL;\n\tfree(c->error_string);\n\tc->error_string = NULL;\n\tif (c->slock) {\n\t\tlxc_putlock(c->slock);\n\t\tc->slock = NULL;\n\t}\n\tif (c->privlock) {\n\t\tlxc_putlock(c->privlock);\n\t\tc->privlock = NULL;\n\t}\n\tfree(c->name);\n\tc->name = NULL;\n\tif (c->lxc_conf) {\n\t\tlxc_conf_free(c->lxc_conf);\n\t\tc->lxc_conf = NULL;\n\t}\n\tfree(c->config_path);\n\tc->config_path = NULL;\n\n\tfree(c);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic void lxc_container_free(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn;\n\n\tfree(c->configfile);\n\tc->configfile = NULL;\n\tfree(c->error_string);\n\tc->error_string = NULL;\n\tif (c->slock) {\n\t\tlxc_putlock(c->slock);\n\t\tc->slock = NULL;\n\t}\n\tif (c->privlock) {\n\t\tlxc_putlock(c->privlock);\n\t\tc->privlock = NULL;\n\t}\n\tfree(c->name);\n\tc->name = NULL;\n\tif (c->lxc_conf) {\n\t\tlxc_conf_free(c->lxc_conf);\n\t\tc->lxc_conf = NULL;\n\t}\n\tfree(c->config_path);\n\tc->config_path = NULL;\n\n\tfree(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_mem_lock",
          "args": [
            "c"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "container_mem_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "342-345",
          "snippet": "int container_mem_lock(struct lxc_container *c)\n{\n\treturn lxclock(c->privlock, 0);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nint container_mem_lock(struct lxc_container *c)\n{\n\treturn lxclock(c->privlock, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_container_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "290-310",
    "snippet": "int lxc_container_get(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn 0;\n\n\t// if someone else has already started freeing the container, don't\n\t// try to take the lock, which may be invalid\n\tif (c->numthreads < 1)\n\t\treturn 0;\n\n\tif (container_mem_lock(c))\n\t\treturn 0;\n\tif (c->numthreads < 1) {\n\t\t// bail without trying to unlock, bc the privlock is now probably\n\t\t// in freed memory\n\t\treturn 0;\n\t}\n\tc->numthreads++;\n\tcontainer_mem_unlock(c);\n\treturn 1;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_mem_unlock",
          "args": [
            "c"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "container_mem_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "347-350",
          "snippet": "void container_mem_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->privlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nvoid container_mem_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->privlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_mem_lock",
          "args": [
            "c"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "container_mem_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "342-345",
          "snippet": "int container_mem_lock(struct lxc_container *c)\n{\n\treturn lxclock(c->privlock, 0);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nint container_mem_lock(struct lxc_container *c)\n{\n\treturn lxclock(c->privlock, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint lxc_container_get(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn 0;\n\n\t// if someone else has already started freeing the container, don't\n\t// try to take the lock, which may be invalid\n\tif (c->numthreads < 1)\n\t\treturn 0;\n\n\tif (container_mem_lock(c))\n\t\treturn 0;\n\tif (c->numthreads < 1) {\n\t\t// bail without trying to unlock, bc the privlock is now probably\n\t\t// in freed memory\n\t\treturn 0;\n\t}\n\tc->numthreads++;\n\tcontainer_mem_unlock(c);\n\treturn 1;\n}"
  },
  {
    "function_name": "lxc_container_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "238-265",
    "snippet": "static void lxc_container_free(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn;\n\n\tfree(c->configfile);\n\tc->configfile = NULL;\n\tfree(c->error_string);\n\tc->error_string = NULL;\n\tif (c->slock) {\n\t\tlxc_putlock(c->slock);\n\t\tc->slock = NULL;\n\t}\n\tif (c->privlock) {\n\t\tlxc_putlock(c->privlock);\n\t\tc->privlock = NULL;\n\t}\n\tfree(c->name);\n\tc->name = NULL;\n\tif (c->lxc_conf) {\n\t\tlxc_conf_free(c->lxc_conf);\n\t\tc->lxc_conf = NULL;\n\t}\n\tfree(c->config_path);\n\tc->config_path = NULL;\n\n\tfree(c);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "c"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "free_init_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "706-715",
          "snippet": "static void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic void free_init_cmd(char **argv)\n{\n\tint i = 0;\n\n\tif (!argv)\n\t\treturn;\n\twhile (argv[i])\n\t\tfree(argv[i++]);\n\tfree(argv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_conf_free",
          "args": [
            "c->lxc_conf"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_conf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4289-4328",
          "snippet": "void lxc_conf_free(struct lxc_conf *conf)\n{\n\tif (!conf)\n\t\treturn;\n\tif (current_config == conf)\n\t\tcurrent_config = NULL;\n\tfree(conf->console.log_path);\n\tfree(conf->console.path);\n\tfree(conf->rootfs.mount);\n\tfree(conf->rootfs.bdev_type);\n\tfree(conf->rootfs.options);\n\tfree(conf->rootfs.path);\n\tfree(conf->logfile);\n\tif (conf->logfd != -1)\n\t\tclose(conf->logfd);\n\tfree(conf->utsname);\n\tfree(conf->ttydir);\n\tfree(conf->fstab);\n\tfree(conf->rcfile);\n\tfree(conf->init_cmd);\n\tfree(conf->unexpanded_config);\n\tfree(conf->pty_names);\n\tfree(conf->syslog);\n\tlxc_clear_config_network(conf);\n\tfree(conf->lsm_aa_profile);\n\tfree(conf->lsm_se_context);\n\tlxc_seccomp_free(conf);\n\tlxc_clear_config_caps(conf);\n\tlxc_clear_config_keepcaps(conf);\n\tlxc_clear_cgroups(conf, \"lxc.cgroup\");\n\tlxc_clear_hooks(conf, \"lxc.hook\");\n\tlxc_clear_mount_entries(conf);\n\tlxc_clear_saved_nics(conf);\n\tlxc_clear_idmaps(conf);\n\tlxc_clear_groups(conf);\n\tlxc_clear_includes(conf);\n\tlxc_clear_aliens(conf);\n\tlxc_clear_environment(conf);\n\tfree(conf);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid lxc_conf_free(struct lxc_conf *conf)\n{\n\tif (!conf)\n\t\treturn;\n\tif (current_config == conf)\n\t\tcurrent_config = NULL;\n\tfree(conf->console.log_path);\n\tfree(conf->console.path);\n\tfree(conf->rootfs.mount);\n\tfree(conf->rootfs.bdev_type);\n\tfree(conf->rootfs.options);\n\tfree(conf->rootfs.path);\n\tfree(conf->logfile);\n\tif (conf->logfd != -1)\n\t\tclose(conf->logfd);\n\tfree(conf->utsname);\n\tfree(conf->ttydir);\n\tfree(conf->fstab);\n\tfree(conf->rcfile);\n\tfree(conf->init_cmd);\n\tfree(conf->unexpanded_config);\n\tfree(conf->pty_names);\n\tfree(conf->syslog);\n\tlxc_clear_config_network(conf);\n\tfree(conf->lsm_aa_profile);\n\tfree(conf->lsm_se_context);\n\tlxc_seccomp_free(conf);\n\tlxc_clear_config_caps(conf);\n\tlxc_clear_config_keepcaps(conf);\n\tlxc_clear_cgroups(conf, \"lxc.cgroup\");\n\tlxc_clear_hooks(conf, \"lxc.hook\");\n\tlxc_clear_mount_entries(conf);\n\tlxc_clear_saved_nics(conf);\n\tlxc_clear_idmaps(conf);\n\tlxc_clear_groups(conf);\n\tlxc_clear_includes(conf);\n\tlxc_clear_aliens(conf);\n\tlxc_clear_environment(conf);\n\tfree(conf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_putlock",
          "args": [
            "c->privlock"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_putlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "291-313",
          "snippet": "void lxc_putlock(struct lxc_lock *l)\n{\n\tif (!l)\n\t\treturn;\n\tswitch(l->type) {\n\tcase LXC_LOCK_ANON_SEM:\n\t\tif (l->u.sem) {\n\t\t\tsem_destroy(l->u.sem);\n\t\t\tfree(l->u.sem);\n\t\t\tl->u.sem = NULL;\n\t\t}\n\t\tbreak;\n\tcase LXC_LOCK_FLOCK:\n\t\tif (l->u.f.fd != -1) {\n\t\t\tclose(l->u.f.fd);\n\t\t\tl->u.f.fd = -1;\n\t\t}\n\t\tfree(l->u.f.fname);\n\t\tl->u.f.fname = NULL;\n\t\tbreak;\n\t}\n\tfree(l);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nvoid lxc_putlock(struct lxc_lock *l)\n{\n\tif (!l)\n\t\treturn;\n\tswitch(l->type) {\n\tcase LXC_LOCK_ANON_SEM:\n\t\tif (l->u.sem) {\n\t\t\tsem_destroy(l->u.sem);\n\t\t\tfree(l->u.sem);\n\t\t\tl->u.sem = NULL;\n\t\t}\n\t\tbreak;\n\tcase LXC_LOCK_FLOCK:\n\t\tif (l->u.f.fd != -1) {\n\t\t\tclose(l->u.f.fd);\n\t\t\tl->u.f.fd = -1;\n\t\t}\n\t\tfree(l->u.f.fname);\n\t\tl->u.f.fname = NULL;\n\t\tbreak;\n\t}\n\tfree(l);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic void lxc_container_free(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn;\n\n\tfree(c->configfile);\n\tc->configfile = NULL;\n\tfree(c->error_string);\n\tc->error_string = NULL;\n\tif (c->slock) {\n\t\tlxc_putlock(c->slock);\n\t\tc->slock = NULL;\n\t}\n\tif (c->privlock) {\n\t\tlxc_putlock(c->privlock);\n\t\tc->privlock = NULL;\n\t}\n\tfree(c->name);\n\tc->name = NULL;\n\tif (c->lxc_conf) {\n\t\tlxc_conf_free(c->lxc_conf);\n\t\tc->lxc_conf = NULL;\n\t}\n\tfree(c->config_path);\n\tc->config_path = NULL;\n\n\tfree(c);\n}"
  },
  {
    "function_name": "remove_partial",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "199-214",
    "snippet": "static void remove_partial(struct lxc_container *c, int fd)\n{\n\t// $lxcpath + '/' + $name + '/partial' + \\0\n\tint len = strlen(c->config_path) + strlen(c->name) + 10;\n\tchar *path = alloca(len);\n\tint ret;\n\n\tclose(fd);\n\tret = snprintf(path, len, \"%s/%s/partial\", c->config_path, c->name);\n\tif (ret < 0 || ret >= len) {\n\t\tERROR(\"Error writing partial pathname\");\n\t\treturn;\n\t}\n\tif (unlink(path) < 0)\n\t\tSYSERROR(\"Error unlink partial file %s\", path);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error unlink partial file %s\"",
            "path"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "path"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error writing partial pathname\""
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "len",
            "\"%s/%s/partial\"",
            "c->config_path",
            "c->name"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "len"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "c->name"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "c->config_path"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic void remove_partial(struct lxc_container *c, int fd)\n{\n\t// $lxcpath + '/' + $name + '/partial' + \\0\n\tint len = strlen(c->config_path) + strlen(c->name) + 10;\n\tchar *path = alloca(len);\n\tint ret;\n\n\tclose(fd);\n\tret = snprintf(path, len, \"%s/%s/partial\", c->config_path, c->name);\n\tif (ret < 0 || ret >= len) {\n\t\tERROR(\"Error writing partial pathname\");\n\t\treturn;\n\t}\n\tif (unlink(path) < 0)\n\t\tSYSERROR(\"Error unlink partial file %s\", path);\n}"
  },
  {
    "function_name": "create_partial",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "169-197",
    "snippet": "static int create_partial(struct lxc_container *c)\n{\n\t// $lxcpath + '/' + $name + '/partial' + \\0\n\tint len = strlen(c->config_path) + strlen(c->name) + 10;\n\tchar *path = alloca(len);\n\tint fd, ret;\n\tstruct flock lk;\n\n\tret = snprintf(path, len, \"%s/%s/partial\", c->config_path, c->name);\n\tif (ret < 0 || ret >= len) {\n\t\tERROR(\"Error writing partial pathname\");\n\t\treturn -1;\n\t}\n\tif ((fd=open(path, O_RDWR | O_CREAT | O_EXCL, 0755)) < 0) {\n\t\tSYSERROR(\"Error creating partial file\");\n\t\treturn -1;\n\t}\n\tlk.l_type = F_WRLCK;\n\tlk.l_whence = SEEK_SET;\n\tlk.l_start = 0;\n\tlk.l_len = 0;\n\tif (fcntl(fd, F_SETLKW, &lk) < 0) {\n\t\tSYSERROR(\"Error locking partial file %s\", path);\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error locking partial file %s\"",
            "path"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "fd",
            "F_SETLKW",
            "&lk"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error creating partial file\""
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "path",
            "O_RDWR | O_CREAT | O_EXCL",
            "0755"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "37-82",
          "snippet": "int lxc_abstract_unix_open(const char *path, int type, int flags)\n{\n\tint fd;\n\tsize_t len;\n\tstruct sockaddr_un addr;\n\n\tif (flags & O_TRUNC)\n\t\tunlink(path);\n\n\tfd = socket(PF_UNIX, type, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\n\t/* Clear address structure */\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (!path)\n\t\treturn fd;\n\n\taddr.sun_family = AF_UNIX;\n\n\tlen = strlen(&path[1]) + 1;\n\tif (len >= sizeof(addr.sun_path) - 1) {\n\t\tclose(fd);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\t/* addr.sun_path[0] has already been set to 0 by memset() */\n\tstrncpy(&addr.sun_path[1], &path[1], strlen(&path[1]));\n\n\tif (bind(fd, (struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path) + len)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\tif (type == SOCK_STREAM && listen(fd, 100)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_open(const char *path, int type, int flags)\n{\n\tint fd;\n\tsize_t len;\n\tstruct sockaddr_un addr;\n\n\tif (flags & O_TRUNC)\n\t\tunlink(path);\n\n\tfd = socket(PF_UNIX, type, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\n\t/* Clear address structure */\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (!path)\n\t\treturn fd;\n\n\taddr.sun_family = AF_UNIX;\n\n\tlen = strlen(&path[1]) + 1;\n\tif (len >= sizeof(addr.sun_path) - 1) {\n\t\tclose(fd);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\t/* addr.sun_path[0] has already been set to 0 by memset() */\n\tstrncpy(&addr.sun_path[1], &path[1], strlen(&path[1]));\n\n\tif (bind(fd, (struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path) + len)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\tif (type == SOCK_STREAM && listen(fd, 100)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error writing partial pathname\""
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "len",
            "\"%s/%s/partial\"",
            "c->config_path",
            "c->name"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "len"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "c->name"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "c->config_path"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic int create_partial(struct lxc_container *c)\n{\n\t// $lxcpath + '/' + $name + '/partial' + \\0\n\tint len = strlen(c->config_path) + strlen(c->name) + 10;\n\tchar *path = alloca(len);\n\tint fd, ret;\n\tstruct flock lk;\n\n\tret = snprintf(path, len, \"%s/%s/partial\", c->config_path, c->name);\n\tif (ret < 0 || ret >= len) {\n\t\tERROR(\"Error writing partial pathname\");\n\t\treturn -1;\n\t}\n\tif ((fd=open(path, O_RDWR | O_CREAT | O_EXCL, 0755)) < 0) {\n\t\tSYSERROR(\"Error creating partial file\");\n\t\treturn -1;\n\t}\n\tlk.l_type = F_WRLCK;\n\tlk.l_whence = SEEK_SET;\n\tlk.l_start = 0;\n\tlk.l_len = 0;\n\tif (fcntl(fd, F_SETLKW, &lk) < 0) {\n\t\tSYSERROR(\"Error locking partial file %s\", path);\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}"
  },
  {
    "function_name": "ongoing_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "133-167",
    "snippet": "static int ongoing_create(struct lxc_container *c)\n{\n\tint len = strlen(c->config_path) + strlen(c->name) + 10;\n\tchar *path = alloca(len);\n\tint fd, ret;\n\tstruct flock lk;\n\n\tret = snprintf(path, len, \"%s/%s/partial\", c->config_path, c->name);\n\tif (ret < 0 || ret >= len) {\n\t\tERROR(\"Error writing partial pathname\");\n\t\treturn -1;\n\t}\n\n\tif (!file_exists(path))\n\t\treturn 0;\n\tfd = open(path, O_RDWR);\n\tif (fd < 0) {\n\t\t// give benefit of the doubt\n\t\tSYSERROR(\"Error opening partial file\");\n\t\treturn 0;\n\t}\n\tlk.l_type = F_WRLCK;\n\tlk.l_whence = SEEK_SET;\n\tlk.l_start = 0;\n\tlk.l_len = 0;\n\tlk.l_pid = -1;\n\tif (fcntl(fd, F_GETLK, &lk) == 0 && lk.l_pid != -1) {\n\t\t// create is still ongoing\n\t\tclose(fd);\n\t\treturn 1;\n\t}\n\t// create completed but partial is still there.\n\tclose(fd);\n\treturn 2;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_lxcapi_destroy(struct lxc_container *c);",
      "static const char *lxcapi_get_config_path(struct lxc_container *c);",
      "static bool container_destroy(struct lxc_container *c);",
      "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "fd",
            "F_GETLK",
            "&lk"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error opening partial file\""
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "path",
            "O_RDWR"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "genetlink_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/genl.c",
          "lines": "106-116",
          "snippet": "extern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"genl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/genetlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"genl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_exists",
          "args": [
            "path"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "file_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1240-1245",
          "snippet": "bool file_exists(const char *f)\n{\n\tstruct stat statbuf;\n\n\treturn stat(f, &statbuf) == 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool file_exists(const char *f)\n{\n\tstruct stat statbuf;\n\n\treturn stat(f, &statbuf) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error writing partial pathname\""
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "len",
            "\"%s/%s/partial\"",
            "c->config_path",
            "c->name"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "len"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "c->name"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "c->config_path"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic int ongoing_create(struct lxc_container *c)\n{\n\tint len = strlen(c->config_path) + strlen(c->name) + 10;\n\tchar *path = alloca(len);\n\tint fd, ret;\n\tstruct flock lk;\n\n\tret = snprintf(path, len, \"%s/%s/partial\", c->config_path, c->name);\n\tif (ret < 0 || ret >= len) {\n\t\tERROR(\"Error writing partial pathname\");\n\t\treturn -1;\n\t}\n\n\tif (!file_exists(path))\n\t\treturn 0;\n\tfd = open(path, O_RDWR);\n\tif (fd < 0) {\n\t\t// give benefit of the doubt\n\t\tSYSERROR(\"Error opening partial file\");\n\t\treturn 0;\n\t}\n\tlk.l_type = F_WRLCK;\n\tlk.l_whence = SEEK_SET;\n\tlk.l_start = 0;\n\tlk.l_len = 0;\n\tlk.l_pid = -1;\n\tif (fcntl(fd, F_GETLK, &lk) == 0 && lk.l_pid != -1) {\n\t\t// create is still ongoing\n\t\tclose(fd);\n\t\treturn 1;\n\t}\n\t// create completed but partial is still there.\n\tclose(fd);\n\treturn 2;\n}"
  },
  {
    "function_name": "config_file_exists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "111-122",
    "snippet": "static bool config_file_exists(const char *lxcpath, const char *cname)\n{\n\t/* $lxcpath + '/' + $cname + '/config' + \\0 */\n\tint ret, len = strlen(lxcpath) + strlen(cname) + 9;\n\tchar *fname = alloca(len);\n\n\tret = snprintf(fname, len,  \"%s/%s/config\", lxcpath, cname);\n\tif (ret < 0 || ret >= len)\n\t\treturn false;\n\n\treturn file_exists(fname);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_exists",
          "args": [
            "fname"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "file_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1240-1245",
          "snippet": "bool file_exists(const char *f)\n{\n\tstruct stat statbuf;\n\n\treturn stat(f, &statbuf) == 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool file_exists(const char *f)\n{\n\tstruct stat statbuf;\n\n\treturn stat(f, &statbuf) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "fname",
            "len",
            "\"%s/%s/config\"",
            "lxcpath",
            "cname"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "len"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cname"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "lxcpath"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool config_file_exists(const char *lxcpath, const char *cname)\n{\n\t/* $lxcpath + '/' + $cname + '/config' + \\0 */\n\tint ret, len = strlen(lxcpath) + strlen(cname) + 9;\n\tchar *fname = alloca(len);\n\n\tret = snprintf(fname, len,  \"%s/%s/config\", lxcpath, cname);\n\tif (ret < 0 || ret >= len)\n\t\treturn false;\n\n\treturn file_exists(fname);\n}"
  },
  {
    "function_name": "faccessat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
    "lines": "89-97",
    "snippet": "static int faccessat(int __fd, const char *__file, int __type, int __flag)\n{\n#ifdef __NR_faccessat\nreturn syscall(__NR_faccessat, __fd, __file, __type, __flag);\n#else\nerrno = ENOSYS;\nreturn -1;\n#endif\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <../include/ifaddrs.h>",
      "#include <ifaddrs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"version.h\"",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"sync.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"commands.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <sched.h>",
      "#include <pthread.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "__NR_faccessat",
            "__fd",
            "__file",
            "__type",
            "__flag"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic int faccessat(int __fd, const char *__file, int __type, int __flag)\n{\n#ifdef __NR_faccessat\nreturn syscall(__NR_faccessat, __fd, __file, __type, __flag);\n#else\nerrno = ENOSYS;\nreturn -1;\n#endif\n}"
  }
]