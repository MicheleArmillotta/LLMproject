[
  {
    "function_name": "wait_for_partition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcnbd.c",
    "lines": "300-311",
    "snippet": "static bool wait_for_partition(const char *path)\n{\n\tint count = 0;\n\twhile (count < 5) {\n\t\tif (file_exists(path))\n\t\t\treturn true;\n\t\tsleep(1);\n\t\tcount++;\n\t}\n\tERROR(\"Device %s did not show up after 5 seconds\", path);\n\treturn false;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/prctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdbool.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool clone_attach_nbd(const char *nbd, const char *path);",
      "static void nbd_detach(const char *path);",
      "static bool wait_for_partition(const char *path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Device %s did not show up after 5 seconds\"",
            "path"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "1"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_util_usleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lua-lxc/core.c",
          "lines": "564-567",
          "snippet": "static int lxc_util_usleep(lua_State *L) {\n    usleep((useconds_t)luaL_checkunsigned(L, 1));\n    return 0;\n}",
          "includes": [
            "#include \"lxc/commands.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <libgen.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <assert.h>",
            "#include <lauxlib.h>",
            "#include <lua.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxc/commands.h\"\n#include <lxc/lxccontainer.h>\n#include <libgen.h>\n#include <unistd.h>\n#include <string.h>\n#include <assert.h>\n#include <lauxlib.h>\n#include <lua.h>\n\nstatic int lxc_util_usleep(lua_State *L) {\n    usleep((useconds_t)luaL_checkunsigned(L, 1));\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_exists",
          "args": [
            "path"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "file_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1240-1245",
          "snippet": "bool file_exists(const char *f)\n{\n\tstruct stat statbuf;\n\n\treturn stat(f, &statbuf) == 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool file_exists(const char *f)\n{\n\tstruct stat statbuf;\n\n\treturn stat(f, &statbuf) == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcnbd.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/prctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <errno.h>\n\nstatic bool clone_attach_nbd(const char *nbd, const char *path);\nstatic void nbd_detach(const char *path);\nstatic bool wait_for_partition(const char *path);\n\nstatic bool wait_for_partition(const char *path)\n{\n\tint count = 0;\n\twhile (count < 5) {\n\t\tif (file_exists(path))\n\t\t\treturn true;\n\t\tsleep(1);\n\t\tcount++;\n\t}\n\tERROR(\"Device %s did not show up after 5 seconds\", path);\n\treturn false;\n}"
  },
  {
    "function_name": "nbd_get_partition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcnbd.c",
    "lines": "286-298",
    "snippet": "static int nbd_get_partition(const char *src)\n{\n\tchar *p = strchr(src, ':');\n\tif (!p)\n\t\treturn 0;\n\tp = strchr(p+1, ':');\n\tif (!p)\n\t\treturn 0;\n\tp++;\n\tif (*p < '1' || *p > '9')\n\t\treturn 0;\n\treturn *p - '0';\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/prctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdbool.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nbd_get_partition(const char *src);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p+1",
            "':'"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcnbd.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/prctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <errno.h>\n\nstatic int nbd_get_partition(const char *src);\n\nstatic int nbd_get_partition(const char *src)\n{\n\tchar *p = strchr(src, ':');\n\tif (!p)\n\t\treturn 0;\n\tp = strchr(p+1, ':');\n\tif (!p)\n\t\treturn 0;\n\tp++;\n\tif (*p < '1' || *p > '9')\n\t\treturn 0;\n\treturn *p - '0';\n}"
  },
  {
    "function_name": "nbd_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcnbd.c",
    "lines": "261-279",
    "snippet": "static void nbd_detach(const char *path)\n{\n\tint ret;\n\tpid_t pid = fork();\n\n\tif (pid < 0) {\n\t\tSYSERROR(\"Error forking to detach nbd\");\n\t\treturn;\n\t}\n\tif (pid) {\n\t\tret = wait_for_pid(pid);\n\t\tif (ret < 0)\n\t\t\tERROR(\"nbd disconnect returned an error\");\n\t\treturn;\n\t}\n\texeclp(\"qemu-nbd\", \"qemu-nbd\", \"-d\", path, (char *)NULL);\n\tSYSERROR(\"Error executing qemu-nbd\");\n\texit(1);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/prctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdbool.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool clone_attach_nbd(const char *nbd, const char *path);",
      "static int do_attach_nbd(void *d);",
      "static void nbd_detach(const char *path);",
      "static bool wait_for_partition(const char *path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error executing qemu-nbd\""
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "\"qemu-nbd\"",
            "\"qemu-nbd\"",
            "\"-d\"",
            "path",
            "(char *)NULL"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"nbd disconnect returned an error\""
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_pid",
          "args": [
            "pid"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "67-81",
          "snippet": "static int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error forking to detach nbd\""
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcnbd.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/prctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <errno.h>\n\nstatic bool clone_attach_nbd(const char *nbd, const char *path);\nstatic int do_attach_nbd(void *d);\nstatic void nbd_detach(const char *path);\nstatic bool wait_for_partition(const char *path);\n\nstatic void nbd_detach(const char *path)\n{\n\tint ret;\n\tpid_t pid = fork();\n\n\tif (pid < 0) {\n\t\tSYSERROR(\"Error forking to detach nbd\");\n\t\treturn;\n\t}\n\tif (pid) {\n\t\tret = wait_for_pid(pid);\n\t\tif (ret < 0)\n\t\t\tERROR(\"nbd disconnect returned an error\");\n\t\treturn;\n\t}\n\texeclp(\"qemu-nbd\", \"qemu-nbd\", \"-d\", path, (char *)NULL);\n\tSYSERROR(\"Error executing qemu-nbd\");\n\texit(1);\n}"
  },
  {
    "function_name": "nbd_busy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcnbd.c",
    "lines": "250-259",
    "snippet": "static bool nbd_busy(int idx)\n{\n\tchar path[100];\n\tint ret;\n\n\tret = snprintf(path, 100, \"/sys/block/nbd%d/pid\", idx);\n\tif (ret < 0 || ret >= 100)\n\t\treturn true;\n\treturn file_exists(path);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/prctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdbool.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool clone_attach_nbd(const char *nbd, const char *path);",
      "static int do_attach_nbd(void *d);",
      "static bool nbd_busy(int idx);",
      "static void nbd_detach(const char *path);",
      "static bool wait_for_partition(const char *path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_exists",
          "args": [
            "path"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "file_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1240-1245",
          "snippet": "bool file_exists(const char *f)\n{\n\tstruct stat statbuf;\n\n\treturn stat(f, &statbuf) == 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool file_exists(const char *f)\n{\n\tstruct stat statbuf;\n\n\treturn stat(f, &statbuf) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "100",
            "\"/sys/block/nbd%d/pid\"",
            "idx"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcnbd.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/prctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <errno.h>\n\nstatic bool clone_attach_nbd(const char *nbd, const char *path);\nstatic int do_attach_nbd(void *d);\nstatic bool nbd_busy(int idx);\nstatic void nbd_detach(const char *path);\nstatic bool wait_for_partition(const char *path);\n\nstatic bool nbd_busy(int idx)\n{\n\tchar path[100];\n\tint ret;\n\n\tret = snprintf(path, 100, \"/sys/block/nbd%d/pid\", idx);\n\tif (ret < 0 || ret >= 100)\n\t\treturn true;\n\treturn file_exists(path);\n}"
  },
  {
    "function_name": "clone_attach_nbd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcnbd.c",
    "lines": "236-248",
    "snippet": "static bool clone_attach_nbd(const char *nbd, const char *path)\n{\n\tpid_t pid;\n\tstruct nbd_attach_data data;\n\n\tdata.nbd = nbd;\n\tdata.path = path;\n\n\tpid = lxc_clone(do_attach_nbd, &data, CLONE_NEWPID);\n\tif (pid < 0)\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/prctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdbool.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool clone_attach_nbd(const char *nbd, const char *path);",
      "static void nbd_detach(const char *path);",
      "static bool wait_for_partition(const char *path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_clone",
          "args": [
            "do_attach_nbd",
            "&data",
            "CLONE_NEWPID"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_clone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/namespace.c",
          "lines": "49-70",
          "snippet": "pid_t lxc_clone(int (*fn)(void *), void *arg, int flags)\n{\n\tstruct clone_arg clone_arg = {\n\t\t.fn = fn,\n\t\t.arg = arg,\n\t};\n\n\tsize_t stack_size = sysconf(_SC_PAGESIZE);\n\tvoid *stack = alloca(stack_size);\n\tpid_t ret;\n\n#ifdef __ia64__\n\tret = __clone2(do_clone, stack,\n\t\t       stack_size, flags | SIGCHLD, &clone_arg);\n#else\n\tret = clone(do_clone, stack  + stack_size, flags | SIGCHLD, &clone_arg);\n#endif\n\tif (ret < 0)\n\t\tERROR(\"Failed to clone (%#x): %s.\", flags, strerror(errno));\n\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"namespace.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <alloca.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"namespace.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <signal.h>\n#include <errno.h>\n#include <alloca.h>\n#include <unistd.h>\n\npid_t lxc_clone(int (*fn)(void *), void *arg, int flags)\n{\n\tstruct clone_arg clone_arg = {\n\t\t.fn = fn,\n\t\t.arg = arg,\n\t};\n\n\tsize_t stack_size = sysconf(_SC_PAGESIZE);\n\tvoid *stack = alloca(stack_size);\n\tpid_t ret;\n\n#ifdef __ia64__\n\tret = __clone2(do_clone, stack,\n\t\t       stack_size, flags | SIGCHLD, &clone_arg);\n#else\n\tret = clone(do_clone, stack  + stack_size, flags | SIGCHLD, &clone_arg);\n#endif\n\tif (ret < 0)\n\t\tERROR(\"Failed to clone (%#x): %s.\", flags, strerror(errno));\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcnbd.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/prctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <errno.h>\n\nstatic bool clone_attach_nbd(const char *nbd, const char *path);\nstatic void nbd_detach(const char *path);\nstatic bool wait_for_partition(const char *path);\n\nstatic bool clone_attach_nbd(const char *nbd, const char *path)\n{\n\tpid_t pid;\n\tstruct nbd_attach_data data;\n\n\tdata.nbd = nbd;\n\tdata.path = path;\n\n\tpid = lxc_clone(do_attach_nbd, &data, CLONE_NEWPID);\n\tif (pid < 0)\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "do_attach_nbd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcnbd.c",
    "lines": "170-234",
    "snippet": "static int do_attach_nbd(void *d)\n{\n\tstruct nbd_attach_data *data = d;\n\tconst char *nbd, *path;\n\tpid_t pid;\n\tsigset_t mask;\n\tint sfd;\n\tssize_t s;\n\tstruct signalfd_siginfo fdsi;\n\n\tsigemptyset(&mask);\n\tsigaddset(&mask, SIGHUP);\n\tsigaddset(&mask, SIGCHLD);\n\n\tnbd = data->nbd;\n\tpath = data->path;\n\n\tif (sigprocmask(SIG_BLOCK, &mask, NULL) == -1) {\n\t\tSYSERROR(\"Error blocking signals for nbd watcher\");\n\t\texit(1);\n\t}\n\n\tsfd = signalfd(-1, &mask, 0);\n\tif (sfd == -1) {\n\t\tSYSERROR(\"Error opening signalfd for nbd task\");\n\t\texit(1);\n\t}\n\n\tif (prctl(PR_SET_PDEATHSIG, SIGHUP, 0, 0, 0) < 0)\n\t\tSYSERROR(\"Error setting parent death signal for nbd watcher\");\n\n\tpid = fork();\n\tif (pid) {\n\t\tfor (;;) {\n\t\t\ts = read(sfd, &fdsi, sizeof(struct signalfd_siginfo));\n\t\t\tif (s != sizeof(struct signalfd_siginfo))\n\t\t\t\tSYSERROR(\"Error reading from signalfd\");\n\n\t\t\tif (fdsi.ssi_signo == SIGHUP) {\n\t\t\t\t/* container has exited */\n\t\t\t\tnbd_detach(nbd);\n\t\t\t\texit(0);\n\t\t\t} else if (fdsi.ssi_signo == SIGCHLD) {\n\t\t\t\tint status;\n\t\t\t\t/* If qemu-nbd fails, or is killed by a signal,\n\t\t\t\t * then exit */\n\t\t\t\twhile (waitpid(-1, &status, WNOHANG) > 0) {\n\t\t\t\t\tif ((WIFEXITED(status) && WEXITSTATUS(status) != 0) ||\n\t\t\t\t\t\t\tWIFSIGNALED(status)) {\n\t\t\t\t\t\tnbd_detach(nbd);\n\t\t\t\t\t\texit(1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tclose(sfd);\n\tif (sigprocmask(SIG_UNBLOCK, &mask, NULL) == -1)\n\t\tWARN(\"Warning: unblocking signals for nbd watcher\");\n\n\texeclp(\"qemu-nbd\", \"qemu-nbd\", \"-c\", nbd, path, (char *)NULL);\n\tSYSERROR(\"Error executing qemu-nbd\");\n\texit(1);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/prctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdbool.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool clone_attach_nbd(const char *nbd, const char *path);",
      "static int do_attach_nbd(void *d);",
      "static void nbd_detach(const char *path);",
      "static bool wait_for_partition(const char *path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error executing qemu-nbd\""
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "\"qemu-nbd\"",
            "\"qemu-nbd\"",
            "\"-c\"",
            "nbd",
            "path",
            "(char *)NULL"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Warning: unblocking signals for nbd watcher\""
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_UNBLOCK",
            "&mask",
            "NULL"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sfd"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nbd_detach",
          "args": [
            "nbd"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "nbd_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcnbd.c",
          "lines": "261-279",
          "snippet": "static void nbd_detach(const char *path)\n{\n\tint ret;\n\tpid_t pid = fork();\n\n\tif (pid < 0) {\n\t\tSYSERROR(\"Error forking to detach nbd\");\n\t\treturn;\n\t}\n\tif (pid) {\n\t\tret = wait_for_pid(pid);\n\t\tif (ret < 0)\n\t\t\tERROR(\"nbd disconnect returned an error\");\n\t\treturn;\n\t}\n\texeclp(\"qemu-nbd\", \"qemu-nbd\", \"-d\", path, (char *)NULL);\n\tSYSERROR(\"Error executing qemu-nbd\");\n\texit(1);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/prctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdbool.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool clone_attach_nbd(const char *nbd, const char *path);",
            "static int do_attach_nbd(void *d);",
            "static void nbd_detach(const char *path);",
            "static bool wait_for_partition(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcnbd.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/prctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <errno.h>\n\nstatic bool clone_attach_nbd(const char *nbd, const char *path);\nstatic int do_attach_nbd(void *d);\nstatic void nbd_detach(const char *path);\nstatic bool wait_for_partition(const char *path);\n\nstatic void nbd_detach(const char *path)\n{\n\tint ret;\n\tpid_t pid = fork();\n\n\tif (pid < 0) {\n\t\tSYSERROR(\"Error forking to detach nbd\");\n\t\treturn;\n\t}\n\tif (pid) {\n\t\tret = wait_for_pid(pid);\n\t\tif (ret < 0)\n\t\t\tERROR(\"nbd disconnect returned an error\");\n\t\treturn;\n\t}\n\texeclp(\"qemu-nbd\", \"qemu-nbd\", \"-d\", path, (char *)NULL);\n\tSYSERROR(\"Error executing qemu-nbd\");\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WIFSIGNALED",
          "args": [
            "status"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "-1",
            "&status",
            "WNOHANG"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error reading from signalfd\""
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "sfd",
            "&fdsi",
            "sizeof(struct signalfd_siginfo)"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "962-990",
          "snippet": "int lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error setting parent death signal for nbd watcher\""
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prctl",
          "args": [
            "PR_SET_PDEATHSIG",
            "SIGHUP",
            "0",
            "0",
            "0"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error opening signalfd for nbd task\""
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signalfd",
          "args": [
            "-1",
            "&mask",
            "0"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "signalfd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.h",
          "lines": "155-163",
          "snippet": "static inline int signalfd(int fd, const sigset_t *mask, int flags)\n{\n\tint retval;\n\n\tretval = syscall (__NR_signalfd4, fd, mask, _NSIG / 8, flags);\n\tif (errno == ENOSYS && flags == 0)\n\t\tretval = syscall (__NR_signalfd, fd, mask, _NSIG / 8);\n\treturn retval;\n}",
          "includes": [
            "#include <stdint.h>",
            "#  include <sys/signalfd.h>",
            "#include <../include/getline.h>",
            "#include \"initutils.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#  include <sys/signalfd.h>\n#include <../include/getline.h>\n#include \"initutils.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic inline int signalfd(int fd, const sigset_t *mask, int flags)\n{\n\tint retval;\n\n\tretval = syscall (__NR_signalfd4, fd, mask, _NSIG / 8, flags);\n\tif (errno == ENOSYS && flags == 0)\n\t\tretval = syscall (__NR_signalfd, fd, mask, _NSIG / 8);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error blocking signals for nbd watcher\""
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_BLOCK",
            "&mask",
            "NULL"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&mask",
            "SIGCHLD"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&mask",
            "SIGHUP"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&mask"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcnbd.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/prctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <errno.h>\n\nstatic bool clone_attach_nbd(const char *nbd, const char *path);\nstatic int do_attach_nbd(void *d);\nstatic void nbd_detach(const char *path);\nstatic bool wait_for_partition(const char *path);\n\nstatic int do_attach_nbd(void *d)\n{\n\tstruct nbd_attach_data *data = d;\n\tconst char *nbd, *path;\n\tpid_t pid;\n\tsigset_t mask;\n\tint sfd;\n\tssize_t s;\n\tstruct signalfd_siginfo fdsi;\n\n\tsigemptyset(&mask);\n\tsigaddset(&mask, SIGHUP);\n\tsigaddset(&mask, SIGCHLD);\n\n\tnbd = data->nbd;\n\tpath = data->path;\n\n\tif (sigprocmask(SIG_BLOCK, &mask, NULL) == -1) {\n\t\tSYSERROR(\"Error blocking signals for nbd watcher\");\n\t\texit(1);\n\t}\n\n\tsfd = signalfd(-1, &mask, 0);\n\tif (sfd == -1) {\n\t\tSYSERROR(\"Error opening signalfd for nbd task\");\n\t\texit(1);\n\t}\n\n\tif (prctl(PR_SET_PDEATHSIG, SIGHUP, 0, 0, 0) < 0)\n\t\tSYSERROR(\"Error setting parent death signal for nbd watcher\");\n\n\tpid = fork();\n\tif (pid) {\n\t\tfor (;;) {\n\t\t\ts = read(sfd, &fdsi, sizeof(struct signalfd_siginfo));\n\t\t\tif (s != sizeof(struct signalfd_siginfo))\n\t\t\t\tSYSERROR(\"Error reading from signalfd\");\n\n\t\t\tif (fdsi.ssi_signo == SIGHUP) {\n\t\t\t\t/* container has exited */\n\t\t\t\tnbd_detach(nbd);\n\t\t\t\texit(0);\n\t\t\t} else if (fdsi.ssi_signo == SIGCHLD) {\n\t\t\t\tint status;\n\t\t\t\t/* If qemu-nbd fails, or is killed by a signal,\n\t\t\t\t * then exit */\n\t\t\t\twhile (waitpid(-1, &status, WNOHANG) > 0) {\n\t\t\t\t\tif ((WIFEXITED(status) && WEXITSTATUS(status) != 0) ||\n\t\t\t\t\t\t\tWIFSIGNALED(status)) {\n\t\t\t\t\t\tnbd_detach(nbd);\n\t\t\t\t\t\texit(1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tclose(sfd);\n\tif (sigprocmask(SIG_UNBLOCK, &mask, NULL) == -1)\n\t\tWARN(\"Warning: unblocking signals for nbd watcher\");\n\n\texeclp(\"qemu-nbd\", \"qemu-nbd\", \"-c\", nbd, path, (char *)NULL);\n\tSYSERROR(\"Error executing qemu-nbd\");\n\texit(1);\n}"
  },
  {
    "function_name": "requires_nbd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcnbd.c",
    "lines": "163-168",
    "snippet": "bool requires_nbd(const char *path)\n{\n\tif (strncmp(path, \"nbd:\", 4) == 0)\n\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/prctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdbool.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool clone_attach_nbd(const char *nbd, const char *path);",
      "static void nbd_detach(const char *path);",
      "static bool wait_for_partition(const char *path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "path",
            "\"nbd:\"",
            "4"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcnbd.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/prctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <errno.h>\n\nstatic bool clone_attach_nbd(const char *nbd, const char *path);\nstatic void nbd_detach(const char *path);\nstatic bool wait_for_partition(const char *path);\n\nbool requires_nbd(const char *path)\n{\n\tif (strncmp(path, \"nbd:\", 4) == 0)\n\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "nbd_umount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcnbd.c",
    "lines": "151-161",
    "snippet": "int nbd_umount(struct bdev *bdev)\n{\n\tint ret;\n\n\tif (strcmp(bdev->type, \"nbd\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\tret = umount(bdev->dest);\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/prctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdbool.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nbd_get_partition(const char *src);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "umount",
          "args": [
            "bdev->dest"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "nbd_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcnbd.c",
          "lines": "151-161",
          "snippet": "int nbd_umount(struct bdev *bdev)\n{\n\tint ret;\n\n\tif (strcmp(bdev->type, \"nbd\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\tret = umount(bdev->dest);\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "bdev->type",
            "\"nbd\""
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcnbd.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/prctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <errno.h>\n\nstatic int nbd_get_partition(const char *src);\n\nint nbd_umount(struct bdev *bdev)\n{\n\tint ret;\n\n\tif (strcmp(bdev->type, \"nbd\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\tret = umount(bdev->dest);\n\treturn ret;\n}"
  },
  {
    "function_name": "nbd_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcnbd.c",
    "lines": "115-149",
    "snippet": "int nbd_mount(struct bdev *bdev)\n{\n\tint ret = -1, partition;\n\tchar path[50];\n\n\tif (strcmp(bdev->type, \"nbd\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\n\t/* nbd_idx should have been copied by bdev_init from the lxc_conf */\n\tif (bdev->nbd_idx < 0)\n\t\treturn -22;\n\tpartition = nbd_get_partition(bdev->src);\n\tif (partition)\n\t\tret = snprintf(path, 50, \"/dev/nbd%dp%d\", bdev->nbd_idx,\n\t\t\t\tpartition);\n\telse\n\t\tret = snprintf(path, 50, \"/dev/nbd%d\", bdev->nbd_idx);\n\tif (ret < 0 || ret >= 50) {\n\t\tERROR(\"Error setting up nbd device path\");\n\t\treturn ret;\n\t}\n\n\t/* It might take awhile for the partition files to show up */\n\tif (partition) {\n\t\tif (!wait_for_partition(path))\n\t\t\treturn -2;\n\t}\n\tret = mount_unknown_fs(path, bdev->dest, bdev->mntopts);\n\tif (ret < 0)\n\t\tERROR(\"Error mounting %s\", bdev->src);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/prctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdbool.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool clone_attach_nbd(const char *nbd, const char *path);",
      "static int do_attach_nbd(void *d);",
      "static void nbd_detach(const char *path);",
      "static int nbd_get_partition(const char *src);",
      "static bool wait_for_partition(const char *path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error mounting %s\"",
            "bdev->src"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount_unknown_fs",
          "args": [
            "path",
            "bdev->dest",
            "bdev->mntopts"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "mount_unknown_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "739-782",
          "snippet": "int mount_unknown_fs(const char *rootfs, const char *target,\n\t\tconst char *options)\n{\n\tstruct cbarg {\n\t\tconst char *rootfs;\n\t\tconst char *target;\n\t\tconst char *options;\n\t} cbarg = {\n\t\t.rootfs = rootfs,\n\t\t.target = target,\n\t\t.options = options,\n\t};\n\n\t/*\n\t * find the filesystem type with brute force:\n\t * first we check with /etc/filesystems, in case the modules\n\t * are auto-loaded and fall back to the supported kernel fs\n\t */\n\tchar *fsfile[] = {\n\t\t\"/etc/filesystems\",\n\t\t\"/proc/filesystems\",\n\t};\n\n\tsize_t i;\n\tfor (i = 0; i < sizeof(fsfile) / sizeof(fsfile[0]); i++) {\n\n\t\tint ret;\n\n\t\tif (access(fsfile[i], F_OK))\n\t\t\tcontinue;\n\n\t\tret = lxc_file_for_each_line(fsfile[i], find_fstype_cb, &cbarg);\n\t\tif (ret < 0) {\n\t\t\tERROR(\"failed to parse '%s'\", fsfile[i]);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (ret)\n\t\t\treturn 0;\n\t}\n\n\tERROR(\"failed to determine fs type for '%s'\", rootfs);\n\treturn -1;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bdev *bdev_get(const char *type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic struct bdev *bdev_get(const char *type);\n\nint mount_unknown_fs(const char *rootfs, const char *target,\n\t\tconst char *options)\n{\n\tstruct cbarg {\n\t\tconst char *rootfs;\n\t\tconst char *target;\n\t\tconst char *options;\n\t} cbarg = {\n\t\t.rootfs = rootfs,\n\t\t.target = target,\n\t\t.options = options,\n\t};\n\n\t/*\n\t * find the filesystem type with brute force:\n\t * first we check with /etc/filesystems, in case the modules\n\t * are auto-loaded and fall back to the supported kernel fs\n\t */\n\tchar *fsfile[] = {\n\t\t\"/etc/filesystems\",\n\t\t\"/proc/filesystems\",\n\t};\n\n\tsize_t i;\n\tfor (i = 0; i < sizeof(fsfile) / sizeof(fsfile[0]); i++) {\n\n\t\tint ret;\n\n\t\tif (access(fsfile[i], F_OK))\n\t\t\tcontinue;\n\n\t\tret = lxc_file_for_each_line(fsfile[i], find_fstype_cb, &cbarg);\n\t\tif (ret < 0) {\n\t\t\tERROR(\"failed to parse '%s'\", fsfile[i]);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (ret)\n\t\t\treturn 0;\n\t}\n\n\tERROR(\"failed to determine fs type for '%s'\", rootfs);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_partition",
          "args": [
            "path"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_partition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcnbd.c",
          "lines": "300-311",
          "snippet": "static bool wait_for_partition(const char *path)\n{\n\tint count = 0;\n\twhile (count < 5) {\n\t\tif (file_exists(path))\n\t\t\treturn true;\n\t\tsleep(1);\n\t\tcount++;\n\t}\n\tERROR(\"Device %s did not show up after 5 seconds\", path);\n\treturn false;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/prctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdbool.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool clone_attach_nbd(const char *nbd, const char *path);",
            "static void nbd_detach(const char *path);",
            "static bool wait_for_partition(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcnbd.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/prctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <errno.h>\n\nstatic bool clone_attach_nbd(const char *nbd, const char *path);\nstatic void nbd_detach(const char *path);\nstatic bool wait_for_partition(const char *path);\n\nstatic bool wait_for_partition(const char *path)\n{\n\tint count = 0;\n\twhile (count < 5) {\n\t\tif (file_exists(path))\n\t\t\treturn true;\n\t\tsleep(1);\n\t\tcount++;\n\t}\n\tERROR(\"Device %s did not show up after 5 seconds\", path);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error setting up nbd device path\""
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "50",
            "\"/dev/nbd%d\"",
            "bdev->nbd_idx"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "50",
            "\"/dev/nbd%dp%d\"",
            "bdev->nbd_idx",
            "partition"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nbd_get_partition",
          "args": [
            "bdev->src"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "nbd_get_partition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcnbd.c",
          "lines": "286-298",
          "snippet": "static int nbd_get_partition(const char *src)\n{\n\tchar *p = strchr(src, ':');\n\tif (!p)\n\t\treturn 0;\n\tp = strchr(p+1, ':');\n\tif (!p)\n\t\treturn 0;\n\tp++;\n\tif (*p < '1' || *p > '9')\n\t\treturn 0;\n\treturn *p - '0';\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/prctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdbool.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nbd_get_partition(const char *src);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcnbd.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/prctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <errno.h>\n\nstatic int nbd_get_partition(const char *src);\n\nstatic int nbd_get_partition(const char *src)\n{\n\tchar *p = strchr(src, ':');\n\tif (!p)\n\t\treturn 0;\n\tp = strchr(p+1, ':');\n\tif (!p)\n\t\treturn 0;\n\tp++;\n\tif (*p < '1' || *p > '9')\n\t\treturn 0;\n\treturn *p - '0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "bdev->type",
            "\"nbd\""
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcnbd.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/prctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <errno.h>\n\nstatic bool clone_attach_nbd(const char *nbd, const char *path);\nstatic int do_attach_nbd(void *d);\nstatic void nbd_detach(const char *path);\nstatic int nbd_get_partition(const char *src);\nstatic bool wait_for_partition(const char *path);\n\nint nbd_mount(struct bdev *bdev)\n{\n\tint ret = -1, partition;\n\tchar path[50];\n\n\tif (strcmp(bdev->type, \"nbd\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\n\t/* nbd_idx should have been copied by bdev_init from the lxc_conf */\n\tif (bdev->nbd_idx < 0)\n\t\treturn -22;\n\tpartition = nbd_get_partition(bdev->src);\n\tif (partition)\n\t\tret = snprintf(path, 50, \"/dev/nbd%dp%d\", bdev->nbd_idx,\n\t\t\t\tpartition);\n\telse\n\t\tret = snprintf(path, 50, \"/dev/nbd%d\", bdev->nbd_idx);\n\tif (ret < 0 || ret >= 50) {\n\t\tERROR(\"Error setting up nbd device path\");\n\t\treturn ret;\n\t}\n\n\t/* It might take awhile for the partition files to show up */\n\tif (partition) {\n\t\tif (!wait_for_partition(path))\n\t\t\treturn -2;\n\t}\n\tret = mount_unknown_fs(path, bdev->dest, bdev->mntopts);\n\tif (ret < 0)\n\t\tERROR(\"Error mounting %s\", bdev->src);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "nbd_detect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcnbd.c",
    "lines": "108-113",
    "snippet": "int nbd_detect(const char *path)\n{\n\tif (strncmp(path, \"nbd:\", 4) == 0)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/prctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdbool.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool clone_attach_nbd(const char *nbd, const char *path);",
      "static void nbd_detach(const char *path);",
      "static bool wait_for_partition(const char *path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "path",
            "\"nbd:\"",
            "4"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcnbd.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/prctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <errno.h>\n\nstatic bool clone_attach_nbd(const char *nbd, const char *path);\nstatic void nbd_detach(const char *path);\nstatic bool wait_for_partition(const char *path);\n\nint nbd_detect(const char *path)\n{\n\tif (strncmp(path, \"nbd:\", 4) == 0)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "nbd_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcnbd.c",
    "lines": "103-106",
    "snippet": "int nbd_destroy(struct bdev *orig)\n{\n\treturn -ENOSYS;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/prctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdbool.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcnbd.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/prctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <errno.h>\n\nint nbd_destroy(struct bdev *orig)\n{\n\treturn -ENOSYS;\n}"
  },
  {
    "function_name": "nbd_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcnbd.c",
    "lines": "97-101",
    "snippet": "int nbd_create(struct bdev *bdev, const char *dest, const char *n,\n\t\tstruct bdev_specs *specs)\n{\n\treturn -ENOSYS;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/prctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdbool.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcnbd.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/prctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <errno.h>\n\nint nbd_create(struct bdev *bdev, const char *dest, const char *n,\n\t\tstruct bdev_specs *specs)\n{\n\treturn -ENOSYS;\n}"
  },
  {
    "function_name": "nbd_clonepaths",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcnbd.c",
    "lines": "90-95",
    "snippet": "int nbd_clonepaths(struct bdev *orig, struct bdev *new, const char *oldname,\n\t\tconst char *cname, const char *oldpath, const char *lxcpath,\n\t\tint snap, uint64_t newsize, struct lxc_conf *conf)\n{\n\treturn -ENOSYS;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/prctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdbool.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcnbd.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/prctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <errno.h>\n\nint nbd_clonepaths(struct bdev *orig, struct bdev *new, const char *oldname,\n\t\tconst char *cname, const char *oldpath, const char *lxcpath,\n\t\tint snap, uint64_t newsize, struct lxc_conf *conf)\n{\n\treturn -ENOSYS;\n}"
  },
  {
    "function_name": "detach_nbd_idx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcnbd.c",
    "lines": "78-88",
    "snippet": "void detach_nbd_idx(int idx)\n{\n\tint ret;\n\tchar path[50];\n\n\tret = snprintf(path, 50, \"/dev/nbd%d\", idx);\n\tif (ret < 0 || ret >= 50)\n\t\treturn;\n\n\tnbd_detach(path);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/prctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdbool.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool clone_attach_nbd(const char *nbd, const char *path);",
      "static int do_attach_nbd(void *d);",
      "static bool nbd_busy(int idx);",
      "static void nbd_detach(const char *path);",
      "static bool wait_for_partition(const char *path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nbd_detach",
          "args": [
            "path"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "nbd_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcnbd.c",
          "lines": "261-279",
          "snippet": "static void nbd_detach(const char *path)\n{\n\tint ret;\n\tpid_t pid = fork();\n\n\tif (pid < 0) {\n\t\tSYSERROR(\"Error forking to detach nbd\");\n\t\treturn;\n\t}\n\tif (pid) {\n\t\tret = wait_for_pid(pid);\n\t\tif (ret < 0)\n\t\t\tERROR(\"nbd disconnect returned an error\");\n\t\treturn;\n\t}\n\texeclp(\"qemu-nbd\", \"qemu-nbd\", \"-d\", path, (char *)NULL);\n\tSYSERROR(\"Error executing qemu-nbd\");\n\texit(1);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/prctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdbool.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool clone_attach_nbd(const char *nbd, const char *path);",
            "static int do_attach_nbd(void *d);",
            "static void nbd_detach(const char *path);",
            "static bool wait_for_partition(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcnbd.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/prctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <errno.h>\n\nstatic bool clone_attach_nbd(const char *nbd, const char *path);\nstatic int do_attach_nbd(void *d);\nstatic void nbd_detach(const char *path);\nstatic bool wait_for_partition(const char *path);\n\nstatic void nbd_detach(const char *path)\n{\n\tint ret;\n\tpid_t pid = fork();\n\n\tif (pid < 0) {\n\t\tSYSERROR(\"Error forking to detach nbd\");\n\t\treturn;\n\t}\n\tif (pid) {\n\t\tret = wait_for_pid(pid);\n\t\tif (ret < 0)\n\t\t\tERROR(\"nbd disconnect returned an error\");\n\t\treturn;\n\t}\n\texeclp(\"qemu-nbd\", \"qemu-nbd\", \"-d\", path, (char *)NULL);\n\tSYSERROR(\"Error executing qemu-nbd\");\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "50",
            "\"/dev/nbd%d\"",
            "idx"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcnbd.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/prctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <errno.h>\n\nstatic bool clone_attach_nbd(const char *nbd, const char *path);\nstatic int do_attach_nbd(void *d);\nstatic bool nbd_busy(int idx);\nstatic void nbd_detach(const char *path);\nstatic bool wait_for_partition(const char *path);\n\nvoid detach_nbd_idx(int idx)\n{\n\tint ret;\n\tchar path[50];\n\n\tret = snprintf(path, 50, \"/dev/nbd%d\", idx);\n\tif (ret < 0 || ret >= 50)\n\t\treturn;\n\n\tnbd_detach(path);\n}"
  },
  {
    "function_name": "attach_nbd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcnbd.c",
    "lines": "53-76",
    "snippet": "bool attach_nbd(char *src, struct lxc_conf *conf)\n{\n\tchar *orig = alloca(strlen(src)+1), *p, path[50];\n\tint i = 0;\n\n\tstrcpy(orig, src);\n\t/* if path is followed by a partition, drop that for now */\n\tp = strchr(orig, ':');\n\tif (p)\n\t\t*p = '\\0';\n\twhile (1) {\n\t\tsprintf(path, \"/dev/nbd%d\", i);\n\t\tif (!file_exists(path))\n\t\t\treturn false;\n\t\tif (nbd_busy(i)) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!clone_attach_nbd(path, orig))\n\t\t\treturn false;\n\t\tconf->nbd_idx = i;\n\t\treturn true;\n\t}\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/prctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdbool.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool clone_attach_nbd(const char *nbd, const char *path);",
      "static int do_attach_nbd(void *d);",
      "static void nbd_detach(const char *path);",
      "static int nbd_get_partition(const char *src);",
      "static bool wait_for_partition(const char *path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clone_attach_nbd",
          "args": [
            "path",
            "orig"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "clone_attach_nbd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcnbd.c",
          "lines": "236-248",
          "snippet": "static bool clone_attach_nbd(const char *nbd, const char *path)\n{\n\tpid_t pid;\n\tstruct nbd_attach_data data;\n\n\tdata.nbd = nbd;\n\tdata.path = path;\n\n\tpid = lxc_clone(do_attach_nbd, &data, CLONE_NEWPID);\n\tif (pid < 0)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/prctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdbool.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool clone_attach_nbd(const char *nbd, const char *path);",
            "static void nbd_detach(const char *path);",
            "static bool wait_for_partition(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcnbd.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/prctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <errno.h>\n\nstatic bool clone_attach_nbd(const char *nbd, const char *path);\nstatic void nbd_detach(const char *path);\nstatic bool wait_for_partition(const char *path);\n\nstatic bool clone_attach_nbd(const char *nbd, const char *path)\n{\n\tpid_t pid;\n\tstruct nbd_attach_data data;\n\n\tdata.nbd = nbd;\n\tdata.path = path;\n\n\tpid = lxc_clone(do_attach_nbd, &data, CLONE_NEWPID);\n\tif (pid < 0)\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nbd_busy",
          "args": [
            "i"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "nbd_busy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcnbd.c",
          "lines": "250-259",
          "snippet": "static bool nbd_busy(int idx)\n{\n\tchar path[100];\n\tint ret;\n\n\tret = snprintf(path, 100, \"/sys/block/nbd%d/pid\", idx);\n\tif (ret < 0 || ret >= 100)\n\t\treturn true;\n\treturn file_exists(path);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/prctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdbool.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool clone_attach_nbd(const char *nbd, const char *path);",
            "static int do_attach_nbd(void *d);",
            "static bool nbd_busy(int idx);",
            "static void nbd_detach(const char *path);",
            "static bool wait_for_partition(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcnbd.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/prctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <errno.h>\n\nstatic bool clone_attach_nbd(const char *nbd, const char *path);\nstatic int do_attach_nbd(void *d);\nstatic bool nbd_busy(int idx);\nstatic void nbd_detach(const char *path);\nstatic bool wait_for_partition(const char *path);\n\nstatic bool nbd_busy(int idx)\n{\n\tchar path[100];\n\tint ret;\n\n\tret = snprintf(path, 100, \"/sys/block/nbd%d/pid\", idx);\n\tif (ret < 0 || ret >= 100)\n\t\treturn true;\n\treturn file_exists(path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_exists",
          "args": [
            "path"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "file_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1240-1245",
          "snippet": "bool file_exists(const char *f)\n{\n\tstruct stat statbuf;\n\n\treturn stat(f, &statbuf) == 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool file_exists(const char *f)\n{\n\tstruct stat statbuf;\n\n\treturn stat(f, &statbuf) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "path",
            "\"/dev/nbd%d\"",
            "i"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "orig",
            "':'"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "orig",
            "src"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "strlen(src)+1"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "src"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcnbd.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/prctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <errno.h>\n\nstatic bool clone_attach_nbd(const char *nbd, const char *path);\nstatic int do_attach_nbd(void *d);\nstatic void nbd_detach(const char *path);\nstatic int nbd_get_partition(const char *src);\nstatic bool wait_for_partition(const char *path);\n\nbool attach_nbd(char *src, struct lxc_conf *conf)\n{\n\tchar *orig = alloca(strlen(src)+1), *p, path[50];\n\tint i = 0;\n\n\tstrcpy(orig, src);\n\t/* if path is followed by a partition, drop that for now */\n\tp = strchr(orig, ':');\n\tif (p)\n\t\t*p = '\\0';\n\twhile (1) {\n\t\tsprintf(path, \"/dev/nbd%d\", i);\n\t\tif (!file_exists(path))\n\t\t\treturn false;\n\t\tif (nbd_busy(i)) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!clone_attach_nbd(path, orig))\n\t\t\treturn false;\n\t\tconf->nbd_idx = i;\n\t\treturn true;\n\t}\n}"
  }
]