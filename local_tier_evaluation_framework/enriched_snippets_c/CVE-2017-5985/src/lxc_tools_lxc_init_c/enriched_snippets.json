[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_init.c",
    "lines": "77-261",
    "snippet": "int main(int argc, char *argv[])\n{\n\tpid_t pid;\n\tint err;\n\tchar **aargv;\n\tsigset_t mask, omask;\n\tint i, have_status = 0, shutdown = 0;\n\tint opt;\n\tchar *lxcpath = NULL, *name = NULL, *logpriority = NULL;\n\n\twhile ((opt = getopt_long(argc, argv, \"n:l:qP:\", options, NULL)) != -1) {\n\t\tswitch(opt) {\n\t\tcase 'n':\n\t\t\tname = optarg;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlogpriority = optarg;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tquiet = 1;\n \t\t\tbreak;\n\t\tcase 'P':\n\t\t\tlxcpath = optarg;\n\t\t\tbreak;\n\t\tdefault: /* '?' */\n\t\t\tusage();\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\terr = lxc_log_init(name, name ? NULL : \"none\", logpriority,\n\t\t\t   basename(argv[0]), quiet, lxcpath);\n\tif (err < 0)\n\t\texit(EXIT_FAILURE);\n\tlxc_log_options_no_override();\n\n\tif (!argv[optind]) {\n\t\tERROR(\"missing command to launch\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\taargv = &argv[optind];\n\n\t/*\n\t * mask all the signals so we are safe to install a\n\t * signal handler and to fork\n\t */\n\tif (sigfillset(&mask) ||\n\t    sigdelset(&mask, SIGILL) ||\n\t    sigdelset(&mask, SIGSEGV) ||\n\t    sigdelset(&mask, SIGBUS) ||\n\t    sigprocmask(SIG_SETMASK, &mask, &omask)) {\n\t\tSYSERROR(\"failed to set signal mask\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tfor (i = 1; i < NSIG; i++) {\n\t\tstruct sigaction act;\n\n\t\t/* Exclude some signals: ILL, SEGV and BUS are likely to\n\t\t * reveal a bug and we want a core. STOP and KILL cannot be\n\t\t * handled anyway: they're here for documentation.\n\t\t */\n\t\tif (i == SIGILL ||\n\t\t    i == SIGSEGV ||\n\t\t    i == SIGBUS ||\n\t\t    i == SIGSTOP ||\n\t\t    i == SIGKILL ||\n\t\t    i == 32 || i == 33)\n\t\t\tcontinue;\n\n\t\tif (sigfillset(&act.sa_mask) ||\n\t\t    sigdelset(&act.sa_mask, SIGILL) ||\n\t\t    sigdelset(&act.sa_mask, SIGSEGV) ||\n\t\t    sigdelset(&act.sa_mask, SIGBUS) ||\n\t\t    sigdelset(&act.sa_mask, SIGSTOP) ||\n\t\t    sigdelset(&act.sa_mask, SIGKILL)) {\n\t\t\tERROR(\"failed to set signal\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tact.sa_flags = 0;\n\t\tact.sa_handler = interrupt_handler;\n\t\tif (sigaction(i, &act, NULL) && errno != EINVAL) {\n\t\t\tSYSERROR(\"failed to sigaction\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tlxc_setup_fs();\n\n\tpid = fork();\n\n\tif (pid < 0)\n\t\texit(EXIT_FAILURE);\n\n\tif (!pid) {\n\n\t\t/* restore default signal handlers */\n\t\tfor (i = 1; i < NSIG; i++)\n\t\t\tsignal(i, SIG_DFL);\n\n\t\tif (sigprocmask(SIG_SETMASK, &omask, NULL)) {\n\t\t\tSYSERROR(\"failed to set signal mask\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tNOTICE(\"about to exec '%s'\", aargv[0]);\n\n\t\texecvp(aargv[0], aargv);\n\t\tERROR(\"failed to exec: '%s' : %m\", aargv[0]);\n\t\texit(err);\n\t}\n\n\t/* let's process the signals now */\n\tif (sigdelset(&omask, SIGALRM) ||\n\t    sigprocmask(SIG_SETMASK, &omask, NULL)) {\n\t\tSYSERROR(\"failed to set signal mask\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t/* no need of other inherited fds but stderr */\n\tclose(fileno(stdin));\n\tclose(fileno(stdout));\n\n\terr = EXIT_SUCCESS;\n\tfor (;;) {\n\t\tint status;\n\t\tpid_t waited_pid;\n\n\t\tswitch (was_interrupted) {\n\n\t\tcase 0:\n\t\t\tbreak;\n\n\t\tcase SIGPWR:\n\t\tcase SIGTERM:\n\t\t\tif (!shutdown) {\n\t\t\t\tshutdown = 1;\n\t\t\t\tkill(-1, SIGTERM);\n\t\t\t\talarm(1);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SIGALRM:\n\t\t\tkill(-1, SIGKILL);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tkill(pid, was_interrupted);\n\t\t\tbreak;\n\t\t}\n\n\t\twas_interrupted = 0;\n\t\twaited_pid = wait(&status);\n\t\tif (waited_pid < 0) {\n\t\t\tif (errno == ECHILD)\n\t\t\t\tgoto out;\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\n\t\t\tERROR(\"failed to wait child : %s\",\n\t\t\t      strerror(errno));\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* reset timer each time a process exited */\n\t\tif (shutdown)\n\t\t\talarm(1);\n\n\t\t/*\n\t\t * keep the exit code of started application\n\t\t * (not wrapped pid) and continue to wait for\n\t\t * the end of the orphan group.\n\t\t */\n\t\tif (waited_pid == pid && !have_status) {\n\t\t\terr = lxc_error_set_and_log(waited_pid, status);\n\t\t\thave_status = 1;\n\t\t}\n\t}\nout:\n\tif (err < 0)\n\t\texit(EXIT_FAILURE);\n\texit(err);\n}",
    "includes": [
      "#include \"initutils.h\"",
      "#include \"error.h\"",
      "#include \"caps.h\"",
      "#include \"log.h\"",
      "#include <getopt.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <libgen.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int quiet;",
      "static const struct option options[] = {\n\t{ \"name\",        required_argument, NULL, 'n' },\n\t{ \"logpriority\", required_argument, NULL, 'l' },\n\t{ \"quiet\",       no_argument,       NULL, 'q' },\n\t{ \"lxcpath\",     required_argument, NULL, 'P' },\n\t{ 0, 0, 0, 0 },\n};",
      "static sig_atomic_t was_interrupted = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "err"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_error_set_and_log",
          "args": [
            "waited_pid",
            "status"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_error_set_and_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/error.c",
          "lines": "42-58",
          "snippet": "extern int  lxc_error_set_and_log(int pid, int status)\n{\n\tint ret = 0;\n\n\tif (WIFEXITED(status)) {\n\t\tret = WEXITSTATUS(status);\n\t\tif (ret)\n\t\t\tINFO(\"Child <%d> ended on error (%d).\", pid, ret);\n\t}\n\n\tif (WIFSIGNALED(status)) {\n\t\tint signal = WTERMSIG(status);\n\t\tINFO(\"Child <%d> ended on signal (%d).\", pid, signal);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"error.h\"\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nextern int  lxc_error_set_and_log(int pid, int status)\n{\n\tint ret = 0;\n\n\tif (WIFEXITED(status)) {\n\t\tret = WEXITSTATUS(status);\n\t\tif (ret)\n\t\t\tINFO(\"Child <%d> ended on error (%d).\", pid, ret);\n\t}\n\n\tif (WIFSIGNALED(status)) {\n\t\tint signal = WTERMSIG(status);\n\t\tINFO(\"Child <%d> ended on signal (%d).\", pid, signal);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alarm",
          "args": [
            "1"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to wait child : %s\"",
            "strerror(errno)"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait",
          "args": [
            "&status"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "67-81",
          "snippet": "static int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "pid",
            "was_interrupted"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "-1",
            "SIGKILL"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alarm",
          "args": [
            "1"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "-1",
            "SIGTERM"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fileno(stdout)"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stdout"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stdin"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to set signal mask\""
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_SETMASK",
            "&omask",
            "NULL"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelset",
          "args": [
            "&omask",
            "SIGALRM"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "err"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to exec: '%s' : %m\"",
            "aargv[0]"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "aargv[0]",
            "aargv"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NOTICE",
          "args": [
            "\"about to exec '%s'\"",
            "aargv[0]"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to set signal mask\""
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_SETMASK",
            "&omask",
            "NULL"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "i",
            "SIG_DFL"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "task_blocking_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1893-1925",
          "snippet": "bool task_blocking_signal(pid_t pid, int signal)\n{\n\tbool bret = false;\n\tchar *line = NULL;\n\tlong unsigned int sigblk = 0;\n\tsize_t n = 0;\n\tint ret;\n\tFILE *f;\n\n\tchar status[__PROC_STATUS_LEN];\n\n\tret = snprintf(status, __PROC_STATUS_LEN, \"/proc/%d/status\", pid);\n\tif (ret < 0 || ret >= __PROC_STATUS_LEN)\n\t\treturn bret;\n\n\tf = fopen(status, \"r\");\n\tif (!f)\n\t\treturn bret;\n\n\twhile (getline(&line, &n, f) != -1) {\n\t\tif (!strncmp(line, \"SigBlk:\\t\", 8))\n\t\t\tif (sscanf(line + 8, \"%lx\", &sigblk) != 1)\n\t\t\t\tgoto out;\n\t}\n\n\tif (sigblk & signal)\n\t\tbret = true;\n\nout:\n\tfree(line);\n\tfclose(f);\n\treturn bret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define __PROC_STATUS_LEN (5 + (LXC_NUMSTRLEN64) + 7 + 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\n#define __PROC_STATUS_LEN (5 + (LXC_NUMSTRLEN64) + 7 + 1)\n\nbool task_blocking_signal(pid_t pid, int signal)\n{\n\tbool bret = false;\n\tchar *line = NULL;\n\tlong unsigned int sigblk = 0;\n\tsize_t n = 0;\n\tint ret;\n\tFILE *f;\n\n\tchar status[__PROC_STATUS_LEN];\n\n\tret = snprintf(status, __PROC_STATUS_LEN, \"/proc/%d/status\", pid);\n\tif (ret < 0 || ret >= __PROC_STATUS_LEN)\n\t\treturn bret;\n\n\tf = fopen(status, \"r\");\n\tif (!f)\n\t\treturn bret;\n\n\twhile (getline(&line, &n, f) != -1) {\n\t\tif (!strncmp(line, \"SigBlk:\\t\", 8))\n\t\t\tif (sscanf(line + 8, \"%lx\", &sigblk) != 1)\n\t\t\t\tgoto out;\n\t}\n\n\tif (sigblk & signal)\n\t\tbret = true;\n\nout:\n\tfree(line);\n\tfclose(f);\n\treturn bret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_setup_fs",
          "args": [],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_setup_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "45-68",
          "snippet": "extern void lxc_setup_fs(void)\n{\n\tif (mount_fs(\"proc\", \"/proc\", \"proc\"))\n\t\tINFO(\"failed to remount proc\");\n\n\t/* if /dev has been populated by us, /dev/shm does not exist */\n\tif (access(\"/dev/shm\", F_OK) && mkdir(\"/dev/shm\", 0777))\n\t\tINFO(\"failed to create /dev/shm\");\n\n\t/* if we can't mount /dev/shm, continue anyway */\n\tif (mount_fs(\"shmfs\", \"/dev/shm\", \"tmpfs\"))\n\t\tINFO(\"failed to mount /dev/shm\");\n\n\t/* If we were able to mount /dev/shm, then /dev exists */\n\t/* Sure, but it's read-only per config :) */\n\tif (access(\"/dev/mqueue\", F_OK) && mkdir(\"/dev/mqueue\", 0666)) {\n\t\tDEBUG(\"failed to create '/dev/mqueue'\");\n\t\treturn;\n\t}\n\n\t/* continue even without posix message queue support */\n\tif (mount_fs(\"mqueue\", \"/dev/mqueue\", \"mqueue\"))\n\t\tINFO(\"failed to mount /dev/mqueue\");\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nextern void lxc_setup_fs(void)\n{\n\tif (mount_fs(\"proc\", \"/proc\", \"proc\"))\n\t\tINFO(\"failed to remount proc\");\n\n\t/* if /dev has been populated by us, /dev/shm does not exist */\n\tif (access(\"/dev/shm\", F_OK) && mkdir(\"/dev/shm\", 0777))\n\t\tINFO(\"failed to create /dev/shm\");\n\n\t/* if we can't mount /dev/shm, continue anyway */\n\tif (mount_fs(\"shmfs\", \"/dev/shm\", \"tmpfs\"))\n\t\tINFO(\"failed to mount /dev/shm\");\n\n\t/* If we were able to mount /dev/shm, then /dev exists */\n\t/* Sure, but it's read-only per config :) */\n\tif (access(\"/dev/mqueue\", F_OK) && mkdir(\"/dev/mqueue\", 0666)) {\n\t\tDEBUG(\"failed to create '/dev/mqueue'\");\n\t\treturn;\n\t}\n\n\t/* continue even without posix message queue support */\n\tif (mount_fs(\"mqueue\", \"/dev/mqueue\", \"mqueue\"))\n\t\tINFO(\"failed to mount /dev/mqueue\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to sigaction\""
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "i",
            "&act",
            "NULL"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to set signal\""
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelset",
          "args": [
            "&act.sa_mask",
            "SIGKILL"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelset",
          "args": [
            "&act.sa_mask",
            "SIGSTOP"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelset",
          "args": [
            "&act.sa_mask",
            "SIGBUS"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelset",
          "args": [
            "&act.sa_mask",
            "SIGSEGV"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelset",
          "args": [
            "&act.sa_mask",
            "SIGILL"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigfillset",
          "args": [
            "&act.sa_mask"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to set signal mask\""
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_SETMASK",
            "&mask",
            "&omask"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelset",
          "args": [
            "&mask",
            "SIGBUS"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelset",
          "args": [
            "&mask",
            "SIGSEGV"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelset",
          "args": [
            "&mask",
            "SIGILL"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigfillset",
          "args": [
            "&mask"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"missing command to launch\""
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_log_options_no_override",
          "args": [],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_log_options_no_override",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
          "lines": "685-689",
          "snippet": "extern void lxc_log_options_no_override()\n{\n\tlxc_quiet_specified = 1;\n\tlxc_loglevel_specified = 1;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"caps.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <pthread.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int lxc_quiet_specified;",
            "static int lxc_loglevel_specified;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nint lxc_quiet_specified;\nstatic int lxc_loglevel_specified;\n\nextern void lxc_log_options_no_override()\n{\n\tlxc_quiet_specified = 1;\n\tlxc_loglevel_specified = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_log_init",
          "args": [
            "name",
            "name ? NULL : \"none\"",
            "logpriority",
            "basename(argv[0])",
            "quiet",
            "lxcpath"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_log_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
          "lines": "546-615",
          "snippet": "extern int lxc_log_init(const char *name, const char *file,\n\t\t\tconst char *priority, const char *prefix, int quiet,\n\t\t\tconst char *lxcpath)\n{\n\tint lxc_priority = LXC_LOG_PRIORITY_ERROR;\n\tint ret;\n\n\tif (lxc_log_fd != -1) {\n\t\tWARN(\"lxc_log_init called with log already initialized\");\n\t\treturn 0;\n\t}\n\n\tif (priority)\n\t\tlxc_priority = lxc_log_priority_to_int(priority);\n\n\tif (!lxc_loglevel_specified) {\n\t\tlxc_log_category_lxc.priority = lxc_priority;\n\t\tlxc_loglevel_specified = 1;\n\t}\n\n\tif (!lxc_quiet_specified) {\n\t\tif (!quiet)\n\t\t\tlxc_log_category_lxc.appender->next = &log_appender_stderr;\n\t}\n\n\tif (prefix)\n\t\tlxc_log_set_prefix(prefix);\n\n\tif (name)\n\t\tlog_vmname = strdup(name);\n\n\tif (file) {\n\t\tif (strcmp(file, \"none\") == 0)\n\t\t\treturn 0;\n\t\tret = __lxc_log_set_file(file, 1);\n\t\tlxc_log_use_global_fd = 1;\n\t} else {\n\t\t/* if no name was specified, there nothing to do */\n\t\tif (!name)\n\t\t\treturn 0;\n\n\t\tret = -1;\n\n\t\tif (!lxcpath)\n\t\t\tlxcpath = LOGPATH;\n\n\t\t/* try LOGPATH if lxcpath is the default for the privileged containers */\n\t\tif (!geteuid() && strcmp(LXCPATH, lxcpath) == 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\n\t\t/* try in lxcpath */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, lxcpath, 1);\n\n\t\t/* try LOGPATH in case its writable by the caller */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\t}\n\n\t/*\n\t * If !file, that is, if the user did not request this logpath, then\n\t * ignore failures and continue logging to console\n\t */\n\tif (!file && ret != 0) {\n\t\tINFO(\"Ignoring failure to open default logfile.\");\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"caps.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <pthread.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int lxc_log_fd = -1;",
            "int lxc_quiet_specified;",
            "int lxc_log_use_global_fd;",
            "static int lxc_loglevel_specified;",
            "static char *log_vmname = NULL;",
            "static struct lxc_log_appender log_appender_stderr = {\n\t.name\t\t= \"stderr\",\n\t.append\t\t= log_append_stderr,\n\t.next\t\t= NULL,\n};",
            "struct lxc_log_category lxc_log_category_lxc = {\n\t.name\t\t= \"lxc\",\n\t.priority\t= LXC_LOG_PRIORITY_ERROR,\n\t.appender\t= &log_appender_logfile,\n\t.parent\t\t= &log_root\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nint lxc_log_fd = -1;\nint lxc_quiet_specified;\nint lxc_log_use_global_fd;\nstatic int lxc_loglevel_specified;\nstatic char *log_vmname = NULL;\nstatic struct lxc_log_appender log_appender_stderr = {\n\t.name\t\t= \"stderr\",\n\t.append\t\t= log_append_stderr,\n\t.next\t\t= NULL,\n};\nstruct lxc_log_category lxc_log_category_lxc = {\n\t.name\t\t= \"lxc\",\n\t.priority\t= LXC_LOG_PRIORITY_ERROR,\n\t.appender\t= &log_appender_logfile,\n\t.parent\t\t= &log_root\n};\n\nextern int lxc_log_init(const char *name, const char *file,\n\t\t\tconst char *priority, const char *prefix, int quiet,\n\t\t\tconst char *lxcpath)\n{\n\tint lxc_priority = LXC_LOG_PRIORITY_ERROR;\n\tint ret;\n\n\tif (lxc_log_fd != -1) {\n\t\tWARN(\"lxc_log_init called with log already initialized\");\n\t\treturn 0;\n\t}\n\n\tif (priority)\n\t\tlxc_priority = lxc_log_priority_to_int(priority);\n\n\tif (!lxc_loglevel_specified) {\n\t\tlxc_log_category_lxc.priority = lxc_priority;\n\t\tlxc_loglevel_specified = 1;\n\t}\n\n\tif (!lxc_quiet_specified) {\n\t\tif (!quiet)\n\t\t\tlxc_log_category_lxc.appender->next = &log_appender_stderr;\n\t}\n\n\tif (prefix)\n\t\tlxc_log_set_prefix(prefix);\n\n\tif (name)\n\t\tlog_vmname = strdup(name);\n\n\tif (file) {\n\t\tif (strcmp(file, \"none\") == 0)\n\t\t\treturn 0;\n\t\tret = __lxc_log_set_file(file, 1);\n\t\tlxc_log_use_global_fd = 1;\n\t} else {\n\t\t/* if no name was specified, there nothing to do */\n\t\tif (!name)\n\t\t\treturn 0;\n\n\t\tret = -1;\n\n\t\tif (!lxcpath)\n\t\t\tlxcpath = LOGPATH;\n\n\t\t/* try LOGPATH if lxcpath is the default for the privileged containers */\n\t\tif (!geteuid() && strcmp(LXCPATH, lxcpath) == 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\n\t\t/* try in lxcpath */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, lxcpath, 1);\n\n\t\t/* try LOGPATH in case its writable by the caller */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\t}\n\n\t/*\n\t * If !file, that is, if the user did not request this logpath, then\n\t * ignore failures and continue logging to console\n\t */\n\tif (!file && ret != 0) {\n\t\tINFO(\"Ignoring failure to open default logfile.\");\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "basename",
          "args": [
            "argv[0]"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "lxcbasename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "1064-1070",
          "snippet": "static char *lxcbasename(char *path)\n{\n\tchar *p = path + strlen(path) - 1;\n\twhile (*p != '/' && p > path)\n\t\tp--;\n\treturn p;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic char *lxcbasename(char *path)\n{\n\tchar *p = path + strlen(path) - 1;\n\twhile (*p != '/' && p > path)\n\t\tp--;\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usage",
          "args": [],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_init.c",
          "lines": "61-75",
          "snippet": "static void usage(void) {\n\tfprintf(stderr, \"Usage: lxc-init [OPTION]...\\n\\n\"\n\t\t\"Common options :\\n\"\n\t\t\"  -n, --name=NAME          NAME of the container\\n\"\n\t\t\"  -l, --logpriority=LEVEL  Set log priority to LEVEL\\n\"\n\t\t\"  -q, --quiet              Don't produce any output\\n\"\n\t\t\"  -P, --lxcpath=PATH       Use specified container path\\n\"\n\t\t\"  -?, --help               Give this help list\\n\"\n\t\t\"\\n\"\n\t\t\"Mandatory or optional arguments to long options are also mandatory or optional\\n\"\n\t\t\"for any corresponding short options.\\n\"\n\t\t\"\\n\"\n\t\t\"NOTE: lxc-init is intended for use by lxc internally\\n\"\n\t\t\"      and does not need to be run by hand\\n\\n\");\n}",
          "includes": [
            "#include \"initutils.h\"",
            "#include \"error.h\"",
            "#include \"caps.h\"",
            "#include \"log.h\"",
            "#include <getopt.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <libgen.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int quiet;",
            "static const struct option options[] = {\n\t{ \"name\",        required_argument, NULL, 'n' },\n\t{ \"logpriority\", required_argument, NULL, 'l' },\n\t{ \"quiet\",       no_argument,       NULL, 'q' },\n\t{ \"lxcpath\",     required_argument, NULL, 'P' },\n\t{ 0, 0, 0, 0 },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initutils.h\"\n#include \"error.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <getopt.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <libgen.h>\n#include <signal.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\nstatic int quiet;\nstatic const struct option options[] = {\n\t{ \"name\",        required_argument, NULL, 'n' },\n\t{ \"logpriority\", required_argument, NULL, 'l' },\n\t{ \"quiet\",       no_argument,       NULL, 'q' },\n\t{ \"lxcpath\",     required_argument, NULL, 'P' },\n\t{ 0, 0, 0, 0 },\n};\n\nstatic void usage(void) {\n\tfprintf(stderr, \"Usage: lxc-init [OPTION]...\\n\\n\"\n\t\t\"Common options :\\n\"\n\t\t\"  -n, --name=NAME          NAME of the container\\n\"\n\t\t\"  -l, --logpriority=LEVEL  Set log priority to LEVEL\\n\"\n\t\t\"  -q, --quiet              Don't produce any output\\n\"\n\t\t\"  -P, --lxcpath=PATH       Use specified container path\\n\"\n\t\t\"  -?, --help               Give this help list\\n\"\n\t\t\"\\n\"\n\t\t\"Mandatory or optional arguments to long options are also mandatory or optional\\n\"\n\t\t\"for any corresponding short options.\\n\"\n\t\t\"\\n\"\n\t\t\"NOTE: lxc-init is intended for use by lxc internally\\n\"\n\t\t\"      and does not need to be run by hand\\n\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "getopt_long",
          "args": [
            "argc",
            "argv",
            "\"n:l:qP:\"",
            "options",
            "NULL"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initutils.h\"\n#include \"error.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <getopt.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <libgen.h>\n#include <signal.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\nstatic int quiet;\nstatic const struct option options[] = {\n\t{ \"name\",        required_argument, NULL, 'n' },\n\t{ \"logpriority\", required_argument, NULL, 'l' },\n\t{ \"quiet\",       no_argument,       NULL, 'q' },\n\t{ \"lxcpath\",     required_argument, NULL, 'P' },\n\t{ 0, 0, 0, 0 },\n};\nstatic sig_atomic_t was_interrupted = 0;\n\nint main(int argc, char *argv[])\n{\n\tpid_t pid;\n\tint err;\n\tchar **aargv;\n\tsigset_t mask, omask;\n\tint i, have_status = 0, shutdown = 0;\n\tint opt;\n\tchar *lxcpath = NULL, *name = NULL, *logpriority = NULL;\n\n\twhile ((opt = getopt_long(argc, argv, \"n:l:qP:\", options, NULL)) != -1) {\n\t\tswitch(opt) {\n\t\tcase 'n':\n\t\t\tname = optarg;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlogpriority = optarg;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tquiet = 1;\n \t\t\tbreak;\n\t\tcase 'P':\n\t\t\tlxcpath = optarg;\n\t\t\tbreak;\n\t\tdefault: /* '?' */\n\t\t\tusage();\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\terr = lxc_log_init(name, name ? NULL : \"none\", logpriority,\n\t\t\t   basename(argv[0]), quiet, lxcpath);\n\tif (err < 0)\n\t\texit(EXIT_FAILURE);\n\tlxc_log_options_no_override();\n\n\tif (!argv[optind]) {\n\t\tERROR(\"missing command to launch\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\taargv = &argv[optind];\n\n\t/*\n\t * mask all the signals so we are safe to install a\n\t * signal handler and to fork\n\t */\n\tif (sigfillset(&mask) ||\n\t    sigdelset(&mask, SIGILL) ||\n\t    sigdelset(&mask, SIGSEGV) ||\n\t    sigdelset(&mask, SIGBUS) ||\n\t    sigprocmask(SIG_SETMASK, &mask, &omask)) {\n\t\tSYSERROR(\"failed to set signal mask\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tfor (i = 1; i < NSIG; i++) {\n\t\tstruct sigaction act;\n\n\t\t/* Exclude some signals: ILL, SEGV and BUS are likely to\n\t\t * reveal a bug and we want a core. STOP and KILL cannot be\n\t\t * handled anyway: they're here for documentation.\n\t\t */\n\t\tif (i == SIGILL ||\n\t\t    i == SIGSEGV ||\n\t\t    i == SIGBUS ||\n\t\t    i == SIGSTOP ||\n\t\t    i == SIGKILL ||\n\t\t    i == 32 || i == 33)\n\t\t\tcontinue;\n\n\t\tif (sigfillset(&act.sa_mask) ||\n\t\t    sigdelset(&act.sa_mask, SIGILL) ||\n\t\t    sigdelset(&act.sa_mask, SIGSEGV) ||\n\t\t    sigdelset(&act.sa_mask, SIGBUS) ||\n\t\t    sigdelset(&act.sa_mask, SIGSTOP) ||\n\t\t    sigdelset(&act.sa_mask, SIGKILL)) {\n\t\t\tERROR(\"failed to set signal\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tact.sa_flags = 0;\n\t\tact.sa_handler = interrupt_handler;\n\t\tif (sigaction(i, &act, NULL) && errno != EINVAL) {\n\t\t\tSYSERROR(\"failed to sigaction\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tlxc_setup_fs();\n\n\tpid = fork();\n\n\tif (pid < 0)\n\t\texit(EXIT_FAILURE);\n\n\tif (!pid) {\n\n\t\t/* restore default signal handlers */\n\t\tfor (i = 1; i < NSIG; i++)\n\t\t\tsignal(i, SIG_DFL);\n\n\t\tif (sigprocmask(SIG_SETMASK, &omask, NULL)) {\n\t\t\tSYSERROR(\"failed to set signal mask\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tNOTICE(\"about to exec '%s'\", aargv[0]);\n\n\t\texecvp(aargv[0], aargv);\n\t\tERROR(\"failed to exec: '%s' : %m\", aargv[0]);\n\t\texit(err);\n\t}\n\n\t/* let's process the signals now */\n\tif (sigdelset(&omask, SIGALRM) ||\n\t    sigprocmask(SIG_SETMASK, &omask, NULL)) {\n\t\tSYSERROR(\"failed to set signal mask\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t/* no need of other inherited fds but stderr */\n\tclose(fileno(stdin));\n\tclose(fileno(stdout));\n\n\terr = EXIT_SUCCESS;\n\tfor (;;) {\n\t\tint status;\n\t\tpid_t waited_pid;\n\n\t\tswitch (was_interrupted) {\n\n\t\tcase 0:\n\t\t\tbreak;\n\n\t\tcase SIGPWR:\n\t\tcase SIGTERM:\n\t\t\tif (!shutdown) {\n\t\t\t\tshutdown = 1;\n\t\t\t\tkill(-1, SIGTERM);\n\t\t\t\talarm(1);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SIGALRM:\n\t\t\tkill(-1, SIGKILL);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tkill(pid, was_interrupted);\n\t\t\tbreak;\n\t\t}\n\n\t\twas_interrupted = 0;\n\t\twaited_pid = wait(&status);\n\t\tif (waited_pid < 0) {\n\t\t\tif (errno == ECHILD)\n\t\t\t\tgoto out;\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\n\t\t\tERROR(\"failed to wait child : %s\",\n\t\t\t      strerror(errno));\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* reset timer each time a process exited */\n\t\tif (shutdown)\n\t\t\talarm(1);\n\n\t\t/*\n\t\t * keep the exit code of started application\n\t\t * (not wrapped pid) and continue to wait for\n\t\t * the end of the orphan group.\n\t\t */\n\t\tif (waited_pid == pid && !have_status) {\n\t\t\terr = lxc_error_set_and_log(waited_pid, status);\n\t\t\thave_status = 1;\n\t\t}\n\t}\nout:\n\tif (err < 0)\n\t\texit(EXIT_FAILURE);\n\texit(err);\n}"
  },
  {
    "function_name": "usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_init.c",
    "lines": "61-75",
    "snippet": "static void usage(void) {\n\tfprintf(stderr, \"Usage: lxc-init [OPTION]...\\n\\n\"\n\t\t\"Common options :\\n\"\n\t\t\"  -n, --name=NAME          NAME of the container\\n\"\n\t\t\"  -l, --logpriority=LEVEL  Set log priority to LEVEL\\n\"\n\t\t\"  -q, --quiet              Don't produce any output\\n\"\n\t\t\"  -P, --lxcpath=PATH       Use specified container path\\n\"\n\t\t\"  -?, --help               Give this help list\\n\"\n\t\t\"\\n\"\n\t\t\"Mandatory or optional arguments to long options are also mandatory or optional\\n\"\n\t\t\"for any corresponding short options.\\n\"\n\t\t\"\\n\"\n\t\t\"NOTE: lxc-init is intended for use by lxc internally\\n\"\n\t\t\"      and does not need to be run by hand\\n\\n\");\n}",
    "includes": [
      "#include \"initutils.h\"",
      "#include \"error.h\"",
      "#include \"caps.h\"",
      "#include \"log.h\"",
      "#include <getopt.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <libgen.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int quiet;",
      "static const struct option options[] = {\n\t{ \"name\",        required_argument, NULL, 'n' },\n\t{ \"logpriority\", required_argument, NULL, 'l' },\n\t{ \"quiet\",       no_argument,       NULL, 'q' },\n\t{ \"lxcpath\",     required_argument, NULL, 'P' },\n\t{ 0, 0, 0, 0 },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Usage: lxc-init [OPTION]...\\n\\n\"\n\t\t\"Common options :\\n\"\n\t\t\"  -n, --name=NAME          NAME of the container\\n\"\n\t\t\"  -l, --logpriority=LEVEL  Set log priority to LEVEL\\n\"\n\t\t\"  -q, --quiet              Don't produce any output\\n\"\n\t\t\"  -P, --lxcpath=PATH       Use specified container path\\n\"\n\t\t\"  -?, --help               Give this help list\\n\"\n\t\t\"\\n\"\n\t\t\"Mandatory or optional arguments to long options are also mandatory or optional\\n\"\n\t\t\"for any corresponding short options.\\n\"\n\t\t\"\\n\"\n\t\t\"NOTE: lxc-init is intended for use by lxc internally\\n\"\n\t\t\"      and does not need to be run by hand\\n\\n\""
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initutils.h\"\n#include \"error.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <getopt.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <libgen.h>\n#include <signal.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\nstatic int quiet;\nstatic const struct option options[] = {\n\t{ \"name\",        required_argument, NULL, 'n' },\n\t{ \"logpriority\", required_argument, NULL, 'l' },\n\t{ \"quiet\",       no_argument,       NULL, 'q' },\n\t{ \"lxcpath\",     required_argument, NULL, 'P' },\n\t{ 0, 0, 0, 0 },\n};\n\nstatic void usage(void) {\n\tfprintf(stderr, \"Usage: lxc-init [OPTION]...\\n\\n\"\n\t\t\"Common options :\\n\"\n\t\t\"  -n, --name=NAME          NAME of the container\\n\"\n\t\t\"  -l, --logpriority=LEVEL  Set log priority to LEVEL\\n\"\n\t\t\"  -q, --quiet              Don't produce any output\\n\"\n\t\t\"  -P, --lxcpath=PATH       Use specified container path\\n\"\n\t\t\"  -?, --help               Give this help list\\n\"\n\t\t\"\\n\"\n\t\t\"Mandatory or optional arguments to long options are also mandatory or optional\\n\"\n\t\t\"for any corresponding short options.\\n\"\n\t\t\"\\n\"\n\t\t\"NOTE: lxc-init is intended for use by lxc internally\\n\"\n\t\t\"      and does not need to be run by hand\\n\\n\");\n}"
  },
  {
    "function_name": "interrupt_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_init.c",
    "lines": "55-59",
    "snippet": "static void interrupt_handler(int sig)\n{\n\tif (!was_interrupted)\n\t\twas_interrupted = sig;\n}",
    "includes": [
      "#include \"initutils.h\"",
      "#include \"error.h\"",
      "#include \"caps.h\"",
      "#include \"log.h\"",
      "#include <getopt.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <libgen.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static sig_atomic_t was_interrupted = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"initutils.h\"\n#include \"error.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <getopt.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <libgen.h>\n#include <signal.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\nstatic sig_atomic_t was_interrupted = 0;\n\nstatic void interrupt_handler(int sig)\n{\n\tif (!was_interrupted)\n\t\twas_interrupted = sig;\n}"
  }
]