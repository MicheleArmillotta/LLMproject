[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_create.c",
    "lines": "207-326",
    "snippet": "int main(int argc, char *argv[])\n{\n\tstruct lxc_container *c;\n\tstruct bdev_specs spec;\n\tint flags = 0;\n\n\tif (lxc_arguments_parse(&my_args, argc, argv))\n\t\texit(EXIT_FAILURE);\n\n\tif (!my_args.log_file)\n\t\tmy_args.log_file = \"none\";\n\n\tif (lxc_log_init(my_args.name, my_args.log_file, my_args.log_priority,\n\t\t\t my_args.progname, my_args.quiet, my_args.lxcpath[0]))\n\t\texit(EXIT_FAILURE);\n\tlxc_log_options_no_override();\n\n\tif (!my_args.template) {\n\t\tfprintf(stderr, \"A template must be specified.\\n\");\n\t\tfprintf(stderr, \"Use \\\"none\\\" if you really want a container without a rootfs.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (strcmp(my_args.template, \"none\") == 0)\n\t\tmy_args.template = NULL;\n\n\tmemset(&spec, 0, sizeof(spec));\n\tif (!my_args.bdevtype)\n\t\tmy_args.bdevtype = \"_unset\";\n\n\tif (!validate_bdev_args(&my_args))\n\t\texit(EXIT_FAILURE);\n\n\tif (strcmp(my_args.bdevtype, \"none\") == 0)\n\t\tmy_args.bdevtype = \"dir\";\n\n\t// Final check whether the user gave use a valid bdev type.\n\tif (strcmp(my_args.bdevtype, \"best\") &&\n\t    strcmp(my_args.bdevtype, \"_unset\") &&\n\t    !is_valid_bdev_type(my_args.bdevtype)) {\n\t\tfprintf(stderr, \"%s is not a valid backing storage type.\\n\", my_args.bdevtype);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (geteuid()) {\n\t\tif (mkdir_p(my_args.lxcpath[0], 0755)) {\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tif (access(my_args.lxcpath[0], O_RDONLY) < 0) {\n\t\t\tfprintf(stderr, \"You lack access to %s\\n\", my_args.lxcpath[0]);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tif (strcmp(my_args.bdevtype, \"dir\") && strcmp(my_args.bdevtype, \"_unset\") &&\n\t\t\t\tstrcmp(my_args.bdevtype, \"btrfs\")) {\n\t\t\tfprintf(stderr, \"Unprivileged users cannot create %s containers.\\n\", my_args.bdevtype);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\n\tc = lxc_container_new(my_args.name, my_args.lxcpath[0]);\n\tif (!c) {\n\t\tfprintf(stderr, \"Failed to create lxc container.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (c->is_defined(c)) {\n\t\tlxc_container_put(c);\n\t\tfprintf(stderr, \"Container already exists\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (my_args.configfile)\n\t\tc->load_config(c, my_args.configfile);\n\telse\n\t\tc->load_config(c, lxc_global_config_value(\"lxc.default_config\"));\n\n\tif (my_args.fstype)\n\t\tspec.fstype = my_args.fstype;\n\tif (my_args.fssize)\n\t\tspec.fssize = my_args.fssize;\n\n\tif ((strcmp(my_args.bdevtype, \"zfs\") == 0) || (strcmp(my_args.bdevtype, \"best\") == 0)) {\n\t\tif (my_args.zfsroot)\n\t\t\tspec.zfs.zfsroot = my_args.zfsroot;\n\t}\n\n\tif ((strcmp(my_args.bdevtype, \"lvm\") == 0) || (strcmp(my_args.bdevtype, \"best\") == 0)) {\n\t\tif (my_args.lvname)\n\t\t\tspec.lvm.lv = my_args.lvname;\n\t\tif (my_args.vgname)\n\t\t\tspec.lvm.vg = my_args.vgname;\n\t\tif (my_args.thinpool)\n\t\t\tspec.lvm.thinpool = my_args.thinpool;\n\t}\n\n\tif ((strcmp(my_args.bdevtype, \"rbd\") == 0) || (strcmp(my_args.bdevtype, \"best\") == 0)) {\n\t\tif (my_args.rbdname)\n\t\t\tspec.rbd.rbdname = my_args.rbdname;\n\t\tif (my_args.rbdpool)\n\t\t\tspec.rbd.rbdpool = my_args.rbdpool;\n\t}\n\n\tif (my_args.dir)\n\t\tspec.dir = my_args.dir;\n\n\tif (strcmp(my_args.bdevtype, \"_unset\") == 0)\n\t\tmy_args.bdevtype = NULL;\n\n\tif (my_args.quiet)\n\t\tflags = LXC_CREATE_QUIET;\n\n\tif (!c->create(c, my_args.template, my_args.bdevtype, &spec, flags, &argv[optind])) {\n\t\tERROR(\"Error creating container %s\", c->name);\n\t\tlxc_container_put(c);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tlxc_container_put(c);\n\tINFO(\"container %s created\", c->name);\n\texit(EXIT_SUCCESS);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include \"arguments.h\"",
      "#include <sys/types.h>",
      "#include <lxc/lxccontainer.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <libgen.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lxc_arguments my_args = {\n\t.progname = \"lxc-create\",\n\t.helpfn   = create_helpfn,\n\t.help     = \"\\\n--name=NAME --template=TEMPLATE [OPTION...]\\n\\\n\\n\\\nlxc-create creates a container\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME               NAME of the container\\n\\\n  -f, --config=CONFIG           Initial configuration file\\n\\\n  -t, --template=TEMPLATE       Template to use to setup container\\n\\\n  -B, --bdev=BDEV               Backing store type to use\\n\\\n      --dir=DIR                 Place rootfs directory under DIR\\n\\\n\\n\\\n  BDEV options for LVM (with -B/--bdev lvm):\\n\\\n      --lvname=LVNAME           Use LVM lv name LVNAME\\n\\\n                                (Default: container name)\\n\\\n      --vgname=VG               Use LVM vg called VG\\n\\\n                                (Default: lxc)\\n\\\n      --thinpool=TP             Use LVM thin pool called TP\\n\\\n                                (Default: lxc)\\n\\\n\\n\\\n  BDEV options for Ceph RBD (with -B/--bdev rbd) :\\n\\\n      --rbdname=RBDNAME         Use Ceph RBD name RBDNAME\\n\\\n                                (Default: container name)\\n\\\n      --rbdpool=POOL            Use Ceph RBD pool name POOL\\n\\\n                                (Default: lxc)\\n\\\n\\n\\\n  BDEV option for ZFS (with -B/--bdev zfs) :\\n\\\n      --zfsroot=PATH            Create zfs under given zfsroot\\n\\\n                                (Default: tank/lxc)\\n\\\n\\n\\\n  BDEV options for LVM or Loop (with -B/--bdev lvm/loop) :\\n\\\n      --fstype=TYPE             Create fstype TYPE\\n\\\n                                (Default: ext3)\\n\\\n      --fssize=SIZE[U]          Create filesystem of\\n\\\n                                size SIZE * unit U (bBkKmMgGtT)\\n\\\n                                (Default: 1G, default unit: M)\\n\",\n\t.options  = my_longopts,\n\t.parser   = my_parser,\n\t.checker  = NULL,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_SUCCESS"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"container %s created\"",
            "c->name"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_container_put",
          "args": [
            "c"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "312-325",
          "snippet": "int lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error creating container %s\"",
            "c->name"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->create",
          "args": [
            "c",
            "my_args.template",
            "my_args.bdevtype",
            "&spec",
            "flags",
            "&argv[optind]"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "my_args.bdevtype",
            "\"_unset\""
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "my_args.bdevtype",
            "\"best\""
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "my_args.bdevtype",
            "\"rbd\""
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "my_args.bdevtype",
            "\"best\""
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "my_args.bdevtype",
            "\"lvm\""
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "my_args.bdevtype",
            "\"best\""
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "my_args.bdevtype",
            "\"zfs\""
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->load_config",
          "args": [
            "c",
            "lxc_global_config_value(\"lxc.default_config\")"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_global_config_value",
          "args": [
            "\"lxc.default_config\""
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_global_config_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "88-247",
          "snippet": "const char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nconst char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->load_config",
          "args": [
            "c",
            "my_args.configfile"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Container already exists\\n\""
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->is_defined",
          "args": [
            "c"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to create lxc container.\\n\""
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_container_new",
          "args": [
            "my_args.name",
            "my_args.lxcpath[0]"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "4099-4218",
          "snippet": "struct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstruct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Unprivileged users cannot create %s containers.\\n\"",
            "my_args.bdevtype"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "my_args.bdevtype",
            "\"btrfs\""
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "my_args.bdevtype",
            "\"_unset\""
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "my_args.bdevtype",
            "\"dir\""
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"You lack access to %s\\n\"",
            "my_args.lxcpath[0]"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "my_args.lxcpath[0]",
            "O_RDONLY"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir_p",
          "args": [
            "my_args.lxcpath[0]",
            "0755"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "241-262",
          "snippet": "extern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s is not a valid backing storage type.\\n\"",
            "my_args.bdevtype"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_valid_bdev_type",
          "args": [
            "my_args.bdevtype"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "is_valid_bdev_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "975-988",
          "snippet": "bool is_valid_bdev_type(const char *type)\n{\n\tif (strcmp(type, \"dir\") == 0 ||\n\t\t\tstrcmp(type, \"btrfs\") == 0 ||\n\t\t\tstrcmp(type, \"aufs\") == 0 ||\n\t\t\tstrcmp(type, \"loop\") == 0 ||\n\t\t\tstrcmp(type, \"lvm\") == 0 ||\n\t\t\tstrcmp(type, \"nbd\") == 0 ||\n\t\t\tstrcmp(type, \"overlayfs\") == 0 ||\n\t\t\tstrcmp(type, \"rbd\") == 0 ||\n\t\t\tstrcmp(type, \"zfs\") == 0)\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bdev *bdev_get(const char *type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic struct bdev *bdev_get(const char *type);\n\nbool is_valid_bdev_type(const char *type)\n{\n\tif (strcmp(type, \"dir\") == 0 ||\n\t\t\tstrcmp(type, \"btrfs\") == 0 ||\n\t\t\tstrcmp(type, \"aufs\") == 0 ||\n\t\t\tstrcmp(type, \"loop\") == 0 ||\n\t\t\tstrcmp(type, \"lvm\") == 0 ||\n\t\t\tstrcmp(type, \"nbd\") == 0 ||\n\t\t\tstrcmp(type, \"overlayfs\") == 0 ||\n\t\t\tstrcmp(type, \"rbd\") == 0 ||\n\t\t\tstrcmp(type, \"zfs\") == 0)\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "my_args.bdevtype",
            "\"_unset\""
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "my_args.bdevtype",
            "\"best\""
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "my_args.bdevtype",
            "\"none\""
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_bdev_args",
          "args": [
            "&my_args"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "validate_bdev_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_create.c",
          "lines": "174-205",
          "snippet": "static bool validate_bdev_args(struct lxc_arguments *a)\n{\n\tif (strcmp(a->bdevtype, \"best\") != 0) {\n\t\tif (a->fstype || a->fssize) {\n\t\t\tif (strcmp(a->bdevtype, \"lvm\") != 0 &&\n\t\t\t    strcmp(a->bdevtype, \"loop\") != 0 &&\n\t\t\t    strcmp(a->bdevtype, \"rbd\") != 0) {\n\t\t\t\tfprintf(stderr, \"filesystem type and size are only valid with block devices\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (strcmp(a->bdevtype, \"lvm\") != 0) {\n\t\t\tif (a->lvname || a->vgname || a->thinpool) {\n\t\t\t\tfprintf(stderr, \"--lvname, --vgname and --thinpool are only valid with -B lvm\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (strcmp(a->bdevtype, \"rbd\") != 0) {\n\t\t\tif (a->rbdname || a->rbdpool) {\n\t\t\t\tfprintf(stderr, \"--rbdname and --rbdpool are only valid with -B rbd\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (strcmp(a->bdevtype, \"zfs\") != 0) {\n\t\t\tif (a->zfsroot) {\n\t\t\t\tfprintf(stderr, \"zfsroot is only valid with -B zfs\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"arguments.h\"",
            "#include <sys/types.h>",
            "#include <lxc/lxccontainer.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <libgen.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"arguments.h\"\n#include <sys/types.h>\n#include <lxc/lxccontainer.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <libgen.h>\n#include <fcntl.h>\n#include <ctype.h>\n\nstatic bool validate_bdev_args(struct lxc_arguments *a)\n{\n\tif (strcmp(a->bdevtype, \"best\") != 0) {\n\t\tif (a->fstype || a->fssize) {\n\t\t\tif (strcmp(a->bdevtype, \"lvm\") != 0 &&\n\t\t\t    strcmp(a->bdevtype, \"loop\") != 0 &&\n\t\t\t    strcmp(a->bdevtype, \"rbd\") != 0) {\n\t\t\t\tfprintf(stderr, \"filesystem type and size are only valid with block devices\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (strcmp(a->bdevtype, \"lvm\") != 0) {\n\t\t\tif (a->lvname || a->vgname || a->thinpool) {\n\t\t\t\tfprintf(stderr, \"--lvname, --vgname and --thinpool are only valid with -B lvm\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (strcmp(a->bdevtype, \"rbd\") != 0) {\n\t\t\tif (a->rbdname || a->rbdpool) {\n\t\t\t\tfprintf(stderr, \"--rbdname and --rbdpool are only valid with -B rbd\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (strcmp(a->bdevtype, \"zfs\") != 0) {\n\t\t\tif (a->zfsroot) {\n\t\t\t\tfprintf(stderr, \"zfsroot is only valid with -B zfs\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&spec",
            "0",
            "sizeof(spec)"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "my_args.template",
            "\"none\""
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Use \\\"none\\\" if you really want a container without a rootfs.\\n\""
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"A template must be specified.\\n\""
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_log_options_no_override",
          "args": [],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_log_options_no_override",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
          "lines": "685-689",
          "snippet": "extern void lxc_log_options_no_override()\n{\n\tlxc_quiet_specified = 1;\n\tlxc_loglevel_specified = 1;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"caps.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <pthread.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int lxc_quiet_specified;",
            "static int lxc_loglevel_specified;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nint lxc_quiet_specified;\nstatic int lxc_loglevel_specified;\n\nextern void lxc_log_options_no_override()\n{\n\tlxc_quiet_specified = 1;\n\tlxc_loglevel_specified = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_log_init",
          "args": [
            "my_args.name",
            "my_args.log_file",
            "my_args.log_priority",
            "my_args.progname",
            "my_args.quiet",
            "my_args.lxcpath[0]"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_log_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
          "lines": "546-615",
          "snippet": "extern int lxc_log_init(const char *name, const char *file,\n\t\t\tconst char *priority, const char *prefix, int quiet,\n\t\t\tconst char *lxcpath)\n{\n\tint lxc_priority = LXC_LOG_PRIORITY_ERROR;\n\tint ret;\n\n\tif (lxc_log_fd != -1) {\n\t\tWARN(\"lxc_log_init called with log already initialized\");\n\t\treturn 0;\n\t}\n\n\tif (priority)\n\t\tlxc_priority = lxc_log_priority_to_int(priority);\n\n\tif (!lxc_loglevel_specified) {\n\t\tlxc_log_category_lxc.priority = lxc_priority;\n\t\tlxc_loglevel_specified = 1;\n\t}\n\n\tif (!lxc_quiet_specified) {\n\t\tif (!quiet)\n\t\t\tlxc_log_category_lxc.appender->next = &log_appender_stderr;\n\t}\n\n\tif (prefix)\n\t\tlxc_log_set_prefix(prefix);\n\n\tif (name)\n\t\tlog_vmname = strdup(name);\n\n\tif (file) {\n\t\tif (strcmp(file, \"none\") == 0)\n\t\t\treturn 0;\n\t\tret = __lxc_log_set_file(file, 1);\n\t\tlxc_log_use_global_fd = 1;\n\t} else {\n\t\t/* if no name was specified, there nothing to do */\n\t\tif (!name)\n\t\t\treturn 0;\n\n\t\tret = -1;\n\n\t\tif (!lxcpath)\n\t\t\tlxcpath = LOGPATH;\n\n\t\t/* try LOGPATH if lxcpath is the default for the privileged containers */\n\t\tif (!geteuid() && strcmp(LXCPATH, lxcpath) == 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\n\t\t/* try in lxcpath */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, lxcpath, 1);\n\n\t\t/* try LOGPATH in case its writable by the caller */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\t}\n\n\t/*\n\t * If !file, that is, if the user did not request this logpath, then\n\t * ignore failures and continue logging to console\n\t */\n\tif (!file && ret != 0) {\n\t\tINFO(\"Ignoring failure to open default logfile.\");\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"caps.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <pthread.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int lxc_log_fd = -1;",
            "int lxc_quiet_specified;",
            "int lxc_log_use_global_fd;",
            "static int lxc_loglevel_specified;",
            "static char *log_vmname = NULL;",
            "static struct lxc_log_appender log_appender_stderr = {\n\t.name\t\t= \"stderr\",\n\t.append\t\t= log_append_stderr,\n\t.next\t\t= NULL,\n};",
            "struct lxc_log_category lxc_log_category_lxc = {\n\t.name\t\t= \"lxc\",\n\t.priority\t= LXC_LOG_PRIORITY_ERROR,\n\t.appender\t= &log_appender_logfile,\n\t.parent\t\t= &log_root\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nint lxc_log_fd = -1;\nint lxc_quiet_specified;\nint lxc_log_use_global_fd;\nstatic int lxc_loglevel_specified;\nstatic char *log_vmname = NULL;\nstatic struct lxc_log_appender log_appender_stderr = {\n\t.name\t\t= \"stderr\",\n\t.append\t\t= log_append_stderr,\n\t.next\t\t= NULL,\n};\nstruct lxc_log_category lxc_log_category_lxc = {\n\t.name\t\t= \"lxc\",\n\t.priority\t= LXC_LOG_PRIORITY_ERROR,\n\t.appender\t= &log_appender_logfile,\n\t.parent\t\t= &log_root\n};\n\nextern int lxc_log_init(const char *name, const char *file,\n\t\t\tconst char *priority, const char *prefix, int quiet,\n\t\t\tconst char *lxcpath)\n{\n\tint lxc_priority = LXC_LOG_PRIORITY_ERROR;\n\tint ret;\n\n\tif (lxc_log_fd != -1) {\n\t\tWARN(\"lxc_log_init called with log already initialized\");\n\t\treturn 0;\n\t}\n\n\tif (priority)\n\t\tlxc_priority = lxc_log_priority_to_int(priority);\n\n\tif (!lxc_loglevel_specified) {\n\t\tlxc_log_category_lxc.priority = lxc_priority;\n\t\tlxc_loglevel_specified = 1;\n\t}\n\n\tif (!lxc_quiet_specified) {\n\t\tif (!quiet)\n\t\t\tlxc_log_category_lxc.appender->next = &log_appender_stderr;\n\t}\n\n\tif (prefix)\n\t\tlxc_log_set_prefix(prefix);\n\n\tif (name)\n\t\tlog_vmname = strdup(name);\n\n\tif (file) {\n\t\tif (strcmp(file, \"none\") == 0)\n\t\t\treturn 0;\n\t\tret = __lxc_log_set_file(file, 1);\n\t\tlxc_log_use_global_fd = 1;\n\t} else {\n\t\t/* if no name was specified, there nothing to do */\n\t\tif (!name)\n\t\t\treturn 0;\n\n\t\tret = -1;\n\n\t\tif (!lxcpath)\n\t\t\tlxcpath = LOGPATH;\n\n\t\t/* try LOGPATH if lxcpath is the default for the privileged containers */\n\t\tif (!geteuid() && strcmp(LXCPATH, lxcpath) == 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\n\t\t/* try in lxcpath */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, lxcpath, 1);\n\n\t\t/* try LOGPATH in case its writable by the caller */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\t}\n\n\t/*\n\t * If !file, that is, if the user did not request this logpath, then\n\t * ignore failures and continue logging to console\n\t */\n\tif (!file && ret != 0) {\n\t\tINFO(\"Ignoring failure to open default logfile.\");\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_arguments_parse",
          "args": [
            "&my_args",
            "argc",
            "argv"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_arguments_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/arguments.c",
          "lines": "182-252",
          "snippet": "extern int lxc_arguments_parse(struct lxc_arguments *args,\n\t\t\t       int argc, char * const argv[])\n{\n\tchar shortopts[256];\n\tint  ret = 0;\n\n\tret = build_shortopts(args->options, shortopts, sizeof(shortopts));\n\tif (ret < 0) {\n\t\tlxc_error(args, \"build_shortopts() failed : %s\",\n\t\t\t  strerror(errno));\n\t\treturn ret;\n\t}\n\n\twhile (1)  {\n\t\tint c, index = 0;\n\n\t\tc = getopt_long(argc, argv, shortopts, args->options, &index);\n\t\tif (c == -1)\n\t\t\tbreak;\n\t\tswitch (c) {\n\t\tcase 'n': \targs->name = optarg; break;\n\t\tcase 'o':\targs->log_file = optarg; break;\n\t\tcase 'l':\targs->log_priority = optarg; break;\n\t\tcase 'q':\targs->quiet = 1; break;\n\t\tcase OPT_RCFILE: args->rcfile = optarg; break;\n\t\tcase 'P':\n\t\t\tremove_trailing_slashes(optarg);\n\t\t\tret = lxc_arguments_lxcpath_add(args, optarg);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase OPT_USAGE: print_usage(args->options, args);\n\t\tcase OPT_VERSION: print_version();\n\t\tcase '?':\tprint_help(args, 1);\n\t\tcase 'h': \tprint_help(args, 0);\n\t\tdefault:\n\t\t\tif (args->parser) {\n\t\t\t\tret = args->parser(args, c, optarg);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Reclaim the remaining command arguments\n\t */\n\targs->argv = &argv[optind];\n\targs->argc = argc - optind;\n\n\t/* If no lxcpaths were given, use default */\n\tif (!args->lxcpath_cnt) {\n\t\tret = lxc_arguments_lxcpath_add(args, lxc_global_config_value(\"lxc.lxcpath\"));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t/* Check the command options */\n\n\tif (!args->name && strcmp(args->progname, \"lxc-autostart\") != 0) {\n\t\tlxc_error(args, \"missing container name, use --name option\");\n\t\treturn -1;\n\t}\n\n\tif (args->checker)\n\t\tret = args->checker(args);\nerror:\n\tif (ret)\n\t\tlxc_error(args, \"could not parse command line\");\n\treturn ret;\n}",
          "includes": [
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"arguments.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <ctype.h>\t\t/* for isprint() */",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"utils.h\"\n#include \"arguments.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <ctype.h>\t\t/* for isprint() */\n#include <string.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nextern int lxc_arguments_parse(struct lxc_arguments *args,\n\t\t\t       int argc, char * const argv[])\n{\n\tchar shortopts[256];\n\tint  ret = 0;\n\n\tret = build_shortopts(args->options, shortopts, sizeof(shortopts));\n\tif (ret < 0) {\n\t\tlxc_error(args, \"build_shortopts() failed : %s\",\n\t\t\t  strerror(errno));\n\t\treturn ret;\n\t}\n\n\twhile (1)  {\n\t\tint c, index = 0;\n\n\t\tc = getopt_long(argc, argv, shortopts, args->options, &index);\n\t\tif (c == -1)\n\t\t\tbreak;\n\t\tswitch (c) {\n\t\tcase 'n': \targs->name = optarg; break;\n\t\tcase 'o':\targs->log_file = optarg; break;\n\t\tcase 'l':\targs->log_priority = optarg; break;\n\t\tcase 'q':\targs->quiet = 1; break;\n\t\tcase OPT_RCFILE: args->rcfile = optarg; break;\n\t\tcase 'P':\n\t\t\tremove_trailing_slashes(optarg);\n\t\t\tret = lxc_arguments_lxcpath_add(args, optarg);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase OPT_USAGE: print_usage(args->options, args);\n\t\tcase OPT_VERSION: print_version();\n\t\tcase '?':\tprint_help(args, 1);\n\t\tcase 'h': \tprint_help(args, 0);\n\t\tdefault:\n\t\t\tif (args->parser) {\n\t\t\t\tret = args->parser(args, c, optarg);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Reclaim the remaining command arguments\n\t */\n\targs->argv = &argv[optind];\n\targs->argc = argc - optind;\n\n\t/* If no lxcpaths were given, use default */\n\tif (!args->lxcpath_cnt) {\n\t\tret = lxc_arguments_lxcpath_add(args, lxc_global_config_value(\"lxc.lxcpath\"));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t/* Check the command options */\n\n\tif (!args->name && strcmp(args->progname, \"lxc-autostart\") != 0) {\n\t\tlxc_error(args, \"missing container name, use --name option\");\n\t\treturn -1;\n\t}\n\n\tif (args->checker)\n\t\tret = args->checker(args);\nerror:\n\tif (ret)\n\t\tlxc_error(args, \"could not parse command line\");\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"arguments.h\"\n#include <sys/types.h>\n#include <lxc/lxccontainer.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <libgen.h>\n#include <fcntl.h>\n#include <ctype.h>\n\nstatic struct lxc_arguments my_args = {\n\t.progname = \"lxc-create\",\n\t.helpfn   = create_helpfn,\n\t.help     = \"\\\n--name=NAME --template=TEMPLATE [OPTION...]\\n\\\n\\n\\\nlxc-create creates a container\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME               NAME of the container\\n\\\n  -f, --config=CONFIG           Initial configuration file\\n\\\n  -t, --template=TEMPLATE       Template to use to setup container\\n\\\n  -B, --bdev=BDEV               Backing store type to use\\n\\\n      --dir=DIR                 Place rootfs directory under DIR\\n\\\n\\n\\\n  BDEV options for LVM (with -B/--bdev lvm):\\n\\\n      --lvname=LVNAME           Use LVM lv name LVNAME\\n\\\n                                (Default: container name)\\n\\\n      --vgname=VG               Use LVM vg called VG\\n\\\n                                (Default: lxc)\\n\\\n      --thinpool=TP             Use LVM thin pool called TP\\n\\\n                                (Default: lxc)\\n\\\n\\n\\\n  BDEV options for Ceph RBD (with -B/--bdev rbd) :\\n\\\n      --rbdname=RBDNAME         Use Ceph RBD name RBDNAME\\n\\\n                                (Default: container name)\\n\\\n      --rbdpool=POOL            Use Ceph RBD pool name POOL\\n\\\n                                (Default: lxc)\\n\\\n\\n\\\n  BDEV option for ZFS (with -B/--bdev zfs) :\\n\\\n      --zfsroot=PATH            Create zfs under given zfsroot\\n\\\n                                (Default: tank/lxc)\\n\\\n\\n\\\n  BDEV options for LVM or Loop (with -B/--bdev lvm/loop) :\\n\\\n      --fstype=TYPE             Create fstype TYPE\\n\\\n                                (Default: ext3)\\n\\\n      --fssize=SIZE[U]          Create filesystem of\\n\\\n                                size SIZE * unit U (bBkKmMgGtT)\\n\\\n                                (Default: 1G, default unit: M)\\n\",\n\t.options  = my_longopts,\n\t.parser   = my_parser,\n\t.checker  = NULL,\n};\n\nint main(int argc, char *argv[])\n{\n\tstruct lxc_container *c;\n\tstruct bdev_specs spec;\n\tint flags = 0;\n\n\tif (lxc_arguments_parse(&my_args, argc, argv))\n\t\texit(EXIT_FAILURE);\n\n\tif (!my_args.log_file)\n\t\tmy_args.log_file = \"none\";\n\n\tif (lxc_log_init(my_args.name, my_args.log_file, my_args.log_priority,\n\t\t\t my_args.progname, my_args.quiet, my_args.lxcpath[0]))\n\t\texit(EXIT_FAILURE);\n\tlxc_log_options_no_override();\n\n\tif (!my_args.template) {\n\t\tfprintf(stderr, \"A template must be specified.\\n\");\n\t\tfprintf(stderr, \"Use \\\"none\\\" if you really want a container without a rootfs.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (strcmp(my_args.template, \"none\") == 0)\n\t\tmy_args.template = NULL;\n\n\tmemset(&spec, 0, sizeof(spec));\n\tif (!my_args.bdevtype)\n\t\tmy_args.bdevtype = \"_unset\";\n\n\tif (!validate_bdev_args(&my_args))\n\t\texit(EXIT_FAILURE);\n\n\tif (strcmp(my_args.bdevtype, \"none\") == 0)\n\t\tmy_args.bdevtype = \"dir\";\n\n\t// Final check whether the user gave use a valid bdev type.\n\tif (strcmp(my_args.bdevtype, \"best\") &&\n\t    strcmp(my_args.bdevtype, \"_unset\") &&\n\t    !is_valid_bdev_type(my_args.bdevtype)) {\n\t\tfprintf(stderr, \"%s is not a valid backing storage type.\\n\", my_args.bdevtype);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (geteuid()) {\n\t\tif (mkdir_p(my_args.lxcpath[0], 0755)) {\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tif (access(my_args.lxcpath[0], O_RDONLY) < 0) {\n\t\t\tfprintf(stderr, \"You lack access to %s\\n\", my_args.lxcpath[0]);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tif (strcmp(my_args.bdevtype, \"dir\") && strcmp(my_args.bdevtype, \"_unset\") &&\n\t\t\t\tstrcmp(my_args.bdevtype, \"btrfs\")) {\n\t\t\tfprintf(stderr, \"Unprivileged users cannot create %s containers.\\n\", my_args.bdevtype);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\n\tc = lxc_container_new(my_args.name, my_args.lxcpath[0]);\n\tif (!c) {\n\t\tfprintf(stderr, \"Failed to create lxc container.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (c->is_defined(c)) {\n\t\tlxc_container_put(c);\n\t\tfprintf(stderr, \"Container already exists\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (my_args.configfile)\n\t\tc->load_config(c, my_args.configfile);\n\telse\n\t\tc->load_config(c, lxc_global_config_value(\"lxc.default_config\"));\n\n\tif (my_args.fstype)\n\t\tspec.fstype = my_args.fstype;\n\tif (my_args.fssize)\n\t\tspec.fssize = my_args.fssize;\n\n\tif ((strcmp(my_args.bdevtype, \"zfs\") == 0) || (strcmp(my_args.bdevtype, \"best\") == 0)) {\n\t\tif (my_args.zfsroot)\n\t\t\tspec.zfs.zfsroot = my_args.zfsroot;\n\t}\n\n\tif ((strcmp(my_args.bdevtype, \"lvm\") == 0) || (strcmp(my_args.bdevtype, \"best\") == 0)) {\n\t\tif (my_args.lvname)\n\t\t\tspec.lvm.lv = my_args.lvname;\n\t\tif (my_args.vgname)\n\t\t\tspec.lvm.vg = my_args.vgname;\n\t\tif (my_args.thinpool)\n\t\t\tspec.lvm.thinpool = my_args.thinpool;\n\t}\n\n\tif ((strcmp(my_args.bdevtype, \"rbd\") == 0) || (strcmp(my_args.bdevtype, \"best\") == 0)) {\n\t\tif (my_args.rbdname)\n\t\t\tspec.rbd.rbdname = my_args.rbdname;\n\t\tif (my_args.rbdpool)\n\t\t\tspec.rbd.rbdpool = my_args.rbdpool;\n\t}\n\n\tif (my_args.dir)\n\t\tspec.dir = my_args.dir;\n\n\tif (strcmp(my_args.bdevtype, \"_unset\") == 0)\n\t\tmy_args.bdevtype = NULL;\n\n\tif (my_args.quiet)\n\t\tflags = LXC_CREATE_QUIET;\n\n\tif (!c->create(c, my_args.template, my_args.bdevtype, &spec, flags, &argv[optind])) {\n\t\tERROR(\"Error creating container %s\", c->name);\n\t\tlxc_container_put(c);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tlxc_container_put(c);\n\tINFO(\"container %s created\", c->name);\n\texit(EXIT_SUCCESS);\n}"
  },
  {
    "function_name": "validate_bdev_args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_create.c",
    "lines": "174-205",
    "snippet": "static bool validate_bdev_args(struct lxc_arguments *a)\n{\n\tif (strcmp(a->bdevtype, \"best\") != 0) {\n\t\tif (a->fstype || a->fssize) {\n\t\t\tif (strcmp(a->bdevtype, \"lvm\") != 0 &&\n\t\t\t    strcmp(a->bdevtype, \"loop\") != 0 &&\n\t\t\t    strcmp(a->bdevtype, \"rbd\") != 0) {\n\t\t\t\tfprintf(stderr, \"filesystem type and size are only valid with block devices\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (strcmp(a->bdevtype, \"lvm\") != 0) {\n\t\t\tif (a->lvname || a->vgname || a->thinpool) {\n\t\t\t\tfprintf(stderr, \"--lvname, --vgname and --thinpool are only valid with -B lvm\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (strcmp(a->bdevtype, \"rbd\") != 0) {\n\t\t\tif (a->rbdname || a->rbdpool) {\n\t\t\t\tfprintf(stderr, \"--rbdname and --rbdpool are only valid with -B rbd\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (strcmp(a->bdevtype, \"zfs\") != 0) {\n\t\t\tif (a->zfsroot) {\n\t\t\t\tfprintf(stderr, \"zfsroot is only valid with -B zfs\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include \"arguments.h\"",
      "#include <sys/types.h>",
      "#include <lxc/lxccontainer.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <libgen.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"zfsroot is only valid with -B zfs\\n\""
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "a->bdevtype",
            "\"zfs\""
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"--rbdname and --rbdpool are only valid with -B rbd\\n\""
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "a->bdevtype",
            "\"rbd\""
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"--lvname, --vgname and --thinpool are only valid with -B lvm\\n\""
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "a->bdevtype",
            "\"lvm\""
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"filesystem type and size are only valid with block devices\\n\""
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "a->bdevtype",
            "\"rbd\""
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "a->bdevtype",
            "\"loop\""
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "a->bdevtype",
            "\"lvm\""
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "a->bdevtype",
            "\"best\""
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"arguments.h\"\n#include <sys/types.h>\n#include <lxc/lxccontainer.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <libgen.h>\n#include <fcntl.h>\n#include <ctype.h>\n\nstatic bool validate_bdev_args(struct lxc_arguments *a)\n{\n\tif (strcmp(a->bdevtype, \"best\") != 0) {\n\t\tif (a->fstype || a->fssize) {\n\t\t\tif (strcmp(a->bdevtype, \"lvm\") != 0 &&\n\t\t\t    strcmp(a->bdevtype, \"loop\") != 0 &&\n\t\t\t    strcmp(a->bdevtype, \"rbd\") != 0) {\n\t\t\t\tfprintf(stderr, \"filesystem type and size are only valid with block devices\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (strcmp(a->bdevtype, \"lvm\") != 0) {\n\t\t\tif (a->lvname || a->vgname || a->thinpool) {\n\t\t\t\tfprintf(stderr, \"--lvname, --vgname and --thinpool are only valid with -B lvm\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (strcmp(a->bdevtype, \"rbd\") != 0) {\n\t\t\tif (a->rbdname || a->rbdpool) {\n\t\t\t\tfprintf(stderr, \"--rbdname and --rbdpool are only valid with -B rbd\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (strcmp(a->bdevtype, \"zfs\") != 0) {\n\t\t\tif (a->zfsroot) {\n\t\t\t\tfprintf(stderr, \"zfsroot is only valid with -B zfs\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "create_helpfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_create.c",
    "lines": "105-128",
    "snippet": "static void create_helpfn(const struct lxc_arguments *args)\n{\n\tchar *argv[3], *path;\n\tpid_t pid;\n\n\tif (!args->template)\n\t\treturn;\n\n\tpid = fork();\n\tif (pid) {\n\t\twait_for_pid(pid);\n\t\treturn;\n\t}\n\n\tpath = get_template_path(args->template);\n\n\targv[0] = path;\n\targv[1] = \"-h\";\n\targv[2] = NULL;\n\n\texecv(path, argv);\n\tERROR(\"Error executing %s -h\", path);\n\texit(EXIT_FAILURE);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include \"arguments.h\"",
      "#include <sys/types.h>",
      "#include <lxc/lxccontainer.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <libgen.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error executing %s -h\"",
            "path"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execv",
          "args": [
            "path",
            "argv"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_template_path",
          "args": [
            "args->template"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "get_template_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1379-1405",
          "snippet": "char *get_template_path(const char *t)\n{\n\tint ret, len;\n\tchar *tpath;\n\n\tif (t[0] == '/' && access(t, X_OK) == 0) {\n\t\ttpath = strdup(t);\n\t\treturn tpath;\n\t}\n\n\tlen = strlen(LXCTEMPLATEDIR) + strlen(t) + strlen(\"/lxc-\") + 1;\n\ttpath = malloc(len);\n\tif (!tpath)\n\t\treturn NULL;\n\tret = snprintf(tpath, len, \"%s/lxc-%s\", LXCTEMPLATEDIR, t);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(tpath);\n\t\treturn NULL;\n\t}\n\tif (access(tpath, X_OK) < 0) {\n\t\tSYSERROR(\"bad template: %s\", t);\n\t\tfree(tpath);\n\t\treturn NULL;\n\t}\n\n\treturn tpath;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *get_template_path(const char *t)\n{\n\tint ret, len;\n\tchar *tpath;\n\n\tif (t[0] == '/' && access(t, X_OK) == 0) {\n\t\ttpath = strdup(t);\n\t\treturn tpath;\n\t}\n\n\tlen = strlen(LXCTEMPLATEDIR) + strlen(t) + strlen(\"/lxc-\") + 1;\n\ttpath = malloc(len);\n\tif (!tpath)\n\t\treturn NULL;\n\tret = snprintf(tpath, len, \"%s/lxc-%s\", LXCTEMPLATEDIR, t);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(tpath);\n\t\treturn NULL;\n\t}\n\tif (access(tpath, X_OK) < 0) {\n\t\tSYSERROR(\"bad template: %s\", t);\n\t\tfree(tpath);\n\t\treturn NULL;\n\t}\n\n\treturn tpath;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_pid",
          "args": [
            "pid"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "67-81",
          "snippet": "static int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"arguments.h\"\n#include <sys/types.h>\n#include <lxc/lxccontainer.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <libgen.h>\n#include <fcntl.h>\n#include <ctype.h>\n\nstatic void create_helpfn(const struct lxc_arguments *args)\n{\n\tchar *argv[3], *path;\n\tpid_t pid;\n\n\tif (!args->template)\n\t\treturn;\n\n\tpid = fork();\n\tif (pid) {\n\t\twait_for_pid(pid);\n\t\treturn;\n\t}\n\n\tpath = get_template_path(args->template);\n\n\targv[0] = path;\n\targv[1] = \"-h\";\n\targv[2] = NULL;\n\n\texecv(path, argv);\n\tERROR(\"Error executing %s -h\", path);\n\texit(EXIT_FAILURE);\n}"
  },
  {
    "function_name": "my_parser",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_create.c",
    "lines": "70-87",
    "snippet": "static int my_parser(struct lxc_arguments* args, int c, char* arg)\n{\n\tswitch (c) {\n\tcase 'B': args->bdevtype = arg; break;\n\tcase 'f': args->configfile = arg; break;\n\tcase 't': args->template = arg; break;\n\tcase '0': args->lvname = arg; break;\n\tcase '1': args->vgname = arg; break;\n\tcase '2': args->thinpool = arg; break;\n\tcase '3': args->fstype = arg; break;\n\tcase '4': args->fssize = get_fssize(arg); break;\n\tcase '5': args->zfsroot = arg; break;\n\tcase '6': args->dir = arg; break;\n\tcase '7': args->rbdname = arg; break;\n\tcase '8': args->rbdpool = arg; break;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include \"arguments.h\"",
      "#include <sys/types.h>",
      "#include <lxc/lxccontainer.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <libgen.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_fssize",
          "args": [
            "arg"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "get_fssize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_create.c",
          "lines": "37-68",
          "snippet": "static uint64_t get_fssize(char *s)\n{\n\tuint64_t ret;\n\tchar *end;\n\n\tret = strtoull(s, &end, 0);\n\tif (end == s)\n\t{\n\t\tfprintf(stderr, \"Invalid blockdev size '%s', using default size\\n\", s);\n\t\treturn 0;\n\t}\n\twhile (isblank(*end))\n\t\tend++;\n\tif (*end == '\\0')\n\t\tret *= 1024ULL * 1024ULL; // MB by default\n\telse if (*end == 'b' || *end == 'B')\n\t\tret *= 1ULL;\n\telse if (*end == 'k' || *end == 'K')\n\t\tret *= 1024ULL;\n\telse if (*end == 'm' || *end == 'M')\n\t\tret *= 1024ULL * 1024ULL;\n\telse if (*end == 'g' || *end == 'G')\n\t\tret *= 1024ULL * 1024ULL * 1024ULL;\n\telse if (*end == 't' || *end == 'T')\n\t\tret *= 1024ULL * 1024ULL * 1024ULL * 1024ULL;\n\telse\n\t{\n\t\tfprintf(stderr, \"Invalid blockdev unit size '%c' in '%s', using default size\\n\", *end, s);\n\t\treturn 0;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"arguments.h\"",
            "#include <sys/types.h>",
            "#include <lxc/lxccontainer.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <libgen.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"arguments.h\"\n#include <sys/types.h>\n#include <lxc/lxccontainer.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <libgen.h>\n#include <fcntl.h>\n#include <ctype.h>\n\nstatic uint64_t get_fssize(char *s)\n{\n\tuint64_t ret;\n\tchar *end;\n\n\tret = strtoull(s, &end, 0);\n\tif (end == s)\n\t{\n\t\tfprintf(stderr, \"Invalid blockdev size '%s', using default size\\n\", s);\n\t\treturn 0;\n\t}\n\twhile (isblank(*end))\n\t\tend++;\n\tif (*end == '\\0')\n\t\tret *= 1024ULL * 1024ULL; // MB by default\n\telse if (*end == 'b' || *end == 'B')\n\t\tret *= 1ULL;\n\telse if (*end == 'k' || *end == 'K')\n\t\tret *= 1024ULL;\n\telse if (*end == 'm' || *end == 'M')\n\t\tret *= 1024ULL * 1024ULL;\n\telse if (*end == 'g' || *end == 'G')\n\t\tret *= 1024ULL * 1024ULL * 1024ULL;\n\telse if (*end == 't' || *end == 'T')\n\t\tret *= 1024ULL * 1024ULL * 1024ULL * 1024ULL;\n\telse\n\t{\n\t\tfprintf(stderr, \"Invalid blockdev unit size '%c' in '%s', using default size\\n\", *end, s);\n\t\treturn 0;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"arguments.h\"\n#include <sys/types.h>\n#include <lxc/lxccontainer.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <libgen.h>\n#include <fcntl.h>\n#include <ctype.h>\n\nstatic int my_parser(struct lxc_arguments* args, int c, char* arg)\n{\n\tswitch (c) {\n\tcase 'B': args->bdevtype = arg; break;\n\tcase 'f': args->configfile = arg; break;\n\tcase 't': args->template = arg; break;\n\tcase '0': args->lvname = arg; break;\n\tcase '1': args->vgname = arg; break;\n\tcase '2': args->thinpool = arg; break;\n\tcase '3': args->fstype = arg; break;\n\tcase '4': args->fssize = get_fssize(arg); break;\n\tcase '5': args->zfsroot = arg; break;\n\tcase '6': args->dir = arg; break;\n\tcase '7': args->rbdname = arg; break;\n\tcase '8': args->rbdpool = arg; break;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "get_fssize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_create.c",
    "lines": "37-68",
    "snippet": "static uint64_t get_fssize(char *s)\n{\n\tuint64_t ret;\n\tchar *end;\n\n\tret = strtoull(s, &end, 0);\n\tif (end == s)\n\t{\n\t\tfprintf(stderr, \"Invalid blockdev size '%s', using default size\\n\", s);\n\t\treturn 0;\n\t}\n\twhile (isblank(*end))\n\t\tend++;\n\tif (*end == '\\0')\n\t\tret *= 1024ULL * 1024ULL; // MB by default\n\telse if (*end == 'b' || *end == 'B')\n\t\tret *= 1ULL;\n\telse if (*end == 'k' || *end == 'K')\n\t\tret *= 1024ULL;\n\telse if (*end == 'm' || *end == 'M')\n\t\tret *= 1024ULL * 1024ULL;\n\telse if (*end == 'g' || *end == 'G')\n\t\tret *= 1024ULL * 1024ULL * 1024ULL;\n\telse if (*end == 't' || *end == 'T')\n\t\tret *= 1024ULL * 1024ULL * 1024ULL * 1024ULL;\n\telse\n\t{\n\t\tfprintf(stderr, \"Invalid blockdev unit size '%c' in '%s', using default size\\n\", *end, s);\n\t\treturn 0;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include \"arguments.h\"",
      "#include <sys/types.h>",
      "#include <lxc/lxccontainer.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <libgen.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Invalid blockdev unit size '%c' in '%s', using default size\\n\"",
            "*end",
            "s"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isblank",
          "args": [
            "*end"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Invalid blockdev size '%s', using default size\\n\"",
            "s"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoull",
          "args": [
            "s",
            "&end",
            "0"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"arguments.h\"\n#include <sys/types.h>\n#include <lxc/lxccontainer.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <libgen.h>\n#include <fcntl.h>\n#include <ctype.h>\n\nstatic uint64_t get_fssize(char *s)\n{\n\tuint64_t ret;\n\tchar *end;\n\n\tret = strtoull(s, &end, 0);\n\tif (end == s)\n\t{\n\t\tfprintf(stderr, \"Invalid blockdev size '%s', using default size\\n\", s);\n\t\treturn 0;\n\t}\n\twhile (isblank(*end))\n\t\tend++;\n\tif (*end == '\\0')\n\t\tret *= 1024ULL * 1024ULL; // MB by default\n\telse if (*end == 'b' || *end == 'B')\n\t\tret *= 1ULL;\n\telse if (*end == 'k' || *end == 'K')\n\t\tret *= 1024ULL;\n\telse if (*end == 'm' || *end == 'M')\n\t\tret *= 1024ULL * 1024ULL;\n\telse if (*end == 'g' || *end == 'G')\n\t\tret *= 1024ULL * 1024ULL * 1024ULL;\n\telse if (*end == 't' || *end == 'T')\n\t\tret *= 1024ULL * 1024ULL * 1024ULL * 1024ULL;\n\telse\n\t{\n\t\tfprintf(stderr, \"Invalid blockdev unit size '%c' in '%s', using default size\\n\", *end, s);\n\t\treturn 0;\n\t}\n\treturn ret;\n}"
  }
]