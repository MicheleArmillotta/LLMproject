[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/startone.c",
    "lines": "97-252",
    "snippet": "int main(int argc, char *argv[])\n{\n\tstruct lxc_container *c;\n\tint ret = 0;\n\tconst char *s;\n\tbool b;\n\tchar buf[201];\n\tint len;\n\n\tret = 1;\n\t/* test a real container */\n\tc = lxc_container_new(MYNAME, NULL);\n\tif (!c) {\n\t\tfprintf(stderr, \"%d: error creating lxc_container %s\\n\", __LINE__, MYNAME);\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tif (c->is_defined(c)) {\n\t\tfprintf(stderr, \"%d: %s thought it was defined\\n\", __LINE__, MYNAME);\n\t\tgoto out;\n\t}\n\n\tret = create_container();\n\tif (ret) {\n\t\tfprintf(stderr, \"%d: failed to create a container\\n\", __LINE__);\n\t\tgoto out;\n\t}\n\n\tb = c->is_defined(c);\n\tif (!b) {\n\t\tfprintf(stderr, \"%d: %s thought it was not defined\\n\", __LINE__, MYNAME);\n\t\tgoto out;\n\t}\n\n\tlen = c->get_cgroup_item(c, \"cpuset.cpus\", buf, 200);\n\tif (len >= 0) {\n\t\tfprintf(stderr, \"%d: %s not running but had cgroup settings\\n\", __LINE__, MYNAME);\n\t\tgoto out;\n\t}\n\n\tsprintf(buf, \"0\");\n\tb = c->set_cgroup_item(c, \"cpuset.cpus\", buf);\n\tif (b) {\n\t\tfprintf(stderr, \"%d: %s not running but coudl set cgroup settings\\n\", __LINE__, MYNAME);\n\t\tgoto out;\n\t}\n\n\ts = c->state(c);\n\tif (!s || strcmp(s, \"STOPPED\")) {\n\t\tfprintf(stderr, \"%d: %s is in state %s, not in STOPPED.\\n\", __LINE__, c->name, s ? s : \"undefined\");\n\t\tgoto out;\n\t}\n\n\tb = c->load_config(c, NULL);\n\tif (!b) {\n\t\tfprintf(stderr, \"%d: %s failed to read its config\\n\", __LINE__, c->name);\n\t\tgoto out;\n\t}\n\n\tif (!c->set_config_item(c, \"lxc.utsname\", \"bobo\")) {\n\t\tfprintf(stderr, \"%d: failed setting lxc.utsname\\n\", __LINE__);\n\t\tgoto out;\n\t}\n\n\tif (!lxc_container_get(c)) {\n\t\tfprintf(stderr, \"%d: failed to get extra ref to container\\n\", __LINE__);\n\t\texit(1);\n\t}\n\n\tc->want_daemonize(c, true);\n\tif (!c->startl(c, 0, NULL)) {\n\t\tfprintf(stderr, \"%d: %s failed to start\\n\", __LINE__, c->name);\n\t\texit(1);\n\t}\n\n\tsleep(3);\n\ts = c->state(c);\n\tif (!s || strcmp(s, \"RUNNING\")) {\n\t\tfprintf(stderr, \"%d: %s is in state %s, not in RUNNING.\\n\", __LINE__, c->name, s ? s : \"undefined\");\n\t\tgoto out;\n\t}\n\n\tlen = c->get_cgroup_item(c, \"cpuset.cpus\", buf, 0);\n\tif (len <= 0) {\n\t\tfprintf(stderr, \"%d: not able to get length of cpuset.cpus (ret %d)\\n\", __LINE__, len);\n\t\tgoto out;\n\t}\n\n\tlen = c->get_cgroup_item(c, \"cpuset.cpus\", buf, 200);\n\tif (len <= 0 || strncmp(buf, \"0\", 1)) {\n\t\tfprintf(stderr, \"%d: not able to get cpuset.cpus (len %d buf %s)\\n\", __LINE__, len, buf);\n\t\tgoto out;\n\t}\n\n\tsprintf(buf, \"FROZEN\");\n\tb = c->set_cgroup_item(c, \"freezer.state\", buf);\n\tif (!b) {\n\t\tfprintf(stderr, \"%d: not able to set freezer.state.\\n\", __LINE__);\n\t\tgoto out;\n\t}\n\n    sprintf(buf, \"XXX\");\n\tlen = c->get_cgroup_item(c, \"freezer.state\", buf, 200);\n\tif (len <= 0 || (strcmp(buf, \"FREEZING\\n\") && strcmp(buf, \"FROZEN\\n\"))) {\n\t\tfprintf(stderr, \"%d: not able to get freezer.state (len %d buf %s)\\n\", __LINE__, len, buf);\n\t\tgoto out;\n\t}\n\n\tc->set_cgroup_item(c, \"freezer.state\", \"THAWED\");\n\n\tc->stop(c);\n\n    /* feh - multilib has moved the lxc-init crap */\n#if 0\n    goto ok;\n\n\tret = system(\"mkdir -p \" LXCPATH \"/lxctest1/rootfs//usr/local/libexec/lxc\");\n\tif (!ret)\n\t\tret = system(\"mkdir -p \" LXCPATH \"/lxctest1/rootfs/usr/lib/lxc/\");\n\tif (!ret)\n\t\tret = system(\"cp src/lxc/lxc-init \" LXCPATH \"/lxctest1/rootfs//usr/local/libexec/lxc\");\n\tif (!ret)\n\t\tret = system(\"cp src/lxc/liblxc.so \" LXCPATH \"/lxctest1/rootfs/usr/lib/lxc\");\n\tif (!ret)\n\t\tret = system(\"cp src/lxc/liblxc.so \" LXCPATH \"/lxctest1/rootfs/usr/lib/lxc/liblxc.so.0\");\n\tif (!ret)\n\t\tret = system(\"cp src/lxc/liblxc.so \" LXCPATH \"/lxctest1/rootfs/usr/lib\");\n\tif (!ret)\n\t\tret = system(\"mkdir -p \" LXCPATH \"/lxctest1/rootfs/dev/shm\");\n\tif (!ret)\n\t\tret = system(\"chroot \" LXCPATH \"/lxctest1/rootfs apt-get install --no-install-recommends lxc\");\n\tif (ret) {\n\t\tfprintf(stderr, \"%d: failed to installing lxc-init in container\\n\", __LINE__);\n\t\tgoto out;\n\t}\n\t// next write out the config file;  does it match?\n\tif (!c->startl(c, 1, \"/bin/hostname\", NULL)) {\n\t\tfprintf(stderr, \"%d: failed to lxc-execute /bin/hostname\\n\", __LINE__);\n\t\tgoto out;\n\t}\n\t//  auto-check result?  ('bobo' is printed on stdout)\n\nok:\n#endif\n\tfprintf(stderr, \"all lxc_container tests passed for %s\\n\", c->name);\n\tret = 0;\n\nout:\n\tif (c) {\n\t\tc->stop(c);\n\t\tdestroy_container();\n\t}\n\tlxc_container_put(c);\n\texit(ret);\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <lxc/lxccontainer.h>"
    ],
    "macros_used": [
      "#define MYNAME \"lxctest1\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "ret"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_container_put",
          "args": [
            "c"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "312-325",
          "snippet": "int lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_container",
          "args": [],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_container",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/startone.c",
          "lines": "33-63",
          "snippet": "static int destroy_container(void)\n{\n\tint status, ret;\n\tpid_t pid = fork();\n\n\tif (pid < 0) {\n\t\tperror(\"fork\");\n\t\treturn -1;\n\t}\n\tif (pid == 0) {\n\t\tret = execlp(\"lxc-destroy\", \"lxc-destroy\", \"-f\", \"-n\", MYNAME, NULL);\n\t\t// Should not return\n\t\tperror(\"execl\");\n\t\texit(1);\n\t}\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\tperror(\"waitpid\");\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\tif (!WIFEXITED(status))  { // did not exit normally\n\t\tfprintf(stderr, \"%d: lxc-create exited abnormally\\n\", __LINE__);\n\t\treturn -1;\n\t}\n\treturn WEXITSTATUS(status);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <lxc/lxccontainer.h>"
          ],
          "macros_used": [
            "#define MYNAME \"lxctest1\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <unistd.h>\n#include <lxc/lxccontainer.h>\n\n#define MYNAME \"lxctest1\"\n\nstatic int destroy_container(void)\n{\n\tint status, ret;\n\tpid_t pid = fork();\n\n\tif (pid < 0) {\n\t\tperror(\"fork\");\n\t\treturn -1;\n\t}\n\tif (pid == 0) {\n\t\tret = execlp(\"lxc-destroy\", \"lxc-destroy\", \"-f\", \"-n\", MYNAME, NULL);\n\t\t// Should not return\n\t\tperror(\"execl\");\n\t\texit(1);\n\t}\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\tperror(\"waitpid\");\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\tif (!WIFEXITED(status))  { // did not exit normally\n\t\tfprintf(stderr, \"%d: lxc-create exited abnormally\\n\", __LINE__);\n\t\treturn -1;\n\t}\n\treturn WEXITSTATUS(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->stop",
          "args": [
            "c"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"all lxc_container tests passed for %s\\n\"",
            "c->name"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d: failed to lxc-execute /bin/hostname\\n\"",
            "__LINE__"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->startl",
          "args": [
            "c",
            "1",
            "\"/bin/hostname\"",
            "NULL"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d: failed to installing lxc-init in container\\n\"",
            "__LINE__"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "\"chroot \" LXCPATH \"/lxctest1/rootfs apt-get install --no-install-recommends lxc\""
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "mount_entry_on_systemfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1871-1889",
          "snippet": "static inline int mount_entry_on_systemfs(struct mntent *mntent)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\n\t/* For containers created without a rootfs all mounts are treated as\n\t * absolute paths starting at / on the host. */\n\tif (mntent->mnt_dir[0] != '/')\n\t\tret = snprintf(path, sizeof(path), \"/%s\", mntent->mnt_dir);\n\telse\n\t\tret = snprintf(path, sizeof(path), \"%s\", mntent->mnt_dir);\n\n\tif (ret < 0 || ret >= sizeof(path)) {\n\t\tERROR(\"path name too long\");\n\t\treturn -1;\n\t}\n\n\treturn mount_entry_on_generic(mntent, path, NULL, NULL, NULL);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic inline int mount_entry_on_systemfs(struct mntent *mntent)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\n\t/* For containers created without a rootfs all mounts are treated as\n\t * absolute paths starting at / on the host. */\n\tif (mntent->mnt_dir[0] != '/')\n\t\tret = snprintf(path, sizeof(path), \"/%s\", mntent->mnt_dir);\n\telse\n\t\tret = snprintf(path, sizeof(path), \"%s\", mntent->mnt_dir);\n\n\tif (ret < 0 || ret >= sizeof(path)) {\n\t\tERROR(\"path name too long\");\n\t\treturn -1;\n\t}\n\n\treturn mount_entry_on_generic(mntent, path, NULL, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->stop",
          "args": [
            "c"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->set_cgroup_item",
          "args": [
            "c",
            "\"freezer.state\"",
            "\"THAWED\""
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d: not able to get freezer.state (len %d buf %s)\\n\"",
            "__LINE__",
            "len",
            "buf"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "buf",
            "\"FROZEN\\n\""
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "buf",
            "\"FREEZING\\n\""
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->get_cgroup_item",
          "args": [
            "c",
            "\"freezer.state\"",
            "buf",
            "200"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"XXX\""
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d: not able to set freezer.state.\\n\"",
            "__LINE__"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->set_cgroup_item",
          "args": [
            "c",
            "\"freezer.state\"",
            "buf"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"FROZEN\""
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d: not able to get cpuset.cpus (len %d buf %s)\\n\"",
            "__LINE__",
            "len",
            "buf"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"0\"",
            "1"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->get_cgroup_item",
          "args": [
            "c",
            "\"cpuset.cpus\"",
            "buf",
            "200"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d: not able to get length of cpuset.cpus (ret %d)\\n\"",
            "__LINE__",
            "len"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->get_cgroup_item",
          "args": [
            "c",
            "\"cpuset.cpus\"",
            "buf",
            "0"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d: %s is in state %s, not in RUNNING.\\n\"",
            "__LINE__",
            "c->name",
            "s ? s : \"undefined\""
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"RUNNING\""
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->state",
          "args": [
            "c"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "3"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_util_usleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lua-lxc/core.c",
          "lines": "564-567",
          "snippet": "static int lxc_util_usleep(lua_State *L) {\n    usleep((useconds_t)luaL_checkunsigned(L, 1));\n    return 0;\n}",
          "includes": [
            "#include \"lxc/commands.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <libgen.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <assert.h>",
            "#include <lauxlib.h>",
            "#include <lua.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxc/commands.h\"\n#include <lxc/lxccontainer.h>\n#include <libgen.h>\n#include <unistd.h>\n#include <string.h>\n#include <assert.h>\n#include <lauxlib.h>\n#include <lua.h>\n\nstatic int lxc_util_usleep(lua_State *L) {\n    usleep((useconds_t)luaL_checkunsigned(L, 1));\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d: %s failed to start\\n\"",
            "__LINE__",
            "c->name"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->startl",
          "args": [
            "c",
            "0",
            "NULL"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->want_daemonize",
          "args": [
            "c",
            "true"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d: failed to get extra ref to container\\n\"",
            "__LINE__"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_container_get",
          "args": [
            "c"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "290-310",
          "snippet": "int lxc_container_get(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn 0;\n\n\t// if someone else has already started freeing the container, don't\n\t// try to take the lock, which may be invalid\n\tif (c->numthreads < 1)\n\t\treturn 0;\n\n\tif (container_mem_lock(c))\n\t\treturn 0;\n\tif (c->numthreads < 1) {\n\t\t// bail without trying to unlock, bc the privlock is now probably\n\t\t// in freed memory\n\t\treturn 0;\n\t}\n\tc->numthreads++;\n\tcontainer_mem_unlock(c);\n\treturn 1;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint lxc_container_get(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn 0;\n\n\t// if someone else has already started freeing the container, don't\n\t// try to take the lock, which may be invalid\n\tif (c->numthreads < 1)\n\t\treturn 0;\n\n\tif (container_mem_lock(c))\n\t\treturn 0;\n\tif (c->numthreads < 1) {\n\t\t// bail without trying to unlock, bc the privlock is now probably\n\t\t// in freed memory\n\t\treturn 0;\n\t}\n\tc->numthreads++;\n\tcontainer_mem_unlock(c);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d: failed setting lxc.utsname\\n\"",
            "__LINE__"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->set_config_item",
          "args": [
            "c",
            "\"lxc.utsname\"",
            "\"bobo\""
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d: %s failed to read its config\\n\"",
            "__LINE__",
            "c->name"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->load_config",
          "args": [
            "c",
            "NULL"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d: %s is in state %s, not in STOPPED.\\n\"",
            "__LINE__",
            "c->name",
            "s ? s : \"undefined\""
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"STOPPED\""
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->state",
          "args": [
            "c"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d: %s not running but coudl set cgroup settings\\n\"",
            "__LINE__",
            "MYNAME"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->set_cgroup_item",
          "args": [
            "c",
            "\"cpuset.cpus\"",
            "buf"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"0\""
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d: %s not running but had cgroup settings\\n\"",
            "__LINE__",
            "MYNAME"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->get_cgroup_item",
          "args": [
            "c",
            "\"cpuset.cpus\"",
            "buf",
            "200"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d: %s thought it was not defined\\n\"",
            "__LINE__",
            "MYNAME"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->is_defined",
          "args": [
            "c"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d: failed to create a container\\n\"",
            "__LINE__"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_container",
          "args": [],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "create_container",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/startone.c",
          "lines": "65-95",
          "snippet": "static int create_container(void)\n{\n\tint status, ret;\n\tpid_t pid = fork();\n\n\tif (pid < 0) {\n\t\tperror(\"fork\");\n\t\treturn -1;\n\t}\n\tif (pid == 0) {\n\t\tret = execlp(\"lxc-create\", \"lxc-create\", \"-t\", \"busybox\", \"-n\", MYNAME, NULL);\n\t\t// Should not return\n\t\tperror(\"execl\");\n\t\texit(1);\n\t}\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\tperror(\"waitpid\");\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\tif (!WIFEXITED(status))  { // did not exit normally\n\t\tfprintf(stderr, \"%d: lxc-create exited abnormally\\n\", __LINE__);\n\t\treturn -1;\n\t}\n\treturn WEXITSTATUS(status);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <lxc/lxccontainer.h>"
          ],
          "macros_used": [
            "#define MYNAME \"lxctest1\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <unistd.h>\n#include <lxc/lxccontainer.h>\n\n#define MYNAME \"lxctest1\"\n\nstatic int create_container(void)\n{\n\tint status, ret;\n\tpid_t pid = fork();\n\n\tif (pid < 0) {\n\t\tperror(\"fork\");\n\t\treturn -1;\n\t}\n\tif (pid == 0) {\n\t\tret = execlp(\"lxc-create\", \"lxc-create\", \"-t\", \"busybox\", \"-n\", MYNAME, NULL);\n\t\t// Should not return\n\t\tperror(\"execl\");\n\t\texit(1);\n\t}\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\tperror(\"waitpid\");\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\tif (!WIFEXITED(status))  { // did not exit normally\n\t\tfprintf(stderr, \"%d: lxc-create exited abnormally\\n\", __LINE__);\n\t\treturn -1;\n\t}\n\treturn WEXITSTATUS(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d: %s thought it was defined\\n\"",
            "__LINE__",
            "MYNAME"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->is_defined",
          "args": [
            "c"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d: error creating lxc_container %s\\n\"",
            "__LINE__",
            "MYNAME"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_container_new",
          "args": [
            "MYNAME",
            "NULL"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "4099-4218",
          "snippet": "struct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstruct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <unistd.h>\n#include <lxc/lxccontainer.h>\n\n#define MYNAME \"lxctest1\"\n\nint main(int argc, char *argv[])\n{\n\tstruct lxc_container *c;\n\tint ret = 0;\n\tconst char *s;\n\tbool b;\n\tchar buf[201];\n\tint len;\n\n\tret = 1;\n\t/* test a real container */\n\tc = lxc_container_new(MYNAME, NULL);\n\tif (!c) {\n\t\tfprintf(stderr, \"%d: error creating lxc_container %s\\n\", __LINE__, MYNAME);\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tif (c->is_defined(c)) {\n\t\tfprintf(stderr, \"%d: %s thought it was defined\\n\", __LINE__, MYNAME);\n\t\tgoto out;\n\t}\n\n\tret = create_container();\n\tif (ret) {\n\t\tfprintf(stderr, \"%d: failed to create a container\\n\", __LINE__);\n\t\tgoto out;\n\t}\n\n\tb = c->is_defined(c);\n\tif (!b) {\n\t\tfprintf(stderr, \"%d: %s thought it was not defined\\n\", __LINE__, MYNAME);\n\t\tgoto out;\n\t}\n\n\tlen = c->get_cgroup_item(c, \"cpuset.cpus\", buf, 200);\n\tif (len >= 0) {\n\t\tfprintf(stderr, \"%d: %s not running but had cgroup settings\\n\", __LINE__, MYNAME);\n\t\tgoto out;\n\t}\n\n\tsprintf(buf, \"0\");\n\tb = c->set_cgroup_item(c, \"cpuset.cpus\", buf);\n\tif (b) {\n\t\tfprintf(stderr, \"%d: %s not running but coudl set cgroup settings\\n\", __LINE__, MYNAME);\n\t\tgoto out;\n\t}\n\n\ts = c->state(c);\n\tif (!s || strcmp(s, \"STOPPED\")) {\n\t\tfprintf(stderr, \"%d: %s is in state %s, not in STOPPED.\\n\", __LINE__, c->name, s ? s : \"undefined\");\n\t\tgoto out;\n\t}\n\n\tb = c->load_config(c, NULL);\n\tif (!b) {\n\t\tfprintf(stderr, \"%d: %s failed to read its config\\n\", __LINE__, c->name);\n\t\tgoto out;\n\t}\n\n\tif (!c->set_config_item(c, \"lxc.utsname\", \"bobo\")) {\n\t\tfprintf(stderr, \"%d: failed setting lxc.utsname\\n\", __LINE__);\n\t\tgoto out;\n\t}\n\n\tif (!lxc_container_get(c)) {\n\t\tfprintf(stderr, \"%d: failed to get extra ref to container\\n\", __LINE__);\n\t\texit(1);\n\t}\n\n\tc->want_daemonize(c, true);\n\tif (!c->startl(c, 0, NULL)) {\n\t\tfprintf(stderr, \"%d: %s failed to start\\n\", __LINE__, c->name);\n\t\texit(1);\n\t}\n\n\tsleep(3);\n\ts = c->state(c);\n\tif (!s || strcmp(s, \"RUNNING\")) {\n\t\tfprintf(stderr, \"%d: %s is in state %s, not in RUNNING.\\n\", __LINE__, c->name, s ? s : \"undefined\");\n\t\tgoto out;\n\t}\n\n\tlen = c->get_cgroup_item(c, \"cpuset.cpus\", buf, 0);\n\tif (len <= 0) {\n\t\tfprintf(stderr, \"%d: not able to get length of cpuset.cpus (ret %d)\\n\", __LINE__, len);\n\t\tgoto out;\n\t}\n\n\tlen = c->get_cgroup_item(c, \"cpuset.cpus\", buf, 200);\n\tif (len <= 0 || strncmp(buf, \"0\", 1)) {\n\t\tfprintf(stderr, \"%d: not able to get cpuset.cpus (len %d buf %s)\\n\", __LINE__, len, buf);\n\t\tgoto out;\n\t}\n\n\tsprintf(buf, \"FROZEN\");\n\tb = c->set_cgroup_item(c, \"freezer.state\", buf);\n\tif (!b) {\n\t\tfprintf(stderr, \"%d: not able to set freezer.state.\\n\", __LINE__);\n\t\tgoto out;\n\t}\n\n    sprintf(buf, \"XXX\");\n\tlen = c->get_cgroup_item(c, \"freezer.state\", buf, 200);\n\tif (len <= 0 || (strcmp(buf, \"FREEZING\\n\") && strcmp(buf, \"FROZEN\\n\"))) {\n\t\tfprintf(stderr, \"%d: not able to get freezer.state (len %d buf %s)\\n\", __LINE__, len, buf);\n\t\tgoto out;\n\t}\n\n\tc->set_cgroup_item(c, \"freezer.state\", \"THAWED\");\n\n\tc->stop(c);\n\n    /* feh - multilib has moved the lxc-init crap */\n#if 0\n    goto ok;\n\n\tret = system(\"mkdir -p \" LXCPATH \"/lxctest1/rootfs//usr/local/libexec/lxc\");\n\tif (!ret)\n\t\tret = system(\"mkdir -p \" LXCPATH \"/lxctest1/rootfs/usr/lib/lxc/\");\n\tif (!ret)\n\t\tret = system(\"cp src/lxc/lxc-init \" LXCPATH \"/lxctest1/rootfs//usr/local/libexec/lxc\");\n\tif (!ret)\n\t\tret = system(\"cp src/lxc/liblxc.so \" LXCPATH \"/lxctest1/rootfs/usr/lib/lxc\");\n\tif (!ret)\n\t\tret = system(\"cp src/lxc/liblxc.so \" LXCPATH \"/lxctest1/rootfs/usr/lib/lxc/liblxc.so.0\");\n\tif (!ret)\n\t\tret = system(\"cp src/lxc/liblxc.so \" LXCPATH \"/lxctest1/rootfs/usr/lib\");\n\tif (!ret)\n\t\tret = system(\"mkdir -p \" LXCPATH \"/lxctest1/rootfs/dev/shm\");\n\tif (!ret)\n\t\tret = system(\"chroot \" LXCPATH \"/lxctest1/rootfs apt-get install --no-install-recommends lxc\");\n\tif (ret) {\n\t\tfprintf(stderr, \"%d: failed to installing lxc-init in container\\n\", __LINE__);\n\t\tgoto out;\n\t}\n\t// next write out the config file;  does it match?\n\tif (!c->startl(c, 1, \"/bin/hostname\", NULL)) {\n\t\tfprintf(stderr, \"%d: failed to lxc-execute /bin/hostname\\n\", __LINE__);\n\t\tgoto out;\n\t}\n\t//  auto-check result?  ('bobo' is printed on stdout)\n\nok:\n#endif\n\tfprintf(stderr, \"all lxc_container tests passed for %s\\n\", c->name);\n\tret = 0;\n\nout:\n\tif (c) {\n\t\tc->stop(c);\n\t\tdestroy_container();\n\t}\n\tlxc_container_put(c);\n\texit(ret);\n}"
  },
  {
    "function_name": "create_container",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/startone.c",
    "lines": "65-95",
    "snippet": "static int create_container(void)\n{\n\tint status, ret;\n\tpid_t pid = fork();\n\n\tif (pid < 0) {\n\t\tperror(\"fork\");\n\t\treturn -1;\n\t}\n\tif (pid == 0) {\n\t\tret = execlp(\"lxc-create\", \"lxc-create\", \"-t\", \"busybox\", \"-n\", MYNAME, NULL);\n\t\t// Should not return\n\t\tperror(\"execl\");\n\t\texit(1);\n\t}\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\tperror(\"waitpid\");\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\tif (!WIFEXITED(status))  { // did not exit normally\n\t\tfprintf(stderr, \"%d: lxc-create exited abnormally\\n\", __LINE__);\n\t\treturn -1;\n\t}\n\treturn WEXITSTATUS(status);\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <lxc/lxccontainer.h>"
    ],
    "macros_used": [
      "#define MYNAME \"lxctest1\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d: lxc-create exited abnormally\\n\"",
            "__LINE__"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"waitpid\""
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "0"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"execl\""
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "\"lxc-create\"",
            "\"lxc-create\"",
            "\"-t\"",
            "\"busybox\"",
            "\"-n\"",
            "MYNAME",
            "NULL"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"fork\""
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <unistd.h>\n#include <lxc/lxccontainer.h>\n\n#define MYNAME \"lxctest1\"\n\nstatic int create_container(void)\n{\n\tint status, ret;\n\tpid_t pid = fork();\n\n\tif (pid < 0) {\n\t\tperror(\"fork\");\n\t\treturn -1;\n\t}\n\tif (pid == 0) {\n\t\tret = execlp(\"lxc-create\", \"lxc-create\", \"-t\", \"busybox\", \"-n\", MYNAME, NULL);\n\t\t// Should not return\n\t\tperror(\"execl\");\n\t\texit(1);\n\t}\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\tperror(\"waitpid\");\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\tif (!WIFEXITED(status))  { // did not exit normally\n\t\tfprintf(stderr, \"%d: lxc-create exited abnormally\\n\", __LINE__);\n\t\treturn -1;\n\t}\n\treturn WEXITSTATUS(status);\n}"
  },
  {
    "function_name": "destroy_container",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/startone.c",
    "lines": "33-63",
    "snippet": "static int destroy_container(void)\n{\n\tint status, ret;\n\tpid_t pid = fork();\n\n\tif (pid < 0) {\n\t\tperror(\"fork\");\n\t\treturn -1;\n\t}\n\tif (pid == 0) {\n\t\tret = execlp(\"lxc-destroy\", \"lxc-destroy\", \"-f\", \"-n\", MYNAME, NULL);\n\t\t// Should not return\n\t\tperror(\"execl\");\n\t\texit(1);\n\t}\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\tperror(\"waitpid\");\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\tif (!WIFEXITED(status))  { // did not exit normally\n\t\tfprintf(stderr, \"%d: lxc-create exited abnormally\\n\", __LINE__);\n\t\treturn -1;\n\t}\n\treturn WEXITSTATUS(status);\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <lxc/lxccontainer.h>"
    ],
    "macros_used": [
      "#define MYNAME \"lxctest1\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d: lxc-create exited abnormally\\n\"",
            "__LINE__"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"waitpid\""
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "0"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"execl\""
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "\"lxc-destroy\"",
            "\"lxc-destroy\"",
            "\"-f\"",
            "\"-n\"",
            "MYNAME",
            "NULL"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"fork\""
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <unistd.h>\n#include <lxc/lxccontainer.h>\n\n#define MYNAME \"lxctest1\"\n\nstatic int destroy_container(void)\n{\n\tint status, ret;\n\tpid_t pid = fork();\n\n\tif (pid < 0) {\n\t\tperror(\"fork\");\n\t\treturn -1;\n\t}\n\tif (pid == 0) {\n\t\tret = execlp(\"lxc-destroy\", \"lxc-destroy\", \"-f\", \"-n\", MYNAME, NULL);\n\t\t// Should not return\n\t\tperror(\"execl\");\n\t\texit(1);\n\t}\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\tperror(\"waitpid\");\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\tif (!WIFEXITED(status))  { // did not exit normally\n\t\tfprintf(stderr, \"%d: lxc-create exited abnormally\\n\", __LINE__);\n\t\treturn -1;\n\t}\n\treturn WEXITSTATUS(status);\n}"
  }
]