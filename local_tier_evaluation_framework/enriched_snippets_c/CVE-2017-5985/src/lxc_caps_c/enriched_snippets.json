[
  {
    "function_name": "lxc_cap_is_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/caps.c",
    "lines": "212-233",
    "snippet": "bool lxc_cap_is_set(cap_value_t cap, cap_flag_t flag)\n{\n\tint ret;\n\tcap_t caps;\n\tcap_flag_value_t flagval;\n\n\tcaps = cap_get_proc();\n\tif (!caps) {\n\t\tERROR(\"Failed to perform cap_get_proc(): %s.\", strerror(errno));\n\t\treturn false;\n\t}\n\n\tret = cap_get_flag(caps, cap, flag, &flagval);\n\tif (ret < 0) {\n\t\tERROR(\"Failed to perform cap_get_flag(): %s.\", strerror(errno));\n\t\tcap_free(caps);\n\t\treturn false;\n\t}\n\n\tcap_free(caps);\n\treturn flagval == CAP_SET;\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"caps.h\"",
      "#include <sys/prctl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cap_free",
          "args": [
            "caps"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_free",
          "args": [
            "caps"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to perform cap_get_flag(): %s.\"",
            "strerror(errno)"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_get_flag",
          "args": [
            "caps",
            "cap",
            "flag",
            "&flagval"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to perform cap_get_proc(): %s.\"",
            "strerror(errno)"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_get_proc",
          "args": [],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"caps.h\"\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nbool lxc_cap_is_set(cap_value_t cap, cap_flag_t flag)\n{\n\tint ret;\n\tcap_t caps;\n\tcap_flag_value_t flagval;\n\n\tcaps = cap_get_proc();\n\tif (!caps) {\n\t\tERROR(\"Failed to perform cap_get_proc(): %s.\", strerror(errno));\n\t\treturn false;\n\t}\n\n\tret = cap_get_flag(caps, cap, flag, &flagval);\n\tif (ret < 0) {\n\t\tERROR(\"Failed to perform cap_get_flag(): %s.\", strerror(errno));\n\t\tcap_free(caps);\n\t\treturn false;\n\t}\n\n\tcap_free(caps);\n\treturn flagval == CAP_SET;\n}"
  },
  {
    "function_name": "lxc_caps_last_cap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/caps.c",
    "lines": "204-210",
    "snippet": "int lxc_caps_last_cap(void)\n{\n\tstatic int last_cap = -1;\n\tif (last_cap < 0) last_cap = _real_caps_last_cap();\n\n\treturn last_cap;\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"caps.h\"",
      "#include <sys/prctl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_real_caps_last_cap",
          "args": [],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "_real_caps_last_cap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/caps.c",
          "lines": "169-202",
          "snippet": "static int _real_caps_last_cap(void)\n{\n\tint fd;\n\tint result = -1;\n\n\t/* try to get the maximum capability over the kernel\n\t* interface introduced in v3.2 */\n\tfd = open(\"/proc/sys/kernel/cap_last_cap\", O_RDONLY);\n\tif (fd >= 0) {\n\t\tchar buf[32];\n\t\tchar *ptr;\n\t\tint n;\n\n\t\tif ((n = read(fd, buf, 31)) >= 0) {\n\t\t\tbuf[n] = '\\0';\n\t\t\terrno = 0;\n\t\t\tresult = strtol(buf, &ptr, 10);\n\t\t\tif (!ptr || (*ptr != '\\0' && *ptr != '\\n') || errno != 0)\n\t\t\t\tresult = -1;\n\t\t}\n\n\t\tclose(fd);\n\t}\n\n\t/* try to get it manually by trying to get the status of\n\t* each capability indiviually from the kernel */\n\tif (result < 0) {\n\t\tint cap = 0;\n\t\twhile (prctl(PR_CAPBSET_READ, cap) >= 0) cap++;\n\t\tresult = cap - 1;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"caps.h\"",
            "#include <sys/prctl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PR_CAPBSET_READ 23"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"caps.h\"\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\n#define PR_CAPBSET_READ 23\n\nstatic int _real_caps_last_cap(void)\n{\n\tint fd;\n\tint result = -1;\n\n\t/* try to get the maximum capability over the kernel\n\t* interface introduced in v3.2 */\n\tfd = open(\"/proc/sys/kernel/cap_last_cap\", O_RDONLY);\n\tif (fd >= 0) {\n\t\tchar buf[32];\n\t\tchar *ptr;\n\t\tint n;\n\n\t\tif ((n = read(fd, buf, 31)) >= 0) {\n\t\t\tbuf[n] = '\\0';\n\t\t\terrno = 0;\n\t\t\tresult = strtol(buf, &ptr, 10);\n\t\t\tif (!ptr || (*ptr != '\\0' && *ptr != '\\n') || errno != 0)\n\t\t\t\tresult = -1;\n\t\t}\n\n\t\tclose(fd);\n\t}\n\n\t/* try to get it manually by trying to get the status of\n\t* each capability indiviually from the kernel */\n\tif (result < 0) {\n\t\tint cap = 0;\n\t\twhile (prctl(PR_CAPBSET_READ, cap) >= 0) cap++;\n\t\tresult = cap - 1;\n\t}\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"caps.h\"\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nint lxc_caps_last_cap(void)\n{\n\tstatic int last_cap = -1;\n\tif (last_cap < 0) last_cap = _real_caps_last_cap();\n\n\treturn last_cap;\n}"
  },
  {
    "function_name": "_real_caps_last_cap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/caps.c",
    "lines": "169-202",
    "snippet": "static int _real_caps_last_cap(void)\n{\n\tint fd;\n\tint result = -1;\n\n\t/* try to get the maximum capability over the kernel\n\t* interface introduced in v3.2 */\n\tfd = open(\"/proc/sys/kernel/cap_last_cap\", O_RDONLY);\n\tif (fd >= 0) {\n\t\tchar buf[32];\n\t\tchar *ptr;\n\t\tint n;\n\n\t\tif ((n = read(fd, buf, 31)) >= 0) {\n\t\t\tbuf[n] = '\\0';\n\t\t\terrno = 0;\n\t\t\tresult = strtol(buf, &ptr, 10);\n\t\t\tif (!ptr || (*ptr != '\\0' && *ptr != '\\n') || errno != 0)\n\t\t\t\tresult = -1;\n\t\t}\n\n\t\tclose(fd);\n\t}\n\n\t/* try to get it manually by trying to get the status of\n\t* each capability indiviually from the kernel */\n\tif (result < 0) {\n\t\tint cap = 0;\n\t\twhile (prctl(PR_CAPBSET_READ, cap) >= 0) cap++;\n\t\tresult = cap - 1;\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"caps.h\"",
      "#include <sys/prctl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define PR_CAPBSET_READ 23"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "prctl",
          "args": [
            "PR_CAPBSET_READ",
            "cap"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "buf",
            "&ptr",
            "10"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "buf",
            "31"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "962-990",
          "snippet": "int lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/proc/sys/kernel/cap_last_cap\"",
            "O_RDONLY"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "genetlink_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/genl.c",
          "lines": "106-116",
          "snippet": "extern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"genl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/genetlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"genl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"caps.h\"\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\n#define PR_CAPBSET_READ 23\n\nstatic int _real_caps_last_cap(void)\n{\n\tint fd;\n\tint result = -1;\n\n\t/* try to get the maximum capability over the kernel\n\t* interface introduced in v3.2 */\n\tfd = open(\"/proc/sys/kernel/cap_last_cap\", O_RDONLY);\n\tif (fd >= 0) {\n\t\tchar buf[32];\n\t\tchar *ptr;\n\t\tint n;\n\n\t\tif ((n = read(fd, buf, 31)) >= 0) {\n\t\t\tbuf[n] = '\\0';\n\t\t\terrno = 0;\n\t\t\tresult = strtol(buf, &ptr, 10);\n\t\t\tif (!ptr || (*ptr != '\\0' && *ptr != '\\n') || errno != 0)\n\t\t\t\tresult = -1;\n\t\t}\n\n\t\tclose(fd);\n\t}\n\n\t/* try to get it manually by trying to get the status of\n\t* each capability indiviually from the kernel */\n\tif (result < 0) {\n\t\tint cap = 0;\n\t\twhile (prctl(PR_CAPBSET_READ, cap) >= 0) cap++;\n\t\tresult = cap - 1;\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "lxc_caps_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/caps.c",
    "lines": "128-167",
    "snippet": "int lxc_caps_init(void)\n{\n\tuid_t uid = getuid();\n\tgid_t gid = getgid();\n\tuid_t euid = geteuid();\n\n\tif (!uid) {\n\t\tINFO(\"command is run as 'root'\");\n\t\treturn 0;\n\t}\n\n\tif (uid && !euid) {\n\t\tINFO(\"command is run as setuid root (uid : %d)\", uid);\n\n\t\tif (prctl(PR_SET_KEEPCAPS, 1)) {\n\t\t\tERROR(\"failed to 'PR_SET_KEEPCAPS': %m\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (setresgid(gid, gid, gid)) {\n\t\t\tERROR(\"failed to change gid to '%d': %m\", gid);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (setresuid(uid, uid, uid)) {\n\t\t\tERROR(\"failed to change uid to '%d': %m\", uid);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (lxc_caps_up()) {\n\t\t\tERROR(\"failed to restore capabilities: %m\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (uid == euid)\n\t\tINFO(\"command is run as user '%d'\", uid);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"caps.h\"",
      "#include <sys/prctl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"command is run as user '%d'\"",
            "uid"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to restore capabilities: %m\""
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_caps_up",
          "args": [],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_caps_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/caps.c",
          "lines": "78-126",
          "snippet": "int lxc_caps_up(void)\n{\n\tcap_t caps;\n\tcap_value_t cap;\n\tint ret;\n\n\t/* when we are run as root, we don't want to play\n\t * with the capabilities */\n\tif (!getuid())\n\t\treturn 0;\n\n\tcaps = cap_get_proc();\n\tif (!caps) {\n\t\tERROR(\"failed to cap_get_proc: %m\");\n\t\treturn -1;\n\t}\n\n\tfor (cap = 0; cap <= CAP_LAST_CAP; cap++) {\n\n\t\tcap_flag_value_t flag;\n\n\t\tret = cap_get_flag(caps, cap, CAP_PERMITTED, &flag);\n\t\tif (ret) {\n\t\t\tif (errno == EINVAL) {\n\t\t\t\tINFO(\"Last supported cap was %d\", cap-1);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tERROR(\"failed to cap_get_flag: %m\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tret = cap_set_flag(caps, CAP_EFFECTIVE, 1, &cap, flag);\n\t\tif (ret) {\n\t\t\tERROR(\"failed to cap_set_flag: %m\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = cap_set_proc(caps);\n\tif (ret) {\n\t\tERROR(\"failed to cap_set_proc: %m\");\n\t\tgoto out;\n\t}\n\nout:\n\tcap_free(caps);\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"caps.h\"",
            "#include <sys/prctl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"caps.h\"\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nint lxc_caps_up(void)\n{\n\tcap_t caps;\n\tcap_value_t cap;\n\tint ret;\n\n\t/* when we are run as root, we don't want to play\n\t * with the capabilities */\n\tif (!getuid())\n\t\treturn 0;\n\n\tcaps = cap_get_proc();\n\tif (!caps) {\n\t\tERROR(\"failed to cap_get_proc: %m\");\n\t\treturn -1;\n\t}\n\n\tfor (cap = 0; cap <= CAP_LAST_CAP; cap++) {\n\n\t\tcap_flag_value_t flag;\n\n\t\tret = cap_get_flag(caps, cap, CAP_PERMITTED, &flag);\n\t\tif (ret) {\n\t\t\tif (errno == EINVAL) {\n\t\t\t\tINFO(\"Last supported cap was %d\", cap-1);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tERROR(\"failed to cap_get_flag: %m\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tret = cap_set_flag(caps, CAP_EFFECTIVE, 1, &cap, flag);\n\t\tif (ret) {\n\t\t\tERROR(\"failed to cap_set_flag: %m\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = cap_set_proc(caps);\n\tif (ret) {\n\t\tERROR(\"failed to cap_set_proc: %m\");\n\t\tgoto out;\n\t}\n\nout:\n\tcap_free(caps);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to change uid to '%d': %m\"",
            "uid"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setresuid",
          "args": [
            "uid",
            "uid",
            "uid"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to change gid to '%d': %m\"",
            "gid"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setresgid",
          "args": [
            "gid",
            "gid",
            "gid"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to 'PR_SET_KEEPCAPS': %m\""
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prctl",
          "args": [
            "PR_SET_KEEPCAPS",
            "1"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"command is run as setuid root (uid : %d)\"",
            "uid"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"command is run as 'root'\""
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"caps.h\"\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nint lxc_caps_init(void)\n{\n\tuid_t uid = getuid();\n\tgid_t gid = getgid();\n\tuid_t euid = geteuid();\n\n\tif (!uid) {\n\t\tINFO(\"command is run as 'root'\");\n\t\treturn 0;\n\t}\n\n\tif (uid && !euid) {\n\t\tINFO(\"command is run as setuid root (uid : %d)\", uid);\n\n\t\tif (prctl(PR_SET_KEEPCAPS, 1)) {\n\t\t\tERROR(\"failed to 'PR_SET_KEEPCAPS': %m\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (setresgid(gid, gid, gid)) {\n\t\t\tERROR(\"failed to change gid to '%d': %m\", gid);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (setresuid(uid, uid, uid)) {\n\t\t\tERROR(\"failed to change uid to '%d': %m\", uid);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (lxc_caps_up()) {\n\t\t\tERROR(\"failed to restore capabilities: %m\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (uid == euid)\n\t\tINFO(\"command is run as user '%d'\", uid);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_caps_up",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/caps.c",
    "lines": "78-126",
    "snippet": "int lxc_caps_up(void)\n{\n\tcap_t caps;\n\tcap_value_t cap;\n\tint ret;\n\n\t/* when we are run as root, we don't want to play\n\t * with the capabilities */\n\tif (!getuid())\n\t\treturn 0;\n\n\tcaps = cap_get_proc();\n\tif (!caps) {\n\t\tERROR(\"failed to cap_get_proc: %m\");\n\t\treturn -1;\n\t}\n\n\tfor (cap = 0; cap <= CAP_LAST_CAP; cap++) {\n\n\t\tcap_flag_value_t flag;\n\n\t\tret = cap_get_flag(caps, cap, CAP_PERMITTED, &flag);\n\t\tif (ret) {\n\t\t\tif (errno == EINVAL) {\n\t\t\t\tINFO(\"Last supported cap was %d\", cap-1);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tERROR(\"failed to cap_get_flag: %m\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tret = cap_set_flag(caps, CAP_EFFECTIVE, 1, &cap, flag);\n\t\tif (ret) {\n\t\t\tERROR(\"failed to cap_set_flag: %m\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = cap_set_proc(caps);\n\tif (ret) {\n\t\tERROR(\"failed to cap_set_proc: %m\");\n\t\tgoto out;\n\t}\n\nout:\n\tcap_free(caps);\n\treturn 0;\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"caps.h\"",
      "#include <sys/prctl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cap_free",
          "args": [
            "caps"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to cap_set_proc: %m\""
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_set_proc",
          "args": [
            "caps"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to cap_set_flag: %m\""
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_set_flag",
          "args": [
            "caps",
            "CAP_EFFECTIVE",
            "1",
            "&cap",
            "flag"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to cap_get_flag: %m\""
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Last supported cap was %d\"",
            "cap-1"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_get_flag",
          "args": [
            "caps",
            "cap",
            "CAP_PERMITTED",
            "&flag"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to cap_get_proc: %m\""
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_get_proc",
          "args": [],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"caps.h\"\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nint lxc_caps_up(void)\n{\n\tcap_t caps;\n\tcap_value_t cap;\n\tint ret;\n\n\t/* when we are run as root, we don't want to play\n\t * with the capabilities */\n\tif (!getuid())\n\t\treturn 0;\n\n\tcaps = cap_get_proc();\n\tif (!caps) {\n\t\tERROR(\"failed to cap_get_proc: %m\");\n\t\treturn -1;\n\t}\n\n\tfor (cap = 0; cap <= CAP_LAST_CAP; cap++) {\n\n\t\tcap_flag_value_t flag;\n\n\t\tret = cap_get_flag(caps, cap, CAP_PERMITTED, &flag);\n\t\tif (ret) {\n\t\t\tif (errno == EINVAL) {\n\t\t\t\tINFO(\"Last supported cap was %d\", cap-1);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tERROR(\"failed to cap_get_flag: %m\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tret = cap_set_flag(caps, CAP_EFFECTIVE, 1, &cap, flag);\n\t\tif (ret) {\n\t\t\tERROR(\"failed to cap_set_flag: %m\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = cap_set_proc(caps);\n\tif (ret) {\n\t\tERROR(\"failed to cap_set_proc: %m\");\n\t\tgoto out;\n\t}\n\nout:\n\tcap_free(caps);\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_caps_down",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/caps.c",
    "lines": "45-76",
    "snippet": "int lxc_caps_down(void)\n{\n\tcap_t caps;\n\tint ret;\n\n\t/* when we are run as root, we don't want to play\n\t * with the capabilities */\n\tif (!getuid())\n\t\treturn 0;\n\n\tcaps = cap_get_proc();\n\tif (!caps) {\n\t\tERROR(\"failed to cap_get_proc: %m\");\n\t\treturn -1;\n\t}\n\n\tret = cap_clear_flag(caps, CAP_EFFECTIVE);\n\tif (ret) {\n\t\tERROR(\"failed to cap_clear_flag: %m\");\n\t\tgoto out;\n\t}\n\n\tret = cap_set_proc(caps);\n\tif (ret) {\n\t\tERROR(\"failed to cap_set_proc: %m\");\n\t\tgoto out;\n\t}\n\nout:\n\tcap_free(caps);\n\treturn 0;\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"caps.h\"",
      "#include <sys/prctl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cap_free",
          "args": [
            "caps"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to cap_set_proc: %m\""
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_set_proc",
          "args": [
            "caps"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to cap_clear_flag: %m\""
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_clear_flag",
          "args": [
            "caps",
            "CAP_EFFECTIVE"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to cap_get_proc: %m\""
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_get_proc",
          "args": [],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"caps.h\"\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nint lxc_caps_down(void)\n{\n\tcap_t caps;\n\tint ret;\n\n\t/* when we are run as root, we don't want to play\n\t * with the capabilities */\n\tif (!getuid())\n\t\treturn 0;\n\n\tcaps = cap_get_proc();\n\tif (!caps) {\n\t\tERROR(\"failed to cap_get_proc: %m\");\n\t\treturn -1;\n\t}\n\n\tret = cap_clear_flag(caps, CAP_EFFECTIVE);\n\tif (ret) {\n\t\tERROR(\"failed to cap_clear_flag: %m\");\n\t\tgoto out;\n\t}\n\n\tret = cap_set_proc(caps);\n\tif (ret) {\n\t\tERROR(\"failed to cap_set_proc: %m\");\n\t\tgoto out;\n\t}\n\nout:\n\tcap_free(caps);\n\treturn 0;\n}"
  }
]