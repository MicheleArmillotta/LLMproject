[
  {
    "function_name": "freeifaddrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
    "lines": "590-599",
    "snippet": "void freeifaddrs(struct ifaddrs *ifa)\n{\n    struct ifaddrs *l_cur;\n    while(ifa)\n    {\n        l_cur = ifa;\n        ifa = ifa->ifa_next;\n        free(l_cur);\n    }\n}",
    "includes": [
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"ifaddrs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "l_cur"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "freeifaddrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
          "lines": "590-599",
          "snippet": "void freeifaddrs(struct ifaddrs *ifa)\n{\n    struct ifaddrs *l_cur;\n    while(ifa)\n    {\n        l_cur = ifa;\n        ifa = ifa->ifa_next;\n        free(l_cur);\n    }\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nvoid freeifaddrs(struct ifaddrs *ifa)\n{\n    struct ifaddrs *l_cur;\n    while(ifa)\n    {\n        l_cur = ifa;\n        ifa = ifa->ifa_next;\n        free(l_cur);\n    }\n}"
  },
  {
    "function_name": "getifaddrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
    "lines": "548-588",
    "snippet": "int getifaddrs(struct ifaddrs **ifap)\n{\n    if(!ifap)\n    {\n        return -1;\n    }\n    *ifap = NULL;\n\n    int l_socket = netlink_socket();\n    if(l_socket < 0)\n    {\n        return -1;\n    }\n\n    NetlinkList *l_linkResults = getResultList(l_socket, RTM_GETLINK);\n    if(!l_linkResults)\n    {\n        close(l_socket);\n        return -1;\n    }\n\n    NetlinkList *l_addrResults = getResultList(l_socket, RTM_GETADDR);\n    if(!l_addrResults)\n    {\n        close(l_socket);\n        freeResultList(l_linkResults);\n        return -1;\n    }\n\n    unsigned l_numLinks = countLinks(l_socket, l_linkResults) + countLinks(l_socket, l_addrResults);\n    struct ifaddrs *l_links[l_numLinks];\n    memset(l_links, 0, l_numLinks * sizeof(struct ifaddrs *));\n\n    interpret(l_socket, l_linkResults, l_links, ifap);\n    interpret(l_socket, l_addrResults, l_links, ifap);\n\n    freeResultList(l_linkResults);\n    freeResultList(l_addrResults);\n    close(l_socket);\n    return 0;\n}",
    "includes": [
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"ifaddrs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "l_socket"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "freeResultList",
          "args": [
            "l_addrResults"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "freeResultList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
          "lines": "174-184",
          "snippet": "static void freeResultList(NetlinkList *p_list)\n{\n    NetlinkList *l_cur;\n    while(p_list)\n    {\n        l_cur = p_list;\n        p_list = p_list->m_next;\n        free(l_cur->m_data);\n        free(l_cur);\n    }\n}",
          "includes": [
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"ifaddrs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nstatic void freeResultList(NetlinkList *p_list)\n{\n    NetlinkList *l_cur;\n    while(p_list)\n    {\n        l_cur = p_list;\n        p_list = p_list->m_next;\n        free(l_cur->m_data);\n        free(l_cur);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "interpret",
          "args": [
            "l_socket",
            "l_addrResults",
            "l_links",
            "ifap"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "interpret",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
          "lines": "487-516",
          "snippet": "static void interpret(int p_socket, NetlinkList *p_netlinkList, struct ifaddrs **p_links, struct ifaddrs **p_resultList)\n{\n    pid_t l_pid = getpid();\n    for(; p_netlinkList; p_netlinkList = p_netlinkList->m_next)\n    {\n        unsigned int l_nlsize = p_netlinkList->m_size;\n        struct nlmsghdr *l_hdr;\n        for(l_hdr = p_netlinkList->m_data; NLMSG_OK(l_hdr, l_nlsize); l_hdr = NLMSG_NEXT(l_hdr, l_nlsize))\n        {\n            if((pid_t)l_hdr->nlmsg_pid != l_pid || (int)l_hdr->nlmsg_seq != p_socket)\n            {\n                continue;\n            }\n\n            if(l_hdr->nlmsg_type == NLMSG_DONE)\n            {\n                break;\n            }\n\n            if(l_hdr->nlmsg_type == RTM_NEWLINK)\n            {\n                interpretLink(l_hdr, p_links, p_resultList);\n            }\n            else if(l_hdr->nlmsg_type == RTM_NEWADDR)\n            {\n                interpretAddr(l_hdr, p_links, p_resultList);\n            }\n        }\n    }\n}",
          "includes": [
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"ifaddrs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nstatic void interpret(int p_socket, NetlinkList *p_netlinkList, struct ifaddrs **p_links, struct ifaddrs **p_resultList)\n{\n    pid_t l_pid = getpid();\n    for(; p_netlinkList; p_netlinkList = p_netlinkList->m_next)\n    {\n        unsigned int l_nlsize = p_netlinkList->m_size;\n        struct nlmsghdr *l_hdr;\n        for(l_hdr = p_netlinkList->m_data; NLMSG_OK(l_hdr, l_nlsize); l_hdr = NLMSG_NEXT(l_hdr, l_nlsize))\n        {\n            if((pid_t)l_hdr->nlmsg_pid != l_pid || (int)l_hdr->nlmsg_seq != p_socket)\n            {\n                continue;\n            }\n\n            if(l_hdr->nlmsg_type == NLMSG_DONE)\n            {\n                break;\n            }\n\n            if(l_hdr->nlmsg_type == RTM_NEWLINK)\n            {\n                interpretLink(l_hdr, p_links, p_resultList);\n            }\n            else if(l_hdr->nlmsg_type == RTM_NEWADDR)\n            {\n                interpretAddr(l_hdr, p_links, p_resultList);\n            }\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "l_links",
            "0",
            "l_numLinks * sizeof(struct ifaddrs *)"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "countLinks",
          "args": [
            "l_socket",
            "l_addrResults"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "countLinks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
          "lines": "518-546",
          "snippet": "static unsigned countLinks(int p_socket, NetlinkList *p_netlinkList)\n{\n    unsigned l_links = 0;\n    pid_t l_pid = getpid();\n    for(; p_netlinkList; p_netlinkList = p_netlinkList->m_next)\n    {\n        unsigned int l_nlsize = p_netlinkList->m_size;\n        struct nlmsghdr *l_hdr;\n        for(l_hdr = p_netlinkList->m_data; NLMSG_OK(l_hdr, l_nlsize); l_hdr = NLMSG_NEXT(l_hdr, l_nlsize))\n        {\n            if((pid_t)l_hdr->nlmsg_pid != l_pid || (int)l_hdr->nlmsg_seq != p_socket)\n            {\n                continue;\n            }\n\n            if(l_hdr->nlmsg_type == NLMSG_DONE)\n            {\n                break;\n            }\n\n            if(l_hdr->nlmsg_type == RTM_NEWLINK)\n            {\n                ++l_links;\n            }\n        }\n    }\n\n    return l_links;\n}",
          "includes": [
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"ifaddrs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nstatic unsigned countLinks(int p_socket, NetlinkList *p_netlinkList)\n{\n    unsigned l_links = 0;\n    pid_t l_pid = getpid();\n    for(; p_netlinkList; p_netlinkList = p_netlinkList->m_next)\n    {\n        unsigned int l_nlsize = p_netlinkList->m_size;\n        struct nlmsghdr *l_hdr;\n        for(l_hdr = p_netlinkList->m_data; NLMSG_OK(l_hdr, l_nlsize); l_hdr = NLMSG_NEXT(l_hdr, l_nlsize))\n        {\n            if((pid_t)l_hdr->nlmsg_pid != l_pid || (int)l_hdr->nlmsg_seq != p_socket)\n            {\n                continue;\n            }\n\n            if(l_hdr->nlmsg_type == NLMSG_DONE)\n            {\n                break;\n            }\n\n            if(l_hdr->nlmsg_type == RTM_NEWLINK)\n            {\n                ++l_links;\n            }\n        }\n    }\n\n    return l_links;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getResultList",
          "args": [
            "l_socket",
            "RTM_GETADDR"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "getResultList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
          "lines": "186-218",
          "snippet": "static NetlinkList *getResultList(int p_socket, int p_request)\n{\n    if(netlink_send(p_socket, p_request) < 0)\n    {\n        return NULL;\n    }\n\n    NetlinkList *l_list = NULL;\n    NetlinkList *l_end = NULL;\n    int l_size;\n    int l_done = 0;\n    while(!l_done)\n    {\n        struct nlmsghdr *l_hdr = getNetlinkResponse(p_socket, &l_size, &l_done);\n        if(!l_hdr)\n        { // error\n            freeResultList(l_list);\n            return NULL;\n        }\n\n        NetlinkList *l_item = newListItem(l_hdr, l_size);\n        if(!l_list)\n        {\n            l_list = l_item;\n        }\n        else\n        {\n            l_end->m_next = l_item;\n        }\n        l_end = l_item;\n    }\n    return l_list;\n}",
          "includes": [
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"ifaddrs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nstatic NetlinkList *getResultList(int p_socket, int p_request)\n{\n    if(netlink_send(p_socket, p_request) < 0)\n    {\n        return NULL;\n    }\n\n    NetlinkList *l_list = NULL;\n    NetlinkList *l_end = NULL;\n    int l_size;\n    int l_done = 0;\n    while(!l_done)\n    {\n        struct nlmsghdr *l_hdr = getNetlinkResponse(p_socket, &l_size, &l_done);\n        if(!l_hdr)\n        { // error\n            freeResultList(l_list);\n            return NULL;\n        }\n\n        NetlinkList *l_item = newListItem(l_hdr, l_size);\n        if(!l_list)\n        {\n            l_list = l_item;\n        }\n        else\n        {\n            l_end->m_next = l_item;\n        }\n        l_end = l_item;\n    }\n    return l_list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_socket",
          "args": [],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "netlink_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
          "lines": "44-62",
          "snippet": "static int netlink_socket(void)\n{\n    int l_socket = socket(PF_NETLINK, SOCK_RAW, NETLINK_ROUTE);\n    if(l_socket < 0)\n    {\n        return -1;\n    }\n\n    struct sockaddr_nl l_addr;\n    memset(&l_addr, 0, sizeof(l_addr));\n    l_addr.nl_family = AF_NETLINK;\n    if(bind(l_socket, (struct sockaddr *)&l_addr, sizeof(l_addr)) < 0)\n    {\n        close(l_socket);\n        return -1;\n    }\n\n    return l_socket;\n}",
          "includes": [
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"ifaddrs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nstatic int netlink_socket(void)\n{\n    int l_socket = socket(PF_NETLINK, SOCK_RAW, NETLINK_ROUTE);\n    if(l_socket < 0)\n    {\n        return -1;\n    }\n\n    struct sockaddr_nl l_addr;\n    memset(&l_addr, 0, sizeof(l_addr));\n    l_addr.nl_family = AF_NETLINK;\n    if(bind(l_socket, (struct sockaddr *)&l_addr, sizeof(l_addr)) < 0)\n    {\n        close(l_socket);\n        return -1;\n    }\n\n    return l_socket;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nint getifaddrs(struct ifaddrs **ifap)\n{\n    if(!ifap)\n    {\n        return -1;\n    }\n    *ifap = NULL;\n\n    int l_socket = netlink_socket();\n    if(l_socket < 0)\n    {\n        return -1;\n    }\n\n    NetlinkList *l_linkResults = getResultList(l_socket, RTM_GETLINK);\n    if(!l_linkResults)\n    {\n        close(l_socket);\n        return -1;\n    }\n\n    NetlinkList *l_addrResults = getResultList(l_socket, RTM_GETADDR);\n    if(!l_addrResults)\n    {\n        close(l_socket);\n        freeResultList(l_linkResults);\n        return -1;\n    }\n\n    unsigned l_numLinks = countLinks(l_socket, l_linkResults) + countLinks(l_socket, l_addrResults);\n    struct ifaddrs *l_links[l_numLinks];\n    memset(l_links, 0, l_numLinks * sizeof(struct ifaddrs *));\n\n    interpret(l_socket, l_linkResults, l_links, ifap);\n    interpret(l_socket, l_addrResults, l_links, ifap);\n\n    freeResultList(l_linkResults);\n    freeResultList(l_addrResults);\n    close(l_socket);\n    return 0;\n}"
  },
  {
    "function_name": "countLinks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
    "lines": "518-546",
    "snippet": "static unsigned countLinks(int p_socket, NetlinkList *p_netlinkList)\n{\n    unsigned l_links = 0;\n    pid_t l_pid = getpid();\n    for(; p_netlinkList; p_netlinkList = p_netlinkList->m_next)\n    {\n        unsigned int l_nlsize = p_netlinkList->m_size;\n        struct nlmsghdr *l_hdr;\n        for(l_hdr = p_netlinkList->m_data; NLMSG_OK(l_hdr, l_nlsize); l_hdr = NLMSG_NEXT(l_hdr, l_nlsize))\n        {\n            if((pid_t)l_hdr->nlmsg_pid != l_pid || (int)l_hdr->nlmsg_seq != p_socket)\n            {\n                continue;\n            }\n\n            if(l_hdr->nlmsg_type == NLMSG_DONE)\n            {\n                break;\n            }\n\n            if(l_hdr->nlmsg_type == RTM_NEWLINK)\n            {\n                ++l_links;\n            }\n        }\n    }\n\n    return l_links;\n}",
    "includes": [
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"ifaddrs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NLMSG_NEXT",
          "args": [
            "l_hdr",
            "l_nlsize"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_OK",
          "args": [
            "l_hdr",
            "l_nlsize"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nstatic unsigned countLinks(int p_socket, NetlinkList *p_netlinkList)\n{\n    unsigned l_links = 0;\n    pid_t l_pid = getpid();\n    for(; p_netlinkList; p_netlinkList = p_netlinkList->m_next)\n    {\n        unsigned int l_nlsize = p_netlinkList->m_size;\n        struct nlmsghdr *l_hdr;\n        for(l_hdr = p_netlinkList->m_data; NLMSG_OK(l_hdr, l_nlsize); l_hdr = NLMSG_NEXT(l_hdr, l_nlsize))\n        {\n            if((pid_t)l_hdr->nlmsg_pid != l_pid || (int)l_hdr->nlmsg_seq != p_socket)\n            {\n                continue;\n            }\n\n            if(l_hdr->nlmsg_type == NLMSG_DONE)\n            {\n                break;\n            }\n\n            if(l_hdr->nlmsg_type == RTM_NEWLINK)\n            {\n                ++l_links;\n            }\n        }\n    }\n\n    return l_links;\n}"
  },
  {
    "function_name": "interpret",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
    "lines": "487-516",
    "snippet": "static void interpret(int p_socket, NetlinkList *p_netlinkList, struct ifaddrs **p_links, struct ifaddrs **p_resultList)\n{\n    pid_t l_pid = getpid();\n    for(; p_netlinkList; p_netlinkList = p_netlinkList->m_next)\n    {\n        unsigned int l_nlsize = p_netlinkList->m_size;\n        struct nlmsghdr *l_hdr;\n        for(l_hdr = p_netlinkList->m_data; NLMSG_OK(l_hdr, l_nlsize); l_hdr = NLMSG_NEXT(l_hdr, l_nlsize))\n        {\n            if((pid_t)l_hdr->nlmsg_pid != l_pid || (int)l_hdr->nlmsg_seq != p_socket)\n            {\n                continue;\n            }\n\n            if(l_hdr->nlmsg_type == NLMSG_DONE)\n            {\n                break;\n            }\n\n            if(l_hdr->nlmsg_type == RTM_NEWLINK)\n            {\n                interpretLink(l_hdr, p_links, p_resultList);\n            }\n            else if(l_hdr->nlmsg_type == RTM_NEWADDR)\n            {\n                interpretAddr(l_hdr, p_links, p_resultList);\n            }\n        }\n    }\n}",
    "includes": [
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"ifaddrs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "interpretAddr",
          "args": [
            "l_hdr",
            "p_links",
            "p_resultList"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "interpretAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
          "lines": "361-485",
          "snippet": "static void interpretAddr(struct nlmsghdr *p_hdr, struct ifaddrs **p_links, struct ifaddrs **p_resultList)\n{\n    struct ifaddrmsg *l_info = (struct ifaddrmsg *)NLMSG_DATA(p_hdr);\n\n    size_t l_nameSize = 0;\n    size_t l_addrSize = 0;\n\n    int l_addedNetmask = 0;\n\n    size_t l_rtaSize = NLMSG_PAYLOAD(p_hdr, sizeof(struct ifaddrmsg));\n    struct rtattr *l_rta;\n    for(l_rta = (struct rtattr *)(((char *)l_info) + NLMSG_ALIGN(sizeof(struct ifaddrmsg))); RTA_OK(l_rta, l_rtaSize); l_rta = RTA_NEXT(l_rta, l_rtaSize))\n    {\n        size_t l_rtaDataSize = RTA_PAYLOAD(l_rta);\n        if(l_info->ifa_family == AF_PACKET)\n        {\n            continue;\n        }\n\n        switch(l_rta->rta_type)\n        {\n            case IFA_ADDRESS:\n            case IFA_LOCAL:\n                if((l_info->ifa_family == AF_INET || l_info->ifa_family == AF_INET6) && !l_addedNetmask)\n                { // make room for netmask\n                    l_addrSize += NLMSG_ALIGN(calcAddrLen(l_info->ifa_family, l_rtaDataSize));\n                    l_addedNetmask = 1;\n                }\n            case IFA_BROADCAST:\n                l_addrSize += NLMSG_ALIGN(calcAddrLen(l_info->ifa_family, l_rtaDataSize));\n                break;\n            case IFA_LABEL:\n                l_nameSize += NLMSG_ALIGN(l_rtaSize + 1);\n                break;\n            default:\n                break;\n        }\n    }\n\n    struct ifaddrs *l_entry = malloc(sizeof(struct ifaddrs) + l_nameSize + l_addrSize);\n    memset(l_entry, 0, sizeof(struct ifaddrs));\n    l_entry->ifa_name = p_links[l_info->ifa_index - 1]->ifa_name;\n\n    char *l_name = ((char *)l_entry) + sizeof(struct ifaddrs);\n    char *l_addr = l_name + l_nameSize;\n\n    l_entry->ifa_flags = l_info->ifa_flags | p_links[l_info->ifa_index - 1]->ifa_flags;\n\n    l_rtaSize = NLMSG_PAYLOAD(p_hdr, sizeof(struct ifaddrmsg));\n    for(l_rta = (struct rtattr *)(((char *)l_info) + NLMSG_ALIGN(sizeof(struct ifaddrmsg))); RTA_OK(l_rta, l_rtaSize); l_rta = RTA_NEXT(l_rta, l_rtaSize))\n    {\n        void *l_rtaData = RTA_DATA(l_rta);\n        size_t l_rtaDataSize = RTA_PAYLOAD(l_rta);\n        switch(l_rta->rta_type)\n        {\n            case IFA_ADDRESS:\n            case IFA_BROADCAST:\n            case IFA_LOCAL:\n            {\n                size_t l_addrLen = calcAddrLen(l_info->ifa_family, l_rtaDataSize);\n                makeSockaddr(l_info->ifa_family, (struct sockaddr *)l_addr, l_rtaData, l_rtaDataSize);\n                if(l_info->ifa_family == AF_INET6)\n                {\n                    if(IN6_IS_ADDR_LINKLOCAL((struct in6_addr *)l_rtaData) || IN6_IS_ADDR_MC_LINKLOCAL((struct in6_addr *)l_rtaData))\n                    {\n                        ((struct sockaddr_in6 *)l_addr)->sin6_scope_id = l_info->ifa_index;\n                    }\n                }\n\n                if(l_rta->rta_type == IFA_ADDRESS)\n                { // apparently in a point-to-point network IFA_ADDRESS contains the dest address and IFA_LOCAL contains the local address\n                    if(l_entry->ifa_addr)\n                    {\n                        l_entry->ifa_dstaddr = (struct sockaddr *)l_addr;\n                    }\n                    else\n                    {\n                        l_entry->ifa_addr = (struct sockaddr *)l_addr;\n                    }\n                }\n                else if(l_rta->rta_type == IFA_LOCAL)\n                {\n                    if(l_entry->ifa_addr)\n                    {\n                        l_entry->ifa_dstaddr = l_entry->ifa_addr;\n                    }\n                    l_entry->ifa_addr = (struct sockaddr *)l_addr;\n                }\n                else\n                {\n                    l_entry->ifa_broadaddr = (struct sockaddr *)l_addr;\n                }\n                l_addr += NLMSG_ALIGN(l_addrLen);\n                break;\n            }\n            case IFA_LABEL:\n                strncpy(l_name, l_rtaData, l_rtaDataSize);\n                l_name[l_rtaDataSize] = '\\0';\n                l_entry->ifa_name = l_name;\n                break;\n            default:\n                break;\n        }\n    }\n\n    if(l_entry->ifa_addr && (l_entry->ifa_addr->sa_family == AF_INET || l_entry->ifa_addr->sa_family == AF_INET6))\n    {\n        unsigned l_maxPrefix = (l_entry->ifa_addr->sa_family == AF_INET ? 32 : 128);\n        unsigned l_prefix = (l_info->ifa_prefixlen > l_maxPrefix ? l_maxPrefix : l_info->ifa_prefixlen);\n        char l_mask[16] = {0};\n        unsigned i;\n        for(i=0; i<(l_prefix/8); ++i)\n        {\n            l_mask[i] = 0xff;\n        }\n        if (l_prefix % 8) {\n            l_mask[i] = 0xff << (8 - (l_prefix % 8));\n        }\n\n        makeSockaddr(l_entry->ifa_addr->sa_family, (struct sockaddr *)l_addr, l_mask, l_maxPrefix / 8);\n        l_entry->ifa_netmask = (struct sockaddr *)l_addr;\n    }\n\n    addToEnd(p_resultList, l_entry);\n}",
          "includes": [
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"ifaddrs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nstatic void interpretAddr(struct nlmsghdr *p_hdr, struct ifaddrs **p_links, struct ifaddrs **p_resultList)\n{\n    struct ifaddrmsg *l_info = (struct ifaddrmsg *)NLMSG_DATA(p_hdr);\n\n    size_t l_nameSize = 0;\n    size_t l_addrSize = 0;\n\n    int l_addedNetmask = 0;\n\n    size_t l_rtaSize = NLMSG_PAYLOAD(p_hdr, sizeof(struct ifaddrmsg));\n    struct rtattr *l_rta;\n    for(l_rta = (struct rtattr *)(((char *)l_info) + NLMSG_ALIGN(sizeof(struct ifaddrmsg))); RTA_OK(l_rta, l_rtaSize); l_rta = RTA_NEXT(l_rta, l_rtaSize))\n    {\n        size_t l_rtaDataSize = RTA_PAYLOAD(l_rta);\n        if(l_info->ifa_family == AF_PACKET)\n        {\n            continue;\n        }\n\n        switch(l_rta->rta_type)\n        {\n            case IFA_ADDRESS:\n            case IFA_LOCAL:\n                if((l_info->ifa_family == AF_INET || l_info->ifa_family == AF_INET6) && !l_addedNetmask)\n                { // make room for netmask\n                    l_addrSize += NLMSG_ALIGN(calcAddrLen(l_info->ifa_family, l_rtaDataSize));\n                    l_addedNetmask = 1;\n                }\n            case IFA_BROADCAST:\n                l_addrSize += NLMSG_ALIGN(calcAddrLen(l_info->ifa_family, l_rtaDataSize));\n                break;\n            case IFA_LABEL:\n                l_nameSize += NLMSG_ALIGN(l_rtaSize + 1);\n                break;\n            default:\n                break;\n        }\n    }\n\n    struct ifaddrs *l_entry = malloc(sizeof(struct ifaddrs) + l_nameSize + l_addrSize);\n    memset(l_entry, 0, sizeof(struct ifaddrs));\n    l_entry->ifa_name = p_links[l_info->ifa_index - 1]->ifa_name;\n\n    char *l_name = ((char *)l_entry) + sizeof(struct ifaddrs);\n    char *l_addr = l_name + l_nameSize;\n\n    l_entry->ifa_flags = l_info->ifa_flags | p_links[l_info->ifa_index - 1]->ifa_flags;\n\n    l_rtaSize = NLMSG_PAYLOAD(p_hdr, sizeof(struct ifaddrmsg));\n    for(l_rta = (struct rtattr *)(((char *)l_info) + NLMSG_ALIGN(sizeof(struct ifaddrmsg))); RTA_OK(l_rta, l_rtaSize); l_rta = RTA_NEXT(l_rta, l_rtaSize))\n    {\n        void *l_rtaData = RTA_DATA(l_rta);\n        size_t l_rtaDataSize = RTA_PAYLOAD(l_rta);\n        switch(l_rta->rta_type)\n        {\n            case IFA_ADDRESS:\n            case IFA_BROADCAST:\n            case IFA_LOCAL:\n            {\n                size_t l_addrLen = calcAddrLen(l_info->ifa_family, l_rtaDataSize);\n                makeSockaddr(l_info->ifa_family, (struct sockaddr *)l_addr, l_rtaData, l_rtaDataSize);\n                if(l_info->ifa_family == AF_INET6)\n                {\n                    if(IN6_IS_ADDR_LINKLOCAL((struct in6_addr *)l_rtaData) || IN6_IS_ADDR_MC_LINKLOCAL((struct in6_addr *)l_rtaData))\n                    {\n                        ((struct sockaddr_in6 *)l_addr)->sin6_scope_id = l_info->ifa_index;\n                    }\n                }\n\n                if(l_rta->rta_type == IFA_ADDRESS)\n                { // apparently in a point-to-point network IFA_ADDRESS contains the dest address and IFA_LOCAL contains the local address\n                    if(l_entry->ifa_addr)\n                    {\n                        l_entry->ifa_dstaddr = (struct sockaddr *)l_addr;\n                    }\n                    else\n                    {\n                        l_entry->ifa_addr = (struct sockaddr *)l_addr;\n                    }\n                }\n                else if(l_rta->rta_type == IFA_LOCAL)\n                {\n                    if(l_entry->ifa_addr)\n                    {\n                        l_entry->ifa_dstaddr = l_entry->ifa_addr;\n                    }\n                    l_entry->ifa_addr = (struct sockaddr *)l_addr;\n                }\n                else\n                {\n                    l_entry->ifa_broadaddr = (struct sockaddr *)l_addr;\n                }\n                l_addr += NLMSG_ALIGN(l_addrLen);\n                break;\n            }\n            case IFA_LABEL:\n                strncpy(l_name, l_rtaData, l_rtaDataSize);\n                l_name[l_rtaDataSize] = '\\0';\n                l_entry->ifa_name = l_name;\n                break;\n            default:\n                break;\n        }\n    }\n\n    if(l_entry->ifa_addr && (l_entry->ifa_addr->sa_family == AF_INET || l_entry->ifa_addr->sa_family == AF_INET6))\n    {\n        unsigned l_maxPrefix = (l_entry->ifa_addr->sa_family == AF_INET ? 32 : 128);\n        unsigned l_prefix = (l_info->ifa_prefixlen > l_maxPrefix ? l_maxPrefix : l_info->ifa_prefixlen);\n        char l_mask[16] = {0};\n        unsigned i;\n        for(i=0; i<(l_prefix/8); ++i)\n        {\n            l_mask[i] = 0xff;\n        }\n        if (l_prefix % 8) {\n            l_mask[i] = 0xff << (8 - (l_prefix % 8));\n        }\n\n        makeSockaddr(l_entry->ifa_addr->sa_family, (struct sockaddr *)l_addr, l_mask, l_maxPrefix / 8);\n        l_entry->ifa_netmask = (struct sockaddr *)l_addr;\n    }\n\n    addToEnd(p_resultList, l_entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "interpretLink",
          "args": [
            "l_hdr",
            "p_links",
            "p_resultList"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "interpretLink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
          "lines": "278-359",
          "snippet": "static void interpretLink(struct nlmsghdr *p_hdr, struct ifaddrs **p_links, struct ifaddrs **p_resultList)\n{\n    struct ifinfomsg *l_info = (struct ifinfomsg *)NLMSG_DATA(p_hdr);\n\n    size_t l_nameSize = 0;\n    size_t l_addrSize = 0;\n    size_t l_dataSize = 0;\n\n    size_t l_rtaSize = NLMSG_PAYLOAD(p_hdr, sizeof(struct ifinfomsg));\n    struct rtattr *l_rta;\n    for(l_rta = (struct rtattr *)(((char *)l_info) + NLMSG_ALIGN(sizeof(struct ifinfomsg))); RTA_OK(l_rta, l_rtaSize); l_rta = RTA_NEXT(l_rta, l_rtaSize))\n    {\n        size_t l_rtaDataSize = RTA_PAYLOAD(l_rta);\n        switch(l_rta->rta_type)\n        {\n            case IFLA_ADDRESS:\n            case IFLA_BROADCAST:\n                l_addrSize += NLMSG_ALIGN(calcAddrLen(AF_PACKET, l_rtaDataSize));\n                break;\n            case IFLA_IFNAME:\n                l_nameSize += NLMSG_ALIGN(l_rtaSize + 1);\n                break;\n            case IFLA_STATS:\n                l_dataSize += NLMSG_ALIGN(l_rtaSize);\n                break;\n            default:\n                break;\n        }\n    }\n\n    struct ifaddrs *l_entry = malloc(sizeof(struct ifaddrs) + l_nameSize + l_addrSize + l_dataSize);\n    memset(l_entry, 0, sizeof(struct ifaddrs));\n    l_entry->ifa_name = \"\";\n\n    char *l_name = ((char *)l_entry) + sizeof(struct ifaddrs);\n    char *l_addr = l_name + l_nameSize;\n    char *l_data = l_addr + l_addrSize;\n\n    l_entry->ifa_flags = l_info->ifi_flags;\n\n    l_rtaSize = NLMSG_PAYLOAD(p_hdr, sizeof(struct ifinfomsg));\n    for(l_rta = (struct rtattr *)(((char *)l_info) + NLMSG_ALIGN(sizeof(struct ifinfomsg))); RTA_OK(l_rta, l_rtaSize); l_rta = RTA_NEXT(l_rta, l_rtaSize))\n    {\n        void *l_rtaData = RTA_DATA(l_rta);\n        size_t l_rtaDataSize = RTA_PAYLOAD(l_rta);\n        switch(l_rta->rta_type)\n        {\n            case IFLA_ADDRESS:\n            case IFLA_BROADCAST:\n            {\n                size_t l_addrLen = calcAddrLen(AF_PACKET, l_rtaDataSize);\n                makeSockaddr(AF_PACKET, (struct sockaddr *)l_addr, l_rtaData, l_rtaDataSize);\n                ((struct sockaddr_ll *)l_addr)->sll_ifindex = l_info->ifi_index;\n                ((struct sockaddr_ll *)l_addr)->sll_hatype = l_info->ifi_type;\n                if(l_rta->rta_type == IFLA_ADDRESS)\n                {\n                    l_entry->ifa_addr = (struct sockaddr *)l_addr;\n                }\n                else\n                {\n                    l_entry->ifa_broadaddr = (struct sockaddr *)l_addr;\n                }\n                l_addr += NLMSG_ALIGN(l_addrLen);\n                break;\n            }\n            case IFLA_IFNAME:\n                strncpy(l_name, l_rtaData, l_rtaDataSize);\n                l_name[l_rtaDataSize] = '\\0';\n                l_entry->ifa_name = l_name;\n                break;\n            case IFLA_STATS:\n                memcpy(l_data, l_rtaData, l_rtaDataSize);\n                l_entry->ifa_data = l_data;\n                break;\n            default:\n                break;\n        }\n    }\n\n    addToEnd(p_resultList, l_entry);\n    p_links[l_info->ifi_index - 1] = l_entry;\n}",
          "includes": [
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"ifaddrs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nstatic void interpretLink(struct nlmsghdr *p_hdr, struct ifaddrs **p_links, struct ifaddrs **p_resultList)\n{\n    struct ifinfomsg *l_info = (struct ifinfomsg *)NLMSG_DATA(p_hdr);\n\n    size_t l_nameSize = 0;\n    size_t l_addrSize = 0;\n    size_t l_dataSize = 0;\n\n    size_t l_rtaSize = NLMSG_PAYLOAD(p_hdr, sizeof(struct ifinfomsg));\n    struct rtattr *l_rta;\n    for(l_rta = (struct rtattr *)(((char *)l_info) + NLMSG_ALIGN(sizeof(struct ifinfomsg))); RTA_OK(l_rta, l_rtaSize); l_rta = RTA_NEXT(l_rta, l_rtaSize))\n    {\n        size_t l_rtaDataSize = RTA_PAYLOAD(l_rta);\n        switch(l_rta->rta_type)\n        {\n            case IFLA_ADDRESS:\n            case IFLA_BROADCAST:\n                l_addrSize += NLMSG_ALIGN(calcAddrLen(AF_PACKET, l_rtaDataSize));\n                break;\n            case IFLA_IFNAME:\n                l_nameSize += NLMSG_ALIGN(l_rtaSize + 1);\n                break;\n            case IFLA_STATS:\n                l_dataSize += NLMSG_ALIGN(l_rtaSize);\n                break;\n            default:\n                break;\n        }\n    }\n\n    struct ifaddrs *l_entry = malloc(sizeof(struct ifaddrs) + l_nameSize + l_addrSize + l_dataSize);\n    memset(l_entry, 0, sizeof(struct ifaddrs));\n    l_entry->ifa_name = \"\";\n\n    char *l_name = ((char *)l_entry) + sizeof(struct ifaddrs);\n    char *l_addr = l_name + l_nameSize;\n    char *l_data = l_addr + l_addrSize;\n\n    l_entry->ifa_flags = l_info->ifi_flags;\n\n    l_rtaSize = NLMSG_PAYLOAD(p_hdr, sizeof(struct ifinfomsg));\n    for(l_rta = (struct rtattr *)(((char *)l_info) + NLMSG_ALIGN(sizeof(struct ifinfomsg))); RTA_OK(l_rta, l_rtaSize); l_rta = RTA_NEXT(l_rta, l_rtaSize))\n    {\n        void *l_rtaData = RTA_DATA(l_rta);\n        size_t l_rtaDataSize = RTA_PAYLOAD(l_rta);\n        switch(l_rta->rta_type)\n        {\n            case IFLA_ADDRESS:\n            case IFLA_BROADCAST:\n            {\n                size_t l_addrLen = calcAddrLen(AF_PACKET, l_rtaDataSize);\n                makeSockaddr(AF_PACKET, (struct sockaddr *)l_addr, l_rtaData, l_rtaDataSize);\n                ((struct sockaddr_ll *)l_addr)->sll_ifindex = l_info->ifi_index;\n                ((struct sockaddr_ll *)l_addr)->sll_hatype = l_info->ifi_type;\n                if(l_rta->rta_type == IFLA_ADDRESS)\n                {\n                    l_entry->ifa_addr = (struct sockaddr *)l_addr;\n                }\n                else\n                {\n                    l_entry->ifa_broadaddr = (struct sockaddr *)l_addr;\n                }\n                l_addr += NLMSG_ALIGN(l_addrLen);\n                break;\n            }\n            case IFLA_IFNAME:\n                strncpy(l_name, l_rtaData, l_rtaDataSize);\n                l_name[l_rtaDataSize] = '\\0';\n                l_entry->ifa_name = l_name;\n                break;\n            case IFLA_STATS:\n                memcpy(l_data, l_rtaData, l_rtaDataSize);\n                l_entry->ifa_data = l_data;\n                break;\n            default:\n                break;\n        }\n    }\n\n    addToEnd(p_resultList, l_entry);\n    p_links[l_info->ifi_index - 1] = l_entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NLMSG_NEXT",
          "args": [
            "l_hdr",
            "l_nlsize"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_OK",
          "args": [
            "l_hdr",
            "l_nlsize"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nstatic void interpret(int p_socket, NetlinkList *p_netlinkList, struct ifaddrs **p_links, struct ifaddrs **p_resultList)\n{\n    pid_t l_pid = getpid();\n    for(; p_netlinkList; p_netlinkList = p_netlinkList->m_next)\n    {\n        unsigned int l_nlsize = p_netlinkList->m_size;\n        struct nlmsghdr *l_hdr;\n        for(l_hdr = p_netlinkList->m_data; NLMSG_OK(l_hdr, l_nlsize); l_hdr = NLMSG_NEXT(l_hdr, l_nlsize))\n        {\n            if((pid_t)l_hdr->nlmsg_pid != l_pid || (int)l_hdr->nlmsg_seq != p_socket)\n            {\n                continue;\n            }\n\n            if(l_hdr->nlmsg_type == NLMSG_DONE)\n            {\n                break;\n            }\n\n            if(l_hdr->nlmsg_type == RTM_NEWLINK)\n            {\n                interpretLink(l_hdr, p_links, p_resultList);\n            }\n            else if(l_hdr->nlmsg_type == RTM_NEWADDR)\n            {\n                interpretAddr(l_hdr, p_links, p_resultList);\n            }\n        }\n    }\n}"
  },
  {
    "function_name": "interpretAddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
    "lines": "361-485",
    "snippet": "static void interpretAddr(struct nlmsghdr *p_hdr, struct ifaddrs **p_links, struct ifaddrs **p_resultList)\n{\n    struct ifaddrmsg *l_info = (struct ifaddrmsg *)NLMSG_DATA(p_hdr);\n\n    size_t l_nameSize = 0;\n    size_t l_addrSize = 0;\n\n    int l_addedNetmask = 0;\n\n    size_t l_rtaSize = NLMSG_PAYLOAD(p_hdr, sizeof(struct ifaddrmsg));\n    struct rtattr *l_rta;\n    for(l_rta = (struct rtattr *)(((char *)l_info) + NLMSG_ALIGN(sizeof(struct ifaddrmsg))); RTA_OK(l_rta, l_rtaSize); l_rta = RTA_NEXT(l_rta, l_rtaSize))\n    {\n        size_t l_rtaDataSize = RTA_PAYLOAD(l_rta);\n        if(l_info->ifa_family == AF_PACKET)\n        {\n            continue;\n        }\n\n        switch(l_rta->rta_type)\n        {\n            case IFA_ADDRESS:\n            case IFA_LOCAL:\n                if((l_info->ifa_family == AF_INET || l_info->ifa_family == AF_INET6) && !l_addedNetmask)\n                { // make room for netmask\n                    l_addrSize += NLMSG_ALIGN(calcAddrLen(l_info->ifa_family, l_rtaDataSize));\n                    l_addedNetmask = 1;\n                }\n            case IFA_BROADCAST:\n                l_addrSize += NLMSG_ALIGN(calcAddrLen(l_info->ifa_family, l_rtaDataSize));\n                break;\n            case IFA_LABEL:\n                l_nameSize += NLMSG_ALIGN(l_rtaSize + 1);\n                break;\n            default:\n                break;\n        }\n    }\n\n    struct ifaddrs *l_entry = malloc(sizeof(struct ifaddrs) + l_nameSize + l_addrSize);\n    memset(l_entry, 0, sizeof(struct ifaddrs));\n    l_entry->ifa_name = p_links[l_info->ifa_index - 1]->ifa_name;\n\n    char *l_name = ((char *)l_entry) + sizeof(struct ifaddrs);\n    char *l_addr = l_name + l_nameSize;\n\n    l_entry->ifa_flags = l_info->ifa_flags | p_links[l_info->ifa_index - 1]->ifa_flags;\n\n    l_rtaSize = NLMSG_PAYLOAD(p_hdr, sizeof(struct ifaddrmsg));\n    for(l_rta = (struct rtattr *)(((char *)l_info) + NLMSG_ALIGN(sizeof(struct ifaddrmsg))); RTA_OK(l_rta, l_rtaSize); l_rta = RTA_NEXT(l_rta, l_rtaSize))\n    {\n        void *l_rtaData = RTA_DATA(l_rta);\n        size_t l_rtaDataSize = RTA_PAYLOAD(l_rta);\n        switch(l_rta->rta_type)\n        {\n            case IFA_ADDRESS:\n            case IFA_BROADCAST:\n            case IFA_LOCAL:\n            {\n                size_t l_addrLen = calcAddrLen(l_info->ifa_family, l_rtaDataSize);\n                makeSockaddr(l_info->ifa_family, (struct sockaddr *)l_addr, l_rtaData, l_rtaDataSize);\n                if(l_info->ifa_family == AF_INET6)\n                {\n                    if(IN6_IS_ADDR_LINKLOCAL((struct in6_addr *)l_rtaData) || IN6_IS_ADDR_MC_LINKLOCAL((struct in6_addr *)l_rtaData))\n                    {\n                        ((struct sockaddr_in6 *)l_addr)->sin6_scope_id = l_info->ifa_index;\n                    }\n                }\n\n                if(l_rta->rta_type == IFA_ADDRESS)\n                { // apparently in a point-to-point network IFA_ADDRESS contains the dest address and IFA_LOCAL contains the local address\n                    if(l_entry->ifa_addr)\n                    {\n                        l_entry->ifa_dstaddr = (struct sockaddr *)l_addr;\n                    }\n                    else\n                    {\n                        l_entry->ifa_addr = (struct sockaddr *)l_addr;\n                    }\n                }\n                else if(l_rta->rta_type == IFA_LOCAL)\n                {\n                    if(l_entry->ifa_addr)\n                    {\n                        l_entry->ifa_dstaddr = l_entry->ifa_addr;\n                    }\n                    l_entry->ifa_addr = (struct sockaddr *)l_addr;\n                }\n                else\n                {\n                    l_entry->ifa_broadaddr = (struct sockaddr *)l_addr;\n                }\n                l_addr += NLMSG_ALIGN(l_addrLen);\n                break;\n            }\n            case IFA_LABEL:\n                strncpy(l_name, l_rtaData, l_rtaDataSize);\n                l_name[l_rtaDataSize] = '\\0';\n                l_entry->ifa_name = l_name;\n                break;\n            default:\n                break;\n        }\n    }\n\n    if(l_entry->ifa_addr && (l_entry->ifa_addr->sa_family == AF_INET || l_entry->ifa_addr->sa_family == AF_INET6))\n    {\n        unsigned l_maxPrefix = (l_entry->ifa_addr->sa_family == AF_INET ? 32 : 128);\n        unsigned l_prefix = (l_info->ifa_prefixlen > l_maxPrefix ? l_maxPrefix : l_info->ifa_prefixlen);\n        char l_mask[16] = {0};\n        unsigned i;\n        for(i=0; i<(l_prefix/8); ++i)\n        {\n            l_mask[i] = 0xff;\n        }\n        if (l_prefix % 8) {\n            l_mask[i] = 0xff << (8 - (l_prefix % 8));\n        }\n\n        makeSockaddr(l_entry->ifa_addr->sa_family, (struct sockaddr *)l_addr, l_mask, l_maxPrefix / 8);\n        l_entry->ifa_netmask = (struct sockaddr *)l_addr;\n    }\n\n    addToEnd(p_resultList, l_entry);\n}",
    "includes": [
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"ifaddrs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "addToEnd",
          "args": [
            "p_resultList",
            "l_entry"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "addToEnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
          "lines": "261-276",
          "snippet": "static void addToEnd(struct ifaddrs **p_resultList, struct ifaddrs *p_entry)\n{\n    if(!*p_resultList)\n    {\n        *p_resultList = p_entry;\n    }\n    else\n    {\n        struct ifaddrs *l_cur = *p_resultList;\n        while(l_cur->ifa_next)\n        {\n            l_cur = l_cur->ifa_next;\n        }\n        l_cur->ifa_next = p_entry;\n    }\n}",
          "includes": [
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"ifaddrs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nstatic void addToEnd(struct ifaddrs **p_resultList, struct ifaddrs *p_entry)\n{\n    if(!*p_resultList)\n    {\n        *p_resultList = p_entry;\n    }\n    else\n    {\n        struct ifaddrs *l_cur = *p_resultList;\n        while(l_cur->ifa_next)\n        {\n            l_cur = l_cur->ifa_next;\n        }\n        l_cur->ifa_next = p_entry;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeSockaddr",
          "args": [
            "l_entry->ifa_addr->sa_family",
            "(struct sockaddr *)l_addr",
            "l_mask",
            "l_maxPrefix / 8"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "makeSockaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
          "lines": "240-259",
          "snippet": "static void makeSockaddr(sa_family_t p_family, struct sockaddr *p_dest, void *p_data, size_t p_size)\n{\n    switch(p_family)\n    {\n        case AF_INET:\n            memcpy(&((struct sockaddr_in*)p_dest)->sin_addr, p_data, p_size);\n            break;\n        case AF_INET6:\n            memcpy(&((struct sockaddr_in6*)p_dest)->sin6_addr, p_data, p_size);\n            break;\n        case AF_PACKET:\n            memcpy(((struct sockaddr_ll*)p_dest)->sll_addr, p_data, p_size);\n            ((struct sockaddr_ll*)p_dest)->sll_halen = p_size;\n            break;\n        default:\n            memcpy(p_dest->sa_data, p_data, p_size);\n            break;\n    }\n    p_dest->sa_family = p_family;\n}",
          "includes": [
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"ifaddrs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nstatic void makeSockaddr(sa_family_t p_family, struct sockaddr *p_dest, void *p_data, size_t p_size)\n{\n    switch(p_family)\n    {\n        case AF_INET:\n            memcpy(&((struct sockaddr_in*)p_dest)->sin_addr, p_data, p_size);\n            break;\n        case AF_INET6:\n            memcpy(&((struct sockaddr_in6*)p_dest)->sin6_addr, p_data, p_size);\n            break;\n        case AF_PACKET:\n            memcpy(((struct sockaddr_ll*)p_dest)->sll_addr, p_data, p_size);\n            ((struct sockaddr_ll*)p_dest)->sll_halen = p_size;\n            break;\n        default:\n            memcpy(p_dest->sa_data, p_data, p_size);\n            break;\n    }\n    p_dest->sa_family = p_family;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "l_name",
            "l_rtaData",
            "l_rtaDataSize"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_ALIGN",
          "args": [
            "l_addrLen"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IN6_IS_ADDR_MC_LINKLOCAL",
          "args": [
            "(struct in6_addr *)l_rtaData"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IN6_IS_ADDR_LINKLOCAL",
          "args": [
            "(struct in6_addr *)l_rtaData"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calcAddrLen",
          "args": [
            "l_info->ifa_family",
            "l_rtaDataSize"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "calcAddrLen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
          "lines": "225-238",
          "snippet": "static size_t calcAddrLen(sa_family_t p_family, int p_dataSize)\n{\n    switch(p_family)\n    {\n        case AF_INET:\n            return sizeof(struct sockaddr_in);\n        case AF_INET6:\n            return sizeof(struct sockaddr_in6);\n        case AF_PACKET:\n            return maxSize(sizeof(struct sockaddr_ll), offsetof(struct sockaddr_ll, sll_addr) + p_dataSize);\n        default:\n            return maxSize(sizeof(struct sockaddr), offsetof(struct sockaddr, sa_data) + p_dataSize);\n    }\n}",
          "includes": [
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"ifaddrs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nstatic size_t calcAddrLen(sa_family_t p_family, int p_dataSize)\n{\n    switch(p_family)\n    {\n        case AF_INET:\n            return sizeof(struct sockaddr_in);\n        case AF_INET6:\n            return sizeof(struct sockaddr_in6);\n        case AF_PACKET:\n            return maxSize(sizeof(struct sockaddr_ll), offsetof(struct sockaddr_ll, sll_addr) + p_dataSize);\n        default:\n            return maxSize(sizeof(struct sockaddr), offsetof(struct sockaddr, sa_data) + p_dataSize);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "RTA_PAYLOAD",
          "args": [
            "l_rta"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_DATA",
          "args": [
            "l_rta"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_NEXT",
          "args": [
            "l_rta",
            "l_rtaSize"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_OK",
          "args": [
            "l_rta",
            "l_rtaSize"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_ALIGN",
          "args": [
            "sizeof(struct ifaddrmsg)"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_PAYLOAD",
          "args": [
            "p_hdr",
            "sizeof(struct ifaddrmsg)"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "l_entry",
            "0",
            "sizeof(struct ifaddrs)"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct ifaddrs) + l_nameSize + l_addrSize"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_ALIGN",
          "args": [
            "l_rtaSize + 1"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_ALIGN",
          "args": [
            "calcAddrLen(l_info->ifa_family, l_rtaDataSize)"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_ALIGN",
          "args": [
            "calcAddrLen(l_info->ifa_family, l_rtaDataSize)"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_PAYLOAD",
          "args": [
            "l_rta"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_NEXT",
          "args": [
            "l_rta",
            "l_rtaSize"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_OK",
          "args": [
            "l_rta",
            "l_rtaSize"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_ALIGN",
          "args": [
            "sizeof(struct ifaddrmsg)"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_PAYLOAD",
          "args": [
            "p_hdr",
            "sizeof(struct ifaddrmsg)"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_DATA",
          "args": [
            "p_hdr"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nstatic void interpretAddr(struct nlmsghdr *p_hdr, struct ifaddrs **p_links, struct ifaddrs **p_resultList)\n{\n    struct ifaddrmsg *l_info = (struct ifaddrmsg *)NLMSG_DATA(p_hdr);\n\n    size_t l_nameSize = 0;\n    size_t l_addrSize = 0;\n\n    int l_addedNetmask = 0;\n\n    size_t l_rtaSize = NLMSG_PAYLOAD(p_hdr, sizeof(struct ifaddrmsg));\n    struct rtattr *l_rta;\n    for(l_rta = (struct rtattr *)(((char *)l_info) + NLMSG_ALIGN(sizeof(struct ifaddrmsg))); RTA_OK(l_rta, l_rtaSize); l_rta = RTA_NEXT(l_rta, l_rtaSize))\n    {\n        size_t l_rtaDataSize = RTA_PAYLOAD(l_rta);\n        if(l_info->ifa_family == AF_PACKET)\n        {\n            continue;\n        }\n\n        switch(l_rta->rta_type)\n        {\n            case IFA_ADDRESS:\n            case IFA_LOCAL:\n                if((l_info->ifa_family == AF_INET || l_info->ifa_family == AF_INET6) && !l_addedNetmask)\n                { // make room for netmask\n                    l_addrSize += NLMSG_ALIGN(calcAddrLen(l_info->ifa_family, l_rtaDataSize));\n                    l_addedNetmask = 1;\n                }\n            case IFA_BROADCAST:\n                l_addrSize += NLMSG_ALIGN(calcAddrLen(l_info->ifa_family, l_rtaDataSize));\n                break;\n            case IFA_LABEL:\n                l_nameSize += NLMSG_ALIGN(l_rtaSize + 1);\n                break;\n            default:\n                break;\n        }\n    }\n\n    struct ifaddrs *l_entry = malloc(sizeof(struct ifaddrs) + l_nameSize + l_addrSize);\n    memset(l_entry, 0, sizeof(struct ifaddrs));\n    l_entry->ifa_name = p_links[l_info->ifa_index - 1]->ifa_name;\n\n    char *l_name = ((char *)l_entry) + sizeof(struct ifaddrs);\n    char *l_addr = l_name + l_nameSize;\n\n    l_entry->ifa_flags = l_info->ifa_flags | p_links[l_info->ifa_index - 1]->ifa_flags;\n\n    l_rtaSize = NLMSG_PAYLOAD(p_hdr, sizeof(struct ifaddrmsg));\n    for(l_rta = (struct rtattr *)(((char *)l_info) + NLMSG_ALIGN(sizeof(struct ifaddrmsg))); RTA_OK(l_rta, l_rtaSize); l_rta = RTA_NEXT(l_rta, l_rtaSize))\n    {\n        void *l_rtaData = RTA_DATA(l_rta);\n        size_t l_rtaDataSize = RTA_PAYLOAD(l_rta);\n        switch(l_rta->rta_type)\n        {\n            case IFA_ADDRESS:\n            case IFA_BROADCAST:\n            case IFA_LOCAL:\n            {\n                size_t l_addrLen = calcAddrLen(l_info->ifa_family, l_rtaDataSize);\n                makeSockaddr(l_info->ifa_family, (struct sockaddr *)l_addr, l_rtaData, l_rtaDataSize);\n                if(l_info->ifa_family == AF_INET6)\n                {\n                    if(IN6_IS_ADDR_LINKLOCAL((struct in6_addr *)l_rtaData) || IN6_IS_ADDR_MC_LINKLOCAL((struct in6_addr *)l_rtaData))\n                    {\n                        ((struct sockaddr_in6 *)l_addr)->sin6_scope_id = l_info->ifa_index;\n                    }\n                }\n\n                if(l_rta->rta_type == IFA_ADDRESS)\n                { // apparently in a point-to-point network IFA_ADDRESS contains the dest address and IFA_LOCAL contains the local address\n                    if(l_entry->ifa_addr)\n                    {\n                        l_entry->ifa_dstaddr = (struct sockaddr *)l_addr;\n                    }\n                    else\n                    {\n                        l_entry->ifa_addr = (struct sockaddr *)l_addr;\n                    }\n                }\n                else if(l_rta->rta_type == IFA_LOCAL)\n                {\n                    if(l_entry->ifa_addr)\n                    {\n                        l_entry->ifa_dstaddr = l_entry->ifa_addr;\n                    }\n                    l_entry->ifa_addr = (struct sockaddr *)l_addr;\n                }\n                else\n                {\n                    l_entry->ifa_broadaddr = (struct sockaddr *)l_addr;\n                }\n                l_addr += NLMSG_ALIGN(l_addrLen);\n                break;\n            }\n            case IFA_LABEL:\n                strncpy(l_name, l_rtaData, l_rtaDataSize);\n                l_name[l_rtaDataSize] = '\\0';\n                l_entry->ifa_name = l_name;\n                break;\n            default:\n                break;\n        }\n    }\n\n    if(l_entry->ifa_addr && (l_entry->ifa_addr->sa_family == AF_INET || l_entry->ifa_addr->sa_family == AF_INET6))\n    {\n        unsigned l_maxPrefix = (l_entry->ifa_addr->sa_family == AF_INET ? 32 : 128);\n        unsigned l_prefix = (l_info->ifa_prefixlen > l_maxPrefix ? l_maxPrefix : l_info->ifa_prefixlen);\n        char l_mask[16] = {0};\n        unsigned i;\n        for(i=0; i<(l_prefix/8); ++i)\n        {\n            l_mask[i] = 0xff;\n        }\n        if (l_prefix % 8) {\n            l_mask[i] = 0xff << (8 - (l_prefix % 8));\n        }\n\n        makeSockaddr(l_entry->ifa_addr->sa_family, (struct sockaddr *)l_addr, l_mask, l_maxPrefix / 8);\n        l_entry->ifa_netmask = (struct sockaddr *)l_addr;\n    }\n\n    addToEnd(p_resultList, l_entry);\n}"
  },
  {
    "function_name": "interpretLink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
    "lines": "278-359",
    "snippet": "static void interpretLink(struct nlmsghdr *p_hdr, struct ifaddrs **p_links, struct ifaddrs **p_resultList)\n{\n    struct ifinfomsg *l_info = (struct ifinfomsg *)NLMSG_DATA(p_hdr);\n\n    size_t l_nameSize = 0;\n    size_t l_addrSize = 0;\n    size_t l_dataSize = 0;\n\n    size_t l_rtaSize = NLMSG_PAYLOAD(p_hdr, sizeof(struct ifinfomsg));\n    struct rtattr *l_rta;\n    for(l_rta = (struct rtattr *)(((char *)l_info) + NLMSG_ALIGN(sizeof(struct ifinfomsg))); RTA_OK(l_rta, l_rtaSize); l_rta = RTA_NEXT(l_rta, l_rtaSize))\n    {\n        size_t l_rtaDataSize = RTA_PAYLOAD(l_rta);\n        switch(l_rta->rta_type)\n        {\n            case IFLA_ADDRESS:\n            case IFLA_BROADCAST:\n                l_addrSize += NLMSG_ALIGN(calcAddrLen(AF_PACKET, l_rtaDataSize));\n                break;\n            case IFLA_IFNAME:\n                l_nameSize += NLMSG_ALIGN(l_rtaSize + 1);\n                break;\n            case IFLA_STATS:\n                l_dataSize += NLMSG_ALIGN(l_rtaSize);\n                break;\n            default:\n                break;\n        }\n    }\n\n    struct ifaddrs *l_entry = malloc(sizeof(struct ifaddrs) + l_nameSize + l_addrSize + l_dataSize);\n    memset(l_entry, 0, sizeof(struct ifaddrs));\n    l_entry->ifa_name = \"\";\n\n    char *l_name = ((char *)l_entry) + sizeof(struct ifaddrs);\n    char *l_addr = l_name + l_nameSize;\n    char *l_data = l_addr + l_addrSize;\n\n    l_entry->ifa_flags = l_info->ifi_flags;\n\n    l_rtaSize = NLMSG_PAYLOAD(p_hdr, sizeof(struct ifinfomsg));\n    for(l_rta = (struct rtattr *)(((char *)l_info) + NLMSG_ALIGN(sizeof(struct ifinfomsg))); RTA_OK(l_rta, l_rtaSize); l_rta = RTA_NEXT(l_rta, l_rtaSize))\n    {\n        void *l_rtaData = RTA_DATA(l_rta);\n        size_t l_rtaDataSize = RTA_PAYLOAD(l_rta);\n        switch(l_rta->rta_type)\n        {\n            case IFLA_ADDRESS:\n            case IFLA_BROADCAST:\n            {\n                size_t l_addrLen = calcAddrLen(AF_PACKET, l_rtaDataSize);\n                makeSockaddr(AF_PACKET, (struct sockaddr *)l_addr, l_rtaData, l_rtaDataSize);\n                ((struct sockaddr_ll *)l_addr)->sll_ifindex = l_info->ifi_index;\n                ((struct sockaddr_ll *)l_addr)->sll_hatype = l_info->ifi_type;\n                if(l_rta->rta_type == IFLA_ADDRESS)\n                {\n                    l_entry->ifa_addr = (struct sockaddr *)l_addr;\n                }\n                else\n                {\n                    l_entry->ifa_broadaddr = (struct sockaddr *)l_addr;\n                }\n                l_addr += NLMSG_ALIGN(l_addrLen);\n                break;\n            }\n            case IFLA_IFNAME:\n                strncpy(l_name, l_rtaData, l_rtaDataSize);\n                l_name[l_rtaDataSize] = '\\0';\n                l_entry->ifa_name = l_name;\n                break;\n            case IFLA_STATS:\n                memcpy(l_data, l_rtaData, l_rtaDataSize);\n                l_entry->ifa_data = l_data;\n                break;\n            default:\n                break;\n        }\n    }\n\n    addToEnd(p_resultList, l_entry);\n    p_links[l_info->ifi_index - 1] = l_entry;\n}",
    "includes": [
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"ifaddrs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "addToEnd",
          "args": [
            "p_resultList",
            "l_entry"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "addToEnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
          "lines": "261-276",
          "snippet": "static void addToEnd(struct ifaddrs **p_resultList, struct ifaddrs *p_entry)\n{\n    if(!*p_resultList)\n    {\n        *p_resultList = p_entry;\n    }\n    else\n    {\n        struct ifaddrs *l_cur = *p_resultList;\n        while(l_cur->ifa_next)\n        {\n            l_cur = l_cur->ifa_next;\n        }\n        l_cur->ifa_next = p_entry;\n    }\n}",
          "includes": [
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"ifaddrs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nstatic void addToEnd(struct ifaddrs **p_resultList, struct ifaddrs *p_entry)\n{\n    if(!*p_resultList)\n    {\n        *p_resultList = p_entry;\n    }\n    else\n    {\n        struct ifaddrs *l_cur = *p_resultList;\n        while(l_cur->ifa_next)\n        {\n            l_cur = l_cur->ifa_next;\n        }\n        l_cur->ifa_next = p_entry;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "l_data",
            "l_rtaData",
            "l_rtaDataSize"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "l_name",
            "l_rtaData",
            "l_rtaDataSize"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_ALIGN",
          "args": [
            "l_addrLen"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeSockaddr",
          "args": [
            "AF_PACKET",
            "(struct sockaddr *)l_addr",
            "l_rtaData",
            "l_rtaDataSize"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "makeSockaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
          "lines": "240-259",
          "snippet": "static void makeSockaddr(sa_family_t p_family, struct sockaddr *p_dest, void *p_data, size_t p_size)\n{\n    switch(p_family)\n    {\n        case AF_INET:\n            memcpy(&((struct sockaddr_in*)p_dest)->sin_addr, p_data, p_size);\n            break;\n        case AF_INET6:\n            memcpy(&((struct sockaddr_in6*)p_dest)->sin6_addr, p_data, p_size);\n            break;\n        case AF_PACKET:\n            memcpy(((struct sockaddr_ll*)p_dest)->sll_addr, p_data, p_size);\n            ((struct sockaddr_ll*)p_dest)->sll_halen = p_size;\n            break;\n        default:\n            memcpy(p_dest->sa_data, p_data, p_size);\n            break;\n    }\n    p_dest->sa_family = p_family;\n}",
          "includes": [
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"ifaddrs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nstatic void makeSockaddr(sa_family_t p_family, struct sockaddr *p_dest, void *p_data, size_t p_size)\n{\n    switch(p_family)\n    {\n        case AF_INET:\n            memcpy(&((struct sockaddr_in*)p_dest)->sin_addr, p_data, p_size);\n            break;\n        case AF_INET6:\n            memcpy(&((struct sockaddr_in6*)p_dest)->sin6_addr, p_data, p_size);\n            break;\n        case AF_PACKET:\n            memcpy(((struct sockaddr_ll*)p_dest)->sll_addr, p_data, p_size);\n            ((struct sockaddr_ll*)p_dest)->sll_halen = p_size;\n            break;\n        default:\n            memcpy(p_dest->sa_data, p_data, p_size);\n            break;\n    }\n    p_dest->sa_family = p_family;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calcAddrLen",
          "args": [
            "AF_PACKET",
            "l_rtaDataSize"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "calcAddrLen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
          "lines": "225-238",
          "snippet": "static size_t calcAddrLen(sa_family_t p_family, int p_dataSize)\n{\n    switch(p_family)\n    {\n        case AF_INET:\n            return sizeof(struct sockaddr_in);\n        case AF_INET6:\n            return sizeof(struct sockaddr_in6);\n        case AF_PACKET:\n            return maxSize(sizeof(struct sockaddr_ll), offsetof(struct sockaddr_ll, sll_addr) + p_dataSize);\n        default:\n            return maxSize(sizeof(struct sockaddr), offsetof(struct sockaddr, sa_data) + p_dataSize);\n    }\n}",
          "includes": [
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"ifaddrs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nstatic size_t calcAddrLen(sa_family_t p_family, int p_dataSize)\n{\n    switch(p_family)\n    {\n        case AF_INET:\n            return sizeof(struct sockaddr_in);\n        case AF_INET6:\n            return sizeof(struct sockaddr_in6);\n        case AF_PACKET:\n            return maxSize(sizeof(struct sockaddr_ll), offsetof(struct sockaddr_ll, sll_addr) + p_dataSize);\n        default:\n            return maxSize(sizeof(struct sockaddr), offsetof(struct sockaddr, sa_data) + p_dataSize);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "RTA_PAYLOAD",
          "args": [
            "l_rta"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_DATA",
          "args": [
            "l_rta"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_NEXT",
          "args": [
            "l_rta",
            "l_rtaSize"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_OK",
          "args": [
            "l_rta",
            "l_rtaSize"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_ALIGN",
          "args": [
            "sizeof(struct ifinfomsg)"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_PAYLOAD",
          "args": [
            "p_hdr",
            "sizeof(struct ifinfomsg)"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "l_entry",
            "0",
            "sizeof(struct ifaddrs)"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct ifaddrs) + l_nameSize + l_addrSize + l_dataSize"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_ALIGN",
          "args": [
            "l_rtaSize"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_ALIGN",
          "args": [
            "l_rtaSize + 1"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_ALIGN",
          "args": [
            "calcAddrLen(AF_PACKET, l_rtaDataSize)"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_PAYLOAD",
          "args": [
            "l_rta"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_NEXT",
          "args": [
            "l_rta",
            "l_rtaSize"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_OK",
          "args": [
            "l_rta",
            "l_rtaSize"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_ALIGN",
          "args": [
            "sizeof(struct ifinfomsg)"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_PAYLOAD",
          "args": [
            "p_hdr",
            "sizeof(struct ifinfomsg)"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_DATA",
          "args": [
            "p_hdr"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nstatic void interpretLink(struct nlmsghdr *p_hdr, struct ifaddrs **p_links, struct ifaddrs **p_resultList)\n{\n    struct ifinfomsg *l_info = (struct ifinfomsg *)NLMSG_DATA(p_hdr);\n\n    size_t l_nameSize = 0;\n    size_t l_addrSize = 0;\n    size_t l_dataSize = 0;\n\n    size_t l_rtaSize = NLMSG_PAYLOAD(p_hdr, sizeof(struct ifinfomsg));\n    struct rtattr *l_rta;\n    for(l_rta = (struct rtattr *)(((char *)l_info) + NLMSG_ALIGN(sizeof(struct ifinfomsg))); RTA_OK(l_rta, l_rtaSize); l_rta = RTA_NEXT(l_rta, l_rtaSize))\n    {\n        size_t l_rtaDataSize = RTA_PAYLOAD(l_rta);\n        switch(l_rta->rta_type)\n        {\n            case IFLA_ADDRESS:\n            case IFLA_BROADCAST:\n                l_addrSize += NLMSG_ALIGN(calcAddrLen(AF_PACKET, l_rtaDataSize));\n                break;\n            case IFLA_IFNAME:\n                l_nameSize += NLMSG_ALIGN(l_rtaSize + 1);\n                break;\n            case IFLA_STATS:\n                l_dataSize += NLMSG_ALIGN(l_rtaSize);\n                break;\n            default:\n                break;\n        }\n    }\n\n    struct ifaddrs *l_entry = malloc(sizeof(struct ifaddrs) + l_nameSize + l_addrSize + l_dataSize);\n    memset(l_entry, 0, sizeof(struct ifaddrs));\n    l_entry->ifa_name = \"\";\n\n    char *l_name = ((char *)l_entry) + sizeof(struct ifaddrs);\n    char *l_addr = l_name + l_nameSize;\n    char *l_data = l_addr + l_addrSize;\n\n    l_entry->ifa_flags = l_info->ifi_flags;\n\n    l_rtaSize = NLMSG_PAYLOAD(p_hdr, sizeof(struct ifinfomsg));\n    for(l_rta = (struct rtattr *)(((char *)l_info) + NLMSG_ALIGN(sizeof(struct ifinfomsg))); RTA_OK(l_rta, l_rtaSize); l_rta = RTA_NEXT(l_rta, l_rtaSize))\n    {\n        void *l_rtaData = RTA_DATA(l_rta);\n        size_t l_rtaDataSize = RTA_PAYLOAD(l_rta);\n        switch(l_rta->rta_type)\n        {\n            case IFLA_ADDRESS:\n            case IFLA_BROADCAST:\n            {\n                size_t l_addrLen = calcAddrLen(AF_PACKET, l_rtaDataSize);\n                makeSockaddr(AF_PACKET, (struct sockaddr *)l_addr, l_rtaData, l_rtaDataSize);\n                ((struct sockaddr_ll *)l_addr)->sll_ifindex = l_info->ifi_index;\n                ((struct sockaddr_ll *)l_addr)->sll_hatype = l_info->ifi_type;\n                if(l_rta->rta_type == IFLA_ADDRESS)\n                {\n                    l_entry->ifa_addr = (struct sockaddr *)l_addr;\n                }\n                else\n                {\n                    l_entry->ifa_broadaddr = (struct sockaddr *)l_addr;\n                }\n                l_addr += NLMSG_ALIGN(l_addrLen);\n                break;\n            }\n            case IFLA_IFNAME:\n                strncpy(l_name, l_rtaData, l_rtaDataSize);\n                l_name[l_rtaDataSize] = '\\0';\n                l_entry->ifa_name = l_name;\n                break;\n            case IFLA_STATS:\n                memcpy(l_data, l_rtaData, l_rtaDataSize);\n                l_entry->ifa_data = l_data;\n                break;\n            default:\n                break;\n        }\n    }\n\n    addToEnd(p_resultList, l_entry);\n    p_links[l_info->ifi_index - 1] = l_entry;\n}"
  },
  {
    "function_name": "addToEnd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
    "lines": "261-276",
    "snippet": "static void addToEnd(struct ifaddrs **p_resultList, struct ifaddrs *p_entry)\n{\n    if(!*p_resultList)\n    {\n        *p_resultList = p_entry;\n    }\n    else\n    {\n        struct ifaddrs *l_cur = *p_resultList;\n        while(l_cur->ifa_next)\n        {\n            l_cur = l_cur->ifa_next;\n        }\n        l_cur->ifa_next = p_entry;\n    }\n}",
    "includes": [
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"ifaddrs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nstatic void addToEnd(struct ifaddrs **p_resultList, struct ifaddrs *p_entry)\n{\n    if(!*p_resultList)\n    {\n        *p_resultList = p_entry;\n    }\n    else\n    {\n        struct ifaddrs *l_cur = *p_resultList;\n        while(l_cur->ifa_next)\n        {\n            l_cur = l_cur->ifa_next;\n        }\n        l_cur->ifa_next = p_entry;\n    }\n}"
  },
  {
    "function_name": "makeSockaddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
    "lines": "240-259",
    "snippet": "static void makeSockaddr(sa_family_t p_family, struct sockaddr *p_dest, void *p_data, size_t p_size)\n{\n    switch(p_family)\n    {\n        case AF_INET:\n            memcpy(&((struct sockaddr_in*)p_dest)->sin_addr, p_data, p_size);\n            break;\n        case AF_INET6:\n            memcpy(&((struct sockaddr_in6*)p_dest)->sin6_addr, p_data, p_size);\n            break;\n        case AF_PACKET:\n            memcpy(((struct sockaddr_ll*)p_dest)->sll_addr, p_data, p_size);\n            ((struct sockaddr_ll*)p_dest)->sll_halen = p_size;\n            break;\n        default:\n            memcpy(p_dest->sa_data, p_data, p_size);\n            break;\n    }\n    p_dest->sa_family = p_family;\n}",
    "includes": [
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"ifaddrs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p_dest->sa_data",
            "p_data",
            "p_size"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "((struct sockaddr_ll*)p_dest)->sll_addr",
            "p_data",
            "p_size"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&((struct sockaddr_in6*)p_dest)->sin6_addr",
            "p_data",
            "p_size"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&((struct sockaddr_in*)p_dest)->sin_addr",
            "p_data",
            "p_size"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nstatic void makeSockaddr(sa_family_t p_family, struct sockaddr *p_dest, void *p_data, size_t p_size)\n{\n    switch(p_family)\n    {\n        case AF_INET:\n            memcpy(&((struct sockaddr_in*)p_dest)->sin_addr, p_data, p_size);\n            break;\n        case AF_INET6:\n            memcpy(&((struct sockaddr_in6*)p_dest)->sin6_addr, p_data, p_size);\n            break;\n        case AF_PACKET:\n            memcpy(((struct sockaddr_ll*)p_dest)->sll_addr, p_data, p_size);\n            ((struct sockaddr_ll*)p_dest)->sll_halen = p_size;\n            break;\n        default:\n            memcpy(p_dest->sa_data, p_data, p_size);\n            break;\n    }\n    p_dest->sa_family = p_family;\n}"
  },
  {
    "function_name": "calcAddrLen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
    "lines": "225-238",
    "snippet": "static size_t calcAddrLen(sa_family_t p_family, int p_dataSize)\n{\n    switch(p_family)\n    {\n        case AF_INET:\n            return sizeof(struct sockaddr_in);\n        case AF_INET6:\n            return sizeof(struct sockaddr_in6);\n        case AF_PACKET:\n            return maxSize(sizeof(struct sockaddr_ll), offsetof(struct sockaddr_ll, sll_addr) + p_dataSize);\n        default:\n            return maxSize(sizeof(struct sockaddr), offsetof(struct sockaddr, sa_data) + p_dataSize);\n    }\n}",
    "includes": [
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"ifaddrs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "maxSize",
          "args": [
            "sizeof(struct sockaddr)",
            "offsetof(struct sockaddr, sa_data) + p_dataSize"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "maxSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
          "lines": "220-223",
          "snippet": "static size_t maxSize(size_t a, size_t b)\n{\n    return (a > b ? a : b);\n}",
          "includes": [
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"ifaddrs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nstatic size_t maxSize(size_t a, size_t b)\n{\n    return (a > b ? a : b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nstatic size_t calcAddrLen(sa_family_t p_family, int p_dataSize)\n{\n    switch(p_family)\n    {\n        case AF_INET:\n            return sizeof(struct sockaddr_in);\n        case AF_INET6:\n            return sizeof(struct sockaddr_in6);\n        case AF_PACKET:\n            return maxSize(sizeof(struct sockaddr_ll), offsetof(struct sockaddr_ll, sll_addr) + p_dataSize);\n        default:\n            return maxSize(sizeof(struct sockaddr), offsetof(struct sockaddr, sa_data) + p_dataSize);\n    }\n}"
  },
  {
    "function_name": "maxSize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
    "lines": "220-223",
    "snippet": "static size_t maxSize(size_t a, size_t b)\n{\n    return (a > b ? a : b);\n}",
    "includes": [
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"ifaddrs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nstatic size_t maxSize(size_t a, size_t b)\n{\n    return (a > b ? a : b);\n}"
  },
  {
    "function_name": "getResultList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
    "lines": "186-218",
    "snippet": "static NetlinkList *getResultList(int p_socket, int p_request)\n{\n    if(netlink_send(p_socket, p_request) < 0)\n    {\n        return NULL;\n    }\n\n    NetlinkList *l_list = NULL;\n    NetlinkList *l_end = NULL;\n    int l_size;\n    int l_done = 0;\n    while(!l_done)\n    {\n        struct nlmsghdr *l_hdr = getNetlinkResponse(p_socket, &l_size, &l_done);\n        if(!l_hdr)\n        { // error\n            freeResultList(l_list);\n            return NULL;\n        }\n\n        NetlinkList *l_item = newListItem(l_hdr, l_size);\n        if(!l_list)\n        {\n            l_list = l_item;\n        }\n        else\n        {\n            l_end->m_next = l_item;\n        }\n        l_end = l_item;\n    }\n    return l_list;\n}",
    "includes": [
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"ifaddrs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "newListItem",
          "args": [
            "l_hdr",
            "l_size"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "newListItem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
          "lines": "165-172",
          "snippet": "static NetlinkList *newListItem(struct nlmsghdr *p_data, unsigned int p_size)\n{\n    NetlinkList *l_item = malloc(sizeof(NetlinkList));\n    l_item->m_next = NULL;\n    l_item->m_data = p_data;\n    l_item->m_size = p_size;\n    return l_item;\n}",
          "includes": [
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"ifaddrs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nstatic NetlinkList *newListItem(struct nlmsghdr *p_data, unsigned int p_size)\n{\n    NetlinkList *l_item = malloc(sizeof(NetlinkList));\n    l_item->m_next = NULL;\n    l_item->m_data = p_data;\n    l_item->m_size = p_size;\n    return l_item;\n}"
        }
      },
      {
        "call_info": {
          "callee": "freeResultList",
          "args": [
            "l_list"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "freeResultList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
          "lines": "174-184",
          "snippet": "static void freeResultList(NetlinkList *p_list)\n{\n    NetlinkList *l_cur;\n    while(p_list)\n    {\n        l_cur = p_list;\n        p_list = p_list->m_next;\n        free(l_cur->m_data);\n        free(l_cur);\n    }\n}",
          "includes": [
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"ifaddrs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nstatic void freeResultList(NetlinkList *p_list)\n{\n    NetlinkList *l_cur;\n    while(p_list)\n    {\n        l_cur = p_list;\n        p_list = p_list->m_next;\n        free(l_cur->m_data);\n        free(l_cur);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getNetlinkResponse",
          "args": [
            "p_socket",
            "&l_size",
            "&l_done"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "getNetlinkResponse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
          "lines": "118-163",
          "snippet": "static struct nlmsghdr *getNetlinkResponse(int p_socket, int *p_size, int *p_done)\n{\n    size_t l_size = 4096;\n    void *l_buffer = NULL;\n\n    for(;;)\n    {\n        free(l_buffer);\n        l_buffer = malloc(l_size);\n\n        int l_read = netlink_recv(p_socket, l_buffer, l_size);\n        *p_size = l_read;\n        if(l_read == -2)\n        {\n            free(l_buffer);\n            return NULL;\n        }\n        if(l_read >= 0)\n        {\n            pid_t l_pid = getpid();\n            struct nlmsghdr *l_hdr;\n            for(l_hdr = (struct nlmsghdr *)l_buffer; NLMSG_OK(l_hdr, (unsigned int)l_read); l_hdr = (struct nlmsghdr *)NLMSG_NEXT(l_hdr, l_read))\n            {\n                if((pid_t)l_hdr->nlmsg_pid != l_pid || (int)l_hdr->nlmsg_seq != p_socket)\n                {\n                    continue;\n                }\n\n                if(l_hdr->nlmsg_type == NLMSG_DONE)\n                {\n                    *p_done = 1;\n                    break;\n                }\n\n                if(l_hdr->nlmsg_type == NLMSG_ERROR)\n                {\n                    free(l_buffer);\n                    return NULL;\n                }\n            }\n            return l_buffer;\n        }\n\n        l_size *= 2;\n    }\n}",
          "includes": [
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"ifaddrs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nstatic struct nlmsghdr *getNetlinkResponse(int p_socket, int *p_size, int *p_done)\n{\n    size_t l_size = 4096;\n    void *l_buffer = NULL;\n\n    for(;;)\n    {\n        free(l_buffer);\n        l_buffer = malloc(l_size);\n\n        int l_read = netlink_recv(p_socket, l_buffer, l_size);\n        *p_size = l_read;\n        if(l_read == -2)\n        {\n            free(l_buffer);\n            return NULL;\n        }\n        if(l_read >= 0)\n        {\n            pid_t l_pid = getpid();\n            struct nlmsghdr *l_hdr;\n            for(l_hdr = (struct nlmsghdr *)l_buffer; NLMSG_OK(l_hdr, (unsigned int)l_read); l_hdr = (struct nlmsghdr *)NLMSG_NEXT(l_hdr, l_read))\n            {\n                if((pid_t)l_hdr->nlmsg_pid != l_pid || (int)l_hdr->nlmsg_seq != p_socket)\n                {\n                    continue;\n                }\n\n                if(l_hdr->nlmsg_type == NLMSG_DONE)\n                {\n                    *p_done = 1;\n                    break;\n                }\n\n                if(l_hdr->nlmsg_type == NLMSG_ERROR)\n                {\n                    free(l_buffer);\n                    return NULL;\n                }\n            }\n            return l_buffer;\n        }\n\n        l_size *= 2;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_send",
          "args": [
            "p_socket",
            "p_request"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "netlink_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
          "lines": "64-82",
          "snippet": "static int netlink_send(int p_socket, int p_request)\n{\n    char l_buffer[NLMSG_ALIGN(sizeof(struct nlmsghdr)) + NLMSG_ALIGN(sizeof(struct rtgenmsg))];\n    memset(l_buffer, 0, sizeof(l_buffer));\n    struct nlmsghdr *l_hdr = (struct nlmsghdr *)l_buffer;\n    struct rtgenmsg *l_msg = (struct rtgenmsg *)NLMSG_DATA(l_hdr);\n\n    l_hdr->nlmsg_len = NLMSG_LENGTH(sizeof(*l_msg));\n    l_hdr->nlmsg_type = p_request;\n    l_hdr->nlmsg_flags = NLM_F_ROOT | NLM_F_MATCH | NLM_F_REQUEST;\n    l_hdr->nlmsg_pid = 0;\n    l_hdr->nlmsg_seq = p_socket;\n    l_msg->rtgen_family = AF_UNSPEC;\n\n    struct sockaddr_nl l_addr;\n    memset(&l_addr, 0, sizeof(l_addr));\n    l_addr.nl_family = AF_NETLINK;\n    return (sendto(p_socket, l_hdr, l_hdr->nlmsg_len, 0, (struct sockaddr *)&l_addr, sizeof(l_addr)));\n}",
          "includes": [
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"ifaddrs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nstatic int netlink_send(int p_socket, int p_request)\n{\n    char l_buffer[NLMSG_ALIGN(sizeof(struct nlmsghdr)) + NLMSG_ALIGN(sizeof(struct rtgenmsg))];\n    memset(l_buffer, 0, sizeof(l_buffer));\n    struct nlmsghdr *l_hdr = (struct nlmsghdr *)l_buffer;\n    struct rtgenmsg *l_msg = (struct rtgenmsg *)NLMSG_DATA(l_hdr);\n\n    l_hdr->nlmsg_len = NLMSG_LENGTH(sizeof(*l_msg));\n    l_hdr->nlmsg_type = p_request;\n    l_hdr->nlmsg_flags = NLM_F_ROOT | NLM_F_MATCH | NLM_F_REQUEST;\n    l_hdr->nlmsg_pid = 0;\n    l_hdr->nlmsg_seq = p_socket;\n    l_msg->rtgen_family = AF_UNSPEC;\n\n    struct sockaddr_nl l_addr;\n    memset(&l_addr, 0, sizeof(l_addr));\n    l_addr.nl_family = AF_NETLINK;\n    return (sendto(p_socket, l_hdr, l_hdr->nlmsg_len, 0, (struct sockaddr *)&l_addr, sizeof(l_addr)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nstatic NetlinkList *getResultList(int p_socket, int p_request)\n{\n    if(netlink_send(p_socket, p_request) < 0)\n    {\n        return NULL;\n    }\n\n    NetlinkList *l_list = NULL;\n    NetlinkList *l_end = NULL;\n    int l_size;\n    int l_done = 0;\n    while(!l_done)\n    {\n        struct nlmsghdr *l_hdr = getNetlinkResponse(p_socket, &l_size, &l_done);\n        if(!l_hdr)\n        { // error\n            freeResultList(l_list);\n            return NULL;\n        }\n\n        NetlinkList *l_item = newListItem(l_hdr, l_size);\n        if(!l_list)\n        {\n            l_list = l_item;\n        }\n        else\n        {\n            l_end->m_next = l_item;\n        }\n        l_end = l_item;\n    }\n    return l_list;\n}"
  },
  {
    "function_name": "freeResultList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
    "lines": "174-184",
    "snippet": "static void freeResultList(NetlinkList *p_list)\n{\n    NetlinkList *l_cur;\n    while(p_list)\n    {\n        l_cur = p_list;\n        p_list = p_list->m_next;\n        free(l_cur->m_data);\n        free(l_cur);\n    }\n}",
    "includes": [
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"ifaddrs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "l_cur"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "freeifaddrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
          "lines": "590-599",
          "snippet": "void freeifaddrs(struct ifaddrs *ifa)\n{\n    struct ifaddrs *l_cur;\n    while(ifa)\n    {\n        l_cur = ifa;\n        ifa = ifa->ifa_next;\n        free(l_cur);\n    }\n}",
          "includes": [
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"ifaddrs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nvoid freeifaddrs(struct ifaddrs *ifa)\n{\n    struct ifaddrs *l_cur;\n    while(ifa)\n    {\n        l_cur = ifa;\n        ifa = ifa->ifa_next;\n        free(l_cur);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nstatic void freeResultList(NetlinkList *p_list)\n{\n    NetlinkList *l_cur;\n    while(p_list)\n    {\n        l_cur = p_list;\n        p_list = p_list->m_next;\n        free(l_cur->m_data);\n        free(l_cur);\n    }\n}"
  },
  {
    "function_name": "newListItem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
    "lines": "165-172",
    "snippet": "static NetlinkList *newListItem(struct nlmsghdr *p_data, unsigned int p_size)\n{\n    NetlinkList *l_item = malloc(sizeof(NetlinkList));\n    l_item->m_next = NULL;\n    l_item->m_data = p_data;\n    l_item->m_size = p_size;\n    return l_item;\n}",
    "includes": [
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"ifaddrs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(NetlinkList)"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nstatic NetlinkList *newListItem(struct nlmsghdr *p_data, unsigned int p_size)\n{\n    NetlinkList *l_item = malloc(sizeof(NetlinkList));\n    l_item->m_next = NULL;\n    l_item->m_data = p_data;\n    l_item->m_size = p_size;\n    return l_item;\n}"
  },
  {
    "function_name": "getNetlinkResponse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
    "lines": "118-163",
    "snippet": "static struct nlmsghdr *getNetlinkResponse(int p_socket, int *p_size, int *p_done)\n{\n    size_t l_size = 4096;\n    void *l_buffer = NULL;\n\n    for(;;)\n    {\n        free(l_buffer);\n        l_buffer = malloc(l_size);\n\n        int l_read = netlink_recv(p_socket, l_buffer, l_size);\n        *p_size = l_read;\n        if(l_read == -2)\n        {\n            free(l_buffer);\n            return NULL;\n        }\n        if(l_read >= 0)\n        {\n            pid_t l_pid = getpid();\n            struct nlmsghdr *l_hdr;\n            for(l_hdr = (struct nlmsghdr *)l_buffer; NLMSG_OK(l_hdr, (unsigned int)l_read); l_hdr = (struct nlmsghdr *)NLMSG_NEXT(l_hdr, l_read))\n            {\n                if((pid_t)l_hdr->nlmsg_pid != l_pid || (int)l_hdr->nlmsg_seq != p_socket)\n                {\n                    continue;\n                }\n\n                if(l_hdr->nlmsg_type == NLMSG_DONE)\n                {\n                    *p_done = 1;\n                    break;\n                }\n\n                if(l_hdr->nlmsg_type == NLMSG_ERROR)\n                {\n                    free(l_buffer);\n                    return NULL;\n                }\n            }\n            return l_buffer;\n        }\n\n        l_size *= 2;\n    }\n}",
    "includes": [
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"ifaddrs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "l_buffer"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "freeifaddrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
          "lines": "590-599",
          "snippet": "void freeifaddrs(struct ifaddrs *ifa)\n{\n    struct ifaddrs *l_cur;\n    while(ifa)\n    {\n        l_cur = ifa;\n        ifa = ifa->ifa_next;\n        free(l_cur);\n    }\n}",
          "includes": [
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"ifaddrs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nvoid freeifaddrs(struct ifaddrs *ifa)\n{\n    struct ifaddrs *l_cur;\n    while(ifa)\n    {\n        l_cur = ifa;\n        ifa = ifa->ifa_next;\n        free(l_cur);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "NLMSG_NEXT",
          "args": [
            "l_hdr",
            "l_read"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_OK",
          "args": [
            "l_hdr",
            "(unsigned int)l_read"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlink_recv",
          "args": [
            "p_socket",
            "l_buffer",
            "l_size"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "netlink_recv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
          "lines": "84-116",
          "snippet": "static int netlink_recv(int p_socket, void *p_buffer, size_t p_len)\n{\n    struct msghdr l_msg;\n    struct iovec l_iov = { p_buffer, p_len };\n    struct sockaddr_nl l_addr;\n\n    for(;;)\n    {\n        l_msg.msg_name = (void *)&l_addr;\n        l_msg.msg_namelen = sizeof(l_addr);\n        l_msg.msg_iov = &l_iov;\n        l_msg.msg_iovlen = 1;\n        l_msg.msg_control = NULL;\n        l_msg.msg_controllen = 0;\n        l_msg.msg_flags = 0;\n        int l_result = recvmsg(p_socket, &l_msg, 0);\n\n        if(l_result < 0)\n        {\n            if(errno == EINTR)\n            {\n                continue;\n            }\n            return -2;\n        }\n\n        if(l_msg.msg_flags & MSG_TRUNC)\n        { // buffer was too small\n            return -1;\n        }\n        return l_result;\n    }\n}",
          "includes": [
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"ifaddrs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nstatic int netlink_recv(int p_socket, void *p_buffer, size_t p_len)\n{\n    struct msghdr l_msg;\n    struct iovec l_iov = { p_buffer, p_len };\n    struct sockaddr_nl l_addr;\n\n    for(;;)\n    {\n        l_msg.msg_name = (void *)&l_addr;\n        l_msg.msg_namelen = sizeof(l_addr);\n        l_msg.msg_iov = &l_iov;\n        l_msg.msg_iovlen = 1;\n        l_msg.msg_control = NULL;\n        l_msg.msg_controllen = 0;\n        l_msg.msg_flags = 0;\n        int l_result = recvmsg(p_socket, &l_msg, 0);\n\n        if(l_result < 0)\n        {\n            if(errno == EINTR)\n            {\n                continue;\n            }\n            return -2;\n        }\n\n        if(l_msg.msg_flags & MSG_TRUNC)\n        { // buffer was too small\n            return -1;\n        }\n        return l_result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "l_size"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nstatic struct nlmsghdr *getNetlinkResponse(int p_socket, int *p_size, int *p_done)\n{\n    size_t l_size = 4096;\n    void *l_buffer = NULL;\n\n    for(;;)\n    {\n        free(l_buffer);\n        l_buffer = malloc(l_size);\n\n        int l_read = netlink_recv(p_socket, l_buffer, l_size);\n        *p_size = l_read;\n        if(l_read == -2)\n        {\n            free(l_buffer);\n            return NULL;\n        }\n        if(l_read >= 0)\n        {\n            pid_t l_pid = getpid();\n            struct nlmsghdr *l_hdr;\n            for(l_hdr = (struct nlmsghdr *)l_buffer; NLMSG_OK(l_hdr, (unsigned int)l_read); l_hdr = (struct nlmsghdr *)NLMSG_NEXT(l_hdr, l_read))\n            {\n                if((pid_t)l_hdr->nlmsg_pid != l_pid || (int)l_hdr->nlmsg_seq != p_socket)\n                {\n                    continue;\n                }\n\n                if(l_hdr->nlmsg_type == NLMSG_DONE)\n                {\n                    *p_done = 1;\n                    break;\n                }\n\n                if(l_hdr->nlmsg_type == NLMSG_ERROR)\n                {\n                    free(l_buffer);\n                    return NULL;\n                }\n            }\n            return l_buffer;\n        }\n\n        l_size *= 2;\n    }\n}"
  },
  {
    "function_name": "netlink_recv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
    "lines": "84-116",
    "snippet": "static int netlink_recv(int p_socket, void *p_buffer, size_t p_len)\n{\n    struct msghdr l_msg;\n    struct iovec l_iov = { p_buffer, p_len };\n    struct sockaddr_nl l_addr;\n\n    for(;;)\n    {\n        l_msg.msg_name = (void *)&l_addr;\n        l_msg.msg_namelen = sizeof(l_addr);\n        l_msg.msg_iov = &l_iov;\n        l_msg.msg_iovlen = 1;\n        l_msg.msg_control = NULL;\n        l_msg.msg_controllen = 0;\n        l_msg.msg_flags = 0;\n        int l_result = recvmsg(p_socket, &l_msg, 0);\n\n        if(l_result < 0)\n        {\n            if(errno == EINTR)\n            {\n                continue;\n            }\n            return -2;\n        }\n\n        if(l_msg.msg_flags & MSG_TRUNC)\n        { // buffer was too small\n            return -1;\n        }\n        return l_result;\n    }\n}",
    "includes": [
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"ifaddrs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "recvmsg",
          "args": [
            "p_socket",
            "&l_msg",
            "0"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nstatic int netlink_recv(int p_socket, void *p_buffer, size_t p_len)\n{\n    struct msghdr l_msg;\n    struct iovec l_iov = { p_buffer, p_len };\n    struct sockaddr_nl l_addr;\n\n    for(;;)\n    {\n        l_msg.msg_name = (void *)&l_addr;\n        l_msg.msg_namelen = sizeof(l_addr);\n        l_msg.msg_iov = &l_iov;\n        l_msg.msg_iovlen = 1;\n        l_msg.msg_control = NULL;\n        l_msg.msg_controllen = 0;\n        l_msg.msg_flags = 0;\n        int l_result = recvmsg(p_socket, &l_msg, 0);\n\n        if(l_result < 0)\n        {\n            if(errno == EINTR)\n            {\n                continue;\n            }\n            return -2;\n        }\n\n        if(l_msg.msg_flags & MSG_TRUNC)\n        { // buffer was too small\n            return -1;\n        }\n        return l_result;\n    }\n}"
  },
  {
    "function_name": "netlink_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
    "lines": "64-82",
    "snippet": "static int netlink_send(int p_socket, int p_request)\n{\n    char l_buffer[NLMSG_ALIGN(sizeof(struct nlmsghdr)) + NLMSG_ALIGN(sizeof(struct rtgenmsg))];\n    memset(l_buffer, 0, sizeof(l_buffer));\n    struct nlmsghdr *l_hdr = (struct nlmsghdr *)l_buffer;\n    struct rtgenmsg *l_msg = (struct rtgenmsg *)NLMSG_DATA(l_hdr);\n\n    l_hdr->nlmsg_len = NLMSG_LENGTH(sizeof(*l_msg));\n    l_hdr->nlmsg_type = p_request;\n    l_hdr->nlmsg_flags = NLM_F_ROOT | NLM_F_MATCH | NLM_F_REQUEST;\n    l_hdr->nlmsg_pid = 0;\n    l_hdr->nlmsg_seq = p_socket;\n    l_msg->rtgen_family = AF_UNSPEC;\n\n    struct sockaddr_nl l_addr;\n    memset(&l_addr, 0, sizeof(l_addr));\n    l_addr.nl_family = AF_NETLINK;\n    return (sendto(p_socket, l_hdr, l_hdr->nlmsg_len, 0, (struct sockaddr *)&l_addr, sizeof(l_addr)));\n}",
    "includes": [
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"ifaddrs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sendto",
          "args": [
            "p_socket",
            "l_hdr",
            "l_hdr->nlmsg_len",
            "0",
            "(struct sockaddr *)&l_addr",
            "sizeof(l_addr)"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&l_addr",
            "0",
            "sizeof(l_addr)"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_LENGTH",
          "args": [
            "sizeof(*l_msg)"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_DATA",
          "args": [
            "l_hdr"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "l_buffer",
            "0",
            "sizeof(l_buffer)"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_ALIGN",
          "args": [
            "sizeof(struct rtgenmsg)"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_ALIGN",
          "args": [
            "sizeof(struct nlmsghdr)"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nstatic int netlink_send(int p_socket, int p_request)\n{\n    char l_buffer[NLMSG_ALIGN(sizeof(struct nlmsghdr)) + NLMSG_ALIGN(sizeof(struct rtgenmsg))];\n    memset(l_buffer, 0, sizeof(l_buffer));\n    struct nlmsghdr *l_hdr = (struct nlmsghdr *)l_buffer;\n    struct rtgenmsg *l_msg = (struct rtgenmsg *)NLMSG_DATA(l_hdr);\n\n    l_hdr->nlmsg_len = NLMSG_LENGTH(sizeof(*l_msg));\n    l_hdr->nlmsg_type = p_request;\n    l_hdr->nlmsg_flags = NLM_F_ROOT | NLM_F_MATCH | NLM_F_REQUEST;\n    l_hdr->nlmsg_pid = 0;\n    l_hdr->nlmsg_seq = p_socket;\n    l_msg->rtgen_family = AF_UNSPEC;\n\n    struct sockaddr_nl l_addr;\n    memset(&l_addr, 0, sizeof(l_addr));\n    l_addr.nl_family = AF_NETLINK;\n    return (sendto(p_socket, l_hdr, l_hdr->nlmsg_len, 0, (struct sockaddr *)&l_addr, sizeof(l_addr)));\n}"
  },
  {
    "function_name": "netlink_socket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
    "lines": "44-62",
    "snippet": "static int netlink_socket(void)\n{\n    int l_socket = socket(PF_NETLINK, SOCK_RAW, NETLINK_ROUTE);\n    if(l_socket < 0)\n    {\n        return -1;\n    }\n\n    struct sockaddr_nl l_addr;\n    memset(&l_addr, 0, sizeof(l_addr));\n    l_addr.nl_family = AF_NETLINK;\n    if(bind(l_socket, (struct sockaddr *)&l_addr, sizeof(l_addr)) < 0)\n    {\n        close(l_socket);\n        return -1;\n    }\n\n    return l_socket;\n}",
    "includes": [
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"ifaddrs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "l_socket"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "l_socket",
            "(struct sockaddr *)&l_addr",
            "sizeof(l_addr)"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&l_addr",
            "0",
            "sizeof(l_addr)"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "PF_NETLINK",
            "SOCK_RAW",
            "NETLINK_ROUTE"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nstatic int netlink_socket(void)\n{\n    int l_socket = socket(PF_NETLINK, SOCK_RAW, NETLINK_ROUTE);\n    if(l_socket < 0)\n    {\n        return -1;\n    }\n\n    struct sockaddr_nl l_addr;\n    memset(&l_addr, 0, sizeof(l_addr));\n    l_addr.nl_family = AF_NETLINK;\n    if(bind(l_socket, (struct sockaddr *)&l_addr, sizeof(l_addr)) < 0)\n    {\n        close(l_socket);\n        return -1;\n    }\n\n    return l_socket;\n}"
  }
]