[
  {
    "function_name": "lsm_selinux_drv_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lsm/selinux.c",
    "lines": "110-115",
    "snippet": "struct lsm_drv *lsm_selinux_drv_init(void)\n{\n\tif (!is_selinux_enabled())\n\t\treturn NULL;\n\treturn &selinux_drv;\n}",
    "includes": [
      "#include \"conf.h\"",
      "#include \"lsm/lsm.h\"",
      "#include \"log.h\"",
      "#include <selinux/selinux.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <stdlib.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lsm_drv selinux_drv = {\n\t.name = \"SELinux\",\n\t.enabled           = is_selinux_enabled,\n\t.process_label_get = selinux_process_label_get,\n\t.process_label_set = selinux_process_label_set,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_selinux_enabled",
          "args": [],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conf.h\"\n#include \"lsm/lsm.h\"\n#include \"log.h\"\n#include <selinux/selinux.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <errno.h>\n\nstatic struct lsm_drv selinux_drv = {\n\t.name = \"SELinux\",\n\t.enabled           = is_selinux_enabled,\n\t.process_label_get = selinux_process_label_get,\n\t.process_label_set = selinux_process_label_set,\n};\n\nstruct lsm_drv *lsm_selinux_drv_init(void)\n{\n\tif (!is_selinux_enabled())\n\t\treturn NULL;\n\treturn &selinux_drv;\n}"
  },
  {
    "function_name": "selinux_process_label_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lsm/selinux.c",
    "lines": "74-101",
    "snippet": "static int selinux_process_label_set(const char *inlabel, struct lxc_conf *conf,\n\t\t\t\t     int use_default, int on_exec)\n{\n\tconst char *label = inlabel ? inlabel : conf->lsm_se_context;\n\tif (!label) {\n\t\tif (use_default)\n\t\t\tlabel = DEFAULT_LABEL;\n\t\telse\n\t\t\treturn -1;\n\t}\n\tif (!strcmp(label, \"unconfined_t\"))\n\t\treturn 0;\n\n\tif (on_exec) {\n\t\tif (setexeccon_raw((char *)label) < 0) {\n\t\t\tSYSERROR(\"failed to set new SELinux exec context %s\", label);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tif (setcon_raw((char *)label) < 0) {\n\t\t\tSYSERROR(\"failed to set new SELinux context %s\", label);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tINFO(\"changed SELinux%s context to %s\", on_exec ? \" exec\" : \"\", label);\n\treturn 0;\n}",
    "includes": [
      "#include \"conf.h\"",
      "#include \"lsm/lsm.h\"",
      "#include \"log.h\"",
      "#include <selinux/selinux.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <stdlib.h>",
      "#include <errno.h>"
    ],
    "macros_used": [
      "#define DEFAULT_LABEL \"unconfined_t\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"changed SELinux%s context to %s\"",
            "on_exec ? \" exec\" : \"\"",
            "label"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to set new SELinux context %s\"",
            "label"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setcon_raw",
          "args": [
            "(char *)label"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to set new SELinux exec context %s\"",
            "label"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setexeccon_raw",
          "args": [
            "(char *)label"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "label",
            "\"unconfined_t\""
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conf.h\"\n#include \"lsm/lsm.h\"\n#include \"log.h\"\n#include <selinux/selinux.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <errno.h>\n\n#define DEFAULT_LABEL \"unconfined_t\"\n\nstatic int selinux_process_label_set(const char *inlabel, struct lxc_conf *conf,\n\t\t\t\t     int use_default, int on_exec)\n{\n\tconst char *label = inlabel ? inlabel : conf->lsm_se_context;\n\tif (!label) {\n\t\tif (use_default)\n\t\t\tlabel = DEFAULT_LABEL;\n\t\telse\n\t\t\treturn -1;\n\t}\n\tif (!strcmp(label, \"unconfined_t\"))\n\t\treturn 0;\n\n\tif (on_exec) {\n\t\tif (setexeccon_raw((char *)label) < 0) {\n\t\t\tSYSERROR(\"failed to set new SELinux exec context %s\", label);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tif (setcon_raw((char *)label) < 0) {\n\t\t\tSYSERROR(\"failed to set new SELinux context %s\", label);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tINFO(\"changed SELinux%s context to %s\", on_exec ? \" exec\" : \"\", label);\n\treturn 0;\n}"
  },
  {
    "function_name": "selinux_process_label_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lsm/selinux.c",
    "lines": "48-60",
    "snippet": "static char *selinux_process_label_get(pid_t pid)\n{\n\tsecurity_context_t ctx;\n\tchar *label;\n\n\tif (getpidcon_raw(pid, &ctx) < 0) {\n\t\tSYSERROR(\"failed to get SELinux context for pid %d\", pid);\n\t\treturn NULL;\n\t}\n\tlabel = strdup((char *)ctx);\n\tfreecon(ctx);\n\treturn label;\n}",
    "includes": [
      "#include \"conf.h\"",
      "#include \"lsm/lsm.h\"",
      "#include \"log.h\"",
      "#include <selinux/selinux.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <stdlib.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "freecon",
          "args": [
            "ctx"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "(char *)ctx"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to get SELinux context for pid %d\"",
            "pid"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpidcon_raw",
          "args": [
            "pid",
            "&ctx"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conf.h\"\n#include \"lsm/lsm.h\"\n#include \"log.h\"\n#include <selinux/selinux.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <errno.h>\n\nstatic char *selinux_process_label_get(pid_t pid)\n{\n\tsecurity_context_t ctx;\n\tchar *label;\n\n\tif (getpidcon_raw(pid, &ctx) < 0) {\n\t\tSYSERROR(\"failed to get SELinux context for pid %d\", pid);\n\t\treturn NULL;\n\t}\n\tlabel = strdup((char *)ctx);\n\tfreecon(ctx);\n\treturn label;\n}"
  }
]