[
  {
    "function_name": "btrfs_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
    "lines": "741-749",
    "snippet": "int btrfs_create(struct bdev *bdev, const char *dest, const char *n,\n\t\t struct bdev_specs *specs)\n{\n\tbdev->src = strdup(dest);\n\tbdev->dest = strdup(dest);\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -1;\n\treturn btrfs_subvolume_create(bdev->dest);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_subvolume_create",
          "args": [
            "bdev->dest"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_subvolume_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "221-256",
          "snippet": "static int btrfs_subvolume_create(const char *path)\n{\n\tint ret, fd = -1;\n\tstruct btrfs_ioctl_vol_args  args;\n\tchar *p, *newfull = strdup(path);\n\n\tif (!newfull) {\n\t\tERROR(\"Error: out of memory\");\n\t\treturn -1;\n\t}\n\n\tp = strrchr(newfull, '/');\n\tif (!p) {\n\t\tERROR(\"bad path: %s\", path);\n\t\tfree(newfull);\n\t\treturn -1;\n\t}\n\t*p = '\\0';\n\n\tfd = open(newfull, O_RDONLY);\n\tif (fd < 0) {\n\t\tERROR(\"Error opening %s\", newfull);\n\t\tfree(newfull);\n\t\treturn -1;\n\t}\n\n\tmemset(&args, 0, sizeof(args));\n\tstrncpy(args.name, p+1, BTRFS_SUBVOL_NAME_MAX);\n\targs.name[BTRFS_SUBVOL_NAME_MAX-1] = 0;\n\tret = ioctl(fd, BTRFS_IOC_SUBVOL_CREATE, &args);\n\tINFO(\"btrfs: snapshot create ioctl returned %d\", ret);\n\n\tfree(newfull);\n\tclose(fd);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic int btrfs_subvolume_create(const char *path)\n{\n\tint ret, fd = -1;\n\tstruct btrfs_ioctl_vol_args  args;\n\tchar *p, *newfull = strdup(path);\n\n\tif (!newfull) {\n\t\tERROR(\"Error: out of memory\");\n\t\treturn -1;\n\t}\n\n\tp = strrchr(newfull, '/');\n\tif (!p) {\n\t\tERROR(\"bad path: %s\", path);\n\t\tfree(newfull);\n\t\treturn -1;\n\t}\n\t*p = '\\0';\n\n\tfd = open(newfull, O_RDONLY);\n\tif (fd < 0) {\n\t\tERROR(\"Error opening %s\", newfull);\n\t\tfree(newfull);\n\t\treturn -1;\n\t}\n\n\tmemset(&args, 0, sizeof(args));\n\tstrncpy(args.name, p+1, BTRFS_SUBVOL_NAME_MAX);\n\targs.name[BTRFS_SUBVOL_NAME_MAX-1] = 0;\n\tret = ioctl(fd, BTRFS_IOC_SUBVOL_CREATE, &args);\n\tINFO(\"btrfs: snapshot create ioctl returned %d\", ret);\n\n\tfree(newfull);\n\tclose(fd);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "dest"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "dest"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint btrfs_create(struct bdev *bdev, const char *dest, const char *n,\n\t\t struct bdev_specs *specs)\n{\n\tbdev->src = strdup(dest);\n\tbdev->dest = strdup(dest);\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -1;\n\treturn btrfs_subvolume_create(bdev->dest);\n}"
  },
  {
    "function_name": "btrfs_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
    "lines": "736-739",
    "snippet": "int btrfs_destroy(struct bdev *orig)\n{\n\treturn btrfs_recursive_destroy(orig->src);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_recursive_destroy",
          "args": [
            "orig->src"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_recursive_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "589-727",
          "snippet": "static int btrfs_recursive_destroy(const char *path)\n{\n\tu64 root_id;\n\tint fd;\n\tstruct btrfs_ioctl_search_args args;\n\tstruct btrfs_ioctl_search_key *sk = &args.key;\n\tstruct btrfs_ioctl_search_header sh;\n\tstruct btrfs_root_ref *ref;\n\tstruct my_btrfs_tree *tree;\n\tint ret, e, i;\n\tunsigned long off = 0;\n\tint name_len;\n\tchar *name;\n\tchar *tmppath;\n\tu64 dir_id;\n\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0) {\n\t\tERROR(\"Failed to open %s\\n\", path);\n\t\treturn -1;\n\t}\n\n\tif (btrfs_list_get_path_rootid(fd, &root_id)) {\n\t\te = errno;\n\t\tclose(fd);\n\t\tif (e == EPERM || e == EACCES) {\n\t\t\tWARN(\"Will simply try removing\");\n\t\t\tgoto ignore_search;\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\ttree = create_my_btrfs_tree(root_id, path, strlen(path));\n\tif (!tree) {\n\t\tERROR(\"Out of memory\\n\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\t/* Walk all subvols looking for any under this id */\n\tmemset(&args, 0, sizeof(args));\n\n\t/* search in the tree of tree roots */\n\tsk->tree_id = 1;\n\n\tsk->max_type = BTRFS_ROOT_REF_KEY;\n\tsk->min_type = BTRFS_ROOT_ITEM_KEY;\n\tsk->min_objectid = 0;\n\tsk->max_objectid = (u64)-1;\n\tsk->max_offset = (u64)-1;\n\tsk->min_offset = 0;\n\tsk->max_transid = (u64)-1;\n\tsk->nr_items = 4096;\n\n\twhile(1) {\n\t\tret = ioctl(fd, BTRFS_IOC_TREE_SEARCH, &args);\n\t\te = errno;\n\t\tif (ret < 0) {\n\t\t\tclose(fd);\n\t\t\tfree_btrfs_tree(tree);\n\t\t\tif (e == EPERM || e == EACCES) {\n\t\t\t\tWARN(\"Warn: can't perform the search under %s. Will simply try removing\", path);\n\t\t\t\tgoto ignore_search;\n\t\t\t}\n\n\t\t\tERROR(\"Error: can't perform the search under %s\\n\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tif (sk->nr_items == 0)\n\t\t\tbreak;\n\n\t\toff = 0;\n\t\tfor (i = 0; i < sk->nr_items; i++) {\n\t\t\tmemcpy(&sh, args.buf + off, sizeof(sh));\n\t\t\toff += sizeof(sh);\n\t\t\t/*\n\t\t\t * A backref key with the name and dirid of the parent\n\t\t\t * comes followed by the reoot ref key which has the\n\t\t\t * name of the child subvol in question.\n\t\t\t */\n\t\t\tif (sh.objectid != root_id && sh.type == BTRFS_ROOT_BACKREF_KEY) {\n\t\t\t\tref = (struct btrfs_root_ref *)(args.buf + off);\n\t\t\t\tname_len = btrfs_stack_root_ref_name_len(ref);\n\t\t\t\tname = (char *)(ref + 1);\n\t\t\t\tdir_id = btrfs_stack_root_ref_dirid(ref);\n\t\t\t\ttmppath = get_btrfs_subvol_path(fd, sh.offset,\n\t\t\t\t\t\tdir_id, name, name_len);\n\t\t\t\tif (!add_btrfs_tree_node(tree, sh.objectid,\n\t\t\t\t\t\t\tsh.offset, name,\n\t\t\t\t\t\t\tname_len, tmppath)) {\n\t\t\t\t\tERROR(\"Out of memory\");\n\t\t\t\t\tfree_btrfs_tree(tree);\n\t\t\t\t\tfree(tmppath);\n\t\t\t\t\tclose(fd);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tfree(tmppath);\n\t\t\t}\n\t\t\toff += sh.len;\n\n\t\t\t/*\n\t\t\t * record the mins in sk so we can make sure the\n\t\t\t * next search doesn't repeat this root\n\t\t\t */\n\t\t\tsk->min_objectid = sh.objectid;\n\t\t\tsk->min_type = sh.type;\n\t\t\tsk->min_offset = sh.offset;\n\t\t}\n\t\tsk->nr_items = 4096;\n\t\tsk->min_offset++;\n\t\tif (!sk->min_offset)\n\t\t\tsk->min_type++;\n\t\telse\n\t\t\tcontinue;\n\n\t\tif (sk->min_type > BTRFS_ROOT_BACKREF_KEY) {\n\t\t\tsk->min_type = BTRFS_ROOT_ITEM_KEY;\n\t\t\tsk->min_objectid++;\n\t\t} else\n\t\t\tcontinue;\n\n\t\tif (sk->min_objectid >= sk->max_objectid)\n\t\t\tbreak;\n\t}\n\tclose(fd);\n\n\t/* now actually remove them */\n\n\tif (!do_remove_btrfs_children(tree, root_id, path)) {\n\t\tfree_btrfs_tree(tree);\n\t\tERROR(\"failed pruning\\n\");\n\t\treturn -1;\n\t}\n\n\tfree_btrfs_tree(tree);\n\t/* All child subvols have been removed, now remove this one */\nignore_search:\n\treturn btrfs_do_destroy_subvol(path);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic int btrfs_recursive_destroy(const char *path)\n{\n\tu64 root_id;\n\tint fd;\n\tstruct btrfs_ioctl_search_args args;\n\tstruct btrfs_ioctl_search_key *sk = &args.key;\n\tstruct btrfs_ioctl_search_header sh;\n\tstruct btrfs_root_ref *ref;\n\tstruct my_btrfs_tree *tree;\n\tint ret, e, i;\n\tunsigned long off = 0;\n\tint name_len;\n\tchar *name;\n\tchar *tmppath;\n\tu64 dir_id;\n\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0) {\n\t\tERROR(\"Failed to open %s\\n\", path);\n\t\treturn -1;\n\t}\n\n\tif (btrfs_list_get_path_rootid(fd, &root_id)) {\n\t\te = errno;\n\t\tclose(fd);\n\t\tif (e == EPERM || e == EACCES) {\n\t\t\tWARN(\"Will simply try removing\");\n\t\t\tgoto ignore_search;\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\ttree = create_my_btrfs_tree(root_id, path, strlen(path));\n\tif (!tree) {\n\t\tERROR(\"Out of memory\\n\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\t/* Walk all subvols looking for any under this id */\n\tmemset(&args, 0, sizeof(args));\n\n\t/* search in the tree of tree roots */\n\tsk->tree_id = 1;\n\n\tsk->max_type = BTRFS_ROOT_REF_KEY;\n\tsk->min_type = BTRFS_ROOT_ITEM_KEY;\n\tsk->min_objectid = 0;\n\tsk->max_objectid = (u64)-1;\n\tsk->max_offset = (u64)-1;\n\tsk->min_offset = 0;\n\tsk->max_transid = (u64)-1;\n\tsk->nr_items = 4096;\n\n\twhile(1) {\n\t\tret = ioctl(fd, BTRFS_IOC_TREE_SEARCH, &args);\n\t\te = errno;\n\t\tif (ret < 0) {\n\t\t\tclose(fd);\n\t\t\tfree_btrfs_tree(tree);\n\t\t\tif (e == EPERM || e == EACCES) {\n\t\t\t\tWARN(\"Warn: can't perform the search under %s. Will simply try removing\", path);\n\t\t\t\tgoto ignore_search;\n\t\t\t}\n\n\t\t\tERROR(\"Error: can't perform the search under %s\\n\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tif (sk->nr_items == 0)\n\t\t\tbreak;\n\n\t\toff = 0;\n\t\tfor (i = 0; i < sk->nr_items; i++) {\n\t\t\tmemcpy(&sh, args.buf + off, sizeof(sh));\n\t\t\toff += sizeof(sh);\n\t\t\t/*\n\t\t\t * A backref key with the name and dirid of the parent\n\t\t\t * comes followed by the reoot ref key which has the\n\t\t\t * name of the child subvol in question.\n\t\t\t */\n\t\t\tif (sh.objectid != root_id && sh.type == BTRFS_ROOT_BACKREF_KEY) {\n\t\t\t\tref = (struct btrfs_root_ref *)(args.buf + off);\n\t\t\t\tname_len = btrfs_stack_root_ref_name_len(ref);\n\t\t\t\tname = (char *)(ref + 1);\n\t\t\t\tdir_id = btrfs_stack_root_ref_dirid(ref);\n\t\t\t\ttmppath = get_btrfs_subvol_path(fd, sh.offset,\n\t\t\t\t\t\tdir_id, name, name_len);\n\t\t\t\tif (!add_btrfs_tree_node(tree, sh.objectid,\n\t\t\t\t\t\t\tsh.offset, name,\n\t\t\t\t\t\t\tname_len, tmppath)) {\n\t\t\t\t\tERROR(\"Out of memory\");\n\t\t\t\t\tfree_btrfs_tree(tree);\n\t\t\t\t\tfree(tmppath);\n\t\t\t\t\tclose(fd);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tfree(tmppath);\n\t\t\t}\n\t\t\toff += sh.len;\n\n\t\t\t/*\n\t\t\t * record the mins in sk so we can make sure the\n\t\t\t * next search doesn't repeat this root\n\t\t\t */\n\t\t\tsk->min_objectid = sh.objectid;\n\t\t\tsk->min_type = sh.type;\n\t\t\tsk->min_offset = sh.offset;\n\t\t}\n\t\tsk->nr_items = 4096;\n\t\tsk->min_offset++;\n\t\tif (!sk->min_offset)\n\t\t\tsk->min_type++;\n\t\telse\n\t\t\tcontinue;\n\n\t\tif (sk->min_type > BTRFS_ROOT_BACKREF_KEY) {\n\t\t\tsk->min_type = BTRFS_ROOT_ITEM_KEY;\n\t\t\tsk->min_objectid++;\n\t\t} else\n\t\t\tcontinue;\n\n\t\tif (sk->min_objectid >= sk->max_objectid)\n\t\t\tbreak;\n\t}\n\tclose(fd);\n\n\t/* now actually remove them */\n\n\tif (!do_remove_btrfs_children(tree, root_id, path)) {\n\t\tfree_btrfs_tree(tree);\n\t\tERROR(\"failed pruning\\n\");\n\t\treturn -1;\n\t}\n\n\tfree_btrfs_tree(tree);\n\t/* All child subvols have been removed, now remove this one */\nignore_search:\n\treturn btrfs_do_destroy_subvol(path);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint btrfs_destroy(struct bdev *orig)\n{\n\treturn btrfs_recursive_destroy(orig->src);\n}"
  },
  {
    "function_name": "btrfs_try_remove_subvol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
    "lines": "729-734",
    "snippet": "bool btrfs_try_remove_subvol(const char *path)\n{\n\tif (!btrfs_detect(path))\n\t\treturn false;\n\treturn btrfs_recursive_destroy(path) == 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_recursive_destroy",
          "args": [
            "path"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_recursive_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "589-727",
          "snippet": "static int btrfs_recursive_destroy(const char *path)\n{\n\tu64 root_id;\n\tint fd;\n\tstruct btrfs_ioctl_search_args args;\n\tstruct btrfs_ioctl_search_key *sk = &args.key;\n\tstruct btrfs_ioctl_search_header sh;\n\tstruct btrfs_root_ref *ref;\n\tstruct my_btrfs_tree *tree;\n\tint ret, e, i;\n\tunsigned long off = 0;\n\tint name_len;\n\tchar *name;\n\tchar *tmppath;\n\tu64 dir_id;\n\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0) {\n\t\tERROR(\"Failed to open %s\\n\", path);\n\t\treturn -1;\n\t}\n\n\tif (btrfs_list_get_path_rootid(fd, &root_id)) {\n\t\te = errno;\n\t\tclose(fd);\n\t\tif (e == EPERM || e == EACCES) {\n\t\t\tWARN(\"Will simply try removing\");\n\t\t\tgoto ignore_search;\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\ttree = create_my_btrfs_tree(root_id, path, strlen(path));\n\tif (!tree) {\n\t\tERROR(\"Out of memory\\n\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\t/* Walk all subvols looking for any under this id */\n\tmemset(&args, 0, sizeof(args));\n\n\t/* search in the tree of tree roots */\n\tsk->tree_id = 1;\n\n\tsk->max_type = BTRFS_ROOT_REF_KEY;\n\tsk->min_type = BTRFS_ROOT_ITEM_KEY;\n\tsk->min_objectid = 0;\n\tsk->max_objectid = (u64)-1;\n\tsk->max_offset = (u64)-1;\n\tsk->min_offset = 0;\n\tsk->max_transid = (u64)-1;\n\tsk->nr_items = 4096;\n\n\twhile(1) {\n\t\tret = ioctl(fd, BTRFS_IOC_TREE_SEARCH, &args);\n\t\te = errno;\n\t\tif (ret < 0) {\n\t\t\tclose(fd);\n\t\t\tfree_btrfs_tree(tree);\n\t\t\tif (e == EPERM || e == EACCES) {\n\t\t\t\tWARN(\"Warn: can't perform the search under %s. Will simply try removing\", path);\n\t\t\t\tgoto ignore_search;\n\t\t\t}\n\n\t\t\tERROR(\"Error: can't perform the search under %s\\n\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tif (sk->nr_items == 0)\n\t\t\tbreak;\n\n\t\toff = 0;\n\t\tfor (i = 0; i < sk->nr_items; i++) {\n\t\t\tmemcpy(&sh, args.buf + off, sizeof(sh));\n\t\t\toff += sizeof(sh);\n\t\t\t/*\n\t\t\t * A backref key with the name and dirid of the parent\n\t\t\t * comes followed by the reoot ref key which has the\n\t\t\t * name of the child subvol in question.\n\t\t\t */\n\t\t\tif (sh.objectid != root_id && sh.type == BTRFS_ROOT_BACKREF_KEY) {\n\t\t\t\tref = (struct btrfs_root_ref *)(args.buf + off);\n\t\t\t\tname_len = btrfs_stack_root_ref_name_len(ref);\n\t\t\t\tname = (char *)(ref + 1);\n\t\t\t\tdir_id = btrfs_stack_root_ref_dirid(ref);\n\t\t\t\ttmppath = get_btrfs_subvol_path(fd, sh.offset,\n\t\t\t\t\t\tdir_id, name, name_len);\n\t\t\t\tif (!add_btrfs_tree_node(tree, sh.objectid,\n\t\t\t\t\t\t\tsh.offset, name,\n\t\t\t\t\t\t\tname_len, tmppath)) {\n\t\t\t\t\tERROR(\"Out of memory\");\n\t\t\t\t\tfree_btrfs_tree(tree);\n\t\t\t\t\tfree(tmppath);\n\t\t\t\t\tclose(fd);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tfree(tmppath);\n\t\t\t}\n\t\t\toff += sh.len;\n\n\t\t\t/*\n\t\t\t * record the mins in sk so we can make sure the\n\t\t\t * next search doesn't repeat this root\n\t\t\t */\n\t\t\tsk->min_objectid = sh.objectid;\n\t\t\tsk->min_type = sh.type;\n\t\t\tsk->min_offset = sh.offset;\n\t\t}\n\t\tsk->nr_items = 4096;\n\t\tsk->min_offset++;\n\t\tif (!sk->min_offset)\n\t\t\tsk->min_type++;\n\t\telse\n\t\t\tcontinue;\n\n\t\tif (sk->min_type > BTRFS_ROOT_BACKREF_KEY) {\n\t\t\tsk->min_type = BTRFS_ROOT_ITEM_KEY;\n\t\t\tsk->min_objectid++;\n\t\t} else\n\t\t\tcontinue;\n\n\t\tif (sk->min_objectid >= sk->max_objectid)\n\t\t\tbreak;\n\t}\n\tclose(fd);\n\n\t/* now actually remove them */\n\n\tif (!do_remove_btrfs_children(tree, root_id, path)) {\n\t\tfree_btrfs_tree(tree);\n\t\tERROR(\"failed pruning\\n\");\n\t\treturn -1;\n\t}\n\n\tfree_btrfs_tree(tree);\n\t/* All child subvols have been removed, now remove this one */\nignore_search:\n\treturn btrfs_do_destroy_subvol(path);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic int btrfs_recursive_destroy(const char *path)\n{\n\tu64 root_id;\n\tint fd;\n\tstruct btrfs_ioctl_search_args args;\n\tstruct btrfs_ioctl_search_key *sk = &args.key;\n\tstruct btrfs_ioctl_search_header sh;\n\tstruct btrfs_root_ref *ref;\n\tstruct my_btrfs_tree *tree;\n\tint ret, e, i;\n\tunsigned long off = 0;\n\tint name_len;\n\tchar *name;\n\tchar *tmppath;\n\tu64 dir_id;\n\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0) {\n\t\tERROR(\"Failed to open %s\\n\", path);\n\t\treturn -1;\n\t}\n\n\tif (btrfs_list_get_path_rootid(fd, &root_id)) {\n\t\te = errno;\n\t\tclose(fd);\n\t\tif (e == EPERM || e == EACCES) {\n\t\t\tWARN(\"Will simply try removing\");\n\t\t\tgoto ignore_search;\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\ttree = create_my_btrfs_tree(root_id, path, strlen(path));\n\tif (!tree) {\n\t\tERROR(\"Out of memory\\n\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\t/* Walk all subvols looking for any under this id */\n\tmemset(&args, 0, sizeof(args));\n\n\t/* search in the tree of tree roots */\n\tsk->tree_id = 1;\n\n\tsk->max_type = BTRFS_ROOT_REF_KEY;\n\tsk->min_type = BTRFS_ROOT_ITEM_KEY;\n\tsk->min_objectid = 0;\n\tsk->max_objectid = (u64)-1;\n\tsk->max_offset = (u64)-1;\n\tsk->min_offset = 0;\n\tsk->max_transid = (u64)-1;\n\tsk->nr_items = 4096;\n\n\twhile(1) {\n\t\tret = ioctl(fd, BTRFS_IOC_TREE_SEARCH, &args);\n\t\te = errno;\n\t\tif (ret < 0) {\n\t\t\tclose(fd);\n\t\t\tfree_btrfs_tree(tree);\n\t\t\tif (e == EPERM || e == EACCES) {\n\t\t\t\tWARN(\"Warn: can't perform the search under %s. Will simply try removing\", path);\n\t\t\t\tgoto ignore_search;\n\t\t\t}\n\n\t\t\tERROR(\"Error: can't perform the search under %s\\n\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tif (sk->nr_items == 0)\n\t\t\tbreak;\n\n\t\toff = 0;\n\t\tfor (i = 0; i < sk->nr_items; i++) {\n\t\t\tmemcpy(&sh, args.buf + off, sizeof(sh));\n\t\t\toff += sizeof(sh);\n\t\t\t/*\n\t\t\t * A backref key with the name and dirid of the parent\n\t\t\t * comes followed by the reoot ref key which has the\n\t\t\t * name of the child subvol in question.\n\t\t\t */\n\t\t\tif (sh.objectid != root_id && sh.type == BTRFS_ROOT_BACKREF_KEY) {\n\t\t\t\tref = (struct btrfs_root_ref *)(args.buf + off);\n\t\t\t\tname_len = btrfs_stack_root_ref_name_len(ref);\n\t\t\t\tname = (char *)(ref + 1);\n\t\t\t\tdir_id = btrfs_stack_root_ref_dirid(ref);\n\t\t\t\ttmppath = get_btrfs_subvol_path(fd, sh.offset,\n\t\t\t\t\t\tdir_id, name, name_len);\n\t\t\t\tif (!add_btrfs_tree_node(tree, sh.objectid,\n\t\t\t\t\t\t\tsh.offset, name,\n\t\t\t\t\t\t\tname_len, tmppath)) {\n\t\t\t\t\tERROR(\"Out of memory\");\n\t\t\t\t\tfree_btrfs_tree(tree);\n\t\t\t\t\tfree(tmppath);\n\t\t\t\t\tclose(fd);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tfree(tmppath);\n\t\t\t}\n\t\t\toff += sh.len;\n\n\t\t\t/*\n\t\t\t * record the mins in sk so we can make sure the\n\t\t\t * next search doesn't repeat this root\n\t\t\t */\n\t\t\tsk->min_objectid = sh.objectid;\n\t\t\tsk->min_type = sh.type;\n\t\t\tsk->min_offset = sh.offset;\n\t\t}\n\t\tsk->nr_items = 4096;\n\t\tsk->min_offset++;\n\t\tif (!sk->min_offset)\n\t\t\tsk->min_type++;\n\t\telse\n\t\t\tcontinue;\n\n\t\tif (sk->min_type > BTRFS_ROOT_BACKREF_KEY) {\n\t\t\tsk->min_type = BTRFS_ROOT_ITEM_KEY;\n\t\t\tsk->min_objectid++;\n\t\t} else\n\t\t\tcontinue;\n\n\t\tif (sk->min_objectid >= sk->max_objectid)\n\t\t\tbreak;\n\t}\n\tclose(fd);\n\n\t/* now actually remove them */\n\n\tif (!do_remove_btrfs_children(tree, root_id, path)) {\n\t\tfree_btrfs_tree(tree);\n\t\tERROR(\"failed pruning\\n\");\n\t\treturn -1;\n\t}\n\n\tfree_btrfs_tree(tree);\n\t/* All child subvols have been removed, now remove this one */\nignore_search:\n\treturn btrfs_do_destroy_subvol(path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_detect",
          "args": [
            "path"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_detect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "172-189",
          "snippet": "int btrfs_detect(const char *path)\n{\n\tstruct stat st;\n\tint ret;\n\n\tif (!is_btrfs_fs(path))\n\t\treturn 0;\n\n\t// and make sure it's a subvolume.\n\tret = stat(path, &st);\n\tif (ret < 0)\n\t\treturn 0;\n\n\tif (st.st_ino == 256 && S_ISDIR(st.st_mode))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint btrfs_detect(const char *path)\n{\n\tstruct stat st;\n\tint ret;\n\n\tif (!is_btrfs_fs(path))\n\t\treturn 0;\n\n\t// and make sure it's a subvolume.\n\tret = stat(path, &st);\n\tif (ret < 0)\n\t\treturn 0;\n\n\tif (st.st_ino == 256 && S_ISDIR(st.st_mode))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nbool btrfs_try_remove_subvol(const char *path)\n{\n\tif (!btrfs_detect(path))\n\t\treturn false;\n\treturn btrfs_recursive_destroy(path) == 0;\n}"
  },
  {
    "function_name": "btrfs_recursive_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
    "lines": "589-727",
    "snippet": "static int btrfs_recursive_destroy(const char *path)\n{\n\tu64 root_id;\n\tint fd;\n\tstruct btrfs_ioctl_search_args args;\n\tstruct btrfs_ioctl_search_key *sk = &args.key;\n\tstruct btrfs_ioctl_search_header sh;\n\tstruct btrfs_root_ref *ref;\n\tstruct my_btrfs_tree *tree;\n\tint ret, e, i;\n\tunsigned long off = 0;\n\tint name_len;\n\tchar *name;\n\tchar *tmppath;\n\tu64 dir_id;\n\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0) {\n\t\tERROR(\"Failed to open %s\\n\", path);\n\t\treturn -1;\n\t}\n\n\tif (btrfs_list_get_path_rootid(fd, &root_id)) {\n\t\te = errno;\n\t\tclose(fd);\n\t\tif (e == EPERM || e == EACCES) {\n\t\t\tWARN(\"Will simply try removing\");\n\t\t\tgoto ignore_search;\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\ttree = create_my_btrfs_tree(root_id, path, strlen(path));\n\tif (!tree) {\n\t\tERROR(\"Out of memory\\n\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\t/* Walk all subvols looking for any under this id */\n\tmemset(&args, 0, sizeof(args));\n\n\t/* search in the tree of tree roots */\n\tsk->tree_id = 1;\n\n\tsk->max_type = BTRFS_ROOT_REF_KEY;\n\tsk->min_type = BTRFS_ROOT_ITEM_KEY;\n\tsk->min_objectid = 0;\n\tsk->max_objectid = (u64)-1;\n\tsk->max_offset = (u64)-1;\n\tsk->min_offset = 0;\n\tsk->max_transid = (u64)-1;\n\tsk->nr_items = 4096;\n\n\twhile(1) {\n\t\tret = ioctl(fd, BTRFS_IOC_TREE_SEARCH, &args);\n\t\te = errno;\n\t\tif (ret < 0) {\n\t\t\tclose(fd);\n\t\t\tfree_btrfs_tree(tree);\n\t\t\tif (e == EPERM || e == EACCES) {\n\t\t\t\tWARN(\"Warn: can't perform the search under %s. Will simply try removing\", path);\n\t\t\t\tgoto ignore_search;\n\t\t\t}\n\n\t\t\tERROR(\"Error: can't perform the search under %s\\n\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tif (sk->nr_items == 0)\n\t\t\tbreak;\n\n\t\toff = 0;\n\t\tfor (i = 0; i < sk->nr_items; i++) {\n\t\t\tmemcpy(&sh, args.buf + off, sizeof(sh));\n\t\t\toff += sizeof(sh);\n\t\t\t/*\n\t\t\t * A backref key with the name and dirid of the parent\n\t\t\t * comes followed by the reoot ref key which has the\n\t\t\t * name of the child subvol in question.\n\t\t\t */\n\t\t\tif (sh.objectid != root_id && sh.type == BTRFS_ROOT_BACKREF_KEY) {\n\t\t\t\tref = (struct btrfs_root_ref *)(args.buf + off);\n\t\t\t\tname_len = btrfs_stack_root_ref_name_len(ref);\n\t\t\t\tname = (char *)(ref + 1);\n\t\t\t\tdir_id = btrfs_stack_root_ref_dirid(ref);\n\t\t\t\ttmppath = get_btrfs_subvol_path(fd, sh.offset,\n\t\t\t\t\t\tdir_id, name, name_len);\n\t\t\t\tif (!add_btrfs_tree_node(tree, sh.objectid,\n\t\t\t\t\t\t\tsh.offset, name,\n\t\t\t\t\t\t\tname_len, tmppath)) {\n\t\t\t\t\tERROR(\"Out of memory\");\n\t\t\t\t\tfree_btrfs_tree(tree);\n\t\t\t\t\tfree(tmppath);\n\t\t\t\t\tclose(fd);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tfree(tmppath);\n\t\t\t}\n\t\t\toff += sh.len;\n\n\t\t\t/*\n\t\t\t * record the mins in sk so we can make sure the\n\t\t\t * next search doesn't repeat this root\n\t\t\t */\n\t\t\tsk->min_objectid = sh.objectid;\n\t\t\tsk->min_type = sh.type;\n\t\t\tsk->min_offset = sh.offset;\n\t\t}\n\t\tsk->nr_items = 4096;\n\t\tsk->min_offset++;\n\t\tif (!sk->min_offset)\n\t\t\tsk->min_type++;\n\t\telse\n\t\t\tcontinue;\n\n\t\tif (sk->min_type > BTRFS_ROOT_BACKREF_KEY) {\n\t\t\tsk->min_type = BTRFS_ROOT_ITEM_KEY;\n\t\t\tsk->min_objectid++;\n\t\t} else\n\t\t\tcontinue;\n\n\t\tif (sk->min_objectid >= sk->max_objectid)\n\t\t\tbreak;\n\t}\n\tclose(fd);\n\n\t/* now actually remove them */\n\n\tif (!do_remove_btrfs_children(tree, root_id, path)) {\n\t\tfree_btrfs_tree(tree);\n\t\tERROR(\"failed pruning\\n\");\n\t\treturn -1;\n\t}\n\n\tfree_btrfs_tree(tree);\n\t/* All child subvols have been removed, now remove this one */\nignore_search:\n\treturn btrfs_do_destroy_subvol(path);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_do_destroy_subvol",
          "args": [
            "path"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_do_destroy_subvol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "412-449",
          "snippet": "static int btrfs_do_destroy_subvol(const char *path)\n{\n\tint ret, fd = -1;\n\tstruct btrfs_ioctl_vol_args  args;\n\tchar *p, *newfull = strdup(path);\n\n\tif (!newfull) {\n\t\tERROR(\"Error: out of memory\");\n\t\treturn -1;\n\t}\n\n\tp = strrchr(newfull, '/');\n\tif (!p) {\n\t\tERROR(\"bad path: %s\", path);\n\t\tfree(newfull);\n\t\treturn -1;\n\t}\n\t*p = '\\0';\n\n\tfd = open(newfull, O_RDONLY);\n\tif (fd < 0) {\n\t\tSYSERROR(\"Error opening %s\", newfull);\n\t\tfree(newfull);\n\t\treturn -1;\n\t}\n\n\tmemset(&args, 0, sizeof(args));\n\tstrncpy(args.name, p+1, BTRFS_SUBVOL_NAME_MAX);\n\targs.name[BTRFS_SUBVOL_NAME_MAX-1] = 0;\n\tret = ioctl(fd, BTRFS_IOC_SNAP_DESTROY, &args);\n\tINFO(\"btrfs: snapshot destroy ioctl returned %d for %s\", ret, path);\n\tif (ret < 0 && errno == EPERM)\n\t\tERROR(\"Is the rootfs mounted with -o user_subvol_rm_allowed?\");\n\n\tfree(newfull);\n\tclose(fd);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic int btrfs_do_destroy_subvol(const char *path)\n{\n\tint ret, fd = -1;\n\tstruct btrfs_ioctl_vol_args  args;\n\tchar *p, *newfull = strdup(path);\n\n\tif (!newfull) {\n\t\tERROR(\"Error: out of memory\");\n\t\treturn -1;\n\t}\n\n\tp = strrchr(newfull, '/');\n\tif (!p) {\n\t\tERROR(\"bad path: %s\", path);\n\t\tfree(newfull);\n\t\treturn -1;\n\t}\n\t*p = '\\0';\n\n\tfd = open(newfull, O_RDONLY);\n\tif (fd < 0) {\n\t\tSYSERROR(\"Error opening %s\", newfull);\n\t\tfree(newfull);\n\t\treturn -1;\n\t}\n\n\tmemset(&args, 0, sizeof(args));\n\tstrncpy(args.name, p+1, BTRFS_SUBVOL_NAME_MAX);\n\targs.name[BTRFS_SUBVOL_NAME_MAX-1] = 0;\n\tret = ioctl(fd, BTRFS_IOC_SNAP_DESTROY, &args);\n\tINFO(\"btrfs: snapshot destroy ioctl returned %d for %s\", ret, path);\n\tif (ret < 0 && errno == EPERM)\n\t\tERROR(\"Is the rootfs mounted with -o user_subvol_rm_allowed?\");\n\n\tfree(newfull);\n\tclose(fd);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_btrfs_tree",
          "args": [
            "tree"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "free_btrfs_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "536-547",
          "snippet": "static void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed pruning\\n\""
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_remove_btrfs_children",
          "args": [
            "tree",
            "root_id",
            "path"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "do_remove_btrfs_children",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "553-587",
          "snippet": "static bool do_remove_btrfs_children(struct my_btrfs_tree *tree, u64 root_id,\n\t\t\t\t     const char *path)\n{\n\tint i;\n\tchar *newpath;\n\tsize_t len;\n\n\tfor (i = 0; i < tree->num; i++) {\n\t\tif (tree->nodes[i].parentid == root_id) {\n\t\t\tif (!tree->nodes[i].dirname) {\n\t\t\t\tWARN(\"Odd condition: child objid with no name under %s\\n\", path);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlen = strlen(path) + strlen(tree->nodes[i].dirname) + 2;\n\t\t\tnewpath = malloc(len);\n\t\t\tif (!newpath) {\n\t\t\t\tERROR(\"Out of memory\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tsnprintf(newpath, len, \"%s/%s\", path, tree->nodes[i].dirname);\n\t\t\tif (!do_remove_btrfs_children(tree, tree->nodes[i].objid, newpath)) {\n\t\t\t\tERROR(\"Failed to prune %s\\n\", tree->nodes[i].name);\n\t\t\t\tfree(newpath);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (btrfs_do_destroy_subvol(newpath) != 0) {\n\t\t\t\tERROR(\"Failed to remove %s\\n\", newpath);\n\t\t\t\tfree(newpath);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfree(newpath);\n\t\t}\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic bool do_remove_btrfs_children(struct my_btrfs_tree *tree, u64 root_id,\n\t\t\t\t     const char *path)\n{\n\tint i;\n\tchar *newpath;\n\tsize_t len;\n\n\tfor (i = 0; i < tree->num; i++) {\n\t\tif (tree->nodes[i].parentid == root_id) {\n\t\t\tif (!tree->nodes[i].dirname) {\n\t\t\t\tWARN(\"Odd condition: child objid with no name under %s\\n\", path);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlen = strlen(path) + strlen(tree->nodes[i].dirname) + 2;\n\t\t\tnewpath = malloc(len);\n\t\t\tif (!newpath) {\n\t\t\t\tERROR(\"Out of memory\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tsnprintf(newpath, len, \"%s/%s\", path, tree->nodes[i].dirname);\n\t\t\tif (!do_remove_btrfs_children(tree, tree->nodes[i].objid, newpath)) {\n\t\t\t\tERROR(\"Failed to prune %s\\n\", tree->nodes[i].name);\n\t\t\t\tfree(newpath);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (btrfs_do_destroy_subvol(newpath) != 0) {\n\t\t\t\tERROR(\"Failed to remove %s\\n\", newpath);\n\t\t\t\tfree(newpath);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfree(newpath);\n\t\t}\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Out of memory\""
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_btrfs_tree_node",
          "args": [
            "tree",
            "sh.objectid",
            "sh.offset",
            "name",
            "name_len",
            "tmppath"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "add_btrfs_tree_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "514-534",
          "snippet": "static bool add_btrfs_tree_node(struct my_btrfs_tree *tree, u64 id, u64 parent,\n\t\t\t\tchar *name, int name_len, char *dirname)\n{\n\tstruct mytree_node *tmp;\n\n\tint i = get_btrfs_tree_idx(tree, id);\n\tif (i != -1)\n\t\treturn update_tree_node(&tree->nodes[i], id, parent, name,\n\t\t\t\tname_len, dirname);\n\n\ttmp = realloc(tree->nodes, (tree->num+1) * sizeof(struct mytree_node));\n\tif (!tmp)\n\t\treturn false;\n\ttree->nodes = tmp;\n\tmemset(&tree->nodes[tree->num], 0, sizeof(struct mytree_node));\n\tif (!update_tree_node(&tree->nodes[tree->num], id, parent, name,\n\t\t\t\tname_len, dirname))\n\t\treturn false;\n\ttree->num++;\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic bool add_btrfs_tree_node(struct my_btrfs_tree *tree, u64 id, u64 parent,\n\t\t\t\tchar *name, int name_len, char *dirname)\n{\n\tstruct mytree_node *tmp;\n\n\tint i = get_btrfs_tree_idx(tree, id);\n\tif (i != -1)\n\t\treturn update_tree_node(&tree->nodes[i], id, parent, name,\n\t\t\t\tname_len, dirname);\n\n\ttmp = realloc(tree->nodes, (tree->num+1) * sizeof(struct mytree_node));\n\tif (!tmp)\n\t\treturn false;\n\ttree->nodes = tmp;\n\tmemset(&tree->nodes[tree->num], 0, sizeof(struct mytree_node));\n\tif (!update_tree_node(&tree->nodes[tree->num], id, parent, name,\n\t\t\t\tname_len, dirname))\n\t\treturn false;\n\ttree->num++;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_btrfs_subvol_path",
          "args": [
            "fd",
            "sh.offset",
            "dir_id",
            "name",
            "name_len"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "get_btrfs_subvol_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "56-103",
          "snippet": "char *get_btrfs_subvol_path(int fd, u64 dir_id, u64 objid, char *name,\n\t\t\t    int name_len)\n{\n\tstruct btrfs_ioctl_ino_lookup_args args;\n\tint ret, e;\n\tsize_t len;\n\tchar *retpath;\n\n\tmemset(&args, 0, sizeof(args));\n\targs.treeid = dir_id;\n\targs.objectid = objid;\n\n\tret = ioctl(fd, BTRFS_IOC_INO_LOOKUP, &args);\n\te = errno;\n\tif (ret) {\n\t\tERROR(\"%s: ERROR: Failed to lookup path for %llu %llu %s - %s\\n\",\n\t\t\t\t __func__, (unsigned long long) dir_id,\n\t\t\t\t (unsigned long long) objid,\n\t\t\t\t name, strerror(e));\n\t\treturn NULL;\n\t} else\n\t\tINFO(\"%s: got path for %llu %llu - %s\\n\", __func__,\n\t\t\t(unsigned long long) objid, (unsigned long long) dir_id,\n\t\t\tname);\n\n\tif (args.name[0]) {\n\t\t/*\n\t\t * we're in a subdirectory of ref_tree, the kernel ioctl\n\t\t * puts a / in there for us\n\t\t */\n\t\tlen = strlen(args.name) + name_len + 2;\n\t\tretpath = malloc(len);\n\t\tif (!retpath)\n\t\t\treturn NULL;\n\t\tstrcpy(retpath, args.name);\n\t\tstrcat(retpath, \"/\");\n\t\tstrncat(retpath, name, name_len);\n\t} else {\n\t\t/* we're at the root of ref_tree */\n\t\tlen = name_len + 1;\n\t\tretpath = malloc(len);\n\t\tif (!retpath)\n\t\t\treturn NULL;\n\t\t*retpath = '\\0';\n\t\tstrncat(retpath, name, name_len);\n\t}\n\treturn retpath;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nchar *get_btrfs_subvol_path(int fd, u64 dir_id, u64 objid, char *name,\n\t\t\t    int name_len)\n{\n\tstruct btrfs_ioctl_ino_lookup_args args;\n\tint ret, e;\n\tsize_t len;\n\tchar *retpath;\n\n\tmemset(&args, 0, sizeof(args));\n\targs.treeid = dir_id;\n\targs.objectid = objid;\n\n\tret = ioctl(fd, BTRFS_IOC_INO_LOOKUP, &args);\n\te = errno;\n\tif (ret) {\n\t\tERROR(\"%s: ERROR: Failed to lookup path for %llu %llu %s - %s\\n\",\n\t\t\t\t __func__, (unsigned long long) dir_id,\n\t\t\t\t (unsigned long long) objid,\n\t\t\t\t name, strerror(e));\n\t\treturn NULL;\n\t} else\n\t\tINFO(\"%s: got path for %llu %llu - %s\\n\", __func__,\n\t\t\t(unsigned long long) objid, (unsigned long long) dir_id,\n\t\t\tname);\n\n\tif (args.name[0]) {\n\t\t/*\n\t\t * we're in a subdirectory of ref_tree, the kernel ioctl\n\t\t * puts a / in there for us\n\t\t */\n\t\tlen = strlen(args.name) + name_len + 2;\n\t\tretpath = malloc(len);\n\t\tif (!retpath)\n\t\t\treturn NULL;\n\t\tstrcpy(retpath, args.name);\n\t\tstrcat(retpath, \"/\");\n\t\tstrncat(retpath, name, name_len);\n\t} else {\n\t\t/* we're at the root of ref_tree */\n\t\tlen = name_len + 1;\n\t\tretpath = malloc(len);\n\t\tif (!retpath)\n\t\t\treturn NULL;\n\t\t*retpath = '\\0';\n\t\tstrncat(retpath, name, name_len);\n\t}\n\treturn retpath;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_stack_root_ref_dirid",
          "args": [
            "ref"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stack_root_ref_name_len",
          "args": [
            "ref"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&sh",
            "args.buf + off",
            "sizeof(sh)"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error: can't perform the search under %s\\n\"",
            "path"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Warn: can't perform the search under %s. Will simply try removing\"",
            "path"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "BTRFS_IOC_TREE_SEARCH",
            "&args"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&args",
            "0",
            "sizeof(args)"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Out of memory\\n\""
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_my_btrfs_tree",
          "args": [
            "root_id",
            "path",
            "strlen(path)"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "create_my_btrfs_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "463-487",
          "snippet": "static struct my_btrfs_tree *create_my_btrfs_tree(u64 id, const char *path,\n\t\t\t\t\t\t  int name_len)\n{\n\tstruct my_btrfs_tree *tree;\n\n\ttree = malloc(sizeof(struct my_btrfs_tree));\n\tif (!tree)\n\t\treturn NULL;\n\ttree->nodes = malloc(sizeof(struct mytree_node));\n\tif (!tree->nodes) {\n\t\tfree(tree);\n\t\treturn NULL;\n\t}\n\ttree->num = 1;\n\ttree->nodes[0].dirname = NULL;\n\ttree->nodes[0].name = strdup(path);\n\tif (!tree->nodes[0].name) {\n\t\tfree(tree->nodes);\n\t\tfree(tree);\n\t\treturn NULL;\n\t}\n\ttree->nodes[0].parentid = 0;\n\ttree->nodes[0].objid = id;\n\treturn tree;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic struct my_btrfs_tree *create_my_btrfs_tree(u64 id, const char *path,\n\t\t\t\t\t\t  int name_len)\n{\n\tstruct my_btrfs_tree *tree;\n\n\ttree = malloc(sizeof(struct my_btrfs_tree));\n\tif (!tree)\n\t\treturn NULL;\n\ttree->nodes = malloc(sizeof(struct mytree_node));\n\tif (!tree->nodes) {\n\t\tfree(tree);\n\t\treturn NULL;\n\t}\n\ttree->num = 1;\n\ttree->nodes[0].dirname = NULL;\n\ttree->nodes[0].name = strdup(path);\n\tif (!tree->nodes[0].name) {\n\t\tfree(tree->nodes);\n\t\tfree(tree);\n\t\treturn NULL;\n\t}\n\ttree->nodes[0].parentid = 0;\n\ttree->nodes[0].objid = id;\n\treturn tree;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Will simply try removing\""
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_list_get_path_rootid",
          "args": [
            "fd",
            "&root_id"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_list_get_path_rootid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "109-125",
          "snippet": "int btrfs_list_get_path_rootid(int fd, u64 *treeid)\n{\n\tint  ret;\n\tstruct btrfs_ioctl_ino_lookup_args args;\n\n\tmemset(&args, 0, sizeof(args));\n\targs.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\n\tret = ioctl(fd, BTRFS_IOC_INO_LOOKUP, &args);\n\tif (ret < 0) {\n\t\tWARN(\"Warning: can't perform the search -%s\\n\",\n\t\t\t\tstrerror(errno));\n\t\treturn ret;\n\t}\n\t*treeid = args.treeid;\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint btrfs_list_get_path_rootid(int fd, u64 *treeid)\n{\n\tint  ret;\n\tstruct btrfs_ioctl_ino_lookup_args args;\n\n\tmemset(&args, 0, sizeof(args));\n\targs.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\n\tret = ioctl(fd, BTRFS_IOC_INO_LOOKUP, &args);\n\tif (ret < 0) {\n\t\tWARN(\"Warning: can't perform the search -%s\\n\",\n\t\t\t\tstrerror(errno));\n\t\treturn ret;\n\t}\n\t*treeid = args.treeid;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to open %s\\n\"",
            "path"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "path",
            "O_RDONLY"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "genetlink_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/genl.c",
          "lines": "106-116",
          "snippet": "extern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"genl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/genetlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"genl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic int btrfs_recursive_destroy(const char *path)\n{\n\tu64 root_id;\n\tint fd;\n\tstruct btrfs_ioctl_search_args args;\n\tstruct btrfs_ioctl_search_key *sk = &args.key;\n\tstruct btrfs_ioctl_search_header sh;\n\tstruct btrfs_root_ref *ref;\n\tstruct my_btrfs_tree *tree;\n\tint ret, e, i;\n\tunsigned long off = 0;\n\tint name_len;\n\tchar *name;\n\tchar *tmppath;\n\tu64 dir_id;\n\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0) {\n\t\tERROR(\"Failed to open %s\\n\", path);\n\t\treturn -1;\n\t}\n\n\tif (btrfs_list_get_path_rootid(fd, &root_id)) {\n\t\te = errno;\n\t\tclose(fd);\n\t\tif (e == EPERM || e == EACCES) {\n\t\t\tWARN(\"Will simply try removing\");\n\t\t\tgoto ignore_search;\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\ttree = create_my_btrfs_tree(root_id, path, strlen(path));\n\tif (!tree) {\n\t\tERROR(\"Out of memory\\n\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\t/* Walk all subvols looking for any under this id */\n\tmemset(&args, 0, sizeof(args));\n\n\t/* search in the tree of tree roots */\n\tsk->tree_id = 1;\n\n\tsk->max_type = BTRFS_ROOT_REF_KEY;\n\tsk->min_type = BTRFS_ROOT_ITEM_KEY;\n\tsk->min_objectid = 0;\n\tsk->max_objectid = (u64)-1;\n\tsk->max_offset = (u64)-1;\n\tsk->min_offset = 0;\n\tsk->max_transid = (u64)-1;\n\tsk->nr_items = 4096;\n\n\twhile(1) {\n\t\tret = ioctl(fd, BTRFS_IOC_TREE_SEARCH, &args);\n\t\te = errno;\n\t\tif (ret < 0) {\n\t\t\tclose(fd);\n\t\t\tfree_btrfs_tree(tree);\n\t\t\tif (e == EPERM || e == EACCES) {\n\t\t\t\tWARN(\"Warn: can't perform the search under %s. Will simply try removing\", path);\n\t\t\t\tgoto ignore_search;\n\t\t\t}\n\n\t\t\tERROR(\"Error: can't perform the search under %s\\n\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tif (sk->nr_items == 0)\n\t\t\tbreak;\n\n\t\toff = 0;\n\t\tfor (i = 0; i < sk->nr_items; i++) {\n\t\t\tmemcpy(&sh, args.buf + off, sizeof(sh));\n\t\t\toff += sizeof(sh);\n\t\t\t/*\n\t\t\t * A backref key with the name and dirid of the parent\n\t\t\t * comes followed by the reoot ref key which has the\n\t\t\t * name of the child subvol in question.\n\t\t\t */\n\t\t\tif (sh.objectid != root_id && sh.type == BTRFS_ROOT_BACKREF_KEY) {\n\t\t\t\tref = (struct btrfs_root_ref *)(args.buf + off);\n\t\t\t\tname_len = btrfs_stack_root_ref_name_len(ref);\n\t\t\t\tname = (char *)(ref + 1);\n\t\t\t\tdir_id = btrfs_stack_root_ref_dirid(ref);\n\t\t\t\ttmppath = get_btrfs_subvol_path(fd, sh.offset,\n\t\t\t\t\t\tdir_id, name, name_len);\n\t\t\t\tif (!add_btrfs_tree_node(tree, sh.objectid,\n\t\t\t\t\t\t\tsh.offset, name,\n\t\t\t\t\t\t\tname_len, tmppath)) {\n\t\t\t\t\tERROR(\"Out of memory\");\n\t\t\t\t\tfree_btrfs_tree(tree);\n\t\t\t\t\tfree(tmppath);\n\t\t\t\t\tclose(fd);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tfree(tmppath);\n\t\t\t}\n\t\t\toff += sh.len;\n\n\t\t\t/*\n\t\t\t * record the mins in sk so we can make sure the\n\t\t\t * next search doesn't repeat this root\n\t\t\t */\n\t\t\tsk->min_objectid = sh.objectid;\n\t\t\tsk->min_type = sh.type;\n\t\t\tsk->min_offset = sh.offset;\n\t\t}\n\t\tsk->nr_items = 4096;\n\t\tsk->min_offset++;\n\t\tif (!sk->min_offset)\n\t\t\tsk->min_type++;\n\t\telse\n\t\t\tcontinue;\n\n\t\tif (sk->min_type > BTRFS_ROOT_BACKREF_KEY) {\n\t\t\tsk->min_type = BTRFS_ROOT_ITEM_KEY;\n\t\t\tsk->min_objectid++;\n\t\t} else\n\t\t\tcontinue;\n\n\t\tif (sk->min_objectid >= sk->max_objectid)\n\t\t\tbreak;\n\t}\n\tclose(fd);\n\n\t/* now actually remove them */\n\n\tif (!do_remove_btrfs_children(tree, root_id, path)) {\n\t\tfree_btrfs_tree(tree);\n\t\tERROR(\"failed pruning\\n\");\n\t\treturn -1;\n\t}\n\n\tfree_btrfs_tree(tree);\n\t/* All child subvols have been removed, now remove this one */\nignore_search:\n\treturn btrfs_do_destroy_subvol(path);\n}"
  },
  {
    "function_name": "do_remove_btrfs_children",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
    "lines": "553-587",
    "snippet": "static bool do_remove_btrfs_children(struct my_btrfs_tree *tree, u64 root_id,\n\t\t\t\t     const char *path)\n{\n\tint i;\n\tchar *newpath;\n\tsize_t len;\n\n\tfor (i = 0; i < tree->num; i++) {\n\t\tif (tree->nodes[i].parentid == root_id) {\n\t\t\tif (!tree->nodes[i].dirname) {\n\t\t\t\tWARN(\"Odd condition: child objid with no name under %s\\n\", path);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlen = strlen(path) + strlen(tree->nodes[i].dirname) + 2;\n\t\t\tnewpath = malloc(len);\n\t\t\tif (!newpath) {\n\t\t\t\tERROR(\"Out of memory\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tsnprintf(newpath, len, \"%s/%s\", path, tree->nodes[i].dirname);\n\t\t\tif (!do_remove_btrfs_children(tree, tree->nodes[i].objid, newpath)) {\n\t\t\t\tERROR(\"Failed to prune %s\\n\", tree->nodes[i].name);\n\t\t\t\tfree(newpath);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (btrfs_do_destroy_subvol(newpath) != 0) {\n\t\t\t\tERROR(\"Failed to remove %s\\n\", newpath);\n\t\t\t\tfree(newpath);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfree(newpath);\n\t\t}\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "newpath"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "free_btrfs_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "536-547",
          "snippet": "static void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to remove %s\\n\"",
            "newpath"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_do_destroy_subvol",
          "args": [
            "newpath"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_do_destroy_subvol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "412-449",
          "snippet": "static int btrfs_do_destroy_subvol(const char *path)\n{\n\tint ret, fd = -1;\n\tstruct btrfs_ioctl_vol_args  args;\n\tchar *p, *newfull = strdup(path);\n\n\tif (!newfull) {\n\t\tERROR(\"Error: out of memory\");\n\t\treturn -1;\n\t}\n\n\tp = strrchr(newfull, '/');\n\tif (!p) {\n\t\tERROR(\"bad path: %s\", path);\n\t\tfree(newfull);\n\t\treturn -1;\n\t}\n\t*p = '\\0';\n\n\tfd = open(newfull, O_RDONLY);\n\tif (fd < 0) {\n\t\tSYSERROR(\"Error opening %s\", newfull);\n\t\tfree(newfull);\n\t\treturn -1;\n\t}\n\n\tmemset(&args, 0, sizeof(args));\n\tstrncpy(args.name, p+1, BTRFS_SUBVOL_NAME_MAX);\n\targs.name[BTRFS_SUBVOL_NAME_MAX-1] = 0;\n\tret = ioctl(fd, BTRFS_IOC_SNAP_DESTROY, &args);\n\tINFO(\"btrfs: snapshot destroy ioctl returned %d for %s\", ret, path);\n\tif (ret < 0 && errno == EPERM)\n\t\tERROR(\"Is the rootfs mounted with -o user_subvol_rm_allowed?\");\n\n\tfree(newfull);\n\tclose(fd);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic int btrfs_do_destroy_subvol(const char *path)\n{\n\tint ret, fd = -1;\n\tstruct btrfs_ioctl_vol_args  args;\n\tchar *p, *newfull = strdup(path);\n\n\tif (!newfull) {\n\t\tERROR(\"Error: out of memory\");\n\t\treturn -1;\n\t}\n\n\tp = strrchr(newfull, '/');\n\tif (!p) {\n\t\tERROR(\"bad path: %s\", path);\n\t\tfree(newfull);\n\t\treturn -1;\n\t}\n\t*p = '\\0';\n\n\tfd = open(newfull, O_RDONLY);\n\tif (fd < 0) {\n\t\tSYSERROR(\"Error opening %s\", newfull);\n\t\tfree(newfull);\n\t\treturn -1;\n\t}\n\n\tmemset(&args, 0, sizeof(args));\n\tstrncpy(args.name, p+1, BTRFS_SUBVOL_NAME_MAX);\n\targs.name[BTRFS_SUBVOL_NAME_MAX-1] = 0;\n\tret = ioctl(fd, BTRFS_IOC_SNAP_DESTROY, &args);\n\tINFO(\"btrfs: snapshot destroy ioctl returned %d for %s\", ret, path);\n\tif (ret < 0 && errno == EPERM)\n\t\tERROR(\"Is the rootfs mounted with -o user_subvol_rm_allowed?\");\n\n\tfree(newfull);\n\tclose(fd);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to prune %s\\n\"",
            "tree->nodes[i].name"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_remove_btrfs_children",
          "args": [
            "tree",
            "tree->nodes[i].objid",
            "newpath"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "do_remove_btrfs_children",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "553-587",
          "snippet": "static bool do_remove_btrfs_children(struct my_btrfs_tree *tree, u64 root_id,\n\t\t\t\t     const char *path)\n{\n\tint i;\n\tchar *newpath;\n\tsize_t len;\n\n\tfor (i = 0; i < tree->num; i++) {\n\t\tif (tree->nodes[i].parentid == root_id) {\n\t\t\tif (!tree->nodes[i].dirname) {\n\t\t\t\tWARN(\"Odd condition: child objid with no name under %s\\n\", path);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlen = strlen(path) + strlen(tree->nodes[i].dirname) + 2;\n\t\t\tnewpath = malloc(len);\n\t\t\tif (!newpath) {\n\t\t\t\tERROR(\"Out of memory\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tsnprintf(newpath, len, \"%s/%s\", path, tree->nodes[i].dirname);\n\t\t\tif (!do_remove_btrfs_children(tree, tree->nodes[i].objid, newpath)) {\n\t\t\t\tERROR(\"Failed to prune %s\\n\", tree->nodes[i].name);\n\t\t\t\tfree(newpath);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (btrfs_do_destroy_subvol(newpath) != 0) {\n\t\t\t\tERROR(\"Failed to remove %s\\n\", newpath);\n\t\t\t\tfree(newpath);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfree(newpath);\n\t\t}\n\t}\n\treturn true;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "newpath",
            "len",
            "\"%s/%s\"",
            "path",
            "tree->nodes[i].dirname"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Out of memory\""
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tree->nodes[i].dirname"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Odd condition: child objid with no name under %s\\n\"",
            "path"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic bool do_remove_btrfs_children(struct my_btrfs_tree *tree, u64 root_id,\n\t\t\t\t     const char *path)\n{\n\tint i;\n\tchar *newpath;\n\tsize_t len;\n\n\tfor (i = 0; i < tree->num; i++) {\n\t\tif (tree->nodes[i].parentid == root_id) {\n\t\t\tif (!tree->nodes[i].dirname) {\n\t\t\t\tWARN(\"Odd condition: child objid with no name under %s\\n\", path);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlen = strlen(path) + strlen(tree->nodes[i].dirname) + 2;\n\t\t\tnewpath = malloc(len);\n\t\t\tif (!newpath) {\n\t\t\t\tERROR(\"Out of memory\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tsnprintf(newpath, len, \"%s/%s\", path, tree->nodes[i].dirname);\n\t\t\tif (!do_remove_btrfs_children(tree, tree->nodes[i].objid, newpath)) {\n\t\t\t\tERROR(\"Failed to prune %s\\n\", tree->nodes[i].name);\n\t\t\t\tfree(newpath);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (btrfs_do_destroy_subvol(newpath) != 0) {\n\t\t\t\tERROR(\"Failed to remove %s\\n\", newpath);\n\t\t\t\tfree(newpath);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfree(newpath);\n\t\t}\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "free_btrfs_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
    "lines": "536-547",
    "snippet": "static void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tree"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "free_btrfs_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "536-547",
          "snippet": "static void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}"
  },
  {
    "function_name": "add_btrfs_tree_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
    "lines": "514-534",
    "snippet": "static bool add_btrfs_tree_node(struct my_btrfs_tree *tree, u64 id, u64 parent,\n\t\t\t\tchar *name, int name_len, char *dirname)\n{\n\tstruct mytree_node *tmp;\n\n\tint i = get_btrfs_tree_idx(tree, id);\n\tif (i != -1)\n\t\treturn update_tree_node(&tree->nodes[i], id, parent, name,\n\t\t\t\tname_len, dirname);\n\n\ttmp = realloc(tree->nodes, (tree->num+1) * sizeof(struct mytree_node));\n\tif (!tmp)\n\t\treturn false;\n\ttree->nodes = tmp;\n\tmemset(&tree->nodes[tree->num], 0, sizeof(struct mytree_node));\n\tif (!update_tree_node(&tree->nodes[tree->num], id, parent, name,\n\t\t\t\tname_len, dirname))\n\t\treturn false;\n\ttree->num++;\n\treturn true;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_tree_node",
          "args": [
            "&tree->nodes[tree->num]",
            "id",
            "parent",
            "name",
            "name_len",
            "dirname"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "update_tree_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "489-512",
          "snippet": "static bool update_tree_node(struct mytree_node *n, u64 id, u64 parent,\n\t\t\t     char *name, int name_len, char *dirname)\n{\n\tif (id)\n\t\tn->objid = id;\n\tif (parent)\n\t\tn->parentid = parent;\n\tif (name) {\n\t\tn->name = malloc(name_len + 1);\n\t\tif (!n->name)\n\t\t\treturn false;\n\t\tstrncpy(n->name, name, name_len);\n\t\tn->name[name_len] = '\\0';\n\t}\n\tif (dirname) {\n\t\tn->dirname = malloc(strlen(dirname) + 1);\n\t\tif (!n->dirname) {\n\t\t\tfree(n->name);\n\t\t\treturn false;\n\t\t}\n\t\tstrcpy(n->dirname, dirname);\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic bool update_tree_node(struct mytree_node *n, u64 id, u64 parent,\n\t\t\t     char *name, int name_len, char *dirname)\n{\n\tif (id)\n\t\tn->objid = id;\n\tif (parent)\n\t\tn->parentid = parent;\n\tif (name) {\n\t\tn->name = malloc(name_len + 1);\n\t\tif (!n->name)\n\t\t\treturn false;\n\t\tstrncpy(n->name, name, name_len);\n\t\tn->name[name_len] = '\\0';\n\t}\n\tif (dirname) {\n\t\tn->dirname = malloc(strlen(dirname) + 1);\n\t\tif (!n->dirname) {\n\t\t\tfree(n->name);\n\t\t\treturn false;\n\t\t}\n\t\tstrcpy(n->dirname, dirname);\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&tree->nodes[tree->num]",
            "0",
            "sizeof(struct mytree_node)"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "tree->nodes",
            "(tree->num+1) * sizeof(struct mytree_node)"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "must_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "116-124",
          "snippet": "static void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_btrfs_tree_idx",
          "args": [
            "tree",
            "id"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "get_btrfs_tree_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "451-461",
          "snippet": "static int get_btrfs_tree_idx(struct my_btrfs_tree *tree, u64 id)\n{\n\tint i;\n\tif (!tree)\n\t\treturn -1;\n\tfor (i = 0; i < tree->num; i++) {\n\t\tif (tree->nodes[i].objid == id)\n\t\t\treturn i;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic int get_btrfs_tree_idx(struct my_btrfs_tree *tree, u64 id)\n{\n\tint i;\n\tif (!tree)\n\t\treturn -1;\n\tfor (i = 0; i < tree->num; i++) {\n\t\tif (tree->nodes[i].objid == id)\n\t\t\treturn i;\n\t}\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic bool add_btrfs_tree_node(struct my_btrfs_tree *tree, u64 id, u64 parent,\n\t\t\t\tchar *name, int name_len, char *dirname)\n{\n\tstruct mytree_node *tmp;\n\n\tint i = get_btrfs_tree_idx(tree, id);\n\tif (i != -1)\n\t\treturn update_tree_node(&tree->nodes[i], id, parent, name,\n\t\t\t\tname_len, dirname);\n\n\ttmp = realloc(tree->nodes, (tree->num+1) * sizeof(struct mytree_node));\n\tif (!tmp)\n\t\treturn false;\n\ttree->nodes = tmp;\n\tmemset(&tree->nodes[tree->num], 0, sizeof(struct mytree_node));\n\tif (!update_tree_node(&tree->nodes[tree->num], id, parent, name,\n\t\t\t\tname_len, dirname))\n\t\treturn false;\n\ttree->num++;\n\treturn true;\n}"
  },
  {
    "function_name": "update_tree_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
    "lines": "489-512",
    "snippet": "static bool update_tree_node(struct mytree_node *n, u64 id, u64 parent,\n\t\t\t     char *name, int name_len, char *dirname)\n{\n\tif (id)\n\t\tn->objid = id;\n\tif (parent)\n\t\tn->parentid = parent;\n\tif (name) {\n\t\tn->name = malloc(name_len + 1);\n\t\tif (!n->name)\n\t\t\treturn false;\n\t\tstrncpy(n->name, name, name_len);\n\t\tn->name[name_len] = '\\0';\n\t}\n\tif (dirname) {\n\t\tn->dirname = malloc(strlen(dirname) + 1);\n\t\tif (!n->dirname) {\n\t\t\tfree(n->name);\n\t\t\treturn false;\n\t\t}\n\t\tstrcpy(n->dirname, dirname);\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "n->dirname",
            "dirname"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "n->name"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "free_btrfs_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "536-547",
          "snippet": "static void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(dirname) + 1"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dirname"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "n->name",
            "name",
            "name_len"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "name_len + 1"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic bool update_tree_node(struct mytree_node *n, u64 id, u64 parent,\n\t\t\t     char *name, int name_len, char *dirname)\n{\n\tif (id)\n\t\tn->objid = id;\n\tif (parent)\n\t\tn->parentid = parent;\n\tif (name) {\n\t\tn->name = malloc(name_len + 1);\n\t\tif (!n->name)\n\t\t\treturn false;\n\t\tstrncpy(n->name, name, name_len);\n\t\tn->name[name_len] = '\\0';\n\t}\n\tif (dirname) {\n\t\tn->dirname = malloc(strlen(dirname) + 1);\n\t\tif (!n->dirname) {\n\t\t\tfree(n->name);\n\t\t\treturn false;\n\t\t}\n\t\tstrcpy(n->dirname, dirname);\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "create_my_btrfs_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
    "lines": "463-487",
    "snippet": "static struct my_btrfs_tree *create_my_btrfs_tree(u64 id, const char *path,\n\t\t\t\t\t\t  int name_len)\n{\n\tstruct my_btrfs_tree *tree;\n\n\ttree = malloc(sizeof(struct my_btrfs_tree));\n\tif (!tree)\n\t\treturn NULL;\n\ttree->nodes = malloc(sizeof(struct mytree_node));\n\tif (!tree->nodes) {\n\t\tfree(tree);\n\t\treturn NULL;\n\t}\n\ttree->num = 1;\n\ttree->nodes[0].dirname = NULL;\n\ttree->nodes[0].name = strdup(path);\n\tif (!tree->nodes[0].name) {\n\t\tfree(tree->nodes);\n\t\tfree(tree);\n\t\treturn NULL;\n\t}\n\ttree->nodes[0].parentid = 0;\n\ttree->nodes[0].objid = id;\n\treturn tree;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tree"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "free_btrfs_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "536-547",
          "snippet": "static void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "path"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct mytree_node)"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct my_btrfs_tree)"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic struct my_btrfs_tree *create_my_btrfs_tree(u64 id, const char *path,\n\t\t\t\t\t\t  int name_len)\n{\n\tstruct my_btrfs_tree *tree;\n\n\ttree = malloc(sizeof(struct my_btrfs_tree));\n\tif (!tree)\n\t\treturn NULL;\n\ttree->nodes = malloc(sizeof(struct mytree_node));\n\tif (!tree->nodes) {\n\t\tfree(tree);\n\t\treturn NULL;\n\t}\n\ttree->num = 1;\n\ttree->nodes[0].dirname = NULL;\n\ttree->nodes[0].name = strdup(path);\n\tif (!tree->nodes[0].name) {\n\t\tfree(tree->nodes);\n\t\tfree(tree);\n\t\treturn NULL;\n\t}\n\ttree->nodes[0].parentid = 0;\n\ttree->nodes[0].objid = id;\n\treturn tree;\n}"
  },
  {
    "function_name": "get_btrfs_tree_idx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
    "lines": "451-461",
    "snippet": "static int get_btrfs_tree_idx(struct my_btrfs_tree *tree, u64 id)\n{\n\tint i;\n\tif (!tree)\n\t\treturn -1;\n\tfor (i = 0; i < tree->num; i++) {\n\t\tif (tree->nodes[i].objid == id)\n\t\t\treturn i;\n\t}\n\treturn -1;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic int get_btrfs_tree_idx(struct my_btrfs_tree *tree, u64 id)\n{\n\tint i;\n\tif (!tree)\n\t\treturn -1;\n\tfor (i = 0; i < tree->num; i++) {\n\t\tif (tree->nodes[i].objid == id)\n\t\t\treturn i;\n\t}\n\treturn -1;\n}"
  },
  {
    "function_name": "btrfs_do_destroy_subvol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
    "lines": "412-449",
    "snippet": "static int btrfs_do_destroy_subvol(const char *path)\n{\n\tint ret, fd = -1;\n\tstruct btrfs_ioctl_vol_args  args;\n\tchar *p, *newfull = strdup(path);\n\n\tif (!newfull) {\n\t\tERROR(\"Error: out of memory\");\n\t\treturn -1;\n\t}\n\n\tp = strrchr(newfull, '/');\n\tif (!p) {\n\t\tERROR(\"bad path: %s\", path);\n\t\tfree(newfull);\n\t\treturn -1;\n\t}\n\t*p = '\\0';\n\n\tfd = open(newfull, O_RDONLY);\n\tif (fd < 0) {\n\t\tSYSERROR(\"Error opening %s\", newfull);\n\t\tfree(newfull);\n\t\treturn -1;\n\t}\n\n\tmemset(&args, 0, sizeof(args));\n\tstrncpy(args.name, p+1, BTRFS_SUBVOL_NAME_MAX);\n\targs.name[BTRFS_SUBVOL_NAME_MAX-1] = 0;\n\tret = ioctl(fd, BTRFS_IOC_SNAP_DESTROY, &args);\n\tINFO(\"btrfs: snapshot destroy ioctl returned %d for %s\", ret, path);\n\tif (ret < 0 && errno == EPERM)\n\t\tERROR(\"Is the rootfs mounted with -o user_subvol_rm_allowed?\");\n\n\tfree(newfull);\n\tclose(fd);\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "newfull"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "free_btrfs_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "536-547",
          "snippet": "static void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Is the rootfs mounted with -o user_subvol_rm_allowed?\""
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"btrfs: snapshot destroy ioctl returned %d for %s\"",
            "ret",
            "path"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "BTRFS_IOC_SNAP_DESTROY",
            "&args"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "args.name",
            "p+1",
            "BTRFS_SUBVOL_NAME_MAX"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&args",
            "0",
            "sizeof(args)"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error opening %s\"",
            "newfull"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "newfull",
            "O_RDONLY"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "genetlink_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/genl.c",
          "lines": "106-116",
          "snippet": "extern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"genl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/genetlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"genl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"bad path: %s\"",
            "path"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "newfull",
            "'/'"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error: out of memory\""
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "path"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic int btrfs_do_destroy_subvol(const char *path)\n{\n\tint ret, fd = -1;\n\tstruct btrfs_ioctl_vol_args  args;\n\tchar *p, *newfull = strdup(path);\n\n\tif (!newfull) {\n\t\tERROR(\"Error: out of memory\");\n\t\treturn -1;\n\t}\n\n\tp = strrchr(newfull, '/');\n\tif (!p) {\n\t\tERROR(\"bad path: %s\", path);\n\t\tfree(newfull);\n\t\treturn -1;\n\t}\n\t*p = '\\0';\n\n\tfd = open(newfull, O_RDONLY);\n\tif (fd < 0) {\n\t\tSYSERROR(\"Error opening %s\", newfull);\n\t\tfree(newfull);\n\t\treturn -1;\n\t}\n\n\tmemset(&args, 0, sizeof(args));\n\tstrncpy(args.name, p+1, BTRFS_SUBVOL_NAME_MAX);\n\targs.name[BTRFS_SUBVOL_NAME_MAX-1] = 0;\n\tret = ioctl(fd, BTRFS_IOC_SNAP_DESTROY, &args);\n\tINFO(\"btrfs: snapshot destroy ioctl returned %d for %s\", ret, path);\n\tif (ret < 0 && errno == EPERM)\n\t\tERROR(\"Is the rootfs mounted with -o user_subvol_rm_allowed?\");\n\n\tfree(newfull);\n\tclose(fd);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_clonepaths",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
    "lines": "360-410",
    "snippet": "int btrfs_clonepaths(struct bdev *orig, struct bdev *new, const char *oldname,\n\t\t     const char *cname, const char *oldpath,\n\t\t     const char *lxcpath, int snap, uint64_t newsize,\n\t\t     struct lxc_conf *conf)\n{\n\tif (!orig->dest || !orig->src)\n\t\treturn -1;\n\n\tif (strcmp(orig->type, \"btrfs\")) {\n\t\tint len, ret;\n\t\tif (snap) {\n\t\t\tERROR(\"btrfs snapshot from %s backing store is not supported\",\n\t\t\t\torig->type);\n\t\t\treturn -1;\n\t\t}\n\t\tlen = strlen(lxcpath) + strlen(cname) + strlen(\"rootfs\") + 3;\n\t\tnew->src = malloc(len);\n\t\tif (!new->src)\n\t\t\treturn -1;\n\t\tret = snprintf(new->src, len, \"%s/%s/rootfs\", lxcpath, cname);\n\t\tif (ret < 0 || ret >= len)\n\t\t\treturn -1;\n\t} else {\n\t\t// in case rootfs is in custom path, reuse it\n\t\tif ((new->src = dir_new_path(orig->src, oldname, cname, oldpath, lxcpath)) == NULL)\n\t\t\treturn -1;\n\n\t}\n\n\tif ((new->dest = strdup(new->src)) == NULL)\n\t\treturn -1;\n\n\tif (orig->mntopts && (new->mntopts = strdup(orig->mntopts)) == NULL)\n\t\treturn -1;\n\n\tif (snap) {\n\t\tstruct rsync_data_char sdata;\n\t\tif (!am_unpriv())\n\t\t\treturn btrfs_snapshot(orig->dest, new->dest);\n\t\tsdata.dest = new->dest;\n\t\tsdata.src = orig->dest;\n\t\treturn userns_exec_1(conf, btrfs_snapshot_wrapper, &sdata);\n\t}\n\n\tif (rmdir(new->dest) < 0 && errno != ENOENT) {\n\t\tSYSERROR(\"removing %s\", new->dest);\n\t\treturn -1;\n\t}\n\n\treturn btrfs_subvolume_create(new->dest);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern char *dir_new_path(char *src, const char *oldname, const char *name,\n\t\t\t  const char *oldpath, const char *lxcpath);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_subvolume_create",
          "args": [
            "new->dest"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_subvolume_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "221-256",
          "snippet": "static int btrfs_subvolume_create(const char *path)\n{\n\tint ret, fd = -1;\n\tstruct btrfs_ioctl_vol_args  args;\n\tchar *p, *newfull = strdup(path);\n\n\tif (!newfull) {\n\t\tERROR(\"Error: out of memory\");\n\t\treturn -1;\n\t}\n\n\tp = strrchr(newfull, '/');\n\tif (!p) {\n\t\tERROR(\"bad path: %s\", path);\n\t\tfree(newfull);\n\t\treturn -1;\n\t}\n\t*p = '\\0';\n\n\tfd = open(newfull, O_RDONLY);\n\tif (fd < 0) {\n\t\tERROR(\"Error opening %s\", newfull);\n\t\tfree(newfull);\n\t\treturn -1;\n\t}\n\n\tmemset(&args, 0, sizeof(args));\n\tstrncpy(args.name, p+1, BTRFS_SUBVOL_NAME_MAX);\n\targs.name[BTRFS_SUBVOL_NAME_MAX-1] = 0;\n\tret = ioctl(fd, BTRFS_IOC_SUBVOL_CREATE, &args);\n\tINFO(\"btrfs: snapshot create ioctl returned %d\", ret);\n\n\tfree(newfull);\n\tclose(fd);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic int btrfs_subvolume_create(const char *path)\n{\n\tint ret, fd = -1;\n\tstruct btrfs_ioctl_vol_args  args;\n\tchar *p, *newfull = strdup(path);\n\n\tif (!newfull) {\n\t\tERROR(\"Error: out of memory\");\n\t\treturn -1;\n\t}\n\n\tp = strrchr(newfull, '/');\n\tif (!p) {\n\t\tERROR(\"bad path: %s\", path);\n\t\tfree(newfull);\n\t\treturn -1;\n\t}\n\t*p = '\\0';\n\n\tfd = open(newfull, O_RDONLY);\n\tif (fd < 0) {\n\t\tERROR(\"Error opening %s\", newfull);\n\t\tfree(newfull);\n\t\treturn -1;\n\t}\n\n\tmemset(&args, 0, sizeof(args));\n\tstrncpy(args.name, p+1, BTRFS_SUBVOL_NAME_MAX);\n\targs.name[BTRFS_SUBVOL_NAME_MAX-1] = 0;\n\tret = ioctl(fd, BTRFS_IOC_SUBVOL_CREATE, &args);\n\tINFO(\"btrfs: snapshot create ioctl returned %d\", ret);\n\n\tfree(newfull);\n\tclose(fd);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"removing %s\"",
            "new->dest"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmdir",
          "args": [
            "new->dest"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_rmdir_onedev_wrapper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2332-2336",
          "snippet": "static int lxc_rmdir_onedev_wrapper(void *data)\n{\n\tchar *arg = (char *) data;\n\treturn lxc_rmdir_onedev(arg, \"snaps\");\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic int lxc_rmdir_onedev_wrapper(void *data)\n{\n\tchar *arg = (char *) data;\n\treturn lxc_rmdir_onedev(arg, \"snaps\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "userns_exec_1",
          "args": [
            "conf",
            "btrfs_snapshot_wrapper",
            "&sdata"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "userns_exec_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4435-4487",
          "snippet": "int userns_exec_1(struct lxc_conf *conf, int (*fn)(void *), void *data)\n{\n\tint ret, pid;\n\tstruct userns_fn_data d;\n\tchar c = '1';\n\tint p[2];\n\tstruct lxc_list *idmap;\n\n\tret = pipe(p);\n\tif (ret < 0) {\n\t\tSYSERROR(\"opening pipe\");\n\t\treturn -1;\n\t}\n\td.fn = fn;\n\td.arg = data;\n\td.p[0] = p[0];\n\td.p[1] = p[1];\n\tpid = lxc_clone(run_userns_fn, &d, CLONE_NEWUSER);\n\tif (pid < 0)\n\t\tgoto err;\n\tclose(p[0]);\n\tp[0] = -1;\n\n\tif ((idmap = idmap_add_id(conf, geteuid(), getegid())) == NULL) {\n\t\tERROR(\"Error adding self to container uid/gid map\");\n\t\tgoto err;\n\t}\n\n\tret = lxc_map_ids(idmap, pid);\n\tlxc_free_idmap(idmap);\n\tfree(idmap);\n\tif (ret) {\n\t\tERROR(\"Error setting up child mappings\");\n\t\tgoto err;\n\t}\n\n\t// kick the child\n\tif (write(p[1], &c, 1) != 1) {\n\t\tSYSERROR(\"writing to pipe to child\");\n\t\tgoto err;\n\t}\n\n\tret = wait_for_pid(pid);\n\n\tclose(p[1]);\n\treturn ret;\n\nerr:\n\tif (p[0] != -1)\n\t\tclose(p[0]);\n\tclose(p[1]);\n\treturn -1;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint userns_exec_1(struct lxc_conf *conf, int (*fn)(void *), void *data)\n{\n\tint ret, pid;\n\tstruct userns_fn_data d;\n\tchar c = '1';\n\tint p[2];\n\tstruct lxc_list *idmap;\n\n\tret = pipe(p);\n\tif (ret < 0) {\n\t\tSYSERROR(\"opening pipe\");\n\t\treturn -1;\n\t}\n\td.fn = fn;\n\td.arg = data;\n\td.p[0] = p[0];\n\td.p[1] = p[1];\n\tpid = lxc_clone(run_userns_fn, &d, CLONE_NEWUSER);\n\tif (pid < 0)\n\t\tgoto err;\n\tclose(p[0]);\n\tp[0] = -1;\n\n\tif ((idmap = idmap_add_id(conf, geteuid(), getegid())) == NULL) {\n\t\tERROR(\"Error adding self to container uid/gid map\");\n\t\tgoto err;\n\t}\n\n\tret = lxc_map_ids(idmap, pid);\n\tlxc_free_idmap(idmap);\n\tfree(idmap);\n\tif (ret) {\n\t\tERROR(\"Error setting up child mappings\");\n\t\tgoto err;\n\t}\n\n\t// kick the child\n\tif (write(p[1], &c, 1) != 1) {\n\t\tSYSERROR(\"writing to pipe to child\");\n\t\tgoto err;\n\t}\n\n\tret = wait_for_pid(pid);\n\n\tclose(p[1]);\n\treturn ret;\n\nerr:\n\tif (p[0] != -1)\n\t\tclose(p[0]);\n\tclose(p[1]);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_snapshot",
          "args": [
            "orig->dest",
            "new->dest"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_snapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "299-342",
          "snippet": "int btrfs_snapshot(const char *orig, const char *new)\n{\n\tint fd = -1, fddst = -1, ret = -1;\n\tstruct btrfs_ioctl_vol_args_v2  args;\n\tchar *newdir, *newname, *newfull = NULL;\n\n\tnewfull = strdup(new);\n\tif (!newfull) {\n\t\tERROR(\"Error: out of memory\");\n\t\tgoto out;\n\t}\n\t// make sure the directory doesn't already exist\n\tif (rmdir(newfull) < 0 && errno != ENOENT) {\n\t\tSYSERROR(\"Error removing empty new rootfs\");\n\t\tgoto out;\n\t}\n\tnewname = basename(newfull);\n\tnewdir = dirname(newfull);\n\tfd = open(orig, O_RDONLY);\n\tif (fd < 0) {\n\t\tSYSERROR(\"Error opening original rootfs %s\", orig);\n\t\tgoto out;\n\t}\n\tfddst = open(newdir, O_RDONLY);\n\tif (fddst < 0) {\n\t\tSYSERROR(\"Error opening new container dir %s\", newdir);\n\t\tgoto out;\n\t}\n\n\tmemset(&args, 0, sizeof(args));\n\targs.fd = fd;\n\tstrncpy(args.name, newname, BTRFS_SUBVOL_NAME_MAX);\n\targs.name[BTRFS_SUBVOL_NAME_MAX-1] = 0;\n\tret = ioctl(fddst, BTRFS_IOC_SNAP_CREATE_V2, &args);\n\tINFO(\"btrfs: snapshot create ioctl returned %d\", ret);\n\nout:\n\tif (fddst != -1)\n\t\tclose(fddst);\n\tif (fd != -1)\n\t\tclose(fd);\n\tfree(newfull);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint btrfs_snapshot(const char *orig, const char *new)\n{\n\tint fd = -1, fddst = -1, ret = -1;\n\tstruct btrfs_ioctl_vol_args_v2  args;\n\tchar *newdir, *newname, *newfull = NULL;\n\n\tnewfull = strdup(new);\n\tif (!newfull) {\n\t\tERROR(\"Error: out of memory\");\n\t\tgoto out;\n\t}\n\t// make sure the directory doesn't already exist\n\tif (rmdir(newfull) < 0 && errno != ENOENT) {\n\t\tSYSERROR(\"Error removing empty new rootfs\");\n\t\tgoto out;\n\t}\n\tnewname = basename(newfull);\n\tnewdir = dirname(newfull);\n\tfd = open(orig, O_RDONLY);\n\tif (fd < 0) {\n\t\tSYSERROR(\"Error opening original rootfs %s\", orig);\n\t\tgoto out;\n\t}\n\tfddst = open(newdir, O_RDONLY);\n\tif (fddst < 0) {\n\t\tSYSERROR(\"Error opening new container dir %s\", newdir);\n\t\tgoto out;\n\t}\n\n\tmemset(&args, 0, sizeof(args));\n\targs.fd = fd;\n\tstrncpy(args.name, newname, BTRFS_SUBVOL_NAME_MAX);\n\targs.name[BTRFS_SUBVOL_NAME_MAX-1] = 0;\n\tret = ioctl(fddst, BTRFS_IOC_SNAP_CREATE_V2, &args);\n\tINFO(\"btrfs: snapshot create ioctl returned %d\", ret);\n\nout:\n\tif (fddst != -1)\n\t\tclose(fddst);\n\tif (fd != -1)\n\t\tclose(fd);\n\tfree(newfull);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "am_unpriv",
          "args": [],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "am_unpriv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.h",
          "lines": "288-290",
          "snippet": "inline static bool am_unpriv(void) {\n\treturn geteuid() != 0;\n}",
          "includes": [
            "#include <stdint.h>",
            "#  include <sys/signalfd.h>",
            "#include <../include/getline.h>",
            "#include \"initutils.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#  include <sys/signalfd.h>\n#include <../include/getline.h>\n#include \"initutils.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"config.h\"\n\ninline static bool am_unpriv(void) {\n\treturn geteuid() != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "orig->mntopts"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "new->src"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_new_path",
          "args": [
            "orig->src",
            "oldname",
            "cname",
            "oldpath",
            "lxcpath"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "dir_new_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "214-253",
          "snippet": "char *dir_new_path(char *src, const char *oldname, const char *name,\n\t\tconst char *oldpath, const char *lxcpath)\n{\n\tchar *ret, *p, *p2;\n\tint l1, l2, nlen;\n\n\tnlen = strlen(src) + 1;\n\tl1 = strlen(oldpath);\n\tp = src;\n\t/* if src starts with oldpath, look for oldname only after\n\t * that path */\n\tif (strncmp(src, oldpath, l1) == 0) {\n\t\tp += l1;\n\t\tnlen += (strlen(lxcpath) - l1);\n\t}\n\tl2 = strlen(oldname);\n\twhile ((p = strstr(p, oldname)) != NULL) {\n\t\tp += l2;\n\t\tnlen += strlen(name) - l2;\n\t}\n\n\tret = malloc(nlen);\n\tif (!ret)\n\t\treturn NULL;\n\n\tp = ret;\n\tif (strncmp(src, oldpath, l1) == 0) {\n\t\tp += sprintf(p, \"%s\", lxcpath);\n\t\tsrc += l1;\n\t}\n\n\twhile ((p2 = strstr(src, oldname)) != NULL) {\n\t\tstrncpy(p, src, p2 - src); // copy text up to oldname\n\t\tp += p2 - src; // move target pointer (p)\n\t\tp += sprintf(p, \"%s\", name); // print new name in place of oldname\n\t\tsrc = p2 + l2;  // move src to end of oldname\n\t}\n\tsprintf(p, \"%s\", src);  // copy the rest of src\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);\n\nchar *dir_new_path(char *src, const char *oldname, const char *name,\n\t\tconst char *oldpath, const char *lxcpath)\n{\n\tchar *ret, *p, *p2;\n\tint l1, l2, nlen;\n\n\tnlen = strlen(src) + 1;\n\tl1 = strlen(oldpath);\n\tp = src;\n\t/* if src starts with oldpath, look for oldname only after\n\t * that path */\n\tif (strncmp(src, oldpath, l1) == 0) {\n\t\tp += l1;\n\t\tnlen += (strlen(lxcpath) - l1);\n\t}\n\tl2 = strlen(oldname);\n\twhile ((p = strstr(p, oldname)) != NULL) {\n\t\tp += l2;\n\t\tnlen += strlen(name) - l2;\n\t}\n\n\tret = malloc(nlen);\n\tif (!ret)\n\t\treturn NULL;\n\n\tp = ret;\n\tif (strncmp(src, oldpath, l1) == 0) {\n\t\tp += sprintf(p, \"%s\", lxcpath);\n\t\tsrc += l1;\n\t}\n\n\twhile ((p2 = strstr(src, oldname)) != NULL) {\n\t\tstrncpy(p, src, p2 - src); // copy text up to oldname\n\t\tp += p2 - src; // move target pointer (p)\n\t\tp += sprintf(p, \"%s\", name); // print new name in place of oldname\n\t\tsrc = p2 + l2;  // move src to end of oldname\n\t}\n\tsprintf(p, \"%s\", src);  // copy the rest of src\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "new->src",
            "len",
            "\"%s/%s/rootfs\"",
            "lxcpath",
            "cname"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"rootfs\""
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cname"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "lxcpath"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"btrfs snapshot from %s backing store is not supported\"",
            "orig->type"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "orig->type",
            "\"btrfs\""
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nextern char *dir_new_path(char *src, const char *oldname, const char *name,\n\t\t\t  const char *oldpath, const char *lxcpath);\n\nint btrfs_clonepaths(struct bdev *orig, struct bdev *new, const char *oldname,\n\t\t     const char *cname, const char *oldpath,\n\t\t     const char *lxcpath, int snap, uint64_t newsize,\n\t\t     struct lxc_conf *conf)\n{\n\tif (!orig->dest || !orig->src)\n\t\treturn -1;\n\n\tif (strcmp(orig->type, \"btrfs\")) {\n\t\tint len, ret;\n\t\tif (snap) {\n\t\t\tERROR(\"btrfs snapshot from %s backing store is not supported\",\n\t\t\t\torig->type);\n\t\t\treturn -1;\n\t\t}\n\t\tlen = strlen(lxcpath) + strlen(cname) + strlen(\"rootfs\") + 3;\n\t\tnew->src = malloc(len);\n\t\tif (!new->src)\n\t\t\treturn -1;\n\t\tret = snprintf(new->src, len, \"%s/%s/rootfs\", lxcpath, cname);\n\t\tif (ret < 0 || ret >= len)\n\t\t\treturn -1;\n\t} else {\n\t\t// in case rootfs is in custom path, reuse it\n\t\tif ((new->src = dir_new_path(orig->src, oldname, cname, oldpath, lxcpath)) == NULL)\n\t\t\treturn -1;\n\n\t}\n\n\tif ((new->dest = strdup(new->src)) == NULL)\n\t\treturn -1;\n\n\tif (orig->mntopts && (new->mntopts = strdup(orig->mntopts)) == NULL)\n\t\treturn -1;\n\n\tif (snap) {\n\t\tstruct rsync_data_char sdata;\n\t\tif (!am_unpriv())\n\t\t\treturn btrfs_snapshot(orig->dest, new->dest);\n\t\tsdata.dest = new->dest;\n\t\tsdata.src = orig->dest;\n\t\treturn userns_exec_1(conf, btrfs_snapshot_wrapper, &sdata);\n\t}\n\n\tif (rmdir(new->dest) < 0 && errno != ENOENT) {\n\t\tSYSERROR(\"removing %s\", new->dest);\n\t\treturn -1;\n\t}\n\n\treturn btrfs_subvolume_create(new->dest);\n}"
  },
  {
    "function_name": "btrfs_snapshot_wrapper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
    "lines": "344-358",
    "snippet": "static int btrfs_snapshot_wrapper(void *data)\n{\n\tstruct rsync_data_char *arg = data;\n\tif (setgid(0) < 0) {\n\t\tERROR(\"Failed to setgid to 0\");\n\t\treturn -1;\n\t}\n\tif (setgroups(0, NULL) < 0)\n\t\tWARN(\"Failed to clear groups\");\n\tif (setuid(0) < 0) {\n\t\tERROR(\"Failed to setuid to 0\");\n\t\treturn -1;\n\t}\n\treturn btrfs_snapshot(arg->src, arg->dest);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_snapshot",
          "args": [
            "arg->src",
            "arg->dest"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_snapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "299-342",
          "snippet": "int btrfs_snapshot(const char *orig, const char *new)\n{\n\tint fd = -1, fddst = -1, ret = -1;\n\tstruct btrfs_ioctl_vol_args_v2  args;\n\tchar *newdir, *newname, *newfull = NULL;\n\n\tnewfull = strdup(new);\n\tif (!newfull) {\n\t\tERROR(\"Error: out of memory\");\n\t\tgoto out;\n\t}\n\t// make sure the directory doesn't already exist\n\tif (rmdir(newfull) < 0 && errno != ENOENT) {\n\t\tSYSERROR(\"Error removing empty new rootfs\");\n\t\tgoto out;\n\t}\n\tnewname = basename(newfull);\n\tnewdir = dirname(newfull);\n\tfd = open(orig, O_RDONLY);\n\tif (fd < 0) {\n\t\tSYSERROR(\"Error opening original rootfs %s\", orig);\n\t\tgoto out;\n\t}\n\tfddst = open(newdir, O_RDONLY);\n\tif (fddst < 0) {\n\t\tSYSERROR(\"Error opening new container dir %s\", newdir);\n\t\tgoto out;\n\t}\n\n\tmemset(&args, 0, sizeof(args));\n\targs.fd = fd;\n\tstrncpy(args.name, newname, BTRFS_SUBVOL_NAME_MAX);\n\targs.name[BTRFS_SUBVOL_NAME_MAX-1] = 0;\n\tret = ioctl(fddst, BTRFS_IOC_SNAP_CREATE_V2, &args);\n\tINFO(\"btrfs: snapshot create ioctl returned %d\", ret);\n\nout:\n\tif (fddst != -1)\n\t\tclose(fddst);\n\tif (fd != -1)\n\t\tclose(fd);\n\tfree(newfull);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint btrfs_snapshot(const char *orig, const char *new)\n{\n\tint fd = -1, fddst = -1, ret = -1;\n\tstruct btrfs_ioctl_vol_args_v2  args;\n\tchar *newdir, *newname, *newfull = NULL;\n\n\tnewfull = strdup(new);\n\tif (!newfull) {\n\t\tERROR(\"Error: out of memory\");\n\t\tgoto out;\n\t}\n\t// make sure the directory doesn't already exist\n\tif (rmdir(newfull) < 0 && errno != ENOENT) {\n\t\tSYSERROR(\"Error removing empty new rootfs\");\n\t\tgoto out;\n\t}\n\tnewname = basename(newfull);\n\tnewdir = dirname(newfull);\n\tfd = open(orig, O_RDONLY);\n\tif (fd < 0) {\n\t\tSYSERROR(\"Error opening original rootfs %s\", orig);\n\t\tgoto out;\n\t}\n\tfddst = open(newdir, O_RDONLY);\n\tif (fddst < 0) {\n\t\tSYSERROR(\"Error opening new container dir %s\", newdir);\n\t\tgoto out;\n\t}\n\n\tmemset(&args, 0, sizeof(args));\n\targs.fd = fd;\n\tstrncpy(args.name, newname, BTRFS_SUBVOL_NAME_MAX);\n\targs.name[BTRFS_SUBVOL_NAME_MAX-1] = 0;\n\tret = ioctl(fddst, BTRFS_IOC_SNAP_CREATE_V2, &args);\n\tINFO(\"btrfs: snapshot create ioctl returned %d\", ret);\n\nout:\n\tif (fddst != -1)\n\t\tclose(fddst);\n\tif (fd != -1)\n\t\tclose(fd);\n\tfree(newfull);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to setuid to 0\""
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setuid",
          "args": [
            "0"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to clear groups\""
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setgroups",
          "args": [
            "0",
            "NULL"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_setgroups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "2063-2072",
          "snippet": "int lxc_setgroups(int size, gid_t list[])\n{\n\tif (setgroups(size, list) < 0) {\n\t\tSYSERROR(\"Failed to setgroups().\");\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Dropped additional groups.\");\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_setgroups(int size, gid_t list[])\n{\n\tif (setgroups(size, list) < 0) {\n\t\tSYSERROR(\"Failed to setgroups().\");\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Dropped additional groups.\");\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to setgid to 0\""
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setgid",
          "args": [
            "0"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic int btrfs_snapshot_wrapper(void *data)\n{\n\tstruct rsync_data_char *arg = data;\n\tif (setgid(0) < 0) {\n\t\tERROR(\"Failed to setgid to 0\");\n\t\treturn -1;\n\t}\n\tif (setgroups(0, NULL) < 0)\n\t\tWARN(\"Failed to clear groups\");\n\tif (setuid(0) < 0) {\n\t\tERROR(\"Failed to setuid to 0\");\n\t\treturn -1;\n\t}\n\treturn btrfs_snapshot(arg->src, arg->dest);\n}"
  },
  {
    "function_name": "btrfs_snapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
    "lines": "299-342",
    "snippet": "int btrfs_snapshot(const char *orig, const char *new)\n{\n\tint fd = -1, fddst = -1, ret = -1;\n\tstruct btrfs_ioctl_vol_args_v2  args;\n\tchar *newdir, *newname, *newfull = NULL;\n\n\tnewfull = strdup(new);\n\tif (!newfull) {\n\t\tERROR(\"Error: out of memory\");\n\t\tgoto out;\n\t}\n\t// make sure the directory doesn't already exist\n\tif (rmdir(newfull) < 0 && errno != ENOENT) {\n\t\tSYSERROR(\"Error removing empty new rootfs\");\n\t\tgoto out;\n\t}\n\tnewname = basename(newfull);\n\tnewdir = dirname(newfull);\n\tfd = open(orig, O_RDONLY);\n\tif (fd < 0) {\n\t\tSYSERROR(\"Error opening original rootfs %s\", orig);\n\t\tgoto out;\n\t}\n\tfddst = open(newdir, O_RDONLY);\n\tif (fddst < 0) {\n\t\tSYSERROR(\"Error opening new container dir %s\", newdir);\n\t\tgoto out;\n\t}\n\n\tmemset(&args, 0, sizeof(args));\n\targs.fd = fd;\n\tstrncpy(args.name, newname, BTRFS_SUBVOL_NAME_MAX);\n\targs.name[BTRFS_SUBVOL_NAME_MAX-1] = 0;\n\tret = ioctl(fddst, BTRFS_IOC_SNAP_CREATE_V2, &args);\n\tINFO(\"btrfs: snapshot create ioctl returned %d\", ret);\n\nout:\n\tif (fddst != -1)\n\t\tclose(fddst);\n\tif (fd != -1)\n\t\tclose(fd);\n\tfree(newfull);\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "newfull"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "free_btrfs_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "536-547",
          "snippet": "static void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"btrfs: snapshot create ioctl returned %d\"",
            "ret"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fddst",
            "BTRFS_IOC_SNAP_CREATE_V2",
            "&args"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "args.name",
            "newname",
            "BTRFS_SUBVOL_NAME_MAX"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&args",
            "0",
            "sizeof(args)"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error opening new container dir %s\"",
            "newdir"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "newdir",
            "O_RDONLY"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "genetlink_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/genl.c",
          "lines": "106-116",
          "snippet": "extern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"genl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/genetlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"genl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error opening original rootfs %s\"",
            "orig"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dirname",
          "args": [
            "newfull"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_util_dirname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lua-lxc/core.c",
          "lines": "569-573",
          "snippet": "static int lxc_util_dirname(lua_State *L) {\n    char *path = strdupa(luaL_checkstring(L, 1));\n    lua_pushstring(L, dirname(path));\n    return 1;\n}",
          "includes": [
            "#include \"lxc/commands.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <libgen.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <assert.h>",
            "#include <lauxlib.h>",
            "#include <lua.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxc/commands.h\"\n#include <lxc/lxccontainer.h>\n#include <libgen.h>\n#include <unistd.h>\n#include <string.h>\n#include <assert.h>\n#include <lauxlib.h>\n#include <lua.h>\n\nstatic int lxc_util_dirname(lua_State *L) {\n    char *path = strdupa(luaL_checkstring(L, 1));\n    lua_pushstring(L, dirname(path));\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "basename",
          "args": [
            "newfull"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "lxcbasename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "1064-1070",
          "snippet": "static char *lxcbasename(char *path)\n{\n\tchar *p = path + strlen(path) - 1;\n\twhile (*p != '/' && p > path)\n\t\tp--;\n\treturn p;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic char *lxcbasename(char *path)\n{\n\tchar *p = path + strlen(path) - 1;\n\twhile (*p != '/' && p > path)\n\t\tp--;\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error removing empty new rootfs\""
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmdir",
          "args": [
            "newfull"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_rmdir_onedev_wrapper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2332-2336",
          "snippet": "static int lxc_rmdir_onedev_wrapper(void *data)\n{\n\tchar *arg = (char *) data;\n\treturn lxc_rmdir_onedev(arg, \"snaps\");\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic int lxc_rmdir_onedev_wrapper(void *data)\n{\n\tchar *arg = (char *) data;\n\treturn lxc_rmdir_onedev(arg, \"snaps\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error: out of memory\""
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "new"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint btrfs_snapshot(const char *orig, const char *new)\n{\n\tint fd = -1, fddst = -1, ret = -1;\n\tstruct btrfs_ioctl_vol_args_v2  args;\n\tchar *newdir, *newname, *newfull = NULL;\n\n\tnewfull = strdup(new);\n\tif (!newfull) {\n\t\tERROR(\"Error: out of memory\");\n\t\tgoto out;\n\t}\n\t// make sure the directory doesn't already exist\n\tif (rmdir(newfull) < 0 && errno != ENOENT) {\n\t\tSYSERROR(\"Error removing empty new rootfs\");\n\t\tgoto out;\n\t}\n\tnewname = basename(newfull);\n\tnewdir = dirname(newfull);\n\tfd = open(orig, O_RDONLY);\n\tif (fd < 0) {\n\t\tSYSERROR(\"Error opening original rootfs %s\", orig);\n\t\tgoto out;\n\t}\n\tfddst = open(newdir, O_RDONLY);\n\tif (fddst < 0) {\n\t\tSYSERROR(\"Error opening new container dir %s\", newdir);\n\t\tgoto out;\n\t}\n\n\tmemset(&args, 0, sizeof(args));\n\targs.fd = fd;\n\tstrncpy(args.name, newname, BTRFS_SUBVOL_NAME_MAX);\n\targs.name[BTRFS_SUBVOL_NAME_MAX-1] = 0;\n\tret = ioctl(fddst, BTRFS_IOC_SNAP_CREATE_V2, &args);\n\tINFO(\"btrfs: snapshot create ioctl returned %d\", ret);\n\nout:\n\tif (fddst != -1)\n\t\tclose(fddst);\n\tif (fd != -1)\n\t\tclose(fd);\n\tfree(newfull);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_same_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
    "lines": "258-297",
    "snippet": "int btrfs_same_fs(const char *orig, const char *new)\n{\n\tint fd_orig = -1, fd_new = -1, ret = -1;\n\tstruct btrfs_ioctl_fs_info_args orig_args, new_args;\n\n\tfd_orig = open(orig, O_RDONLY);\n\tif (fd_orig < 0) {\n\t\tSYSERROR(\"Error opening original rootfs %s\", orig);\n\t\tgoto out;\n\t}\n\tret = ioctl(fd_orig, BTRFS_IOC_FS_INFO, &orig_args);\n\tif (ret < 0) {\n\t\tSYSERROR(\"BTRFS_IOC_FS_INFO %s\", orig);\n\t\tgoto out;\n\t}\n\n\tfd_new = open(new, O_RDONLY);\n\tif (fd_new < 0) {\n\t\tSYSERROR(\"Error opening new container dir %s\", new);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\tret = ioctl(fd_new, BTRFS_IOC_FS_INFO, &new_args);\n\tif (ret < 0) {\n\t\tSYSERROR(\"BTRFS_IOC_FS_INFO %s\", new);\n\t\tgoto out;\n\t}\n\n\tif (strncmp(orig_args.fsid, new_args.fsid, BTRFS_FSID_SIZE) != 0) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tif (fd_new != -1)\n\t\tclose(fd_new);\n\tif (fd_orig != -1)\n\t\tclose(fd_orig);\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd_orig"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "orig_args.fsid",
            "new_args.fsid",
            "BTRFS_FSID_SIZE"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"BTRFS_IOC_FS_INFO %s\"",
            "new"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd_new",
            "BTRFS_IOC_FS_INFO",
            "&new_args"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error opening new container dir %s\"",
            "new"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "new",
            "O_RDONLY"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "genetlink_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/genl.c",
          "lines": "106-116",
          "snippet": "extern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"genl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/genetlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"genl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"BTRFS_IOC_FS_INFO %s\"",
            "orig"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd_orig",
            "BTRFS_IOC_FS_INFO",
            "&orig_args"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error opening original rootfs %s\"",
            "orig"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint btrfs_same_fs(const char *orig, const char *new)\n{\n\tint fd_orig = -1, fd_new = -1, ret = -1;\n\tstruct btrfs_ioctl_fs_info_args orig_args, new_args;\n\n\tfd_orig = open(orig, O_RDONLY);\n\tif (fd_orig < 0) {\n\t\tSYSERROR(\"Error opening original rootfs %s\", orig);\n\t\tgoto out;\n\t}\n\tret = ioctl(fd_orig, BTRFS_IOC_FS_INFO, &orig_args);\n\tif (ret < 0) {\n\t\tSYSERROR(\"BTRFS_IOC_FS_INFO %s\", orig);\n\t\tgoto out;\n\t}\n\n\tfd_new = open(new, O_RDONLY);\n\tif (fd_new < 0) {\n\t\tSYSERROR(\"Error opening new container dir %s\", new);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\tret = ioctl(fd_new, BTRFS_IOC_FS_INFO, &new_args);\n\tif (ret < 0) {\n\t\tSYSERROR(\"BTRFS_IOC_FS_INFO %s\", new);\n\t\tgoto out;\n\t}\n\n\tif (strncmp(orig_args.fsid, new_args.fsid, BTRFS_FSID_SIZE) != 0) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tif (fd_new != -1)\n\t\tclose(fd_new);\n\tif (fd_orig != -1)\n\t\tclose(fd_orig);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_subvolume_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
    "lines": "221-256",
    "snippet": "static int btrfs_subvolume_create(const char *path)\n{\n\tint ret, fd = -1;\n\tstruct btrfs_ioctl_vol_args  args;\n\tchar *p, *newfull = strdup(path);\n\n\tif (!newfull) {\n\t\tERROR(\"Error: out of memory\");\n\t\treturn -1;\n\t}\n\n\tp = strrchr(newfull, '/');\n\tif (!p) {\n\t\tERROR(\"bad path: %s\", path);\n\t\tfree(newfull);\n\t\treturn -1;\n\t}\n\t*p = '\\0';\n\n\tfd = open(newfull, O_RDONLY);\n\tif (fd < 0) {\n\t\tERROR(\"Error opening %s\", newfull);\n\t\tfree(newfull);\n\t\treturn -1;\n\t}\n\n\tmemset(&args, 0, sizeof(args));\n\tstrncpy(args.name, p+1, BTRFS_SUBVOL_NAME_MAX);\n\targs.name[BTRFS_SUBVOL_NAME_MAX-1] = 0;\n\tret = ioctl(fd, BTRFS_IOC_SUBVOL_CREATE, &args);\n\tINFO(\"btrfs: snapshot create ioctl returned %d\", ret);\n\n\tfree(newfull);\n\tclose(fd);\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "newfull"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "free_btrfs_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "536-547",
          "snippet": "static void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"btrfs: snapshot create ioctl returned %d\"",
            "ret"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "BTRFS_IOC_SUBVOL_CREATE",
            "&args"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "args.name",
            "p+1",
            "BTRFS_SUBVOL_NAME_MAX"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&args",
            "0",
            "sizeof(args)"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error opening %s\"",
            "newfull"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "newfull",
            "O_RDONLY"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "genetlink_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/genl.c",
          "lines": "106-116",
          "snippet": "extern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"genl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/genetlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"genl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"bad path: %s\"",
            "path"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "newfull",
            "'/'"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error: out of memory\""
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "path"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic int btrfs_subvolume_create(const char *path)\n{\n\tint ret, fd = -1;\n\tstruct btrfs_ioctl_vol_args  args;\n\tchar *p, *newfull = strdup(path);\n\n\tif (!newfull) {\n\t\tERROR(\"Error: out of memory\");\n\t\treturn -1;\n\t}\n\n\tp = strrchr(newfull, '/');\n\tif (!p) {\n\t\tERROR(\"bad path: %s\", path);\n\t\tfree(newfull);\n\t\treturn -1;\n\t}\n\t*p = '\\0';\n\n\tfd = open(newfull, O_RDONLY);\n\tif (fd < 0) {\n\t\tERROR(\"Error opening %s\", newfull);\n\t\tfree(newfull);\n\t\treturn -1;\n\t}\n\n\tmemset(&args, 0, sizeof(args));\n\tstrncpy(args.name, p+1, BTRFS_SUBVOL_NAME_MAX);\n\targs.name[BTRFS_SUBVOL_NAME_MAX-1] = 0;\n\tret = ioctl(fd, BTRFS_IOC_SUBVOL_CREATE, &args);\n\tINFO(\"btrfs: snapshot create ioctl returned %d\", ret);\n\n\tfree(newfull);\n\tclose(fd);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_umount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
    "lines": "212-219",
    "snippet": "int btrfs_umount(struct bdev *bdev)\n{\n\tif (strcmp(bdev->type, \"btrfs\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\treturn umount(bdev->dest);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "umount",
          "args": [
            "bdev->dest"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "212-219",
          "snippet": "int btrfs_umount(struct bdev *bdev)\n{\n\tif (strcmp(bdev->type, \"btrfs\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\treturn umount(bdev->dest);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "bdev->type",
            "\"btrfs\""
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint btrfs_umount(struct bdev *bdev)\n{\n\tif (strcmp(bdev->type, \"btrfs\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\treturn umount(bdev->dest);\n}"
  },
  {
    "function_name": "btrfs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
    "lines": "191-210",
    "snippet": "int btrfs_mount(struct bdev *bdev)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\n\tif (strcmp(bdev->type, \"btrfs\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\n\tif (parse_mntopts(bdev->mntopts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -22;\n\t}\n\n\tret = mount(bdev->src, bdev->dest, \"bind\", MS_BIND | MS_REC | mntflags, mntdata);\n\tfree(mntdata);\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "mntdata"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "free_btrfs_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "536-547",
          "snippet": "static void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "bdev->src",
            "bdev->dest",
            "\"bind\"",
            "MS_BIND | MS_REC | mntflags",
            "mntdata"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_remount_on_enodev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcoverlay.c",
          "lines": "664-676",
          "snippet": "static int ovl_remount_on_enodev(const char *lower, const char *target,\n\t\t\t\t const char *name, unsigned long mountflags,\n\t\t\t\t const void *options)\n{\n        int ret;\n        ret = mount(lower, target, ovl_name, MS_MGC_VAL | mountflags, options);\n        if (ret < 0 && errno == ENODEV) /* Try other module name. */\n\t\tret = mount(lower, target,\n\t\t\t    ovl_name == ovl_version[0] ? ovl_version[1]\n\t\t\t\t\t\t       : ovl_version[0],\n\t\t\t    MS_MGC_VAL | mountflags, options);\n        return ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *ovl_name;",
            "static char *ovl_version[] = {\"overlay\", \"overlayfs\"};",
            "static int ovl_remount_on_enodev(const char *lower, const char *target,\n\t\t\t\t const char *name, unsigned long mountflags,\n\t\t\t\t const void *options);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcoverlay.h\"\n#include \"lxccontainer.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nstatic char *ovl_name;\nstatic char *ovl_version[] = {\"overlay\", \"overlayfs\"};\nstatic int ovl_remount_on_enodev(const char *lower, const char *target,\n\t\t\t\t const char *name, unsigned long mountflags,\n\t\t\t\t const void *options);\n\nstatic int ovl_remount_on_enodev(const char *lower, const char *target,\n\t\t\t\t const char *name, unsigned long mountflags,\n\t\t\t\t const void *options)\n{\n        int ret;\n        ret = mount(lower, target, ovl_name, MS_MGC_VAL | mountflags, options);\n        if (ret < 0 && errno == ENODEV) /* Try other module name. */\n\t\tret = mount(lower, target,\n\t\t\t    ovl_name == ovl_version[0] ? ovl_version[1]\n\t\t\t\t\t\t       : ovl_version[0],\n\t\t\t    MS_MGC_VAL | mountflags, options);\n        return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_mntopts",
          "args": [
            "bdev->mntopts",
            "&mntflags",
            "&mntdata"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "parse_mntopts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1629-1666",
          "snippet": "int parse_mntopts(const char *mntopts, unsigned long *mntflags,\n\t\t\t char **mntdata)\n{\n\tchar *s, *data;\n\tchar *p, *saveptr = NULL;\n\n\t*mntdata = NULL;\n\t*mntflags = 0L;\n\n\tif (!mntopts)\n\t\treturn 0;\n\n\ts = strdup(mntopts);\n\tif (!s) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\treturn -1;\n\t}\n\n\tdata = malloc(strlen(s) + 1);\n\tif (!data) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\tfree(s);\n\t\treturn -1;\n\t}\n\t*data = 0;\n\n\tfor (p = strtok_r(s, \",\", &saveptr); p != NULL;\n\t     p = strtok_r(NULL, \",\", &saveptr))\n\t\tparse_mntopt(p, mntflags, &data);\n\n\tif (*data)\n\t\t*mntdata = data;\n\telse\n\t\tfree(data);\n\tfree(s);\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint parse_mntopts(const char *mntopts, unsigned long *mntflags,\n\t\t\t char **mntdata)\n{\n\tchar *s, *data;\n\tchar *p, *saveptr = NULL;\n\n\t*mntdata = NULL;\n\t*mntflags = 0L;\n\n\tif (!mntopts)\n\t\treturn 0;\n\n\ts = strdup(mntopts);\n\tif (!s) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\treturn -1;\n\t}\n\n\tdata = malloc(strlen(s) + 1);\n\tif (!data) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\tfree(s);\n\t\treturn -1;\n\t}\n\t*data = 0;\n\n\tfor (p = strtok_r(s, \",\", &saveptr); p != NULL;\n\t     p = strtok_r(NULL, \",\", &saveptr))\n\t\tparse_mntopt(p, mntflags, &data);\n\n\tif (*data)\n\t\t*mntdata = data;\n\telse\n\t\tfree(data);\n\tfree(s);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "bdev->type",
            "\"btrfs\""
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint btrfs_mount(struct bdev *bdev)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\n\tif (strcmp(bdev->type, \"btrfs\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\n\tif (parse_mntopts(bdev->mntopts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -22;\n\t}\n\n\tret = mount(bdev->src, bdev->dest, \"bind\", MS_BIND | MS_REC | mntflags, mntdata);\n\tfree(mntdata);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_detect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
    "lines": "172-189",
    "snippet": "int btrfs_detect(const char *path)\n{\n\tstruct stat st;\n\tint ret;\n\n\tif (!is_btrfs_fs(path))\n\t\treturn 0;\n\n\t// and make sure it's a subvolume.\n\tret = stat(path, &st);\n\tif (ret < 0)\n\t\treturn 0;\n\n\tif (st.st_ino == 256 && S_ISDIR(st.st_mode))\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "st.st_mode"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "path",
            "&st"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "Container_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "599-603",
          "snippet": "static PyObject *\nContainer_state(Container *self, void *closure)\n{\n    return PyUnicode_FromString(self->container->state(self->container));\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_state(Container *self, void *closure)\n{\n    return PyUnicode_FromString(self->container->state(self->container));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_btrfs_fs",
          "args": [
            "path"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "is_btrfs_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "127-144",
          "snippet": "bool is_btrfs_fs(const char *path)\n{\n\tint fd, ret;\n\tstruct btrfs_ioctl_space_args sargs;\n\n\t// make sure this is a btrfs filesystem\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn false;\n\tsargs.space_slots = 0;\n\tsargs.total_spaces = 0;\n\tret = ioctl(fd, BTRFS_IOC_SPACE_INFO, &sargs);\n\tclose(fd);\n\tif (ret < 0)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nbool is_btrfs_fs(const char *path)\n{\n\tint fd, ret;\n\tstruct btrfs_ioctl_space_args sargs;\n\n\t// make sure this is a btrfs filesystem\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn false;\n\tsargs.space_slots = 0;\n\tsargs.total_spaces = 0;\n\tret = ioctl(fd, BTRFS_IOC_SPACE_INFO, &sargs);\n\tclose(fd);\n\tif (ret < 0)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint btrfs_detect(const char *path)\n{\n\tstruct stat st;\n\tint ret;\n\n\tif (!is_btrfs_fs(path))\n\t\treturn 0;\n\n\t// and make sure it's a subvolume.\n\tret = stat(path, &st);\n\tif (ret < 0)\n\t\treturn 0;\n\n\tif (st.st_ino == 256 && S_ISDIR(st.st_mode))\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "is_btrfs_subvol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
    "lines": "152-170",
    "snippet": "int is_btrfs_subvol(const char *path)\n{\n\tstruct stat st;\n\tstruct statfs stfs;\n\tint ret;\n\n\tret = stat(path, &st);\n\tif (ret < 0)\n\t\treturn -errno;\n\n\tif (st.st_ino != BTRFS_FIRST_FREE_OBJECTID || !S_ISDIR(st.st_mode))\n\t\treturn 0;\n\n\tret = statfs(path, &stfs);\n\tif (ret < 0)\n\t\treturn -errno;\n\n\treturn stfs.f_type == BTRFS_SUPER_MAGIC;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "statfs",
          "args": [
            "path",
            "&stfs"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "st.st_mode"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "path",
            "&st"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "Container_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "599-603",
          "snippet": "static PyObject *\nContainer_state(Container *self, void *closure)\n{\n    return PyUnicode_FromString(self->container->state(self->container));\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_state(Container *self, void *closure)\n{\n    return PyUnicode_FromString(self->container->state(self->container));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint is_btrfs_subvol(const char *path)\n{\n\tstruct stat st;\n\tstruct statfs stfs;\n\tint ret;\n\n\tret = stat(path, &st);\n\tif (ret < 0)\n\t\treturn -errno;\n\n\tif (st.st_ino != BTRFS_FIRST_FREE_OBJECTID || !S_ISDIR(st.st_mode))\n\t\treturn 0;\n\n\tret = statfs(path, &stfs);\n\tif (ret < 0)\n\t\treturn -errno;\n\n\treturn stfs.f_type == BTRFS_SUPER_MAGIC;\n}"
  },
  {
    "function_name": "is_btrfs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
    "lines": "127-144",
    "snippet": "bool is_btrfs_fs(const char *path)\n{\n\tint fd, ret;\n\tstruct btrfs_ioctl_space_args sargs;\n\n\t// make sure this is a btrfs filesystem\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn false;\n\tsargs.space_slots = 0;\n\tsargs.total_spaces = 0;\n\tret = ioctl(fd, BTRFS_IOC_SPACE_INFO, &sargs);\n\tclose(fd);\n\tif (ret < 0)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "BTRFS_IOC_SPACE_INFO",
            "&sargs"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "path",
            "O_RDONLY"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "genetlink_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/genl.c",
          "lines": "106-116",
          "snippet": "extern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"genl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/genetlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"genl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nbool is_btrfs_fs(const char *path)\n{\n\tint fd, ret;\n\tstruct btrfs_ioctl_space_args sargs;\n\n\t// make sure this is a btrfs filesystem\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn false;\n\tsargs.space_slots = 0;\n\tsargs.total_spaces = 0;\n\tret = ioctl(fd, BTRFS_IOC_SPACE_INFO, &sargs);\n\tclose(fd);\n\tif (ret < 0)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "btrfs_list_get_path_rootid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
    "lines": "109-125",
    "snippet": "int btrfs_list_get_path_rootid(int fd, u64 *treeid)\n{\n\tint  ret;\n\tstruct btrfs_ioctl_ino_lookup_args args;\n\n\tmemset(&args, 0, sizeof(args));\n\targs.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\n\tret = ioctl(fd, BTRFS_IOC_INO_LOOKUP, &args);\n\tif (ret < 0) {\n\t\tWARN(\"Warning: can't perform the search -%s\\n\",\n\t\t\t\tstrerror(errno));\n\t\treturn ret;\n\t}\n\t*treeid = args.treeid;\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Warning: can't perform the search -%s\\n\"",
            "strerror(errno)"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "BTRFS_IOC_INO_LOOKUP",
            "&args"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&args",
            "0",
            "sizeof(args)"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint btrfs_list_get_path_rootid(int fd, u64 *treeid)\n{\n\tint  ret;\n\tstruct btrfs_ioctl_ino_lookup_args args;\n\n\tmemset(&args, 0, sizeof(args));\n\targs.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\n\tret = ioctl(fd, BTRFS_IOC_INO_LOOKUP, &args);\n\tif (ret < 0) {\n\t\tWARN(\"Warning: can't perform the search -%s\\n\",\n\t\t\t\tstrerror(errno));\n\t\treturn ret;\n\t}\n\t*treeid = args.treeid;\n\treturn 0;\n}"
  },
  {
    "function_name": "get_btrfs_subvol_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
    "lines": "56-103",
    "snippet": "char *get_btrfs_subvol_path(int fd, u64 dir_id, u64 objid, char *name,\n\t\t\t    int name_len)\n{\n\tstruct btrfs_ioctl_ino_lookup_args args;\n\tint ret, e;\n\tsize_t len;\n\tchar *retpath;\n\n\tmemset(&args, 0, sizeof(args));\n\targs.treeid = dir_id;\n\targs.objectid = objid;\n\n\tret = ioctl(fd, BTRFS_IOC_INO_LOOKUP, &args);\n\te = errno;\n\tif (ret) {\n\t\tERROR(\"%s: ERROR: Failed to lookup path for %llu %llu %s - %s\\n\",\n\t\t\t\t __func__, (unsigned long long) dir_id,\n\t\t\t\t (unsigned long long) objid,\n\t\t\t\t name, strerror(e));\n\t\treturn NULL;\n\t} else\n\t\tINFO(\"%s: got path for %llu %llu - %s\\n\", __func__,\n\t\t\t(unsigned long long) objid, (unsigned long long) dir_id,\n\t\t\tname);\n\n\tif (args.name[0]) {\n\t\t/*\n\t\t * we're in a subdirectory of ref_tree, the kernel ioctl\n\t\t * puts a / in there for us\n\t\t */\n\t\tlen = strlen(args.name) + name_len + 2;\n\t\tretpath = malloc(len);\n\t\tif (!retpath)\n\t\t\treturn NULL;\n\t\tstrcpy(retpath, args.name);\n\t\tstrcat(retpath, \"/\");\n\t\tstrncat(retpath, name, name_len);\n\t} else {\n\t\t/* we're at the root of ref_tree */\n\t\tlen = name_len + 1;\n\t\tretpath = malloc(len);\n\t\tif (!retpath)\n\t\t\treturn NULL;\n\t\t*retpath = '\\0';\n\t\tstrncat(retpath, name, name_len);\n\t}\n\treturn retpath;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncat",
          "args": [
            "retpath",
            "name",
            "name_len"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncat",
          "args": [
            "retpath",
            "name",
            "name_len"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "retpath",
            "\"/\""
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "retpath",
            "args.name"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "args.name"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"%s: got path for %llu %llu - %s\\n\"",
            "__func__",
            "(unsigned long long) objid",
            "(unsigned long long) dir_id",
            "name"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"%s: ERROR: Failed to lookup path for %llu %llu %s - %s\\n\"",
            "__func__",
            "(unsigned long long) dir_id",
            "(unsigned long long) objid",
            "name",
            "strerror(e)"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "e"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "BTRFS_IOC_INO_LOOKUP",
            "&args"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&args",
            "0",
            "sizeof(args)"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nchar *get_btrfs_subvol_path(int fd, u64 dir_id, u64 objid, char *name,\n\t\t\t    int name_len)\n{\n\tstruct btrfs_ioctl_ino_lookup_args args;\n\tint ret, e;\n\tsize_t len;\n\tchar *retpath;\n\n\tmemset(&args, 0, sizeof(args));\n\targs.treeid = dir_id;\n\targs.objectid = objid;\n\n\tret = ioctl(fd, BTRFS_IOC_INO_LOOKUP, &args);\n\te = errno;\n\tif (ret) {\n\t\tERROR(\"%s: ERROR: Failed to lookup path for %llu %llu %s - %s\\n\",\n\t\t\t\t __func__, (unsigned long long) dir_id,\n\t\t\t\t (unsigned long long) objid,\n\t\t\t\t name, strerror(e));\n\t\treturn NULL;\n\t} else\n\t\tINFO(\"%s: got path for %llu %llu - %s\\n\", __func__,\n\t\t\t(unsigned long long) objid, (unsigned long long) dir_id,\n\t\t\tname);\n\n\tif (args.name[0]) {\n\t\t/*\n\t\t * we're in a subdirectory of ref_tree, the kernel ioctl\n\t\t * puts a / in there for us\n\t\t */\n\t\tlen = strlen(args.name) + name_len + 2;\n\t\tretpath = malloc(len);\n\t\tif (!retpath)\n\t\t\treturn NULL;\n\t\tstrcpy(retpath, args.name);\n\t\tstrcat(retpath, \"/\");\n\t\tstrncat(retpath, name, name_len);\n\t} else {\n\t\t/* we're at the root of ref_tree */\n\t\tlen = name_len + 1;\n\t\tretpath = malloc(len);\n\t\tif (!retpath)\n\t\t\treturn NULL;\n\t\t*retpath = '\\0';\n\t\tstrncat(retpath, name, name_len);\n\t}\n\treturn retpath;\n}"
  }
]