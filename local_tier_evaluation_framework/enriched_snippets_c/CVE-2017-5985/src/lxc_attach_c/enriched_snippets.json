[
  {
    "function_name": "lxc_attach_run_shell",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
    "lines": "1350-1382",
    "snippet": "int lxc_attach_run_shell(void* payload)\n{\n\tuid_t uid;\n\tstruct passwd *passwd;\n\tchar *user_shell;\n\n\t/* Ignore payload parameter. */\n\t(void)payload;\n\n\tuid = getuid();\n\tpasswd = getpwuid(uid);\n\n\t/* This probably happens because of incompatible nss implementations in\n\t * host and container (remember, this code is still using the host's\n\t * glibc but our mount namespace is in the container) we may try to get\n\t * the information by spawning a [getent passwd uid] process and parsing\n\t * the result.\n\t */\n\tif (!passwd)\n\t\tuser_shell = lxc_attach_getpwshell(uid);\n\telse\n\t\tuser_shell = passwd->pw_shell;\n\n\tif (user_shell)\n\t\texeclp(user_shell, user_shell, (char *)NULL);\n\n\t/* Executed if either no passwd entry or execvp fails, we will fall back\n\t * on /bin/sh as a default shell.\n\t */\n\texeclp(\"/bin/sh\", \"/bin/sh\", (char *)NULL);\n\tSYSERROR(\"Failed to exec shell.\");\n\treturn -1;\n}",
    "includes": [
      "#include <sys/personality.h>",
      "#include \"confile.h\"",
      "#include \"lsm/lsm.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include \"lxcseccomp.h\"",
      "#include \"conf.h\"",
      "#include \"lxclock.h\"",
      "#include \"cgroup.h\"",
      "#include \"commands.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include \"caps.h\"",
      "#include \"attach.h\"",
      "#include \"af_unix.h\"",
      "#include \"log.h\"",
      "#include \"namespace.h\"",
      "#include <pwd.h>",
      "#include <linux/unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/mount.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to exec shell.\""
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "\"/bin/sh\"",
            "\"/bin/sh\"",
            "(char *)NULL"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "user_shell",
            "user_shell",
            "(char *)NULL"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_attach_getpwshell",
          "args": [
            "uid"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_attach_getpwshell",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
          "lines": "469-615",
          "snippet": "static char *lxc_attach_getpwshell(uid_t uid)\n{\n\tpid_t pid;\n\tint pipes[2];\n\tint ret;\n\tint fd;\n\tchar *result = NULL;\n\n\t/* We need to fork off a process that runs the getent program, and we\n\t * need to capture its output, so we use a pipe for that purpose.\n\t */\n\tret = pipe(pipes);\n\tif (ret < 0)\n\t\treturn NULL;\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tclose(pipes[0]);\n\t\tclose(pipes[1]);\n\t\treturn NULL;\n\t}\n\n\tif (pid) {\n\t\tFILE *pipe_f;\n\t\tchar *line = NULL;\n\t\tsize_t line_bufsz = 0;\n\t\tint found = 0;\n\t\tint status;\n\n\t\tclose(pipes[1]);\n\n\t\tpipe_f = fdopen(pipes[0], \"r\");\n\t\twhile (getline(&line, &line_bufsz, pipe_f) != -1) {\n\t\t\tchar *token;\n\t\t\tchar *saveptr = NULL;\n\t\t\tlong value;\n\t\t\tchar *endptr = NULL;\n\t\t\tint i;\n\n\t\t\t/* If we already found something, just continue to read\n\t\t\t * until the pipe doesn't deliver any more data, but\n\t\t\t * don't modify the existing data structure.\n\t\t\t */\n\t\t\tif (found)\n\t\t\t\tcontinue;\n\n\t\t\t/* Trim line on the right hand side. */\n\t\t\tfor (i = strlen(line); i > 0 && (line[i - 1] == '\\n' || line[i - 1] == '\\r'); --i)\n\t\t\t\tline[i - 1] = '\\0';\n\n\t\t\t/* Split into tokens: first: user name. */\n\t\t\ttoken = strtok_r(line, \":\", &saveptr);\n\t\t\tif (!token)\n\t\t\t\tcontinue;\n\t\t\t/* next: dummy password field */\n\t\t\ttoken = strtok_r(NULL, \":\", &saveptr);\n\t\t\tif (!token)\n\t\t\t\tcontinue;\n\t\t\t/* next: user id */\n\t\t\ttoken = strtok_r(NULL, \":\", &saveptr);\n\t\t\tvalue = token ? strtol(token, &endptr, 10) : 0;\n\t\t\tif (!token || !endptr || *endptr || value == LONG_MIN || value == LONG_MAX)\n\t\t\t\tcontinue;\n\t\t\t/* dummy sanity check: user id matches */\n\t\t\tif ((uid_t) value != uid)\n\t\t\t\tcontinue;\n\t\t\t/* skip fields: gid, gecos, dir, go to next field 'shell' */\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\ttoken = strtok_r(NULL, \":\", &saveptr);\n\t\t\t\tif (!token)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!token)\n\t\t\t\tcontinue;\n\t\t\tfree(result);\n\t\t\tresult = strdup(token);\n\n\t\t\t/* Sanity check that there are no fields after that. */\n\t\t\ttoken = strtok_r(NULL, \":\", &saveptr);\n\t\t\tif (token)\n\t\t\t\tcontinue;\n\n\t\t\tfound = 1;\n\t\t}\n\n\t\tfree(line);\n\t\tfclose(pipe_f);\n\tagain:\n\t\tif (waitpid(pid, &status, 0) < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tgoto again;\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* Some sanity checks. If anything even hinted at going wrong,\n\t\t * we can't be sure we have a valid result, so we assume we\n\t\t * don't.\n\t\t */\n\n\t\tif (!WIFEXITED(status))\n\t\t\treturn NULL;\n\n\t\tif (WEXITSTATUS(status) != 0)\n\t\t\treturn NULL;\n\n\t\tif (!found)\n\t\t\treturn NULL;\n\n\t\treturn result;\n\t} else {\n\t\tchar uid_buf[32];\n\t\tchar *arguments[] = {\n\t\t\t\"getent\",\n\t\t\t\"passwd\",\n\t\t\tuid_buf,\n\t\t\tNULL\n\t\t};\n\n\t\tclose(pipes[0]);\n\n\t\t/* We want to capture stdout. */\n\t\tdup2(pipes[1], 1);\n\t\tclose(pipes[1]);\n\n\t\t/* Get rid of stdin/stderr, so we try to associate it with\n\t\t * /dev/null.\n\t\t */\n\t\tfd = open(\"/dev/null\", O_RDWR);\n\t\tif (fd < 0) {\n\t\t\tclose(0);\n\t\t\tclose(2);\n\t\t} else {\n\t\t\tdup2(fd, 0);\n\t\t\tdup2(fd, 2);\n\t\t\tclose(fd);\n\t\t}\n\n\t\t/* Finish argument list. */\n\t\tret = snprintf(uid_buf, sizeof(uid_buf), \"%ld\", (long) uid);\n\t\tif (ret <= 0)\n\t\t\texit(-1);\n\n\t\t/* Try to run getent program. */\n\t\t(void) execvp(\"getent\", arguments);\n\t\texit(-1);\n\t}\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include \"confile.h\"",
            "#include \"lsm/lsm.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"conf.h\"",
            "#include \"lxclock.h\"",
            "#include \"cgroup.h\"",
            "#include \"commands.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include \"caps.h\"",
            "#include \"attach.h\"",
            "#include \"af_unix.h\"",
            "#include \"log.h\"",
            "#include \"namespace.h\"",
            "#include <pwd.h>",
            "#include <linux/unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/mount.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int attach_child_main(void* data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include \"confile.h\"\n#include \"lsm/lsm.h\"\n#include <lxc/lxccontainer.h>\n#include \"lxcseccomp.h\"\n#include \"conf.h\"\n#include \"lxclock.h\"\n#include \"cgroup.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"caps.h\"\n#include \"attach.h\"\n#include \"af_unix.h\"\n#include \"log.h\"\n#include \"namespace.h\"\n#include <pwd.h>\n#include <linux/unistd.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\nstatic int attach_child_main(void* data);\n\nstatic char *lxc_attach_getpwshell(uid_t uid)\n{\n\tpid_t pid;\n\tint pipes[2];\n\tint ret;\n\tint fd;\n\tchar *result = NULL;\n\n\t/* We need to fork off a process that runs the getent program, and we\n\t * need to capture its output, so we use a pipe for that purpose.\n\t */\n\tret = pipe(pipes);\n\tif (ret < 0)\n\t\treturn NULL;\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tclose(pipes[0]);\n\t\tclose(pipes[1]);\n\t\treturn NULL;\n\t}\n\n\tif (pid) {\n\t\tFILE *pipe_f;\n\t\tchar *line = NULL;\n\t\tsize_t line_bufsz = 0;\n\t\tint found = 0;\n\t\tint status;\n\n\t\tclose(pipes[1]);\n\n\t\tpipe_f = fdopen(pipes[0], \"r\");\n\t\twhile (getline(&line, &line_bufsz, pipe_f) != -1) {\n\t\t\tchar *token;\n\t\t\tchar *saveptr = NULL;\n\t\t\tlong value;\n\t\t\tchar *endptr = NULL;\n\t\t\tint i;\n\n\t\t\t/* If we already found something, just continue to read\n\t\t\t * until the pipe doesn't deliver any more data, but\n\t\t\t * don't modify the existing data structure.\n\t\t\t */\n\t\t\tif (found)\n\t\t\t\tcontinue;\n\n\t\t\t/* Trim line on the right hand side. */\n\t\t\tfor (i = strlen(line); i > 0 && (line[i - 1] == '\\n' || line[i - 1] == '\\r'); --i)\n\t\t\t\tline[i - 1] = '\\0';\n\n\t\t\t/* Split into tokens: first: user name. */\n\t\t\ttoken = strtok_r(line, \":\", &saveptr);\n\t\t\tif (!token)\n\t\t\t\tcontinue;\n\t\t\t/* next: dummy password field */\n\t\t\ttoken = strtok_r(NULL, \":\", &saveptr);\n\t\t\tif (!token)\n\t\t\t\tcontinue;\n\t\t\t/* next: user id */\n\t\t\ttoken = strtok_r(NULL, \":\", &saveptr);\n\t\t\tvalue = token ? strtol(token, &endptr, 10) : 0;\n\t\t\tif (!token || !endptr || *endptr || value == LONG_MIN || value == LONG_MAX)\n\t\t\t\tcontinue;\n\t\t\t/* dummy sanity check: user id matches */\n\t\t\tif ((uid_t) value != uid)\n\t\t\t\tcontinue;\n\t\t\t/* skip fields: gid, gecos, dir, go to next field 'shell' */\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\ttoken = strtok_r(NULL, \":\", &saveptr);\n\t\t\t\tif (!token)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!token)\n\t\t\t\tcontinue;\n\t\t\tfree(result);\n\t\t\tresult = strdup(token);\n\n\t\t\t/* Sanity check that there are no fields after that. */\n\t\t\ttoken = strtok_r(NULL, \":\", &saveptr);\n\t\t\tif (token)\n\t\t\t\tcontinue;\n\n\t\t\tfound = 1;\n\t\t}\n\n\t\tfree(line);\n\t\tfclose(pipe_f);\n\tagain:\n\t\tif (waitpid(pid, &status, 0) < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tgoto again;\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* Some sanity checks. If anything even hinted at going wrong,\n\t\t * we can't be sure we have a valid result, so we assume we\n\t\t * don't.\n\t\t */\n\n\t\tif (!WIFEXITED(status))\n\t\t\treturn NULL;\n\n\t\tif (WEXITSTATUS(status) != 0)\n\t\t\treturn NULL;\n\n\t\tif (!found)\n\t\t\treturn NULL;\n\n\t\treturn result;\n\t} else {\n\t\tchar uid_buf[32];\n\t\tchar *arguments[] = {\n\t\t\t\"getent\",\n\t\t\t\"passwd\",\n\t\t\tuid_buf,\n\t\t\tNULL\n\t\t};\n\n\t\tclose(pipes[0]);\n\n\t\t/* We want to capture stdout. */\n\t\tdup2(pipes[1], 1);\n\t\tclose(pipes[1]);\n\n\t\t/* Get rid of stdin/stderr, so we try to associate it with\n\t\t * /dev/null.\n\t\t */\n\t\tfd = open(\"/dev/null\", O_RDWR);\n\t\tif (fd < 0) {\n\t\t\tclose(0);\n\t\t\tclose(2);\n\t\t} else {\n\t\t\tdup2(fd, 0);\n\t\t\tdup2(fd, 2);\n\t\t\tclose(fd);\n\t\t}\n\n\t\t/* Finish argument list. */\n\t\tret = snprintf(uid_buf, sizeof(uid_buf), \"%ld\", (long) uid);\n\t\tif (ret <= 0)\n\t\t\texit(-1);\n\n\t\t/* Try to run getent program. */\n\t\t(void) execvp(\"getent\", arguments);\n\t\texit(-1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpwuid",
          "args": [
            "uid"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/personality.h>\n#include \"confile.h\"\n#include \"lsm/lsm.h\"\n#include <lxc/lxccontainer.h>\n#include \"lxcseccomp.h\"\n#include \"conf.h\"\n#include \"lxclock.h\"\n#include \"cgroup.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"caps.h\"\n#include \"attach.h\"\n#include \"af_unix.h\"\n#include \"log.h\"\n#include \"namespace.h\"\n#include <pwd.h>\n#include <linux/unistd.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\nint lxc_attach_run_shell(void* payload)\n{\n\tuid_t uid;\n\tstruct passwd *passwd;\n\tchar *user_shell;\n\n\t/* Ignore payload parameter. */\n\t(void)payload;\n\n\tuid = getuid();\n\tpasswd = getpwuid(uid);\n\n\t/* This probably happens because of incompatible nss implementations in\n\t * host and container (remember, this code is still using the host's\n\t * glibc but our mount namespace is in the container) we may try to get\n\t * the information by spawning a [getent passwd uid] process and parsing\n\t * the result.\n\t */\n\tif (!passwd)\n\t\tuser_shell = lxc_attach_getpwshell(uid);\n\telse\n\t\tuser_shell = passwd->pw_shell;\n\n\tif (user_shell)\n\t\texeclp(user_shell, user_shell, (char *)NULL);\n\n\t/* Executed if either no passwd entry or execvp fails, we will fall back\n\t * on /bin/sh as a default shell.\n\t */\n\texeclp(\"/bin/sh\", \"/bin/sh\", (char *)NULL);\n\tSYSERROR(\"Failed to exec shell.\");\n\treturn -1;\n}"
  },
  {
    "function_name": "lxc_attach_run_command",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
    "lines": "1341-1348",
    "snippet": "int lxc_attach_run_command(void* payload)\n{\n\tlxc_attach_command_t* cmd = (lxc_attach_command_t*)payload;\n\n\texecvp(cmd->program, cmd->argv);\n\tSYSERROR(\"Failed to exec \\\"%s\\\".\", cmd->program);\n\treturn -1;\n}",
    "includes": [
      "#include <sys/personality.h>",
      "#include \"confile.h\"",
      "#include \"lsm/lsm.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include \"lxcseccomp.h\"",
      "#include \"conf.h\"",
      "#include \"lxclock.h\"",
      "#include \"cgroup.h\"",
      "#include \"commands.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include \"caps.h\"",
      "#include \"attach.h\"",
      "#include \"af_unix.h\"",
      "#include \"log.h\"",
      "#include \"namespace.h\"",
      "#include <pwd.h>",
      "#include <linux/unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/mount.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to exec \\\"%s\\\".\"",
            "cmd->program"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "cmd->program",
            "cmd->argv"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/personality.h>\n#include \"confile.h\"\n#include \"lsm/lsm.h\"\n#include <lxc/lxccontainer.h>\n#include \"lxcseccomp.h\"\n#include \"conf.h\"\n#include \"lxclock.h\"\n#include \"cgroup.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"caps.h\"\n#include \"attach.h\"\n#include \"af_unix.h\"\n#include \"log.h\"\n#include \"namespace.h\"\n#include <pwd.h>\n#include <linux/unistd.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\nint lxc_attach_run_command(void* payload)\n{\n\tlxc_attach_command_t* cmd = (lxc_attach_command_t*)payload;\n\n\texecvp(cmd->program, cmd->argv);\n\tSYSERROR(\"Failed to exec \\\"%s\\\".\", cmd->program);\n\treturn -1;\n}"
  },
  {
    "function_name": "attach_child_main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
    "lines": "1102-1339",
    "snippet": "static int attach_child_main(void* data)\n{\n\tstruct attach_clone_payload* payload = (struct attach_clone_payload*)data;\n\tint ipc_socket = payload->ipc_socket;\n\tlxc_attach_options_t* options = payload->options;\n\tstruct lxc_proc_context_info* init_ctx = payload->init_ctx;\n#if HAVE_SYS_PERSONALITY_H\n\tlong new_personality;\n#endif\n\tint ret;\n\tint status;\n\tint expected;\n\tlong flags;\n\tint fd;\n\tint lsm_labelfd;\n\tuid_t new_uid;\n\tgid_t new_gid;\n\n\t/* Wait for the initial thread to signal us that it's ready for us to\n\t * start initializing.\n\t */\n\texpected = 0;\n\tstatus = -1;\n\tret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);\n\tif (ret <= 0) {\n\t\tERROR(\"Expected to receive sequence number 0: %s.\", strerror(errno));\n\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\t/* A description of the purpose of this functionality is provided in the\n\t * lxc-attach(1) manual page. We have to remount here and not in the\n\t * parent process, otherwise /proc may not properly reflect the new pid\n\t * namespace.\n\t */\n\tif (!(options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_REMOUNT_PROC_SYS)) {\n\t\tret = lxc_attach_remount_sys_proc();\n\t\tif (ret < 0) {\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\trexit(-1);\n\t\t}\n\t}\n\n\t/* Now perform additional attachments. */\n#if HAVE_SYS_PERSONALITY_H\n\tif (options->personality < 0)\n\t\tnew_personality = init_ctx->personality;\n\telse\n\t\tnew_personality = options->personality;\n\n\tif (options->attach_flags & LXC_ATTACH_SET_PERSONALITY) {\n\t\tret = personality(new_personality);\n\t\tif (ret < 0) {\n\t\t\tSYSERROR(\"Could not ensure correct architecture.\");\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\trexit(-1);\n\t\t}\n\t}\n#endif\n\n\tif (options->attach_flags & LXC_ATTACH_DROP_CAPABILITIES) {\n\t\tret = lxc_attach_drop_privs(init_ctx);\n\t\tif (ret < 0) {\n\t\t\tERROR(\"Could not drop privileges.\");\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\trexit(-1);\n\t\t}\n\t}\n\n\t/* Always set the environment (specify (LXC_ATTACH_KEEP_ENV, NULL, NULL)\n\t * if you want this to be a no-op).\n\t */\n\tret = lxc_attach_set_environment(options->env_policy, options->extra_env_vars, options->extra_keep_env);\n\tif (ret < 0) {\n\t\tERROR(\"Could not set initial environment for attached process.\");\n\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\t/* Set {u,g}id. */\n\tnew_uid = 0;\n\tnew_gid = 0;\n\t/* Ignore errors, we will fall back to root in that case (/proc was not\n\t * mounted etc.).\n\t */\n\tif (options->namespaces & CLONE_NEWUSER)\n\t\tlxc_attach_get_init_uidgid(&new_uid, &new_gid);\n\n\tif (options->uid != (uid_t)-1)\n\t\tnew_uid = options->uid;\n\tif (options->gid != (gid_t)-1)\n\t\tnew_gid = options->gid;\n\n\t/* Setup the controlling tty. */\n\tif (options->stdin_fd && isatty(options->stdin_fd)) {\n\t\tif (setsid() < 0) {\n\t\t\tSYSERROR(\"Unable to setsid.\");\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\trexit(-1);\n\t\t}\n\n\t\tif (ioctl(options->stdin_fd, TIOCSCTTY, (char *)NULL) < 0) {\n\t\t\tSYSERROR(\"Unable to set TIOCSTTY.\");\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\trexit(-1);\n\t\t}\n\t}\n\n\t/* Try to set the {u,g}id combination. */\n\tif ((new_gid != 0 || options->namespaces & CLONE_NEWUSER)) {\n\t\tif (setgid(new_gid) || setgroups(0, NULL)) {\n\t\t\tSYSERROR(\"Switching to container gid.\");\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\trexit(-1);\n\t\t}\n\t}\n\tif ((new_uid != 0 || options->namespaces & CLONE_NEWUSER) && setuid(new_uid)) {\n\t\tSYSERROR(\"Switching to container uid.\");\n\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\t/* Tell initial process it may now put us into cgroups. */\n\tstatus = 1;\n\tret = lxc_write_nointr(ipc_socket, &status, sizeof(status));\n\tif (ret != sizeof(status)) {\n\t\tERROR(\"Intended to send sequence number 1: %s.\", strerror(errno));\n\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\t/* Wait for the initial thread to signal us that it has done everything\n\t * for us when it comes to cgroups etc.\n\t */\n\texpected = 2;\n\tstatus = -1;\n\tret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);\n\tif (ret <= 0) {\n\t\tERROR(\"Expected to receive sequence number 2: %s\", strerror(errno));\n\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\tif ((init_ctx->container && init_ctx->container->lxc_conf &&\n\t     init_ctx->container->lxc_conf->no_new_privs) ||\n\t    (options->attach_flags & LXC_ATTACH_NO_NEW_PRIVS)) {\n\t\tif (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0) {\n\t\t\tSYSERROR(\"PR_SET_NO_NEW_PRIVS could not be set. \"\n\t\t\t\t \"Process can use execve() gainable \"\n\t\t\t\t \"privileges.\");\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\trexit(-1);\n\t\t}\n\t\tINFO(\"PR_SET_NO_NEW_PRIVS is set. Process cannot use execve() \"\n\t\t     \"gainable privileges.\");\n\t}\n\n\t/* Tell the (grand)parent to send us LSM label fd. */\n\tstatus = 3;\n\tret = lxc_write_nointr(ipc_socket, &status, sizeof(status));\n\tif (ret <= 0) {\n\t\tERROR(\"Intended to send sequence number 3: %s.\", strerror(errno));\n\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\tif ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {\n\t\tint on_exec;\n\t\t/* Receive fd for LSM security module. */\n\t\tret = lxc_abstract_unix_recv_fd(ipc_socket, &lsm_labelfd, NULL, 0);\n\t\tif (ret <= 0) {\n\t\t\tERROR(\"Expected to receive file descriptor: %s.\", strerror(errno));\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\trexit(-1);\n\t\t}\n\n\t\t/* Change into our new LSM profile. */\n\t\ton_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;\n\t\tif (lsm_set_label_at(lsm_labelfd, on_exec, init_ctx->lsm_label) < 0) {\n\t\t\tSYSERROR(\"Failed to set LSM label.\");\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\tclose(lsm_labelfd);\n\t\t\trexit(-1);\n\t\t}\n\t\tclose(lsm_labelfd);\n\t}\n\n\tif (init_ctx->container && init_ctx->container->lxc_conf &&\n\t    init_ctx->container->lxc_conf->seccomp &&\n\t    (lxc_seccomp_load(init_ctx->container->lxc_conf) != 0)) {\n\t\tERROR(\"Failed to load seccomp policy.\");\n\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\tshutdown(ipc_socket, SHUT_RDWR);\n\tclose(ipc_socket);\n\tlxc_proc_put_context_info(init_ctx);\n\n\t/* The following is done after the communication socket is shut down.\n\t * That way, all errors that might (though unlikely) occur up until this\n\t * point will have their messages printed to the original stderr (if\n\t * logging is so configured) and not the fd the user supplied, if any.\n\t */\n\n\t/* Fd handling for stdin, stdout and stderr; ignore errors here, user\n\t * may want to make sure the fds are closed, for example.\n\t */\n\tif (options->stdin_fd >= 0 && options->stdin_fd != 0)\n\t\tdup2(options->stdin_fd, 0);\n\tif (options->stdout_fd >= 0 && options->stdout_fd != 1)\n\t\tdup2(options->stdout_fd, 1);\n\tif (options->stderr_fd >= 0 && options->stderr_fd != 2)\n\t\tdup2(options->stderr_fd, 2);\n\n\t/* close the old fds */\n\tif (options->stdin_fd > 2)\n\t\tclose(options->stdin_fd);\n\tif (options->stdout_fd > 2)\n\t\tclose(options->stdout_fd);\n\tif (options->stderr_fd > 2)\n\t\tclose(options->stderr_fd);\n\n\t/* Try to remove FD_CLOEXEC flag from stdin/stdout/stderr, but also\n\t * here, ignore errors.\n\t */\n\tfor (fd = 0; fd <= 2; fd++) {\n\t\tflags = fcntl(fd, F_GETFL);\n\t\tif (flags < 0)\n\t\t\tcontinue;\n\t\tif (flags & FD_CLOEXEC)\n\t\t\tif (fcntl(fd, F_SETFL, flags & ~FD_CLOEXEC) < 0)\n\t\t\t\tSYSERROR(\"Unable to clear FD_CLOEXEC from file descriptor.\");\n\t}\n\n\t/* We're done, so we can now do whatever the user intended us to do. */\n\trexit(payload->exec_function(payload->exec_payload));\n}",
    "includes": [
      "#include <sys/personality.h>",
      "#include \"confile.h\"",
      "#include \"lsm/lsm.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include \"lxcseccomp.h\"",
      "#include \"conf.h\"",
      "#include \"lxclock.h\"",
      "#include \"cgroup.h\"",
      "#include \"commands.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include \"caps.h\"",
      "#include \"attach.h\"",
      "#include \"af_unix.h\"",
      "#include \"log.h\"",
      "#include \"namespace.h\"",
      "#include <pwd.h>",
      "#include <linux/unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/mount.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [
      "#define PR_SET_NO_NEW_PRIVS 38"
    ],
    "globals_used": [
      "static int attach_child_main(void* data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rexit",
          "args": [
            "payload->exec_function(payload->exec_payload)"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "payload->exec_function",
          "args": [
            "payload->exec_payload"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Unable to clear FD_CLOEXEC from file descriptor.\""
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "fd",
            "F_SETFL",
            "flags & ~FD_CLOEXEC"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "fd",
            "F_GETFL"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "options->stderr_fd"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "options->stderr_fd",
            "2"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "options->stdout_fd",
            "1"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "options->stdin_fd",
            "0"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_proc_put_context_info",
          "args": [
            "init_ctx"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_proc_put_context_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
          "lines": "240-246",
          "snippet": "static void lxc_proc_put_context_info(struct lxc_proc_context_info *ctx)\n{\n\tfree(ctx->lsm_label);\n\tif (ctx->container)\n\t\tlxc_container_put(ctx->container);\n\tfree(ctx);\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include \"confile.h\"",
            "#include \"lsm/lsm.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"conf.h\"",
            "#include \"lxclock.h\"",
            "#include \"cgroup.h\"",
            "#include \"commands.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include \"caps.h\"",
            "#include \"attach.h\"",
            "#include \"af_unix.h\"",
            "#include \"log.h\"",
            "#include \"namespace.h\"",
            "#include <pwd.h>",
            "#include <linux/unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/mount.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include \"confile.h\"\n#include \"lsm/lsm.h\"\n#include <lxc/lxccontainer.h>\n#include \"lxcseccomp.h\"\n#include \"conf.h\"\n#include \"lxclock.h\"\n#include \"cgroup.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"caps.h\"\n#include \"attach.h\"\n#include \"af_unix.h\"\n#include \"log.h\"\n#include \"namespace.h\"\n#include <pwd.h>\n#include <linux/unistd.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\nstatic void lxc_proc_put_context_info(struct lxc_proc_context_info *ctx)\n{\n\tfree(ctx->lsm_label);\n\tif (ctx->container)\n\t\tlxc_container_put(ctx->container);\n\tfree(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "shutdown",
          "args": [
            "ipc_socket",
            "SHUT_RDWR"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "do_lxcapi_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "1602-1631",
          "snippet": "static bool do_lxcapi_shutdown(struct lxc_container *c, int timeout)\n{\n\tbool retv;\n\tpid_t pid;\n\tint haltsignal = SIGPWR;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (!do_lxcapi_is_running(c))\n\t\treturn true;\n\tpid = do_lxcapi_init_pid(c);\n\tif (pid <= 0)\n\t\treturn true;\n\n\t/* Detect whether we should send SIGRTMIN + 3 (e.g. systemd). */\n\tif (task_blocking_signal(pid, (SIGRTMIN + 3)))\n\t\thaltsignal = (SIGRTMIN + 3);\n\n\tif (c->lxc_conf && c->lxc_conf->haltsignal)\n\t\thaltsignal = c->lxc_conf->haltsignal;\n\n\tINFO(\"Using signal number '%d' as halt signal.\", haltsignal);\n\n\tif (kill(pid, haltsignal) < 0)\n\t\tWARN(\"Could not send signal %d to pid %d.\", haltsignal, pid);\n\n\tretv = do_lxcapi_wait(c, \"STOPPED\", timeout);\n\treturn retv;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_shutdown(struct lxc_container *c, int timeout)\n{\n\tbool retv;\n\tpid_t pid;\n\tint haltsignal = SIGPWR;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (!do_lxcapi_is_running(c))\n\t\treturn true;\n\tpid = do_lxcapi_init_pid(c);\n\tif (pid <= 0)\n\t\treturn true;\n\n\t/* Detect whether we should send SIGRTMIN + 3 (e.g. systemd). */\n\tif (task_blocking_signal(pid, (SIGRTMIN + 3)))\n\t\thaltsignal = (SIGRTMIN + 3);\n\n\tif (c->lxc_conf && c->lxc_conf->haltsignal)\n\t\thaltsignal = c->lxc_conf->haltsignal;\n\n\tINFO(\"Using signal number '%d' as halt signal.\", haltsignal);\n\n\tif (kill(pid, haltsignal) < 0)\n\t\tWARN(\"Could not send signal %d to pid %d.\", haltsignal, pid);\n\n\tretv = do_lxcapi_wait(c, \"STOPPED\", timeout);\n\treturn retv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rexit",
          "args": [
            "-1"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to load seccomp policy.\""
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_seccomp_load",
          "args": [
            "init_ctx->container->lxc_conf"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_load",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxcseccomp.h",
          "lines": "34-36",
          "snippet": "static inline int lxc_seccomp_load(struct lxc_conf *conf) {\n\treturn 0;\n}",
          "includes": [
            "#include \"conf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"conf.h\"\n\nstatic inline int lxc_seccomp_load(struct lxc_conf *conf) {\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rexit",
          "args": [
            "-1"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to set LSM label.\""
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lsm_set_label_at",
          "args": [
            "lsm_labelfd",
            "on_exec",
            "init_ctx->lsm_label"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "lsm_set_label_at",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
          "lines": "125-182",
          "snippet": "static int lsm_set_label_at(int lsm_labelfd, int on_exec, char *lsm_label)\n{\n\tint fret = -1;\n\tconst char* name;\n\tchar *command = NULL;\n\n\tname = lsm_name();\n\n\tif (strcmp(name, \"nop\") == 0)\n\t\treturn 0;\n\n\tif (strcmp(name, \"none\") == 0)\n\t\treturn 0;\n\n\t/* We don't support on-exec with AppArmor */\n\tif (strcmp(name, \"AppArmor\") == 0)\n\t\ton_exec = 0;\n\n\tif (strcmp(name, \"AppArmor\") == 0) {\n\t\tint size;\n\n\t\tcommand = malloc(strlen(lsm_label) + strlen(\"changeprofile \") + 1);\n\t\tif (!command) {\n\t\t\tSYSERROR(\"Failed to write apparmor profile.\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tsize = sprintf(command, \"changeprofile %s\", lsm_label);\n\t\tif (size < 0) {\n\t\t\tSYSERROR(\"Failed to write apparmor profile.\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (write(lsm_labelfd, command, size + 1) < 0) {\n\t\t\tSYSERROR(\"Unable to set LSM label: %s.\", command);\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Set LSM label to: %s.\", command);\n\t} else if (strcmp(name, \"SELinux\") == 0) {\n\t\tif (write(lsm_labelfd, lsm_label, strlen(lsm_label) + 1) < 0) {\n\t\t\tSYSERROR(\"Unable to set LSM label: %s.\", lsm_label);\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Set LSM label to: %s.\", lsm_label);\n\t} else {\n\t\tERROR(\"Unable to restore label for unknown LSM: %s.\", name);\n\t\tgoto out;\n\t}\n\tfret = 0;\n\nout:\n\tfree(command);\n\n\tif (lsm_labelfd != -1)\n\t\tclose(lsm_labelfd);\n\n\treturn fret;\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include \"confile.h\"",
            "#include \"lsm/lsm.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"conf.h\"",
            "#include \"lxclock.h\"",
            "#include \"cgroup.h\"",
            "#include \"commands.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include \"caps.h\"",
            "#include \"attach.h\"",
            "#include \"af_unix.h\"",
            "#include \"log.h\"",
            "#include \"namespace.h\"",
            "#include <pwd.h>",
            "#include <linux/unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/mount.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include \"confile.h\"\n#include \"lsm/lsm.h\"\n#include <lxc/lxccontainer.h>\n#include \"lxcseccomp.h\"\n#include \"conf.h\"\n#include \"lxclock.h\"\n#include \"cgroup.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"caps.h\"\n#include \"attach.h\"\n#include \"af_unix.h\"\n#include \"log.h\"\n#include \"namespace.h\"\n#include <pwd.h>\n#include <linux/unistd.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\nstatic int lsm_set_label_at(int lsm_labelfd, int on_exec, char *lsm_label)\n{\n\tint fret = -1;\n\tconst char* name;\n\tchar *command = NULL;\n\n\tname = lsm_name();\n\n\tif (strcmp(name, \"nop\") == 0)\n\t\treturn 0;\n\n\tif (strcmp(name, \"none\") == 0)\n\t\treturn 0;\n\n\t/* We don't support on-exec with AppArmor */\n\tif (strcmp(name, \"AppArmor\") == 0)\n\t\ton_exec = 0;\n\n\tif (strcmp(name, \"AppArmor\") == 0) {\n\t\tint size;\n\n\t\tcommand = malloc(strlen(lsm_label) + strlen(\"changeprofile \") + 1);\n\t\tif (!command) {\n\t\t\tSYSERROR(\"Failed to write apparmor profile.\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tsize = sprintf(command, \"changeprofile %s\", lsm_label);\n\t\tif (size < 0) {\n\t\t\tSYSERROR(\"Failed to write apparmor profile.\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (write(lsm_labelfd, command, size + 1) < 0) {\n\t\t\tSYSERROR(\"Unable to set LSM label: %s.\", command);\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Set LSM label to: %s.\", command);\n\t} else if (strcmp(name, \"SELinux\") == 0) {\n\t\tif (write(lsm_labelfd, lsm_label, strlen(lsm_label) + 1) < 0) {\n\t\t\tSYSERROR(\"Unable to set LSM label: %s.\", lsm_label);\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Set LSM label to: %s.\", lsm_label);\n\t} else {\n\t\tERROR(\"Unable to restore label for unknown LSM: %s.\", name);\n\t\tgoto out;\n\t}\n\tfret = 0;\n\nout:\n\tfree(command);\n\n\tif (lsm_labelfd != -1)\n\t\tclose(lsm_labelfd);\n\n\treturn fret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rexit",
          "args": [
            "-1"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Expected to receive file descriptor: %s.\"",
            "strerror(errno)"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_abstract_unix_recv_fd",
          "args": [
            "ipc_socket",
            "&lsm_labelfd",
            "NULL",
            "0"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_recv_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "164-201",
          "snippet": "int lxc_abstract_unix_recv_fd(int fd, int *recvfd, void *data, size_t size)\n{\n\tstruct msghdr msg = { 0 };\n\tstruct iovec iov;\n\tstruct cmsghdr *cmsg;\n\tchar cmsgbuf[CMSG_SPACE(sizeof(int))];\n\tchar buf[1];\n\tint ret, *val;\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_namelen = 0;\n\tmsg.msg_control = cmsgbuf;\n\tmsg.msg_controllen = sizeof(cmsgbuf);\n\n\tiov.iov_base = data ? data : buf;\n\tiov.iov_len = data ? size : sizeof(buf);\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\tret = recvmsg(fd, &msg, 0);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\n\t/* if the message is wrong the variable will not be\n\t * filled and the peer will notified about a problem */\n\t*recvfd = -1;\n\n\tif (cmsg && cmsg->cmsg_len == CMSG_LEN(sizeof(int)) &&\n\t\t\tcmsg->cmsg_level == SOL_SOCKET &&\n\t\t\tcmsg->cmsg_type == SCM_RIGHTS) {\n\t\tval = (int *) CMSG_DATA(cmsg);\n\t\t*recvfd = *val;\n\t}\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_recv_fd(int fd, int *recvfd, void *data, size_t size)\n{\n\tstruct msghdr msg = { 0 };\n\tstruct iovec iov;\n\tstruct cmsghdr *cmsg;\n\tchar cmsgbuf[CMSG_SPACE(sizeof(int))];\n\tchar buf[1];\n\tint ret, *val;\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_namelen = 0;\n\tmsg.msg_control = cmsgbuf;\n\tmsg.msg_controllen = sizeof(cmsgbuf);\n\n\tiov.iov_base = data ? data : buf;\n\tiov.iov_len = data ? size : sizeof(buf);\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\tret = recvmsg(fd, &msg, 0);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\n\t/* if the message is wrong the variable will not be\n\t * filled and the peer will notified about a problem */\n\t*recvfd = -1;\n\n\tif (cmsg && cmsg->cmsg_len == CMSG_LEN(sizeof(int)) &&\n\t\t\tcmsg->cmsg_level == SOL_SOCKET &&\n\t\t\tcmsg->cmsg_type == SCM_RIGHTS) {\n\t\tval = (int *) CMSG_DATA(cmsg);\n\t\t*recvfd = *val;\n\t}\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rexit",
          "args": [
            "-1"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Intended to send sequence number 3: %s.\"",
            "strerror(errno)"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_write_nointr",
          "args": [
            "ipc_socket",
            "&status",
            "sizeof(status)"
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_nointr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "327-335",
          "snippet": "ssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"PR_SET_NO_NEW_PRIVS is set. Process cannot use execve() \"\n\t\t     \"gainable privileges.\""
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rexit",
          "args": [
            "-1"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"PR_SET_NO_NEW_PRIVS could not be set. \"\n\t\t\t\t \"Process can use execve() gainable \"\n\t\t\t\t \"privileges.\""
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prctl",
          "args": [
            "PR_SET_NO_NEW_PRIVS",
            "1",
            "0",
            "0",
            "0"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rexit",
          "args": [
            "-1"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Expected to receive sequence number 2: %s\"",
            "strerror(errno)"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_read_nointr_expect",
          "args": [
            "ipc_socket",
            "&status",
            "sizeof(status)",
            "&expected"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_nointr_expect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "347-360",
          "snippet": "ssize_t lxc_read_nointr_expect(int fd, void* buf, size_t count, const void* expected_buf)\n{\n\tssize_t ret;\n\tret = lxc_read_nointr(fd, buf, count);\n\tif (ret <= 0)\n\t\treturn ret;\n\tif ((size_t)ret != count)\n\t\treturn -1;\n\tif (expected_buf && memcmp(buf, expected_buf, count) != 0) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_read_nointr_expect(int fd, void* buf, size_t count, const void* expected_buf)\n{\n\tssize_t ret;\n\tret = lxc_read_nointr(fd, buf, count);\n\tif (ret <= 0)\n\t\treturn ret;\n\tif ((size_t)ret != count)\n\t\treturn -1;\n\tif (expected_buf && memcmp(buf, expected_buf, count) != 0) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rexit",
          "args": [
            "-1"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Intended to send sequence number 1: %s.\"",
            "strerror(errno)"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rexit",
          "args": [
            "-1"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Switching to container uid.\""
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setuid",
          "args": [
            "new_uid"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rexit",
          "args": [
            "-1"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Switching to container gid.\""
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setgroups",
          "args": [
            "0",
            "NULL"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_setgroups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "2063-2072",
          "snippet": "int lxc_setgroups(int size, gid_t list[])\n{\n\tif (setgroups(size, list) < 0) {\n\t\tSYSERROR(\"Failed to setgroups().\");\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Dropped additional groups.\");\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_setgroups(int size, gid_t list[])\n{\n\tif (setgroups(size, list) < 0) {\n\t\tSYSERROR(\"Failed to setgroups().\");\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Dropped additional groups.\");\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setgid",
          "args": [
            "new_gid"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rexit",
          "args": [
            "-1"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Unable to set TIOCSTTY.\""
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "options->stdin_fd",
            "TIOCSCTTY",
            "(char *)NULL"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rexit",
          "args": [
            "-1"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Unable to setsid.\""
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsid",
          "args": [],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "options->stdin_fd"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_attach_get_init_uidgid",
          "args": [
            "&new_uid",
            "&new_gid"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_attach_get_init_uidgid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
          "lines": "617-663",
          "snippet": "static void lxc_attach_get_init_uidgid(uid_t* init_uid, gid_t* init_gid)\n{\n\tFILE *proc_file;\n\tchar proc_fn[__PROC_STATUS_LEN];\n\tint ret;\n\tchar *line = NULL;\n\tsize_t line_bufsz = 0;\n\tlong value = -1;\n\tuid_t uid = (uid_t)-1;\n\tgid_t gid = (gid_t)-1;\n\n\t/* Read capabilities. */\n\tsnprintf(proc_fn, __PROC_STATUS_LEN, \"/proc/%d/status\", 1);\n\n\tproc_file = fopen(proc_fn, \"r\");\n\tif (!proc_file)\n\t\treturn;\n\n\twhile (getline(&line, &line_bufsz, proc_file) != -1) {\n\t\t/* Format is: real, effective, saved set user, fs we only care\n\t\t * about real uid.\n\t\t */\n\t\tret = sscanf(line, \"Uid: %ld\", &value);\n\t\tif (ret != EOF && ret == 1) {\n\t\t\tuid = (uid_t) value;\n\t\t} else {\n\t\t\tret = sscanf(line, \"Gid: %ld\", &value);\n\t\t\tif (ret != EOF && ret == 1)\n\t\t\t\tgid = (gid_t) value;\n\t\t}\n\t\tif (uid != (uid_t)-1 && gid != (gid_t)-1)\n\t\t\tbreak;\n\t}\n\n\tfclose(proc_file);\n\tfree(line);\n\n\t/* Only override arguments if we found something. */\n\tif (uid != (uid_t)-1)\n\t\t*init_uid = uid;\n\tif (gid != (gid_t)-1)\n\t\t*init_gid = gid;\n\n\t/* TODO: we should also parse supplementary groups and use\n\t * setgroups() to set them.\n\t */\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include \"confile.h\"",
            "#include \"lsm/lsm.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"conf.h\"",
            "#include \"lxclock.h\"",
            "#include \"cgroup.h\"",
            "#include \"commands.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include \"caps.h\"",
            "#include \"attach.h\"",
            "#include \"af_unix.h\"",
            "#include \"log.h\"",
            "#include \"namespace.h\"",
            "#include <pwd.h>",
            "#include <linux/unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/mount.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [
            "#define __PROC_STATUS_LEN (5 + (LXC_NUMSTRLEN64) + 7 + 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include \"confile.h\"\n#include \"lsm/lsm.h\"\n#include <lxc/lxccontainer.h>\n#include \"lxcseccomp.h\"\n#include \"conf.h\"\n#include \"lxclock.h\"\n#include \"cgroup.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"caps.h\"\n#include \"attach.h\"\n#include \"af_unix.h\"\n#include \"log.h\"\n#include \"namespace.h\"\n#include <pwd.h>\n#include <linux/unistd.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\n#define __PROC_STATUS_LEN (5 + (LXC_NUMSTRLEN64) + 7 + 1)\n\nstatic void lxc_attach_get_init_uidgid(uid_t* init_uid, gid_t* init_gid)\n{\n\tFILE *proc_file;\n\tchar proc_fn[__PROC_STATUS_LEN];\n\tint ret;\n\tchar *line = NULL;\n\tsize_t line_bufsz = 0;\n\tlong value = -1;\n\tuid_t uid = (uid_t)-1;\n\tgid_t gid = (gid_t)-1;\n\n\t/* Read capabilities. */\n\tsnprintf(proc_fn, __PROC_STATUS_LEN, \"/proc/%d/status\", 1);\n\n\tproc_file = fopen(proc_fn, \"r\");\n\tif (!proc_file)\n\t\treturn;\n\n\twhile (getline(&line, &line_bufsz, proc_file) != -1) {\n\t\t/* Format is: real, effective, saved set user, fs we only care\n\t\t * about real uid.\n\t\t */\n\t\tret = sscanf(line, \"Uid: %ld\", &value);\n\t\tif (ret != EOF && ret == 1) {\n\t\t\tuid = (uid_t) value;\n\t\t} else {\n\t\t\tret = sscanf(line, \"Gid: %ld\", &value);\n\t\t\tif (ret != EOF && ret == 1)\n\t\t\t\tgid = (gid_t) value;\n\t\t}\n\t\tif (uid != (uid_t)-1 && gid != (gid_t)-1)\n\t\t\tbreak;\n\t}\n\n\tfclose(proc_file);\n\tfree(line);\n\n\t/* Only override arguments if we found something. */\n\tif (uid != (uid_t)-1)\n\t\t*init_uid = uid;\n\tif (gid != (gid_t)-1)\n\t\t*init_gid = gid;\n\n\t/* TODO: we should also parse supplementary groups and use\n\t * setgroups() to set them.\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rexit",
          "args": [
            "-1"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Could not set initial environment for attached process.\""
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_attach_set_environment",
          "args": [
            "options->env_policy",
            "options->extra_env_vars",
            "options->extra_keep_env"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_attach_set_environment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
          "lines": "372-467",
          "snippet": "static int lxc_attach_set_environment(enum lxc_attach_env_policy_t policy, char** extra_env, char** extra_keep)\n{\n\tif (policy == LXC_ATTACH_CLEAR_ENV) {\n\t\tchar **extra_keep_store = NULL;\n\t\tint path_kept = 0;\n\n\t\tif (extra_keep) {\n\t\t\tsize_t count, i;\n\n\t\t\tfor (count = 0; extra_keep[count]; count++);\n\n\t\t\textra_keep_store = calloc(count, sizeof(char *));\n\t\t\tif (!extra_keep_store) {\n\t\t\t\tSYSERROR(\"Failed to allocate memory for storing current \"\n\t\t\t\t         \"environment variable values that will be kept.\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tchar *v = getenv(extra_keep[i]);\n\t\t\t\tif (v) {\n\t\t\t\t\textra_keep_store[i] = strdup(v);\n\t\t\t\t\tif (!extra_keep_store[i]) {\n\t\t\t\t\t\tSYSERROR(\"Failed to allocate memory for storing current \"\n\t\t\t\t\t\t         \"environment variable values that will be kept.\");\n\t\t\t\t\t\twhile (i > 0)\n\t\t\t\t\t\t\tfree(extra_keep_store[--i]);\n\t\t\t\t\t\tfree(extra_keep_store);\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (strcmp(extra_keep[i], \"PATH\") == 0)\n\t\t\t\t\t\tpath_kept = 1;\n\t\t\t\t}\n\t\t\t\t/* Calloc sets entire array to zero, so we don't\n\t\t\t\t * need an else.\n\t\t\t\t */\n\t\t\t}\n\t\t}\n\n\t\tif (clearenv()) {\n\t\t\tchar **p;\n\t\t\tSYSERROR(\"Failed to clear environment.\");\n\t\t\tif (extra_keep_store) {\n\t\t\t\tfor (p = extra_keep_store; *p; p++)\n\t\t\t\t\tfree(*p);\n\t\t\t\tfree(extra_keep_store);\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (extra_keep_store) {\n\t\t\tsize_t i;\n\t\t\tfor (i = 0; extra_keep[i]; i++) {\n\t\t\t\tif (extra_keep_store[i]) {\n\t\t\t\t\tif (setenv(extra_keep[i], extra_keep_store[i], 1) < 0)\n\t\t\t\t\t\tSYSERROR(\"Unable to set environment variable.\");\n\t\t\t\t}\n\t\t\t\tfree(extra_keep_store[i]);\n\t\t\t}\n\t\t\tfree(extra_keep_store);\n\t\t}\n\n\t\t/* Always set a default path; shells and execlp tend to be fine\n\t\t * without it, but there is a disturbing number of C programs\n\t\t * out there that just assume that getenv(\"PATH\") is never NULL\n\t\t * and then die a painful segfault death.\n\t\t */\n\t\tif (!path_kept)\n\t\t\tsetenv(\"PATH\", \"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", 1);\n\t}\n\n\tif (putenv(\"container=lxc\")) {\n\t\tSYSERROR(\"Failed to set environment variable.\");\n\t\treturn -1;\n\t}\n\n\t/* Set extra environment variables. */\n\tif (extra_env) {\n\t\tfor (; *extra_env; extra_env++) {\n\t\t\t/* Duplicate the string, just to be on the safe side,\n\t\t\t * because putenv does not do it for us.\n\t\t\t */\n\t\t\tchar *p = strdup(*extra_env);\n\t\t\t/* We just assume the user knows what they are doing, so\n\t\t\t * we don't do any checks.\n\t\t\t */\n\t\t\tif (!p) {\n\t\t\t\tSYSERROR(\"Failed to allocate memory for additional environment \"\n\t\t\t\t         \"variables.\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tputenv(p);\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include \"confile.h\"",
            "#include \"lsm/lsm.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"conf.h\"",
            "#include \"lxclock.h\"",
            "#include \"cgroup.h\"",
            "#include \"commands.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include \"caps.h\"",
            "#include \"attach.h\"",
            "#include \"af_unix.h\"",
            "#include \"log.h\"",
            "#include \"namespace.h\"",
            "#include <pwd.h>",
            "#include <linux/unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/mount.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include \"confile.h\"\n#include \"lsm/lsm.h\"\n#include <lxc/lxccontainer.h>\n#include \"lxcseccomp.h\"\n#include \"conf.h\"\n#include \"lxclock.h\"\n#include \"cgroup.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"caps.h\"\n#include \"attach.h\"\n#include \"af_unix.h\"\n#include \"log.h\"\n#include \"namespace.h\"\n#include <pwd.h>\n#include <linux/unistd.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\nstatic int lxc_attach_set_environment(enum lxc_attach_env_policy_t policy, char** extra_env, char** extra_keep)\n{\n\tif (policy == LXC_ATTACH_CLEAR_ENV) {\n\t\tchar **extra_keep_store = NULL;\n\t\tint path_kept = 0;\n\n\t\tif (extra_keep) {\n\t\t\tsize_t count, i;\n\n\t\t\tfor (count = 0; extra_keep[count]; count++);\n\n\t\t\textra_keep_store = calloc(count, sizeof(char *));\n\t\t\tif (!extra_keep_store) {\n\t\t\t\tSYSERROR(\"Failed to allocate memory for storing current \"\n\t\t\t\t         \"environment variable values that will be kept.\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tchar *v = getenv(extra_keep[i]);\n\t\t\t\tif (v) {\n\t\t\t\t\textra_keep_store[i] = strdup(v);\n\t\t\t\t\tif (!extra_keep_store[i]) {\n\t\t\t\t\t\tSYSERROR(\"Failed to allocate memory for storing current \"\n\t\t\t\t\t\t         \"environment variable values that will be kept.\");\n\t\t\t\t\t\twhile (i > 0)\n\t\t\t\t\t\t\tfree(extra_keep_store[--i]);\n\t\t\t\t\t\tfree(extra_keep_store);\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (strcmp(extra_keep[i], \"PATH\") == 0)\n\t\t\t\t\t\tpath_kept = 1;\n\t\t\t\t}\n\t\t\t\t/* Calloc sets entire array to zero, so we don't\n\t\t\t\t * need an else.\n\t\t\t\t */\n\t\t\t}\n\t\t}\n\n\t\tif (clearenv()) {\n\t\t\tchar **p;\n\t\t\tSYSERROR(\"Failed to clear environment.\");\n\t\t\tif (extra_keep_store) {\n\t\t\t\tfor (p = extra_keep_store; *p; p++)\n\t\t\t\t\tfree(*p);\n\t\t\t\tfree(extra_keep_store);\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (extra_keep_store) {\n\t\t\tsize_t i;\n\t\t\tfor (i = 0; extra_keep[i]; i++) {\n\t\t\t\tif (extra_keep_store[i]) {\n\t\t\t\t\tif (setenv(extra_keep[i], extra_keep_store[i], 1) < 0)\n\t\t\t\t\t\tSYSERROR(\"Unable to set environment variable.\");\n\t\t\t\t}\n\t\t\t\tfree(extra_keep_store[i]);\n\t\t\t}\n\t\t\tfree(extra_keep_store);\n\t\t}\n\n\t\t/* Always set a default path; shells and execlp tend to be fine\n\t\t * without it, but there is a disturbing number of C programs\n\t\t * out there that just assume that getenv(\"PATH\") is never NULL\n\t\t * and then die a painful segfault death.\n\t\t */\n\t\tif (!path_kept)\n\t\t\tsetenv(\"PATH\", \"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", 1);\n\t}\n\n\tif (putenv(\"container=lxc\")) {\n\t\tSYSERROR(\"Failed to set environment variable.\");\n\t\treturn -1;\n\t}\n\n\t/* Set extra environment variables. */\n\tif (extra_env) {\n\t\tfor (; *extra_env; extra_env++) {\n\t\t\t/* Duplicate the string, just to be on the safe side,\n\t\t\t * because putenv does not do it for us.\n\t\t\t */\n\t\t\tchar *p = strdup(*extra_env);\n\t\t\t/* We just assume the user knows what they are doing, so\n\t\t\t * we don't do any checks.\n\t\t\t */\n\t\t\tif (!p) {\n\t\t\t\tSYSERROR(\"Failed to allocate memory for additional environment \"\n\t\t\t\t         \"variables.\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tputenv(p);\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rexit",
          "args": [
            "-1"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Could not drop privileges.\""
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_attach_drop_privs",
          "args": [
            "init_ctx"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_attach_drop_privs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
          "lines": "354-370",
          "snippet": "static int lxc_attach_drop_privs(struct lxc_proc_context_info *ctx)\n{\n\tint last_cap = lxc_caps_last_cap();\n\tint cap;\n\n\tfor (cap = 0; cap <= last_cap; cap++) {\n\t\tif (ctx->capability_mask & (1LL << cap))\n\t\t\tcontinue;\n\n\t\tif (prctl(PR_CAPBSET_DROP, cap, 0, 0, 0)) {\n\t\t\tSYSERROR(\"Failed to remove capability id %d.\", cap);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include \"confile.h\"",
            "#include \"lsm/lsm.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"conf.h\"",
            "#include \"lxclock.h\"",
            "#include \"cgroup.h\"",
            "#include \"commands.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include \"caps.h\"",
            "#include \"attach.h\"",
            "#include \"af_unix.h\"",
            "#include \"log.h\"",
            "#include \"namespace.h\"",
            "#include <pwd.h>",
            "#include <linux/unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/mount.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [
            "#define PR_CAPBSET_DROP 24"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include \"confile.h\"\n#include \"lsm/lsm.h\"\n#include <lxc/lxccontainer.h>\n#include \"lxcseccomp.h\"\n#include \"conf.h\"\n#include \"lxclock.h\"\n#include \"cgroup.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"caps.h\"\n#include \"attach.h\"\n#include \"af_unix.h\"\n#include \"log.h\"\n#include \"namespace.h\"\n#include <pwd.h>\n#include <linux/unistd.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\n#define PR_CAPBSET_DROP 24\n\nstatic int lxc_attach_drop_privs(struct lxc_proc_context_info *ctx)\n{\n\tint last_cap = lxc_caps_last_cap();\n\tint cap;\n\n\tfor (cap = 0; cap <= last_cap; cap++) {\n\t\tif (ctx->capability_mask & (1LL << cap))\n\t\t\tcontinue;\n\n\t\tif (prctl(PR_CAPBSET_DROP, cap, 0, 0, 0)) {\n\t\t\tSYSERROR(\"Failed to remove capability id %d.\", cap);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rexit",
          "args": [
            "-1"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Could not ensure correct architecture.\""
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "personality",
          "args": [
            "new_personality"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "setup_personality",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1440-1455",
          "snippet": "static int setup_personality(int persona)\n{\n\t#if HAVE_SYS_PERSONALITY_H\n\tif (persona == -1)\n\t\treturn 0;\n\n\tif (personality(persona) < 0) {\n\t\tSYSERROR(\"failed to set personality to '0x%x'\", persona);\n\t\treturn -1;\n\t}\n\n\tINFO(\"set personality to '0x%x'\", persona);\n\t#endif\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int setup_personality(int persona)\n{\n\t#if HAVE_SYS_PERSONALITY_H\n\tif (persona == -1)\n\t\treturn 0;\n\n\tif (personality(persona) < 0) {\n\t\tSYSERROR(\"failed to set personality to '0x%x'\", persona);\n\t\treturn -1;\n\t}\n\n\tINFO(\"set personality to '0x%x'\", persona);\n\t#endif\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rexit",
          "args": [
            "-1"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_attach_remount_sys_proc",
          "args": [],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_attach_remount_sys_proc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
          "lines": "305-352",
          "snippet": "static int lxc_attach_remount_sys_proc(void)\n{\n\tint ret;\n\n\tret = unshare(CLONE_NEWNS);\n\tif (ret < 0) {\n\t\tSYSERROR(\"Failed to unshare mount namespace.\");\n\t\treturn -1;\n\t}\n\n\tif (detect_shared_rootfs()) {\n\t\tif (mount(NULL, \"/\", NULL, MS_SLAVE|MS_REC, NULL)) {\n\t\t\tSYSERROR(\"Failed to make / rslave.\");\n\t\t\tERROR(\"Continuing...\");\n\t\t}\n\t}\n\n\t/* Assume /proc is always mounted, so remount it. */\n\tret = umount2(\"/proc\", MNT_DETACH);\n\tif (ret < 0) {\n\t\tSYSERROR(\"Failed to unmount /proc.\");\n\t\treturn -1;\n\t}\n\n\tret = mount(\"none\", \"/proc\", \"proc\", 0, NULL);\n\tif (ret < 0) {\n\t\tSYSERROR(\"Failed to remount /proc.\");\n\t\treturn -1;\n\t}\n\n\t/* Try to umount /sys. If it's not a mount point, we'll get EINVAL, then\n\t * we ignore it because it may not have been mounted in the first place.\n\t */\n\tret = umount2(\"/sys\", MNT_DETACH);\n\tif (ret < 0 && errno != EINVAL) {\n\t\tSYSERROR(\"Failed to unmount /sys.\");\n\t\treturn -1;\n\t} else if (ret == 0) {\n\t\t/* Remount it. */\n\t\tret = mount(\"none\", \"/sys\", \"sysfs\", 0, NULL);\n\t\tif (ret < 0) {\n\t\t\tSYSERROR(\"Failed to remount /sys.\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include \"confile.h\"",
            "#include \"lsm/lsm.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"conf.h\"",
            "#include \"lxclock.h\"",
            "#include \"cgroup.h\"",
            "#include \"commands.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include \"caps.h\"",
            "#include \"attach.h\"",
            "#include \"af_unix.h\"",
            "#include \"log.h\"",
            "#include \"namespace.h\"",
            "#include <pwd.h>",
            "#include <linux/unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/mount.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [
            "#define MS_SLAVE (1<<19)",
            "#define MS_REC 16384"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include \"confile.h\"\n#include \"lsm/lsm.h\"\n#include <lxc/lxccontainer.h>\n#include \"lxcseccomp.h\"\n#include \"conf.h\"\n#include \"lxclock.h\"\n#include \"cgroup.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"caps.h\"\n#include \"attach.h\"\n#include \"af_unix.h\"\n#include \"log.h\"\n#include \"namespace.h\"\n#include <pwd.h>\n#include <linux/unistd.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\n#define MS_SLAVE (1<<19)\n#define MS_REC 16384\n\nstatic int lxc_attach_remount_sys_proc(void)\n{\n\tint ret;\n\n\tret = unshare(CLONE_NEWNS);\n\tif (ret < 0) {\n\t\tSYSERROR(\"Failed to unshare mount namespace.\");\n\t\treturn -1;\n\t}\n\n\tif (detect_shared_rootfs()) {\n\t\tif (mount(NULL, \"/\", NULL, MS_SLAVE|MS_REC, NULL)) {\n\t\t\tSYSERROR(\"Failed to make / rslave.\");\n\t\t\tERROR(\"Continuing...\");\n\t\t}\n\t}\n\n\t/* Assume /proc is always mounted, so remount it. */\n\tret = umount2(\"/proc\", MNT_DETACH);\n\tif (ret < 0) {\n\t\tSYSERROR(\"Failed to unmount /proc.\");\n\t\treturn -1;\n\t}\n\n\tret = mount(\"none\", \"/proc\", \"proc\", 0, NULL);\n\tif (ret < 0) {\n\t\tSYSERROR(\"Failed to remount /proc.\");\n\t\treturn -1;\n\t}\n\n\t/* Try to umount /sys. If it's not a mount point, we'll get EINVAL, then\n\t * we ignore it because it may not have been mounted in the first place.\n\t */\n\tret = umount2(\"/sys\", MNT_DETACH);\n\tif (ret < 0 && errno != EINVAL) {\n\t\tSYSERROR(\"Failed to unmount /sys.\");\n\t\treturn -1;\n\t} else if (ret == 0) {\n\t\t/* Remount it. */\n\t\tret = mount(\"none\", \"/sys\", \"sysfs\", 0, NULL);\n\t\tif (ret < 0) {\n\t\t\tSYSERROR(\"Failed to remount /sys.\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rexit",
          "args": [
            "-1"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Expected to receive sequence number 0: %s.\"",
            "strerror(errno)"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/personality.h>\n#include \"confile.h\"\n#include \"lsm/lsm.h\"\n#include <lxc/lxccontainer.h>\n#include \"lxcseccomp.h\"\n#include \"conf.h\"\n#include \"lxclock.h\"\n#include \"cgroup.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"caps.h\"\n#include \"attach.h\"\n#include \"af_unix.h\"\n#include \"log.h\"\n#include \"namespace.h\"\n#include <pwd.h>\n#include <linux/unistd.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\n#define PR_SET_NO_NEW_PRIVS 38\n\nstatic int attach_child_main(void* data);\n\nstatic int attach_child_main(void* data)\n{\n\tstruct attach_clone_payload* payload = (struct attach_clone_payload*)data;\n\tint ipc_socket = payload->ipc_socket;\n\tlxc_attach_options_t* options = payload->options;\n\tstruct lxc_proc_context_info* init_ctx = payload->init_ctx;\n#if HAVE_SYS_PERSONALITY_H\n\tlong new_personality;\n#endif\n\tint ret;\n\tint status;\n\tint expected;\n\tlong flags;\n\tint fd;\n\tint lsm_labelfd;\n\tuid_t new_uid;\n\tgid_t new_gid;\n\n\t/* Wait for the initial thread to signal us that it's ready for us to\n\t * start initializing.\n\t */\n\texpected = 0;\n\tstatus = -1;\n\tret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);\n\tif (ret <= 0) {\n\t\tERROR(\"Expected to receive sequence number 0: %s.\", strerror(errno));\n\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\t/* A description of the purpose of this functionality is provided in the\n\t * lxc-attach(1) manual page. We have to remount here and not in the\n\t * parent process, otherwise /proc may not properly reflect the new pid\n\t * namespace.\n\t */\n\tif (!(options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_REMOUNT_PROC_SYS)) {\n\t\tret = lxc_attach_remount_sys_proc();\n\t\tif (ret < 0) {\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\trexit(-1);\n\t\t}\n\t}\n\n\t/* Now perform additional attachments. */\n#if HAVE_SYS_PERSONALITY_H\n\tif (options->personality < 0)\n\t\tnew_personality = init_ctx->personality;\n\telse\n\t\tnew_personality = options->personality;\n\n\tif (options->attach_flags & LXC_ATTACH_SET_PERSONALITY) {\n\t\tret = personality(new_personality);\n\t\tif (ret < 0) {\n\t\t\tSYSERROR(\"Could not ensure correct architecture.\");\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\trexit(-1);\n\t\t}\n\t}\n#endif\n\n\tif (options->attach_flags & LXC_ATTACH_DROP_CAPABILITIES) {\n\t\tret = lxc_attach_drop_privs(init_ctx);\n\t\tif (ret < 0) {\n\t\t\tERROR(\"Could not drop privileges.\");\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\trexit(-1);\n\t\t}\n\t}\n\n\t/* Always set the environment (specify (LXC_ATTACH_KEEP_ENV, NULL, NULL)\n\t * if you want this to be a no-op).\n\t */\n\tret = lxc_attach_set_environment(options->env_policy, options->extra_env_vars, options->extra_keep_env);\n\tif (ret < 0) {\n\t\tERROR(\"Could not set initial environment for attached process.\");\n\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\t/* Set {u,g}id. */\n\tnew_uid = 0;\n\tnew_gid = 0;\n\t/* Ignore errors, we will fall back to root in that case (/proc was not\n\t * mounted etc.).\n\t */\n\tif (options->namespaces & CLONE_NEWUSER)\n\t\tlxc_attach_get_init_uidgid(&new_uid, &new_gid);\n\n\tif (options->uid != (uid_t)-1)\n\t\tnew_uid = options->uid;\n\tif (options->gid != (gid_t)-1)\n\t\tnew_gid = options->gid;\n\n\t/* Setup the controlling tty. */\n\tif (options->stdin_fd && isatty(options->stdin_fd)) {\n\t\tif (setsid() < 0) {\n\t\t\tSYSERROR(\"Unable to setsid.\");\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\trexit(-1);\n\t\t}\n\n\t\tif (ioctl(options->stdin_fd, TIOCSCTTY, (char *)NULL) < 0) {\n\t\t\tSYSERROR(\"Unable to set TIOCSTTY.\");\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\trexit(-1);\n\t\t}\n\t}\n\n\t/* Try to set the {u,g}id combination. */\n\tif ((new_gid != 0 || options->namespaces & CLONE_NEWUSER)) {\n\t\tif (setgid(new_gid) || setgroups(0, NULL)) {\n\t\t\tSYSERROR(\"Switching to container gid.\");\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\trexit(-1);\n\t\t}\n\t}\n\tif ((new_uid != 0 || options->namespaces & CLONE_NEWUSER) && setuid(new_uid)) {\n\t\tSYSERROR(\"Switching to container uid.\");\n\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\t/* Tell initial process it may now put us into cgroups. */\n\tstatus = 1;\n\tret = lxc_write_nointr(ipc_socket, &status, sizeof(status));\n\tif (ret != sizeof(status)) {\n\t\tERROR(\"Intended to send sequence number 1: %s.\", strerror(errno));\n\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\t/* Wait for the initial thread to signal us that it has done everything\n\t * for us when it comes to cgroups etc.\n\t */\n\texpected = 2;\n\tstatus = -1;\n\tret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);\n\tif (ret <= 0) {\n\t\tERROR(\"Expected to receive sequence number 2: %s\", strerror(errno));\n\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\tif ((init_ctx->container && init_ctx->container->lxc_conf &&\n\t     init_ctx->container->lxc_conf->no_new_privs) ||\n\t    (options->attach_flags & LXC_ATTACH_NO_NEW_PRIVS)) {\n\t\tif (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0) {\n\t\t\tSYSERROR(\"PR_SET_NO_NEW_PRIVS could not be set. \"\n\t\t\t\t \"Process can use execve() gainable \"\n\t\t\t\t \"privileges.\");\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\trexit(-1);\n\t\t}\n\t\tINFO(\"PR_SET_NO_NEW_PRIVS is set. Process cannot use execve() \"\n\t\t     \"gainable privileges.\");\n\t}\n\n\t/* Tell the (grand)parent to send us LSM label fd. */\n\tstatus = 3;\n\tret = lxc_write_nointr(ipc_socket, &status, sizeof(status));\n\tif (ret <= 0) {\n\t\tERROR(\"Intended to send sequence number 3: %s.\", strerror(errno));\n\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\tif ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {\n\t\tint on_exec;\n\t\t/* Receive fd for LSM security module. */\n\t\tret = lxc_abstract_unix_recv_fd(ipc_socket, &lsm_labelfd, NULL, 0);\n\t\tif (ret <= 0) {\n\t\t\tERROR(\"Expected to receive file descriptor: %s.\", strerror(errno));\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\trexit(-1);\n\t\t}\n\n\t\t/* Change into our new LSM profile. */\n\t\ton_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;\n\t\tif (lsm_set_label_at(lsm_labelfd, on_exec, init_ctx->lsm_label) < 0) {\n\t\t\tSYSERROR(\"Failed to set LSM label.\");\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\tclose(lsm_labelfd);\n\t\t\trexit(-1);\n\t\t}\n\t\tclose(lsm_labelfd);\n\t}\n\n\tif (init_ctx->container && init_ctx->container->lxc_conf &&\n\t    init_ctx->container->lxc_conf->seccomp &&\n\t    (lxc_seccomp_load(init_ctx->container->lxc_conf) != 0)) {\n\t\tERROR(\"Failed to load seccomp policy.\");\n\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\tshutdown(ipc_socket, SHUT_RDWR);\n\tclose(ipc_socket);\n\tlxc_proc_put_context_info(init_ctx);\n\n\t/* The following is done after the communication socket is shut down.\n\t * That way, all errors that might (though unlikely) occur up until this\n\t * point will have their messages printed to the original stderr (if\n\t * logging is so configured) and not the fd the user supplied, if any.\n\t */\n\n\t/* Fd handling for stdin, stdout and stderr; ignore errors here, user\n\t * may want to make sure the fds are closed, for example.\n\t */\n\tif (options->stdin_fd >= 0 && options->stdin_fd != 0)\n\t\tdup2(options->stdin_fd, 0);\n\tif (options->stdout_fd >= 0 && options->stdout_fd != 1)\n\t\tdup2(options->stdout_fd, 1);\n\tif (options->stderr_fd >= 0 && options->stderr_fd != 2)\n\t\tdup2(options->stderr_fd, 2);\n\n\t/* close the old fds */\n\tif (options->stdin_fd > 2)\n\t\tclose(options->stdin_fd);\n\tif (options->stdout_fd > 2)\n\t\tclose(options->stdout_fd);\n\tif (options->stderr_fd > 2)\n\t\tclose(options->stderr_fd);\n\n\t/* Try to remove FD_CLOEXEC flag from stdin/stdout/stderr, but also\n\t * here, ignore errors.\n\t */\n\tfor (fd = 0; fd <= 2; fd++) {\n\t\tflags = fcntl(fd, F_GETFL);\n\t\tif (flags < 0)\n\t\t\tcontinue;\n\t\tif (flags & FD_CLOEXEC)\n\t\t\tif (fcntl(fd, F_SETFL, flags & ~FD_CLOEXEC) < 0)\n\t\t\t\tSYSERROR(\"Unable to clear FD_CLOEXEC from file descriptor.\");\n\t}\n\n\t/* We're done, so we can now do whatever the user intended us to do. */\n\trexit(payload->exec_function(payload->exec_payload));\n}"
  },
  {
    "function_name": "lxc_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
    "lines": "760-1100",
    "snippet": "int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_function, void* exec_payload, lxc_attach_options_t* options, pid_t* attached_process)\n{\n\tint ret, status;\n\tpid_t init_pid, pid, attached_pid, expected;\n\tstruct lxc_proc_context_info *init_ctx;\n\tchar* cwd;\n\tchar* new_cwd;\n\tint ipc_sockets[2];\n\tsigned long personality;\n\n\tif (!options)\n\t\toptions = &attach_static_default_options;\n\n\tinit_pid = lxc_cmd_get_init_pid(name, lxcpath);\n\tif (init_pid < 0) {\n\t\tERROR(\"Failed to get init pid.\");\n\t\treturn -1;\n\t}\n\n\tinit_ctx = lxc_proc_get_context_info(init_pid);\n\tif (!init_ctx) {\n\t\tERROR(\"Failed to get context of init process: %ld.\",\n\t\t      (long)init_pid);\n\t\treturn -1;\n\t}\n\n\tpersonality = get_personality(name, lxcpath);\n\tif (init_ctx->personality < 0) {\n\t\tERROR(\"Failed to get personality of the container.\");\n\t\tlxc_proc_put_context_info(init_ctx);\n\t\treturn -1;\n\t}\n\tinit_ctx->personality = personality;\n\n\tinit_ctx->container = lxc_container_new(name, lxcpath);\n\tif (!init_ctx->container)\n\t\treturn -1;\n\n\tif (!fetch_seccomp(init_ctx->container, options))\n\t\tWARN(\"Failed to get seccomp policy.\");\n\n\tif (!no_new_privs(init_ctx->container, options))\n\t\tWARN(\"Could not determine whether PR_SET_NO_NEW_PRIVS is set.\");\n\n\tcwd = getcwd(NULL, 0);\n\n\t/* Determine which namespaces the container was created with\n\t * by asking lxc-start, if necessary.\n\t */\n\tif (options->namespaces == -1) {\n\t\toptions->namespaces = lxc_cmd_get_clone_flags(name, lxcpath);\n\t\t/* call failed */\n\t\tif (options->namespaces == -1) {\n\t\t\tERROR(\"Failed to automatically determine the \"\n\t\t\t      \"namespaces which the container uses.\");\n\t\t\tfree(cwd);\n\t\t\tlxc_proc_put_context_info(init_ctx);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Create a socket pair for IPC communication; set SOCK_CLOEXEC in order\n\t * to make sure we don't irritate other threads that want to fork+exec\n\t * away\n\t *\n\t * IMPORTANT: if the initial process is multithreaded and another call\n\t * just fork()s away without exec'ing directly after, the socket fd will\n\t * exist in the forked process from the other thread and any close() in\n\t * our own child process will not really cause the socket to close\n\t * properly, potentiall causing the parent to hang.\n\t *\n\t * For this reason, while IPC is still active, we have to use shutdown()\n\t * if the child exits prematurely in order to signal that the socket is\n\t * closed and cannot assume that the child exiting will automatically do\n\t * that.\n\t *\n\t * IPC mechanism: (X is receiver)\n\t *   initial process        intermediate          attached\n\t *        X           <---  send pid of\n\t *                          attached proc,\n\t *                          then exit\n\t *    send 0 ------------------------------------>    X\n\t *                                              [do initialization]\n\t *        X  <------------------------------------  send 1\n\t *   [add to cgroup, ...]\n\t *    send 2 ------------------------------------>    X\n\t *\t\t\t\t\t\t[set LXC_ATTACH_NO_NEW_PRIVS]\n\t *        X  <------------------------------------  send 3\n\t *   [open LSM label fd]\n\t *    send 4 ------------------------------------>    X\n\t *   \t\t\t\t\t\t[set LSM label]\n\t *   close socket                                 close socket\n\t *                                                run program\n\t */\n\tret = socketpair(PF_LOCAL, SOCK_STREAM | SOCK_CLOEXEC, 0, ipc_sockets);\n\tif (ret < 0) {\n\t\tSYSERROR(\"Could not set up required IPC mechanism for attaching.\");\n\t\tfree(cwd);\n\t\tlxc_proc_put_context_info(init_ctx);\n\t\treturn -1;\n\t}\n\n\t/* Create intermediate subprocess, three reasons:\n\t *       1. Runs all pthread_atfork handlers and the child will no\n\t *          longer be threaded (we can't properly setns() in a threaded\n\t *          process).\n\t *       2. We can't setns() in the child itself, since we want to make\n\t *          sure we are properly attached to the pidns.\n\t *       3. Also, the initial thread has to put the attached process\n\t *          into the cgroup, which we can only do if we didn't already\n\t *          setns() (otherwise, user namespaces will hate us).\n\t */\n\tpid = fork();\n\n\tif (pid < 0) {\n\t\tSYSERROR(\"Failed to create first subprocess.\");\n\t\tfree(cwd);\n\t\tlxc_proc_put_context_info(init_ctx);\n\t\treturn -1;\n\t}\n\n\tif (pid) {\n\t\tint procfd = -1;\n\t\tpid_t to_cleanup_pid = pid;\n\n\t\t/* Initial thread, we close the socket that is for the\n\t\t * subprocesses.\n\t\t */\n\t\tclose(ipc_sockets[1]);\n\t\tfree(cwd);\n\n\t\t/* Attach to cgroup, if requested. */\n\t\tif (options->attach_flags & LXC_ATTACH_MOVE_TO_CGROUP) {\n\t\t\tif (!cgroup_attach(name, lxcpath, pid))\n\t\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Open /proc before setns() to the containers namespace so we\n\t\t * don't rely on any information from inside the container.\n\t\t */\n\t\tprocfd = open(\"/proc\", O_DIRECTORY | O_RDONLY | O_CLOEXEC);\n\t\tif (procfd < 0) {\n\t\t\tSYSERROR(\"Unable to open /proc.\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Let the child process know to go ahead. */\n\t\tstatus = 0;\n\t\tret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));\n\t\tif (ret <= 0) {\n\t\t\tERROR(\"Intended to send sequence number 0: %s.\",\n\t\t\t      strerror(errno));\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Get pid of attached process from intermediate process. */\n\t\tret = lxc_read_nointr_expect(ipc_sockets[0], &attached_pid, sizeof(attached_pid), NULL);\n\t\tif (ret <= 0) {\n\t\t\tif (ret != 0)\n\t\t\t\tERROR(\"Expected to receive pid: %s.\", strerror(errno));\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Ignore SIGKILL (CTRL-C) and SIGQUIT (CTRL-\\) - issue #313. */\n\t\tif (options->stdin_fd == 0) {\n\t\t\tsignal(SIGINT, SIG_IGN);\n\t\t\tsignal(SIGQUIT, SIG_IGN);\n\t\t}\n\n\t\t/* Reap intermediate process. */\n\t\tret = wait_for_pid(pid);\n\t\tif (ret < 0)\n\t\t\tgoto on_error;\n\n\t\t/* We will always have to reap the attached process now. */\n\t\tto_cleanup_pid = attached_pid;\n\n\t\t/* Tell attached process it may start initializing. */\n\t\tstatus = 0;\n\t\tret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));\n\t\tif (ret <= 0) {\n\t\t\tERROR(\"Intended to send sequence number 0: %s.\", strerror(errno));\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Wait for the attached process to finish initializing. */\n\t\texpected = 1;\n\t\tret = lxc_read_nointr_expect(ipc_sockets[0], &status, sizeof(status), &expected);\n\t\tif (ret <= 0) {\n\t\t\tif (ret != 0)\n\t\t\t\tERROR(\"Expected to receive sequence number 1: %s.\", strerror(errno));\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Tell attached process we're done. */\n\t\tstatus = 2;\n\t\tret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));\n\t\tif (ret <= 0) {\n\t\t\tERROR(\"Intended to send sequence number 2: %s.\", strerror(errno));\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Wait for the (grand)child to tell us that it's ready to set\n\t\t * up its LSM labels.\n\t\t */\n\t\texpected = 3;\n\t\tret = lxc_read_nointr_expect(ipc_sockets[0], &status, sizeof(status), &expected);\n\t\tif (ret <= 0) {\n\t\t\tERROR(\"Expected to receive sequence number 3: %s.\",\n\t\t\t      strerror(errno));\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Open LSM fd and send it to child. */\n\t\tif ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {\n\t\t\tint on_exec, saved_errno;\n\t\t\tint labelfd = -1;\n\t\t\ton_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;\n\t\t\t/* Open fd for the LSM security module. */\n\t\t\tlabelfd = lsm_openat(procfd, attached_pid, on_exec);\n\t\t\tif (labelfd < 0)\n\t\t\t\tgoto on_error;\n\n\t\t\t/* Send child fd of the LSM security module to write to. */\n\t\t\tret = lxc_abstract_unix_send_fd(ipc_sockets[0], labelfd, NULL, 0);\n\t\t\tsaved_errno = errno;\n\t\t\tclose(labelfd);\n\t\t\tif (ret <= 0) {\n\t\t\t\tERROR(\"Intended to send file descriptor %d: %s.\", labelfd, strerror(saved_errno));\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t}\n\n\t\tif (procfd >= 0)\n\t\t\tclose(procfd);\n\t\t/* Now shut down communication with child, we're done. */\n\t\tshutdown(ipc_sockets[0], SHUT_RDWR);\n\t\tclose(ipc_sockets[0]);\n\t\tlxc_proc_put_context_info(init_ctx);\n\n\t\t/* We're done, the child process should now execute whatever it\n\t\t * is that the user requested. The parent can now track it with\n\t\t * waitpid() or similar.\n\t\t */\n\n\t\t*attached_process = attached_pid;\n\t\treturn 0;\n\n\ton_error:\n\t\t/* First shut down the socket, then wait for the pid, otherwise\n\t\t * the pid we're waiting for may never exit.\n\t\t */\n\t\tif (procfd >= 0)\n\t\t\tclose(procfd);\n\t\tshutdown(ipc_sockets[0], SHUT_RDWR);\n\t\tclose(ipc_sockets[0]);\n\t\tif (to_cleanup_pid)\n\t\t\t(void) wait_for_pid(to_cleanup_pid);\n\t\tlxc_proc_put_context_info(init_ctx);\n\t\treturn -1;\n\t}\n\n\t/* First subprocess begins here, we close the socket that is for the\n\t * initial thread.\n\t */\n\tclose(ipc_sockets[0]);\n\n\t/* Wait for the parent to have setup cgroups. */\n\texpected = 0;\n\tstatus = -1;\n\tret = lxc_read_nointr_expect(ipc_sockets[1], &status, sizeof(status), &expected);\n\tif (ret <= 0) {\n\t\tERROR(\"Expected to receive sequence number 0: %s.\", strerror(errno));\n\t\tshutdown(ipc_sockets[1], SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\tif ((options->attach_flags & LXC_ATTACH_MOVE_TO_CGROUP) && cgns_supported())\n\t\toptions->namespaces |= CLONE_NEWCGROUP;\n\n\t/* Attach now, create another subprocess later, since pid namespaces\n\t * only really affect the children of the current process.\n\t */\n\tret = lxc_attach_to_ns(init_pid, options->namespaces);\n\tif (ret < 0) {\n\t\tERROR(\"Failed to enter namespaces.\");\n\t\tshutdown(ipc_sockets[1], SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\t/* Attach succeeded, try to cwd. */\n\tif (options->initial_cwd)\n\t\tnew_cwd = options->initial_cwd;\n\telse\n\t\tnew_cwd = cwd;\n\tret = chdir(new_cwd);\n\tif (ret < 0)\n\t\tWARN(\"Could not change directory to \\\"%s\\\".\", new_cwd);\n\tfree(cwd);\n\n\t/* Now create the real child process. */\n\t{\n\t\tstruct attach_clone_payload payload = {\n\t\t\t.ipc_socket = ipc_sockets[1],\n\t\t\t.options = options,\n\t\t\t.init_ctx = init_ctx,\n\t\t\t.exec_function = exec_function,\n\t\t\t.exec_payload = exec_payload,\n\t\t};\n\t\t/* We use clone_parent here to make this subprocess a direct\n\t\t * child of the initial process. Then this intermediate process\n\t\t * can exit and the parent can directly track the attached\n\t\t * process.\n\t\t */\n\t\tpid = lxc_clone(attach_child_main, &payload, CLONE_PARENT);\n\t}\n\n\t/* Shouldn't happen, clone() should always return positive pid. */\n\tif (pid <= 0) {\n\t\tSYSERROR(\"Failed to create subprocess.\");\n\t\tshutdown(ipc_sockets[1], SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\t/* Tell grandparent the pid of the pid of the newly created child. */\n\tret = lxc_write_nointr(ipc_sockets[1], &pid, sizeof(pid));\n\tif (ret != sizeof(pid)) {\n\t\t/* If this really happens here, this is very unfortunate, since\n\t\t * the parent will not know the pid of the attached process and\n\t\t * will not be able to wait for it (and we won't either due to\n\t\t * CLONE_PARENT) so the parent won't be able to reap it and the\n\t\t * attached process will remain a zombie.\n\t\t */\n\t\tERROR(\"Intended to send pid %d: %s.\", pid, strerror(errno));\n\t\tshutdown(ipc_sockets[1], SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\t/* The rest is in the hands of the initial and the attached process. */\n\trexit(0);\n}",
    "includes": [
      "#include <sys/personality.h>",
      "#include \"confile.h\"",
      "#include \"lsm/lsm.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include \"lxcseccomp.h\"",
      "#include \"conf.h\"",
      "#include \"lxclock.h\"",
      "#include \"cgroup.h\"",
      "#include \"commands.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include \"caps.h\"",
      "#include \"attach.h\"",
      "#include \"af_unix.h\"",
      "#include \"log.h\"",
      "#include \"namespace.h\"",
      "#include <pwd.h>",
      "#include <linux/unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/mount.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [
      "#define PR_SET_NO_NEW_PRIVS 38"
    ],
    "globals_used": [
      "static lxc_attach_options_t attach_static_default_options = LXC_ATTACH_OPTIONS_DEFAULT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rexit",
          "args": [
            "0"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rexit",
          "args": [
            "-1"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shutdown",
          "args": [
            "ipc_sockets[1]",
            "SHUT_RDWR"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "do_lxcapi_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "1602-1631",
          "snippet": "static bool do_lxcapi_shutdown(struct lxc_container *c, int timeout)\n{\n\tbool retv;\n\tpid_t pid;\n\tint haltsignal = SIGPWR;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (!do_lxcapi_is_running(c))\n\t\treturn true;\n\tpid = do_lxcapi_init_pid(c);\n\tif (pid <= 0)\n\t\treturn true;\n\n\t/* Detect whether we should send SIGRTMIN + 3 (e.g. systemd). */\n\tif (task_blocking_signal(pid, (SIGRTMIN + 3)))\n\t\thaltsignal = (SIGRTMIN + 3);\n\n\tif (c->lxc_conf && c->lxc_conf->haltsignal)\n\t\thaltsignal = c->lxc_conf->haltsignal;\n\n\tINFO(\"Using signal number '%d' as halt signal.\", haltsignal);\n\n\tif (kill(pid, haltsignal) < 0)\n\t\tWARN(\"Could not send signal %d to pid %d.\", haltsignal, pid);\n\n\tretv = do_lxcapi_wait(c, \"STOPPED\", timeout);\n\treturn retv;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_shutdown(struct lxc_container *c, int timeout)\n{\n\tbool retv;\n\tpid_t pid;\n\tint haltsignal = SIGPWR;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (!do_lxcapi_is_running(c))\n\t\treturn true;\n\tpid = do_lxcapi_init_pid(c);\n\tif (pid <= 0)\n\t\treturn true;\n\n\t/* Detect whether we should send SIGRTMIN + 3 (e.g. systemd). */\n\tif (task_blocking_signal(pid, (SIGRTMIN + 3)))\n\t\thaltsignal = (SIGRTMIN + 3);\n\n\tif (c->lxc_conf && c->lxc_conf->haltsignal)\n\t\thaltsignal = c->lxc_conf->haltsignal;\n\n\tINFO(\"Using signal number '%d' as halt signal.\", haltsignal);\n\n\tif (kill(pid, haltsignal) < 0)\n\t\tWARN(\"Could not send signal %d to pid %d.\", haltsignal, pid);\n\n\tretv = do_lxcapi_wait(c, \"STOPPED\", timeout);\n\treturn retv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Intended to send pid %d: %s.\"",
            "pid",
            "strerror(errno)"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_write_nointr",
          "args": [
            "ipc_sockets[1]",
            "&pid",
            "sizeof(pid)"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_nointr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "327-335",
          "snippet": "ssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rexit",
          "args": [
            "-1"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to create subprocess.\""
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_clone",
          "args": [
            "attach_child_main",
            "&payload",
            "CLONE_PARENT"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_clone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/namespace.c",
          "lines": "49-70",
          "snippet": "pid_t lxc_clone(int (*fn)(void *), void *arg, int flags)\n{\n\tstruct clone_arg clone_arg = {\n\t\t.fn = fn,\n\t\t.arg = arg,\n\t};\n\n\tsize_t stack_size = sysconf(_SC_PAGESIZE);\n\tvoid *stack = alloca(stack_size);\n\tpid_t ret;\n\n#ifdef __ia64__\n\tret = __clone2(do_clone, stack,\n\t\t       stack_size, flags | SIGCHLD, &clone_arg);\n#else\n\tret = clone(do_clone, stack  + stack_size, flags | SIGCHLD, &clone_arg);\n#endif\n\tif (ret < 0)\n\t\tERROR(\"Failed to clone (%#x): %s.\", flags, strerror(errno));\n\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"namespace.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <alloca.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"namespace.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <signal.h>\n#include <errno.h>\n#include <alloca.h>\n#include <unistd.h>\n\npid_t lxc_clone(int (*fn)(void *), void *arg, int flags)\n{\n\tstruct clone_arg clone_arg = {\n\t\t.fn = fn,\n\t\t.arg = arg,\n\t};\n\n\tsize_t stack_size = sysconf(_SC_PAGESIZE);\n\tvoid *stack = alloca(stack_size);\n\tpid_t ret;\n\n#ifdef __ia64__\n\tret = __clone2(do_clone, stack,\n\t\t       stack_size, flags | SIGCHLD, &clone_arg);\n#else\n\tret = clone(do_clone, stack  + stack_size, flags | SIGCHLD, &clone_arg);\n#endif\n\tif (ret < 0)\n\t\tERROR(\"Failed to clone (%#x): %s.\", flags, strerror(errno));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cwd"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Could not change directory to \\\"%s\\\".\"",
            "new_cwd"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "new_cwd"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rexit",
          "args": [
            "-1"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to enter namespaces.\""
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_attach_to_ns",
          "args": [
            "init_pid",
            "options->namespaces"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_attach_to_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
          "lines": "248-303",
          "snippet": "static int lxc_attach_to_ns(pid_t pid, int which)\n{\n\tint fd[LXC_NS_MAX];\n\tint i, j, saved_errno;\n\n\n\tif (access(\"/proc/self/ns\", X_OK)) {\n\t\tERROR(\"Does this kernel version support namespaces?\");\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\t/* Ignore if we are not supposed to attach to that namespace. */\n\t\tif (which != -1 && !(which & ns_info[i].clone_flag)) {\n\t\t\tfd[i] = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfd[i] = lxc_preserve_ns(pid, ns_info[i].proc_name);\n\t\tif (fd[i] < 0) {\n\t\t\tsaved_errno = errno;\n\n\t\t\t/* Close all already opened file descriptors before we\n\t\t\t * return an error, so we don't leak them.\n\t\t\t */\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tclose(fd[j]);\n\n\t\t\terrno = saved_errno;\n\t\t\tSYSERROR(\"Failed to open namespace: \\\"%s\\\".\", ns_info[i].proc_name);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (fd[i] < 0)\n\t\t\tcontinue;\n\n\t\tif (setns(fd[i], 0) < 0) {\n\t\t\tsaved_errno = errno;\n\n\t\t\tfor (j = i; j < LXC_NS_MAX; j++)\n\t\t\t\tclose(fd[j]);\n\n\t\t\terrno = saved_errno;\n\t\t\tSYSERROR(\"Failed to attach to namespace \\\"%s\\\".\", ns_info[i].proc_name);\n\t\t\treturn -1;\n\t\t}\n\n\t\tDEBUG(\"Attached to namespace \\\"%s\\\".\", ns_info[i].proc_name);\n\n\t\tclose(fd[i]);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include \"confile.h\"",
            "#include \"lsm/lsm.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"conf.h\"",
            "#include \"lxclock.h\"",
            "#include \"cgroup.h\"",
            "#include \"commands.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include \"caps.h\"",
            "#include \"attach.h\"",
            "#include \"af_unix.h\"",
            "#include \"log.h\"",
            "#include \"namespace.h\"",
            "#include <pwd.h>",
            "#include <linux/unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/mount.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include \"confile.h\"\n#include \"lsm/lsm.h\"\n#include <lxc/lxccontainer.h>\n#include \"lxcseccomp.h\"\n#include \"conf.h\"\n#include \"lxclock.h\"\n#include \"cgroup.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"caps.h\"\n#include \"attach.h\"\n#include \"af_unix.h\"\n#include \"log.h\"\n#include \"namespace.h\"\n#include <pwd.h>\n#include <linux/unistd.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\nstatic int lxc_attach_to_ns(pid_t pid, int which)\n{\n\tint fd[LXC_NS_MAX];\n\tint i, j, saved_errno;\n\n\n\tif (access(\"/proc/self/ns\", X_OK)) {\n\t\tERROR(\"Does this kernel version support namespaces?\");\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\t/* Ignore if we are not supposed to attach to that namespace. */\n\t\tif (which != -1 && !(which & ns_info[i].clone_flag)) {\n\t\t\tfd[i] = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfd[i] = lxc_preserve_ns(pid, ns_info[i].proc_name);\n\t\tif (fd[i] < 0) {\n\t\t\tsaved_errno = errno;\n\n\t\t\t/* Close all already opened file descriptors before we\n\t\t\t * return an error, so we don't leak them.\n\t\t\t */\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tclose(fd[j]);\n\n\t\t\terrno = saved_errno;\n\t\t\tSYSERROR(\"Failed to open namespace: \\\"%s\\\".\", ns_info[i].proc_name);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (fd[i] < 0)\n\t\t\tcontinue;\n\n\t\tif (setns(fd[i], 0) < 0) {\n\t\t\tsaved_errno = errno;\n\n\t\t\tfor (j = i; j < LXC_NS_MAX; j++)\n\t\t\t\tclose(fd[j]);\n\n\t\t\terrno = saved_errno;\n\t\t\tSYSERROR(\"Failed to attach to namespace \\\"%s\\\".\", ns_info[i].proc_name);\n\t\t\treturn -1;\n\t\t}\n\n\t\tDEBUG(\"Attached to namespace \\\"%s\\\".\", ns_info[i].proc_name);\n\n\t\tclose(fd[i]);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgns_supported",
          "args": [],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "cgns_supported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1247-1250",
          "snippet": "bool cgns_supported(void)\n{\n\treturn file_exists(\"/proc/self/ns/cgroup\");\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool cgns_supported(void)\n{\n\treturn file_exists(\"/proc/self/ns/cgroup\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "rexit",
          "args": [
            "-1"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Expected to receive sequence number 0: %s.\"",
            "strerror(errno)"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_read_nointr_expect",
          "args": [
            "ipc_sockets[1]",
            "&status",
            "sizeof(status)",
            "&expected"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_nointr_expect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "347-360",
          "snippet": "ssize_t lxc_read_nointr_expect(int fd, void* buf, size_t count, const void* expected_buf)\n{\n\tssize_t ret;\n\tret = lxc_read_nointr(fd, buf, count);\n\tif (ret <= 0)\n\t\treturn ret;\n\tif ((size_t)ret != count)\n\t\treturn -1;\n\tif (expected_buf && memcmp(buf, expected_buf, count) != 0) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_read_nointr_expect(int fd, void* buf, size_t count, const void* expected_buf)\n{\n\tssize_t ret;\n\tret = lxc_read_nointr(fd, buf, count);\n\tif (ret <= 0)\n\t\treturn ret;\n\tif ((size_t)ret != count)\n\t\treturn -1;\n\tif (expected_buf && memcmp(buf, expected_buf, count) != 0) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "ipc_sockets[0]"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_proc_put_context_info",
          "args": [
            "init_ctx"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_proc_put_context_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
          "lines": "240-246",
          "snippet": "static void lxc_proc_put_context_info(struct lxc_proc_context_info *ctx)\n{\n\tfree(ctx->lsm_label);\n\tif (ctx->container)\n\t\tlxc_container_put(ctx->container);\n\tfree(ctx);\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include \"confile.h\"",
            "#include \"lsm/lsm.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"conf.h\"",
            "#include \"lxclock.h\"",
            "#include \"cgroup.h\"",
            "#include \"commands.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include \"caps.h\"",
            "#include \"attach.h\"",
            "#include \"af_unix.h\"",
            "#include \"log.h\"",
            "#include \"namespace.h\"",
            "#include <pwd.h>",
            "#include <linux/unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/mount.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include \"confile.h\"\n#include \"lsm/lsm.h\"\n#include <lxc/lxccontainer.h>\n#include \"lxcseccomp.h\"\n#include \"conf.h\"\n#include \"lxclock.h\"\n#include \"cgroup.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"caps.h\"\n#include \"attach.h\"\n#include \"af_unix.h\"\n#include \"log.h\"\n#include \"namespace.h\"\n#include <pwd.h>\n#include <linux/unistd.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\nstatic void lxc_proc_put_context_info(struct lxc_proc_context_info *ctx)\n{\n\tfree(ctx->lsm_label);\n\tif (ctx->container)\n\t\tlxc_container_put(ctx->container);\n\tfree(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_pid",
          "args": [
            "to_cleanup_pid"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "311-325",
          "snippet": "int lxc_wait_for_pid_status(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\treturn status;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_wait_for_pid_status(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Intended to send file descriptor %d: %s.\"",
            "labelfd",
            "strerror(saved_errno)"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "saved_errno"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_abstract_unix_send_fd",
          "args": [
            "ipc_sockets[0]",
            "labelfd",
            "NULL",
            "0"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_send_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "134-162",
          "snippet": "int lxc_abstract_unix_send_fd(int fd, int sendfd, void *data, size_t size)\n{\n\tstruct msghdr msg = { 0 };\n\tstruct iovec iov;\n\tstruct cmsghdr *cmsg;\n\tchar cmsgbuf[CMSG_SPACE(sizeof(int))];\n\tchar buf[1];\n\tint *val;\n\n\tmsg.msg_control = cmsgbuf;\n\tmsg.msg_controllen = sizeof(cmsgbuf);\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(int));\n\tcmsg->cmsg_level = SOL_SOCKET;\n\tcmsg->cmsg_type = SCM_RIGHTS;\n\tval = (int *)(CMSG_DATA(cmsg));\n\t*val = sendfd;\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_namelen = 0;\n\n\tiov.iov_base = data ? data : buf;\n\tiov.iov_len = data ? size : sizeof(buf);\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\treturn sendmsg(fd, &msg, MSG_NOSIGNAL);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_send_fd(int fd, int sendfd, void *data, size_t size)\n{\n\tstruct msghdr msg = { 0 };\n\tstruct iovec iov;\n\tstruct cmsghdr *cmsg;\n\tchar cmsgbuf[CMSG_SPACE(sizeof(int))];\n\tchar buf[1];\n\tint *val;\n\n\tmsg.msg_control = cmsgbuf;\n\tmsg.msg_controllen = sizeof(cmsgbuf);\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(int));\n\tcmsg->cmsg_level = SOL_SOCKET;\n\tcmsg->cmsg_type = SCM_RIGHTS;\n\tval = (int *)(CMSG_DATA(cmsg));\n\t*val = sendfd;\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_namelen = 0;\n\n\tiov.iov_base = data ? data : buf;\n\tiov.iov_len = data ? size : sizeof(buf);\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\treturn sendmsg(fd, &msg, MSG_NOSIGNAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lsm_openat",
          "args": [
            "procfd",
            "attached_pid",
            "on_exec"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "lsm_openat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
          "lines": "90-123",
          "snippet": "static int lsm_openat(int procfd, pid_t pid, int on_exec)\n{\n\tint ret = -1;\n\tint labelfd = -1;\n\tconst char *name;\n\tchar path[__LSMATTRLEN];\n\n\tname = lsm_name();\n\n\tif (strcmp(name, \"nop\") == 0)\n\t\treturn 0;\n\n\tif (strcmp(name, \"none\") == 0)\n\t\treturn 0;\n\n\t/* We don't support on-exec with AppArmor */\n\tif (strcmp(name, \"AppArmor\") == 0)\n\t\ton_exec = 0;\n\n\tif (on_exec)\n\t\tret = snprintf(path, __LSMATTRLEN, \"%d/attr/exec\", pid);\n\telse\n\t\tret = snprintf(path, __LSMATTRLEN, \"%d/attr/current\", pid);\n\tif (ret < 0 || ret >= __LSMATTRLEN)\n\t\treturn -1;\n\n\tlabelfd = openat(procfd, path, O_RDWR);\n\tif (labelfd < 0) {\n\t\tSYSERROR(\"Unable to open file descriptor to set LSM label.\");\n\t\treturn -1;\n\t}\n\n\treturn labelfd;\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include \"confile.h\"",
            "#include \"lsm/lsm.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"conf.h\"",
            "#include \"lxclock.h\"",
            "#include \"cgroup.h\"",
            "#include \"commands.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include \"caps.h\"",
            "#include \"attach.h\"",
            "#include \"af_unix.h\"",
            "#include \"log.h\"",
            "#include \"namespace.h\"",
            "#include <pwd.h>",
            "#include <linux/unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/mount.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [
            "#define __LSMATTRLEN (5 + (LXC_NUMSTRLEN64) + 7 + 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include \"confile.h\"\n#include \"lsm/lsm.h\"\n#include <lxc/lxccontainer.h>\n#include \"lxcseccomp.h\"\n#include \"conf.h\"\n#include \"lxclock.h\"\n#include \"cgroup.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"caps.h\"\n#include \"attach.h\"\n#include \"af_unix.h\"\n#include \"log.h\"\n#include \"namespace.h\"\n#include <pwd.h>\n#include <linux/unistd.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\n#define __LSMATTRLEN (5 + (LXC_NUMSTRLEN64) + 7 + 1)\n\nstatic int lsm_openat(int procfd, pid_t pid, int on_exec)\n{\n\tint ret = -1;\n\tint labelfd = -1;\n\tconst char *name;\n\tchar path[__LSMATTRLEN];\n\n\tname = lsm_name();\n\n\tif (strcmp(name, \"nop\") == 0)\n\t\treturn 0;\n\n\tif (strcmp(name, \"none\") == 0)\n\t\treturn 0;\n\n\t/* We don't support on-exec with AppArmor */\n\tif (strcmp(name, \"AppArmor\") == 0)\n\t\ton_exec = 0;\n\n\tif (on_exec)\n\t\tret = snprintf(path, __LSMATTRLEN, \"%d/attr/exec\", pid);\n\telse\n\t\tret = snprintf(path, __LSMATTRLEN, \"%d/attr/current\", pid);\n\tif (ret < 0 || ret >= __LSMATTRLEN)\n\t\treturn -1;\n\n\tlabelfd = openat(procfd, path, O_RDWR);\n\tif (labelfd < 0) {\n\t\tSYSERROR(\"Unable to open file descriptor to set LSM label.\");\n\t\treturn -1;\n\t}\n\n\treturn labelfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Expected to receive sequence number 3: %s.\"",
            "strerror(errno)"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Intended to send sequence number 2: %s.\"",
            "strerror(errno)"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Expected to receive sequence number 1: %s.\"",
            "strerror(errno)"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Intended to send sequence number 0: %s.\"",
            "strerror(errno)"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGQUIT",
            "SIG_IGN"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "task_blocking_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1893-1925",
          "snippet": "bool task_blocking_signal(pid_t pid, int signal)\n{\n\tbool bret = false;\n\tchar *line = NULL;\n\tlong unsigned int sigblk = 0;\n\tsize_t n = 0;\n\tint ret;\n\tFILE *f;\n\n\tchar status[__PROC_STATUS_LEN];\n\n\tret = snprintf(status, __PROC_STATUS_LEN, \"/proc/%d/status\", pid);\n\tif (ret < 0 || ret >= __PROC_STATUS_LEN)\n\t\treturn bret;\n\n\tf = fopen(status, \"r\");\n\tif (!f)\n\t\treturn bret;\n\n\twhile (getline(&line, &n, f) != -1) {\n\t\tif (!strncmp(line, \"SigBlk:\\t\", 8))\n\t\t\tif (sscanf(line + 8, \"%lx\", &sigblk) != 1)\n\t\t\t\tgoto out;\n\t}\n\n\tif (sigblk & signal)\n\t\tbret = true;\n\nout:\n\tfree(line);\n\tfclose(f);\n\treturn bret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define __PROC_STATUS_LEN (5 + (LXC_NUMSTRLEN64) + 7 + 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\n#define __PROC_STATUS_LEN (5 + (LXC_NUMSTRLEN64) + 7 + 1)\n\nbool task_blocking_signal(pid_t pid, int signal)\n{\n\tbool bret = false;\n\tchar *line = NULL;\n\tlong unsigned int sigblk = 0;\n\tsize_t n = 0;\n\tint ret;\n\tFILE *f;\n\n\tchar status[__PROC_STATUS_LEN];\n\n\tret = snprintf(status, __PROC_STATUS_LEN, \"/proc/%d/status\", pid);\n\tif (ret < 0 || ret >= __PROC_STATUS_LEN)\n\t\treturn bret;\n\n\tf = fopen(status, \"r\");\n\tif (!f)\n\t\treturn bret;\n\n\twhile (getline(&line, &n, f) != -1) {\n\t\tif (!strncmp(line, \"SigBlk:\\t\", 8))\n\t\t\tif (sscanf(line + 8, \"%lx\", &sigblk) != 1)\n\t\t\t\tgoto out;\n\t}\n\n\tif (sigblk & signal)\n\t\tbret = true;\n\nout:\n\tfree(line);\n\tfclose(f);\n\treturn bret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Expected to receive pid: %s.\"",
            "strerror(errno)"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Intended to send sequence number 0: %s.\"",
            "strerror(errno)"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Unable to open /proc.\""
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/proc\"",
            "O_DIRECTORY | O_RDONLY | O_CLOEXEC"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "genetlink_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/genl.c",
          "lines": "106-116",
          "snippet": "extern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"genl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/genetlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"genl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_attach",
          "args": [
            "name",
            "lxcpath",
            "pid"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgroup.c",
          "lines": "179-184",
          "snippet": "bool cgroup_attach(const char *name, const char *lxcpath, pid_t pid)\n{\n\tif (ops)\n\t\treturn ops->attach(name, lxcpath, pid);\n\treturn false;\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"log.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_ops *ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"log.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <unistd.h>\n\nstatic struct cgroup_ops *ops = NULL;\n\nbool cgroup_attach(const char *name, const char *lxcpath, pid_t pid)\n{\n\tif (ops)\n\t\treturn ops->attach(name, lxcpath, pid);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to create first subprocess.\""
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Could not set up required IPC mechanism for attaching.\""
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socketpair",
          "args": [
            "PF_LOCAL",
            "SOCK_STREAM | SOCK_CLOEXEC",
            "0",
            "ipc_sockets"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to automatically determine the \"\n\t\t\t      \"namespaces which the container uses.\""
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cmd_get_clone_flags",
          "args": [
            "name",
            "lxcpath"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_get_clone_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "410-422",
          "snippet": "int lxc_cmd_get_clone_flags(const char *name, const char *lxcpath)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_GET_CLONE_FLAGS },\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn PTR_TO_INT(cmd.rsp.data);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nint lxc_cmd_get_clone_flags(const char *name, const char *lxcpath)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_GET_CLONE_FLAGS },\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn PTR_TO_INT(cmd.rsp.data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getcwd",
          "args": [
            "NULL",
            "0"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Could not determine whether PR_SET_NO_NEW_PRIVS is set.\""
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no_new_privs",
          "args": [
            "init_ctx->container",
            "options"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "no_new_privs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
          "lines": "721-746",
          "snippet": "static bool no_new_privs(struct lxc_container *c,\n\t\t\t lxc_attach_options_t *options)\n{\n\tchar *val;\n\n\t/* Remove current setting. */\n\tif (!c->set_config_item(c, \"lxc.no_new_privs\", \"\")) {\n\t\treturn false;\n\t}\n\n\t/* Retrieve currently active setting. */\n\tval = c->get_running_config_item(c, \"lxc.no_new_privs\");\n\tif (!val) {\n\t\tINFO(\"Failed to get running config item for lxc.no_new_privs.\");\n\t\treturn false;\n\t}\n\n\t/* Set currently active setting. */\n\tif (!c->set_config_item(c, \"lxc.no_new_privs\", val)) {\n\t\tfree(val);\n\t\treturn false;\n\t}\n\tfree(val);\n\n\treturn true;\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include \"confile.h\"",
            "#include \"lsm/lsm.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"conf.h\"",
            "#include \"lxclock.h\"",
            "#include \"cgroup.h\"",
            "#include \"commands.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include \"caps.h\"",
            "#include \"attach.h\"",
            "#include \"af_unix.h\"",
            "#include \"log.h\"",
            "#include \"namespace.h\"",
            "#include <pwd.h>",
            "#include <linux/unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/mount.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include \"confile.h\"\n#include \"lsm/lsm.h\"\n#include <lxc/lxccontainer.h>\n#include \"lxcseccomp.h\"\n#include \"conf.h\"\n#include \"lxclock.h\"\n#include \"cgroup.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"caps.h\"\n#include \"attach.h\"\n#include \"af_unix.h\"\n#include \"log.h\"\n#include \"namespace.h\"\n#include <pwd.h>\n#include <linux/unistd.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\nstatic bool no_new_privs(struct lxc_container *c,\n\t\t\t lxc_attach_options_t *options)\n{\n\tchar *val;\n\n\t/* Remove current setting. */\n\tif (!c->set_config_item(c, \"lxc.no_new_privs\", \"\")) {\n\t\treturn false;\n\t}\n\n\t/* Retrieve currently active setting. */\n\tval = c->get_running_config_item(c, \"lxc.no_new_privs\");\n\tif (!val) {\n\t\tINFO(\"Failed to get running config item for lxc.no_new_privs.\");\n\t\treturn false;\n\t}\n\n\t/* Set currently active setting. */\n\tif (!c->set_config_item(c, \"lxc.no_new_privs\", val)) {\n\t\tfree(val);\n\t\treturn false;\n\t}\n\tfree(val);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to get seccomp policy.\""
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fetch_seccomp",
          "args": [
            "init_ctx->container",
            "options"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_seccomp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
          "lines": "681-719",
          "snippet": "static bool fetch_seccomp(struct lxc_container *c,\n\t\t\t  lxc_attach_options_t *options)\n{\n\tchar *path;\n\n\tif (!(options->namespaces & CLONE_NEWNS) || !(options->attach_flags & LXC_ATTACH_LSM)) {\n\t\tfree(c->lxc_conf->seccomp);\n\t\tc->lxc_conf->seccomp = NULL;\n\t\treturn true;\n\t}\n\n\t/* Remove current setting. */\n\tif (!c->set_config_item(c, \"lxc.seccomp\", \"\")) {\n\t\treturn false;\n\t}\n\n\t/* Fetch the current profile path over the cmd interface. */\n\tpath = c->get_running_config_item(c, \"lxc.seccomp\");\n\tif (!path) {\n\t\tINFO(\"Failed to get running config item for lxc.seccomp.\");\n\t\treturn true;\n\t}\n\n\t/* Copy the value into the new lxc_conf. */\n\tif (!c->set_config_item(c, \"lxc.seccomp\", path)) {\n\t\tfree(path);\n\t\treturn false;\n\t}\n\tfree(path);\n\n\t/* Attempt to parse the resulting config. */\n\tif (lxc_read_seccomp_config(c->lxc_conf) < 0) {\n\t\tERROR(\"Error reading seccomp policy.\");\n\t\treturn false;\n\t}\n\n\tINFO(\"Retrieved seccomp policy.\");\n\treturn true;\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include \"confile.h\"",
            "#include \"lsm/lsm.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"conf.h\"",
            "#include \"lxclock.h\"",
            "#include \"cgroup.h\"",
            "#include \"commands.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include \"caps.h\"",
            "#include \"attach.h\"",
            "#include \"af_unix.h\"",
            "#include \"log.h\"",
            "#include \"namespace.h\"",
            "#include <pwd.h>",
            "#include <linux/unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/mount.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include \"confile.h\"\n#include \"lsm/lsm.h\"\n#include <lxc/lxccontainer.h>\n#include \"lxcseccomp.h\"\n#include \"conf.h\"\n#include \"lxclock.h\"\n#include \"cgroup.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"caps.h\"\n#include \"attach.h\"\n#include \"af_unix.h\"\n#include \"log.h\"\n#include \"namespace.h\"\n#include <pwd.h>\n#include <linux/unistd.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\nstatic bool fetch_seccomp(struct lxc_container *c,\n\t\t\t  lxc_attach_options_t *options)\n{\n\tchar *path;\n\n\tif (!(options->namespaces & CLONE_NEWNS) || !(options->attach_flags & LXC_ATTACH_LSM)) {\n\t\tfree(c->lxc_conf->seccomp);\n\t\tc->lxc_conf->seccomp = NULL;\n\t\treturn true;\n\t}\n\n\t/* Remove current setting. */\n\tif (!c->set_config_item(c, \"lxc.seccomp\", \"\")) {\n\t\treturn false;\n\t}\n\n\t/* Fetch the current profile path over the cmd interface. */\n\tpath = c->get_running_config_item(c, \"lxc.seccomp\");\n\tif (!path) {\n\t\tINFO(\"Failed to get running config item for lxc.seccomp.\");\n\t\treturn true;\n\t}\n\n\t/* Copy the value into the new lxc_conf. */\n\tif (!c->set_config_item(c, \"lxc.seccomp\", path)) {\n\t\tfree(path);\n\t\treturn false;\n\t}\n\tfree(path);\n\n\t/* Attempt to parse the resulting config. */\n\tif (lxc_read_seccomp_config(c->lxc_conf) < 0) {\n\t\tERROR(\"Error reading seccomp policy.\");\n\t\treturn false;\n\t}\n\n\tINFO(\"Retrieved seccomp policy.\");\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_container_new",
          "args": [
            "name",
            "lxcpath"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "4099-4218",
          "snippet": "struct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstruct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to get personality of the container.\""
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_personality",
          "args": [
            "name",
            "lxcpath"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "get_personality",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
          "lines": "748-758",
          "snippet": "static signed long get_personality(const char *name, const char *lxcpath)\n{\n\tchar *p = lxc_cmd_get_config_item(name, \"lxc.arch\", lxcpath);\n\tsigned long ret;\n\n\tif (!p)\n\t\treturn -1;\n\tret = lxc_config_parse_arch(p);\n\tfree(p);\n\treturn ret;\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include \"confile.h\"",
            "#include \"lsm/lsm.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"conf.h\"",
            "#include \"lxclock.h\"",
            "#include \"cgroup.h\"",
            "#include \"commands.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include \"caps.h\"",
            "#include \"attach.h\"",
            "#include \"af_unix.h\"",
            "#include \"log.h\"",
            "#include \"namespace.h\"",
            "#include <pwd.h>",
            "#include <linux/unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/mount.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include \"confile.h\"\n#include \"lsm/lsm.h\"\n#include <lxc/lxccontainer.h>\n#include \"lxcseccomp.h\"\n#include \"conf.h\"\n#include \"lxclock.h\"\n#include \"cgroup.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"caps.h\"\n#include \"attach.h\"\n#include \"af_unix.h\"\n#include \"log.h\"\n#include \"namespace.h\"\n#include <pwd.h>\n#include <linux/unistd.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\nstatic signed long get_personality(const char *name, const char *lxcpath)\n{\n\tchar *p = lxc_cmd_get_config_item(name, \"lxc.arch\", lxcpath);\n\tsigned long ret;\n\n\tif (!p)\n\t\treturn -1;\n\tret = lxc_config_parse_arch(p);\n\tfree(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to get context of init process: %ld.\"",
            "(long)init_pid"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_proc_get_context_info",
          "args": [
            "init_pid"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_proc_get_context_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
          "lines": "186-238",
          "snippet": "static struct lxc_proc_context_info *lxc_proc_get_context_info(pid_t pid)\n{\n\tFILE *proc_file;\n\tchar proc_fn[__PROC_STATUS_LEN];\n\tbool found;\n\tint ret;\n\tchar *line = NULL;\n\tsize_t line_bufsz = 0;\n\tstruct lxc_proc_context_info *info = NULL;\n\n\t/* Read capabilities. */\n\tret = snprintf(proc_fn, __PROC_STATUS_LEN, \"/proc/%d/status\", pid);\n\tif (ret < 0 || ret >= __PROC_STATUS_LEN)\n\t\tgoto on_error;\n\n\tproc_file = fopen(proc_fn, \"r\");\n\tif (!proc_file) {\n\t\tSYSERROR(\"Could not open %s.\", proc_fn);\n\t\tgoto on_error;\n\t}\n\n\tinfo = calloc(1, sizeof(*info));\n\tif (!info) {\n\t\tSYSERROR(\"Could not allocate memory.\");\n\t\treturn NULL;\n\t}\n\n\tfound = false;\n\twhile (getline(&line, &line_bufsz, proc_file) != -1) {\n\t\tret = sscanf(line, \"CapBnd: %llx\", &info->capability_mask);\n\t\tif (ret != EOF && ret == 1) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree(line);\n\tfclose(proc_file);\n\n\tif (!found) {\n\t\tSYSERROR(\"Could not read capability bounding set from %s.\", proc_fn);\n\t\terrno = ENOENT;\n\t\tgoto on_error;\n\t}\n\n\tinfo->lsm_label = lsm_process_label_get(pid);\n\n\treturn info;\n\non_error:\n\tfree(info);\n\treturn NULL;\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include \"confile.h\"",
            "#include \"lsm/lsm.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"conf.h\"",
            "#include \"lxclock.h\"",
            "#include \"cgroup.h\"",
            "#include \"commands.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include \"caps.h\"",
            "#include \"attach.h\"",
            "#include \"af_unix.h\"",
            "#include \"log.h\"",
            "#include \"namespace.h\"",
            "#include <pwd.h>",
            "#include <linux/unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/mount.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [
            "#define __PROC_STATUS_LEN (5 + (LXC_NUMSTRLEN64) + 7 + 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include \"confile.h\"\n#include \"lsm/lsm.h\"\n#include <lxc/lxccontainer.h>\n#include \"lxcseccomp.h\"\n#include \"conf.h\"\n#include \"lxclock.h\"\n#include \"cgroup.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"caps.h\"\n#include \"attach.h\"\n#include \"af_unix.h\"\n#include \"log.h\"\n#include \"namespace.h\"\n#include <pwd.h>\n#include <linux/unistd.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\n#define __PROC_STATUS_LEN (5 + (LXC_NUMSTRLEN64) + 7 + 1)\n\nstatic struct lxc_proc_context_info *lxc_proc_get_context_info(pid_t pid)\n{\n\tFILE *proc_file;\n\tchar proc_fn[__PROC_STATUS_LEN];\n\tbool found;\n\tint ret;\n\tchar *line = NULL;\n\tsize_t line_bufsz = 0;\n\tstruct lxc_proc_context_info *info = NULL;\n\n\t/* Read capabilities. */\n\tret = snprintf(proc_fn, __PROC_STATUS_LEN, \"/proc/%d/status\", pid);\n\tif (ret < 0 || ret >= __PROC_STATUS_LEN)\n\t\tgoto on_error;\n\n\tproc_file = fopen(proc_fn, \"r\");\n\tif (!proc_file) {\n\t\tSYSERROR(\"Could not open %s.\", proc_fn);\n\t\tgoto on_error;\n\t}\n\n\tinfo = calloc(1, sizeof(*info));\n\tif (!info) {\n\t\tSYSERROR(\"Could not allocate memory.\");\n\t\treturn NULL;\n\t}\n\n\tfound = false;\n\twhile (getline(&line, &line_bufsz, proc_file) != -1) {\n\t\tret = sscanf(line, \"CapBnd: %llx\", &info->capability_mask);\n\t\tif (ret != EOF && ret == 1) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree(line);\n\tfclose(proc_file);\n\n\tif (!found) {\n\t\tSYSERROR(\"Could not read capability bounding set from %s.\", proc_fn);\n\t\terrno = ENOENT;\n\t\tgoto on_error;\n\t}\n\n\tinfo->lsm_label = lsm_process_label_get(pid);\n\n\treturn info;\n\non_error:\n\tfree(info);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to get init pid.\""
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cmd_get_init_pid",
          "args": [
            "name",
            "lxcpath"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_get_init_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "380-392",
          "snippet": "pid_t lxc_cmd_get_init_pid(const char *name, const char *lxcpath)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_GET_INIT_PID },\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn PTR_TO_INT(cmd.rsp.data);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\npid_t lxc_cmd_get_init_pid(const char *name, const char *lxcpath)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_GET_INIT_PID },\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn PTR_TO_INT(cmd.rsp.data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/personality.h>\n#include \"confile.h\"\n#include \"lsm/lsm.h\"\n#include <lxc/lxccontainer.h>\n#include \"lxcseccomp.h\"\n#include \"conf.h\"\n#include \"lxclock.h\"\n#include \"cgroup.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"caps.h\"\n#include \"attach.h\"\n#include \"af_unix.h\"\n#include \"log.h\"\n#include \"namespace.h\"\n#include <pwd.h>\n#include <linux/unistd.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\n#define PR_SET_NO_NEW_PRIVS 38\n\nstatic lxc_attach_options_t attach_static_default_options = LXC_ATTACH_OPTIONS_DEFAULT;\n\nint lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_function, void* exec_payload, lxc_attach_options_t* options, pid_t* attached_process)\n{\n\tint ret, status;\n\tpid_t init_pid, pid, attached_pid, expected;\n\tstruct lxc_proc_context_info *init_ctx;\n\tchar* cwd;\n\tchar* new_cwd;\n\tint ipc_sockets[2];\n\tsigned long personality;\n\n\tif (!options)\n\t\toptions = &attach_static_default_options;\n\n\tinit_pid = lxc_cmd_get_init_pid(name, lxcpath);\n\tif (init_pid < 0) {\n\t\tERROR(\"Failed to get init pid.\");\n\t\treturn -1;\n\t}\n\n\tinit_ctx = lxc_proc_get_context_info(init_pid);\n\tif (!init_ctx) {\n\t\tERROR(\"Failed to get context of init process: %ld.\",\n\t\t      (long)init_pid);\n\t\treturn -1;\n\t}\n\n\tpersonality = get_personality(name, lxcpath);\n\tif (init_ctx->personality < 0) {\n\t\tERROR(\"Failed to get personality of the container.\");\n\t\tlxc_proc_put_context_info(init_ctx);\n\t\treturn -1;\n\t}\n\tinit_ctx->personality = personality;\n\n\tinit_ctx->container = lxc_container_new(name, lxcpath);\n\tif (!init_ctx->container)\n\t\treturn -1;\n\n\tif (!fetch_seccomp(init_ctx->container, options))\n\t\tWARN(\"Failed to get seccomp policy.\");\n\n\tif (!no_new_privs(init_ctx->container, options))\n\t\tWARN(\"Could not determine whether PR_SET_NO_NEW_PRIVS is set.\");\n\n\tcwd = getcwd(NULL, 0);\n\n\t/* Determine which namespaces the container was created with\n\t * by asking lxc-start, if necessary.\n\t */\n\tif (options->namespaces == -1) {\n\t\toptions->namespaces = lxc_cmd_get_clone_flags(name, lxcpath);\n\t\t/* call failed */\n\t\tif (options->namespaces == -1) {\n\t\t\tERROR(\"Failed to automatically determine the \"\n\t\t\t      \"namespaces which the container uses.\");\n\t\t\tfree(cwd);\n\t\t\tlxc_proc_put_context_info(init_ctx);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Create a socket pair for IPC communication; set SOCK_CLOEXEC in order\n\t * to make sure we don't irritate other threads that want to fork+exec\n\t * away\n\t *\n\t * IMPORTANT: if the initial process is multithreaded and another call\n\t * just fork()s away without exec'ing directly after, the socket fd will\n\t * exist in the forked process from the other thread and any close() in\n\t * our own child process will not really cause the socket to close\n\t * properly, potentiall causing the parent to hang.\n\t *\n\t * For this reason, while IPC is still active, we have to use shutdown()\n\t * if the child exits prematurely in order to signal that the socket is\n\t * closed and cannot assume that the child exiting will automatically do\n\t * that.\n\t *\n\t * IPC mechanism: (X is receiver)\n\t *   initial process        intermediate          attached\n\t *        X           <---  send pid of\n\t *                          attached proc,\n\t *                          then exit\n\t *    send 0 ------------------------------------>    X\n\t *                                              [do initialization]\n\t *        X  <------------------------------------  send 1\n\t *   [add to cgroup, ...]\n\t *    send 2 ------------------------------------>    X\n\t *\t\t\t\t\t\t[set LXC_ATTACH_NO_NEW_PRIVS]\n\t *        X  <------------------------------------  send 3\n\t *   [open LSM label fd]\n\t *    send 4 ------------------------------------>    X\n\t *   \t\t\t\t\t\t[set LSM label]\n\t *   close socket                                 close socket\n\t *                                                run program\n\t */\n\tret = socketpair(PF_LOCAL, SOCK_STREAM | SOCK_CLOEXEC, 0, ipc_sockets);\n\tif (ret < 0) {\n\t\tSYSERROR(\"Could not set up required IPC mechanism for attaching.\");\n\t\tfree(cwd);\n\t\tlxc_proc_put_context_info(init_ctx);\n\t\treturn -1;\n\t}\n\n\t/* Create intermediate subprocess, three reasons:\n\t *       1. Runs all pthread_atfork handlers and the child will no\n\t *          longer be threaded (we can't properly setns() in a threaded\n\t *          process).\n\t *       2. We can't setns() in the child itself, since we want to make\n\t *          sure we are properly attached to the pidns.\n\t *       3. Also, the initial thread has to put the attached process\n\t *          into the cgroup, which we can only do if we didn't already\n\t *          setns() (otherwise, user namespaces will hate us).\n\t */\n\tpid = fork();\n\n\tif (pid < 0) {\n\t\tSYSERROR(\"Failed to create first subprocess.\");\n\t\tfree(cwd);\n\t\tlxc_proc_put_context_info(init_ctx);\n\t\treturn -1;\n\t}\n\n\tif (pid) {\n\t\tint procfd = -1;\n\t\tpid_t to_cleanup_pid = pid;\n\n\t\t/* Initial thread, we close the socket that is for the\n\t\t * subprocesses.\n\t\t */\n\t\tclose(ipc_sockets[1]);\n\t\tfree(cwd);\n\n\t\t/* Attach to cgroup, if requested. */\n\t\tif (options->attach_flags & LXC_ATTACH_MOVE_TO_CGROUP) {\n\t\t\tif (!cgroup_attach(name, lxcpath, pid))\n\t\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Open /proc before setns() to the containers namespace so we\n\t\t * don't rely on any information from inside the container.\n\t\t */\n\t\tprocfd = open(\"/proc\", O_DIRECTORY | O_RDONLY | O_CLOEXEC);\n\t\tif (procfd < 0) {\n\t\t\tSYSERROR(\"Unable to open /proc.\");\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Let the child process know to go ahead. */\n\t\tstatus = 0;\n\t\tret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));\n\t\tif (ret <= 0) {\n\t\t\tERROR(\"Intended to send sequence number 0: %s.\",\n\t\t\t      strerror(errno));\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Get pid of attached process from intermediate process. */\n\t\tret = lxc_read_nointr_expect(ipc_sockets[0], &attached_pid, sizeof(attached_pid), NULL);\n\t\tif (ret <= 0) {\n\t\t\tif (ret != 0)\n\t\t\t\tERROR(\"Expected to receive pid: %s.\", strerror(errno));\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Ignore SIGKILL (CTRL-C) and SIGQUIT (CTRL-\\) - issue #313. */\n\t\tif (options->stdin_fd == 0) {\n\t\t\tsignal(SIGINT, SIG_IGN);\n\t\t\tsignal(SIGQUIT, SIG_IGN);\n\t\t}\n\n\t\t/* Reap intermediate process. */\n\t\tret = wait_for_pid(pid);\n\t\tif (ret < 0)\n\t\t\tgoto on_error;\n\n\t\t/* We will always have to reap the attached process now. */\n\t\tto_cleanup_pid = attached_pid;\n\n\t\t/* Tell attached process it may start initializing. */\n\t\tstatus = 0;\n\t\tret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));\n\t\tif (ret <= 0) {\n\t\t\tERROR(\"Intended to send sequence number 0: %s.\", strerror(errno));\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Wait for the attached process to finish initializing. */\n\t\texpected = 1;\n\t\tret = lxc_read_nointr_expect(ipc_sockets[0], &status, sizeof(status), &expected);\n\t\tif (ret <= 0) {\n\t\t\tif (ret != 0)\n\t\t\t\tERROR(\"Expected to receive sequence number 1: %s.\", strerror(errno));\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Tell attached process we're done. */\n\t\tstatus = 2;\n\t\tret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));\n\t\tif (ret <= 0) {\n\t\t\tERROR(\"Intended to send sequence number 2: %s.\", strerror(errno));\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Wait for the (grand)child to tell us that it's ready to set\n\t\t * up its LSM labels.\n\t\t */\n\t\texpected = 3;\n\t\tret = lxc_read_nointr_expect(ipc_sockets[0], &status, sizeof(status), &expected);\n\t\tif (ret <= 0) {\n\t\t\tERROR(\"Expected to receive sequence number 3: %s.\",\n\t\t\t      strerror(errno));\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Open LSM fd and send it to child. */\n\t\tif ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {\n\t\t\tint on_exec, saved_errno;\n\t\t\tint labelfd = -1;\n\t\t\ton_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;\n\t\t\t/* Open fd for the LSM security module. */\n\t\t\tlabelfd = lsm_openat(procfd, attached_pid, on_exec);\n\t\t\tif (labelfd < 0)\n\t\t\t\tgoto on_error;\n\n\t\t\t/* Send child fd of the LSM security module to write to. */\n\t\t\tret = lxc_abstract_unix_send_fd(ipc_sockets[0], labelfd, NULL, 0);\n\t\t\tsaved_errno = errno;\n\t\t\tclose(labelfd);\n\t\t\tif (ret <= 0) {\n\t\t\t\tERROR(\"Intended to send file descriptor %d: %s.\", labelfd, strerror(saved_errno));\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t}\n\n\t\tif (procfd >= 0)\n\t\t\tclose(procfd);\n\t\t/* Now shut down communication with child, we're done. */\n\t\tshutdown(ipc_sockets[0], SHUT_RDWR);\n\t\tclose(ipc_sockets[0]);\n\t\tlxc_proc_put_context_info(init_ctx);\n\n\t\t/* We're done, the child process should now execute whatever it\n\t\t * is that the user requested. The parent can now track it with\n\t\t * waitpid() or similar.\n\t\t */\n\n\t\t*attached_process = attached_pid;\n\t\treturn 0;\n\n\ton_error:\n\t\t/* First shut down the socket, then wait for the pid, otherwise\n\t\t * the pid we're waiting for may never exit.\n\t\t */\n\t\tif (procfd >= 0)\n\t\t\tclose(procfd);\n\t\tshutdown(ipc_sockets[0], SHUT_RDWR);\n\t\tclose(ipc_sockets[0]);\n\t\tif (to_cleanup_pid)\n\t\t\t(void) wait_for_pid(to_cleanup_pid);\n\t\tlxc_proc_put_context_info(init_ctx);\n\t\treturn -1;\n\t}\n\n\t/* First subprocess begins here, we close the socket that is for the\n\t * initial thread.\n\t */\n\tclose(ipc_sockets[0]);\n\n\t/* Wait for the parent to have setup cgroups. */\n\texpected = 0;\n\tstatus = -1;\n\tret = lxc_read_nointr_expect(ipc_sockets[1], &status, sizeof(status), &expected);\n\tif (ret <= 0) {\n\t\tERROR(\"Expected to receive sequence number 0: %s.\", strerror(errno));\n\t\tshutdown(ipc_sockets[1], SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\tif ((options->attach_flags & LXC_ATTACH_MOVE_TO_CGROUP) && cgns_supported())\n\t\toptions->namespaces |= CLONE_NEWCGROUP;\n\n\t/* Attach now, create another subprocess later, since pid namespaces\n\t * only really affect the children of the current process.\n\t */\n\tret = lxc_attach_to_ns(init_pid, options->namespaces);\n\tif (ret < 0) {\n\t\tERROR(\"Failed to enter namespaces.\");\n\t\tshutdown(ipc_sockets[1], SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\t/* Attach succeeded, try to cwd. */\n\tif (options->initial_cwd)\n\t\tnew_cwd = options->initial_cwd;\n\telse\n\t\tnew_cwd = cwd;\n\tret = chdir(new_cwd);\n\tif (ret < 0)\n\t\tWARN(\"Could not change directory to \\\"%s\\\".\", new_cwd);\n\tfree(cwd);\n\n\t/* Now create the real child process. */\n\t{\n\t\tstruct attach_clone_payload payload = {\n\t\t\t.ipc_socket = ipc_sockets[1],\n\t\t\t.options = options,\n\t\t\t.init_ctx = init_ctx,\n\t\t\t.exec_function = exec_function,\n\t\t\t.exec_payload = exec_payload,\n\t\t};\n\t\t/* We use clone_parent here to make this subprocess a direct\n\t\t * child of the initial process. Then this intermediate process\n\t\t * can exit and the parent can directly track the attached\n\t\t * process.\n\t\t */\n\t\tpid = lxc_clone(attach_child_main, &payload, CLONE_PARENT);\n\t}\n\n\t/* Shouldn't happen, clone() should always return positive pid. */\n\tif (pid <= 0) {\n\t\tSYSERROR(\"Failed to create subprocess.\");\n\t\tshutdown(ipc_sockets[1], SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\t/* Tell grandparent the pid of the pid of the newly created child. */\n\tret = lxc_write_nointr(ipc_sockets[1], &pid, sizeof(pid));\n\tif (ret != sizeof(pid)) {\n\t\t/* If this really happens here, this is very unfortunate, since\n\t\t * the parent will not know the pid of the attached process and\n\t\t * will not be able to wait for it (and we won't either due to\n\t\t * CLONE_PARENT) so the parent won't be able to reap it and the\n\t\t * attached process will remain a zombie.\n\t\t */\n\t\tERROR(\"Intended to send pid %d: %s.\", pid, strerror(errno));\n\t\tshutdown(ipc_sockets[1], SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\t/* The rest is in the hands of the initial and the attached process. */\n\trexit(0);\n}"
  },
  {
    "function_name": "get_personality",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
    "lines": "748-758",
    "snippet": "static signed long get_personality(const char *name, const char *lxcpath)\n{\n\tchar *p = lxc_cmd_get_config_item(name, \"lxc.arch\", lxcpath);\n\tsigned long ret;\n\n\tif (!p)\n\t\treturn -1;\n\tret = lxc_config_parse_arch(p);\n\tfree(p);\n\treturn ret;\n}",
    "includes": [
      "#include <sys/personality.h>",
      "#include \"confile.h\"",
      "#include \"lsm/lsm.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include \"lxcseccomp.h\"",
      "#include \"conf.h\"",
      "#include \"lxclock.h\"",
      "#include \"cgroup.h\"",
      "#include \"commands.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include \"caps.h\"",
      "#include \"attach.h\"",
      "#include \"af_unix.h\"",
      "#include \"log.h\"",
      "#include \"namespace.h\"",
      "#include <pwd.h>",
      "#include <linux/unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/mount.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "p"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_config_parse_arch",
          "args": [
            "p"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_config_parse_arch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/confile.c",
          "lines": "2165-2211",
          "snippet": "signed long lxc_config_parse_arch(const char *arch)\n{\n\t#if HAVE_SYS_PERSONALITY_H\n\tstruct per_name {\n\t\tchar *name;\n\t\tunsigned long per;\n\t} pername[] = {\n\t\t{ \"x86\", PER_LINUX32 },\n\t\t{ \"linux32\", PER_LINUX32 },\n\t\t{ \"i386\", PER_LINUX32 },\n\t\t{ \"i486\", PER_LINUX32 },\n\t\t{ \"i586\", PER_LINUX32 },\n\t\t{ \"i686\", PER_LINUX32 },\n\t\t{ \"athlon\", PER_LINUX32 },\n\t\t{ \"mips\", PER_LINUX32 },\n\t\t{ \"mipsel\", PER_LINUX32 },\n\t\t{ \"ppc\", PER_LINUX32 },\n\t\t{ \"arm\", PER_LINUX32 },\n\t\t{ \"armv7l\", PER_LINUX32 },\n\t\t{ \"armhf\", PER_LINUX32 },\n\t\t{ \"armel\", PER_LINUX32 },\n\t\t{ \"powerpc\", PER_LINUX32 },\n\t\t{ \"linux64\", PER_LINUX },\n\t\t{ \"x86_64\", PER_LINUX },\n\t\t{ \"amd64\", PER_LINUX },\n\t\t{ \"mips64\", PER_LINUX },\n\t\t{ \"mips64el\", PER_LINUX },\n\t\t{ \"ppc64\", PER_LINUX },\n\t\t{ \"ppc64le\", PER_LINUX },\n\t\t{ \"ppc64el\", PER_LINUX },\n\t\t{ \"powerpc64\", PER_LINUX },\n\t\t{ \"s390x\", PER_LINUX },\n\t\t{ \"aarch64\", PER_LINUX },\n\t\t{ \"arm64\", PER_LINUX },\n\t};\n\tsize_t len = sizeof(pername) / sizeof(pername[0]);\n\n\tsize_t i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (!strcmp(pername[i].name, arch))\n\t\t    return pername[i].per;\n\t}\n\t#endif\n\n\treturn -1;\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"network.h\"",
            "#include \"conf.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"confile.h\"",
            "#include \"config.h\"",
            "#include \"parse.h\"",
            "#include \"bdev.h\"",
            "#include <syslog.h>",
            "#include <dirent.h>",
            "#include <time.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"lxcseccomp.h\"\n#include \"network.h\"\n#include \"conf.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"confile.h\"\n#include \"config.h\"\n#include \"parse.h\"\n#include \"bdev.h\"\n#include <syslog.h>\n#include <dirent.h>\n#include <time.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nsigned long lxc_config_parse_arch(const char *arch)\n{\n\t#if HAVE_SYS_PERSONALITY_H\n\tstruct per_name {\n\t\tchar *name;\n\t\tunsigned long per;\n\t} pername[] = {\n\t\t{ \"x86\", PER_LINUX32 },\n\t\t{ \"linux32\", PER_LINUX32 },\n\t\t{ \"i386\", PER_LINUX32 },\n\t\t{ \"i486\", PER_LINUX32 },\n\t\t{ \"i586\", PER_LINUX32 },\n\t\t{ \"i686\", PER_LINUX32 },\n\t\t{ \"athlon\", PER_LINUX32 },\n\t\t{ \"mips\", PER_LINUX32 },\n\t\t{ \"mipsel\", PER_LINUX32 },\n\t\t{ \"ppc\", PER_LINUX32 },\n\t\t{ \"arm\", PER_LINUX32 },\n\t\t{ \"armv7l\", PER_LINUX32 },\n\t\t{ \"armhf\", PER_LINUX32 },\n\t\t{ \"armel\", PER_LINUX32 },\n\t\t{ \"powerpc\", PER_LINUX32 },\n\t\t{ \"linux64\", PER_LINUX },\n\t\t{ \"x86_64\", PER_LINUX },\n\t\t{ \"amd64\", PER_LINUX },\n\t\t{ \"mips64\", PER_LINUX },\n\t\t{ \"mips64el\", PER_LINUX },\n\t\t{ \"ppc64\", PER_LINUX },\n\t\t{ \"ppc64le\", PER_LINUX },\n\t\t{ \"ppc64el\", PER_LINUX },\n\t\t{ \"powerpc64\", PER_LINUX },\n\t\t{ \"s390x\", PER_LINUX },\n\t\t{ \"aarch64\", PER_LINUX },\n\t\t{ \"arm64\", PER_LINUX },\n\t};\n\tsize_t len = sizeof(pername) / sizeof(pername[0]);\n\n\tsize_t i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (!strcmp(pername[i].name, arch))\n\t\t    return pername[i].per;\n\t}\n\t#endif\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cmd_get_config_item",
          "args": [
            "name",
            "\"lxc.arch\"",
            "lxcpath"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_get_config_item_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "523-548",
          "snippet": "static int lxc_cmd_get_config_item_callback(int fd, struct lxc_cmd_req *req,\n\t\t\t\t\t    struct lxc_handler *handler)\n{\n\tint cilen;\n\tstruct lxc_cmd_rsp rsp;\n\tchar *cidata;\n\n\tmemset(&rsp, 0, sizeof(rsp));\n\tcilen = lxc_get_config_item(handler->conf, req->data, NULL, 0);\n\tif (cilen <= 0)\n\t\tgoto err1;\n\n\tcidata = alloca(cilen + 1);\n\tif (lxc_get_config_item(handler->conf, req->data, cidata, cilen + 1) != cilen)\n\t\tgoto err1;\n\tcidata[cilen] = '\\0';\n\trsp.data = cidata;\n\trsp.datalen = cilen + 1;\n\trsp.ret = 0;\n\tgoto out;\n\nerr1:\n\trsp.ret = -1;\nout:\n\treturn lxc_cmd_rsp_send(fd, &rsp);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nstatic int lxc_cmd_get_config_item_callback(int fd, struct lxc_cmd_req *req,\n\t\t\t\t\t    struct lxc_handler *handler)\n{\n\tint cilen;\n\tstruct lxc_cmd_rsp rsp;\n\tchar *cidata;\n\n\tmemset(&rsp, 0, sizeof(rsp));\n\tcilen = lxc_get_config_item(handler->conf, req->data, NULL, 0);\n\tif (cilen <= 0)\n\t\tgoto err1;\n\n\tcidata = alloca(cilen + 1);\n\tif (lxc_get_config_item(handler->conf, req->data, cidata, cilen + 1) != cilen)\n\t\tgoto err1;\n\tcidata[cilen] = '\\0';\n\trsp.data = cidata;\n\trsp.datalen = cilen + 1;\n\trsp.ret = 0;\n\tgoto out;\n\nerr1:\n\trsp.ret = -1;\nout:\n\treturn lxc_cmd_rsp_send(fd, &rsp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/personality.h>\n#include \"confile.h\"\n#include \"lsm/lsm.h\"\n#include <lxc/lxccontainer.h>\n#include \"lxcseccomp.h\"\n#include \"conf.h\"\n#include \"lxclock.h\"\n#include \"cgroup.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"caps.h\"\n#include \"attach.h\"\n#include \"af_unix.h\"\n#include \"log.h\"\n#include \"namespace.h\"\n#include <pwd.h>\n#include <linux/unistd.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\nstatic signed long get_personality(const char *name, const char *lxcpath)\n{\n\tchar *p = lxc_cmd_get_config_item(name, \"lxc.arch\", lxcpath);\n\tsigned long ret;\n\n\tif (!p)\n\t\treturn -1;\n\tret = lxc_config_parse_arch(p);\n\tfree(p);\n\treturn ret;\n}"
  },
  {
    "function_name": "no_new_privs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
    "lines": "721-746",
    "snippet": "static bool no_new_privs(struct lxc_container *c,\n\t\t\t lxc_attach_options_t *options)\n{\n\tchar *val;\n\n\t/* Remove current setting. */\n\tif (!c->set_config_item(c, \"lxc.no_new_privs\", \"\")) {\n\t\treturn false;\n\t}\n\n\t/* Retrieve currently active setting. */\n\tval = c->get_running_config_item(c, \"lxc.no_new_privs\");\n\tif (!val) {\n\t\tINFO(\"Failed to get running config item for lxc.no_new_privs.\");\n\t\treturn false;\n\t}\n\n\t/* Set currently active setting. */\n\tif (!c->set_config_item(c, \"lxc.no_new_privs\", val)) {\n\t\tfree(val);\n\t\treturn false;\n\t}\n\tfree(val);\n\n\treturn true;\n}",
    "includes": [
      "#include <sys/personality.h>",
      "#include \"confile.h\"",
      "#include \"lsm/lsm.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include \"lxcseccomp.h\"",
      "#include \"conf.h\"",
      "#include \"lxclock.h\"",
      "#include \"cgroup.h\"",
      "#include \"commands.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include \"caps.h\"",
      "#include \"attach.h\"",
      "#include \"af_unix.h\"",
      "#include \"log.h\"",
      "#include \"namespace.h\"",
      "#include <pwd.h>",
      "#include <linux/unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/mount.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "val"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->set_config_item",
          "args": [
            "c",
            "\"lxc.no_new_privs\"",
            "val"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Failed to get running config item for lxc.no_new_privs.\""
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->get_running_config_item",
          "args": [
            "c",
            "\"lxc.no_new_privs\""
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->set_config_item",
          "args": [
            "c",
            "\"lxc.no_new_privs\"",
            "\"\""
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/personality.h>\n#include \"confile.h\"\n#include \"lsm/lsm.h\"\n#include <lxc/lxccontainer.h>\n#include \"lxcseccomp.h\"\n#include \"conf.h\"\n#include \"lxclock.h\"\n#include \"cgroup.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"caps.h\"\n#include \"attach.h\"\n#include \"af_unix.h\"\n#include \"log.h\"\n#include \"namespace.h\"\n#include <pwd.h>\n#include <linux/unistd.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\nstatic bool no_new_privs(struct lxc_container *c,\n\t\t\t lxc_attach_options_t *options)\n{\n\tchar *val;\n\n\t/* Remove current setting. */\n\tif (!c->set_config_item(c, \"lxc.no_new_privs\", \"\")) {\n\t\treturn false;\n\t}\n\n\t/* Retrieve currently active setting. */\n\tval = c->get_running_config_item(c, \"lxc.no_new_privs\");\n\tif (!val) {\n\t\tINFO(\"Failed to get running config item for lxc.no_new_privs.\");\n\t\treturn false;\n\t}\n\n\t/* Set currently active setting. */\n\tif (!c->set_config_item(c, \"lxc.no_new_privs\", val)) {\n\t\tfree(val);\n\t\treturn false;\n\t}\n\tfree(val);\n\n\treturn true;\n}"
  },
  {
    "function_name": "fetch_seccomp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
    "lines": "681-719",
    "snippet": "static bool fetch_seccomp(struct lxc_container *c,\n\t\t\t  lxc_attach_options_t *options)\n{\n\tchar *path;\n\n\tif (!(options->namespaces & CLONE_NEWNS) || !(options->attach_flags & LXC_ATTACH_LSM)) {\n\t\tfree(c->lxc_conf->seccomp);\n\t\tc->lxc_conf->seccomp = NULL;\n\t\treturn true;\n\t}\n\n\t/* Remove current setting. */\n\tif (!c->set_config_item(c, \"lxc.seccomp\", \"\")) {\n\t\treturn false;\n\t}\n\n\t/* Fetch the current profile path over the cmd interface. */\n\tpath = c->get_running_config_item(c, \"lxc.seccomp\");\n\tif (!path) {\n\t\tINFO(\"Failed to get running config item for lxc.seccomp.\");\n\t\treturn true;\n\t}\n\n\t/* Copy the value into the new lxc_conf. */\n\tif (!c->set_config_item(c, \"lxc.seccomp\", path)) {\n\t\tfree(path);\n\t\treturn false;\n\t}\n\tfree(path);\n\n\t/* Attempt to parse the resulting config. */\n\tif (lxc_read_seccomp_config(c->lxc_conf) < 0) {\n\t\tERROR(\"Error reading seccomp policy.\");\n\t\treturn false;\n\t}\n\n\tINFO(\"Retrieved seccomp policy.\");\n\treturn true;\n}",
    "includes": [
      "#include <sys/personality.h>",
      "#include \"confile.h\"",
      "#include \"lsm/lsm.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include \"lxcseccomp.h\"",
      "#include \"conf.h\"",
      "#include \"lxclock.h\"",
      "#include \"cgroup.h\"",
      "#include \"commands.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include \"caps.h\"",
      "#include \"attach.h\"",
      "#include \"af_unix.h\"",
      "#include \"log.h\"",
      "#include \"namespace.h\"",
      "#include <pwd.h>",
      "#include <linux/unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/mount.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Retrieved seccomp policy.\""
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error reading seccomp policy.\""
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_read_seccomp_config",
          "args": [
            "c->lxc_conf"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_seccomp_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "707-755",
          "snippet": "int lxc_read_seccomp_config(struct lxc_conf *conf)\n{\n\tFILE *f;\n\tint ret;\n\tint check_seccomp_attr_set;\n\n\tif (!conf->seccomp)\n\t\treturn 0;\n\n\tif (!use_seccomp())\n\t\treturn 0;\n#if HAVE_SCMP_FILTER_CTX\n\t/* XXX for debug, pass in SCMP_ACT_TRAP */\n\tconf->seccomp_ctx = seccomp_init(SCMP_ACT_KILL);\n\tret = !conf->seccomp_ctx;\n#else\n\tret = seccomp_init(SCMP_ACT_KILL) < 0;\n#endif\n\tif (ret) {\n\t\tERROR(\"Failed initializing seccomp.\");\n\t\treturn -1;\n\t}\n\n/* turn off no-new-privs.  We don't want it in lxc, and it breaks\n * with apparmor */\n#if HAVE_SCMP_FILTER_CTX\n\tcheck_seccomp_attr_set = seccomp_attr_set(conf->seccomp_ctx, SCMP_FLTATR_CTL_NNP, 0);\n#else\n\tcheck_seccomp_attr_set = seccomp_attr_set(SCMP_FLTATR_CTL_NNP, 0);\n#endif\n\tif (check_seccomp_attr_set) {\n\t\tERROR(\"Failed to turn off n-new-privs.\");\n\t\treturn -1;\n\t}\n#ifdef SCMP_FLTATR_ATL_TSKIP\n\tif (seccomp_attr_set(conf->seccomp_ctx, SCMP_FLTATR_ATL_TSKIP, 1)) {\n\t\tWARN(\"Failed to turn on seccomp nop-skip, continuing\");\n\t}\n#endif\n\n\tf = fopen(conf->seccomp, \"r\");\n\tif (!f) {\n\t\tSYSERROR(\"Failed to open seccomp policy file %s.\", conf->seccomp);\n\t\treturn -1;\n\t}\n\tret = parse_config(f, conf);\n\tfclose(f);\n\treturn ret;\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ret;",
            "int ret;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nint ret;\nint ret;\n\nint lxc_read_seccomp_config(struct lxc_conf *conf)\n{\n\tFILE *f;\n\tint ret;\n\tint check_seccomp_attr_set;\n\n\tif (!conf->seccomp)\n\t\treturn 0;\n\n\tif (!use_seccomp())\n\t\treturn 0;\n#if HAVE_SCMP_FILTER_CTX\n\t/* XXX for debug, pass in SCMP_ACT_TRAP */\n\tconf->seccomp_ctx = seccomp_init(SCMP_ACT_KILL);\n\tret = !conf->seccomp_ctx;\n#else\n\tret = seccomp_init(SCMP_ACT_KILL) < 0;\n#endif\n\tif (ret) {\n\t\tERROR(\"Failed initializing seccomp.\");\n\t\treturn -1;\n\t}\n\n/* turn off no-new-privs.  We don't want it in lxc, and it breaks\n * with apparmor */\n#if HAVE_SCMP_FILTER_CTX\n\tcheck_seccomp_attr_set = seccomp_attr_set(conf->seccomp_ctx, SCMP_FLTATR_CTL_NNP, 0);\n#else\n\tcheck_seccomp_attr_set = seccomp_attr_set(SCMP_FLTATR_CTL_NNP, 0);\n#endif\n\tif (check_seccomp_attr_set) {\n\t\tERROR(\"Failed to turn off n-new-privs.\");\n\t\treturn -1;\n\t}\n#ifdef SCMP_FLTATR_ATL_TSKIP\n\tif (seccomp_attr_set(conf->seccomp_ctx, SCMP_FLTATR_ATL_TSKIP, 1)) {\n\t\tWARN(\"Failed to turn on seccomp nop-skip, continuing\");\n\t}\n#endif\n\n\tf = fopen(conf->seccomp, \"r\");\n\tif (!f) {\n\t\tSYSERROR(\"Failed to open seccomp policy file %s.\", conf->seccomp);\n\t\treturn -1;\n\t}\n\tret = parse_config(f, conf);\n\tfclose(f);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "path"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->set_config_item",
          "args": [
            "c",
            "\"lxc.seccomp\"",
            "path"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Failed to get running config item for lxc.seccomp.\""
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->get_running_config_item",
          "args": [
            "c",
            "\"lxc.seccomp\""
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->set_config_item",
          "args": [
            "c",
            "\"lxc.seccomp\"",
            "\"\""
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/personality.h>\n#include \"confile.h\"\n#include \"lsm/lsm.h\"\n#include <lxc/lxccontainer.h>\n#include \"lxcseccomp.h\"\n#include \"conf.h\"\n#include \"lxclock.h\"\n#include \"cgroup.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"caps.h\"\n#include \"attach.h\"\n#include \"af_unix.h\"\n#include \"log.h\"\n#include \"namespace.h\"\n#include <pwd.h>\n#include <linux/unistd.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\nstatic bool fetch_seccomp(struct lxc_container *c,\n\t\t\t  lxc_attach_options_t *options)\n{\n\tchar *path;\n\n\tif (!(options->namespaces & CLONE_NEWNS) || !(options->attach_flags & LXC_ATTACH_LSM)) {\n\t\tfree(c->lxc_conf->seccomp);\n\t\tc->lxc_conf->seccomp = NULL;\n\t\treturn true;\n\t}\n\n\t/* Remove current setting. */\n\tif (!c->set_config_item(c, \"lxc.seccomp\", \"\")) {\n\t\treturn false;\n\t}\n\n\t/* Fetch the current profile path over the cmd interface. */\n\tpath = c->get_running_config_item(c, \"lxc.seccomp\");\n\tif (!path) {\n\t\tINFO(\"Failed to get running config item for lxc.seccomp.\");\n\t\treturn true;\n\t}\n\n\t/* Copy the value into the new lxc_conf. */\n\tif (!c->set_config_item(c, \"lxc.seccomp\", path)) {\n\t\tfree(path);\n\t\treturn false;\n\t}\n\tfree(path);\n\n\t/* Attempt to parse the resulting config. */\n\tif (lxc_read_seccomp_config(c->lxc_conf) < 0) {\n\t\tERROR(\"Error reading seccomp policy.\");\n\t\treturn false;\n\t}\n\n\tINFO(\"Retrieved seccomp policy.\");\n\treturn true;\n}"
  },
  {
    "function_name": "lxc_attach_get_init_uidgid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
    "lines": "617-663",
    "snippet": "static void lxc_attach_get_init_uidgid(uid_t* init_uid, gid_t* init_gid)\n{\n\tFILE *proc_file;\n\tchar proc_fn[__PROC_STATUS_LEN];\n\tint ret;\n\tchar *line = NULL;\n\tsize_t line_bufsz = 0;\n\tlong value = -1;\n\tuid_t uid = (uid_t)-1;\n\tgid_t gid = (gid_t)-1;\n\n\t/* Read capabilities. */\n\tsnprintf(proc_fn, __PROC_STATUS_LEN, \"/proc/%d/status\", 1);\n\n\tproc_file = fopen(proc_fn, \"r\");\n\tif (!proc_file)\n\t\treturn;\n\n\twhile (getline(&line, &line_bufsz, proc_file) != -1) {\n\t\t/* Format is: real, effective, saved set user, fs we only care\n\t\t * about real uid.\n\t\t */\n\t\tret = sscanf(line, \"Uid: %ld\", &value);\n\t\tif (ret != EOF && ret == 1) {\n\t\t\tuid = (uid_t) value;\n\t\t} else {\n\t\t\tret = sscanf(line, \"Gid: %ld\", &value);\n\t\t\tif (ret != EOF && ret == 1)\n\t\t\t\tgid = (gid_t) value;\n\t\t}\n\t\tif (uid != (uid_t)-1 && gid != (gid_t)-1)\n\t\t\tbreak;\n\t}\n\n\tfclose(proc_file);\n\tfree(line);\n\n\t/* Only override arguments if we found something. */\n\tif (uid != (uid_t)-1)\n\t\t*init_uid = uid;\n\tif (gid != (gid_t)-1)\n\t\t*init_gid = gid;\n\n\t/* TODO: we should also parse supplementary groups and use\n\t * setgroups() to set them.\n\t */\n}",
    "includes": [
      "#include <sys/personality.h>",
      "#include \"confile.h\"",
      "#include \"lsm/lsm.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include \"lxcseccomp.h\"",
      "#include \"conf.h\"",
      "#include \"lxclock.h\"",
      "#include \"cgroup.h\"",
      "#include \"commands.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include \"caps.h\"",
      "#include \"attach.h\"",
      "#include \"af_unix.h\"",
      "#include \"log.h\"",
      "#include \"namespace.h\"",
      "#include <pwd.h>",
      "#include <linux/unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/mount.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [
      "#define __PROC_STATUS_LEN (5 + (LXC_NUMSTRLEN64) + 7 + 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "line"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "proc_file"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "line",
            "\"Gid: %ld\"",
            "&value"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "line",
            "\"Uid: %ld\"",
            "&value"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&line",
            "&line_bufsz",
            "proc_file"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getline.c",
          "lines": "39-60",
          "snippet": "ssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "proc_fn",
            "\"r\""
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "proc_fn",
            "__PROC_STATUS_LEN",
            "\"/proc/%d/status\"",
            "1"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/personality.h>\n#include \"confile.h\"\n#include \"lsm/lsm.h\"\n#include <lxc/lxccontainer.h>\n#include \"lxcseccomp.h\"\n#include \"conf.h\"\n#include \"lxclock.h\"\n#include \"cgroup.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"caps.h\"\n#include \"attach.h\"\n#include \"af_unix.h\"\n#include \"log.h\"\n#include \"namespace.h\"\n#include <pwd.h>\n#include <linux/unistd.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\n#define __PROC_STATUS_LEN (5 + (LXC_NUMSTRLEN64) + 7 + 1)\n\nstatic void lxc_attach_get_init_uidgid(uid_t* init_uid, gid_t* init_gid)\n{\n\tFILE *proc_file;\n\tchar proc_fn[__PROC_STATUS_LEN];\n\tint ret;\n\tchar *line = NULL;\n\tsize_t line_bufsz = 0;\n\tlong value = -1;\n\tuid_t uid = (uid_t)-1;\n\tgid_t gid = (gid_t)-1;\n\n\t/* Read capabilities. */\n\tsnprintf(proc_fn, __PROC_STATUS_LEN, \"/proc/%d/status\", 1);\n\n\tproc_file = fopen(proc_fn, \"r\");\n\tif (!proc_file)\n\t\treturn;\n\n\twhile (getline(&line, &line_bufsz, proc_file) != -1) {\n\t\t/* Format is: real, effective, saved set user, fs we only care\n\t\t * about real uid.\n\t\t */\n\t\tret = sscanf(line, \"Uid: %ld\", &value);\n\t\tif (ret != EOF && ret == 1) {\n\t\t\tuid = (uid_t) value;\n\t\t} else {\n\t\t\tret = sscanf(line, \"Gid: %ld\", &value);\n\t\t\tif (ret != EOF && ret == 1)\n\t\t\t\tgid = (gid_t) value;\n\t\t}\n\t\tif (uid != (uid_t)-1 && gid != (gid_t)-1)\n\t\t\tbreak;\n\t}\n\n\tfclose(proc_file);\n\tfree(line);\n\n\t/* Only override arguments if we found something. */\n\tif (uid != (uid_t)-1)\n\t\t*init_uid = uid;\n\tif (gid != (gid_t)-1)\n\t\t*init_gid = gid;\n\n\t/* TODO: we should also parse supplementary groups and use\n\t * setgroups() to set them.\n\t */\n}"
  },
  {
    "function_name": "lxc_attach_getpwshell",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
    "lines": "469-615",
    "snippet": "static char *lxc_attach_getpwshell(uid_t uid)\n{\n\tpid_t pid;\n\tint pipes[2];\n\tint ret;\n\tint fd;\n\tchar *result = NULL;\n\n\t/* We need to fork off a process that runs the getent program, and we\n\t * need to capture its output, so we use a pipe for that purpose.\n\t */\n\tret = pipe(pipes);\n\tif (ret < 0)\n\t\treturn NULL;\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tclose(pipes[0]);\n\t\tclose(pipes[1]);\n\t\treturn NULL;\n\t}\n\n\tif (pid) {\n\t\tFILE *pipe_f;\n\t\tchar *line = NULL;\n\t\tsize_t line_bufsz = 0;\n\t\tint found = 0;\n\t\tint status;\n\n\t\tclose(pipes[1]);\n\n\t\tpipe_f = fdopen(pipes[0], \"r\");\n\t\twhile (getline(&line, &line_bufsz, pipe_f) != -1) {\n\t\t\tchar *token;\n\t\t\tchar *saveptr = NULL;\n\t\t\tlong value;\n\t\t\tchar *endptr = NULL;\n\t\t\tint i;\n\n\t\t\t/* If we already found something, just continue to read\n\t\t\t * until the pipe doesn't deliver any more data, but\n\t\t\t * don't modify the existing data structure.\n\t\t\t */\n\t\t\tif (found)\n\t\t\t\tcontinue;\n\n\t\t\t/* Trim line on the right hand side. */\n\t\t\tfor (i = strlen(line); i > 0 && (line[i - 1] == '\\n' || line[i - 1] == '\\r'); --i)\n\t\t\t\tline[i - 1] = '\\0';\n\n\t\t\t/* Split into tokens: first: user name. */\n\t\t\ttoken = strtok_r(line, \":\", &saveptr);\n\t\t\tif (!token)\n\t\t\t\tcontinue;\n\t\t\t/* next: dummy password field */\n\t\t\ttoken = strtok_r(NULL, \":\", &saveptr);\n\t\t\tif (!token)\n\t\t\t\tcontinue;\n\t\t\t/* next: user id */\n\t\t\ttoken = strtok_r(NULL, \":\", &saveptr);\n\t\t\tvalue = token ? strtol(token, &endptr, 10) : 0;\n\t\t\tif (!token || !endptr || *endptr || value == LONG_MIN || value == LONG_MAX)\n\t\t\t\tcontinue;\n\t\t\t/* dummy sanity check: user id matches */\n\t\t\tif ((uid_t) value != uid)\n\t\t\t\tcontinue;\n\t\t\t/* skip fields: gid, gecos, dir, go to next field 'shell' */\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\ttoken = strtok_r(NULL, \":\", &saveptr);\n\t\t\t\tif (!token)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!token)\n\t\t\t\tcontinue;\n\t\t\tfree(result);\n\t\t\tresult = strdup(token);\n\n\t\t\t/* Sanity check that there are no fields after that. */\n\t\t\ttoken = strtok_r(NULL, \":\", &saveptr);\n\t\t\tif (token)\n\t\t\t\tcontinue;\n\n\t\t\tfound = 1;\n\t\t}\n\n\t\tfree(line);\n\t\tfclose(pipe_f);\n\tagain:\n\t\tif (waitpid(pid, &status, 0) < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tgoto again;\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* Some sanity checks. If anything even hinted at going wrong,\n\t\t * we can't be sure we have a valid result, so we assume we\n\t\t * don't.\n\t\t */\n\n\t\tif (!WIFEXITED(status))\n\t\t\treturn NULL;\n\n\t\tif (WEXITSTATUS(status) != 0)\n\t\t\treturn NULL;\n\n\t\tif (!found)\n\t\t\treturn NULL;\n\n\t\treturn result;\n\t} else {\n\t\tchar uid_buf[32];\n\t\tchar *arguments[] = {\n\t\t\t\"getent\",\n\t\t\t\"passwd\",\n\t\t\tuid_buf,\n\t\t\tNULL\n\t\t};\n\n\t\tclose(pipes[0]);\n\n\t\t/* We want to capture stdout. */\n\t\tdup2(pipes[1], 1);\n\t\tclose(pipes[1]);\n\n\t\t/* Get rid of stdin/stderr, so we try to associate it with\n\t\t * /dev/null.\n\t\t */\n\t\tfd = open(\"/dev/null\", O_RDWR);\n\t\tif (fd < 0) {\n\t\t\tclose(0);\n\t\t\tclose(2);\n\t\t} else {\n\t\t\tdup2(fd, 0);\n\t\t\tdup2(fd, 2);\n\t\t\tclose(fd);\n\t\t}\n\n\t\t/* Finish argument list. */\n\t\tret = snprintf(uid_buf, sizeof(uid_buf), \"%ld\", (long) uid);\n\t\tif (ret <= 0)\n\t\t\texit(-1);\n\n\t\t/* Try to run getent program. */\n\t\t(void) execvp(\"getent\", arguments);\n\t\texit(-1);\n\t}\n}",
    "includes": [
      "#include <sys/personality.h>",
      "#include \"confile.h\"",
      "#include \"lsm/lsm.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include \"lxcseccomp.h\"",
      "#include \"conf.h\"",
      "#include \"lxclock.h\"",
      "#include \"cgroup.h\"",
      "#include \"commands.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include \"caps.h\"",
      "#include \"attach.h\"",
      "#include \"af_unix.h\"",
      "#include \"log.h\"",
      "#include \"namespace.h\"",
      "#include <pwd.h>",
      "#include <linux/unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/mount.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int attach_child_main(void* data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "-1"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "\"getent\"",
            "arguments"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "-1"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "uid_buf",
            "sizeof(uid_buf)",
            "\"%ld\"",
            "(long) uid"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd",
            "2"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd",
            "0"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/dev/null\"",
            "O_RDWR"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "genetlink_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/genl.c",
          "lines": "106-116",
          "snippet": "extern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"genl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/genetlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"genl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "pipes[1]",
            "1"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "0"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "pipe_f"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "line"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "NULL",
            "\":\"",
            "&saveptr"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "token"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "NULL",
            "\":\"",
            "&saveptr"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "token",
            "&endptr",
            "10"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "NULL",
            "\":\"",
            "&saveptr"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "NULL",
            "\":\"",
            "&saveptr"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "line",
            "\":\"",
            "&saveptr"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "line"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&line",
            "&line_bufsz",
            "pipe_f"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getline.c",
          "lines": "39-60",
          "snippet": "ssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdopen",
          "args": [
            "pipes[0]",
            "\"r\""
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "pipes"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/personality.h>\n#include \"confile.h\"\n#include \"lsm/lsm.h\"\n#include <lxc/lxccontainer.h>\n#include \"lxcseccomp.h\"\n#include \"conf.h\"\n#include \"lxclock.h\"\n#include \"cgroup.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"caps.h\"\n#include \"attach.h\"\n#include \"af_unix.h\"\n#include \"log.h\"\n#include \"namespace.h\"\n#include <pwd.h>\n#include <linux/unistd.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\nstatic int attach_child_main(void* data);\n\nstatic char *lxc_attach_getpwshell(uid_t uid)\n{\n\tpid_t pid;\n\tint pipes[2];\n\tint ret;\n\tint fd;\n\tchar *result = NULL;\n\n\t/* We need to fork off a process that runs the getent program, and we\n\t * need to capture its output, so we use a pipe for that purpose.\n\t */\n\tret = pipe(pipes);\n\tif (ret < 0)\n\t\treturn NULL;\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tclose(pipes[0]);\n\t\tclose(pipes[1]);\n\t\treturn NULL;\n\t}\n\n\tif (pid) {\n\t\tFILE *pipe_f;\n\t\tchar *line = NULL;\n\t\tsize_t line_bufsz = 0;\n\t\tint found = 0;\n\t\tint status;\n\n\t\tclose(pipes[1]);\n\n\t\tpipe_f = fdopen(pipes[0], \"r\");\n\t\twhile (getline(&line, &line_bufsz, pipe_f) != -1) {\n\t\t\tchar *token;\n\t\t\tchar *saveptr = NULL;\n\t\t\tlong value;\n\t\t\tchar *endptr = NULL;\n\t\t\tint i;\n\n\t\t\t/* If we already found something, just continue to read\n\t\t\t * until the pipe doesn't deliver any more data, but\n\t\t\t * don't modify the existing data structure.\n\t\t\t */\n\t\t\tif (found)\n\t\t\t\tcontinue;\n\n\t\t\t/* Trim line on the right hand side. */\n\t\t\tfor (i = strlen(line); i > 0 && (line[i - 1] == '\\n' || line[i - 1] == '\\r'); --i)\n\t\t\t\tline[i - 1] = '\\0';\n\n\t\t\t/* Split into tokens: first: user name. */\n\t\t\ttoken = strtok_r(line, \":\", &saveptr);\n\t\t\tif (!token)\n\t\t\t\tcontinue;\n\t\t\t/* next: dummy password field */\n\t\t\ttoken = strtok_r(NULL, \":\", &saveptr);\n\t\t\tif (!token)\n\t\t\t\tcontinue;\n\t\t\t/* next: user id */\n\t\t\ttoken = strtok_r(NULL, \":\", &saveptr);\n\t\t\tvalue = token ? strtol(token, &endptr, 10) : 0;\n\t\t\tif (!token || !endptr || *endptr || value == LONG_MIN || value == LONG_MAX)\n\t\t\t\tcontinue;\n\t\t\t/* dummy sanity check: user id matches */\n\t\t\tif ((uid_t) value != uid)\n\t\t\t\tcontinue;\n\t\t\t/* skip fields: gid, gecos, dir, go to next field 'shell' */\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\ttoken = strtok_r(NULL, \":\", &saveptr);\n\t\t\t\tif (!token)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!token)\n\t\t\t\tcontinue;\n\t\t\tfree(result);\n\t\t\tresult = strdup(token);\n\n\t\t\t/* Sanity check that there are no fields after that. */\n\t\t\ttoken = strtok_r(NULL, \":\", &saveptr);\n\t\t\tif (token)\n\t\t\t\tcontinue;\n\n\t\t\tfound = 1;\n\t\t}\n\n\t\tfree(line);\n\t\tfclose(pipe_f);\n\tagain:\n\t\tif (waitpid(pid, &status, 0) < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tgoto again;\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* Some sanity checks. If anything even hinted at going wrong,\n\t\t * we can't be sure we have a valid result, so we assume we\n\t\t * don't.\n\t\t */\n\n\t\tif (!WIFEXITED(status))\n\t\t\treturn NULL;\n\n\t\tif (WEXITSTATUS(status) != 0)\n\t\t\treturn NULL;\n\n\t\tif (!found)\n\t\t\treturn NULL;\n\n\t\treturn result;\n\t} else {\n\t\tchar uid_buf[32];\n\t\tchar *arguments[] = {\n\t\t\t\"getent\",\n\t\t\t\"passwd\",\n\t\t\tuid_buf,\n\t\t\tNULL\n\t\t};\n\n\t\tclose(pipes[0]);\n\n\t\t/* We want to capture stdout. */\n\t\tdup2(pipes[1], 1);\n\t\tclose(pipes[1]);\n\n\t\t/* Get rid of stdin/stderr, so we try to associate it with\n\t\t * /dev/null.\n\t\t */\n\t\tfd = open(\"/dev/null\", O_RDWR);\n\t\tif (fd < 0) {\n\t\t\tclose(0);\n\t\t\tclose(2);\n\t\t} else {\n\t\t\tdup2(fd, 0);\n\t\t\tdup2(fd, 2);\n\t\t\tclose(fd);\n\t\t}\n\n\t\t/* Finish argument list. */\n\t\tret = snprintf(uid_buf, sizeof(uid_buf), \"%ld\", (long) uid);\n\t\tif (ret <= 0)\n\t\t\texit(-1);\n\n\t\t/* Try to run getent program. */\n\t\t(void) execvp(\"getent\", arguments);\n\t\texit(-1);\n\t}\n}"
  },
  {
    "function_name": "lxc_attach_set_environment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
    "lines": "372-467",
    "snippet": "static int lxc_attach_set_environment(enum lxc_attach_env_policy_t policy, char** extra_env, char** extra_keep)\n{\n\tif (policy == LXC_ATTACH_CLEAR_ENV) {\n\t\tchar **extra_keep_store = NULL;\n\t\tint path_kept = 0;\n\n\t\tif (extra_keep) {\n\t\t\tsize_t count, i;\n\n\t\t\tfor (count = 0; extra_keep[count]; count++);\n\n\t\t\textra_keep_store = calloc(count, sizeof(char *));\n\t\t\tif (!extra_keep_store) {\n\t\t\t\tSYSERROR(\"Failed to allocate memory for storing current \"\n\t\t\t\t         \"environment variable values that will be kept.\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tchar *v = getenv(extra_keep[i]);\n\t\t\t\tif (v) {\n\t\t\t\t\textra_keep_store[i] = strdup(v);\n\t\t\t\t\tif (!extra_keep_store[i]) {\n\t\t\t\t\t\tSYSERROR(\"Failed to allocate memory for storing current \"\n\t\t\t\t\t\t         \"environment variable values that will be kept.\");\n\t\t\t\t\t\twhile (i > 0)\n\t\t\t\t\t\t\tfree(extra_keep_store[--i]);\n\t\t\t\t\t\tfree(extra_keep_store);\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (strcmp(extra_keep[i], \"PATH\") == 0)\n\t\t\t\t\t\tpath_kept = 1;\n\t\t\t\t}\n\t\t\t\t/* Calloc sets entire array to zero, so we don't\n\t\t\t\t * need an else.\n\t\t\t\t */\n\t\t\t}\n\t\t}\n\n\t\tif (clearenv()) {\n\t\t\tchar **p;\n\t\t\tSYSERROR(\"Failed to clear environment.\");\n\t\t\tif (extra_keep_store) {\n\t\t\t\tfor (p = extra_keep_store; *p; p++)\n\t\t\t\t\tfree(*p);\n\t\t\t\tfree(extra_keep_store);\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (extra_keep_store) {\n\t\t\tsize_t i;\n\t\t\tfor (i = 0; extra_keep[i]; i++) {\n\t\t\t\tif (extra_keep_store[i]) {\n\t\t\t\t\tif (setenv(extra_keep[i], extra_keep_store[i], 1) < 0)\n\t\t\t\t\t\tSYSERROR(\"Unable to set environment variable.\");\n\t\t\t\t}\n\t\t\t\tfree(extra_keep_store[i]);\n\t\t\t}\n\t\t\tfree(extra_keep_store);\n\t\t}\n\n\t\t/* Always set a default path; shells and execlp tend to be fine\n\t\t * without it, but there is a disturbing number of C programs\n\t\t * out there that just assume that getenv(\"PATH\") is never NULL\n\t\t * and then die a painful segfault death.\n\t\t */\n\t\tif (!path_kept)\n\t\t\tsetenv(\"PATH\", \"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", 1);\n\t}\n\n\tif (putenv(\"container=lxc\")) {\n\t\tSYSERROR(\"Failed to set environment variable.\");\n\t\treturn -1;\n\t}\n\n\t/* Set extra environment variables. */\n\tif (extra_env) {\n\t\tfor (; *extra_env; extra_env++) {\n\t\t\t/* Duplicate the string, just to be on the safe side,\n\t\t\t * because putenv does not do it for us.\n\t\t\t */\n\t\t\tchar *p = strdup(*extra_env);\n\t\t\t/* We just assume the user knows what they are doing, so\n\t\t\t * we don't do any checks.\n\t\t\t */\n\t\t\tif (!p) {\n\t\t\t\tSYSERROR(\"Failed to allocate memory for additional environment \"\n\t\t\t\t         \"variables.\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tputenv(p);\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <sys/personality.h>",
      "#include \"confile.h\"",
      "#include \"lsm/lsm.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include \"lxcseccomp.h\"",
      "#include \"conf.h\"",
      "#include \"lxclock.h\"",
      "#include \"cgroup.h\"",
      "#include \"commands.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include \"caps.h\"",
      "#include \"attach.h\"",
      "#include \"af_unix.h\"",
      "#include \"log.h\"",
      "#include \"namespace.h\"",
      "#include <pwd.h>",
      "#include <linux/unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/mount.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "putenv",
          "args": [
            "p"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to allocate memory for additional environment \"\n\t\t\t\t         \"variables.\""
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "*extra_env"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to set environment variable.\""
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "putenv",
          "args": [
            "\"container=lxc\""
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"PATH\"",
            "\"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\"",
            "1"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "extra_keep_store"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Unable to set environment variable.\""
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "extra_keep[i]",
            "extra_keep_store[i]",
            "1"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to clear environment.\""
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clearenv",
          "args": [],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "extra_keep[i]",
            "\"PATH\""
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to allocate memory for storing current \"\n\t\t\t\t\t\t         \"environment variable values that will be kept.\""
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "v"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "extra_keep[i]"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to allocate memory for storing current \"\n\t\t\t\t         \"environment variable values that will be kept.\""
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "count",
            "sizeof(char *)"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/personality.h>\n#include \"confile.h\"\n#include \"lsm/lsm.h\"\n#include <lxc/lxccontainer.h>\n#include \"lxcseccomp.h\"\n#include \"conf.h\"\n#include \"lxclock.h\"\n#include \"cgroup.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"caps.h\"\n#include \"attach.h\"\n#include \"af_unix.h\"\n#include \"log.h\"\n#include \"namespace.h\"\n#include <pwd.h>\n#include <linux/unistd.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\nstatic int lxc_attach_set_environment(enum lxc_attach_env_policy_t policy, char** extra_env, char** extra_keep)\n{\n\tif (policy == LXC_ATTACH_CLEAR_ENV) {\n\t\tchar **extra_keep_store = NULL;\n\t\tint path_kept = 0;\n\n\t\tif (extra_keep) {\n\t\t\tsize_t count, i;\n\n\t\t\tfor (count = 0; extra_keep[count]; count++);\n\n\t\t\textra_keep_store = calloc(count, sizeof(char *));\n\t\t\tif (!extra_keep_store) {\n\t\t\t\tSYSERROR(\"Failed to allocate memory for storing current \"\n\t\t\t\t         \"environment variable values that will be kept.\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tchar *v = getenv(extra_keep[i]);\n\t\t\t\tif (v) {\n\t\t\t\t\textra_keep_store[i] = strdup(v);\n\t\t\t\t\tif (!extra_keep_store[i]) {\n\t\t\t\t\t\tSYSERROR(\"Failed to allocate memory for storing current \"\n\t\t\t\t\t\t         \"environment variable values that will be kept.\");\n\t\t\t\t\t\twhile (i > 0)\n\t\t\t\t\t\t\tfree(extra_keep_store[--i]);\n\t\t\t\t\t\tfree(extra_keep_store);\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (strcmp(extra_keep[i], \"PATH\") == 0)\n\t\t\t\t\t\tpath_kept = 1;\n\t\t\t\t}\n\t\t\t\t/* Calloc sets entire array to zero, so we don't\n\t\t\t\t * need an else.\n\t\t\t\t */\n\t\t\t}\n\t\t}\n\n\t\tif (clearenv()) {\n\t\t\tchar **p;\n\t\t\tSYSERROR(\"Failed to clear environment.\");\n\t\t\tif (extra_keep_store) {\n\t\t\t\tfor (p = extra_keep_store; *p; p++)\n\t\t\t\t\tfree(*p);\n\t\t\t\tfree(extra_keep_store);\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (extra_keep_store) {\n\t\t\tsize_t i;\n\t\t\tfor (i = 0; extra_keep[i]; i++) {\n\t\t\t\tif (extra_keep_store[i]) {\n\t\t\t\t\tif (setenv(extra_keep[i], extra_keep_store[i], 1) < 0)\n\t\t\t\t\t\tSYSERROR(\"Unable to set environment variable.\");\n\t\t\t\t}\n\t\t\t\tfree(extra_keep_store[i]);\n\t\t\t}\n\t\t\tfree(extra_keep_store);\n\t\t}\n\n\t\t/* Always set a default path; shells and execlp tend to be fine\n\t\t * without it, but there is a disturbing number of C programs\n\t\t * out there that just assume that getenv(\"PATH\") is never NULL\n\t\t * and then die a painful segfault death.\n\t\t */\n\t\tif (!path_kept)\n\t\t\tsetenv(\"PATH\", \"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", 1);\n\t}\n\n\tif (putenv(\"container=lxc\")) {\n\t\tSYSERROR(\"Failed to set environment variable.\");\n\t\treturn -1;\n\t}\n\n\t/* Set extra environment variables. */\n\tif (extra_env) {\n\t\tfor (; *extra_env; extra_env++) {\n\t\t\t/* Duplicate the string, just to be on the safe side,\n\t\t\t * because putenv does not do it for us.\n\t\t\t */\n\t\t\tchar *p = strdup(*extra_env);\n\t\t\t/* We just assume the user knows what they are doing, so\n\t\t\t * we don't do any checks.\n\t\t\t */\n\t\t\tif (!p) {\n\t\t\t\tSYSERROR(\"Failed to allocate memory for additional environment \"\n\t\t\t\t         \"variables.\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tputenv(p);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_attach_drop_privs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
    "lines": "354-370",
    "snippet": "static int lxc_attach_drop_privs(struct lxc_proc_context_info *ctx)\n{\n\tint last_cap = lxc_caps_last_cap();\n\tint cap;\n\n\tfor (cap = 0; cap <= last_cap; cap++) {\n\t\tif (ctx->capability_mask & (1LL << cap))\n\t\t\tcontinue;\n\n\t\tif (prctl(PR_CAPBSET_DROP, cap, 0, 0, 0)) {\n\t\t\tSYSERROR(\"Failed to remove capability id %d.\", cap);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <sys/personality.h>",
      "#include \"confile.h\"",
      "#include \"lsm/lsm.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include \"lxcseccomp.h\"",
      "#include \"conf.h\"",
      "#include \"lxclock.h\"",
      "#include \"cgroup.h\"",
      "#include \"commands.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include \"caps.h\"",
      "#include \"attach.h\"",
      "#include \"af_unix.h\"",
      "#include \"log.h\"",
      "#include \"namespace.h\"",
      "#include <pwd.h>",
      "#include <linux/unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/mount.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [
      "#define PR_CAPBSET_DROP 24"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to remove capability id %d.\"",
            "cap"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prctl",
          "args": [
            "PR_CAPBSET_DROP",
            "cap",
            "0",
            "0",
            "0"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_caps_last_cap",
          "args": [],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_caps_last_cap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/caps.h",
          "lines": "51-53",
          "snippet": "static inline int lxc_caps_last_cap(void) {\n\treturn 0;\n}",
          "includes": [
            "#include <sys/capability.h>",
            "#include <stdbool.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/capability.h>\n#include <stdbool.h>\n#include \"config.h\"\n\nstatic inline int lxc_caps_last_cap(void) {\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/personality.h>\n#include \"confile.h\"\n#include \"lsm/lsm.h\"\n#include <lxc/lxccontainer.h>\n#include \"lxcseccomp.h\"\n#include \"conf.h\"\n#include \"lxclock.h\"\n#include \"cgroup.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"caps.h\"\n#include \"attach.h\"\n#include \"af_unix.h\"\n#include \"log.h\"\n#include \"namespace.h\"\n#include <pwd.h>\n#include <linux/unistd.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\n#define PR_CAPBSET_DROP 24\n\nstatic int lxc_attach_drop_privs(struct lxc_proc_context_info *ctx)\n{\n\tint last_cap = lxc_caps_last_cap();\n\tint cap;\n\n\tfor (cap = 0; cap <= last_cap; cap++) {\n\t\tif (ctx->capability_mask & (1LL << cap))\n\t\t\tcontinue;\n\n\t\tif (prctl(PR_CAPBSET_DROP, cap, 0, 0, 0)) {\n\t\t\tSYSERROR(\"Failed to remove capability id %d.\", cap);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_attach_remount_sys_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
    "lines": "305-352",
    "snippet": "static int lxc_attach_remount_sys_proc(void)\n{\n\tint ret;\n\n\tret = unshare(CLONE_NEWNS);\n\tif (ret < 0) {\n\t\tSYSERROR(\"Failed to unshare mount namespace.\");\n\t\treturn -1;\n\t}\n\n\tif (detect_shared_rootfs()) {\n\t\tif (mount(NULL, \"/\", NULL, MS_SLAVE|MS_REC, NULL)) {\n\t\t\tSYSERROR(\"Failed to make / rslave.\");\n\t\t\tERROR(\"Continuing...\");\n\t\t}\n\t}\n\n\t/* Assume /proc is always mounted, so remount it. */\n\tret = umount2(\"/proc\", MNT_DETACH);\n\tif (ret < 0) {\n\t\tSYSERROR(\"Failed to unmount /proc.\");\n\t\treturn -1;\n\t}\n\n\tret = mount(\"none\", \"/proc\", \"proc\", 0, NULL);\n\tif (ret < 0) {\n\t\tSYSERROR(\"Failed to remount /proc.\");\n\t\treturn -1;\n\t}\n\n\t/* Try to umount /sys. If it's not a mount point, we'll get EINVAL, then\n\t * we ignore it because it may not have been mounted in the first place.\n\t */\n\tret = umount2(\"/sys\", MNT_DETACH);\n\tif (ret < 0 && errno != EINVAL) {\n\t\tSYSERROR(\"Failed to unmount /sys.\");\n\t\treturn -1;\n\t} else if (ret == 0) {\n\t\t/* Remount it. */\n\t\tret = mount(\"none\", \"/sys\", \"sysfs\", 0, NULL);\n\t\tif (ret < 0) {\n\t\t\tSYSERROR(\"Failed to remount /sys.\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <sys/personality.h>",
      "#include \"confile.h\"",
      "#include \"lsm/lsm.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include \"lxcseccomp.h\"",
      "#include \"conf.h\"",
      "#include \"lxclock.h\"",
      "#include \"cgroup.h\"",
      "#include \"commands.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include \"caps.h\"",
      "#include \"attach.h\"",
      "#include \"af_unix.h\"",
      "#include \"log.h\"",
      "#include \"namespace.h\"",
      "#include <pwd.h>",
      "#include <linux/unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/mount.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [
      "#define MS_SLAVE (1<<19)",
      "#define MS_REC 16384"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to remount /sys.\""
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"none\"",
            "\"/sys\"",
            "\"sysfs\"",
            "0",
            "NULL"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "mount_entry_on_generic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1838-1869",
          "snippet": "static inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to unmount /sys.\""
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umount2",
          "args": [
            "\"/sys\"",
            "MNT_DETACH"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to remount /proc.\""
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to unmount /proc.\""
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umount2",
          "args": [
            "\"/proc\"",
            "MNT_DETACH"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Continuing...\""
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to make / rslave.\""
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "detect_shared_rootfs",
          "args": [],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "detect_shared_rootfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1102-1132",
          "snippet": "int detect_shared_rootfs(void)\n{\n\tchar buf[LXC_LINELEN], *p;\n\tFILE *f;\n\tint i;\n\tchar *p2;\n\n\tf = fopen(\"/proc/self/mountinfo\", \"r\");\n\tif (!f)\n\t\treturn 0;\n\twhile (fgets(buf, LXC_LINELEN, f)) {\n\t\tfor (p = buf, i = 0; p && i < 4; i++)\n\t\t\tp = strchr(p + 1, ' ');\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tp2 = strchr(p + 1, ' ');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\t\tif (strcmp(p + 1, \"/\") == 0) {\n\t\t\t// this is '/'.  is it shared?\n\t\t\tp = strchr(p2 + 1, ' ');\n\t\t\tif (p && strstr(p, \"shared:\")) {\n\t\t\t\tfclose(f);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tfclose(f);\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint detect_shared_rootfs(void)\n{\n\tchar buf[LXC_LINELEN], *p;\n\tFILE *f;\n\tint i;\n\tchar *p2;\n\n\tf = fopen(\"/proc/self/mountinfo\", \"r\");\n\tif (!f)\n\t\treturn 0;\n\twhile (fgets(buf, LXC_LINELEN, f)) {\n\t\tfor (p = buf, i = 0; p && i < 4; i++)\n\t\t\tp = strchr(p + 1, ' ');\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tp2 = strchr(p + 1, ' ');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\t\tif (strcmp(p + 1, \"/\") == 0) {\n\t\t\t// this is '/'.  is it shared?\n\t\t\tp = strchr(p2 + 1, ' ');\n\t\t\tif (p && strstr(p, \"shared:\")) {\n\t\t\t\tfclose(f);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tfclose(f);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to unshare mount namespace.\""
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unshare",
          "args": [
            "CLONE_NEWNS"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "unshare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.h",
          "lines": "73-81",
          "snippet": "static inline int unshare(int flags)\n{\n#ifdef __NR_unshare\n\treturn syscall(__NR_unshare, flags);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}",
          "includes": [
            "#include <stdint.h>",
            "#  include <sys/signalfd.h>",
            "#include <../include/getline.h>",
            "#include \"initutils.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#  include <sys/signalfd.h>\n#include <../include/getline.h>\n#include \"initutils.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic inline int unshare(int flags)\n{\n#ifdef __NR_unshare\n\treturn syscall(__NR_unshare, flags);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/personality.h>\n#include \"confile.h\"\n#include \"lsm/lsm.h\"\n#include <lxc/lxccontainer.h>\n#include \"lxcseccomp.h\"\n#include \"conf.h\"\n#include \"lxclock.h\"\n#include \"cgroup.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"caps.h\"\n#include \"attach.h\"\n#include \"af_unix.h\"\n#include \"log.h\"\n#include \"namespace.h\"\n#include <pwd.h>\n#include <linux/unistd.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\n#define MS_SLAVE (1<<19)\n#define MS_REC 16384\n\nstatic int lxc_attach_remount_sys_proc(void)\n{\n\tint ret;\n\n\tret = unshare(CLONE_NEWNS);\n\tif (ret < 0) {\n\t\tSYSERROR(\"Failed to unshare mount namespace.\");\n\t\treturn -1;\n\t}\n\n\tif (detect_shared_rootfs()) {\n\t\tif (mount(NULL, \"/\", NULL, MS_SLAVE|MS_REC, NULL)) {\n\t\t\tSYSERROR(\"Failed to make / rslave.\");\n\t\t\tERROR(\"Continuing...\");\n\t\t}\n\t}\n\n\t/* Assume /proc is always mounted, so remount it. */\n\tret = umount2(\"/proc\", MNT_DETACH);\n\tif (ret < 0) {\n\t\tSYSERROR(\"Failed to unmount /proc.\");\n\t\treturn -1;\n\t}\n\n\tret = mount(\"none\", \"/proc\", \"proc\", 0, NULL);\n\tif (ret < 0) {\n\t\tSYSERROR(\"Failed to remount /proc.\");\n\t\treturn -1;\n\t}\n\n\t/* Try to umount /sys. If it's not a mount point, we'll get EINVAL, then\n\t * we ignore it because it may not have been mounted in the first place.\n\t */\n\tret = umount2(\"/sys\", MNT_DETACH);\n\tif (ret < 0 && errno != EINVAL) {\n\t\tSYSERROR(\"Failed to unmount /sys.\");\n\t\treturn -1;\n\t} else if (ret == 0) {\n\t\t/* Remount it. */\n\t\tret = mount(\"none\", \"/sys\", \"sysfs\", 0, NULL);\n\t\tif (ret < 0) {\n\t\t\tSYSERROR(\"Failed to remount /sys.\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_attach_to_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
    "lines": "248-303",
    "snippet": "static int lxc_attach_to_ns(pid_t pid, int which)\n{\n\tint fd[LXC_NS_MAX];\n\tint i, j, saved_errno;\n\n\n\tif (access(\"/proc/self/ns\", X_OK)) {\n\t\tERROR(\"Does this kernel version support namespaces?\");\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\t/* Ignore if we are not supposed to attach to that namespace. */\n\t\tif (which != -1 && !(which & ns_info[i].clone_flag)) {\n\t\t\tfd[i] = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfd[i] = lxc_preserve_ns(pid, ns_info[i].proc_name);\n\t\tif (fd[i] < 0) {\n\t\t\tsaved_errno = errno;\n\n\t\t\t/* Close all already opened file descriptors before we\n\t\t\t * return an error, so we don't leak them.\n\t\t\t */\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tclose(fd[j]);\n\n\t\t\terrno = saved_errno;\n\t\t\tSYSERROR(\"Failed to open namespace: \\\"%s\\\".\", ns_info[i].proc_name);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (fd[i] < 0)\n\t\t\tcontinue;\n\n\t\tif (setns(fd[i], 0) < 0) {\n\t\t\tsaved_errno = errno;\n\n\t\t\tfor (j = i; j < LXC_NS_MAX; j++)\n\t\t\t\tclose(fd[j]);\n\n\t\t\terrno = saved_errno;\n\t\t\tSYSERROR(\"Failed to attach to namespace \\\"%s\\\".\", ns_info[i].proc_name);\n\t\t\treturn -1;\n\t\t}\n\n\t\tDEBUG(\"Attached to namespace \\\"%s\\\".\", ns_info[i].proc_name);\n\n\t\tclose(fd[i]);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <sys/personality.h>",
      "#include \"confile.h\"",
      "#include \"lsm/lsm.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include \"lxcseccomp.h\"",
      "#include \"conf.h\"",
      "#include \"lxclock.h\"",
      "#include \"cgroup.h\"",
      "#include \"commands.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include \"caps.h\"",
      "#include \"attach.h\"",
      "#include \"af_unix.h\"",
      "#include \"log.h\"",
      "#include \"namespace.h\"",
      "#include <pwd.h>",
      "#include <linux/unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/mount.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd[i]"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Attached to namespace \\\"%s\\\".\"",
            "ns_info[i].proc_name"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to attach to namespace \\\"%s\\\".\"",
            "ns_info[i].proc_name"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setns",
          "args": [
            "fd[i]",
            "0"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "setns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.h",
          "lines": "58-68",
          "snippet": "static inline int setns(int fd, int nstype)\n{\n#ifdef __NR_setns\n\treturn syscall(__NR_setns, fd, nstype);\n#elif defined(__NR_set_ns)\n\treturn syscall(__NR_set_ns, fd, nstype);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}",
          "includes": [
            "#include <stdint.h>",
            "#  include <sys/signalfd.h>",
            "#include <../include/getline.h>",
            "#include \"initutils.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#  include <sys/signalfd.h>\n#include <../include/getline.h>\n#include \"initutils.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic inline int setns(int fd, int nstype)\n{\n#ifdef __NR_setns\n\treturn syscall(__NR_setns, fd, nstype);\n#elif defined(__NR_set_ns)\n\treturn syscall(__NR_set_ns, fd, nstype);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to open namespace: \\\"%s\\\".\"",
            "ns_info[i].proc_name"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_preserve_ns",
          "args": [
            "pid",
            "ns_info[i].proc_name"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_preserve_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1965-1983",
          "snippet": "int lxc_preserve_ns(const int pid, const char *ns)\n{\n\tint ret;\n/* 5 /proc + 21 /int_as_str + 3 /ns + 20 /NS_NAME + 1 \\0 */\n#define __NS_PATH_LEN 50\n\tchar path[__NS_PATH_LEN];\n\n\t/* This way we can use this function to also check whether namespaces\n\t * are supported by the kernel by passing in the NULL or the empty\n\t * string.\n\t */\n\tret = snprintf(path, __NS_PATH_LEN, \"/proc/%d/ns%s%s\", pid,\n\t\t       !ns || strcmp(ns, \"\") == 0 ? \"\" : \"/\",\n\t\t       !ns || strcmp(ns, \"\") == 0 ? \"\" : ns);\n\tif (ret < 0 || (size_t)ret >= __NS_PATH_LEN)\n\t\treturn -1;\n\n\treturn open(path, O_RDONLY | O_CLOEXEC);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define __NS_PATH_LEN 50"
          ],
          "globals_used": [
            "extern bool btrfs_try_remove_subvol(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\n#define __NS_PATH_LEN 50\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nint lxc_preserve_ns(const int pid, const char *ns)\n{\n\tint ret;\n/* 5 /proc + 21 /int_as_str + 3 /ns + 20 /NS_NAME + 1 \\0 */\n#define __NS_PATH_LEN 50\n\tchar path[__NS_PATH_LEN];\n\n\t/* This way we can use this function to also check whether namespaces\n\t * are supported by the kernel by passing in the NULL or the empty\n\t * string.\n\t */\n\tret = snprintf(path, __NS_PATH_LEN, \"/proc/%d/ns%s%s\", pid,\n\t\t       !ns || strcmp(ns, \"\") == 0 ? \"\" : \"/\",\n\t\t       !ns || strcmp(ns, \"\") == 0 ? \"\" : ns);\n\tif (ret < 0 || (size_t)ret >= __NS_PATH_LEN)\n\t\treturn -1;\n\n\treturn open(path, O_RDONLY | O_CLOEXEC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Does this kernel version support namespaces?\""
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "\"/proc/self/ns\"",
            "X_OK"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/personality.h>\n#include \"confile.h\"\n#include \"lsm/lsm.h\"\n#include <lxc/lxccontainer.h>\n#include \"lxcseccomp.h\"\n#include \"conf.h\"\n#include \"lxclock.h\"\n#include \"cgroup.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"caps.h\"\n#include \"attach.h\"\n#include \"af_unix.h\"\n#include \"log.h\"\n#include \"namespace.h\"\n#include <pwd.h>\n#include <linux/unistd.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\nstatic int lxc_attach_to_ns(pid_t pid, int which)\n{\n\tint fd[LXC_NS_MAX];\n\tint i, j, saved_errno;\n\n\n\tif (access(\"/proc/self/ns\", X_OK)) {\n\t\tERROR(\"Does this kernel version support namespaces?\");\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\t/* Ignore if we are not supposed to attach to that namespace. */\n\t\tif (which != -1 && !(which & ns_info[i].clone_flag)) {\n\t\t\tfd[i] = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfd[i] = lxc_preserve_ns(pid, ns_info[i].proc_name);\n\t\tif (fd[i] < 0) {\n\t\t\tsaved_errno = errno;\n\n\t\t\t/* Close all already opened file descriptors before we\n\t\t\t * return an error, so we don't leak them.\n\t\t\t */\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tclose(fd[j]);\n\n\t\t\terrno = saved_errno;\n\t\t\tSYSERROR(\"Failed to open namespace: \\\"%s\\\".\", ns_info[i].proc_name);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (fd[i] < 0)\n\t\t\tcontinue;\n\n\t\tif (setns(fd[i], 0) < 0) {\n\t\t\tsaved_errno = errno;\n\n\t\t\tfor (j = i; j < LXC_NS_MAX; j++)\n\t\t\t\tclose(fd[j]);\n\n\t\t\terrno = saved_errno;\n\t\t\tSYSERROR(\"Failed to attach to namespace \\\"%s\\\".\", ns_info[i].proc_name);\n\t\t\treturn -1;\n\t\t}\n\n\t\tDEBUG(\"Attached to namespace \\\"%s\\\".\", ns_info[i].proc_name);\n\n\t\tclose(fd[i]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_proc_put_context_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
    "lines": "240-246",
    "snippet": "static void lxc_proc_put_context_info(struct lxc_proc_context_info *ctx)\n{\n\tfree(ctx->lsm_label);\n\tif (ctx->container)\n\t\tlxc_container_put(ctx->container);\n\tfree(ctx);\n}",
    "includes": [
      "#include <sys/personality.h>",
      "#include \"confile.h\"",
      "#include \"lsm/lsm.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include \"lxcseccomp.h\"",
      "#include \"conf.h\"",
      "#include \"lxclock.h\"",
      "#include \"cgroup.h\"",
      "#include \"commands.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include \"caps.h\"",
      "#include \"attach.h\"",
      "#include \"af_unix.h\"",
      "#include \"log.h\"",
      "#include \"namespace.h\"",
      "#include <pwd.h>",
      "#include <linux/unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/mount.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ctx"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_container_put",
          "args": [
            "ctx->container"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "312-325",
          "snippet": "int lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/personality.h>\n#include \"confile.h\"\n#include \"lsm/lsm.h\"\n#include <lxc/lxccontainer.h>\n#include \"lxcseccomp.h\"\n#include \"conf.h\"\n#include \"lxclock.h\"\n#include \"cgroup.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"caps.h\"\n#include \"attach.h\"\n#include \"af_unix.h\"\n#include \"log.h\"\n#include \"namespace.h\"\n#include <pwd.h>\n#include <linux/unistd.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\nstatic void lxc_proc_put_context_info(struct lxc_proc_context_info *ctx)\n{\n\tfree(ctx->lsm_label);\n\tif (ctx->container)\n\t\tlxc_container_put(ctx->container);\n\tfree(ctx);\n}"
  },
  {
    "function_name": "lxc_proc_get_context_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
    "lines": "186-238",
    "snippet": "static struct lxc_proc_context_info *lxc_proc_get_context_info(pid_t pid)\n{\n\tFILE *proc_file;\n\tchar proc_fn[__PROC_STATUS_LEN];\n\tbool found;\n\tint ret;\n\tchar *line = NULL;\n\tsize_t line_bufsz = 0;\n\tstruct lxc_proc_context_info *info = NULL;\n\n\t/* Read capabilities. */\n\tret = snprintf(proc_fn, __PROC_STATUS_LEN, \"/proc/%d/status\", pid);\n\tif (ret < 0 || ret >= __PROC_STATUS_LEN)\n\t\tgoto on_error;\n\n\tproc_file = fopen(proc_fn, \"r\");\n\tif (!proc_file) {\n\t\tSYSERROR(\"Could not open %s.\", proc_fn);\n\t\tgoto on_error;\n\t}\n\n\tinfo = calloc(1, sizeof(*info));\n\tif (!info) {\n\t\tSYSERROR(\"Could not allocate memory.\");\n\t\treturn NULL;\n\t}\n\n\tfound = false;\n\twhile (getline(&line, &line_bufsz, proc_file) != -1) {\n\t\tret = sscanf(line, \"CapBnd: %llx\", &info->capability_mask);\n\t\tif (ret != EOF && ret == 1) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree(line);\n\tfclose(proc_file);\n\n\tif (!found) {\n\t\tSYSERROR(\"Could not read capability bounding set from %s.\", proc_fn);\n\t\terrno = ENOENT;\n\t\tgoto on_error;\n\t}\n\n\tinfo->lsm_label = lsm_process_label_get(pid);\n\n\treturn info;\n\non_error:\n\tfree(info);\n\treturn NULL;\n}",
    "includes": [
      "#include <sys/personality.h>",
      "#include \"confile.h\"",
      "#include \"lsm/lsm.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include \"lxcseccomp.h\"",
      "#include \"conf.h\"",
      "#include \"lxclock.h\"",
      "#include \"cgroup.h\"",
      "#include \"commands.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include \"caps.h\"",
      "#include \"attach.h\"",
      "#include \"af_unix.h\"",
      "#include \"log.h\"",
      "#include \"namespace.h\"",
      "#include <pwd.h>",
      "#include <linux/unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/mount.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [
      "#define __PROC_STATUS_LEN (5 + (LXC_NUMSTRLEN64) + 7 + 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "info"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "lsm_process_label_get",
          "args": [
            "pid"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "lsm_process_label_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lsm/lsm.h",
          "lines": "51-51",
          "snippet": "static inline char       *lsm_process_label_get(pid_t pid) { return NULL; }",
          "includes": [
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n\nstatic inline char       *lsm_process_label_get(pid_t pid) { return NULL; }"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Could not read capability bounding set from %s.\"",
            "proc_fn"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "proc_file"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "line",
            "\"CapBnd: %llx\"",
            "&info->capability_mask"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&line",
            "&line_bufsz",
            "proc_file"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getline.c",
          "lines": "39-60",
          "snippet": "ssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Could not allocate memory.\""
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "sizeof(*info)"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Could not open %s.\"",
            "proc_fn"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "proc_fn",
            "\"r\""
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "proc_fn",
            "__PROC_STATUS_LEN",
            "\"/proc/%d/status\"",
            "pid"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/personality.h>\n#include \"confile.h\"\n#include \"lsm/lsm.h\"\n#include <lxc/lxccontainer.h>\n#include \"lxcseccomp.h\"\n#include \"conf.h\"\n#include \"lxclock.h\"\n#include \"cgroup.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"caps.h\"\n#include \"attach.h\"\n#include \"af_unix.h\"\n#include \"log.h\"\n#include \"namespace.h\"\n#include <pwd.h>\n#include <linux/unistd.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\n#define __PROC_STATUS_LEN (5 + (LXC_NUMSTRLEN64) + 7 + 1)\n\nstatic struct lxc_proc_context_info *lxc_proc_get_context_info(pid_t pid)\n{\n\tFILE *proc_file;\n\tchar proc_fn[__PROC_STATUS_LEN];\n\tbool found;\n\tint ret;\n\tchar *line = NULL;\n\tsize_t line_bufsz = 0;\n\tstruct lxc_proc_context_info *info = NULL;\n\n\t/* Read capabilities. */\n\tret = snprintf(proc_fn, __PROC_STATUS_LEN, \"/proc/%d/status\", pid);\n\tif (ret < 0 || ret >= __PROC_STATUS_LEN)\n\t\tgoto on_error;\n\n\tproc_file = fopen(proc_fn, \"r\");\n\tif (!proc_file) {\n\t\tSYSERROR(\"Could not open %s.\", proc_fn);\n\t\tgoto on_error;\n\t}\n\n\tinfo = calloc(1, sizeof(*info));\n\tif (!info) {\n\t\tSYSERROR(\"Could not allocate memory.\");\n\t\treturn NULL;\n\t}\n\n\tfound = false;\n\twhile (getline(&line, &line_bufsz, proc_file) != -1) {\n\t\tret = sscanf(line, \"CapBnd: %llx\", &info->capability_mask);\n\t\tif (ret != EOF && ret == 1) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree(line);\n\tfclose(proc_file);\n\n\tif (!found) {\n\t\tSYSERROR(\"Could not read capability bounding set from %s.\", proc_fn);\n\t\terrno = ENOENT;\n\t\tgoto on_error;\n\t}\n\n\tinfo->lsm_label = lsm_process_label_get(pid);\n\n\treturn info;\n\non_error:\n\tfree(info);\n\treturn NULL;\n}"
  },
  {
    "function_name": "lsm_set_label_at",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
    "lines": "125-182",
    "snippet": "static int lsm_set_label_at(int lsm_labelfd, int on_exec, char *lsm_label)\n{\n\tint fret = -1;\n\tconst char* name;\n\tchar *command = NULL;\n\n\tname = lsm_name();\n\n\tif (strcmp(name, \"nop\") == 0)\n\t\treturn 0;\n\n\tif (strcmp(name, \"none\") == 0)\n\t\treturn 0;\n\n\t/* We don't support on-exec with AppArmor */\n\tif (strcmp(name, \"AppArmor\") == 0)\n\t\ton_exec = 0;\n\n\tif (strcmp(name, \"AppArmor\") == 0) {\n\t\tint size;\n\n\t\tcommand = malloc(strlen(lsm_label) + strlen(\"changeprofile \") + 1);\n\t\tif (!command) {\n\t\t\tSYSERROR(\"Failed to write apparmor profile.\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tsize = sprintf(command, \"changeprofile %s\", lsm_label);\n\t\tif (size < 0) {\n\t\t\tSYSERROR(\"Failed to write apparmor profile.\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (write(lsm_labelfd, command, size + 1) < 0) {\n\t\t\tSYSERROR(\"Unable to set LSM label: %s.\", command);\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Set LSM label to: %s.\", command);\n\t} else if (strcmp(name, \"SELinux\") == 0) {\n\t\tif (write(lsm_labelfd, lsm_label, strlen(lsm_label) + 1) < 0) {\n\t\t\tSYSERROR(\"Unable to set LSM label: %s.\", lsm_label);\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Set LSM label to: %s.\", lsm_label);\n\t} else {\n\t\tERROR(\"Unable to restore label for unknown LSM: %s.\", name);\n\t\tgoto out;\n\t}\n\tfret = 0;\n\nout:\n\tfree(command);\n\n\tif (lsm_labelfd != -1)\n\t\tclose(lsm_labelfd);\n\n\treturn fret;\n}",
    "includes": [
      "#include <sys/personality.h>",
      "#include \"confile.h\"",
      "#include \"lsm/lsm.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include \"lxcseccomp.h\"",
      "#include \"conf.h\"",
      "#include \"lxclock.h\"",
      "#include \"cgroup.h\"",
      "#include \"commands.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include \"caps.h\"",
      "#include \"attach.h\"",
      "#include \"af_unix.h\"",
      "#include \"log.h\"",
      "#include \"namespace.h\"",
      "#include <pwd.h>",
      "#include <linux/unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/mount.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "lsm_labelfd"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "command"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Unable to restore label for unknown LSM: %s.\"",
            "name"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Set LSM label to: %s.\"",
            "lsm_label"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Unable to set LSM label: %s.\"",
            "lsm_label"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "lsm_labelfd",
            "lsm_label",
            "strlen(lsm_label) + 1"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_nointr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "327-335",
          "snippet": "ssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "lsm_label"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"SELinux\""
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Set LSM label to: %s.\"",
            "command"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Unable to set LSM label: %s.\"",
            "command"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to write apparmor profile.\""
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "command",
            "\"changeprofile %s\"",
            "lsm_label"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to write apparmor profile.\""
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(lsm_label) + strlen(\"changeprofile \") + 1"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"changeprofile \""
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "lsm_label"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"AppArmor\""
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"AppArmor\""
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"none\""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"nop\""
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lsm_name",
          "args": [],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "lsm_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lsm/lsm.h",
          "lines": "50-50",
          "snippet": "static inline const char *lsm_name(void) { return \"none\"; }",
          "includes": [
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n\nstatic inline const char *lsm_name(void) { return \"none\"; }"
        }
      }
    ],
    "contextual_snippet": "#include <sys/personality.h>\n#include \"confile.h\"\n#include \"lsm/lsm.h\"\n#include <lxc/lxccontainer.h>\n#include \"lxcseccomp.h\"\n#include \"conf.h\"\n#include \"lxclock.h\"\n#include \"cgroup.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"caps.h\"\n#include \"attach.h\"\n#include \"af_unix.h\"\n#include \"log.h\"\n#include \"namespace.h\"\n#include <pwd.h>\n#include <linux/unistd.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\nstatic int lsm_set_label_at(int lsm_labelfd, int on_exec, char *lsm_label)\n{\n\tint fret = -1;\n\tconst char* name;\n\tchar *command = NULL;\n\n\tname = lsm_name();\n\n\tif (strcmp(name, \"nop\") == 0)\n\t\treturn 0;\n\n\tif (strcmp(name, \"none\") == 0)\n\t\treturn 0;\n\n\t/* We don't support on-exec with AppArmor */\n\tif (strcmp(name, \"AppArmor\") == 0)\n\t\ton_exec = 0;\n\n\tif (strcmp(name, \"AppArmor\") == 0) {\n\t\tint size;\n\n\t\tcommand = malloc(strlen(lsm_label) + strlen(\"changeprofile \") + 1);\n\t\tif (!command) {\n\t\t\tSYSERROR(\"Failed to write apparmor profile.\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tsize = sprintf(command, \"changeprofile %s\", lsm_label);\n\t\tif (size < 0) {\n\t\t\tSYSERROR(\"Failed to write apparmor profile.\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (write(lsm_labelfd, command, size + 1) < 0) {\n\t\t\tSYSERROR(\"Unable to set LSM label: %s.\", command);\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Set LSM label to: %s.\", command);\n\t} else if (strcmp(name, \"SELinux\") == 0) {\n\t\tif (write(lsm_labelfd, lsm_label, strlen(lsm_label) + 1) < 0) {\n\t\t\tSYSERROR(\"Unable to set LSM label: %s.\", lsm_label);\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Set LSM label to: %s.\", lsm_label);\n\t} else {\n\t\tERROR(\"Unable to restore label for unknown LSM: %s.\", name);\n\t\tgoto out;\n\t}\n\tfret = 0;\n\nout:\n\tfree(command);\n\n\tif (lsm_labelfd != -1)\n\t\tclose(lsm_labelfd);\n\n\treturn fret;\n}"
  },
  {
    "function_name": "lsm_openat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
    "lines": "90-123",
    "snippet": "static int lsm_openat(int procfd, pid_t pid, int on_exec)\n{\n\tint ret = -1;\n\tint labelfd = -1;\n\tconst char *name;\n\tchar path[__LSMATTRLEN];\n\n\tname = lsm_name();\n\n\tif (strcmp(name, \"nop\") == 0)\n\t\treturn 0;\n\n\tif (strcmp(name, \"none\") == 0)\n\t\treturn 0;\n\n\t/* We don't support on-exec with AppArmor */\n\tif (strcmp(name, \"AppArmor\") == 0)\n\t\ton_exec = 0;\n\n\tif (on_exec)\n\t\tret = snprintf(path, __LSMATTRLEN, \"%d/attr/exec\", pid);\n\telse\n\t\tret = snprintf(path, __LSMATTRLEN, \"%d/attr/current\", pid);\n\tif (ret < 0 || ret >= __LSMATTRLEN)\n\t\treturn -1;\n\n\tlabelfd = openat(procfd, path, O_RDWR);\n\tif (labelfd < 0) {\n\t\tSYSERROR(\"Unable to open file descriptor to set LSM label.\");\n\t\treturn -1;\n\t}\n\n\treturn labelfd;\n}",
    "includes": [
      "#include <sys/personality.h>",
      "#include \"confile.h\"",
      "#include \"lsm/lsm.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include \"lxcseccomp.h\"",
      "#include \"conf.h\"",
      "#include \"lxclock.h\"",
      "#include \"cgroup.h\"",
      "#include \"commands.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include \"caps.h\"",
      "#include \"attach.h\"",
      "#include \"af_unix.h\"",
      "#include \"log.h\"",
      "#include \"namespace.h\"",
      "#include <pwd.h>",
      "#include <linux/unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/mount.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [
      "#define __LSMATTRLEN (5 + (LXC_NUMSTRLEN64) + 7 + 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Unable to open file descriptor to set LSM label.\""
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openat",
          "args": [
            "procfd",
            "path",
            "O_RDWR"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "lsm_openat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
          "lines": "90-123",
          "snippet": "static int lsm_openat(int procfd, pid_t pid, int on_exec)\n{\n\tint ret = -1;\n\tint labelfd = -1;\n\tconst char *name;\n\tchar path[__LSMATTRLEN];\n\n\tname = lsm_name();\n\n\tif (strcmp(name, \"nop\") == 0)\n\t\treturn 0;\n\n\tif (strcmp(name, \"none\") == 0)\n\t\treturn 0;\n\n\t/* We don't support on-exec with AppArmor */\n\tif (strcmp(name, \"AppArmor\") == 0)\n\t\ton_exec = 0;\n\n\tif (on_exec)\n\t\tret = snprintf(path, __LSMATTRLEN, \"%d/attr/exec\", pid);\n\telse\n\t\tret = snprintf(path, __LSMATTRLEN, \"%d/attr/current\", pid);\n\tif (ret < 0 || ret >= __LSMATTRLEN)\n\t\treturn -1;\n\n\tlabelfd = openat(procfd, path, O_RDWR);\n\tif (labelfd < 0) {\n\t\tSYSERROR(\"Unable to open file descriptor to set LSM label.\");\n\t\treturn -1;\n\t}\n\n\treturn labelfd;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "__LSMATTRLEN",
            "\"%d/attr/current\"",
            "pid"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "__LSMATTRLEN",
            "\"%d/attr/exec\"",
            "pid"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"AppArmor\""
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"none\""
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"nop\""
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lsm_name",
          "args": [],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "lsm_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lsm/lsm.h",
          "lines": "50-50",
          "snippet": "static inline const char *lsm_name(void) { return \"none\"; }",
          "includes": [
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n\nstatic inline const char *lsm_name(void) { return \"none\"; }"
        }
      }
    ],
    "contextual_snippet": "#include <sys/personality.h>\n#include \"confile.h\"\n#include \"lsm/lsm.h\"\n#include <lxc/lxccontainer.h>\n#include \"lxcseccomp.h\"\n#include \"conf.h\"\n#include \"lxclock.h\"\n#include \"cgroup.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"caps.h\"\n#include \"attach.h\"\n#include \"af_unix.h\"\n#include \"log.h\"\n#include \"namespace.h\"\n#include <pwd.h>\n#include <linux/unistd.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\n#define __LSMATTRLEN (5 + (LXC_NUMSTRLEN64) + 7 + 1)\n\nstatic int lsm_openat(int procfd, pid_t pid, int on_exec)\n{\n\tint ret = -1;\n\tint labelfd = -1;\n\tconst char *name;\n\tchar path[__LSMATTRLEN];\n\n\tname = lsm_name();\n\n\tif (strcmp(name, \"nop\") == 0)\n\t\treturn 0;\n\n\tif (strcmp(name, \"none\") == 0)\n\t\treturn 0;\n\n\t/* We don't support on-exec with AppArmor */\n\tif (strcmp(name, \"AppArmor\") == 0)\n\t\ton_exec = 0;\n\n\tif (on_exec)\n\t\tret = snprintf(path, __LSMATTRLEN, \"%d/attr/exec\", pid);\n\telse\n\t\tret = snprintf(path, __LSMATTRLEN, \"%d/attr/current\", pid);\n\tif (ret < 0 || ret >= __LSMATTRLEN)\n\t\treturn -1;\n\n\tlabelfd = openat(procfd, path, O_RDWR);\n\tif (labelfd < 0) {\n\t\tSYSERROR(\"Unable to open file descriptor to set LSM label.\");\n\t\treturn -1;\n\t}\n\n\treturn labelfd;\n}"
  }
]