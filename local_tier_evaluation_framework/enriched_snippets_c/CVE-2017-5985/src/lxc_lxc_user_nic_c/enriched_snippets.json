[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
    "lines": "778-854",
    "snippet": "int main(int argc, char *argv[])\n{\n\tint n, fd;\n\tbool gotone = false;\n\tchar *me;\n\tchar *nicname = alloca(40);\n\tchar *cnic = NULL; // created nic name in container is returned here.\n\tchar *vethname = NULL;\n\tint pid;\n\tstruct alloted_s *alloted = NULL;\n\n\t/* set a sane env, because we are setuid-root */\n\tif (clearenv() < 0) {\n\t\tfprintf(stderr, \"Failed to clear environment\");\n\t\texit(1);\n\t}\n\tif (setenv(\"PATH\", \"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", 1) < 0) {\n\t\tfprintf(stderr, \"Failed to set PATH, exiting\\n\");\n\t\texit(1);\n\t}\n\tif ((me = get_username()) == NULL) {\n\t\tfprintf(stderr, \"Failed to get username\\n\");\n\t\texit(1);\n\t}\n\n\tif (argc < 6)\n\t\tusage(argv[0], true);\n\tif (argc >= 7)\n\t\tvethname = argv[6];\n\n\tlxcpath = argv[1];\n\tlxcname = argv[2];\n\n\terrno = 0;\n\tpid = (int) strtol(argv[3], NULL, 10);\n\tif (errno) {\n\t\tfprintf(stderr, \"Could not read pid: %s\\n\", argv[1]);\n\t\texit(1);\n\t}\n\n\tif (!create_db_dir(LXC_USERNIC_DB)) {\n\t\tfprintf(stderr, \"Failed to create directory for db file\\n\");\n\t\texit(1);\n\t}\n\n\tif ((fd = open_and_lock(LXC_USERNIC_DB)) < 0) {\n\t\tfprintf(stderr, \"Failed to lock %s\\n\", LXC_USERNIC_DB);\n\t\texit(1);\n\t}\n\n\tif (!may_access_netns(pid)) {\n\t\tfprintf(stderr, \"User %s may not modify netns for pid %d\\n\",\n\t\t\tme, pid);\n\t\texit(1);\n\t}\n\n\tn = get_alloted(me, argv[4], argv[5], &alloted);\n\tif (n > 0)\n\t\tgotone = get_nic_if_avail(fd, alloted, pid, argv[4], argv[5], n, &nicname, &cnic);\n\n\tclose(fd);\n\tfree_alloted(&alloted);\n\tif (!gotone) {\n\t\tfprintf(stderr, \"Quota reached\\n\");\n\t\texit(1);\n\t}\n\n\t// Now rename the link\n\tif (rename_in_ns(pid, cnic, &vethname) < 0) {\n\t\tfprintf(stderr, \"Failed to rename the link\\n\");\n\t\texit(1);\n\t}\n\n\t// write the name of the interface pair to the stdout - like eth0:veth9MT2L4\n\tfprintf(stdout, \"%s:%s\\n\", vethname, nicname);\n\texit(0);\n}",
    "includes": [
      "#include \"network.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <linux/netlink.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <sched.h>",
      "#include <string.h>",
      "#include <alloca.h>",
      "#include <sys/file.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <stdbool.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *lxcpath, *lxcname;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"%s:%s\\n\"",
            "vethname",
            "nicname"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to rename the link\\n\""
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rename_in_ns",
          "args": [
            "pid",
            "cnic",
            "&vethname"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "rename_in_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
          "lines": "674-735",
          "snippet": "static int rename_in_ns(int pid, char *oldname, char **newnamep)\n{\n\tint fd = -1, ofd = -1, ret, ifindex = -1;\n\tbool grab_newname = false;\n\n\tofd = lxc_preserve_ns(getpid(), \"net\");\n\tif (ofd < 0) {\n\t\tfprintf(stderr, \"Failed opening network namespace path for '%d'.\", getpid());\n\t\treturn -1;\n\t}\n\n\tfd = lxc_preserve_ns(pid, \"net\");\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Failed opening network namespace path for '%d'.\", pid);\n\t\treturn -1;\n\t}\n\n\tif (setns(fd, 0) < 0) {\n\t\tfprintf(stderr, \"setns to container network namespace\\n\");\n\t\tgoto out_err;\n\t}\n\tclose(fd); fd = -1;\n\tif (!*newnamep) {\n\t\tgrab_newname = true;\n\t\t*newnamep = VETH_DEF_NAME;\n\t\tif (!(ifindex = if_nametoindex(oldname))) {\n\t\t\tfprintf(stderr, \"failed to get netdev index\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\tif ((ret = lxc_netdev_rename_by_name(oldname, *newnamep)) < 0) {\n\t\tfprintf(stderr, \"Error %d renaming netdev %s to %s in container\\n\", ret, oldname, *newnamep);\n\t\tgoto out_err;\n\t}\n\tif (grab_newname) {\n\t\tchar ifname[IFNAMSIZ], *namep = ifname;\n\t\tif (!if_indextoname(ifindex, namep)) {\n\t\t\tfprintf(stderr, \"Failed to get new netdev name\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t\t*newnamep = strdup(namep);\n\t\tif (!*newnamep)\n\t\t\tgoto out_err;\n\t}\n\tif (setns(ofd, 0) < 0) {\n\t\tfprintf(stderr, \"Error returning to original netns\\n\");\n\t\tclose(ofd);\n\t\treturn -1;\n\t}\n\tclose(ofd);\n\n\treturn 0;\n\nout_err:\n\tif (ofd >= 0)\n\t\tclose(ofd);\n\tif (setns(ofd, 0) < 0)\n\t\tfprintf(stderr, \"Error returning to original network namespace\\n\");\n\tif (fd >= 0)\n\t\tclose(fd);\n\treturn -1;\n}",
          "includes": [
            "#include \"network.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <linux/netlink.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <sched.h>",
            "#include <string.h>",
            "#include <alloca.h>",
            "#include <sys/file.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define VETH_DEF_NAME \"eth%d\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define VETH_DEF_NAME \"eth%d\"\n\nstatic int rename_in_ns(int pid, char *oldname, char **newnamep)\n{\n\tint fd = -1, ofd = -1, ret, ifindex = -1;\n\tbool grab_newname = false;\n\n\tofd = lxc_preserve_ns(getpid(), \"net\");\n\tif (ofd < 0) {\n\t\tfprintf(stderr, \"Failed opening network namespace path for '%d'.\", getpid());\n\t\treturn -1;\n\t}\n\n\tfd = lxc_preserve_ns(pid, \"net\");\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Failed opening network namespace path for '%d'.\", pid);\n\t\treturn -1;\n\t}\n\n\tif (setns(fd, 0) < 0) {\n\t\tfprintf(stderr, \"setns to container network namespace\\n\");\n\t\tgoto out_err;\n\t}\n\tclose(fd); fd = -1;\n\tif (!*newnamep) {\n\t\tgrab_newname = true;\n\t\t*newnamep = VETH_DEF_NAME;\n\t\tif (!(ifindex = if_nametoindex(oldname))) {\n\t\t\tfprintf(stderr, \"failed to get netdev index\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\tif ((ret = lxc_netdev_rename_by_name(oldname, *newnamep)) < 0) {\n\t\tfprintf(stderr, \"Error %d renaming netdev %s to %s in container\\n\", ret, oldname, *newnamep);\n\t\tgoto out_err;\n\t}\n\tif (grab_newname) {\n\t\tchar ifname[IFNAMSIZ], *namep = ifname;\n\t\tif (!if_indextoname(ifindex, namep)) {\n\t\t\tfprintf(stderr, \"Failed to get new netdev name\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t\t*newnamep = strdup(namep);\n\t\tif (!*newnamep)\n\t\t\tgoto out_err;\n\t}\n\tif (setns(ofd, 0) < 0) {\n\t\tfprintf(stderr, \"Error returning to original netns\\n\");\n\t\tclose(ofd);\n\t\treturn -1;\n\t}\n\tclose(ofd);\n\n\treturn 0;\n\nout_err:\n\tif (ofd >= 0)\n\t\tclose(ofd);\n\tif (setns(ofd, 0) < 0)\n\t\tfprintf(stderr, \"Error returning to original network namespace\\n\");\n\tif (fd >= 0)\n\t\tclose(fd);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Quota reached\\n\""
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_alloted",
          "args": [
            "&alloted"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "free_alloted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
          "lines": "235-251",
          "snippet": "static void free_alloted(struct alloted_s **head)\n{\n\tstruct alloted_s *cur;\n\n\tif (head == NULL) {\n\t\treturn;\n\t}\n\n\tcur = *head;\n\n\twhile (cur != NULL) {\n\t\tcur = cur->next;\n\t\tfree((*head)->name);\n\t\tfree(*head);\n\t\t*head = cur;\n\t}\n}",
          "includes": [
            "#include \"network.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <linux/netlink.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <sched.h>",
            "#include <string.h>",
            "#include <alloca.h>",
            "#include <sys/file.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic void free_alloted(struct alloted_s **head)\n{\n\tstruct alloted_s *cur;\n\n\tif (head == NULL) {\n\t\treturn;\n\t}\n\n\tcur = *head;\n\n\twhile (cur != NULL) {\n\t\tcur = cur->next;\n\t\tfree((*head)->name);\n\t\tfree(*head);\n\t\t*head = cur;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nic_if_avail",
          "args": [
            "fd",
            "alloted",
            "pid",
            "argv[4]",
            "argv[5]",
            "n",
            "&nicname",
            "&cnic"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "get_nic_if_avail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
          "lines": "580-649",
          "snippet": "static bool get_nic_if_avail(int fd, struct alloted_s *names, int pid, char *intype, char *br, int allowed, char **nicname, char **cnic)\n{\n\toff_t len, slen;\n\tstruct stat sb;\n\tchar *buf = NULL, *newline;\n\tint ret, count = 0;\n\tchar *owner;\n\tstruct alloted_s *n;\n\n\tfor (n=names; n!=NULL; n=n->next)\n\t\tcull_entries(fd, n->name, intype, br);\n\n\tif (allowed == 0)\n\t\treturn false;\n\n\towner = names->name;\n\n\tif (fstat(fd, &sb) < 0) {\n\t\tfprintf(stderr, \"Failed to fstat: %s\\n\", strerror(errno));\n\t\treturn false;\n\t}\n\tlen = sb.st_size;\n\tif (len != 0) {\n\t\tbuf = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n\t\tif (buf == MAP_FAILED) {\n\t\t\tfprintf(stderr, \"Failed to create mapping\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\towner = NULL;\n\t\tfor (n=names; n!=NULL; n=n->next) {\n\t\t\tcount = count_entries(buf, len, n->name, intype, br);\n\n\t\t\tif (count >= n->allowed)\n\t\t\t\tcontinue;\n\n\t\t\towner = n->name;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (owner == NULL)\n\t\treturn false;\n\n\tif (!get_new_nicname(nicname, br, pid, cnic))\n\t\treturn false;\n\t/* owner  ' ' intype ' ' br ' ' *nicname + '\\n' + '\\0' */\n\tslen = strlen(owner) + strlen(intype) + strlen(br) + strlen(*nicname) + 5;\n\tnewline = alloca(slen);\n\tret = snprintf(newline, slen, \"%s %s %s %s\\n\", owner, intype, br, *nicname);\n\tif (ret < 0 || ret >= slen) {\n\t\tif (lxc_netdev_delete_by_name(*nicname) != 0)\n\t\t\tfprintf(stderr, \"Error unlinking %s!\\n\", *nicname);\n\t\treturn false;\n\t}\n\tif (len)\n\t\tmunmap(buf, len);\n\tif (ftruncate(fd, len + slen))\n\t\tfprintf(stderr, \"Failed to set new file size\\n\");\n\tbuf = mmap(NULL, len + slen, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n\tif (buf == MAP_FAILED) {\n\t\tfprintf(stderr, \"Failed to create mapping after extending: %s\\n\", strerror(errno));\n\t\tif (lxc_netdev_delete_by_name(*nicname) != 0)\n\t\t\tfprintf(stderr, \"Error unlinking %s!\\n\", *nicname);\n\t\treturn false;\n\t}\n\tstrcpy(buf+len, newline);\n\tmunmap(buf, len+slen);\n\treturn true;\n}",
          "includes": [
            "#include \"network.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <linux/netlink.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <sched.h>",
            "#include <string.h>",
            "#include <alloca.h>",
            "#include <sys/file.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool get_nic_if_avail(int fd, struct alloted_s *names, int pid, char *intype, char *br, int allowed, char **nicname, char **cnic)\n{\n\toff_t len, slen;\n\tstruct stat sb;\n\tchar *buf = NULL, *newline;\n\tint ret, count = 0;\n\tchar *owner;\n\tstruct alloted_s *n;\n\n\tfor (n=names; n!=NULL; n=n->next)\n\t\tcull_entries(fd, n->name, intype, br);\n\n\tif (allowed == 0)\n\t\treturn false;\n\n\towner = names->name;\n\n\tif (fstat(fd, &sb) < 0) {\n\t\tfprintf(stderr, \"Failed to fstat: %s\\n\", strerror(errno));\n\t\treturn false;\n\t}\n\tlen = sb.st_size;\n\tif (len != 0) {\n\t\tbuf = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n\t\tif (buf == MAP_FAILED) {\n\t\t\tfprintf(stderr, \"Failed to create mapping\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\towner = NULL;\n\t\tfor (n=names; n!=NULL; n=n->next) {\n\t\t\tcount = count_entries(buf, len, n->name, intype, br);\n\n\t\t\tif (count >= n->allowed)\n\t\t\t\tcontinue;\n\n\t\t\towner = n->name;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (owner == NULL)\n\t\treturn false;\n\n\tif (!get_new_nicname(nicname, br, pid, cnic))\n\t\treturn false;\n\t/* owner  ' ' intype ' ' br ' ' *nicname + '\\n' + '\\0' */\n\tslen = strlen(owner) + strlen(intype) + strlen(br) + strlen(*nicname) + 5;\n\tnewline = alloca(slen);\n\tret = snprintf(newline, slen, \"%s %s %s %s\\n\", owner, intype, br, *nicname);\n\tif (ret < 0 || ret >= slen) {\n\t\tif (lxc_netdev_delete_by_name(*nicname) != 0)\n\t\t\tfprintf(stderr, \"Error unlinking %s!\\n\", *nicname);\n\t\treturn false;\n\t}\n\tif (len)\n\t\tmunmap(buf, len);\n\tif (ftruncate(fd, len + slen))\n\t\tfprintf(stderr, \"Failed to set new file size\\n\");\n\tbuf = mmap(NULL, len + slen, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n\tif (buf == MAP_FAILED) {\n\t\tfprintf(stderr, \"Failed to create mapping after extending: %s\\n\", strerror(errno));\n\t\tif (lxc_netdev_delete_by_name(*nicname) != 0)\n\t\t\tfprintf(stderr, \"Error unlinking %s!\\n\", *nicname);\n\t\treturn false;\n\t}\n\tstrcpy(buf+len, newline);\n\tmunmap(buf, len+slen);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_alloted",
          "args": [
            "me",
            "argv[4]",
            "argv[5]",
            "&alloted"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "get_alloted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
          "lines": "262-319",
          "snippet": "static int get_alloted(char *me, char *intype, char *link, struct alloted_s **alloted)\n{\n\tFILE *fin = fopen(LXC_USERNIC_CONF, \"r\");\n\tchar *line = NULL;\n\tchar name[100], type[100], br[100];\n\tsize_t len = 0;\n\tint n, ret, count = 0;\n\tchar **groups;\n\n\tif (!fin) {\n\t\tfprintf(stderr, \"Failed to open %s: %s\\n\", LXC_USERNIC_CONF,\n\t\t\tstrerror(errno));\n\t\treturn -1;\n\t}\n\n\tgroups = get_groupnames();\n\twhile ((getline(&line, &len, fin)) != -1) {\n\t\tret = sscanf(line, \"%99[^ \\t] %99[^ \\t] %99[^ \\t] %d\", name, type, br, &n);\n\n\t\tif (ret != 4)\n\t\t\tcontinue;\n\n\t\tif (strlen(name) == 0)\n\t\t\tcontinue;\n\n\t\tif (strcmp(name, me) != 0)\n\t\t{\n\t\t\tif (name[0] != '@')\n\t\t\t\tcontinue;\n\t\t\tif (!name_is_in_groupnames(name+1, groups))\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (strcmp(type, intype) != 0)\n\t\t\tcontinue;\n\t\tif (strcmp(link, br) != 0)\n\t\t\tcontinue;\n\n\t\t/* found the user or group with the appropriate settings, therefore finish the search.\n\t\t * what to do if there are more than one applicable lines? not specified in the docs.\n\t\t * since getline is implemented with realloc, we don't need to free line until exiting func.\n\t\t *\n\t\t * if append_alloted returns NULL, e.g. due to a malloc error, we set count to 0 and break the loop,\n\t\t * allowing cleanup and then exiting from main()\n\t\t */\n\t\tif (append_alloted(alloted, name, n) == NULL) {\n\t\t\tcount = 0;\n\t\t\tbreak;\n\t\t}\n\t\tcount += n;\n\t}\n\n\tfree_groupnames(groups);\n\tfclose(fin);\n\tfree(line);\n\n\t// now return the total number of nics that this user can create\n\treturn count;\n}",
          "includes": [
            "#include \"network.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <linux/netlink.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <sched.h>",
            "#include <string.h>",
            "#include <alloca.h>",
            "#include <sys/file.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int get_alloted(char *me, char *intype, char *link, struct alloted_s **alloted)\n{\n\tFILE *fin = fopen(LXC_USERNIC_CONF, \"r\");\n\tchar *line = NULL;\n\tchar name[100], type[100], br[100];\n\tsize_t len = 0;\n\tint n, ret, count = 0;\n\tchar **groups;\n\n\tif (!fin) {\n\t\tfprintf(stderr, \"Failed to open %s: %s\\n\", LXC_USERNIC_CONF,\n\t\t\tstrerror(errno));\n\t\treturn -1;\n\t}\n\n\tgroups = get_groupnames();\n\twhile ((getline(&line, &len, fin)) != -1) {\n\t\tret = sscanf(line, \"%99[^ \\t] %99[^ \\t] %99[^ \\t] %d\", name, type, br, &n);\n\n\t\tif (ret != 4)\n\t\t\tcontinue;\n\n\t\tif (strlen(name) == 0)\n\t\t\tcontinue;\n\n\t\tif (strcmp(name, me) != 0)\n\t\t{\n\t\t\tif (name[0] != '@')\n\t\t\t\tcontinue;\n\t\t\tif (!name_is_in_groupnames(name+1, groups))\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (strcmp(type, intype) != 0)\n\t\t\tcontinue;\n\t\tif (strcmp(link, br) != 0)\n\t\t\tcontinue;\n\n\t\t/* found the user or group with the appropriate settings, therefore finish the search.\n\t\t * what to do if there are more than one applicable lines? not specified in the docs.\n\t\t * since getline is implemented with realloc, we don't need to free line until exiting func.\n\t\t *\n\t\t * if append_alloted returns NULL, e.g. due to a malloc error, we set count to 0 and break the loop,\n\t\t * allowing cleanup and then exiting from main()\n\t\t */\n\t\tif (append_alloted(alloted, name, n) == NULL) {\n\t\t\tcount = 0;\n\t\t\tbreak;\n\t\t}\n\t\tcount += n;\n\t}\n\n\tfree_groupnames(groups);\n\tfclose(fin);\n\tfree(line);\n\n\t// now return the total number of nics that this user can create\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"User %s may not modify netns for pid %d\\n\"",
            "me",
            "pid"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "may_access_netns",
          "args": [
            "pid"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "may_access_netns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
          "lines": "742-776",
          "snippet": "static bool may_access_netns(int pid)\n{\n\tint ret;\n\tchar s[200];\n\tuid_t ruid, suid, euid;\n\tbool may_access = false;\n\n\tret = getresuid(&ruid, &euid, &suid);\n\tif (ret) {\n\t\tfprintf(stderr, \"Failed to get my uids: %s\\n\", strerror(errno));\n\t\treturn false;\n\t}\n\tret = setresuid(ruid, ruid, euid);\n\tif (ret) {\n\t\tfprintf(stderr, \"Failed to set temp uids to (%d,%d,%d): %s\\n\",\n\t\t\t\t(int)ruid, (int)ruid, (int)euid, strerror(errno));\n\t\treturn false;\n\t}\n\tret = snprintf(s, 200, \"/proc/%d/ns/net\", pid);\n\tif (ret < 0 || ret >= 200)  // can't happen\n\t\treturn false;\n\tret = access(s, R_OK);\n\tif (ret) {\n\t\tfprintf(stderr, \"Uid %d may not access %s: %s\\n\",\n\t\t\t\t(int)ruid, s, strerror(errno));\n\t}\n\tmay_access = ret == 0;\n\tret = setresuid(ruid, euid, suid);\n\tif (ret) {\n\t\tfprintf(stderr, \"Failed to restore uids to (%d,%d,%d): %s\\n\",\n\t\t\t\t(int)ruid, (int)euid, (int)suid, strerror(errno));\n\t\tmay_access = false;\n\t}\n\treturn may_access;\n}",
          "includes": [
            "#include \"network.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <linux/netlink.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <sched.h>",
            "#include <string.h>",
            "#include <alloca.h>",
            "#include <sys/file.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool may_access_netns(int pid)\n{\n\tint ret;\n\tchar s[200];\n\tuid_t ruid, suid, euid;\n\tbool may_access = false;\n\n\tret = getresuid(&ruid, &euid, &suid);\n\tif (ret) {\n\t\tfprintf(stderr, \"Failed to get my uids: %s\\n\", strerror(errno));\n\t\treturn false;\n\t}\n\tret = setresuid(ruid, ruid, euid);\n\tif (ret) {\n\t\tfprintf(stderr, \"Failed to set temp uids to (%d,%d,%d): %s\\n\",\n\t\t\t\t(int)ruid, (int)ruid, (int)euid, strerror(errno));\n\t\treturn false;\n\t}\n\tret = snprintf(s, 200, \"/proc/%d/ns/net\", pid);\n\tif (ret < 0 || ret >= 200)  // can't happen\n\t\treturn false;\n\tret = access(s, R_OK);\n\tif (ret) {\n\t\tfprintf(stderr, \"Uid %d may not access %s: %s\\n\",\n\t\t\t\t(int)ruid, s, strerror(errno));\n\t}\n\tmay_access = ret == 0;\n\tret = setresuid(ruid, euid, suid);\n\tif (ret) {\n\t\tfprintf(stderr, \"Failed to restore uids to (%d,%d,%d): %s\\n\",\n\t\t\t\t(int)ruid, (int)euid, (int)suid, strerror(errno));\n\t\tmay_access = false;\n\t}\n\treturn may_access;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to lock %s\\n\"",
            "LXC_USERNIC_DB"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_and_lock",
          "args": [
            "LXC_USERNIC_DB"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "open_and_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
          "lines": "62-86",
          "snippet": "static int open_and_lock(char *path)\n{\n\tint fd;\n\tstruct flock lk;\n\n\tfd = open(path, O_RDWR|O_CREAT, S_IWUSR | S_IRUSR);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Failed to open %s: %s\\n\",\n\t\t\tpath, strerror(errno));\n\t\treturn(fd);\n\t}\n\n\tlk.l_type = F_WRLCK;\n\tlk.l_whence = SEEK_SET;\n\tlk.l_start = 0;\n\tlk.l_len = 0;\n\tif (fcntl(fd, F_SETLKW, &lk) < 0) {\n\t\tfprintf(stderr, \"Failed to lock %s: %s\\n\",\n\t\t\tpath, strerror(errno));\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}",
          "includes": [
            "#include \"network.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <linux/netlink.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <sched.h>",
            "#include <string.h>",
            "#include <alloca.h>",
            "#include <sys/file.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int open_and_lock(char *path)\n{\n\tint fd;\n\tstruct flock lk;\n\n\tfd = open(path, O_RDWR|O_CREAT, S_IWUSR | S_IRUSR);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Failed to open %s: %s\\n\",\n\t\t\tpath, strerror(errno));\n\t\treturn(fd);\n\t}\n\n\tlk.l_type = F_WRLCK;\n\tlk.l_whence = SEEK_SET;\n\tlk.l_start = 0;\n\tlk.l_len = 0;\n\tif (fcntl(fd, F_SETLKW, &lk) < 0) {\n\t\tfprintf(stderr, \"Failed to lock %s: %s\\n\",\n\t\t\tpath, strerror(errno));\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to create directory for db file\\n\""
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_db_dir",
          "args": [
            "LXC_USERNIC_DB"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "create_db_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
          "lines": "651-670",
          "snippet": "static bool create_db_dir(char *fnam)\n{\n\tchar *p = alloca(strlen(fnam)+1);\n\n\tstrcpy(p, fnam);\n\tfnam = p;\n\tp = p + 1;\nagain:\n\twhile (*p && *p != '/') p++;\n\tif (!*p)\n\t\treturn true;\n\t*p = '\\0';\n\tif (mkdir(fnam, 0755) && errno != EEXIST) {\n\t\tfprintf(stderr, \"failed to create %s\\n\", fnam);\n\t\t*p = '/';\n\t\treturn false;\n\t}\n\t*(p++) = '/';\n\tgoto again;\n}",
          "includes": [
            "#include \"network.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <linux/netlink.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <sched.h>",
            "#include <string.h>",
            "#include <alloca.h>",
            "#include <sys/file.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool create_db_dir(char *fnam)\n{\n\tchar *p = alloca(strlen(fnam)+1);\n\n\tstrcpy(p, fnam);\n\tfnam = p;\n\tp = p + 1;\nagain:\n\twhile (*p && *p != '/') p++;\n\tif (!*p)\n\t\treturn true;\n\t*p = '\\0';\n\tif (mkdir(fnam, 0755) && errno != EEXIST) {\n\t\tfprintf(stderr, \"failed to create %s\\n\", fnam);\n\t\t*p = '/';\n\t\treturn false;\n\t}\n\t*(p++) = '/';\n\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Could not read pid: %s\\n\"",
            "argv[1]"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "argv[3]",
            "NULL",
            "10"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usage",
          "args": [
            "argv[0]",
            "true"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
          "lines": "53-58",
          "snippet": "static void usage(char *me, bool fail)\n{\n\tfprintf(stderr, \"Usage: %s lxcpath name pid type bridge nicname\\n\", me);\n\tfprintf(stderr, \" nicname is the name to use inside the container\\n\");\n\texit(fail ? 1 : 0);\n}",
          "includes": [
            "#include \"network.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <linux/netlink.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <sched.h>",
            "#include <string.h>",
            "#include <alloca.h>",
            "#include <sys/file.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic void usage(char *me, bool fail)\n{\n\tfprintf(stderr, \"Usage: %s lxcpath name pid type bridge nicname\\n\", me);\n\tfprintf(stderr, \" nicname is the name to use inside the container\\n\");\n\texit(fail ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to get username\\n\""
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_username",
          "args": [],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "get_username",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
          "lines": "89-99",
          "snippet": "static char *get_username(void)\n{\n\tstruct passwd *pwd = getpwuid(getuid());\n\n\tif (pwd == NULL) {\n\t\tperror(\"getpwuid\");\n\t\treturn NULL;\n\t}\n\n\treturn pwd->pw_name;\n}",
          "includes": [
            "#include \"network.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <linux/netlink.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <sched.h>",
            "#include <string.h>",
            "#include <alloca.h>",
            "#include <sys/file.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *get_username(void)\n{\n\tstruct passwd *pwd = getpwuid(getuid());\n\n\tif (pwd == NULL) {\n\t\tperror(\"getpwuid\");\n\t\treturn NULL;\n\t}\n\n\treturn pwd->pw_name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to set PATH, exiting\\n\""
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"PATH\"",
            "\"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\"",
            "1"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to clear environment\""
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clearenv",
          "args": [],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "40"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *lxcpath, *lxcname;\n\nint main(int argc, char *argv[])\n{\n\tint n, fd;\n\tbool gotone = false;\n\tchar *me;\n\tchar *nicname = alloca(40);\n\tchar *cnic = NULL; // created nic name in container is returned here.\n\tchar *vethname = NULL;\n\tint pid;\n\tstruct alloted_s *alloted = NULL;\n\n\t/* set a sane env, because we are setuid-root */\n\tif (clearenv() < 0) {\n\t\tfprintf(stderr, \"Failed to clear environment\");\n\t\texit(1);\n\t}\n\tif (setenv(\"PATH\", \"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", 1) < 0) {\n\t\tfprintf(stderr, \"Failed to set PATH, exiting\\n\");\n\t\texit(1);\n\t}\n\tif ((me = get_username()) == NULL) {\n\t\tfprintf(stderr, \"Failed to get username\\n\");\n\t\texit(1);\n\t}\n\n\tif (argc < 6)\n\t\tusage(argv[0], true);\n\tif (argc >= 7)\n\t\tvethname = argv[6];\n\n\tlxcpath = argv[1];\n\tlxcname = argv[2];\n\n\terrno = 0;\n\tpid = (int) strtol(argv[3], NULL, 10);\n\tif (errno) {\n\t\tfprintf(stderr, \"Could not read pid: %s\\n\", argv[1]);\n\t\texit(1);\n\t}\n\n\tif (!create_db_dir(LXC_USERNIC_DB)) {\n\t\tfprintf(stderr, \"Failed to create directory for db file\\n\");\n\t\texit(1);\n\t}\n\n\tif ((fd = open_and_lock(LXC_USERNIC_DB)) < 0) {\n\t\tfprintf(stderr, \"Failed to lock %s\\n\", LXC_USERNIC_DB);\n\t\texit(1);\n\t}\n\n\tif (!may_access_netns(pid)) {\n\t\tfprintf(stderr, \"User %s may not modify netns for pid %d\\n\",\n\t\t\tme, pid);\n\t\texit(1);\n\t}\n\n\tn = get_alloted(me, argv[4], argv[5], &alloted);\n\tif (n > 0)\n\t\tgotone = get_nic_if_avail(fd, alloted, pid, argv[4], argv[5], n, &nicname, &cnic);\n\n\tclose(fd);\n\tfree_alloted(&alloted);\n\tif (!gotone) {\n\t\tfprintf(stderr, \"Quota reached\\n\");\n\t\texit(1);\n\t}\n\n\t// Now rename the link\n\tif (rename_in_ns(pid, cnic, &vethname) < 0) {\n\t\tfprintf(stderr, \"Failed to rename the link\\n\");\n\t\texit(1);\n\t}\n\n\t// write the name of the interface pair to the stdout - like eth0:veth9MT2L4\n\tfprintf(stdout, \"%s:%s\\n\", vethname, nicname);\n\texit(0);\n}"
  },
  {
    "function_name": "may_access_netns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
    "lines": "742-776",
    "snippet": "static bool may_access_netns(int pid)\n{\n\tint ret;\n\tchar s[200];\n\tuid_t ruid, suid, euid;\n\tbool may_access = false;\n\n\tret = getresuid(&ruid, &euid, &suid);\n\tif (ret) {\n\t\tfprintf(stderr, \"Failed to get my uids: %s\\n\", strerror(errno));\n\t\treturn false;\n\t}\n\tret = setresuid(ruid, ruid, euid);\n\tif (ret) {\n\t\tfprintf(stderr, \"Failed to set temp uids to (%d,%d,%d): %s\\n\",\n\t\t\t\t(int)ruid, (int)ruid, (int)euid, strerror(errno));\n\t\treturn false;\n\t}\n\tret = snprintf(s, 200, \"/proc/%d/ns/net\", pid);\n\tif (ret < 0 || ret >= 200)  // can't happen\n\t\treturn false;\n\tret = access(s, R_OK);\n\tif (ret) {\n\t\tfprintf(stderr, \"Uid %d may not access %s: %s\\n\",\n\t\t\t\t(int)ruid, s, strerror(errno));\n\t}\n\tmay_access = ret == 0;\n\tret = setresuid(ruid, euid, suid);\n\tif (ret) {\n\t\tfprintf(stderr, \"Failed to restore uids to (%d,%d,%d): %s\\n\",\n\t\t\t\t(int)ruid, (int)euid, (int)suid, strerror(errno));\n\t\tmay_access = false;\n\t}\n\treturn may_access;\n}",
    "includes": [
      "#include \"network.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <linux/netlink.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <sched.h>",
      "#include <string.h>",
      "#include <alloca.h>",
      "#include <sys/file.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <stdbool.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to restore uids to (%d,%d,%d): %s\\n\"",
            "(int)ruid",
            "(int)euid",
            "(int)suid",
            "strerror(errno)"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setresuid",
          "args": [
            "ruid",
            "euid",
            "suid"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Uid %d may not access %s: %s\\n\"",
            "(int)ruid",
            "s",
            "strerror(errno)"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "s",
            "R_OK"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "s",
            "200",
            "\"/proc/%d/ns/net\"",
            "pid"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to set temp uids to (%d,%d,%d): %s\\n\"",
            "(int)ruid",
            "(int)ruid",
            "(int)euid",
            "strerror(errno)"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setresuid",
          "args": [
            "ruid",
            "ruid",
            "euid"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to get my uids: %s\\n\"",
            "strerror(errno)"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getresuid",
          "args": [
            "&ruid",
            "&euid",
            "&suid"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool may_access_netns(int pid)\n{\n\tint ret;\n\tchar s[200];\n\tuid_t ruid, suid, euid;\n\tbool may_access = false;\n\n\tret = getresuid(&ruid, &euid, &suid);\n\tif (ret) {\n\t\tfprintf(stderr, \"Failed to get my uids: %s\\n\", strerror(errno));\n\t\treturn false;\n\t}\n\tret = setresuid(ruid, ruid, euid);\n\tif (ret) {\n\t\tfprintf(stderr, \"Failed to set temp uids to (%d,%d,%d): %s\\n\",\n\t\t\t\t(int)ruid, (int)ruid, (int)euid, strerror(errno));\n\t\treturn false;\n\t}\n\tret = snprintf(s, 200, \"/proc/%d/ns/net\", pid);\n\tif (ret < 0 || ret >= 200)  // can't happen\n\t\treturn false;\n\tret = access(s, R_OK);\n\tif (ret) {\n\t\tfprintf(stderr, \"Uid %d may not access %s: %s\\n\",\n\t\t\t\t(int)ruid, s, strerror(errno));\n\t}\n\tmay_access = ret == 0;\n\tret = setresuid(ruid, euid, suid);\n\tif (ret) {\n\t\tfprintf(stderr, \"Failed to restore uids to (%d,%d,%d): %s\\n\",\n\t\t\t\t(int)ruid, (int)euid, (int)suid, strerror(errno));\n\t\tmay_access = false;\n\t}\n\treturn may_access;\n}"
  },
  {
    "function_name": "rename_in_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
    "lines": "674-735",
    "snippet": "static int rename_in_ns(int pid, char *oldname, char **newnamep)\n{\n\tint fd = -1, ofd = -1, ret, ifindex = -1;\n\tbool grab_newname = false;\n\n\tofd = lxc_preserve_ns(getpid(), \"net\");\n\tif (ofd < 0) {\n\t\tfprintf(stderr, \"Failed opening network namespace path for '%d'.\", getpid());\n\t\treturn -1;\n\t}\n\n\tfd = lxc_preserve_ns(pid, \"net\");\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Failed opening network namespace path for '%d'.\", pid);\n\t\treturn -1;\n\t}\n\n\tif (setns(fd, 0) < 0) {\n\t\tfprintf(stderr, \"setns to container network namespace\\n\");\n\t\tgoto out_err;\n\t}\n\tclose(fd); fd = -1;\n\tif (!*newnamep) {\n\t\tgrab_newname = true;\n\t\t*newnamep = VETH_DEF_NAME;\n\t\tif (!(ifindex = if_nametoindex(oldname))) {\n\t\t\tfprintf(stderr, \"failed to get netdev index\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\tif ((ret = lxc_netdev_rename_by_name(oldname, *newnamep)) < 0) {\n\t\tfprintf(stderr, \"Error %d renaming netdev %s to %s in container\\n\", ret, oldname, *newnamep);\n\t\tgoto out_err;\n\t}\n\tif (grab_newname) {\n\t\tchar ifname[IFNAMSIZ], *namep = ifname;\n\t\tif (!if_indextoname(ifindex, namep)) {\n\t\t\tfprintf(stderr, \"Failed to get new netdev name\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t\t*newnamep = strdup(namep);\n\t\tif (!*newnamep)\n\t\t\tgoto out_err;\n\t}\n\tif (setns(ofd, 0) < 0) {\n\t\tfprintf(stderr, \"Error returning to original netns\\n\");\n\t\tclose(ofd);\n\t\treturn -1;\n\t}\n\tclose(ofd);\n\n\treturn 0;\n\nout_err:\n\tif (ofd >= 0)\n\t\tclose(ofd);\n\tif (setns(ofd, 0) < 0)\n\t\tfprintf(stderr, \"Error returning to original network namespace\\n\");\n\tif (fd >= 0)\n\t\tclose(fd);\n\treturn -1;\n}",
    "includes": [
      "#include \"network.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <linux/netlink.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <sched.h>",
      "#include <string.h>",
      "#include <alloca.h>",
      "#include <sys/file.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <stdbool.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [
      "#define VETH_DEF_NAME \"eth%d\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error returning to original network namespace\\n\""
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setns",
          "args": [
            "ofd",
            "0"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "setns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.h",
          "lines": "58-68",
          "snippet": "static inline int setns(int fd, int nstype)\n{\n#ifdef __NR_setns\n\treturn syscall(__NR_setns, fd, nstype);\n#elif defined(__NR_set_ns)\n\treturn syscall(__NR_set_ns, fd, nstype);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}",
          "includes": [
            "#include <stdint.h>",
            "#  include <sys/signalfd.h>",
            "#include <../include/getline.h>",
            "#include \"initutils.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#  include <sys/signalfd.h>\n#include <../include/getline.h>\n#include \"initutils.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic inline int setns(int fd, int nstype)\n{\n#ifdef __NR_setns\n\treturn syscall(__NR_setns, fd, nstype);\n#elif defined(__NR_set_ns)\n\treturn syscall(__NR_set_ns, fd, nstype);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error returning to original netns\\n\""
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "namep"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to get new netdev name\\n\""
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_indextoname",
          "args": [
            "ifindex",
            "namep"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error %d renaming netdev %s to %s in container\\n\"",
            "ret",
            "oldname",
            "*newnamep"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_netdev_rename_by_name",
          "args": [
            "oldname",
            "*newnamep"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_netdev_rename_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "350-363",
          "snippet": "int lxc_netdev_rename_by_name(const char *oldname, const char *newname)\n{\n\tint len, index;\n\n\tlen = strlen(oldname);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\treturn -EINVAL;\n\n\tindex = if_nametoindex(oldname);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\treturn lxc_netdev_rename_by_index(index, newname);\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_netdev_rename_by_name(const char *oldname, const char *newname)\n{\n\tint len, index;\n\n\tlen = strlen(oldname);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\treturn -EINVAL;\n\n\tindex = if_nametoindex(oldname);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\treturn lxc_netdev_rename_by_index(index, newname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"failed to get netdev index\\n\""
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_nametoindex",
          "args": [
            "oldname"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"setns to container network namespace\\n\""
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed opening network namespace path for '%d'.\"",
            "pid"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_preserve_ns",
          "args": [
            "pid",
            "\"net\""
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_preserve_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1965-1983",
          "snippet": "int lxc_preserve_ns(const int pid, const char *ns)\n{\n\tint ret;\n/* 5 /proc + 21 /int_as_str + 3 /ns + 20 /NS_NAME + 1 \\0 */\n#define __NS_PATH_LEN 50\n\tchar path[__NS_PATH_LEN];\n\n\t/* This way we can use this function to also check whether namespaces\n\t * are supported by the kernel by passing in the NULL or the empty\n\t * string.\n\t */\n\tret = snprintf(path, __NS_PATH_LEN, \"/proc/%d/ns%s%s\", pid,\n\t\t       !ns || strcmp(ns, \"\") == 0 ? \"\" : \"/\",\n\t\t       !ns || strcmp(ns, \"\") == 0 ? \"\" : ns);\n\tif (ret < 0 || (size_t)ret >= __NS_PATH_LEN)\n\t\treturn -1;\n\n\treturn open(path, O_RDONLY | O_CLOEXEC);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define __NS_PATH_LEN 50"
          ],
          "globals_used": [
            "extern bool btrfs_try_remove_subvol(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\n#define __NS_PATH_LEN 50\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nint lxc_preserve_ns(const int pid, const char *ns)\n{\n\tint ret;\n/* 5 /proc + 21 /int_as_str + 3 /ns + 20 /NS_NAME + 1 \\0 */\n#define __NS_PATH_LEN 50\n\tchar path[__NS_PATH_LEN];\n\n\t/* This way we can use this function to also check whether namespaces\n\t * are supported by the kernel by passing in the NULL or the empty\n\t * string.\n\t */\n\tret = snprintf(path, __NS_PATH_LEN, \"/proc/%d/ns%s%s\", pid,\n\t\t       !ns || strcmp(ns, \"\") == 0 ? \"\" : \"/\",\n\t\t       !ns || strcmp(ns, \"\") == 0 ? \"\" : ns);\n\tif (ret < 0 || (size_t)ret >= __NS_PATH_LEN)\n\t\treturn -1;\n\n\treturn open(path, O_RDONLY | O_CLOEXEC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed opening network namespace path for '%d'.\"",
            "getpid()"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define VETH_DEF_NAME \"eth%d\"\n\nstatic int rename_in_ns(int pid, char *oldname, char **newnamep)\n{\n\tint fd = -1, ofd = -1, ret, ifindex = -1;\n\tbool grab_newname = false;\n\n\tofd = lxc_preserve_ns(getpid(), \"net\");\n\tif (ofd < 0) {\n\t\tfprintf(stderr, \"Failed opening network namespace path for '%d'.\", getpid());\n\t\treturn -1;\n\t}\n\n\tfd = lxc_preserve_ns(pid, \"net\");\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Failed opening network namespace path for '%d'.\", pid);\n\t\treturn -1;\n\t}\n\n\tif (setns(fd, 0) < 0) {\n\t\tfprintf(stderr, \"setns to container network namespace\\n\");\n\t\tgoto out_err;\n\t}\n\tclose(fd); fd = -1;\n\tif (!*newnamep) {\n\t\tgrab_newname = true;\n\t\t*newnamep = VETH_DEF_NAME;\n\t\tif (!(ifindex = if_nametoindex(oldname))) {\n\t\t\tfprintf(stderr, \"failed to get netdev index\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\tif ((ret = lxc_netdev_rename_by_name(oldname, *newnamep)) < 0) {\n\t\tfprintf(stderr, \"Error %d renaming netdev %s to %s in container\\n\", ret, oldname, *newnamep);\n\t\tgoto out_err;\n\t}\n\tif (grab_newname) {\n\t\tchar ifname[IFNAMSIZ], *namep = ifname;\n\t\tif (!if_indextoname(ifindex, namep)) {\n\t\t\tfprintf(stderr, \"Failed to get new netdev name\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t\t*newnamep = strdup(namep);\n\t\tif (!*newnamep)\n\t\t\tgoto out_err;\n\t}\n\tif (setns(ofd, 0) < 0) {\n\t\tfprintf(stderr, \"Error returning to original netns\\n\");\n\t\tclose(ofd);\n\t\treturn -1;\n\t}\n\tclose(ofd);\n\n\treturn 0;\n\nout_err:\n\tif (ofd >= 0)\n\t\tclose(ofd);\n\tif (setns(ofd, 0) < 0)\n\t\tfprintf(stderr, \"Error returning to original network namespace\\n\");\n\tif (fd >= 0)\n\t\tclose(fd);\n\treturn -1;\n}"
  },
  {
    "function_name": "create_db_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
    "lines": "651-670",
    "snippet": "static bool create_db_dir(char *fnam)\n{\n\tchar *p = alloca(strlen(fnam)+1);\n\n\tstrcpy(p, fnam);\n\tfnam = p;\n\tp = p + 1;\nagain:\n\twhile (*p && *p != '/') p++;\n\tif (!*p)\n\t\treturn true;\n\t*p = '\\0';\n\tif (mkdir(fnam, 0755) && errno != EEXIST) {\n\t\tfprintf(stderr, \"failed to create %s\\n\", fnam);\n\t\t*p = '/';\n\t\treturn false;\n\t}\n\t*(p++) = '/';\n\tgoto again;\n}",
    "includes": [
      "#include \"network.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <linux/netlink.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <sched.h>",
      "#include <string.h>",
      "#include <alloca.h>",
      "#include <sys/file.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <stdbool.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"failed to create %s\\n\"",
            "fnam"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "fnam",
            "0755"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "241-262",
          "snippet": "extern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "p",
            "fnam"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "strlen(fnam)+1"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fnam"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool create_db_dir(char *fnam)\n{\n\tchar *p = alloca(strlen(fnam)+1);\n\n\tstrcpy(p, fnam);\n\tfnam = p;\n\tp = p + 1;\nagain:\n\twhile (*p && *p != '/') p++;\n\tif (!*p)\n\t\treturn true;\n\t*p = '\\0';\n\tif (mkdir(fnam, 0755) && errno != EEXIST) {\n\t\tfprintf(stderr, \"failed to create %s\\n\", fnam);\n\t\t*p = '/';\n\t\treturn false;\n\t}\n\t*(p++) = '/';\n\tgoto again;\n}"
  },
  {
    "function_name": "get_nic_if_avail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
    "lines": "580-649",
    "snippet": "static bool get_nic_if_avail(int fd, struct alloted_s *names, int pid, char *intype, char *br, int allowed, char **nicname, char **cnic)\n{\n\toff_t len, slen;\n\tstruct stat sb;\n\tchar *buf = NULL, *newline;\n\tint ret, count = 0;\n\tchar *owner;\n\tstruct alloted_s *n;\n\n\tfor (n=names; n!=NULL; n=n->next)\n\t\tcull_entries(fd, n->name, intype, br);\n\n\tif (allowed == 0)\n\t\treturn false;\n\n\towner = names->name;\n\n\tif (fstat(fd, &sb) < 0) {\n\t\tfprintf(stderr, \"Failed to fstat: %s\\n\", strerror(errno));\n\t\treturn false;\n\t}\n\tlen = sb.st_size;\n\tif (len != 0) {\n\t\tbuf = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n\t\tif (buf == MAP_FAILED) {\n\t\t\tfprintf(stderr, \"Failed to create mapping\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\towner = NULL;\n\t\tfor (n=names; n!=NULL; n=n->next) {\n\t\t\tcount = count_entries(buf, len, n->name, intype, br);\n\n\t\t\tif (count >= n->allowed)\n\t\t\t\tcontinue;\n\n\t\t\towner = n->name;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (owner == NULL)\n\t\treturn false;\n\n\tif (!get_new_nicname(nicname, br, pid, cnic))\n\t\treturn false;\n\t/* owner  ' ' intype ' ' br ' ' *nicname + '\\n' + '\\0' */\n\tslen = strlen(owner) + strlen(intype) + strlen(br) + strlen(*nicname) + 5;\n\tnewline = alloca(slen);\n\tret = snprintf(newline, slen, \"%s %s %s %s\\n\", owner, intype, br, *nicname);\n\tif (ret < 0 || ret >= slen) {\n\t\tif (lxc_netdev_delete_by_name(*nicname) != 0)\n\t\t\tfprintf(stderr, \"Error unlinking %s!\\n\", *nicname);\n\t\treturn false;\n\t}\n\tif (len)\n\t\tmunmap(buf, len);\n\tif (ftruncate(fd, len + slen))\n\t\tfprintf(stderr, \"Failed to set new file size\\n\");\n\tbuf = mmap(NULL, len + slen, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n\tif (buf == MAP_FAILED) {\n\t\tfprintf(stderr, \"Failed to create mapping after extending: %s\\n\", strerror(errno));\n\t\tif (lxc_netdev_delete_by_name(*nicname) != 0)\n\t\t\tfprintf(stderr, \"Error unlinking %s!\\n\", *nicname);\n\t\treturn false;\n\t}\n\tstrcpy(buf+len, newline);\n\tmunmap(buf, len+slen);\n\treturn true;\n}",
    "includes": [
      "#include \"network.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <linux/netlink.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <sched.h>",
      "#include <string.h>",
      "#include <alloca.h>",
      "#include <sys/file.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <stdbool.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "munmap",
          "args": [
            "buf",
            "len+slen"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_strmunmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1885-1888",
          "snippet": "int lxc_strmunmap(void *addr, size_t length)\n{\n\treturn munmap(addr, length + 1);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_strmunmap(void *addr, size_t length)\n{\n\treturn munmap(addr, length + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "buf+len",
            "newline"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error unlinking %s!\\n\"",
            "*nicname"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_netdev_delete_by_name",
          "args": [
            "*nicname"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_netdev_delete_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "295-304",
          "snippet": "int lxc_netdev_delete_by_name(const char *name)\n{\n\tint index;\n\n\tindex = if_nametoindex(name);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\treturn lxc_netdev_delete_by_index(index);\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_netdev_delete_by_name(const char *name)\n{\n\tint index;\n\n\tindex = if_nametoindex(name);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\treturn lxc_netdev_delete_by_index(index);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to create mapping after extending: %s\\n\"",
            "strerror(errno)"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmap",
          "args": [
            "NULL",
            "len + slen",
            "PROT_READ|PROT_WRITE",
            "MAP_SHARED",
            "fd",
            "0"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_strmmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1863-1883",
          "snippet": "void *lxc_strmmap(void *addr, size_t length, int prot, int flags, int fd,\n\t\t  off_t offset)\n{\n\tvoid *tmp = NULL, *overlap = NULL;\n\n\t/* We establish an anonymous mapping that is one byte larger than the\n\t * underlying file. The pages handed to us are zero filled. */\n\ttmp = mmap(addr, length + 1, PROT_READ, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\tif (tmp == MAP_FAILED)\n\t\treturn tmp;\n\n\t/* Now we establish a fixed-address mapping starting at the address we\n\t * received from our anonymous mapping and replace all bytes excluding\n\t * the additional \\0-byte with the file. This allows us to use normal\n\t * string-handling functions. */\n\toverlap = mmap(tmp, length, prot, MAP_FIXED | flags, fd, offset);\n\tif (overlap == MAP_FAILED)\n\t\tmunmap(tmp, length + 1);\n\n\treturn overlap;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid *lxc_strmmap(void *addr, size_t length, int prot, int flags, int fd,\n\t\t  off_t offset)\n{\n\tvoid *tmp = NULL, *overlap = NULL;\n\n\t/* We establish an anonymous mapping that is one byte larger than the\n\t * underlying file. The pages handed to us are zero filled. */\n\ttmp = mmap(addr, length + 1, PROT_READ, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\tif (tmp == MAP_FAILED)\n\t\treturn tmp;\n\n\t/* Now we establish a fixed-address mapping starting at the address we\n\t * received from our anonymous mapping and replace all bytes excluding\n\t * the additional \\0-byte with the file. This allows us to use normal\n\t * string-handling functions. */\n\toverlap = mmap(tmp, length, prot, MAP_FIXED | flags, fd, offset);\n\tif (overlap == MAP_FAILED)\n\t\tmunmap(tmp, length + 1);\n\n\treturn overlap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to set new file size\\n\""
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftruncate",
          "args": [
            "fd",
            "len + slen"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error unlinking %s!\\n\"",
            "*nicname"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "newline",
            "slen",
            "\"%s %s %s %s\\n\"",
            "owner",
            "intype",
            "br",
            "*nicname"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "slen"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "*nicname"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "br"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "intype"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "owner"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_new_nicname",
          "args": [
            "nicname",
            "br",
            "pid",
            "cnic"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "get_new_nicname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
          "lines": "473-483",
          "snippet": "static bool get_new_nicname(char **dest, char *br, int pid, char **cnic)\n{\n\tchar template[IFNAMSIZ];\n\tsnprintf(template, sizeof(template), \"vethXXXXXX\");\n\t*dest = lxc_mkifname(template);\n\n\tif (!create_nic(*dest, br, pid, cnic)) {\n\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"network.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <linux/netlink.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <sched.h>",
            "#include <string.h>",
            "#include <alloca.h>",
            "#include <sys/file.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool get_new_nicname(char **dest, char *br, int pid, char **cnic)\n{\n\tchar template[IFNAMSIZ];\n\tsnprintf(template, sizeof(template), \"vethXXXXXX\");\n\t*dest = lxc_mkifname(template);\n\n\tif (!create_nic(*dest, br, pid, cnic)) {\n\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_entries",
          "args": [
            "buf",
            "len",
            "n->name",
            "intype",
            "br"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "count_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
          "lines": "562-574",
          "snippet": "static int count_entries(char *buf, off_t len, char *me, char *t, char *br)\n{\n\tchar *e = &buf[len];\n\tint count = 0;\n\twhile ((buf = find_line(buf, e, me, t, br)) != NULL) {\n\t\tcount++;\n\t\tbuf = get_eol(buf, e)+1;\n\t\tif (buf >= e)\n\t\t\tbreak;\n\t}\n\n\treturn count;\n}",
          "includes": [
            "#include \"network.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <linux/netlink.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <sched.h>",
            "#include <string.h>",
            "#include <alloca.h>",
            "#include <sys/file.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int count_entries(char *buf, off_t len, char *me, char *t, char *br)\n{\n\tchar *e = &buf[len];\n\tint count = 0;\n\twhile ((buf = find_line(buf, e, me, t, br)) != NULL) {\n\t\tcount++;\n\t\tbuf = get_eol(buf, e)+1;\n\t\tif (buf >= e)\n\t\t\tbreak;\n\t}\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to create mapping\\n\""
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to fstat: %s\\n\"",
            "strerror(errno)"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&sb"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cull_entries",
          "args": [
            "fd",
            "n->name",
            "intype",
            "br"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "cull_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
          "lines": "502-560",
          "snippet": "static bool cull_entries(int fd, char *me, char *t, char *br)\n{\n\tstruct stat sb;\n\tchar *buf, *p, *e, *nic;\n\toff_t len;\n\tstruct entry_line *entry_lines = NULL;\n\tint i, n = 0;\n\n\tnic = alloca(100);\n\n\tif (fstat(fd, &sb) < 0) {\n\t\tfprintf(stderr, \"Failed to fstat: %s\\n\", strerror(errno));\n\t\treturn false;\n\t}\n\tlen = sb.st_size;\n\tif (len == 0)\n\t\treturn true;\n\tbuf = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n\tif (buf == MAP_FAILED) {\n\t\tfprintf(stderr, \"Failed to create mapping: %s\\n\", strerror(errno));\n\t\treturn false;\n\t}\n\n\tp = buf;\n\te = buf + len;\n\twhile ((p = find_line(p, e, me, t, br)) != NULL) {\n\t\tstruct entry_line *newe = realloc(entry_lines, sizeof(*entry_lines)*(n+1));\n\t\tif (!newe) {\n\t\t\tfree(entry_lines);\n\t\t\treturn false;\n\t\t}\n\t\tentry_lines = newe;\n\t\tentry_lines[n].start = p;\n\t\tentry_lines[n].len = get_eol(p, e) - entry_lines[n].start;\n\t\tentry_lines[n].keep = true;\n\t\tn++;\n\t\tif (!get_nic_from_line(p, &nic))\n\t\t\tcontinue;\n\t\tif (nic && !nic_exists(nic))\n\t\t\tentry_lines[n-1].keep = false;\n\t\tp += entry_lines[n-1].len + 1;\n\t\tif (p >= e)\n\t\t\tbreak;\n \t}\n\tp = buf;\n\tfor (i=0; i<n; i++) {\n\t\tif (!entry_lines[i].keep)\n\t\t\tcontinue;\n\t\tmemcpy(p, entry_lines[i].start, entry_lines[i].len);\n\t\tp += entry_lines[i].len;\n\t\t*p = '\\n';\n\t\tp++;\n\t}\n\tfree(entry_lines);\n\tmunmap(buf, sb.st_size);\n\tif (ftruncate(fd, p-buf))\n\t\tfprintf(stderr, \"Failed to set new file size\\n\");\n\treturn true;\n}",
          "includes": [
            "#include \"network.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <linux/netlink.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <sched.h>",
            "#include <string.h>",
            "#include <alloca.h>",
            "#include <sys/file.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool cull_entries(int fd, char *me, char *t, char *br)\n{\n\tstruct stat sb;\n\tchar *buf, *p, *e, *nic;\n\toff_t len;\n\tstruct entry_line *entry_lines = NULL;\n\tint i, n = 0;\n\n\tnic = alloca(100);\n\n\tif (fstat(fd, &sb) < 0) {\n\t\tfprintf(stderr, \"Failed to fstat: %s\\n\", strerror(errno));\n\t\treturn false;\n\t}\n\tlen = sb.st_size;\n\tif (len == 0)\n\t\treturn true;\n\tbuf = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n\tif (buf == MAP_FAILED) {\n\t\tfprintf(stderr, \"Failed to create mapping: %s\\n\", strerror(errno));\n\t\treturn false;\n\t}\n\n\tp = buf;\n\te = buf + len;\n\twhile ((p = find_line(p, e, me, t, br)) != NULL) {\n\t\tstruct entry_line *newe = realloc(entry_lines, sizeof(*entry_lines)*(n+1));\n\t\tif (!newe) {\n\t\t\tfree(entry_lines);\n\t\t\treturn false;\n\t\t}\n\t\tentry_lines = newe;\n\t\tentry_lines[n].start = p;\n\t\tentry_lines[n].len = get_eol(p, e) - entry_lines[n].start;\n\t\tentry_lines[n].keep = true;\n\t\tn++;\n\t\tif (!get_nic_from_line(p, &nic))\n\t\t\tcontinue;\n\t\tif (nic && !nic_exists(nic))\n\t\t\tentry_lines[n-1].keep = false;\n\t\tp += entry_lines[n-1].len + 1;\n\t\tif (p >= e)\n\t\t\tbreak;\n \t}\n\tp = buf;\n\tfor (i=0; i<n; i++) {\n\t\tif (!entry_lines[i].keep)\n\t\t\tcontinue;\n\t\tmemcpy(p, entry_lines[i].start, entry_lines[i].len);\n\t\tp += entry_lines[i].len;\n\t\t*p = '\\n';\n\t\tp++;\n\t}\n\tfree(entry_lines);\n\tmunmap(buf, sb.st_size);\n\tif (ftruncate(fd, p-buf))\n\t\tfprintf(stderr, \"Failed to set new file size\\n\");\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool get_nic_if_avail(int fd, struct alloted_s *names, int pid, char *intype, char *br, int allowed, char **nicname, char **cnic)\n{\n\toff_t len, slen;\n\tstruct stat sb;\n\tchar *buf = NULL, *newline;\n\tint ret, count = 0;\n\tchar *owner;\n\tstruct alloted_s *n;\n\n\tfor (n=names; n!=NULL; n=n->next)\n\t\tcull_entries(fd, n->name, intype, br);\n\n\tif (allowed == 0)\n\t\treturn false;\n\n\towner = names->name;\n\n\tif (fstat(fd, &sb) < 0) {\n\t\tfprintf(stderr, \"Failed to fstat: %s\\n\", strerror(errno));\n\t\treturn false;\n\t}\n\tlen = sb.st_size;\n\tif (len != 0) {\n\t\tbuf = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n\t\tif (buf == MAP_FAILED) {\n\t\t\tfprintf(stderr, \"Failed to create mapping\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\towner = NULL;\n\t\tfor (n=names; n!=NULL; n=n->next) {\n\t\t\tcount = count_entries(buf, len, n->name, intype, br);\n\n\t\t\tif (count >= n->allowed)\n\t\t\t\tcontinue;\n\n\t\t\towner = n->name;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (owner == NULL)\n\t\treturn false;\n\n\tif (!get_new_nicname(nicname, br, pid, cnic))\n\t\treturn false;\n\t/* owner  ' ' intype ' ' br ' ' *nicname + '\\n' + '\\0' */\n\tslen = strlen(owner) + strlen(intype) + strlen(br) + strlen(*nicname) + 5;\n\tnewline = alloca(slen);\n\tret = snprintf(newline, slen, \"%s %s %s %s\\n\", owner, intype, br, *nicname);\n\tif (ret < 0 || ret >= slen) {\n\t\tif (lxc_netdev_delete_by_name(*nicname) != 0)\n\t\t\tfprintf(stderr, \"Error unlinking %s!\\n\", *nicname);\n\t\treturn false;\n\t}\n\tif (len)\n\t\tmunmap(buf, len);\n\tif (ftruncate(fd, len + slen))\n\t\tfprintf(stderr, \"Failed to set new file size\\n\");\n\tbuf = mmap(NULL, len + slen, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n\tif (buf == MAP_FAILED) {\n\t\tfprintf(stderr, \"Failed to create mapping after extending: %s\\n\", strerror(errno));\n\t\tif (lxc_netdev_delete_by_name(*nicname) != 0)\n\t\t\tfprintf(stderr, \"Error unlinking %s!\\n\", *nicname);\n\t\treturn false;\n\t}\n\tstrcpy(buf+len, newline);\n\tmunmap(buf, len+slen);\n\treturn true;\n}"
  },
  {
    "function_name": "count_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
    "lines": "562-574",
    "snippet": "static int count_entries(char *buf, off_t len, char *me, char *t, char *br)\n{\n\tchar *e = &buf[len];\n\tint count = 0;\n\twhile ((buf = find_line(buf, e, me, t, br)) != NULL) {\n\t\tcount++;\n\t\tbuf = get_eol(buf, e)+1;\n\t\tif (buf >= e)\n\t\t\tbreak;\n\t}\n\n\treturn count;\n}",
    "includes": [
      "#include \"network.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <linux/netlink.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <sched.h>",
      "#include <string.h>",
      "#include <alloca.h>",
      "#include <sys/file.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <stdbool.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_eol",
          "args": [
            "buf",
            "e"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "get_eol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
          "lines": "321-326",
          "snippet": "static char *get_eol(char *s, char *e)\n{\n\twhile (s<e && *s && *s != '\\n')\n\t\ts++;\n\treturn s;\n}",
          "includes": [
            "#include \"network.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <linux/netlink.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <sched.h>",
            "#include <string.h>",
            "#include <alloca.h>",
            "#include <sys/file.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *get_eol(char *s, char *e)\n{\n\twhile (s<e && *s && *s != '\\n')\n\t\ts++;\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_line",
          "args": [
            "buf",
            "e",
            "me",
            "t",
            "br"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "find_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
          "lines": "335-363",
          "snippet": "static char *find_line(char *p, char *e, char *u, char *t, char *l)\n{\n\tchar *p1, *p2, *ret;\n\n\twhile (p<e  && (p1 = get_eol(p, e)) < e) {\n\t\tret = p;\n\t\tif (*p == '#')\n\t\t\tgoto next;\n\t\twhile (p<e && isblank(*p)) p++;\n\t\tp2 = get_eow(p, e);\n\t\tif (!p2 || p2-p != strlen(u) || strncmp(p, u, strlen(u)) != 0)\n\t\t\tgoto next;\n\t\tp = p2+1;\n\t\twhile (p<e && isblank(*p)) p++;\n\t\tp2 = get_eow(p, e);\n\t\tif (!p2 || p2-p != strlen(t) || strncmp(p, t, strlen(t)) != 0)\n\t\t\tgoto next;\n\t\tp = p2+1;\n\t\twhile (p<e && isblank(*p)) p++;\n\t\tp2 = get_eow(p, e);\n\t\tif (!p2 || p2-p != strlen(l) || strncmp(p, l, strlen(l)) != 0)\n\t\t\tgoto next;\n\t\treturn ret;\nnext:\n\t\tp = p1 + 1;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"network.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <linux/netlink.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <sched.h>",
            "#include <string.h>",
            "#include <alloca.h>",
            "#include <sys/file.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *find_line(char *p, char *e, char *u, char *t, char *l)\n{\n\tchar *p1, *p2, *ret;\n\n\twhile (p<e  && (p1 = get_eol(p, e)) < e) {\n\t\tret = p;\n\t\tif (*p == '#')\n\t\t\tgoto next;\n\t\twhile (p<e && isblank(*p)) p++;\n\t\tp2 = get_eow(p, e);\n\t\tif (!p2 || p2-p != strlen(u) || strncmp(p, u, strlen(u)) != 0)\n\t\t\tgoto next;\n\t\tp = p2+1;\n\t\twhile (p<e && isblank(*p)) p++;\n\t\tp2 = get_eow(p, e);\n\t\tif (!p2 || p2-p != strlen(t) || strncmp(p, t, strlen(t)) != 0)\n\t\t\tgoto next;\n\t\tp = p2+1;\n\t\twhile (p<e && isblank(*p)) p++;\n\t\tp2 = get_eow(p, e);\n\t\tif (!p2 || p2-p != strlen(l) || strncmp(p, l, strlen(l)) != 0)\n\t\t\tgoto next;\n\t\treturn ret;\nnext:\n\t\tp = p1 + 1;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int count_entries(char *buf, off_t len, char *me, char *t, char *br)\n{\n\tchar *e = &buf[len];\n\tint count = 0;\n\twhile ((buf = find_line(buf, e, me, t, br)) != NULL) {\n\t\tcount++;\n\t\tbuf = get_eol(buf, e)+1;\n\t\tif (buf >= e)\n\t\t\tbreak;\n\t}\n\n\treturn count;\n}"
  },
  {
    "function_name": "cull_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
    "lines": "502-560",
    "snippet": "static bool cull_entries(int fd, char *me, char *t, char *br)\n{\n\tstruct stat sb;\n\tchar *buf, *p, *e, *nic;\n\toff_t len;\n\tstruct entry_line *entry_lines = NULL;\n\tint i, n = 0;\n\n\tnic = alloca(100);\n\n\tif (fstat(fd, &sb) < 0) {\n\t\tfprintf(stderr, \"Failed to fstat: %s\\n\", strerror(errno));\n\t\treturn false;\n\t}\n\tlen = sb.st_size;\n\tif (len == 0)\n\t\treturn true;\n\tbuf = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n\tif (buf == MAP_FAILED) {\n\t\tfprintf(stderr, \"Failed to create mapping: %s\\n\", strerror(errno));\n\t\treturn false;\n\t}\n\n\tp = buf;\n\te = buf + len;\n\twhile ((p = find_line(p, e, me, t, br)) != NULL) {\n\t\tstruct entry_line *newe = realloc(entry_lines, sizeof(*entry_lines)*(n+1));\n\t\tif (!newe) {\n\t\t\tfree(entry_lines);\n\t\t\treturn false;\n\t\t}\n\t\tentry_lines = newe;\n\t\tentry_lines[n].start = p;\n\t\tentry_lines[n].len = get_eol(p, e) - entry_lines[n].start;\n\t\tentry_lines[n].keep = true;\n\t\tn++;\n\t\tif (!get_nic_from_line(p, &nic))\n\t\t\tcontinue;\n\t\tif (nic && !nic_exists(nic))\n\t\t\tentry_lines[n-1].keep = false;\n\t\tp += entry_lines[n-1].len + 1;\n\t\tif (p >= e)\n\t\t\tbreak;\n \t}\n\tp = buf;\n\tfor (i=0; i<n; i++) {\n\t\tif (!entry_lines[i].keep)\n\t\t\tcontinue;\n\t\tmemcpy(p, entry_lines[i].start, entry_lines[i].len);\n\t\tp += entry_lines[i].len;\n\t\t*p = '\\n';\n\t\tp++;\n\t}\n\tfree(entry_lines);\n\tmunmap(buf, sb.st_size);\n\tif (ftruncate(fd, p-buf))\n\t\tfprintf(stderr, \"Failed to set new file size\\n\");\n\treturn true;\n}",
    "includes": [
      "#include \"network.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <linux/netlink.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <sched.h>",
      "#include <string.h>",
      "#include <alloca.h>",
      "#include <sys/file.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <stdbool.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to set new file size\\n\""
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftruncate",
          "args": [
            "fd",
            "p-buf"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "munmap",
          "args": [
            "buf",
            "sb.st_size"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_strmunmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1885-1888",
          "snippet": "int lxc_strmunmap(void *addr, size_t length)\n{\n\treturn munmap(addr, length + 1);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_strmunmap(void *addr, size_t length)\n{\n\treturn munmap(addr, length + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "entry_lines"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "free_alloted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
          "lines": "235-251",
          "snippet": "static void free_alloted(struct alloted_s **head)\n{\n\tstruct alloted_s *cur;\n\n\tif (head == NULL) {\n\t\treturn;\n\t}\n\n\tcur = *head;\n\n\twhile (cur != NULL) {\n\t\tcur = cur->next;\n\t\tfree((*head)->name);\n\t\tfree(*head);\n\t\t*head = cur;\n\t}\n}",
          "includes": [
            "#include \"network.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <linux/netlink.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <sched.h>",
            "#include <string.h>",
            "#include <alloca.h>",
            "#include <sys/file.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic void free_alloted(struct alloted_s **head)\n{\n\tstruct alloted_s *cur;\n\n\tif (head == NULL) {\n\t\treturn;\n\t}\n\n\tcur = *head;\n\n\twhile (cur != NULL) {\n\t\tcur = cur->next;\n\t\tfree((*head)->name);\n\t\tfree(*head);\n\t\t*head = cur;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "entry_lines[i].start",
            "entry_lines[i].len"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nic_exists",
          "args": [
            "nic"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "nic_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
          "lines": "365-380",
          "snippet": "static bool nic_exists(char *nic)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\tstruct stat sb;\n\n\tif (strcmp(nic, \"none\") == 0)\n\t\treturn true;\n\tret = snprintf(path, MAXPATHLEN, \"/sys/class/net/%s\", nic);\n\tif (ret < 0 || ret >= MAXPATHLEN) // should never happen!\n\t\treturn false;\n\tret = stat(path, &sb);\n\tif (ret != 0)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"network.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <linux/netlink.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <sched.h>",
            "#include <string.h>",
            "#include <alloca.h>",
            "#include <sys/file.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool nic_exists(char *nic)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\tstruct stat sb;\n\n\tif (strcmp(nic, \"none\") == 0)\n\t\treturn true;\n\tret = snprintf(path, MAXPATHLEN, \"/sys/class/net/%s\", nic);\n\tif (ret < 0 || ret >= MAXPATHLEN) // should never happen!\n\t\treturn false;\n\tret = stat(path, &sb);\n\tif (ret != 0)\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nic_from_line",
          "args": [
            "p",
            "&nic"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "get_nic_from_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
          "lines": "485-494",
          "snippet": "static bool get_nic_from_line(char *p, char **nic)\n{\n\tchar user[100], type[100], br[100];\n\tint ret;\n\n\tret = sscanf(p, \"%99[^ \\t\\n] %99[^ \\t\\n] %99[^ \\t\\n] %99[^ \\t\\n]\", user, type, br, *nic);\n\tif (ret != 4)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"network.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <linux/netlink.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <sched.h>",
            "#include <string.h>",
            "#include <alloca.h>",
            "#include <sys/file.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool get_nic_from_line(char *p, char **nic)\n{\n\tchar user[100], type[100], br[100];\n\tint ret;\n\n\tret = sscanf(p, \"%99[^ \\t\\n] %99[^ \\t\\n] %99[^ \\t\\n] %99[^ \\t\\n]\", user, type, br, *nic);\n\tif (ret != 4)\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_eol",
          "args": [
            "p",
            "e"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "get_eol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
          "lines": "321-326",
          "snippet": "static char *get_eol(char *s, char *e)\n{\n\twhile (s<e && *s && *s != '\\n')\n\t\ts++;\n\treturn s;\n}",
          "includes": [
            "#include \"network.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <linux/netlink.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <sched.h>",
            "#include <string.h>",
            "#include <alloca.h>",
            "#include <sys/file.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *get_eol(char *s, char *e)\n{\n\twhile (s<e && *s && *s != '\\n')\n\t\ts++;\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "entry_lines",
            "sizeof(*entry_lines)*(n+1)"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "must_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "116-124",
          "snippet": "static void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_line",
          "args": [
            "p",
            "e",
            "me",
            "t",
            "br"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "find_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
          "lines": "335-363",
          "snippet": "static char *find_line(char *p, char *e, char *u, char *t, char *l)\n{\n\tchar *p1, *p2, *ret;\n\n\twhile (p<e  && (p1 = get_eol(p, e)) < e) {\n\t\tret = p;\n\t\tif (*p == '#')\n\t\t\tgoto next;\n\t\twhile (p<e && isblank(*p)) p++;\n\t\tp2 = get_eow(p, e);\n\t\tif (!p2 || p2-p != strlen(u) || strncmp(p, u, strlen(u)) != 0)\n\t\t\tgoto next;\n\t\tp = p2+1;\n\t\twhile (p<e && isblank(*p)) p++;\n\t\tp2 = get_eow(p, e);\n\t\tif (!p2 || p2-p != strlen(t) || strncmp(p, t, strlen(t)) != 0)\n\t\t\tgoto next;\n\t\tp = p2+1;\n\t\twhile (p<e && isblank(*p)) p++;\n\t\tp2 = get_eow(p, e);\n\t\tif (!p2 || p2-p != strlen(l) || strncmp(p, l, strlen(l)) != 0)\n\t\t\tgoto next;\n\t\treturn ret;\nnext:\n\t\tp = p1 + 1;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"network.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <linux/netlink.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <sched.h>",
            "#include <string.h>",
            "#include <alloca.h>",
            "#include <sys/file.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *find_line(char *p, char *e, char *u, char *t, char *l)\n{\n\tchar *p1, *p2, *ret;\n\n\twhile (p<e  && (p1 = get_eol(p, e)) < e) {\n\t\tret = p;\n\t\tif (*p == '#')\n\t\t\tgoto next;\n\t\twhile (p<e && isblank(*p)) p++;\n\t\tp2 = get_eow(p, e);\n\t\tif (!p2 || p2-p != strlen(u) || strncmp(p, u, strlen(u)) != 0)\n\t\t\tgoto next;\n\t\tp = p2+1;\n\t\twhile (p<e && isblank(*p)) p++;\n\t\tp2 = get_eow(p, e);\n\t\tif (!p2 || p2-p != strlen(t) || strncmp(p, t, strlen(t)) != 0)\n\t\t\tgoto next;\n\t\tp = p2+1;\n\t\twhile (p<e && isblank(*p)) p++;\n\t\tp2 = get_eow(p, e);\n\t\tif (!p2 || p2-p != strlen(l) || strncmp(p, l, strlen(l)) != 0)\n\t\t\tgoto next;\n\t\treturn ret;\nnext:\n\t\tp = p1 + 1;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to create mapping: %s\\n\"",
            "strerror(errno)"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmap",
          "args": [
            "NULL",
            "len",
            "PROT_READ|PROT_WRITE",
            "MAP_SHARED",
            "fd",
            "0"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_strmmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1863-1883",
          "snippet": "void *lxc_strmmap(void *addr, size_t length, int prot, int flags, int fd,\n\t\t  off_t offset)\n{\n\tvoid *tmp = NULL, *overlap = NULL;\n\n\t/* We establish an anonymous mapping that is one byte larger than the\n\t * underlying file. The pages handed to us are zero filled. */\n\ttmp = mmap(addr, length + 1, PROT_READ, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\tif (tmp == MAP_FAILED)\n\t\treturn tmp;\n\n\t/* Now we establish a fixed-address mapping starting at the address we\n\t * received from our anonymous mapping and replace all bytes excluding\n\t * the additional \\0-byte with the file. This allows us to use normal\n\t * string-handling functions. */\n\toverlap = mmap(tmp, length, prot, MAP_FIXED | flags, fd, offset);\n\tif (overlap == MAP_FAILED)\n\t\tmunmap(tmp, length + 1);\n\n\treturn overlap;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid *lxc_strmmap(void *addr, size_t length, int prot, int flags, int fd,\n\t\t  off_t offset)\n{\n\tvoid *tmp = NULL, *overlap = NULL;\n\n\t/* We establish an anonymous mapping that is one byte larger than the\n\t * underlying file. The pages handed to us are zero filled. */\n\ttmp = mmap(addr, length + 1, PROT_READ, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\tif (tmp == MAP_FAILED)\n\t\treturn tmp;\n\n\t/* Now we establish a fixed-address mapping starting at the address we\n\t * received from our anonymous mapping and replace all bytes excluding\n\t * the additional \\0-byte with the file. This allows us to use normal\n\t * string-handling functions. */\n\toverlap = mmap(tmp, length, prot, MAP_FIXED | flags, fd, offset);\n\tif (overlap == MAP_FAILED)\n\t\tmunmap(tmp, length + 1);\n\n\treturn overlap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to fstat: %s\\n\"",
            "strerror(errno)"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&sb"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "100"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool cull_entries(int fd, char *me, char *t, char *br)\n{\n\tstruct stat sb;\n\tchar *buf, *p, *e, *nic;\n\toff_t len;\n\tstruct entry_line *entry_lines = NULL;\n\tint i, n = 0;\n\n\tnic = alloca(100);\n\n\tif (fstat(fd, &sb) < 0) {\n\t\tfprintf(stderr, \"Failed to fstat: %s\\n\", strerror(errno));\n\t\treturn false;\n\t}\n\tlen = sb.st_size;\n\tif (len == 0)\n\t\treturn true;\n\tbuf = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n\tif (buf == MAP_FAILED) {\n\t\tfprintf(stderr, \"Failed to create mapping: %s\\n\", strerror(errno));\n\t\treturn false;\n\t}\n\n\tp = buf;\n\te = buf + len;\n\twhile ((p = find_line(p, e, me, t, br)) != NULL) {\n\t\tstruct entry_line *newe = realloc(entry_lines, sizeof(*entry_lines)*(n+1));\n\t\tif (!newe) {\n\t\t\tfree(entry_lines);\n\t\t\treturn false;\n\t\t}\n\t\tentry_lines = newe;\n\t\tentry_lines[n].start = p;\n\t\tentry_lines[n].len = get_eol(p, e) - entry_lines[n].start;\n\t\tentry_lines[n].keep = true;\n\t\tn++;\n\t\tif (!get_nic_from_line(p, &nic))\n\t\t\tcontinue;\n\t\tif (nic && !nic_exists(nic))\n\t\t\tentry_lines[n-1].keep = false;\n\t\tp += entry_lines[n-1].len + 1;\n\t\tif (p >= e)\n\t\t\tbreak;\n \t}\n\tp = buf;\n\tfor (i=0; i<n; i++) {\n\t\tif (!entry_lines[i].keep)\n\t\t\tcontinue;\n\t\tmemcpy(p, entry_lines[i].start, entry_lines[i].len);\n\t\tp += entry_lines[i].len;\n\t\t*p = '\\n';\n\t\tp++;\n\t}\n\tfree(entry_lines);\n\tmunmap(buf, sb.st_size);\n\tif (ftruncate(fd, p-buf))\n\t\tfprintf(stderr, \"Failed to set new file size\\n\");\n\treturn true;\n}"
  },
  {
    "function_name": "get_nic_from_line",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
    "lines": "485-494",
    "snippet": "static bool get_nic_from_line(char *p, char **nic)\n{\n\tchar user[100], type[100], br[100];\n\tint ret;\n\n\tret = sscanf(p, \"%99[^ \\t\\n] %99[^ \\t\\n] %99[^ \\t\\n] %99[^ \\t\\n]\", user, type, br, *nic);\n\tif (ret != 4)\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include \"network.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <linux/netlink.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <sched.h>",
      "#include <string.h>",
      "#include <alloca.h>",
      "#include <sys/file.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <stdbool.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "p",
            "\"%99[^ \\t\\n] %99[^ \\t\\n] %99[^ \\t\\n] %99[^ \\t\\n]\"",
            "user",
            "type",
            "br",
            "*nic"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool get_nic_from_line(char *p, char **nic)\n{\n\tchar user[100], type[100], br[100];\n\tint ret;\n\n\tret = sscanf(p, \"%99[^ \\t\\n] %99[^ \\t\\n] %99[^ \\t\\n] %99[^ \\t\\n]\", user, type, br, *nic);\n\tif (ret != 4)\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "get_new_nicname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
    "lines": "473-483",
    "snippet": "static bool get_new_nicname(char **dest, char *br, int pid, char **cnic)\n{\n\tchar template[IFNAMSIZ];\n\tsnprintf(template, sizeof(template), \"vethXXXXXX\");\n\t*dest = lxc_mkifname(template);\n\n\tif (!create_nic(*dest, br, pid, cnic)) {\n\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"network.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <linux/netlink.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <sched.h>",
      "#include <string.h>",
      "#include <alloca.h>",
      "#include <sys/file.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <stdbool.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_nic",
          "args": [
            "*dest",
            "br",
            "pid",
            "cnic"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "create_nic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
          "lines": "417-466",
          "snippet": "static bool create_nic(char *nic, char *br, int pid, char **cnic)\n{\n\tchar *veth1buf, *veth2buf;\n\tveth1buf = alloca(IFNAMSIZ);\n\tveth2buf = alloca(IFNAMSIZ);\n\tint ret, mtu;\n\n\tret = snprintf(veth1buf, IFNAMSIZ, \"%s\", nic);\n\tif (ret < 0 || ret >= IFNAMSIZ) {\n\t\tfprintf(stderr, \"host nic name too long\\n\");\n\t\treturn false;\n\t}\n\n\t/* create the nics */\n\tif (instantiate_veth(veth1buf, &veth2buf) < 0) {\n\t\tfprintf(stderr, \"Error creating veth tunnel\\n\");\n\t\treturn false;\n\t}\n\n\tif (strcmp(br, \"none\") != 0) {\n\t\t/* copy the bridge's mtu to both ends */\n\t\tmtu = get_mtu(br);\n\t\tif (mtu != -1) {\n\t\t\tif (lxc_netdev_set_mtu(veth1buf, mtu) < 0 ||\n\t\t\t\t\tlxc_netdev_set_mtu(veth2buf, mtu) < 0) {\n\t\t\t\tfprintf(stderr, \"Failed setting mtu\\n\");\n\t\t\t\tgoto out_del;\n\t\t\t}\n\t\t}\n\n\t\t/* attach veth1 to bridge */\n\t\tif (lxc_bridge_attach(lxcpath, lxcname, br, veth1buf) < 0) {\n\t\t\tfprintf(stderr, \"Error attaching %s to %s\\n\", veth1buf, br);\n\t\t\tgoto out_del;\n\t\t}\n\t}\n\n\t/* pass veth2 to target netns */\n\tret = lxc_netdev_move_by_name(veth2buf, pid, NULL);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"Error moving %s to netns %d\\n\", veth2buf, pid);\n\t\tgoto out_del;\n\t}\n\t*cnic = strdup(veth2buf);\n\treturn true;\n\nout_del:\n\tlxc_netdev_delete_by_name(veth1buf);\n\treturn false;\n}",
          "includes": [
            "#include \"network.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <linux/netlink.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <sched.h>",
            "#include <string.h>",
            "#include <alloca.h>",
            "#include <sys/file.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *lxcpath, *lxcname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *lxcpath, *lxcname;\n\nstatic bool create_nic(char *nic, char *br, int pid, char **cnic)\n{\n\tchar *veth1buf, *veth2buf;\n\tveth1buf = alloca(IFNAMSIZ);\n\tveth2buf = alloca(IFNAMSIZ);\n\tint ret, mtu;\n\n\tret = snprintf(veth1buf, IFNAMSIZ, \"%s\", nic);\n\tif (ret < 0 || ret >= IFNAMSIZ) {\n\t\tfprintf(stderr, \"host nic name too long\\n\");\n\t\treturn false;\n\t}\n\n\t/* create the nics */\n\tif (instantiate_veth(veth1buf, &veth2buf) < 0) {\n\t\tfprintf(stderr, \"Error creating veth tunnel\\n\");\n\t\treturn false;\n\t}\n\n\tif (strcmp(br, \"none\") != 0) {\n\t\t/* copy the bridge's mtu to both ends */\n\t\tmtu = get_mtu(br);\n\t\tif (mtu != -1) {\n\t\t\tif (lxc_netdev_set_mtu(veth1buf, mtu) < 0 ||\n\t\t\t\t\tlxc_netdev_set_mtu(veth2buf, mtu) < 0) {\n\t\t\t\tfprintf(stderr, \"Failed setting mtu\\n\");\n\t\t\t\tgoto out_del;\n\t\t\t}\n\t\t}\n\n\t\t/* attach veth1 to bridge */\n\t\tif (lxc_bridge_attach(lxcpath, lxcname, br, veth1buf) < 0) {\n\t\t\tfprintf(stderr, \"Error attaching %s to %s\\n\", veth1buf, br);\n\t\t\tgoto out_del;\n\t\t}\n\t}\n\n\t/* pass veth2 to target netns */\n\tret = lxc_netdev_move_by_name(veth2buf, pid, NULL);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"Error moving %s to netns %d\\n\", veth2buf, pid);\n\t\tgoto out_del;\n\t}\n\t*cnic = strdup(veth2buf);\n\treturn true;\n\nout_del:\n\tlxc_netdev_delete_by_name(veth1buf);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_mkifname",
          "args": [
            "template"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_mkifname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "1507-1566",
          "snippet": "char *lxc_mkifname(char *template)\n{\n\tchar *name = NULL;\n\tsize_t i = 0;\n\tFILE *urandom;\n\tunsigned int seed;\n\tstruct ifaddrs *ifaddr, *ifa;\n\tint ifexists = 0;\n\n\t/* Get all the network interfaces */\n\tgetifaddrs(&ifaddr);\n\n\t/* Initialize the random number generator */\n\turandom = fopen (\"/dev/urandom\", \"r\");\n\tif (urandom != NULL) {\n\t\tif (fread (&seed, sizeof(seed), 1, urandom) <= 0)\n\t\t\tseed = time(0);\n\t\tfclose(urandom);\n\t}\n\telse\n\t\tseed = time(0);\n\n#ifndef HAVE_RAND_R\n\tsrand(seed);\n#endif\n\n\t/* Generate random names until we find one that doesn't exist */\n\twhile(1) {\n\t\tifexists = 0;\n\t\tname = strdup(template);\n\n\t\tif (name == NULL)\n\t\t\treturn NULL;\n\n\t\tfor (i = 0; i < strlen(name); i++) {\n\t\t\tif (name[i] == 'X') {\n#ifdef HAVE_RAND_R\n\t\t\t\tname[i] = padchar[rand_r(&seed) % (strlen(padchar) - 1)];\n#else\n\t\t\t\tname[i] = padchar[rand() % (strlen(padchar) - 1)];\n#endif\n\t\t\t}\n\t\t}\n\n\t\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n\t\t\tif (strcmp(ifa->ifa_name, name) == 0) {\n\t\t\t\tifexists = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ifexists == 0)\n\t\t\tbreak;\n\n\t\tfree(name);\n\t}\n\n\tfreeifaddrs(ifaddr);\n\treturn name;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char padchar[] =\n\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic const char padchar[] =\n\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\nchar *lxc_mkifname(char *template)\n{\n\tchar *name = NULL;\n\tsize_t i = 0;\n\tFILE *urandom;\n\tunsigned int seed;\n\tstruct ifaddrs *ifaddr, *ifa;\n\tint ifexists = 0;\n\n\t/* Get all the network interfaces */\n\tgetifaddrs(&ifaddr);\n\n\t/* Initialize the random number generator */\n\turandom = fopen (\"/dev/urandom\", \"r\");\n\tif (urandom != NULL) {\n\t\tif (fread (&seed, sizeof(seed), 1, urandom) <= 0)\n\t\t\tseed = time(0);\n\t\tfclose(urandom);\n\t}\n\telse\n\t\tseed = time(0);\n\n#ifndef HAVE_RAND_R\n\tsrand(seed);\n#endif\n\n\t/* Generate random names until we find one that doesn't exist */\n\twhile(1) {\n\t\tifexists = 0;\n\t\tname = strdup(template);\n\n\t\tif (name == NULL)\n\t\t\treturn NULL;\n\n\t\tfor (i = 0; i < strlen(name); i++) {\n\t\t\tif (name[i] == 'X') {\n#ifdef HAVE_RAND_R\n\t\t\t\tname[i] = padchar[rand_r(&seed) % (strlen(padchar) - 1)];\n#else\n\t\t\t\tname[i] = padchar[rand() % (strlen(padchar) - 1)];\n#endif\n\t\t\t}\n\t\t}\n\n\t\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n\t\t\tif (strcmp(ifa->ifa_name, name) == 0) {\n\t\t\t\tifexists = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ifexists == 0)\n\t\t\tbreak;\n\n\t\tfree(name);\n\t}\n\n\tfreeifaddrs(ifaddr);\n\treturn name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "template",
            "sizeof(template)",
            "\"vethXXXXXX\""
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool get_new_nicname(char **dest, char *br, int pid, char **cnic)\n{\n\tchar template[IFNAMSIZ];\n\tsnprintf(template, sizeof(template), \"vethXXXXXX\");\n\t*dest = lxc_mkifname(template);\n\n\tif (!create_nic(*dest, br, pid, cnic)) {\n\t\treturn false;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "create_nic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
    "lines": "417-466",
    "snippet": "static bool create_nic(char *nic, char *br, int pid, char **cnic)\n{\n\tchar *veth1buf, *veth2buf;\n\tveth1buf = alloca(IFNAMSIZ);\n\tveth2buf = alloca(IFNAMSIZ);\n\tint ret, mtu;\n\n\tret = snprintf(veth1buf, IFNAMSIZ, \"%s\", nic);\n\tif (ret < 0 || ret >= IFNAMSIZ) {\n\t\tfprintf(stderr, \"host nic name too long\\n\");\n\t\treturn false;\n\t}\n\n\t/* create the nics */\n\tif (instantiate_veth(veth1buf, &veth2buf) < 0) {\n\t\tfprintf(stderr, \"Error creating veth tunnel\\n\");\n\t\treturn false;\n\t}\n\n\tif (strcmp(br, \"none\") != 0) {\n\t\t/* copy the bridge's mtu to both ends */\n\t\tmtu = get_mtu(br);\n\t\tif (mtu != -1) {\n\t\t\tif (lxc_netdev_set_mtu(veth1buf, mtu) < 0 ||\n\t\t\t\t\tlxc_netdev_set_mtu(veth2buf, mtu) < 0) {\n\t\t\t\tfprintf(stderr, \"Failed setting mtu\\n\");\n\t\t\t\tgoto out_del;\n\t\t\t}\n\t\t}\n\n\t\t/* attach veth1 to bridge */\n\t\tif (lxc_bridge_attach(lxcpath, lxcname, br, veth1buf) < 0) {\n\t\t\tfprintf(stderr, \"Error attaching %s to %s\\n\", veth1buf, br);\n\t\t\tgoto out_del;\n\t\t}\n\t}\n\n\t/* pass veth2 to target netns */\n\tret = lxc_netdev_move_by_name(veth2buf, pid, NULL);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"Error moving %s to netns %d\\n\", veth2buf, pid);\n\t\tgoto out_del;\n\t}\n\t*cnic = strdup(veth2buf);\n\treturn true;\n\nout_del:\n\tlxc_netdev_delete_by_name(veth1buf);\n\treturn false;\n}",
    "includes": [
      "#include \"network.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <linux/netlink.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <sched.h>",
      "#include <string.h>",
      "#include <alloca.h>",
      "#include <sys/file.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <stdbool.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *lxcpath, *lxcname;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_netdev_delete_by_name",
          "args": [
            "veth1buf"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_netdev_delete_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "295-304",
          "snippet": "int lxc_netdev_delete_by_name(const char *name)\n{\n\tint index;\n\n\tindex = if_nametoindex(name);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\treturn lxc_netdev_delete_by_index(index);\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_netdev_delete_by_name(const char *name)\n{\n\tint index;\n\n\tindex = if_nametoindex(name);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\treturn lxc_netdev_delete_by_index(index);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "veth2buf"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error moving %s to netns %d\\n\"",
            "veth2buf",
            "pid"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_netdev_move_by_name",
          "args": [
            "veth2buf",
            "pid",
            "NULL"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_netdev_move_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "240-256",
          "snippet": "int lxc_netdev_move_by_name(const char *ifname, pid_t pid, const char* newname)\n{\n\tint index;\n\tchar *physname;\n\n\tif (!ifname)\n\t\treturn -EINVAL;\n\n\tindex = if_nametoindex(ifname);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\tif ((physname = is_wlan(ifname)))\n\t\treturn lxc_netdev_move_wlan(physname, ifname, pid, newname);\n\n\treturn lxc_netdev_move_by_index(index, pid, newname);\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_netdev_move_by_name(const char *ifname, pid_t pid, const char* newname)\n{\n\tint index;\n\tchar *physname;\n\n\tif (!ifname)\n\t\treturn -EINVAL;\n\n\tindex = if_nametoindex(ifname);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\tif ((physname = is_wlan(ifname)))\n\t\treturn lxc_netdev_move_wlan(physname, ifname, pid, newname);\n\n\treturn lxc_netdev_move_by_index(index, pid, newname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error attaching %s to %s\\n\"",
            "veth1buf",
            "br"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_bridge_attach",
          "args": [
            "lxcpath",
            "lxcname",
            "br",
            "veth1buf"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_bridge_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "1458-1486",
          "snippet": "int lxc_bridge_attach(const char *lxcpath, const char *name, const char *bridge, const char *ifname)\n{\n\tint fd, index, err;\n\tstruct ifreq ifr;\n\n\tif (strlen(ifname) >= IFNAMSIZ)\n\t\treturn -EINVAL;\n\n\tindex = if_nametoindex(ifname);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\tif (is_ovs_bridge(bridge))\n\t\treturn attach_to_ovs_bridge(lxcpath, name, bridge, ifname);\n\n\tfd = socket(AF_INET, SOCK_STREAM, 0);\n\tif (fd < 0)\n\t\treturn -errno;\n\n\tstrncpy(ifr.ifr_name, bridge, IFNAMSIZ-1);\n\tifr.ifr_name[IFNAMSIZ-1] = '\\0';\n\tifr.ifr_ifindex = index;\n\terr = ioctl(fd, SIOCBRADDIF, &ifr);\n\tclose(fd);\n\tif (err)\n\t\terr = -errno;\n\n\treturn err;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_bridge_attach(const char *lxcpath, const char *name, const char *bridge, const char *ifname)\n{\n\tint fd, index, err;\n\tstruct ifreq ifr;\n\n\tif (strlen(ifname) >= IFNAMSIZ)\n\t\treturn -EINVAL;\n\n\tindex = if_nametoindex(ifname);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\tif (is_ovs_bridge(bridge))\n\t\treturn attach_to_ovs_bridge(lxcpath, name, bridge, ifname);\n\n\tfd = socket(AF_INET, SOCK_STREAM, 0);\n\tif (fd < 0)\n\t\treturn -errno;\n\n\tstrncpy(ifr.ifr_name, bridge, IFNAMSIZ-1);\n\tifr.ifr_name[IFNAMSIZ-1] = '\\0';\n\tifr.ifr_ifindex = index;\n\terr = ioctl(fd, SIOCBRADDIF, &ifr);\n\tclose(fd);\n\tif (err)\n\t\terr = -errno;\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed setting mtu\\n\""
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_netdev_set_mtu",
          "args": [
            "veth2buf",
            "mtu"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_netdev_set_mtu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "610-660",
          "snippet": "int lxc_netdev_set_mtu(const char *name, int mtu)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tint index, len, err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tlen = strlen(name);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tindex = if_nametoindex(name);\n\tif (!index)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_REQUEST|NLM_F_ACK;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tifi->ifi_family = AF_UNSPEC;\n\tifi->ifi_index = index;\n\n\tif (nla_put_u32(nlmsg, IFLA_MTU, mtu))\n\t\tgoto out;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(nlmsg);\n\tnlmsg_free(answer);\n\treturn err;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_netdev_set_mtu(const char *name, int mtu)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tint index, len, err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tlen = strlen(name);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tindex = if_nametoindex(name);\n\tif (!index)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_REQUEST|NLM_F_ACK;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tifi->ifi_family = AF_UNSPEC;\n\tifi->ifi_index = index;\n\n\tif (nla_put_u32(nlmsg, IFLA_MTU, mtu))\n\t\tgoto out;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(nlmsg);\n\tnlmsg_free(answer);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_mtu",
          "args": [
            "br"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "get_mtu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
          "lines": "411-415",
          "snippet": "static int get_mtu(char *name)\n{\n\tint idx = if_nametoindex(name);\n\treturn netdev_get_mtu(idx);\n}",
          "includes": [
            "#include \"network.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <linux/netlink.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <sched.h>",
            "#include <string.h>",
            "#include <alloca.h>",
            "#include <sys/file.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int get_mtu(char *name)\n{\n\tint idx = if_nametoindex(name);\n\treturn netdev_get_mtu(idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "br",
            "\"none\""
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error creating veth tunnel\\n\""
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instantiate_veth",
          "args": [
            "veth1buf",
            "&veth2buf"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "instantiate_veth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
          "lines": "382-409",
          "snippet": "static int instantiate_veth(char *n1, char **n2)\n{\n\tint err;\n\n\terr = snprintf(*n2, IFNAMSIZ, \"%sp\", n1);\n\tif (err < 0 || err >= IFNAMSIZ) {\n\t\tfprintf(stderr, \"nic name too long\\n\");\n\t\treturn -1;\n\t}\n\n\terr = lxc_veth_create(n1, *n2);\n\tif (err) {\n\t\tfprintf(stderr, \"failed to create %s-%s : %s\\n\", n1, *n2,\n\t\t      strerror(-err));\n\t\treturn -1;\n\t}\n\n\t/* changing the high byte of the mac address to 0xfe, the bridge interface\n\t * will always keep the host's mac address and not take the mac address\n\t * of a container */\n\terr = setup_private_host_hw_addr(n1);\n\tif (err) {\n\t\tfprintf(stderr, \"failed to change mac address of host interface '%s' : %s\\n\",\n\t\t\tn1, strerror(-err));\n\t}\n\n\treturn netdev_set_flag(n1, IFF_UP);\n}",
          "includes": [
            "#include \"network.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <linux/netlink.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <sched.h>",
            "#include <string.h>",
            "#include <alloca.h>",
            "#include <sys/file.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int instantiate_veth(char *n1, char **n2)\n{\n\tint err;\n\n\terr = snprintf(*n2, IFNAMSIZ, \"%sp\", n1);\n\tif (err < 0 || err >= IFNAMSIZ) {\n\t\tfprintf(stderr, \"nic name too long\\n\");\n\t\treturn -1;\n\t}\n\n\terr = lxc_veth_create(n1, *n2);\n\tif (err) {\n\t\tfprintf(stderr, \"failed to create %s-%s : %s\\n\", n1, *n2,\n\t\t      strerror(-err));\n\t\treturn -1;\n\t}\n\n\t/* changing the high byte of the mac address to 0xfe, the bridge interface\n\t * will always keep the host's mac address and not take the mac address\n\t * of a container */\n\terr = setup_private_host_hw_addr(n1);\n\tif (err) {\n\t\tfprintf(stderr, \"failed to change mac address of host interface '%s' : %s\\n\",\n\t\t\tn1, strerror(-err));\n\t}\n\n\treturn netdev_set_flag(n1, IFF_UP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"host nic name too long\\n\""
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "veth1buf",
            "IFNAMSIZ",
            "\"%s\"",
            "nic"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "IFNAMSIZ"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "IFNAMSIZ"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *lxcpath, *lxcname;\n\nstatic bool create_nic(char *nic, char *br, int pid, char **cnic)\n{\n\tchar *veth1buf, *veth2buf;\n\tveth1buf = alloca(IFNAMSIZ);\n\tveth2buf = alloca(IFNAMSIZ);\n\tint ret, mtu;\n\n\tret = snprintf(veth1buf, IFNAMSIZ, \"%s\", nic);\n\tif (ret < 0 || ret >= IFNAMSIZ) {\n\t\tfprintf(stderr, \"host nic name too long\\n\");\n\t\treturn false;\n\t}\n\n\t/* create the nics */\n\tif (instantiate_veth(veth1buf, &veth2buf) < 0) {\n\t\tfprintf(stderr, \"Error creating veth tunnel\\n\");\n\t\treturn false;\n\t}\n\n\tif (strcmp(br, \"none\") != 0) {\n\t\t/* copy the bridge's mtu to both ends */\n\t\tmtu = get_mtu(br);\n\t\tif (mtu != -1) {\n\t\t\tif (lxc_netdev_set_mtu(veth1buf, mtu) < 0 ||\n\t\t\t\t\tlxc_netdev_set_mtu(veth2buf, mtu) < 0) {\n\t\t\t\tfprintf(stderr, \"Failed setting mtu\\n\");\n\t\t\t\tgoto out_del;\n\t\t\t}\n\t\t}\n\n\t\t/* attach veth1 to bridge */\n\t\tif (lxc_bridge_attach(lxcpath, lxcname, br, veth1buf) < 0) {\n\t\t\tfprintf(stderr, \"Error attaching %s to %s\\n\", veth1buf, br);\n\t\t\tgoto out_del;\n\t\t}\n\t}\n\n\t/* pass veth2 to target netns */\n\tret = lxc_netdev_move_by_name(veth2buf, pid, NULL);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"Error moving %s to netns %d\\n\", veth2buf, pid);\n\t\tgoto out_del;\n\t}\n\t*cnic = strdup(veth2buf);\n\treturn true;\n\nout_del:\n\tlxc_netdev_delete_by_name(veth1buf);\n\treturn false;\n}"
  },
  {
    "function_name": "get_mtu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
    "lines": "411-415",
    "snippet": "static int get_mtu(char *name)\n{\n\tint idx = if_nametoindex(name);\n\treturn netdev_get_mtu(idx);\n}",
    "includes": [
      "#include \"network.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <linux/netlink.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <sched.h>",
      "#include <string.h>",
      "#include <alloca.h>",
      "#include <sys/file.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <stdbool.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "netdev_get_mtu",
          "args": [
            "idx"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "netdev_get_mtu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "499-608",
          "snippet": "int netdev_get_mtu(int ifindex)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tstruct nlmsghdr *msg;\n\tint err, res;\n\tint recv_len = 0, answer_len;\n\tint readmore = 0;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\t/* Save the answer buffer length, since it will be overwritten\n\t * on the first receive (and we might need to receive more than\n\t * once. */\n\tanswer_len = answer->nlmsghdr->nlmsg_len;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_REQUEST|NLM_F_DUMP;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_GETLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi)\n\t\tgoto out;\n\tifi->ifi_family = AF_UNSPEC;\n\n\t/* Send the request for addresses, which returns all addresses\n\t * on all interfaces. */\n\terr = netlink_send(&nlh, nlmsg);\n\tif (err < 0)\n\t\tgoto out;\n\n\tdo {\n\t\t/* Restore the answer buffer length, it might have been\n\t\t * overwritten by a previous receive. */\n\t\tanswer->nlmsghdr->nlmsg_len = answer_len;\n\n\t\t/* Get the (next) batch of reply messages */\n\t\terr = netlink_rcv(&nlh, answer);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t\trecv_len = err;\n\t\terr = 0;\n\n\t\t/* Satisfy the typing for the netlink macros */\n\t\tmsg = answer->nlmsghdr;\n\n\t\twhile (NLMSG_OK(msg, recv_len)) {\n\n\t\t\t/* Stop reading if we see an error message */\n\t\t\tif (msg->nlmsg_type == NLMSG_ERROR) {\n\t\t\t\tstruct nlmsgerr *errmsg = (struct nlmsgerr*)NLMSG_DATA(msg);\n\t\t\t\terr = errmsg->error;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* Stop reading if we see a NLMSG_DONE message */\n\t\t\tif (msg->nlmsg_type == NLMSG_DONE) {\n\t\t\t\treadmore = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tifi = NLMSG_DATA(msg);\n\t\t\tif (ifi->ifi_index == ifindex) {\n\t\t\t\tstruct rtattr *rta = IFLA_RTA(ifi);\n\t\t\t\tint attr_len = msg->nlmsg_len - NLMSG_LENGTH(sizeof(*ifi));\n\t\t\t\tres = 0;\n\t\t\t\twhile(RTA_OK(rta, attr_len)) {\n\t\t\t\t\t/* Found a local address for the requested interface,\n\t\t\t\t\t * return it. */\n\t\t\t\t\tif (rta->rta_type == IFLA_MTU) {\n\t\t\t\t\t\tmemcpy(&res, RTA_DATA(rta), sizeof(int));\n\t\t\t\t\t\terr = res;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\trta = RTA_NEXT(rta, attr_len);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/* Keep reading more data from the socket if the\n\t\t\t * last message had the NLF_F_MULTI flag set */\n\t\t\treadmore = (msg->nlmsg_flags & NLM_F_MULTI);\n\n\t\t\t/* Look at the next message received in this buffer */\n\t\t\tmsg = NLMSG_NEXT(msg, recv_len);\n\t\t}\n\t} while (readmore);\n\n\t/* If we end up here, we didn't find any result, so signal an\n\t * error */\n\terr = -1;\n\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint netdev_get_mtu(int ifindex)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tstruct nlmsghdr *msg;\n\tint err, res;\n\tint recv_len = 0, answer_len;\n\tint readmore = 0;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\t/* Save the answer buffer length, since it will be overwritten\n\t * on the first receive (and we might need to receive more than\n\t * once. */\n\tanswer_len = answer->nlmsghdr->nlmsg_len;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_REQUEST|NLM_F_DUMP;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_GETLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi)\n\t\tgoto out;\n\tifi->ifi_family = AF_UNSPEC;\n\n\t/* Send the request for addresses, which returns all addresses\n\t * on all interfaces. */\n\terr = netlink_send(&nlh, nlmsg);\n\tif (err < 0)\n\t\tgoto out;\n\n\tdo {\n\t\t/* Restore the answer buffer length, it might have been\n\t\t * overwritten by a previous receive. */\n\t\tanswer->nlmsghdr->nlmsg_len = answer_len;\n\n\t\t/* Get the (next) batch of reply messages */\n\t\terr = netlink_rcv(&nlh, answer);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t\trecv_len = err;\n\t\terr = 0;\n\n\t\t/* Satisfy the typing for the netlink macros */\n\t\tmsg = answer->nlmsghdr;\n\n\t\twhile (NLMSG_OK(msg, recv_len)) {\n\n\t\t\t/* Stop reading if we see an error message */\n\t\t\tif (msg->nlmsg_type == NLMSG_ERROR) {\n\t\t\t\tstruct nlmsgerr *errmsg = (struct nlmsgerr*)NLMSG_DATA(msg);\n\t\t\t\terr = errmsg->error;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* Stop reading if we see a NLMSG_DONE message */\n\t\t\tif (msg->nlmsg_type == NLMSG_DONE) {\n\t\t\t\treadmore = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tifi = NLMSG_DATA(msg);\n\t\t\tif (ifi->ifi_index == ifindex) {\n\t\t\t\tstruct rtattr *rta = IFLA_RTA(ifi);\n\t\t\t\tint attr_len = msg->nlmsg_len - NLMSG_LENGTH(sizeof(*ifi));\n\t\t\t\tres = 0;\n\t\t\t\twhile(RTA_OK(rta, attr_len)) {\n\t\t\t\t\t/* Found a local address for the requested interface,\n\t\t\t\t\t * return it. */\n\t\t\t\t\tif (rta->rta_type == IFLA_MTU) {\n\t\t\t\t\t\tmemcpy(&res, RTA_DATA(rta), sizeof(int));\n\t\t\t\t\t\terr = res;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\trta = RTA_NEXT(rta, attr_len);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/* Keep reading more data from the socket if the\n\t\t\t * last message had the NLF_F_MULTI flag set */\n\t\t\treadmore = (msg->nlmsg_flags & NLM_F_MULTI);\n\n\t\t\t/* Look at the next message received in this buffer */\n\t\t\tmsg = NLMSG_NEXT(msg, recv_len);\n\t\t}\n\t} while (readmore);\n\n\t/* If we end up here, we didn't find any result, so signal an\n\t * error */\n\terr = -1;\n\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "if_nametoindex",
          "args": [
            "name"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int get_mtu(char *name)\n{\n\tint idx = if_nametoindex(name);\n\treturn netdev_get_mtu(idx);\n}"
  },
  {
    "function_name": "instantiate_veth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
    "lines": "382-409",
    "snippet": "static int instantiate_veth(char *n1, char **n2)\n{\n\tint err;\n\n\terr = snprintf(*n2, IFNAMSIZ, \"%sp\", n1);\n\tif (err < 0 || err >= IFNAMSIZ) {\n\t\tfprintf(stderr, \"nic name too long\\n\");\n\t\treturn -1;\n\t}\n\n\terr = lxc_veth_create(n1, *n2);\n\tif (err) {\n\t\tfprintf(stderr, \"failed to create %s-%s : %s\\n\", n1, *n2,\n\t\t      strerror(-err));\n\t\treturn -1;\n\t}\n\n\t/* changing the high byte of the mac address to 0xfe, the bridge interface\n\t * will always keep the host's mac address and not take the mac address\n\t * of a container */\n\terr = setup_private_host_hw_addr(n1);\n\tif (err) {\n\t\tfprintf(stderr, \"failed to change mac address of host interface '%s' : %s\\n\",\n\t\t\tn1, strerror(-err));\n\t}\n\n\treturn netdev_set_flag(n1, IFF_UP);\n}",
    "includes": [
      "#include \"network.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <linux/netlink.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <sched.h>",
      "#include <string.h>",
      "#include <alloca.h>",
      "#include <sys/file.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <stdbool.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "netdev_set_flag",
          "args": [
            "n1",
            "IFF_UP"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "netdev_set_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "365-414",
          "snippet": "int netdev_set_flag(const char *name, int flag)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tint index, len, err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tlen = strlen(name);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tindex = if_nametoindex(name);\n\tif (!index)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_REQUEST|NLM_F_ACK;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tifi->ifi_family = AF_UNSPEC;\n\tifi->ifi_index = index;\n\tifi->ifi_change |= IFF_UP;\n\tifi->ifi_flags |= flag;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(nlmsg);\n\tnlmsg_free(answer);\n\treturn err;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint netdev_set_flag(const char *name, int flag)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tint index, len, err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tlen = strlen(name);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tindex = if_nametoindex(name);\n\tif (!index)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_REQUEST|NLM_F_ACK;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tifi->ifi_family = AF_UNSPEC;\n\tifi->ifi_index = index;\n\tifi->ifi_change |= IFF_UP;\n\tifi->ifi_flags |= flag;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(nlmsg);\n\tnlmsg_free(answer);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"failed to change mac address of host interface '%s' : %s\\n\"",
            "n1",
            "strerror(-err)"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "-err"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_private_host_hw_addr",
          "args": [
            "n1"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "setup_private_host_hw_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "1568-1592",
          "snippet": "int setup_private_host_hw_addr(char *veth1)\n{\n\tstruct ifreq ifr;\n\tint err;\n\tint sockfd;\n\n\tsockfd = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (sockfd < 0)\n\t\treturn -errno;\n\n\tsnprintf((char *)ifr.ifr_name, IFNAMSIZ, \"%s\", veth1);\n\terr = ioctl(sockfd, SIOCGIFHWADDR, &ifr);\n\tif (err < 0) {\n\t\tclose(sockfd);\n\t\treturn -errno;\n\t}\n\n\tifr.ifr_hwaddr.sa_data[0] = 0xfe;\n\terr = ioctl(sockfd, SIOCSIFHWADDR, &ifr);\n\tclose(sockfd);\n\tif (err < 0)\n\t\treturn -errno;\n\n\treturn 0;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint setup_private_host_hw_addr(char *veth1)\n{\n\tstruct ifreq ifr;\n\tint err;\n\tint sockfd;\n\n\tsockfd = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (sockfd < 0)\n\t\treturn -errno;\n\n\tsnprintf((char *)ifr.ifr_name, IFNAMSIZ, \"%s\", veth1);\n\terr = ioctl(sockfd, SIOCGIFHWADDR, &ifr);\n\tif (err < 0) {\n\t\tclose(sockfd);\n\t\treturn -errno;\n\t}\n\n\tifr.ifr_hwaddr.sa_data[0] = 0xfe;\n\terr = ioctl(sockfd, SIOCSIFHWADDR, &ifr);\n\tclose(sockfd);\n\tif (err < 0)\n\t\treturn -errno;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"failed to create %s-%s : %s\\n\"",
            "n1",
            "*n2",
            "strerror(-err)"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "-err"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_veth_create",
          "args": [
            "n1",
            "*n2"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_veth_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "672-751",
          "snippet": "int lxc_veth_create(const char *name1, const char *name2)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tstruct rtattr *nest1, *nest2, *nest3;\n\tint len, err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tlen = strlen(name1);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\tlen = strlen(name2);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags =\n\t\tNLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL|NLM_F_ACK;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi)\n\t\tgoto out;\n\tifi->ifi_family = AF_UNSPEC;\n\n\terr = -EINVAL;\n\tnest1 = nla_begin_nested(nlmsg, IFLA_LINKINFO);\n\tif (!nest1)\n\t\tgoto out;\n\n\tif (nla_put_string(nlmsg, IFLA_INFO_KIND, \"veth\"))\n\t\tgoto out;\n\n\tnest2 = nla_begin_nested(nlmsg, IFLA_INFO_DATA);\n\tif (!nest2)\n\t\tgoto out;\n\n\tnest3 = nla_begin_nested(nlmsg, VETH_INFO_PEER);\n\tif (!nest3)\n\t\tgoto out;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (nla_put_string(nlmsg, IFLA_IFNAME, name2))\n\t\tgoto out;\n\n\tnla_end_nested(nlmsg, nest3);\n\n\tnla_end_nested(nlmsg, nest2);\n\n\tnla_end_nested(nlmsg, nest1);\n\n\tif (nla_put_string(nlmsg, IFLA_IFNAME, name1))\n\t\tgoto out;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_veth_create(const char *name1, const char *name2)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tstruct rtattr *nest1, *nest2, *nest3;\n\tint len, err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tlen = strlen(name1);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\tlen = strlen(name2);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags =\n\t\tNLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL|NLM_F_ACK;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi)\n\t\tgoto out;\n\tifi->ifi_family = AF_UNSPEC;\n\n\terr = -EINVAL;\n\tnest1 = nla_begin_nested(nlmsg, IFLA_LINKINFO);\n\tif (!nest1)\n\t\tgoto out;\n\n\tif (nla_put_string(nlmsg, IFLA_INFO_KIND, \"veth\"))\n\t\tgoto out;\n\n\tnest2 = nla_begin_nested(nlmsg, IFLA_INFO_DATA);\n\tif (!nest2)\n\t\tgoto out;\n\n\tnest3 = nla_begin_nested(nlmsg, VETH_INFO_PEER);\n\tif (!nest3)\n\t\tgoto out;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (nla_put_string(nlmsg, IFLA_IFNAME, name2))\n\t\tgoto out;\n\n\tnla_end_nested(nlmsg, nest3);\n\n\tnla_end_nested(nlmsg, nest2);\n\n\tnla_end_nested(nlmsg, nest1);\n\n\tif (nla_put_string(nlmsg, IFLA_IFNAME, name1))\n\t\tgoto out;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"nic name too long\\n\""
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "*n2",
            "IFNAMSIZ",
            "\"%sp\"",
            "n1"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int instantiate_veth(char *n1, char **n2)\n{\n\tint err;\n\n\terr = snprintf(*n2, IFNAMSIZ, \"%sp\", n1);\n\tif (err < 0 || err >= IFNAMSIZ) {\n\t\tfprintf(stderr, \"nic name too long\\n\");\n\t\treturn -1;\n\t}\n\n\terr = lxc_veth_create(n1, *n2);\n\tif (err) {\n\t\tfprintf(stderr, \"failed to create %s-%s : %s\\n\", n1, *n2,\n\t\t      strerror(-err));\n\t\treturn -1;\n\t}\n\n\t/* changing the high byte of the mac address to 0xfe, the bridge interface\n\t * will always keep the host's mac address and not take the mac address\n\t * of a container */\n\terr = setup_private_host_hw_addr(n1);\n\tif (err) {\n\t\tfprintf(stderr, \"failed to change mac address of host interface '%s' : %s\\n\",\n\t\t\tn1, strerror(-err));\n\t}\n\n\treturn netdev_set_flag(n1, IFF_UP);\n}"
  },
  {
    "function_name": "nic_exists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
    "lines": "365-380",
    "snippet": "static bool nic_exists(char *nic)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\tstruct stat sb;\n\n\tif (strcmp(nic, \"none\") == 0)\n\t\treturn true;\n\tret = snprintf(path, MAXPATHLEN, \"/sys/class/net/%s\", nic);\n\tif (ret < 0 || ret >= MAXPATHLEN) // should never happen!\n\t\treturn false;\n\tret = stat(path, &sb);\n\tif (ret != 0)\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include \"network.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <linux/netlink.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <sched.h>",
      "#include <string.h>",
      "#include <alloca.h>",
      "#include <sys/file.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <stdbool.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "path",
            "&sb"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "freezer_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/freezer.c",
          "lines": "42-51",
          "snippet": "lxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}",
          "includes": [
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"monitor.h\"",
            "#include \"state.h\"",
            "#include \"error.h\"",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxc.h\"\n#include \"log.h\"\n#include \"monitor.h\"\n#include \"state.h\"\n#include \"error.h\"\n#include <sys/param.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nlxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "MAXPATHLEN",
            "\"/sys/class/net/%s\"",
            "nic"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "nic",
            "\"none\""
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool nic_exists(char *nic)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\tstruct stat sb;\n\n\tif (strcmp(nic, \"none\") == 0)\n\t\treturn true;\n\tret = snprintf(path, MAXPATHLEN, \"/sys/class/net/%s\", nic);\n\tif (ret < 0 || ret >= MAXPATHLEN) // should never happen!\n\t\treturn false;\n\tret = stat(path, &sb);\n\tif (ret != 0)\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "find_line",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
    "lines": "335-363",
    "snippet": "static char *find_line(char *p, char *e, char *u, char *t, char *l)\n{\n\tchar *p1, *p2, *ret;\n\n\twhile (p<e  && (p1 = get_eol(p, e)) < e) {\n\t\tret = p;\n\t\tif (*p == '#')\n\t\t\tgoto next;\n\t\twhile (p<e && isblank(*p)) p++;\n\t\tp2 = get_eow(p, e);\n\t\tif (!p2 || p2-p != strlen(u) || strncmp(p, u, strlen(u)) != 0)\n\t\t\tgoto next;\n\t\tp = p2+1;\n\t\twhile (p<e && isblank(*p)) p++;\n\t\tp2 = get_eow(p, e);\n\t\tif (!p2 || p2-p != strlen(t) || strncmp(p, t, strlen(t)) != 0)\n\t\t\tgoto next;\n\t\tp = p2+1;\n\t\twhile (p<e && isblank(*p)) p++;\n\t\tp2 = get_eow(p, e);\n\t\tif (!p2 || p2-p != strlen(l) || strncmp(p, l, strlen(l)) != 0)\n\t\t\tgoto next;\n\t\treturn ret;\nnext:\n\t\tp = p1 + 1;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"network.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <linux/netlink.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <sched.h>",
      "#include <string.h>",
      "#include <alloca.h>",
      "#include <sys/file.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <stdbool.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "p",
            "l",
            "strlen(l)"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "l"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "l"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_eow",
          "args": [
            "p",
            "e"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "get_eow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
          "lines": "328-333",
          "snippet": "static char *get_eow(char *s, char *e)\n{\n\twhile (s<e && *s && !isblank(*s) && *s != '\\n')\n\t\ts++;\n\treturn s;\n}",
          "includes": [
            "#include \"network.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <linux/netlink.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <sched.h>",
            "#include <string.h>",
            "#include <alloca.h>",
            "#include <sys/file.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *get_eow(char *s, char *e)\n{\n\twhile (s<e && *s && !isblank(*s) && *s != '\\n')\n\t\ts++;\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isblank",
          "args": [
            "*p"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "p",
            "t",
            "strlen(t)"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "t"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "t"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isblank",
          "args": [
            "*p"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "p",
            "u",
            "strlen(u)"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "u"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "u"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isblank",
          "args": [
            "*p"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_eol",
          "args": [
            "p",
            "e"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "get_eol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
          "lines": "321-326",
          "snippet": "static char *get_eol(char *s, char *e)\n{\n\twhile (s<e && *s && *s != '\\n')\n\t\ts++;\n\treturn s;\n}",
          "includes": [
            "#include \"network.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <linux/netlink.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <sched.h>",
            "#include <string.h>",
            "#include <alloca.h>",
            "#include <sys/file.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *get_eol(char *s, char *e)\n{\n\twhile (s<e && *s && *s != '\\n')\n\t\ts++;\n\treturn s;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *find_line(char *p, char *e, char *u, char *t, char *l)\n{\n\tchar *p1, *p2, *ret;\n\n\twhile (p<e  && (p1 = get_eol(p, e)) < e) {\n\t\tret = p;\n\t\tif (*p == '#')\n\t\t\tgoto next;\n\t\twhile (p<e && isblank(*p)) p++;\n\t\tp2 = get_eow(p, e);\n\t\tif (!p2 || p2-p != strlen(u) || strncmp(p, u, strlen(u)) != 0)\n\t\t\tgoto next;\n\t\tp = p2+1;\n\t\twhile (p<e && isblank(*p)) p++;\n\t\tp2 = get_eow(p, e);\n\t\tif (!p2 || p2-p != strlen(t) || strncmp(p, t, strlen(t)) != 0)\n\t\t\tgoto next;\n\t\tp = p2+1;\n\t\twhile (p<e && isblank(*p)) p++;\n\t\tp2 = get_eow(p, e);\n\t\tif (!p2 || p2-p != strlen(l) || strncmp(p, l, strlen(l)) != 0)\n\t\t\tgoto next;\n\t\treturn ret;\nnext:\n\t\tp = p1 + 1;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "get_eow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
    "lines": "328-333",
    "snippet": "static char *get_eow(char *s, char *e)\n{\n\twhile (s<e && *s && !isblank(*s) && *s != '\\n')\n\t\ts++;\n\treturn s;\n}",
    "includes": [
      "#include \"network.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <linux/netlink.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <sched.h>",
      "#include <string.h>",
      "#include <alloca.h>",
      "#include <sys/file.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <stdbool.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isblank",
          "args": [
            "*s"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *get_eow(char *s, char *e)\n{\n\twhile (s<e && *s && !isblank(*s) && *s != '\\n')\n\t\ts++;\n\treturn s;\n}"
  },
  {
    "function_name": "get_eol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
    "lines": "321-326",
    "snippet": "static char *get_eol(char *s, char *e)\n{\n\twhile (s<e && *s && *s != '\\n')\n\t\ts++;\n\treturn s;\n}",
    "includes": [
      "#include \"network.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <linux/netlink.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <sched.h>",
      "#include <string.h>",
      "#include <alloca.h>",
      "#include <sys/file.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <stdbool.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *get_eol(char *s, char *e)\n{\n\twhile (s<e && *s && *s != '\\n')\n\t\ts++;\n\treturn s;\n}"
  },
  {
    "function_name": "get_alloted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
    "lines": "262-319",
    "snippet": "static int get_alloted(char *me, char *intype, char *link, struct alloted_s **alloted)\n{\n\tFILE *fin = fopen(LXC_USERNIC_CONF, \"r\");\n\tchar *line = NULL;\n\tchar name[100], type[100], br[100];\n\tsize_t len = 0;\n\tint n, ret, count = 0;\n\tchar **groups;\n\n\tif (!fin) {\n\t\tfprintf(stderr, \"Failed to open %s: %s\\n\", LXC_USERNIC_CONF,\n\t\t\tstrerror(errno));\n\t\treturn -1;\n\t}\n\n\tgroups = get_groupnames();\n\twhile ((getline(&line, &len, fin)) != -1) {\n\t\tret = sscanf(line, \"%99[^ \\t] %99[^ \\t] %99[^ \\t] %d\", name, type, br, &n);\n\n\t\tif (ret != 4)\n\t\t\tcontinue;\n\n\t\tif (strlen(name) == 0)\n\t\t\tcontinue;\n\n\t\tif (strcmp(name, me) != 0)\n\t\t{\n\t\t\tif (name[0] != '@')\n\t\t\t\tcontinue;\n\t\t\tif (!name_is_in_groupnames(name+1, groups))\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (strcmp(type, intype) != 0)\n\t\t\tcontinue;\n\t\tif (strcmp(link, br) != 0)\n\t\t\tcontinue;\n\n\t\t/* found the user or group with the appropriate settings, therefore finish the search.\n\t\t * what to do if there are more than one applicable lines? not specified in the docs.\n\t\t * since getline is implemented with realloc, we don't need to free line until exiting func.\n\t\t *\n\t\t * if append_alloted returns NULL, e.g. due to a malloc error, we set count to 0 and break the loop,\n\t\t * allowing cleanup and then exiting from main()\n\t\t */\n\t\tif (append_alloted(alloted, name, n) == NULL) {\n\t\t\tcount = 0;\n\t\t\tbreak;\n\t\t}\n\t\tcount += n;\n\t}\n\n\tfree_groupnames(groups);\n\tfclose(fin);\n\tfree(line);\n\n\t// now return the total number of nics that this user can create\n\treturn count;\n}",
    "includes": [
      "#include \"network.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <linux/netlink.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <sched.h>",
      "#include <string.h>",
      "#include <alloca.h>",
      "#include <sys/file.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <stdbool.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "line"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "free_alloted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
          "lines": "235-251",
          "snippet": "static void free_alloted(struct alloted_s **head)\n{\n\tstruct alloted_s *cur;\n\n\tif (head == NULL) {\n\t\treturn;\n\t}\n\n\tcur = *head;\n\n\twhile (cur != NULL) {\n\t\tcur = cur->next;\n\t\tfree((*head)->name);\n\t\tfree(*head);\n\t\t*head = cur;\n\t}\n}",
          "includes": [
            "#include \"network.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <linux/netlink.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <sched.h>",
            "#include <string.h>",
            "#include <alloca.h>",
            "#include <sys/file.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic void free_alloted(struct alloted_s **head)\n{\n\tstruct alloted_s *cur;\n\n\tif (head == NULL) {\n\t\treturn;\n\t}\n\n\tcur = *head;\n\n\twhile (cur != NULL) {\n\t\tcur = cur->next;\n\t\tfree((*head)->name);\n\t\tfree(*head);\n\t\t*head = cur;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fin"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_groupnames",
          "args": [
            "groups"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "free_groupnames",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
          "lines": "101-109",
          "snippet": "static void free_groupnames(char **groupnames)\n{\n\tint i;\n\tif (!groupnames)\n\t\treturn;\n\tfor (i = 0; groupnames[i]; i++)\n\t\tfree(groupnames[i]);\n\tfree(groupnames);\n}",
          "includes": [
            "#include \"network.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <linux/netlink.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <sched.h>",
            "#include <string.h>",
            "#include <alloca.h>",
            "#include <sys/file.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic void free_groupnames(char **groupnames)\n{\n\tint i;\n\tif (!groupnames)\n\t\treturn;\n\tfor (i = 0; groupnames[i]; i++)\n\t\tfree(groupnames[i]);\n\tfree(groupnames);\n}"
        }
      },
      {
        "call_info": {
          "callee": "append_alloted",
          "args": [
            "alloted",
            "name",
            "n"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "append_alloted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
          "lines": "194-233",
          "snippet": "static struct alloted_s *append_alloted(struct alloted_s **head, char *name, int n)\n{\n\tstruct alloted_s *cur, *al;\n\n\tif (head == NULL || name == NULL) {\n\t\t// sanity check. parameters should not be null\n\t\tfprintf(stderr, \"NULL parameters to append_alloted not allowed\\n\");\n\t\treturn NULL;\n\t}\n\n\tal = (struct alloted_s *)malloc(sizeof(struct alloted_s));\n\n\tif (al == NULL) {\n\t\t// unable to allocate memory to new struct\n\t\tfprintf(stderr, \"Out of memory in append_alloted\\n\");\n\t\treturn NULL;\n\t}\n\n\tal->name = strdup(name);\n\n\tif (al->name == NULL) {\n\t\tfree(al);\n\t\treturn NULL;\n\t}\n\n\tal->allowed = n;\n\tal->next = NULL;\n\n\tif (*head == NULL) {\n\t\t*head = al;\n\t\treturn al;\n\t}\n\n\tcur = *head;\n\twhile (cur->next != NULL)\n\t\tcur = cur->next;\n\n\tcur->next = al;\n\treturn al;\n}",
          "includes": [
            "#include \"network.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <linux/netlink.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <sched.h>",
            "#include <string.h>",
            "#include <alloca.h>",
            "#include <sys/file.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic struct alloted_s *append_alloted(struct alloted_s **head, char *name, int n)\n{\n\tstruct alloted_s *cur, *al;\n\n\tif (head == NULL || name == NULL) {\n\t\t// sanity check. parameters should not be null\n\t\tfprintf(stderr, \"NULL parameters to append_alloted not allowed\\n\");\n\t\treturn NULL;\n\t}\n\n\tal = (struct alloted_s *)malloc(sizeof(struct alloted_s));\n\n\tif (al == NULL) {\n\t\t// unable to allocate memory to new struct\n\t\tfprintf(stderr, \"Out of memory in append_alloted\\n\");\n\t\treturn NULL;\n\t}\n\n\tal->name = strdup(name);\n\n\tif (al->name == NULL) {\n\t\tfree(al);\n\t\treturn NULL;\n\t}\n\n\tal->allowed = n;\n\tal->next = NULL;\n\n\tif (*head == NULL) {\n\t\t*head = al;\n\t\treturn al;\n\t}\n\n\tcur = *head;\n\twhile (cur->next != NULL)\n\t\tcur = cur->next;\n\n\tcur->next = al;\n\treturn al;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "link",
            "br"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "intype"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name_is_in_groupnames",
          "args": [
            "name+1",
            "groups"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "name_is_in_groupnames",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
          "lines": "178-186",
          "snippet": "static bool name_is_in_groupnames(char *name, char **groupnames)\n{\n\twhile (groupnames != NULL) {\n\t\tif (strcmp(name, *groupnames) == 0)\n\t\t\treturn true;\n\t\tgroupnames++;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"network.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <linux/netlink.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <sched.h>",
            "#include <string.h>",
            "#include <alloca.h>",
            "#include <sys/file.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool name_is_in_groupnames(char *name, char **groupnames)\n{\n\twhile (groupnames != NULL) {\n\t\tif (strcmp(name, *groupnames) == 0)\n\t\t\treturn true;\n\t\tgroupnames++;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "me"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "line",
            "\"%99[^ \\t] %99[^ \\t] %99[^ \\t] %d\"",
            "name",
            "type",
            "br",
            "&n"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&line",
            "&len",
            "fin"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getline.c",
          "lines": "39-60",
          "snippet": "ssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_groupnames",
          "args": [],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "get_groupnames",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
          "lines": "111-176",
          "snippet": "static char **get_groupnames(void)\n{\n\tint ngroups;\n\tgid_t *group_ids;\n\tint ret, i;\n\tchar **groupnames;\n\tstruct group *gr;\n\n\tngroups = getgroups(0, NULL);\n\n\tif (ngroups == -1) {\n\t\tfprintf(stderr, \"Failed to get number of groups user belongs to: %s\\n\", strerror(errno));\n\t\treturn NULL;\n\t}\n\tif (ngroups == 0)\n\t\treturn NULL;\n\n\tgroup_ids = (gid_t *)malloc(sizeof(gid_t)*ngroups);\n\n\tif (group_ids == NULL) {\n\t\tfprintf(stderr, \"Out of memory while getting groups the user belongs to\\n\");\n\t\treturn NULL;\n\t}\n\n\tret = getgroups(ngroups, group_ids);\n\n\tif (ret < 0) {\n\t\tfree(group_ids);\n\t\tfprintf(stderr, \"Failed to get process groups: %s\\n\", strerror(errno));\n\t\treturn NULL;\n\t}\n\n\tgroupnames = (char **)malloc(sizeof(char *)*(ngroups+1));\n\n\tif (groupnames == NULL) {\n\t\tfree(group_ids);\n\t\tfprintf(stderr, \"Out of memory while getting group names\\n\");\n\t\treturn NULL;\n\t}\n\n\tmemset(groupnames, 0, sizeof(char *)*(ngroups+1));\n\n\tfor (i=0; i<ngroups; i++ ) {\n\t\tgr = getgrgid(group_ids[i]);\n\n\t\tif (gr == NULL) {\n\t\t\tfprintf(stderr, \"Failed to get group name\\n\");\n\t\t\tfree(group_ids);\n\t\t\tfree_groupnames(groupnames);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tgroupnames[i] = strdup(gr->gr_name);\n\n\t\tif (groupnames[i] == NULL) {\n\t\t\tfprintf(stderr, \"Failed to copy group name: %s\", gr->gr_name);\n\t\t\tfree(group_ids);\n\t\t\tfree_groupnames(groupnames);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tfree(group_ids);\n\n\treturn groupnames;\n}",
          "includes": [
            "#include \"network.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <linux/netlink.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <sched.h>",
            "#include <string.h>",
            "#include <alloca.h>",
            "#include <sys/file.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char **get_groupnames(void)\n{\n\tint ngroups;\n\tgid_t *group_ids;\n\tint ret, i;\n\tchar **groupnames;\n\tstruct group *gr;\n\n\tngroups = getgroups(0, NULL);\n\n\tif (ngroups == -1) {\n\t\tfprintf(stderr, \"Failed to get number of groups user belongs to: %s\\n\", strerror(errno));\n\t\treturn NULL;\n\t}\n\tif (ngroups == 0)\n\t\treturn NULL;\n\n\tgroup_ids = (gid_t *)malloc(sizeof(gid_t)*ngroups);\n\n\tif (group_ids == NULL) {\n\t\tfprintf(stderr, \"Out of memory while getting groups the user belongs to\\n\");\n\t\treturn NULL;\n\t}\n\n\tret = getgroups(ngroups, group_ids);\n\n\tif (ret < 0) {\n\t\tfree(group_ids);\n\t\tfprintf(stderr, \"Failed to get process groups: %s\\n\", strerror(errno));\n\t\treturn NULL;\n\t}\n\n\tgroupnames = (char **)malloc(sizeof(char *)*(ngroups+1));\n\n\tif (groupnames == NULL) {\n\t\tfree(group_ids);\n\t\tfprintf(stderr, \"Out of memory while getting group names\\n\");\n\t\treturn NULL;\n\t}\n\n\tmemset(groupnames, 0, sizeof(char *)*(ngroups+1));\n\n\tfor (i=0; i<ngroups; i++ ) {\n\t\tgr = getgrgid(group_ids[i]);\n\n\t\tif (gr == NULL) {\n\t\t\tfprintf(stderr, \"Failed to get group name\\n\");\n\t\t\tfree(group_ids);\n\t\t\tfree_groupnames(groupnames);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tgroupnames[i] = strdup(gr->gr_name);\n\n\t\tif (groupnames[i] == NULL) {\n\t\t\tfprintf(stderr, \"Failed to copy group name: %s\", gr->gr_name);\n\t\t\tfree(group_ids);\n\t\t\tfree_groupnames(groupnames);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tfree(group_ids);\n\n\treturn groupnames;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to open %s: %s\\n\"",
            "LXC_USERNIC_CONF",
            "strerror(errno)"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "LXC_USERNIC_CONF",
            "\"r\""
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int get_alloted(char *me, char *intype, char *link, struct alloted_s **alloted)\n{\n\tFILE *fin = fopen(LXC_USERNIC_CONF, \"r\");\n\tchar *line = NULL;\n\tchar name[100], type[100], br[100];\n\tsize_t len = 0;\n\tint n, ret, count = 0;\n\tchar **groups;\n\n\tif (!fin) {\n\t\tfprintf(stderr, \"Failed to open %s: %s\\n\", LXC_USERNIC_CONF,\n\t\t\tstrerror(errno));\n\t\treturn -1;\n\t}\n\n\tgroups = get_groupnames();\n\twhile ((getline(&line, &len, fin)) != -1) {\n\t\tret = sscanf(line, \"%99[^ \\t] %99[^ \\t] %99[^ \\t] %d\", name, type, br, &n);\n\n\t\tif (ret != 4)\n\t\t\tcontinue;\n\n\t\tif (strlen(name) == 0)\n\t\t\tcontinue;\n\n\t\tif (strcmp(name, me) != 0)\n\t\t{\n\t\t\tif (name[0] != '@')\n\t\t\t\tcontinue;\n\t\t\tif (!name_is_in_groupnames(name+1, groups))\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (strcmp(type, intype) != 0)\n\t\t\tcontinue;\n\t\tif (strcmp(link, br) != 0)\n\t\t\tcontinue;\n\n\t\t/* found the user or group with the appropriate settings, therefore finish the search.\n\t\t * what to do if there are more than one applicable lines? not specified in the docs.\n\t\t * since getline is implemented with realloc, we don't need to free line until exiting func.\n\t\t *\n\t\t * if append_alloted returns NULL, e.g. due to a malloc error, we set count to 0 and break the loop,\n\t\t * allowing cleanup and then exiting from main()\n\t\t */\n\t\tif (append_alloted(alloted, name, n) == NULL) {\n\t\t\tcount = 0;\n\t\t\tbreak;\n\t\t}\n\t\tcount += n;\n\t}\n\n\tfree_groupnames(groups);\n\tfclose(fin);\n\tfree(line);\n\n\t// now return the total number of nics that this user can create\n\treturn count;\n}"
  },
  {
    "function_name": "free_alloted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
    "lines": "235-251",
    "snippet": "static void free_alloted(struct alloted_s **head)\n{\n\tstruct alloted_s *cur;\n\n\tif (head == NULL) {\n\t\treturn;\n\t}\n\n\tcur = *head;\n\n\twhile (cur != NULL) {\n\t\tcur = cur->next;\n\t\tfree((*head)->name);\n\t\tfree(*head);\n\t\t*head = cur;\n\t}\n}",
    "includes": [
      "#include \"network.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <linux/netlink.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <sched.h>",
      "#include <string.h>",
      "#include <alloca.h>",
      "#include <sys/file.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <stdbool.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "*head"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "free_alloted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
          "lines": "235-251",
          "snippet": "static void free_alloted(struct alloted_s **head)\n{\n\tstruct alloted_s *cur;\n\n\tif (head == NULL) {\n\t\treturn;\n\t}\n\n\tcur = *head;\n\n\twhile (cur != NULL) {\n\t\tcur = cur->next;\n\t\tfree((*head)->name);\n\t\tfree(*head);\n\t\t*head = cur;\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic void free_alloted(struct alloted_s **head)\n{\n\tstruct alloted_s *cur;\n\n\tif (head == NULL) {\n\t\treturn;\n\t}\n\n\tcur = *head;\n\n\twhile (cur != NULL) {\n\t\tcur = cur->next;\n\t\tfree((*head)->name);\n\t\tfree(*head);\n\t\t*head = cur;\n\t}\n}"
  },
  {
    "function_name": "append_alloted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
    "lines": "194-233",
    "snippet": "static struct alloted_s *append_alloted(struct alloted_s **head, char *name, int n)\n{\n\tstruct alloted_s *cur, *al;\n\n\tif (head == NULL || name == NULL) {\n\t\t// sanity check. parameters should not be null\n\t\tfprintf(stderr, \"NULL parameters to append_alloted not allowed\\n\");\n\t\treturn NULL;\n\t}\n\n\tal = (struct alloted_s *)malloc(sizeof(struct alloted_s));\n\n\tif (al == NULL) {\n\t\t// unable to allocate memory to new struct\n\t\tfprintf(stderr, \"Out of memory in append_alloted\\n\");\n\t\treturn NULL;\n\t}\n\n\tal->name = strdup(name);\n\n\tif (al->name == NULL) {\n\t\tfree(al);\n\t\treturn NULL;\n\t}\n\n\tal->allowed = n;\n\tal->next = NULL;\n\n\tif (*head == NULL) {\n\t\t*head = al;\n\t\treturn al;\n\t}\n\n\tcur = *head;\n\twhile (cur->next != NULL)\n\t\tcur = cur->next;\n\n\tcur->next = al;\n\treturn al;\n}",
    "includes": [
      "#include \"network.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <linux/netlink.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <sched.h>",
      "#include <string.h>",
      "#include <alloca.h>",
      "#include <sys/file.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <stdbool.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "al"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "free_alloted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
          "lines": "235-251",
          "snippet": "static void free_alloted(struct alloted_s **head)\n{\n\tstruct alloted_s *cur;\n\n\tif (head == NULL) {\n\t\treturn;\n\t}\n\n\tcur = *head;\n\n\twhile (cur != NULL) {\n\t\tcur = cur->next;\n\t\tfree((*head)->name);\n\t\tfree(*head);\n\t\t*head = cur;\n\t}\n}",
          "includes": [
            "#include \"network.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <linux/netlink.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <sched.h>",
            "#include <string.h>",
            "#include <alloca.h>",
            "#include <sys/file.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic void free_alloted(struct alloted_s **head)\n{\n\tstruct alloted_s *cur;\n\n\tif (head == NULL) {\n\t\treturn;\n\t}\n\n\tcur = *head;\n\n\twhile (cur != NULL) {\n\t\tcur = cur->next;\n\t\tfree((*head)->name);\n\t\tfree(*head);\n\t\t*head = cur;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "name"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Out of memory in append_alloted\\n\""
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct alloted_s)"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"NULL parameters to append_alloted not allowed\\n\""
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic struct alloted_s *append_alloted(struct alloted_s **head, char *name, int n)\n{\n\tstruct alloted_s *cur, *al;\n\n\tif (head == NULL || name == NULL) {\n\t\t// sanity check. parameters should not be null\n\t\tfprintf(stderr, \"NULL parameters to append_alloted not allowed\\n\");\n\t\treturn NULL;\n\t}\n\n\tal = (struct alloted_s *)malloc(sizeof(struct alloted_s));\n\n\tif (al == NULL) {\n\t\t// unable to allocate memory to new struct\n\t\tfprintf(stderr, \"Out of memory in append_alloted\\n\");\n\t\treturn NULL;\n\t}\n\n\tal->name = strdup(name);\n\n\tif (al->name == NULL) {\n\t\tfree(al);\n\t\treturn NULL;\n\t}\n\n\tal->allowed = n;\n\tal->next = NULL;\n\n\tif (*head == NULL) {\n\t\t*head = al;\n\t\treturn al;\n\t}\n\n\tcur = *head;\n\twhile (cur->next != NULL)\n\t\tcur = cur->next;\n\n\tcur->next = al;\n\treturn al;\n}"
  },
  {
    "function_name": "name_is_in_groupnames",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
    "lines": "178-186",
    "snippet": "static bool name_is_in_groupnames(char *name, char **groupnames)\n{\n\twhile (groupnames != NULL) {\n\t\tif (strcmp(name, *groupnames) == 0)\n\t\t\treturn true;\n\t\tgroupnames++;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"network.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <linux/netlink.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <sched.h>",
      "#include <string.h>",
      "#include <alloca.h>",
      "#include <sys/file.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <stdbool.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "*groupnames"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool name_is_in_groupnames(char *name, char **groupnames)\n{\n\twhile (groupnames != NULL) {\n\t\tif (strcmp(name, *groupnames) == 0)\n\t\t\treturn true;\n\t\tgroupnames++;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "get_groupnames",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
    "lines": "111-176",
    "snippet": "static char **get_groupnames(void)\n{\n\tint ngroups;\n\tgid_t *group_ids;\n\tint ret, i;\n\tchar **groupnames;\n\tstruct group *gr;\n\n\tngroups = getgroups(0, NULL);\n\n\tif (ngroups == -1) {\n\t\tfprintf(stderr, \"Failed to get number of groups user belongs to: %s\\n\", strerror(errno));\n\t\treturn NULL;\n\t}\n\tif (ngroups == 0)\n\t\treturn NULL;\n\n\tgroup_ids = (gid_t *)malloc(sizeof(gid_t)*ngroups);\n\n\tif (group_ids == NULL) {\n\t\tfprintf(stderr, \"Out of memory while getting groups the user belongs to\\n\");\n\t\treturn NULL;\n\t}\n\n\tret = getgroups(ngroups, group_ids);\n\n\tif (ret < 0) {\n\t\tfree(group_ids);\n\t\tfprintf(stderr, \"Failed to get process groups: %s\\n\", strerror(errno));\n\t\treturn NULL;\n\t}\n\n\tgroupnames = (char **)malloc(sizeof(char *)*(ngroups+1));\n\n\tif (groupnames == NULL) {\n\t\tfree(group_ids);\n\t\tfprintf(stderr, \"Out of memory while getting group names\\n\");\n\t\treturn NULL;\n\t}\n\n\tmemset(groupnames, 0, sizeof(char *)*(ngroups+1));\n\n\tfor (i=0; i<ngroups; i++ ) {\n\t\tgr = getgrgid(group_ids[i]);\n\n\t\tif (gr == NULL) {\n\t\t\tfprintf(stderr, \"Failed to get group name\\n\");\n\t\t\tfree(group_ids);\n\t\t\tfree_groupnames(groupnames);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tgroupnames[i] = strdup(gr->gr_name);\n\n\t\tif (groupnames[i] == NULL) {\n\t\t\tfprintf(stderr, \"Failed to copy group name: %s\", gr->gr_name);\n\t\t\tfree(group_ids);\n\t\t\tfree_groupnames(groupnames);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tfree(group_ids);\n\n\treturn groupnames;\n}",
    "includes": [
      "#include \"network.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <linux/netlink.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <sched.h>",
      "#include <string.h>",
      "#include <alloca.h>",
      "#include <sys/file.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <stdbool.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "group_ids"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "free_alloted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
          "lines": "235-251",
          "snippet": "static void free_alloted(struct alloted_s **head)\n{\n\tstruct alloted_s *cur;\n\n\tif (head == NULL) {\n\t\treturn;\n\t}\n\n\tcur = *head;\n\n\twhile (cur != NULL) {\n\t\tcur = cur->next;\n\t\tfree((*head)->name);\n\t\tfree(*head);\n\t\t*head = cur;\n\t}\n}",
          "includes": [
            "#include \"network.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <linux/netlink.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <sched.h>",
            "#include <string.h>",
            "#include <alloca.h>",
            "#include <sys/file.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic void free_alloted(struct alloted_s **head)\n{\n\tstruct alloted_s *cur;\n\n\tif (head == NULL) {\n\t\treturn;\n\t}\n\n\tcur = *head;\n\n\twhile (cur != NULL) {\n\t\tcur = cur->next;\n\t\tfree((*head)->name);\n\t\tfree(*head);\n\t\t*head = cur;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_groupnames",
          "args": [
            "groupnames"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "free_groupnames",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
          "lines": "101-109",
          "snippet": "static void free_groupnames(char **groupnames)\n{\n\tint i;\n\tif (!groupnames)\n\t\treturn;\n\tfor (i = 0; groupnames[i]; i++)\n\t\tfree(groupnames[i]);\n\tfree(groupnames);\n}",
          "includes": [
            "#include \"network.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <linux/netlink.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <sched.h>",
            "#include <string.h>",
            "#include <alloca.h>",
            "#include <sys/file.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic void free_groupnames(char **groupnames)\n{\n\tint i;\n\tif (!groupnames)\n\t\treturn;\n\tfor (i = 0; groupnames[i]; i++)\n\t\tfree(groupnames[i]);\n\tfree(groupnames);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to copy group name: %s\"",
            "gr->gr_name"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "gr->gr_name"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to get group name\\n\""
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgrgid",
          "args": [
            "group_ids[i]"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "groupnames",
            "0",
            "sizeof(char *)*(ngroups+1)"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Out of memory while getting group names\\n\""
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(char *)*(ngroups+1)"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to get process groups: %s\\n\"",
            "strerror(errno)"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgroups",
          "args": [
            "ngroups",
            "group_ids"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Out of memory while getting groups the user belongs to\\n\""
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(gid_t)*ngroups"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to get number of groups user belongs to: %s\\n\"",
            "strerror(errno)"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgroups",
          "args": [
            "0",
            "NULL"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char **get_groupnames(void)\n{\n\tint ngroups;\n\tgid_t *group_ids;\n\tint ret, i;\n\tchar **groupnames;\n\tstruct group *gr;\n\n\tngroups = getgroups(0, NULL);\n\n\tif (ngroups == -1) {\n\t\tfprintf(stderr, \"Failed to get number of groups user belongs to: %s\\n\", strerror(errno));\n\t\treturn NULL;\n\t}\n\tif (ngroups == 0)\n\t\treturn NULL;\n\n\tgroup_ids = (gid_t *)malloc(sizeof(gid_t)*ngroups);\n\n\tif (group_ids == NULL) {\n\t\tfprintf(stderr, \"Out of memory while getting groups the user belongs to\\n\");\n\t\treturn NULL;\n\t}\n\n\tret = getgroups(ngroups, group_ids);\n\n\tif (ret < 0) {\n\t\tfree(group_ids);\n\t\tfprintf(stderr, \"Failed to get process groups: %s\\n\", strerror(errno));\n\t\treturn NULL;\n\t}\n\n\tgroupnames = (char **)malloc(sizeof(char *)*(ngroups+1));\n\n\tif (groupnames == NULL) {\n\t\tfree(group_ids);\n\t\tfprintf(stderr, \"Out of memory while getting group names\\n\");\n\t\treturn NULL;\n\t}\n\n\tmemset(groupnames, 0, sizeof(char *)*(ngroups+1));\n\n\tfor (i=0; i<ngroups; i++ ) {\n\t\tgr = getgrgid(group_ids[i]);\n\n\t\tif (gr == NULL) {\n\t\t\tfprintf(stderr, \"Failed to get group name\\n\");\n\t\t\tfree(group_ids);\n\t\t\tfree_groupnames(groupnames);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tgroupnames[i] = strdup(gr->gr_name);\n\n\t\tif (groupnames[i] == NULL) {\n\t\t\tfprintf(stderr, \"Failed to copy group name: %s\", gr->gr_name);\n\t\t\tfree(group_ids);\n\t\t\tfree_groupnames(groupnames);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tfree(group_ids);\n\n\treturn groupnames;\n}"
  },
  {
    "function_name": "free_groupnames",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
    "lines": "101-109",
    "snippet": "static void free_groupnames(char **groupnames)\n{\n\tint i;\n\tif (!groupnames)\n\t\treturn;\n\tfor (i = 0; groupnames[i]; i++)\n\t\tfree(groupnames[i]);\n\tfree(groupnames);\n}",
    "includes": [
      "#include \"network.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <linux/netlink.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <sched.h>",
      "#include <string.h>",
      "#include <alloca.h>",
      "#include <sys/file.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <stdbool.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "groupnames"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "free_alloted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
          "lines": "235-251",
          "snippet": "static void free_alloted(struct alloted_s **head)\n{\n\tstruct alloted_s *cur;\n\n\tif (head == NULL) {\n\t\treturn;\n\t}\n\n\tcur = *head;\n\n\twhile (cur != NULL) {\n\t\tcur = cur->next;\n\t\tfree((*head)->name);\n\t\tfree(*head);\n\t\t*head = cur;\n\t}\n}",
          "includes": [
            "#include \"network.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <linux/netlink.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <sched.h>",
            "#include <string.h>",
            "#include <alloca.h>",
            "#include <sys/file.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic void free_alloted(struct alloted_s **head)\n{\n\tstruct alloted_s *cur;\n\n\tif (head == NULL) {\n\t\treturn;\n\t}\n\n\tcur = *head;\n\n\twhile (cur != NULL) {\n\t\tcur = cur->next;\n\t\tfree((*head)->name);\n\t\tfree(*head);\n\t\t*head = cur;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic void free_groupnames(char **groupnames)\n{\n\tint i;\n\tif (!groupnames)\n\t\treturn;\n\tfor (i = 0; groupnames[i]; i++)\n\t\tfree(groupnames[i]);\n\tfree(groupnames);\n}"
  },
  {
    "function_name": "get_username",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
    "lines": "89-99",
    "snippet": "static char *get_username(void)\n{\n\tstruct passwd *pwd = getpwuid(getuid());\n\n\tif (pwd == NULL) {\n\t\tperror(\"getpwuid\");\n\t\treturn NULL;\n\t}\n\n\treturn pwd->pw_name;\n}",
    "includes": [
      "#include \"network.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <linux/netlink.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <sched.h>",
      "#include <string.h>",
      "#include <alloca.h>",
      "#include <sys/file.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <stdbool.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"getpwuid\""
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpwuid",
          "args": [
            "getuid()"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *get_username(void)\n{\n\tstruct passwd *pwd = getpwuid(getuid());\n\n\tif (pwd == NULL) {\n\t\tperror(\"getpwuid\");\n\t\treturn NULL;\n\t}\n\n\treturn pwd->pw_name;\n}"
  },
  {
    "function_name": "open_and_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
    "lines": "62-86",
    "snippet": "static int open_and_lock(char *path)\n{\n\tint fd;\n\tstruct flock lk;\n\n\tfd = open(path, O_RDWR|O_CREAT, S_IWUSR | S_IRUSR);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Failed to open %s: %s\\n\",\n\t\t\tpath, strerror(errno));\n\t\treturn(fd);\n\t}\n\n\tlk.l_type = F_WRLCK;\n\tlk.l_whence = SEEK_SET;\n\tlk.l_start = 0;\n\tlk.l_len = 0;\n\tif (fcntl(fd, F_SETLKW, &lk) < 0) {\n\t\tfprintf(stderr, \"Failed to lock %s: %s\\n\",\n\t\t\tpath, strerror(errno));\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}",
    "includes": [
      "#include \"network.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <linux/netlink.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <sched.h>",
      "#include <string.h>",
      "#include <alloca.h>",
      "#include <sys/file.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <stdbool.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to lock %s: %s\\n\"",
            "path",
            "strerror(errno)"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "fd",
            "F_SETLKW",
            "&lk"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to open %s: %s\\n\"",
            "path",
            "strerror(errno)"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "path",
            "O_RDWR|O_CREAT",
            "S_IWUSR | S_IRUSR"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "37-82",
          "snippet": "int lxc_abstract_unix_open(const char *path, int type, int flags)\n{\n\tint fd;\n\tsize_t len;\n\tstruct sockaddr_un addr;\n\n\tif (flags & O_TRUNC)\n\t\tunlink(path);\n\n\tfd = socket(PF_UNIX, type, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\n\t/* Clear address structure */\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (!path)\n\t\treturn fd;\n\n\taddr.sun_family = AF_UNIX;\n\n\tlen = strlen(&path[1]) + 1;\n\tif (len >= sizeof(addr.sun_path) - 1) {\n\t\tclose(fd);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\t/* addr.sun_path[0] has already been set to 0 by memset() */\n\tstrncpy(&addr.sun_path[1], &path[1], strlen(&path[1]));\n\n\tif (bind(fd, (struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path) + len)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\tif (type == SOCK_STREAM && listen(fd, 100)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_open(const char *path, int type, int flags)\n{\n\tint fd;\n\tsize_t len;\n\tstruct sockaddr_un addr;\n\n\tif (flags & O_TRUNC)\n\t\tunlink(path);\n\n\tfd = socket(PF_UNIX, type, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\n\t/* Clear address structure */\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (!path)\n\t\treturn fd;\n\n\taddr.sun_family = AF_UNIX;\n\n\tlen = strlen(&path[1]) + 1;\n\tif (len >= sizeof(addr.sun_path) - 1) {\n\t\tclose(fd);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\t/* addr.sun_path[0] has already been set to 0 by memset() */\n\tstrncpy(&addr.sun_path[1], &path[1], strlen(&path[1]));\n\n\tif (bind(fd, (struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path) + len)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\tif (type == SOCK_STREAM && listen(fd, 100)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int open_and_lock(char *path)\n{\n\tint fd;\n\tstruct flock lk;\n\n\tfd = open(path, O_RDWR|O_CREAT, S_IWUSR | S_IRUSR);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Failed to open %s: %s\\n\",\n\t\t\tpath, strerror(errno));\n\t\treturn(fd);\n\t}\n\n\tlk.l_type = F_WRLCK;\n\tlk.l_whence = SEEK_SET;\n\tlk.l_start = 0;\n\tlk.l_len = 0;\n\tif (fcntl(fd, F_SETLKW, &lk) < 0) {\n\t\tfprintf(stderr, \"Failed to lock %s: %s\\n\",\n\t\t\tpath, strerror(errno));\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}"
  },
  {
    "function_name": "usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_user_nic.c",
    "lines": "53-58",
    "snippet": "static void usage(char *me, bool fail)\n{\n\tfprintf(stderr, \"Usage: %s lxcpath name pid type bridge nicname\\n\", me);\n\tfprintf(stderr, \" nicname is the name to use inside the container\\n\");\n\texit(fail ? 1 : 0);\n}",
    "includes": [
      "#include \"network.h\"",
      "#include \"utils.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>",
      "#include <linux/sockios.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <netinet/in.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <arpa/inet.h>",
      "#include <linux/netlink.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <sched.h>",
      "#include <string.h>",
      "#include <alloca.h>",
      "#include <sys/file.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <stdbool.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "fail ? 1 : 0"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" nicname is the name to use inside the container\\n\""
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Usage: %s lxcpath name pid type bridge nicname\\n\"",
            "me"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"network.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include <sys/param.h>\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <linux/netlink.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sched.h>\n#include <string.h>\n#include <alloca.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic void usage(char *me, bool fail)\n{\n\tfprintf(stderr, \"Usage: %s lxcpath name pid type bridge nicname\\n\", me);\n\tfprintf(stderr, \" nicname is the name to use inside the container\\n\");\n\texit(fail ? 1 : 0);\n}"
  }
]