[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_autostart.c",
    "lines": "347-546",
    "snippet": "int main(int argc, char *argv[])\n{\n\tint count = 0;\n\tint i = 0;\n\tint ret = 0;\n\tstruct lxc_container **containers = NULL;\n\tstruct lxc_list **c_groups_lists = NULL;\n\tstruct lxc_list *cmd_group;\n\n\tif (lxc_arguments_parse(&my_args, argc, argv))\n\t\texit(EXIT_FAILURE);\n\n\tif (lxc_log_init(my_args.name, my_args.log_file, my_args.log_priority,\n\t\t\t my_args.progname, my_args.quiet, my_args.lxcpath[0]))\n\t\texit(EXIT_FAILURE);\n\tlxc_log_options_no_override();\n\n\tcount = list_defined_containers(my_args.lxcpath[0], NULL, &containers);\n\n\tif (count < 0)\n\t\texit(EXIT_FAILURE);\n\n\tif (!my_args.all) {\n\t\t/* Allocate an array for our container group lists */\n\t\tc_groups_lists = calloc( count, sizeof( struct lxc_list * ) );\n\t}\n\n\tqsort(&containers[0], count, sizeof(struct lxc_container *), cmporder);\n\n\tif (cmd_groups_list && my_args.all) {\n\t\tfprintf(stderr, \"Specifying -a (all) with -g (groups) doesn't make sense. All option overrides.\\n\");\n\t\tfflush(stderr);\n\t}\n\n\tif (!cmd_groups_list) {\n\t\t/*\n\t\t * We need a default cmd_groups_list even for the -a\n\t\t * case in order to force a pass through the loop for\n\t\t * the NULL group.  This, someday, could be taken from\n\t\t * a config file somewhere...\n\t\t */\n\t\tcmd_groups_list = accumulate_list( \"\" , \",\", NULL );\n\t}\n\n\tlxc_list_for_each(cmd_group, cmd_groups_list) {\n\n\t\t/*\n\t\t * Prograpmmers Note:\n\t\t * Because we may take several passes through the container list\n\t\t * We'll switch on if the container pointer is NULL and if we process a\n\t\t * container (run it or decide to ignore it) and call lxc_container_put\n\t\t * then we'll NULL it out and not check it again.\n\t\t */\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tstruct lxc_container *c = containers[i];\n\n\t\t\tif (!c)\n\t\t\t\t/* Skip - must have been already processed */\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * We haven't loaded the container groups yet so\n\t\t\t * these next two checks don't need to free them\n\t\t\t * if they fail.  They'll fail on the first pass.\n\t\t\t */\n\t\t\tif (!c->may_control(c)) {\n\t\t\t\t/* We're done with this container */\n\t\t\t\tif ( lxc_container_put(c) > 0 )\n\t\t\t\t\tcontainers[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!my_args.ignore_auto &&\n\t\t\t    get_config_integer(c, \"lxc.start.auto\") != 1) {\n\t\t\t\t/* We're done with this container */\n\t\t\t\tif ( lxc_container_put(c) > 0 )\n\t\t\t\t\tcontainers[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!my_args.all) {\n\t\t\t\t/* Filter by group */\n\t\t\t\tif( ! c_groups_lists[i] ) {\n\t\t\t\t\t/* Now we're loading up a container's groups */\n\t\t\t\t\tc_groups_lists[i] = get_config_list(c, \"lxc.group\");\n\t\t\t\t}\n\n\t\t\t\tret = list_contains_entry(cmd_group->elem, c_groups_lists[i]);\n\n\t\t\t\tif ( ret == 0 ) {\n\t\t\t\t\t/* Not in the target group this pass */\n\t\t\t\t\t/* Leave in the list for subsequent passes */\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* We have a candidate continer to process */\n\t\t\tc->want_daemonize(c, 1);\n\n\t\t\tif (my_args.shutdown) {\n\t\t\t\t/* Shutdown the container */\n\t\t\t\tif (c->is_running(c)) {\n\t\t\t\t\tif (my_args.list) {\n\t\t\t\t\t\tprintf(\"%s\\n\", c->name);\n\t\t\t\t\t\tfflush(stdout);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (!c->shutdown(c, my_args.timeout)) {\n\t\t\t\t\t\t\tif (!c->stop(c)) {\n\t\t\t\t\t\t\t\tfprintf(stderr, \"Error shutting down container: %s\\n\", c->name);\n\t\t\t\t\t\t\t\tfflush(stderr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (my_args.hardstop) {\n\t\t\t\t/* Kill the container */\n\t\t\t\tif (c->is_running(c)) {\n\t\t\t\t\tif (my_args.list) {\n\t\t\t\t\t\tprintf(\"%s\\n\", c->name);\n\t\t\t\t\t\tfflush(stdout);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (!c->stop(c)) {\n\t\t\t\t\t\t\tfprintf(stderr, \"Error killing container: %s\\n\", c->name);\n\t\t\t\t\t\t\tfflush(stderr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (my_args.reboot) {\n\t\t\t\t/* Reboot the container */\n\t\t\t\tif (c->is_running(c)) {\n\t\t\t\t\tif (my_args.list) {\n\t\t\t\t\t\tprintf(\"%s %d\\n\", c->name,\n\t\t\t\t\t\t       get_config_integer(c, \"lxc.start.delay\"));\n\t\t\t\t\t\tfflush(stdout);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (!c->reboot(c)) {\n\t\t\t\t\t\t\tfprintf(stderr, \"Error rebooting container: %s\\n\", c->name);\n\t\t\t\t\t\t\tfflush(stderr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tsleep(get_config_integer(c, \"lxc.start.delay\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* Start the container */\n\t\t\t\tif (!c->is_running(c)) {\n\t\t\t\t\tif (my_args.list) {\n\t\t\t\t\t\tprintf(\"%s %d\\n\", c->name,\n\t\t\t\t\t\t       get_config_integer(c, \"lxc.start.delay\"));\n\t\t\t\t\t\tfflush(stdout);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (!c->start(c, 0, NULL)) {\n\t\t\t\t\t\t\tfprintf(stderr, \"Error starting container: %s\\n\", c->name);\n\t\t\t\t\t\t\tfflush(stderr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tsleep(get_config_integer(c, \"lxc.start.delay\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If we get this far and we haven't hit any skip \"continue\"\n\t\t\t * then we're done with this container...  We can dump any\n\t\t\t * c_groups_list and the container itself.\n\t\t\t */\n\t\t\tif ( lxc_container_put(c) > 0 ) {\n\t\t\t\tcontainers[i] = NULL;\n\t\t\t}\n\t\t\tif ( c_groups_lists ) {\n\t\t\t\ttoss_list(c_groups_lists[i]);\n\t\t\t\tc_groups_lists[i] = NULL;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/* clean up any lingering detritus */\n\tfor (i = 0; i < count; i++) {\n\t\tif ( containers[i] ) {\n\t\t\tlxc_container_put(containers[i]);\n\t\t}\n\t\tif ( c_groups_lists && c_groups_lists[i] ) {\n\t\t\ttoss_list(c_groups_lists[i]);\n\t\t}\n\t}\n\n\tfree(c_groups_lists);\n\ttoss_list( cmd_groups_list );\n\tfree(containers);\n\n\texit(EXIT_SUCCESS);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"list.h\"",
      "#include \"arguments.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <unistd.h>",
      "#include <string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct lxc_list *cmd_groups_list = NULL;",
      "static struct lxc_arguments my_args = {\n\t.progname = \"lxc-autostart\",\n\t.help     = \"\\\n\\n\\\nlxc-autostart managed auto-started containers\\n\\\n\\n\\\nOptions:\\n\\\n  -k, --kill        kill the containers instead of starting them\\n\\\n  -L, --list        list all affected containers and wait delay\\n\\\n  -r, --reboot      reboot the containers instead of starting them\\n\\\n  -s, --shutdown    shutdown the containers instead of starting them\\n\\\n\\n\\\n  -a, --all         list all auto-started containers (ignore groups)\\n\\\n  -A, --ignore-auto ignore lxc.start.auto and select all matching containers\\n\\\n  -g, --groups      list of groups (comma separated) to select\\n\\\n  -t, --timeout=T   wait T seconds before hard-stopping\\n\",\n\t.options  = my_longopts,\n\t.parser   = my_parser,\n\t.checker  = NULL,\n\t.timeout = 60,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_SUCCESS"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "containers"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "free_mnts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "539-554",
          "snippet": "static void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int mnt_table_size = 0;",
            "static struct mnts *mnt_table = NULL;",
            "static void free_mnts(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic unsigned int mnt_table_size = 0;\nstatic struct mnts *mnt_table = NULL;\nstatic void free_mnts(void);\n\nstatic void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "toss_list",
          "args": [
            "cmd_groups_list"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "toss_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_autostart.c",
          "lines": "332-345",
          "snippet": "static int toss_list( struct lxc_list *c_groups_list ) {\n\tstruct lxc_list *it, *next;\n\n\tif (c_groups_list) {\n\t\tlxc_list_for_each_safe(it, c_groups_list, next) {\n\t\t\tlxc_list_del(it);\n\t\t\tfree(it->elem);\n\t\t\tfree(it);\n\t\t}\n\t\tfree(c_groups_list);\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"list.h\"",
            "#include \"arguments.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <unistd.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"list.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <unistd.h>\n#include <string.h>\n\nstatic int toss_list( struct lxc_list *c_groups_list ) {\n\tstruct lxc_list *it, *next;\n\n\tif (c_groups_list) {\n\t\tlxc_list_for_each_safe(it, c_groups_list, next) {\n\t\t\tlxc_list_del(it);\n\t\t\tfree(it->elem);\n\t\t\tfree(it);\n\t\t}\n\t\tfree(c_groups_list);\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_container_put",
          "args": [
            "containers[i]"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "312-325",
          "snippet": "int lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "get_config_integer(c, \"lxc.start.delay\")"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_util_usleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lua-lxc/core.c",
          "lines": "564-567",
          "snippet": "static int lxc_util_usleep(lua_State *L) {\n    usleep((useconds_t)luaL_checkunsigned(L, 1));\n    return 0;\n}",
          "includes": [
            "#include \"lxc/commands.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <libgen.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <assert.h>",
            "#include <lauxlib.h>",
            "#include <lua.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxc/commands.h\"\n#include <lxc/lxccontainer.h>\n#include <libgen.h>\n#include <unistd.h>\n#include <string.h>\n#include <assert.h>\n#include <lauxlib.h>\n#include <lua.h>\n\nstatic int lxc_util_usleep(lua_State *L) {\n    usleep((useconds_t)luaL_checkunsigned(L, 1));\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_config_integer",
          "args": [
            "c",
            "\"lxc.start.delay\""
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "get_config_integer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_autostart.c",
          "lines": "293-317",
          "snippet": "static int get_config_integer(struct lxc_container *c, char *key) {\n\tint len = 0;\n\tint ret = 0;\n\tchar* value = NULL;\n\n\tlen = c->get_config_item(c, key, NULL, 0);\n\tif (len < 0)\n\t\treturn 0;\n\n\tvalue = (char*) malloc(sizeof(char)*len + 1);\n\tif (value == NULL)\n\t\treturn 0;\n\n\tif (c->get_config_item(c, key, value, len + 1) != len) {\n\t\tfree(value);\n\t\treturn 0;\n\t}\n\n\tif (lxc_safe_int(value, &ret) < 0)\n\t\tDEBUG(\"Could not parse config item.\");\n\n\tfree(value);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"list.h\"",
            "#include \"arguments.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <unistd.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"list.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <unistd.h>\n#include <string.h>\n\nstatic int get_config_integer(struct lxc_container *c, char *key) {\n\tint len = 0;\n\tint ret = 0;\n\tchar* value = NULL;\n\n\tlen = c->get_config_item(c, key, NULL, 0);\n\tif (len < 0)\n\t\treturn 0;\n\n\tvalue = (char*) malloc(sizeof(char)*len + 1);\n\tif (value == NULL)\n\t\treturn 0;\n\n\tif (c->get_config_item(c, key, value, len + 1) != len) {\n\t\tfree(value);\n\t\treturn 0;\n\t}\n\n\tif (lxc_safe_int(value, &ret) < 0)\n\t\tDEBUG(\"Could not parse config item.\");\n\n\tfree(value);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stderr"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error starting container: %s\\n\"",
            "c->name"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->start",
          "args": [
            "c",
            "0",
            "NULL"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s %d\\n\"",
            "c->name",
            "get_config_integer(c, \"lxc.start.delay\")"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->is_running",
          "args": [
            "c"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stderr"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error rebooting container: %s\\n\"",
            "c->name"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->reboot",
          "args": [
            "c"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s %d\\n\"",
            "c->name",
            "get_config_integer(c, \"lxc.start.delay\")"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->is_running",
          "args": [
            "c"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stderr"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error killing container: %s\\n\"",
            "c->name"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->stop",
          "args": [
            "c"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s\\n\"",
            "c->name"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->is_running",
          "args": [
            "c"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stderr"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error shutting down container: %s\\n\"",
            "c->name"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->stop",
          "args": [
            "c"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->shutdown",
          "args": [
            "c",
            "my_args.timeout"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s\\n\"",
            "c->name"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->is_running",
          "args": [
            "c"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->want_daemonize",
          "args": [
            "c",
            "1"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_contains_entry",
          "args": [
            "cmd_group->elem",
            "c_groups_lists[i]"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "list_contains_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_autostart.c",
          "lines": "103-124",
          "snippet": "int list_contains_entry( char *str_ptr, struct lxc_list *p1 ) {\n\tstruct lxc_list *it1;\n\n\t/*\n\t * If the entry is NULL or the empty string and the list\n\t * is NULL, we have a match\n\t */\n\tif (! p1 && ! str_ptr)\n\t\treturn 1;\n\tif (! p1 && ! *str_ptr)\n\t\treturn 1;\n\n\tif (!p1)\n\t\treturn 0;\n\n\tlxc_list_for_each(it1, p1) {\n\t\tif (strcmp(it1->elem, str_ptr) == 0)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"list.h\"",
            "#include \"arguments.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <unistd.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"list.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <unistd.h>\n#include <string.h>\n\nint list_contains_entry( char *str_ptr, struct lxc_list *p1 ) {\n\tstruct lxc_list *it1;\n\n\t/*\n\t * If the entry is NULL or the empty string and the list\n\t * is NULL, we have a match\n\t */\n\tif (! p1 && ! str_ptr)\n\t\treturn 1;\n\tif (! p1 && ! *str_ptr)\n\t\treturn 1;\n\n\tif (!p1)\n\t\treturn 0;\n\n\tlxc_list_for_each(it1, p1) {\n\t\tif (strcmp(it1->elem, str_ptr) == 0)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_config_list",
          "args": [
            "c",
            "\"lxc.group\""
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "get_config_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_autostart.c",
          "lines": "264-291",
          "snippet": "static struct lxc_list *get_config_list(struct lxc_container *c, char *key) {\n\tint len = 0;\n\tchar* value = NULL;\n\tstruct lxc_list *config_list = NULL;\n\n\tlen = c->get_config_item(c, key, NULL, 0);\n\tif (len < 0)\n\t\treturn NULL;\n\n\tvalue = (char*) malloc(sizeof(char)*len + 1);\n\tif (value == NULL)\n\t\treturn NULL;\n\n\tif (c->get_config_item(c, key, value, len + 1) != len) {\n\t\tfree(value);\n\t\treturn NULL;\n\t}\n\n\tif (strlen(value) == 0) {\n\t\tfree(value);\n\t\treturn NULL;\n\t}\n\n\tconfig_list = get_list(value, \"\\n\");\n\tfree(value);\n\n\treturn config_list;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"list.h\"",
            "#include \"arguments.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <unistd.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"list.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <unistd.h>\n#include <string.h>\n\nstatic struct lxc_list *get_config_list(struct lxc_container *c, char *key) {\n\tint len = 0;\n\tchar* value = NULL;\n\tstruct lxc_list *config_list = NULL;\n\n\tlen = c->get_config_item(c, key, NULL, 0);\n\tif (len < 0)\n\t\treturn NULL;\n\n\tvalue = (char*) malloc(sizeof(char)*len + 1);\n\tif (value == NULL)\n\t\treturn NULL;\n\n\tif (c->get_config_item(c, key, value, len + 1) != len) {\n\t\tfree(value);\n\t\treturn NULL;\n\t}\n\n\tif (strlen(value) == 0) {\n\t\tfree(value);\n\t\treturn NULL;\n\t}\n\n\tconfig_list = get_list(value, \"\\n\");\n\tfree(value);\n\n\treturn config_list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->may_control",
          "args": [
            "c"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "cmd_group",
            "cmd_groups_list"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "accumulate_list",
          "args": [
            "\"\"",
            "\",\"",
            "NULL"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "accumulate_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_autostart.c",
          "lines": "156-221",
          "snippet": "static struct lxc_list *accumulate_list(char *input, char *delimiter, struct lxc_list *str_list) {\n\tchar *workstr = NULL;\n\tchar *workptr = NULL;\n\tchar *next_ptr = NULL;\n\tstruct lxc_list *worklist;\n\tstruct lxc_list *workstr_list;\n\n\tworkstr = strdup(input);\n\tif (!workstr) {\n\t\treturn NULL;\n\t}\n\n\tworkstr_list = str_list;\n\tif ( ! workstr_list ) {\n\t\tworkstr_list = malloc(sizeof(*workstr_list));\n\t\tlxc_list_init(workstr_list);\n\t}\n\n\tfor (workptr = workstr; workptr; workptr = next_ptr) {\n\t\t/*\n\t\t * We can't use strtok_r here because it collapses\n\t\t * multiple delimiters into 1 making empty fields\n\t\t * impossible...\n\t\t */\n\t\t/* token = strtok_r(workptr, delimiter, &sptr); */\n\t\tnext_ptr = strchr( workptr, *delimiter );\n\n\t\tif( next_ptr ) {\n\t\t\t*next_ptr++ = '\\0';\n\t\t}\n\n\t\t/*\n\t\t * At this point, we'd like to check to see if this\n\t\t * group is already contained in the list and ignore\n\t\t * it if it is...  This also helps us with any\n\t\t * corner cases where a string begins or ends with a\n\t\t * delimiter.\n\t\t */\n\n\t\tif ( list_contains_entry( workptr, workstr_list ) ) {\n\t\t\tif ( *workptr ) {\n\t\t\t\tfprintf(stderr, \"Duplicate group \\\"%s\\\" in list - ignoring\\n\", workptr );\n\t\t\t\tfflush(stderr);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Duplicate NULL group in list - ignoring\\n\" );\n\t\t\t\tfflush(stderr);\n\t\t\t}\n\t\t} else {\n\t\t\tworklist = malloc(sizeof(*worklist));\n\t\t\tif (!worklist)\n\t\t\t\tbreak;\n\n\t\t\tworklist->elem = strdup(workptr);\n\t\t\tif (!worklist->elem) {\n\t\t\t\tfree(worklist);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlxc_list_add_tail(workstr_list, worklist);\n\t\t}\n\t}\n\n\tfree(workstr);\n\n\treturn workstr_list;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"list.h\"",
            "#include \"arguments.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <unistd.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lxc_list *accumulate_list(char *input, char *delimiter, struct lxc_list *str_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"list.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <unistd.h>\n#include <string.h>\n\nstatic struct lxc_list *accumulate_list(char *input, char *delimiter, struct lxc_list *str_list);\n\nstatic struct lxc_list *accumulate_list(char *input, char *delimiter, struct lxc_list *str_list) {\n\tchar *workstr = NULL;\n\tchar *workptr = NULL;\n\tchar *next_ptr = NULL;\n\tstruct lxc_list *worklist;\n\tstruct lxc_list *workstr_list;\n\n\tworkstr = strdup(input);\n\tif (!workstr) {\n\t\treturn NULL;\n\t}\n\n\tworkstr_list = str_list;\n\tif ( ! workstr_list ) {\n\t\tworkstr_list = malloc(sizeof(*workstr_list));\n\t\tlxc_list_init(workstr_list);\n\t}\n\n\tfor (workptr = workstr; workptr; workptr = next_ptr) {\n\t\t/*\n\t\t * We can't use strtok_r here because it collapses\n\t\t * multiple delimiters into 1 making empty fields\n\t\t * impossible...\n\t\t */\n\t\t/* token = strtok_r(workptr, delimiter, &sptr); */\n\t\tnext_ptr = strchr( workptr, *delimiter );\n\n\t\tif( next_ptr ) {\n\t\t\t*next_ptr++ = '\\0';\n\t\t}\n\n\t\t/*\n\t\t * At this point, we'd like to check to see if this\n\t\t * group is already contained in the list and ignore\n\t\t * it if it is...  This also helps us with any\n\t\t * corner cases where a string begins or ends with a\n\t\t * delimiter.\n\t\t */\n\n\t\tif ( list_contains_entry( workptr, workstr_list ) ) {\n\t\t\tif ( *workptr ) {\n\t\t\t\tfprintf(stderr, \"Duplicate group \\\"%s\\\" in list - ignoring\\n\", workptr );\n\t\t\t\tfflush(stderr);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Duplicate NULL group in list - ignoring\\n\" );\n\t\t\t\tfflush(stderr);\n\t\t\t}\n\t\t} else {\n\t\t\tworklist = malloc(sizeof(*worklist));\n\t\t\tif (!worklist)\n\t\t\t\tbreak;\n\n\t\t\tworklist->elem = strdup(workptr);\n\t\t\tif (!worklist->elem) {\n\t\t\t\tfree(worklist);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlxc_list_add_tail(workstr_list, worklist);\n\t\t}\n\t}\n\n\tfree(workstr);\n\n\treturn workstr_list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stderr"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Specifying -a (all) with -g (groups) doesn't make sense. All option overrides.\\n\""
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "&containers[0]",
            "count",
            "sizeof(struct lxc_container *)",
            "cmporder"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "count",
            "sizeof( struct lxc_list * )"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_defined_containers",
          "args": [
            "my_args.lxcpath[0]",
            "NULL",
            "&containers"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "list_defined_containers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "4234-4319",
          "snippet": "int list_defined_containers(const char *lxcpath, char ***names, struct lxc_container ***cret)\n{\n\tDIR *dir;\n\tint i, cfound = 0, nfound = 0;\n\tstruct dirent *direntp;\n\tstruct lxc_container *c;\n\n\tif (!lxcpath)\n\t\tlxcpath = lxc_global_config_value(\"lxc.lxcpath\");\n\n\tdir = opendir(lxcpath);\n\tif (!dir) {\n\t\tSYSERROR(\"opendir on lxcpath\");\n\t\treturn -1;\n\t}\n\n\tif (cret)\n\t\t*cret = NULL;\n\tif (names)\n\t\t*names = NULL;\n\n\twhile ((direntp = readdir(dir))) {\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\t// Ignore '.', '..' and any hidden directory\n\t\tif (!strncmp(direntp->d_name, \".\", 1))\n\t\t\tcontinue;\n\n\t\tif (!config_file_exists(lxcpath, direntp->d_name))\n\t\t\tcontinue;\n\n\t\tif (names) {\n\t\t\tif (!add_to_array(names, direntp->d_name, cfound))\n\t\t\t\tgoto free_bad;\n\t\t}\n\t\tcfound++;\n\n\t\tif (!cret) {\n\t\t\tnfound++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tc = lxc_container_new(direntp->d_name, lxcpath);\n\t\tif (!c) {\n\t\t\tINFO(\"Container %s:%s has a config but could not be loaded\",\n\t\t\t\tlxcpath, direntp->d_name);\n\t\t\tif (names)\n\t\t\t\tif(!remove_from_array(names, direntp->d_name, cfound--))\n\t\t\t\t\tgoto free_bad;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!do_lxcapi_is_defined(c)) {\n\t\t\tINFO(\"Container %s:%s has a config but is not defined\",\n\t\t\t\tlxcpath, direntp->d_name);\n\t\t\tif (names)\n\t\t\t\tif(!remove_from_array(names, direntp->d_name, cfound--))\n\t\t\t\t\tgoto free_bad;\n\t\t\tlxc_container_put(c);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!add_to_clist(cret, c, nfound, true)) {\n\t\t\tlxc_container_put(c);\n\t\t\tgoto free_bad;\n\t\t}\n\t\tnfound++;\n\t}\n\n\tclosedir(dir);\n\treturn nfound;\n\nfree_bad:\n\tif (names && *names) {\n\t\tfor (i=0; i<cfound; i++)\n\t\t\tfree((*names)[i]);\n\t\tfree(*names);\n\t}\n\tif (cret && *cret) {\n\t\tfor (i=0; i<nfound; i++)\n\t\t\tlxc_container_put((*cret)[i]);\n\t\tfree(*cret);\n\t}\n\tclosedir(dir);\n\treturn -1;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint list_defined_containers(const char *lxcpath, char ***names, struct lxc_container ***cret)\n{\n\tDIR *dir;\n\tint i, cfound = 0, nfound = 0;\n\tstruct dirent *direntp;\n\tstruct lxc_container *c;\n\n\tif (!lxcpath)\n\t\tlxcpath = lxc_global_config_value(\"lxc.lxcpath\");\n\n\tdir = opendir(lxcpath);\n\tif (!dir) {\n\t\tSYSERROR(\"opendir on lxcpath\");\n\t\treturn -1;\n\t}\n\n\tif (cret)\n\t\t*cret = NULL;\n\tif (names)\n\t\t*names = NULL;\n\n\twhile ((direntp = readdir(dir))) {\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\t// Ignore '.', '..' and any hidden directory\n\t\tif (!strncmp(direntp->d_name, \".\", 1))\n\t\t\tcontinue;\n\n\t\tif (!config_file_exists(lxcpath, direntp->d_name))\n\t\t\tcontinue;\n\n\t\tif (names) {\n\t\t\tif (!add_to_array(names, direntp->d_name, cfound))\n\t\t\t\tgoto free_bad;\n\t\t}\n\t\tcfound++;\n\n\t\tif (!cret) {\n\t\t\tnfound++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tc = lxc_container_new(direntp->d_name, lxcpath);\n\t\tif (!c) {\n\t\t\tINFO(\"Container %s:%s has a config but could not be loaded\",\n\t\t\t\tlxcpath, direntp->d_name);\n\t\t\tif (names)\n\t\t\t\tif(!remove_from_array(names, direntp->d_name, cfound--))\n\t\t\t\t\tgoto free_bad;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!do_lxcapi_is_defined(c)) {\n\t\t\tINFO(\"Container %s:%s has a config but is not defined\",\n\t\t\t\tlxcpath, direntp->d_name);\n\t\t\tif (names)\n\t\t\t\tif(!remove_from_array(names, direntp->d_name, cfound--))\n\t\t\t\t\tgoto free_bad;\n\t\t\tlxc_container_put(c);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!add_to_clist(cret, c, nfound, true)) {\n\t\t\tlxc_container_put(c);\n\t\t\tgoto free_bad;\n\t\t}\n\t\tnfound++;\n\t}\n\n\tclosedir(dir);\n\treturn nfound;\n\nfree_bad:\n\tif (names && *names) {\n\t\tfor (i=0; i<cfound; i++)\n\t\t\tfree((*names)[i]);\n\t\tfree(*names);\n\t}\n\tif (cret && *cret) {\n\t\tfor (i=0; i<nfound; i++)\n\t\t\tlxc_container_put((*cret)[i]);\n\t\tfree(*cret);\n\t}\n\tclosedir(dir);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_log_options_no_override",
          "args": [],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_log_options_no_override",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
          "lines": "685-689",
          "snippet": "extern void lxc_log_options_no_override()\n{\n\tlxc_quiet_specified = 1;\n\tlxc_loglevel_specified = 1;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"caps.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <pthread.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int lxc_quiet_specified;",
            "static int lxc_loglevel_specified;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nint lxc_quiet_specified;\nstatic int lxc_loglevel_specified;\n\nextern void lxc_log_options_no_override()\n{\n\tlxc_quiet_specified = 1;\n\tlxc_loglevel_specified = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_log_init",
          "args": [
            "my_args.name",
            "my_args.log_file",
            "my_args.log_priority",
            "my_args.progname",
            "my_args.quiet",
            "my_args.lxcpath[0]"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_log_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
          "lines": "546-615",
          "snippet": "extern int lxc_log_init(const char *name, const char *file,\n\t\t\tconst char *priority, const char *prefix, int quiet,\n\t\t\tconst char *lxcpath)\n{\n\tint lxc_priority = LXC_LOG_PRIORITY_ERROR;\n\tint ret;\n\n\tif (lxc_log_fd != -1) {\n\t\tWARN(\"lxc_log_init called with log already initialized\");\n\t\treturn 0;\n\t}\n\n\tif (priority)\n\t\tlxc_priority = lxc_log_priority_to_int(priority);\n\n\tif (!lxc_loglevel_specified) {\n\t\tlxc_log_category_lxc.priority = lxc_priority;\n\t\tlxc_loglevel_specified = 1;\n\t}\n\n\tif (!lxc_quiet_specified) {\n\t\tif (!quiet)\n\t\t\tlxc_log_category_lxc.appender->next = &log_appender_stderr;\n\t}\n\n\tif (prefix)\n\t\tlxc_log_set_prefix(prefix);\n\n\tif (name)\n\t\tlog_vmname = strdup(name);\n\n\tif (file) {\n\t\tif (strcmp(file, \"none\") == 0)\n\t\t\treturn 0;\n\t\tret = __lxc_log_set_file(file, 1);\n\t\tlxc_log_use_global_fd = 1;\n\t} else {\n\t\t/* if no name was specified, there nothing to do */\n\t\tif (!name)\n\t\t\treturn 0;\n\n\t\tret = -1;\n\n\t\tif (!lxcpath)\n\t\t\tlxcpath = LOGPATH;\n\n\t\t/* try LOGPATH if lxcpath is the default for the privileged containers */\n\t\tif (!geteuid() && strcmp(LXCPATH, lxcpath) == 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\n\t\t/* try in lxcpath */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, lxcpath, 1);\n\n\t\t/* try LOGPATH in case its writable by the caller */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\t}\n\n\t/*\n\t * If !file, that is, if the user did not request this logpath, then\n\t * ignore failures and continue logging to console\n\t */\n\tif (!file && ret != 0) {\n\t\tINFO(\"Ignoring failure to open default logfile.\");\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"caps.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <pthread.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int lxc_log_fd = -1;",
            "int lxc_quiet_specified;",
            "int lxc_log_use_global_fd;",
            "static int lxc_loglevel_specified;",
            "static char *log_vmname = NULL;",
            "static struct lxc_log_appender log_appender_stderr = {\n\t.name\t\t= \"stderr\",\n\t.append\t\t= log_append_stderr,\n\t.next\t\t= NULL,\n};",
            "struct lxc_log_category lxc_log_category_lxc = {\n\t.name\t\t= \"lxc\",\n\t.priority\t= LXC_LOG_PRIORITY_ERROR,\n\t.appender\t= &log_appender_logfile,\n\t.parent\t\t= &log_root\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nint lxc_log_fd = -1;\nint lxc_quiet_specified;\nint lxc_log_use_global_fd;\nstatic int lxc_loglevel_specified;\nstatic char *log_vmname = NULL;\nstatic struct lxc_log_appender log_appender_stderr = {\n\t.name\t\t= \"stderr\",\n\t.append\t\t= log_append_stderr,\n\t.next\t\t= NULL,\n};\nstruct lxc_log_category lxc_log_category_lxc = {\n\t.name\t\t= \"lxc\",\n\t.priority\t= LXC_LOG_PRIORITY_ERROR,\n\t.appender\t= &log_appender_logfile,\n\t.parent\t\t= &log_root\n};\n\nextern int lxc_log_init(const char *name, const char *file,\n\t\t\tconst char *priority, const char *prefix, int quiet,\n\t\t\tconst char *lxcpath)\n{\n\tint lxc_priority = LXC_LOG_PRIORITY_ERROR;\n\tint ret;\n\n\tif (lxc_log_fd != -1) {\n\t\tWARN(\"lxc_log_init called with log already initialized\");\n\t\treturn 0;\n\t}\n\n\tif (priority)\n\t\tlxc_priority = lxc_log_priority_to_int(priority);\n\n\tif (!lxc_loglevel_specified) {\n\t\tlxc_log_category_lxc.priority = lxc_priority;\n\t\tlxc_loglevel_specified = 1;\n\t}\n\n\tif (!lxc_quiet_specified) {\n\t\tif (!quiet)\n\t\t\tlxc_log_category_lxc.appender->next = &log_appender_stderr;\n\t}\n\n\tif (prefix)\n\t\tlxc_log_set_prefix(prefix);\n\n\tif (name)\n\t\tlog_vmname = strdup(name);\n\n\tif (file) {\n\t\tif (strcmp(file, \"none\") == 0)\n\t\t\treturn 0;\n\t\tret = __lxc_log_set_file(file, 1);\n\t\tlxc_log_use_global_fd = 1;\n\t} else {\n\t\t/* if no name was specified, there nothing to do */\n\t\tif (!name)\n\t\t\treturn 0;\n\n\t\tret = -1;\n\n\t\tif (!lxcpath)\n\t\t\tlxcpath = LOGPATH;\n\n\t\t/* try LOGPATH if lxcpath is the default for the privileged containers */\n\t\tif (!geteuid() && strcmp(LXCPATH, lxcpath) == 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\n\t\t/* try in lxcpath */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, lxcpath, 1);\n\n\t\t/* try LOGPATH in case its writable by the caller */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\t}\n\n\t/*\n\t * If !file, that is, if the user did not request this logpath, then\n\t * ignore failures and continue logging to console\n\t */\n\tif (!file && ret != 0) {\n\t\tINFO(\"Ignoring failure to open default logfile.\");\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_arguments_parse",
          "args": [
            "&my_args",
            "argc",
            "argv"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_arguments_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/arguments.c",
          "lines": "182-252",
          "snippet": "extern int lxc_arguments_parse(struct lxc_arguments *args,\n\t\t\t       int argc, char * const argv[])\n{\n\tchar shortopts[256];\n\tint  ret = 0;\n\n\tret = build_shortopts(args->options, shortopts, sizeof(shortopts));\n\tif (ret < 0) {\n\t\tlxc_error(args, \"build_shortopts() failed : %s\",\n\t\t\t  strerror(errno));\n\t\treturn ret;\n\t}\n\n\twhile (1)  {\n\t\tint c, index = 0;\n\n\t\tc = getopt_long(argc, argv, shortopts, args->options, &index);\n\t\tif (c == -1)\n\t\t\tbreak;\n\t\tswitch (c) {\n\t\tcase 'n': \targs->name = optarg; break;\n\t\tcase 'o':\targs->log_file = optarg; break;\n\t\tcase 'l':\targs->log_priority = optarg; break;\n\t\tcase 'q':\targs->quiet = 1; break;\n\t\tcase OPT_RCFILE: args->rcfile = optarg; break;\n\t\tcase 'P':\n\t\t\tremove_trailing_slashes(optarg);\n\t\t\tret = lxc_arguments_lxcpath_add(args, optarg);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase OPT_USAGE: print_usage(args->options, args);\n\t\tcase OPT_VERSION: print_version();\n\t\tcase '?':\tprint_help(args, 1);\n\t\tcase 'h': \tprint_help(args, 0);\n\t\tdefault:\n\t\t\tif (args->parser) {\n\t\t\t\tret = args->parser(args, c, optarg);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Reclaim the remaining command arguments\n\t */\n\targs->argv = &argv[optind];\n\targs->argc = argc - optind;\n\n\t/* If no lxcpaths were given, use default */\n\tif (!args->lxcpath_cnt) {\n\t\tret = lxc_arguments_lxcpath_add(args, lxc_global_config_value(\"lxc.lxcpath\"));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t/* Check the command options */\n\n\tif (!args->name && strcmp(args->progname, \"lxc-autostart\") != 0) {\n\t\tlxc_error(args, \"missing container name, use --name option\");\n\t\treturn -1;\n\t}\n\n\tif (args->checker)\n\t\tret = args->checker(args);\nerror:\n\tif (ret)\n\t\tlxc_error(args, \"could not parse command line\");\n\treturn ret;\n}",
          "includes": [
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"arguments.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <ctype.h>\t\t/* for isprint() */",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"utils.h\"\n#include \"arguments.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <ctype.h>\t\t/* for isprint() */\n#include <string.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nextern int lxc_arguments_parse(struct lxc_arguments *args,\n\t\t\t       int argc, char * const argv[])\n{\n\tchar shortopts[256];\n\tint  ret = 0;\n\n\tret = build_shortopts(args->options, shortopts, sizeof(shortopts));\n\tif (ret < 0) {\n\t\tlxc_error(args, \"build_shortopts() failed : %s\",\n\t\t\t  strerror(errno));\n\t\treturn ret;\n\t}\n\n\twhile (1)  {\n\t\tint c, index = 0;\n\n\t\tc = getopt_long(argc, argv, shortopts, args->options, &index);\n\t\tif (c == -1)\n\t\t\tbreak;\n\t\tswitch (c) {\n\t\tcase 'n': \targs->name = optarg; break;\n\t\tcase 'o':\targs->log_file = optarg; break;\n\t\tcase 'l':\targs->log_priority = optarg; break;\n\t\tcase 'q':\targs->quiet = 1; break;\n\t\tcase OPT_RCFILE: args->rcfile = optarg; break;\n\t\tcase 'P':\n\t\t\tremove_trailing_slashes(optarg);\n\t\t\tret = lxc_arguments_lxcpath_add(args, optarg);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase OPT_USAGE: print_usage(args->options, args);\n\t\tcase OPT_VERSION: print_version();\n\t\tcase '?':\tprint_help(args, 1);\n\t\tcase 'h': \tprint_help(args, 0);\n\t\tdefault:\n\t\t\tif (args->parser) {\n\t\t\t\tret = args->parser(args, c, optarg);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Reclaim the remaining command arguments\n\t */\n\targs->argv = &argv[optind];\n\targs->argc = argc - optind;\n\n\t/* If no lxcpaths were given, use default */\n\tif (!args->lxcpath_cnt) {\n\t\tret = lxc_arguments_lxcpath_add(args, lxc_global_config_value(\"lxc.lxcpath\"));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t/* Check the command options */\n\n\tif (!args->name && strcmp(args->progname, \"lxc-autostart\") != 0) {\n\t\tlxc_error(args, \"missing container name, use --name option\");\n\t\treturn -1;\n\t}\n\n\tif (args->checker)\n\t\tret = args->checker(args);\nerror:\n\tif (ret)\n\t\tlxc_error(args, \"could not parse command line\");\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"list.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <unistd.h>\n#include <string.h>\n\nstruct lxc_list *cmd_groups_list = NULL;\nstatic struct lxc_arguments my_args = {\n\t.progname = \"lxc-autostart\",\n\t.help     = \"\\\n\\n\\\nlxc-autostart managed auto-started containers\\n\\\n\\n\\\nOptions:\\n\\\n  -k, --kill        kill the containers instead of starting them\\n\\\n  -L, --list        list all affected containers and wait delay\\n\\\n  -r, --reboot      reboot the containers instead of starting them\\n\\\n  -s, --shutdown    shutdown the containers instead of starting them\\n\\\n\\n\\\n  -a, --all         list all auto-started containers (ignore groups)\\n\\\n  -A, --ignore-auto ignore lxc.start.auto and select all matching containers\\n\\\n  -g, --groups      list of groups (comma separated) to select\\n\\\n  -t, --timeout=T   wait T seconds before hard-stopping\\n\",\n\t.options  = my_longopts,\n\t.parser   = my_parser,\n\t.checker  = NULL,\n\t.timeout = 60,\n};\n\nint main(int argc, char *argv[])\n{\n\tint count = 0;\n\tint i = 0;\n\tint ret = 0;\n\tstruct lxc_container **containers = NULL;\n\tstruct lxc_list **c_groups_lists = NULL;\n\tstruct lxc_list *cmd_group;\n\n\tif (lxc_arguments_parse(&my_args, argc, argv))\n\t\texit(EXIT_FAILURE);\n\n\tif (lxc_log_init(my_args.name, my_args.log_file, my_args.log_priority,\n\t\t\t my_args.progname, my_args.quiet, my_args.lxcpath[0]))\n\t\texit(EXIT_FAILURE);\n\tlxc_log_options_no_override();\n\n\tcount = list_defined_containers(my_args.lxcpath[0], NULL, &containers);\n\n\tif (count < 0)\n\t\texit(EXIT_FAILURE);\n\n\tif (!my_args.all) {\n\t\t/* Allocate an array for our container group lists */\n\t\tc_groups_lists = calloc( count, sizeof( struct lxc_list * ) );\n\t}\n\n\tqsort(&containers[0], count, sizeof(struct lxc_container *), cmporder);\n\n\tif (cmd_groups_list && my_args.all) {\n\t\tfprintf(stderr, \"Specifying -a (all) with -g (groups) doesn't make sense. All option overrides.\\n\");\n\t\tfflush(stderr);\n\t}\n\n\tif (!cmd_groups_list) {\n\t\t/*\n\t\t * We need a default cmd_groups_list even for the -a\n\t\t * case in order to force a pass through the loop for\n\t\t * the NULL group.  This, someday, could be taken from\n\t\t * a config file somewhere...\n\t\t */\n\t\tcmd_groups_list = accumulate_list( \"\" , \",\", NULL );\n\t}\n\n\tlxc_list_for_each(cmd_group, cmd_groups_list) {\n\n\t\t/*\n\t\t * Prograpmmers Note:\n\t\t * Because we may take several passes through the container list\n\t\t * We'll switch on if the container pointer is NULL and if we process a\n\t\t * container (run it or decide to ignore it) and call lxc_container_put\n\t\t * then we'll NULL it out and not check it again.\n\t\t */\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tstruct lxc_container *c = containers[i];\n\n\t\t\tif (!c)\n\t\t\t\t/* Skip - must have been already processed */\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * We haven't loaded the container groups yet so\n\t\t\t * these next two checks don't need to free them\n\t\t\t * if they fail.  They'll fail on the first pass.\n\t\t\t */\n\t\t\tif (!c->may_control(c)) {\n\t\t\t\t/* We're done with this container */\n\t\t\t\tif ( lxc_container_put(c) > 0 )\n\t\t\t\t\tcontainers[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!my_args.ignore_auto &&\n\t\t\t    get_config_integer(c, \"lxc.start.auto\") != 1) {\n\t\t\t\t/* We're done with this container */\n\t\t\t\tif ( lxc_container_put(c) > 0 )\n\t\t\t\t\tcontainers[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!my_args.all) {\n\t\t\t\t/* Filter by group */\n\t\t\t\tif( ! c_groups_lists[i] ) {\n\t\t\t\t\t/* Now we're loading up a container's groups */\n\t\t\t\t\tc_groups_lists[i] = get_config_list(c, \"lxc.group\");\n\t\t\t\t}\n\n\t\t\t\tret = list_contains_entry(cmd_group->elem, c_groups_lists[i]);\n\n\t\t\t\tif ( ret == 0 ) {\n\t\t\t\t\t/* Not in the target group this pass */\n\t\t\t\t\t/* Leave in the list for subsequent passes */\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* We have a candidate continer to process */\n\t\t\tc->want_daemonize(c, 1);\n\n\t\t\tif (my_args.shutdown) {\n\t\t\t\t/* Shutdown the container */\n\t\t\t\tif (c->is_running(c)) {\n\t\t\t\t\tif (my_args.list) {\n\t\t\t\t\t\tprintf(\"%s\\n\", c->name);\n\t\t\t\t\t\tfflush(stdout);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (!c->shutdown(c, my_args.timeout)) {\n\t\t\t\t\t\t\tif (!c->stop(c)) {\n\t\t\t\t\t\t\t\tfprintf(stderr, \"Error shutting down container: %s\\n\", c->name);\n\t\t\t\t\t\t\t\tfflush(stderr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (my_args.hardstop) {\n\t\t\t\t/* Kill the container */\n\t\t\t\tif (c->is_running(c)) {\n\t\t\t\t\tif (my_args.list) {\n\t\t\t\t\t\tprintf(\"%s\\n\", c->name);\n\t\t\t\t\t\tfflush(stdout);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (!c->stop(c)) {\n\t\t\t\t\t\t\tfprintf(stderr, \"Error killing container: %s\\n\", c->name);\n\t\t\t\t\t\t\tfflush(stderr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (my_args.reboot) {\n\t\t\t\t/* Reboot the container */\n\t\t\t\tif (c->is_running(c)) {\n\t\t\t\t\tif (my_args.list) {\n\t\t\t\t\t\tprintf(\"%s %d\\n\", c->name,\n\t\t\t\t\t\t       get_config_integer(c, \"lxc.start.delay\"));\n\t\t\t\t\t\tfflush(stdout);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (!c->reboot(c)) {\n\t\t\t\t\t\t\tfprintf(stderr, \"Error rebooting container: %s\\n\", c->name);\n\t\t\t\t\t\t\tfflush(stderr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tsleep(get_config_integer(c, \"lxc.start.delay\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* Start the container */\n\t\t\t\tif (!c->is_running(c)) {\n\t\t\t\t\tif (my_args.list) {\n\t\t\t\t\t\tprintf(\"%s %d\\n\", c->name,\n\t\t\t\t\t\t       get_config_integer(c, \"lxc.start.delay\"));\n\t\t\t\t\t\tfflush(stdout);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (!c->start(c, 0, NULL)) {\n\t\t\t\t\t\t\tfprintf(stderr, \"Error starting container: %s\\n\", c->name);\n\t\t\t\t\t\t\tfflush(stderr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tsleep(get_config_integer(c, \"lxc.start.delay\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If we get this far and we haven't hit any skip \"continue\"\n\t\t\t * then we're done with this container...  We can dump any\n\t\t\t * c_groups_list and the container itself.\n\t\t\t */\n\t\t\tif ( lxc_container_put(c) > 0 ) {\n\t\t\t\tcontainers[i] = NULL;\n\t\t\t}\n\t\t\tif ( c_groups_lists ) {\n\t\t\t\ttoss_list(c_groups_lists[i]);\n\t\t\t\tc_groups_lists[i] = NULL;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/* clean up any lingering detritus */\n\tfor (i = 0; i < count; i++) {\n\t\tif ( containers[i] ) {\n\t\t\tlxc_container_put(containers[i]);\n\t\t}\n\t\tif ( c_groups_lists && c_groups_lists[i] ) {\n\t\t\ttoss_list(c_groups_lists[i]);\n\t\t}\n\t}\n\n\tfree(c_groups_lists);\n\ttoss_list( cmd_groups_list );\n\tfree(containers);\n\n\texit(EXIT_SUCCESS);\n}"
  },
  {
    "function_name": "toss_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_autostart.c",
    "lines": "332-345",
    "snippet": "static int toss_list( struct lxc_list *c_groups_list ) {\n\tstruct lxc_list *it, *next;\n\n\tif (c_groups_list) {\n\t\tlxc_list_for_each_safe(it, c_groups_list, next) {\n\t\t\tlxc_list_del(it);\n\t\t\tfree(it->elem);\n\t\t\tfree(it);\n\t\t}\n\t\tfree(c_groups_list);\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"list.h\"",
      "#include \"arguments.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <unistd.h>",
      "#include <string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "c_groups_list"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "free_mnts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "539-554",
          "snippet": "static void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int mnt_table_size = 0;",
            "static struct mnts *mnt_table = NULL;",
            "static void free_mnts(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic unsigned int mnt_table_size = 0;\nstatic struct mnts *mnt_table = NULL;\nstatic void free_mnts(void);\n\nstatic void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_del",
          "args": [
            "it"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "148-156",
          "snippet": "static inline void lxc_list_del(struct lxc_list *list)\n{\n\tstruct lxc_list *next, *prev;\n\n\tnext = list->next;\n\tprev = list->prev;\n\tnext->prev = prev;\n\tprev->next = next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void lxc_list_del(struct lxc_list *list)\n{\n\tstruct lxc_list *next, *prev;\n\n\tnext = list->next;\n\tprev = list->prev;\n\tnext->prev = prev;\n\tprev->next = next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each_safe",
          "args": [
            "it",
            "c_groups_list",
            "next"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"list.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <unistd.h>\n#include <string.h>\n\nstatic int toss_list( struct lxc_list *c_groups_list ) {\n\tstruct lxc_list *it, *next;\n\n\tif (c_groups_list) {\n\t\tlxc_list_for_each_safe(it, c_groups_list, next) {\n\t\t\tlxc_list_del(it);\n\t\t\tfree(it->elem);\n\t\t\tfree(it);\n\t\t}\n\t\tfree(c_groups_list);\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "cmporder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_autostart.c",
    "lines": "319-330",
    "snippet": "static int cmporder(const void *p1, const void *p2) {\n\tstruct lxc_container *c1 = *(struct lxc_container **)p1;\n\tstruct lxc_container *c2 = *(struct lxc_container **)p2;\n\n\tint c1_order = get_config_integer(c1, \"lxc.start.order\");\n\tint c2_order = get_config_integer(c2, \"lxc.start.order\");\n\n\tif (c1_order == c2_order)\n\t\treturn strcmp(c1->name, c2->name);\n\telse\n\t\treturn (c1_order - c2_order);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"list.h\"",
      "#include \"arguments.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <unistd.h>",
      "#include <string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "c1->name",
            "c2->name"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_config_integer",
          "args": [
            "c2",
            "\"lxc.start.order\""
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "get_config_integer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_autostart.c",
          "lines": "293-317",
          "snippet": "static int get_config_integer(struct lxc_container *c, char *key) {\n\tint len = 0;\n\tint ret = 0;\n\tchar* value = NULL;\n\n\tlen = c->get_config_item(c, key, NULL, 0);\n\tif (len < 0)\n\t\treturn 0;\n\n\tvalue = (char*) malloc(sizeof(char)*len + 1);\n\tif (value == NULL)\n\t\treturn 0;\n\n\tif (c->get_config_item(c, key, value, len + 1) != len) {\n\t\tfree(value);\n\t\treturn 0;\n\t}\n\n\tif (lxc_safe_int(value, &ret) < 0)\n\t\tDEBUG(\"Could not parse config item.\");\n\n\tfree(value);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"list.h\"",
            "#include \"arguments.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <unistd.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"list.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <unistd.h>\n#include <string.h>\n\nstatic int get_config_integer(struct lxc_container *c, char *key) {\n\tint len = 0;\n\tint ret = 0;\n\tchar* value = NULL;\n\n\tlen = c->get_config_item(c, key, NULL, 0);\n\tif (len < 0)\n\t\treturn 0;\n\n\tvalue = (char*) malloc(sizeof(char)*len + 1);\n\tif (value == NULL)\n\t\treturn 0;\n\n\tif (c->get_config_item(c, key, value, len + 1) != len) {\n\t\tfree(value);\n\t\treturn 0;\n\t}\n\n\tif (lxc_safe_int(value, &ret) < 0)\n\t\tDEBUG(\"Could not parse config item.\");\n\n\tfree(value);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"list.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <unistd.h>\n#include <string.h>\n\nstatic int cmporder(const void *p1, const void *p2) {\n\tstruct lxc_container *c1 = *(struct lxc_container **)p1;\n\tstruct lxc_container *c2 = *(struct lxc_container **)p2;\n\n\tint c1_order = get_config_integer(c1, \"lxc.start.order\");\n\tint c2_order = get_config_integer(c2, \"lxc.start.order\");\n\n\tif (c1_order == c2_order)\n\t\treturn strcmp(c1->name, c2->name);\n\telse\n\t\treturn (c1_order - c2_order);\n}"
  },
  {
    "function_name": "get_config_integer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_autostart.c",
    "lines": "293-317",
    "snippet": "static int get_config_integer(struct lxc_container *c, char *key) {\n\tint len = 0;\n\tint ret = 0;\n\tchar* value = NULL;\n\n\tlen = c->get_config_item(c, key, NULL, 0);\n\tif (len < 0)\n\t\treturn 0;\n\n\tvalue = (char*) malloc(sizeof(char)*len + 1);\n\tif (value == NULL)\n\t\treturn 0;\n\n\tif (c->get_config_item(c, key, value, len + 1) != len) {\n\t\tfree(value);\n\t\treturn 0;\n\t}\n\n\tif (lxc_safe_int(value, &ret) < 0)\n\t\tDEBUG(\"Could not parse config item.\");\n\n\tfree(value);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"list.h\"",
      "#include \"arguments.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <unistd.h>",
      "#include <string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "value"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "free_mnts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "539-554",
          "snippet": "static void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int mnt_table_size = 0;",
            "static struct mnts *mnt_table = NULL;",
            "static void free_mnts(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic unsigned int mnt_table_size = 0;\nstatic struct mnts *mnt_table = NULL;\nstatic void free_mnts(void);\n\nstatic void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Could not parse config item.\""
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_safe_int",
          "args": [
            "value",
            "&ret"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_safe_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "2005-2023",
          "snippet": "int lxc_safe_int(const char *numstr, int *converted)\n{\n\tchar *err = NULL;\n\tsigned long int sli;\n\n\terrno = 0;\n\tsli = strtol(numstr, &err, 0);\n\tif (errno > 0)\n\t\treturn -errno;\n\n\tif (!err || err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\n\tif (sli > INT_MAX)\n\t\treturn -ERANGE;\n\n\t*converted = (int)sli;\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_safe_int(const char *numstr, int *converted)\n{\n\tchar *err = NULL;\n\tsigned long int sli;\n\n\terrno = 0;\n\tsli = strtol(numstr, &err, 0);\n\tif (errno > 0)\n\t\treturn -errno;\n\n\tif (!err || err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\n\tif (sli > INT_MAX)\n\t\treturn -ERANGE;\n\n\t*converted = (int)sli;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->get_config_item",
          "args": [
            "c",
            "key",
            "value",
            "len + 1"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(char)*len + 1"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->get_config_item",
          "args": [
            "c",
            "key",
            "NULL",
            "0"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"list.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <unistd.h>\n#include <string.h>\n\nstatic int get_config_integer(struct lxc_container *c, char *key) {\n\tint len = 0;\n\tint ret = 0;\n\tchar* value = NULL;\n\n\tlen = c->get_config_item(c, key, NULL, 0);\n\tif (len < 0)\n\t\treturn 0;\n\n\tvalue = (char*) malloc(sizeof(char)*len + 1);\n\tif (value == NULL)\n\t\treturn 0;\n\n\tif (c->get_config_item(c, key, value, len + 1) != len) {\n\t\tfree(value);\n\t\treturn 0;\n\t}\n\n\tif (lxc_safe_int(value, &ret) < 0)\n\t\tDEBUG(\"Could not parse config item.\");\n\n\tfree(value);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "get_config_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_autostart.c",
    "lines": "264-291",
    "snippet": "static struct lxc_list *get_config_list(struct lxc_container *c, char *key) {\n\tint len = 0;\n\tchar* value = NULL;\n\tstruct lxc_list *config_list = NULL;\n\n\tlen = c->get_config_item(c, key, NULL, 0);\n\tif (len < 0)\n\t\treturn NULL;\n\n\tvalue = (char*) malloc(sizeof(char)*len + 1);\n\tif (value == NULL)\n\t\treturn NULL;\n\n\tif (c->get_config_item(c, key, value, len + 1) != len) {\n\t\tfree(value);\n\t\treturn NULL;\n\t}\n\n\tif (strlen(value) == 0) {\n\t\tfree(value);\n\t\treturn NULL;\n\t}\n\n\tconfig_list = get_list(value, \"\\n\");\n\tfree(value);\n\n\treturn config_list;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"list.h\"",
      "#include \"arguments.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <unistd.h>",
      "#include <string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "value"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "free_mnts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "539-554",
          "snippet": "static void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int mnt_table_size = 0;",
            "static struct mnts *mnt_table = NULL;",
            "static void free_mnts(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic unsigned int mnt_table_size = 0;\nstatic struct mnts *mnt_table = NULL;\nstatic void free_mnts(void);\n\nstatic void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_list",
          "args": [
            "value",
            "\"\\n\""
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "get_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_autostart.c",
          "lines": "223-262",
          "snippet": "static struct lxc_list *get_list(char *input, char *delimiter) {\n\tchar *workstr = NULL;\n\tchar *workptr = NULL;\n\tchar *sptr = NULL;\n\tchar *token = NULL;\n\tstruct lxc_list *worklist;\n\tstruct lxc_list *workstr_list;\n\n\tworkstr_list = malloc(sizeof(*workstr_list));\n\tlxc_list_init(workstr_list);\n\n\tworkstr = strdup(input);\n\tif (!workstr) {\n\t\tfree(workstr_list);\n\t\treturn NULL;\n\t}\n\n\tfor (workptr = workstr;;workptr = NULL) {\n\t\ttoken = strtok_r(workptr, delimiter, &sptr);\n\t\tif (!token) {\n\t\t\tbreak;\n\t\t}\n\n\t\tworklist = malloc(sizeof(*worklist));\n\t\tif (!worklist)\n\t\t\tbreak;\n\n\t\tworklist->elem = strdup(token);\n\t\tif (!worklist->elem) {\n\t\t\tfree(worklist);\n\t\t\tbreak;\n\t\t}\n\n\t\tlxc_list_add_tail(workstr_list, worklist);\n\t}\n\n\tfree(workstr);\n\n\treturn workstr_list;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"list.h\"",
            "#include \"arguments.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <unistd.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"list.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <unistd.h>\n#include <string.h>\n\nstatic struct lxc_list *get_list(char *input, char *delimiter) {\n\tchar *workstr = NULL;\n\tchar *workptr = NULL;\n\tchar *sptr = NULL;\n\tchar *token = NULL;\n\tstruct lxc_list *worklist;\n\tstruct lxc_list *workstr_list;\n\n\tworkstr_list = malloc(sizeof(*workstr_list));\n\tlxc_list_init(workstr_list);\n\n\tworkstr = strdup(input);\n\tif (!workstr) {\n\t\tfree(workstr_list);\n\t\treturn NULL;\n\t}\n\n\tfor (workptr = workstr;;workptr = NULL) {\n\t\ttoken = strtok_r(workptr, delimiter, &sptr);\n\t\tif (!token) {\n\t\t\tbreak;\n\t\t}\n\n\t\tworklist = malloc(sizeof(*worklist));\n\t\tif (!worklist)\n\t\t\tbreak;\n\n\t\tworklist->elem = strdup(token);\n\t\tif (!worklist->elem) {\n\t\t\tfree(worklist);\n\t\t\tbreak;\n\t\t}\n\n\t\tlxc_list_add_tail(workstr_list, worklist);\n\t}\n\n\tfree(workstr);\n\n\treturn workstr_list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "value"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->get_config_item",
          "args": [
            "c",
            "key",
            "value",
            "len + 1"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(char)*len + 1"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->get_config_item",
          "args": [
            "c",
            "key",
            "NULL",
            "0"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"list.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <unistd.h>\n#include <string.h>\n\nstatic struct lxc_list *get_config_list(struct lxc_container *c, char *key) {\n\tint len = 0;\n\tchar* value = NULL;\n\tstruct lxc_list *config_list = NULL;\n\n\tlen = c->get_config_item(c, key, NULL, 0);\n\tif (len < 0)\n\t\treturn NULL;\n\n\tvalue = (char*) malloc(sizeof(char)*len + 1);\n\tif (value == NULL)\n\t\treturn NULL;\n\n\tif (c->get_config_item(c, key, value, len + 1) != len) {\n\t\tfree(value);\n\t\treturn NULL;\n\t}\n\n\tif (strlen(value) == 0) {\n\t\tfree(value);\n\t\treturn NULL;\n\t}\n\n\tconfig_list = get_list(value, \"\\n\");\n\tfree(value);\n\n\treturn config_list;\n}"
  },
  {
    "function_name": "get_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_autostart.c",
    "lines": "223-262",
    "snippet": "static struct lxc_list *get_list(char *input, char *delimiter) {\n\tchar *workstr = NULL;\n\tchar *workptr = NULL;\n\tchar *sptr = NULL;\n\tchar *token = NULL;\n\tstruct lxc_list *worklist;\n\tstruct lxc_list *workstr_list;\n\n\tworkstr_list = malloc(sizeof(*workstr_list));\n\tlxc_list_init(workstr_list);\n\n\tworkstr = strdup(input);\n\tif (!workstr) {\n\t\tfree(workstr_list);\n\t\treturn NULL;\n\t}\n\n\tfor (workptr = workstr;;workptr = NULL) {\n\t\ttoken = strtok_r(workptr, delimiter, &sptr);\n\t\tif (!token) {\n\t\t\tbreak;\n\t\t}\n\n\t\tworklist = malloc(sizeof(*worklist));\n\t\tif (!worklist)\n\t\t\tbreak;\n\n\t\tworklist->elem = strdup(token);\n\t\tif (!worklist->elem) {\n\t\t\tfree(worklist);\n\t\t\tbreak;\n\t\t}\n\n\t\tlxc_list_add_tail(workstr_list, worklist);\n\t}\n\n\tfree(workstr);\n\n\treturn workstr_list;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"list.h\"",
      "#include \"arguments.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <unistd.h>",
      "#include <string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "workstr"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "free_mnts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "539-554",
          "snippet": "static void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int mnt_table_size = 0;",
            "static struct mnts *mnt_table = NULL;",
            "static void free_mnts(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic unsigned int mnt_table_size = 0;\nstatic struct mnts *mnt_table = NULL;\nstatic void free_mnts(void);\n\nstatic void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_add_tail",
          "args": [
            "workstr_list",
            "worklist"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_add_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "133-137",
          "snippet": "static inline void lxc_list_add_tail(struct lxc_list *head,\n\t\t\t\t     struct lxc_list *list)\n{\n\t__lxc_list_add(list, head->prev, head);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void lxc_list_add_tail(struct lxc_list *head,\n\t\t\t\t     struct lxc_list *list)\n{\n\t__lxc_list_add(list, head->prev, head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "token"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*worklist)"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "workptr",
            "delimiter",
            "&sptr"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "input"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_init",
          "args": [
            "workstr_list"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "68-72",
          "snippet": "static inline void lxc_list_init(struct lxc_list *list)\n{\n\tlist->elem = NULL;\n\tlist->next = list->prev = list;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void lxc_list_init(struct lxc_list *list)\n{\n\tlist->elem = NULL;\n\tlist->next = list->prev = list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*workstr_list)"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"list.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <unistd.h>\n#include <string.h>\n\nstatic struct lxc_list *get_list(char *input, char *delimiter) {\n\tchar *workstr = NULL;\n\tchar *workptr = NULL;\n\tchar *sptr = NULL;\n\tchar *token = NULL;\n\tstruct lxc_list *worklist;\n\tstruct lxc_list *workstr_list;\n\n\tworkstr_list = malloc(sizeof(*workstr_list));\n\tlxc_list_init(workstr_list);\n\n\tworkstr = strdup(input);\n\tif (!workstr) {\n\t\tfree(workstr_list);\n\t\treturn NULL;\n\t}\n\n\tfor (workptr = workstr;;workptr = NULL) {\n\t\ttoken = strtok_r(workptr, delimiter, &sptr);\n\t\tif (!token) {\n\t\t\tbreak;\n\t\t}\n\n\t\tworklist = malloc(sizeof(*worklist));\n\t\tif (!worklist)\n\t\t\tbreak;\n\n\t\tworklist->elem = strdup(token);\n\t\tif (!worklist->elem) {\n\t\t\tfree(worklist);\n\t\t\tbreak;\n\t\t}\n\n\t\tlxc_list_add_tail(workstr_list, worklist);\n\t}\n\n\tfree(workstr);\n\n\treturn workstr_list;\n}"
  },
  {
    "function_name": "accumulate_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_autostart.c",
    "lines": "156-221",
    "snippet": "static struct lxc_list *accumulate_list(char *input, char *delimiter, struct lxc_list *str_list) {\n\tchar *workstr = NULL;\n\tchar *workptr = NULL;\n\tchar *next_ptr = NULL;\n\tstruct lxc_list *worklist;\n\tstruct lxc_list *workstr_list;\n\n\tworkstr = strdup(input);\n\tif (!workstr) {\n\t\treturn NULL;\n\t}\n\n\tworkstr_list = str_list;\n\tif ( ! workstr_list ) {\n\t\tworkstr_list = malloc(sizeof(*workstr_list));\n\t\tlxc_list_init(workstr_list);\n\t}\n\n\tfor (workptr = workstr; workptr; workptr = next_ptr) {\n\t\t/*\n\t\t * We can't use strtok_r here because it collapses\n\t\t * multiple delimiters into 1 making empty fields\n\t\t * impossible...\n\t\t */\n\t\t/* token = strtok_r(workptr, delimiter, &sptr); */\n\t\tnext_ptr = strchr( workptr, *delimiter );\n\n\t\tif( next_ptr ) {\n\t\t\t*next_ptr++ = '\\0';\n\t\t}\n\n\t\t/*\n\t\t * At this point, we'd like to check to see if this\n\t\t * group is already contained in the list and ignore\n\t\t * it if it is...  This also helps us with any\n\t\t * corner cases where a string begins or ends with a\n\t\t * delimiter.\n\t\t */\n\n\t\tif ( list_contains_entry( workptr, workstr_list ) ) {\n\t\t\tif ( *workptr ) {\n\t\t\t\tfprintf(stderr, \"Duplicate group \\\"%s\\\" in list - ignoring\\n\", workptr );\n\t\t\t\tfflush(stderr);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Duplicate NULL group in list - ignoring\\n\" );\n\t\t\t\tfflush(stderr);\n\t\t\t}\n\t\t} else {\n\t\t\tworklist = malloc(sizeof(*worklist));\n\t\t\tif (!worklist)\n\t\t\t\tbreak;\n\n\t\t\tworklist->elem = strdup(workptr);\n\t\t\tif (!worklist->elem) {\n\t\t\t\tfree(worklist);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlxc_list_add_tail(workstr_list, worklist);\n\t\t}\n\t}\n\n\tfree(workstr);\n\n\treturn workstr_list;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"list.h\"",
      "#include \"arguments.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <unistd.h>",
      "#include <string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lxc_list *accumulate_list(char *input, char *delimiter, struct lxc_list *str_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "workstr"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "free_mnts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "539-554",
          "snippet": "static void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int mnt_table_size = 0;",
            "static struct mnts *mnt_table = NULL;",
            "static void free_mnts(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic unsigned int mnt_table_size = 0;\nstatic struct mnts *mnt_table = NULL;\nstatic void free_mnts(void);\n\nstatic void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_add_tail",
          "args": [
            "workstr_list",
            "worklist"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_add_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "133-137",
          "snippet": "static inline void lxc_list_add_tail(struct lxc_list *head,\n\t\t\t\t     struct lxc_list *list)\n{\n\t__lxc_list_add(list, head->prev, head);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void lxc_list_add_tail(struct lxc_list *head,\n\t\t\t\t     struct lxc_list *list)\n{\n\t__lxc_list_add(list, head->prev, head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "workptr"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*worklist)"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stderr"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Duplicate NULL group in list - ignoring\\n\""
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stderr"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Duplicate group \\\"%s\\\" in list - ignoring\\n\"",
            "workptr"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_contains_entry",
          "args": [
            "workptr",
            "workstr_list"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "list_contains_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_autostart.c",
          "lines": "103-124",
          "snippet": "int list_contains_entry( char *str_ptr, struct lxc_list *p1 ) {\n\tstruct lxc_list *it1;\n\n\t/*\n\t * If the entry is NULL or the empty string and the list\n\t * is NULL, we have a match\n\t */\n\tif (! p1 && ! str_ptr)\n\t\treturn 1;\n\tif (! p1 && ! *str_ptr)\n\t\treturn 1;\n\n\tif (!p1)\n\t\treturn 0;\n\n\tlxc_list_for_each(it1, p1) {\n\t\tif (strcmp(it1->elem, str_ptr) == 0)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"list.h\"",
            "#include \"arguments.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <unistd.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"list.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <unistd.h>\n#include <string.h>\n\nint list_contains_entry( char *str_ptr, struct lxc_list *p1 ) {\n\tstruct lxc_list *it1;\n\n\t/*\n\t * If the entry is NULL or the empty string and the list\n\t * is NULL, we have a match\n\t */\n\tif (! p1 && ! str_ptr)\n\t\treturn 1;\n\tif (! p1 && ! *str_ptr)\n\t\treturn 1;\n\n\tif (!p1)\n\t\treturn 0;\n\n\tlxc_list_for_each(it1, p1) {\n\t\tif (strcmp(it1->elem, str_ptr) == 0)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "workptr",
            "*delimiter"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_init",
          "args": [
            "workstr_list"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "68-72",
          "snippet": "static inline void lxc_list_init(struct lxc_list *list)\n{\n\tlist->elem = NULL;\n\tlist->next = list->prev = list;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void lxc_list_init(struct lxc_list *list)\n{\n\tlist->elem = NULL;\n\tlist->next = list->prev = list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*workstr_list)"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "input"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"list.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <unistd.h>\n#include <string.h>\n\nstatic struct lxc_list *accumulate_list(char *input, char *delimiter, struct lxc_list *str_list);\n\nstatic struct lxc_list *accumulate_list(char *input, char *delimiter, struct lxc_list *str_list) {\n\tchar *workstr = NULL;\n\tchar *workptr = NULL;\n\tchar *next_ptr = NULL;\n\tstruct lxc_list *worklist;\n\tstruct lxc_list *workstr_list;\n\n\tworkstr = strdup(input);\n\tif (!workstr) {\n\t\treturn NULL;\n\t}\n\n\tworkstr_list = str_list;\n\tif ( ! workstr_list ) {\n\t\tworkstr_list = malloc(sizeof(*workstr_list));\n\t\tlxc_list_init(workstr_list);\n\t}\n\n\tfor (workptr = workstr; workptr; workptr = next_ptr) {\n\t\t/*\n\t\t * We can't use strtok_r here because it collapses\n\t\t * multiple delimiters into 1 making empty fields\n\t\t * impossible...\n\t\t */\n\t\t/* token = strtok_r(workptr, delimiter, &sptr); */\n\t\tnext_ptr = strchr( workptr, *delimiter );\n\n\t\tif( next_ptr ) {\n\t\t\t*next_ptr++ = '\\0';\n\t\t}\n\n\t\t/*\n\t\t * At this point, we'd like to check to see if this\n\t\t * group is already contained in the list and ignore\n\t\t * it if it is...  This also helps us with any\n\t\t * corner cases where a string begins or ends with a\n\t\t * delimiter.\n\t\t */\n\n\t\tif ( list_contains_entry( workptr, workstr_list ) ) {\n\t\t\tif ( *workptr ) {\n\t\t\t\tfprintf(stderr, \"Duplicate group \\\"%s\\\" in list - ignoring\\n\", workptr );\n\t\t\t\tfflush(stderr);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Duplicate NULL group in list - ignoring\\n\" );\n\t\t\t\tfflush(stderr);\n\t\t\t}\n\t\t} else {\n\t\t\tworklist = malloc(sizeof(*worklist));\n\t\t\tif (!worklist)\n\t\t\t\tbreak;\n\n\t\t\tworklist->elem = strdup(workptr);\n\t\t\tif (!worklist->elem) {\n\t\t\t\tfree(worklist);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlxc_list_add_tail(workstr_list, worklist);\n\t\t}\n\t}\n\n\tfree(workstr);\n\n\treturn workstr_list;\n}"
  },
  {
    "function_name": "lists_contain_common_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_autostart.c",
    "lines": "126-147",
    "snippet": "int lists_contain_common_entry(struct lxc_list *p1, struct lxc_list *p2) {\n\tstruct lxc_list *it1;\n\tstruct lxc_list *it2;\n\n\tif (!p1 && !p2)\n\t\treturn 1;\n\n\tif (!p1)\n\t\treturn 0;\n\n\tif (!p2)\n\t\treturn 0;\n\n\tlxc_list_for_each(it1, p1) {\n\t\tlxc_list_for_each(it2, p2) {\n\t\t\tif (strcmp(it1->elem, it2->elem) == 0)\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"list.h\"",
      "#include \"arguments.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <unistd.h>",
      "#include <string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "it1->elem",
            "it2->elem"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "it2",
            "p2"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "it1",
            "p1"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"list.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <unistd.h>\n#include <string.h>\n\nint lists_contain_common_entry(struct lxc_list *p1, struct lxc_list *p2) {\n\tstruct lxc_list *it1;\n\tstruct lxc_list *it2;\n\n\tif (!p1 && !p2)\n\t\treturn 1;\n\n\tif (!p1)\n\t\treturn 0;\n\n\tif (!p2)\n\t\treturn 0;\n\n\tlxc_list_for_each(it1, p1) {\n\t\tlxc_list_for_each(it2, p2) {\n\t\t\tif (strcmp(it1->elem, it2->elem) == 0)\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "list_contains_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_autostart.c",
    "lines": "103-124",
    "snippet": "int list_contains_entry( char *str_ptr, struct lxc_list *p1 ) {\n\tstruct lxc_list *it1;\n\n\t/*\n\t * If the entry is NULL or the empty string and the list\n\t * is NULL, we have a match\n\t */\n\tif (! p1 && ! str_ptr)\n\t\treturn 1;\n\tif (! p1 && ! *str_ptr)\n\t\treturn 1;\n\n\tif (!p1)\n\t\treturn 0;\n\n\tlxc_list_for_each(it1, p1) {\n\t\tif (strcmp(it1->elem, str_ptr) == 0)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"list.h\"",
      "#include \"arguments.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <unistd.h>",
      "#include <string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "it1->elem",
            "str_ptr"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "it1",
            "p1"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"list.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <unistd.h>\n#include <string.h>\n\nint list_contains_entry( char *str_ptr, struct lxc_list *p1 ) {\n\tstruct lxc_list *it1;\n\n\t/*\n\t * If the entry is NULL or the empty string and the list\n\t * is NULL, we have a match\n\t */\n\tif (! p1 && ! str_ptr)\n\t\treturn 1;\n\tif (! p1 && ! *str_ptr)\n\t\treturn 1;\n\n\tif (!p1)\n\t\treturn 0;\n\n\tlxc_list_for_each(it1, p1) {\n\t\tif (strcmp(it1->elem, str_ptr) == 0)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "my_parser",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_autostart.c",
    "lines": "36-66",
    "snippet": "static int my_parser(struct lxc_arguments* args, int c, char* arg)\n{\n\tswitch (c) {\n\tcase 'k':\n\t\targs->hardstop = 1;\n\t\tbreak;\n\tcase 'L':\n\t\targs->list = 1;\n\t\tbreak;\n\tcase 'r':\n\t\targs->reboot = 1;\n\t\tbreak;\n\tcase 's':\n\t\targs->shutdown = 1;\n\t\tbreak;\n\tcase 'a':\n\t\targs->all = 1;\n\t\tbreak;\n\tcase 'A':\n\t\targs->ignore_auto = 1;\n\t\tbreak;\n\tcase 'g':\n\t\tcmd_groups_list = accumulate_list(arg, \",\", cmd_groups_list);\n\t\tbreak;\n\tcase 't':\n\t\tif (lxc_safe_long(arg, &args->timeout) < 0)\n\t\t\treturn -1;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"list.h\"",
      "#include \"arguments.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <unistd.h>",
      "#include <string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct lxc_list *cmd_groups_list = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_safe_long",
          "args": [
            "arg",
            "&args->timeout"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_safe_long",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "2025-2043",
          "snippet": "int lxc_safe_long(const char *numstr, long int *converted)\n{\n\tchar *err = NULL;\n\tsigned long int sli;\n\n\terrno = 0;\n\tsli = strtol(numstr, &err, 0);\n\tif (errno > 0)\n\t\treturn -errno;\n\n\tif (!err || err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\n\tif (sli > LONG_MAX)\n\t\treturn -ERANGE;\n\n\t*converted = sli;\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_safe_long(const char *numstr, long int *converted)\n{\n\tchar *err = NULL;\n\tsigned long int sli;\n\n\terrno = 0;\n\tsli = strtol(numstr, &err, 0);\n\tif (errno > 0)\n\t\treturn -errno;\n\n\tif (!err || err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\n\tif (sli > LONG_MAX)\n\t\treturn -ERANGE;\n\n\t*converted = sli;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "accumulate_list",
          "args": [
            "arg",
            "\",\"",
            "cmd_groups_list"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "accumulate_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_autostart.c",
          "lines": "156-221",
          "snippet": "static struct lxc_list *accumulate_list(char *input, char *delimiter, struct lxc_list *str_list) {\n\tchar *workstr = NULL;\n\tchar *workptr = NULL;\n\tchar *next_ptr = NULL;\n\tstruct lxc_list *worklist;\n\tstruct lxc_list *workstr_list;\n\n\tworkstr = strdup(input);\n\tif (!workstr) {\n\t\treturn NULL;\n\t}\n\n\tworkstr_list = str_list;\n\tif ( ! workstr_list ) {\n\t\tworkstr_list = malloc(sizeof(*workstr_list));\n\t\tlxc_list_init(workstr_list);\n\t}\n\n\tfor (workptr = workstr; workptr; workptr = next_ptr) {\n\t\t/*\n\t\t * We can't use strtok_r here because it collapses\n\t\t * multiple delimiters into 1 making empty fields\n\t\t * impossible...\n\t\t */\n\t\t/* token = strtok_r(workptr, delimiter, &sptr); */\n\t\tnext_ptr = strchr( workptr, *delimiter );\n\n\t\tif( next_ptr ) {\n\t\t\t*next_ptr++ = '\\0';\n\t\t}\n\n\t\t/*\n\t\t * At this point, we'd like to check to see if this\n\t\t * group is already contained in the list and ignore\n\t\t * it if it is...  This also helps us with any\n\t\t * corner cases where a string begins or ends with a\n\t\t * delimiter.\n\t\t */\n\n\t\tif ( list_contains_entry( workptr, workstr_list ) ) {\n\t\t\tif ( *workptr ) {\n\t\t\t\tfprintf(stderr, \"Duplicate group \\\"%s\\\" in list - ignoring\\n\", workptr );\n\t\t\t\tfflush(stderr);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Duplicate NULL group in list - ignoring\\n\" );\n\t\t\t\tfflush(stderr);\n\t\t\t}\n\t\t} else {\n\t\t\tworklist = malloc(sizeof(*worklist));\n\t\t\tif (!worklist)\n\t\t\t\tbreak;\n\n\t\t\tworklist->elem = strdup(workptr);\n\t\t\tif (!worklist->elem) {\n\t\t\t\tfree(worklist);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlxc_list_add_tail(workstr_list, worklist);\n\t\t}\n\t}\n\n\tfree(workstr);\n\n\treturn workstr_list;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"list.h\"",
            "#include \"arguments.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <unistd.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lxc_list *accumulate_list(char *input, char *delimiter, struct lxc_list *str_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"list.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <unistd.h>\n#include <string.h>\n\nstatic struct lxc_list *accumulate_list(char *input, char *delimiter, struct lxc_list *str_list);\n\nstatic struct lxc_list *accumulate_list(char *input, char *delimiter, struct lxc_list *str_list) {\n\tchar *workstr = NULL;\n\tchar *workptr = NULL;\n\tchar *next_ptr = NULL;\n\tstruct lxc_list *worklist;\n\tstruct lxc_list *workstr_list;\n\n\tworkstr = strdup(input);\n\tif (!workstr) {\n\t\treturn NULL;\n\t}\n\n\tworkstr_list = str_list;\n\tif ( ! workstr_list ) {\n\t\tworkstr_list = malloc(sizeof(*workstr_list));\n\t\tlxc_list_init(workstr_list);\n\t}\n\n\tfor (workptr = workstr; workptr; workptr = next_ptr) {\n\t\t/*\n\t\t * We can't use strtok_r here because it collapses\n\t\t * multiple delimiters into 1 making empty fields\n\t\t * impossible...\n\t\t */\n\t\t/* token = strtok_r(workptr, delimiter, &sptr); */\n\t\tnext_ptr = strchr( workptr, *delimiter );\n\n\t\tif( next_ptr ) {\n\t\t\t*next_ptr++ = '\\0';\n\t\t}\n\n\t\t/*\n\t\t * At this point, we'd like to check to see if this\n\t\t * group is already contained in the list and ignore\n\t\t * it if it is...  This also helps us with any\n\t\t * corner cases where a string begins or ends with a\n\t\t * delimiter.\n\t\t */\n\n\t\tif ( list_contains_entry( workptr, workstr_list ) ) {\n\t\t\tif ( *workptr ) {\n\t\t\t\tfprintf(stderr, \"Duplicate group \\\"%s\\\" in list - ignoring\\n\", workptr );\n\t\t\t\tfflush(stderr);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Duplicate NULL group in list - ignoring\\n\" );\n\t\t\t\tfflush(stderr);\n\t\t\t}\n\t\t} else {\n\t\t\tworklist = malloc(sizeof(*worklist));\n\t\t\tif (!worklist)\n\t\t\t\tbreak;\n\n\t\t\tworklist->elem = strdup(workptr);\n\t\t\tif (!worklist->elem) {\n\t\t\t\tfree(worklist);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlxc_list_add_tail(workstr_list, worklist);\n\t\t}\n\t}\n\n\tfree(workstr);\n\n\treturn workstr_list;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"list.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <unistd.h>\n#include <string.h>\n\nstruct lxc_list *cmd_groups_list = NULL;\n\nstatic int my_parser(struct lxc_arguments* args, int c, char* arg)\n{\n\tswitch (c) {\n\tcase 'k':\n\t\targs->hardstop = 1;\n\t\tbreak;\n\tcase 'L':\n\t\targs->list = 1;\n\t\tbreak;\n\tcase 'r':\n\t\targs->reboot = 1;\n\t\tbreak;\n\tcase 's':\n\t\targs->shutdown = 1;\n\t\tbreak;\n\tcase 'a':\n\t\targs->all = 1;\n\t\tbreak;\n\tcase 'A':\n\t\targs->ignore_auto = 1;\n\t\tbreak;\n\tcase 'g':\n\t\tcmd_groups_list = accumulate_list(arg, \",\", cmd_groups_list);\n\t\tbreak;\n\tcase 't':\n\t\tif (lxc_safe_long(arg, &args->timeout) < 0)\n\t\t\treturn -1;\n\t\tbreak;\n\t}\n\treturn 0;\n}"
  }
]