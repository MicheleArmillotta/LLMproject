[
  {
    "function_name": "sort_cgroup_settings",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "4634-4672",
    "snippet": "struct lxc_list *sort_cgroup_settings(struct lxc_list* cgroup_settings)\n{\n\tstruct lxc_list *result;\n\tstruct lxc_list *memsw_limit = NULL;\n\tstruct lxc_list *it = NULL;\n\tstruct lxc_cgroup *cg = NULL;\n\tstruct lxc_list *item = NULL;\n\n\tresult = malloc(sizeof(*result));\n\tif (!result) {\n\t\tERROR(\"failed to allocate memory to sort cgroup settings\");\n\t\treturn NULL;\n\t}\n\tlxc_list_init(result);\n\n\t/*Iterate over the cgroup settings and copy them to the output list*/\n\tlxc_list_for_each(it, cgroup_settings) {\n\t\titem = malloc(sizeof(*item));\n\t\tif (!item) {\n\t\t\tERROR(\"failed to allocate memory to sort cgroup settings\");\n\t\t\tfree_cgroup_settings(result);\n\t\t\treturn NULL;\n\t\t}\n\t\titem->elem = it->elem;\n\t\tcg = it->elem;\n\t\tif (strcmp(cg->subsystem, \"memory.memsw.limit_in_bytes\") == 0) {\n\t\t\t/* Store the memsw_limit location */\n\t\t\tmemsw_limit = item;\n\t\t} else if (strcmp(cg->subsystem, \"memory.limit_in_bytes\") == 0 && memsw_limit != NULL) {\n\t\t\t/* lxc.cgroup.memory.memsw.limit_in_bytes is found before\n\t\t\t * lxc.cgroup.memory.limit_in_bytes, swap these two items */\n\t\t\titem->elem = memsw_limit->elem;\n\t\t\tmemsw_limit->elem = it->elem;\n\t\t}\n\t\tlxc_list_add_tail(result, item);\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_list_add_tail",
          "args": [
            "result",
            "item"
          ],
          "line": 4668
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_add_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "133-137",
          "snippet": "static inline void lxc_list_add_tail(struct lxc_list *head,\n\t\t\t\t     struct lxc_list *list)\n{\n\t__lxc_list_add(list, head->prev, head);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void lxc_list_add_tail(struct lxc_list *head,\n\t\t\t\t     struct lxc_list *list)\n{\n\t__lxc_list_add(list, head->prev, head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cg->subsystem",
            "\"memory.limit_in_bytes\""
          ],
          "line": 4662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cg->subsystem",
            "\"memory.memsw.limit_in_bytes\""
          ],
          "line": 4659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cgroup_settings",
          "args": [
            "result"
          ],
          "line": 4654
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4619-4628",
          "snippet": "static void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to allocate memory to sort cgroup settings\""
          ],
          "line": 4653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*item)"
          ],
          "line": 4651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "it",
            "cgroup_settings"
          ],
          "line": 4650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_init",
          "args": [
            "result"
          ],
          "line": 4647
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "68-72",
          "snippet": "static inline void lxc_list_init(struct lxc_list *list)\n{\n\tlist->elem = NULL;\n\tlist->next = list->prev = list;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void lxc_list_init(struct lxc_list *list)\n{\n\tlist->elem = NULL;\n\tlist->next = list->prev = list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to allocate memory to sort cgroup settings\""
          ],
          "line": 4644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*result)"
          ],
          "line": 4642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstruct lxc_list *sort_cgroup_settings(struct lxc_list* cgroup_settings)\n{\n\tstruct lxc_list *result;\n\tstruct lxc_list *memsw_limit = NULL;\n\tstruct lxc_list *it = NULL;\n\tstruct lxc_cgroup *cg = NULL;\n\tstruct lxc_list *item = NULL;\n\n\tresult = malloc(sizeof(*result));\n\tif (!result) {\n\t\tERROR(\"failed to allocate memory to sort cgroup settings\");\n\t\treturn NULL;\n\t}\n\tlxc_list_init(result);\n\n\t/*Iterate over the cgroup settings and copy them to the output list*/\n\tlxc_list_for_each(it, cgroup_settings) {\n\t\titem = malloc(sizeof(*item));\n\t\tif (!item) {\n\t\t\tERROR(\"failed to allocate memory to sort cgroup settings\");\n\t\t\tfree_cgroup_settings(result);\n\t\t\treturn NULL;\n\t\t}\n\t\titem->elem = it->elem;\n\t\tcg = it->elem;\n\t\tif (strcmp(cg->subsystem, \"memory.memsw.limit_in_bytes\") == 0) {\n\t\t\t/* Store the memsw_limit location */\n\t\t\tmemsw_limit = item;\n\t\t} else if (strcmp(cg->subsystem, \"memory.limit_in_bytes\") == 0 && memsw_limit != NULL) {\n\t\t\t/* lxc.cgroup.memory.memsw.limit_in_bytes is found before\n\t\t\t * lxc.cgroup.memory.limit_in_bytes, swap these two items */\n\t\t\titem->elem = memsw_limit->elem;\n\t\t\tmemsw_limit->elem = it->elem;\n\t\t}\n\t\tlxc_list_add_tail(result, item);\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "free_cgroup_settings",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "4619-4628",
    "snippet": "static void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "result"
          ],
          "line": 4627
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4619-4628",
          "snippet": "static void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_del",
          "args": [
            "iterator"
          ],
          "line": 4624
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "148-156",
          "snippet": "static inline void lxc_list_del(struct lxc_list *list)\n{\n\tstruct lxc_list *next, *prev;\n\n\tnext = list->next;\n\tprev = list->prev;\n\tnext->prev = prev;\n\tprev->next = next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void lxc_list_del(struct lxc_list *list)\n{\n\tstruct lxc_list *next, *prev;\n\n\tnext = list->next;\n\tprev = list->prev;\n\tnext->prev = prev;\n\tprev->next = next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each_safe",
          "args": [
            "iterator",
            "result",
            "next"
          ],
          "line": 4623
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}"
  },
  {
    "function_name": "suggest_default_idmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "4514-4617",
    "snippet": "void suggest_default_idmap(void)\n{\n\tFILE *f;\n\tunsigned int uid = 0, urange = 0, gid = 0, grange = 0;\n\tchar *line = NULL;\n\tchar *uname, *gname;\n\tsize_t len = 0;\n\n\tif (!(uname = getuname()))\n\t\treturn;\n\n\tif (!(gname = getgname())) {\n\t\tfree(uname);\n\t\treturn;\n\t}\n\n\tf = fopen(subuidfile, \"r\");\n\tif (!f) {\n\t\tERROR(\"Your system is not configured with subuids\");\n\t\tfree(gname);\n\t\tfree(uname);\n\t\treturn;\n\t}\n\twhile (getline(&line, &len, f) != -1) {\n\t\tsize_t no_newline = 0;\n\t\tchar *p = strchr(line, ':'), *p2;\n\t\tif (*line == '#')\n\t\t\tcontinue;\n\t\tif (!p)\n\t\t\tcontinue;\n\t\t*p = '\\0';\n\t\tp++;\n\t\tif (strcmp(line, uname))\n\t\t\tcontinue;\n\t\tp2 = strchr(p, ':');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\t\tp2++;\n\t\tif (!*p2)\n\t\t\tcontinue;\n\t\tno_newline = strcspn(p2, \"\\n\");\n\t\tp2[no_newline] = '\\0';\n\n\t\tif (lxc_safe_uint(p, &uid) < 0)\n\t\t\tWARN(\"Could not parse UID.\");\n\t\tif (lxc_safe_uint(p2, &urange) < 0)\n\t\t\tWARN(\"Could not parse UID range.\");\n\t}\n\tfclose(f);\n\n\tf = fopen(subuidfile, \"r\");\n\tif (!f) {\n\t\tERROR(\"Your system is not configured with subgids\");\n\t\tfree(gname);\n\t\tfree(uname);\n\t\treturn;\n\t}\n\twhile (getline(&line, &len, f) != -1) {\n\t\tsize_t no_newline = 0;\n\t\tchar *p = strchr(line, ':'), *p2;\n\t\tif (*line == '#')\n\t\t\tcontinue;\n\t\tif (!p)\n\t\t\tcontinue;\n\t\t*p = '\\0';\n\t\tp++;\n\t\tif (strcmp(line, uname))\n\t\t\tcontinue;\n\t\tp2 = strchr(p, ':');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\t\tp2++;\n\t\tif (!*p2)\n\t\t\tcontinue;\n\t\tno_newline = strcspn(p2, \"\\n\");\n\t\tp2[no_newline] = '\\0';\n\n\t\tif (lxc_safe_uint(p, &gid) < 0)\n\t\t\tWARN(\"Could not parse GID.\");\n\t\tif (lxc_safe_uint(p2, &grange) < 0)\n\t\t\tWARN(\"Could not parse GID range.\");\n\t}\n\tfclose(f);\n\n\tfree(line);\n\n\tif (!urange || !grange) {\n\t\tERROR(\"You do not have subuids or subgids allocated\");\n\t\tERROR(\"Unprivileged containers require subuids and subgids\");\n\t\treturn;\n\t}\n\n\tERROR(\"You must either run as root, or define uid mappings\");\n\tERROR(\"To pass uid mappings to lxc-create, you could create\");\n\tERROR(\"~/.config/lxc/default.conf:\");\n\tERROR(\"lxc.include = %s\", LXC_DEFAULT_CONFIG);\n\tERROR(\"lxc.id_map = u 0 %u %u\", uid, urange);\n\tERROR(\"lxc.id_map = g 0 %u %u\", gid, grange);\n\n\tfree(gname);\n\tfree(uname);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "uname"
          ],
          "line": 4616
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4619-4628",
          "snippet": "static void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"lxc.id_map = g 0 %u %u\"",
            "gid",
            "grange"
          ],
          "line": 4613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"lxc.id_map = u 0 %u %u\"",
            "uid",
            "urange"
          ],
          "line": 4612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"lxc.include = %s\"",
            "LXC_DEFAULT_CONFIG"
          ],
          "line": 4611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"~/.config/lxc/default.conf:\""
          ],
          "line": 4610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"To pass uid mappings to lxc-create, you could create\""
          ],
          "line": 4609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"You must either run as root, or define uid mappings\""
          ],
          "line": 4608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Unprivileged containers require subuids and subgids\""
          ],
          "line": 4604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"You do not have subuids or subgids allocated\""
          ],
          "line": 4603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 4598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Could not parse GID range.\""
          ],
          "line": 4596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_safe_uint",
          "args": [
            "p2",
            "&grange"
          ],
          "line": 4595
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_safe_uint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1985-2003",
          "snippet": "int lxc_safe_uint(const char *numstr, unsigned int *converted)\n{\n\tchar *err = NULL;\n\tunsigned long int uli;\n\n\terrno = 0;\n\tuli = strtoul(numstr, &err, 0);\n\tif (errno > 0)\n\t\treturn -errno;\n\n\tif (!err || err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\n\tif (uli > UINT_MAX)\n\t\treturn -ERANGE;\n\n\t*converted = (unsigned int)uli;\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_safe_uint(const char *numstr, unsigned int *converted)\n{\n\tchar *err = NULL;\n\tunsigned long int uli;\n\n\terrno = 0;\n\tuli = strtoul(numstr, &err, 0);\n\tif (errno > 0)\n\t\treturn -errno;\n\n\tif (!err || err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\n\tif (uli > UINT_MAX)\n\t\treturn -ERANGE;\n\n\t*converted = (unsigned int)uli;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Could not parse GID.\""
          ],
          "line": 4594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcspn",
          "args": [
            "p2",
            "\"\\n\""
          ],
          "line": 4590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "':'"
          ],
          "line": 4583
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "line",
            "uname"
          ],
          "line": 4581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&line",
            "&len",
            "f"
          ],
          "line": 4572
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getline.c",
          "lines": "39-60",
          "snippet": "ssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Your system is not configured with subgids\""
          ],
          "line": 4567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "subuidfile",
            "\"r\""
          ],
          "line": 4565
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 4563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Could not parse UID range.\""
          ],
          "line": 4561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Could not parse UID.\""
          ],
          "line": 4559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcspn",
          "args": [
            "p2",
            "\"\\n\""
          ],
          "line": 4555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "line",
            "uname"
          ],
          "line": 4546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Your system is not configured with subuids\""
          ],
          "line": 4532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgname",
          "args": [],
          "line": 4525
        },
        "resolved": true,
        "details": {
          "function_name": "getgname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4502-4511",
          "snippet": "static char *getgname(void)\n{\n\tstruct group *result;\n\n\tresult = getgrgid(getegid());\n\tif (!result)\n\t\treturn NULL;\n\n\treturn strdup(result->gr_name);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic char *getgname(void)\n{\n\tstruct group *result;\n\n\tresult = getgrgid(getegid());\n\tif (!result)\n\t\treturn NULL;\n\n\treturn strdup(result->gr_name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuname",
          "args": [],
          "line": 4522
        },
        "resolved": true,
        "details": {
          "function_name": "getuname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4490-4499",
          "snippet": "static char* getuname(void)\n{\n\tstruct passwd *result;\n\n\tresult = getpwuid(geteuid());\n\tif (!result)\n\t\treturn NULL;\n\n\treturn strdup(result->pw_name);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic char* getuname(void)\n{\n\tstruct passwd *result;\n\n\tresult = getpwuid(geteuid());\n\tif (!result)\n\t\treturn NULL;\n\n\treturn strdup(result->pw_name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid suggest_default_idmap(void)\n{\n\tFILE *f;\n\tunsigned int uid = 0, urange = 0, gid = 0, grange = 0;\n\tchar *line = NULL;\n\tchar *uname, *gname;\n\tsize_t len = 0;\n\n\tif (!(uname = getuname()))\n\t\treturn;\n\n\tif (!(gname = getgname())) {\n\t\tfree(uname);\n\t\treturn;\n\t}\n\n\tf = fopen(subuidfile, \"r\");\n\tif (!f) {\n\t\tERROR(\"Your system is not configured with subuids\");\n\t\tfree(gname);\n\t\tfree(uname);\n\t\treturn;\n\t}\n\twhile (getline(&line, &len, f) != -1) {\n\t\tsize_t no_newline = 0;\n\t\tchar *p = strchr(line, ':'), *p2;\n\t\tif (*line == '#')\n\t\t\tcontinue;\n\t\tif (!p)\n\t\t\tcontinue;\n\t\t*p = '\\0';\n\t\tp++;\n\t\tif (strcmp(line, uname))\n\t\t\tcontinue;\n\t\tp2 = strchr(p, ':');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\t\tp2++;\n\t\tif (!*p2)\n\t\t\tcontinue;\n\t\tno_newline = strcspn(p2, \"\\n\");\n\t\tp2[no_newline] = '\\0';\n\n\t\tif (lxc_safe_uint(p, &uid) < 0)\n\t\t\tWARN(\"Could not parse UID.\");\n\t\tif (lxc_safe_uint(p2, &urange) < 0)\n\t\t\tWARN(\"Could not parse UID range.\");\n\t}\n\tfclose(f);\n\n\tf = fopen(subuidfile, \"r\");\n\tif (!f) {\n\t\tERROR(\"Your system is not configured with subgids\");\n\t\tfree(gname);\n\t\tfree(uname);\n\t\treturn;\n\t}\n\twhile (getline(&line, &len, f) != -1) {\n\t\tsize_t no_newline = 0;\n\t\tchar *p = strchr(line, ':'), *p2;\n\t\tif (*line == '#')\n\t\t\tcontinue;\n\t\tif (!p)\n\t\t\tcontinue;\n\t\t*p = '\\0';\n\t\tp++;\n\t\tif (strcmp(line, uname))\n\t\t\tcontinue;\n\t\tp2 = strchr(p, ':');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\t\tp2++;\n\t\tif (!*p2)\n\t\t\tcontinue;\n\t\tno_newline = strcspn(p2, \"\\n\");\n\t\tp2[no_newline] = '\\0';\n\n\t\tif (lxc_safe_uint(p, &gid) < 0)\n\t\t\tWARN(\"Could not parse GID.\");\n\t\tif (lxc_safe_uint(p2, &grange) < 0)\n\t\t\tWARN(\"Could not parse GID range.\");\n\t}\n\tfclose(f);\n\n\tfree(line);\n\n\tif (!urange || !grange) {\n\t\tERROR(\"You do not have subuids or subgids allocated\");\n\t\tERROR(\"Unprivileged containers require subuids and subgids\");\n\t\treturn;\n\t}\n\n\tERROR(\"You must either run as root, or define uid mappings\");\n\tERROR(\"To pass uid mappings to lxc-create, you could create\");\n\tERROR(\"~/.config/lxc/default.conf:\");\n\tERROR(\"lxc.include = %s\", LXC_DEFAULT_CONFIG);\n\tERROR(\"lxc.id_map = u 0 %u %u\", uid, urange);\n\tERROR(\"lxc.id_map = g 0 %u %u\", gid, grange);\n\n\tfree(gname);\n\tfree(uname);\n}"
  },
  {
    "function_name": "getgname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "4502-4511",
    "snippet": "static char *getgname(void)\n{\n\tstruct group *result;\n\n\tresult = getgrgid(getegid());\n\tif (!result)\n\t\treturn NULL;\n\n\treturn strdup(result->gr_name);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "result->gr_name"
          ],
          "line": 4510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgrgid",
          "args": [
            "getegid()"
          ],
          "line": 4506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getegid",
          "args": [],
          "line": 4506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic char *getgname(void)\n{\n\tstruct group *result;\n\n\tresult = getgrgid(getegid());\n\tif (!result)\n\t\treturn NULL;\n\n\treturn strdup(result->gr_name);\n}"
  },
  {
    "function_name": "getuname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "4490-4499",
    "snippet": "static char* getuname(void)\n{\n\tstruct passwd *result;\n\n\tresult = getpwuid(geteuid());\n\tif (!result)\n\t\treturn NULL;\n\n\treturn strdup(result->pw_name);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "result->pw_name"
          ],
          "line": 4498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpwuid",
          "args": [
            "geteuid()"
          ],
          "line": 4494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 4494
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic char* getuname(void)\n{\n\tstruct passwd *result;\n\n\tresult = getpwuid(geteuid());\n\tif (!result)\n\t\treturn NULL;\n\n\treturn strdup(result->pw_name);\n}"
  },
  {
    "function_name": "userns_exec_1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "4435-4487",
    "snippet": "int userns_exec_1(struct lxc_conf *conf, int (*fn)(void *), void *data)\n{\n\tint ret, pid;\n\tstruct userns_fn_data d;\n\tchar c = '1';\n\tint p[2];\n\tstruct lxc_list *idmap;\n\n\tret = pipe(p);\n\tif (ret < 0) {\n\t\tSYSERROR(\"opening pipe\");\n\t\treturn -1;\n\t}\n\td.fn = fn;\n\td.arg = data;\n\td.p[0] = p[0];\n\td.p[1] = p[1];\n\tpid = lxc_clone(run_userns_fn, &d, CLONE_NEWUSER);\n\tif (pid < 0)\n\t\tgoto err;\n\tclose(p[0]);\n\tp[0] = -1;\n\n\tif ((idmap = idmap_add_id(conf, geteuid(), getegid())) == NULL) {\n\t\tERROR(\"Error adding self to container uid/gid map\");\n\t\tgoto err;\n\t}\n\n\tret = lxc_map_ids(idmap, pid);\n\tlxc_free_idmap(idmap);\n\tfree(idmap);\n\tif (ret) {\n\t\tERROR(\"Error setting up child mappings\");\n\t\tgoto err;\n\t}\n\n\t// kick the child\n\tif (write(p[1], &c, 1) != 1) {\n\t\tSYSERROR(\"writing to pipe to child\");\n\t\tgoto err;\n\t}\n\n\tret = wait_for_pid(pid);\n\n\tclose(p[1]);\n\treturn ret;\n\nerr:\n\tif (p[0] != -1)\n\t\tclose(p[0]);\n\tclose(p[1]);\n\treturn -1;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "p[1]"
          ],
          "line": 4485
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_pid",
          "args": [
            "pid"
          ],
          "line": 4477
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "311-325",
          "snippet": "int lxc_wait_for_pid_status(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\treturn status;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_wait_for_pid_status(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"writing to pipe to child\""
          ],
          "line": 4473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "p[1]",
            "&c",
            "1"
          ],
          "line": 4472
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_nointr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "327-335",
          "snippet": "ssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error setting up child mappings\""
          ],
          "line": 4467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "idmap"
          ],
          "line": 4465
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4619-4628",
          "snippet": "static void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_free_idmap",
          "args": [
            "idmap"
          ],
          "line": 4464
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_free_idmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4135-4144",
          "snippet": "static int lxc_free_idmap(struct lxc_list *id_map) {\n\tstruct lxc_list *it, *next;\n\n\tlxc_list_for_each_safe(it, id_map, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int lxc_free_idmap(struct lxc_list *id_map) {\n\tstruct lxc_list *it, *next;\n\n\tlxc_list_for_each_safe(it, id_map, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_map_ids",
          "args": [
            "idmap",
            "pid"
          ],
          "line": 4463
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_map_ids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3230-3305",
          "snippet": "int lxc_map_ids(struct lxc_list *idmap, pid_t pid)\n{\n\tstruct lxc_list *iterator;\n\tstruct id_map *map;\n\tint ret = 0, use_shadow = 0;\n\tenum idtype type;\n\tchar *buf = NULL, *pos, *cmdpath = NULL;\n\n\t/*\n\t * If newuidmap exists, that is, if shadow is handing out subuid\n\t * ranges, then insist that root also reserve ranges in subuid.  This\n\t * will protected it by preventing another user from being handed the\n\t * range by shadow.\n\t */\n\tcmdpath = on_path(\"newuidmap\", NULL);\n\tif (cmdpath) {\n\t\tuse_shadow = 1;\n\t\tfree(cmdpath);\n\t}\n\n\tif (!use_shadow && geteuid()) {\n\t\tERROR(\"Missing newuidmap/newgidmap\");\n\t\treturn -1;\n\t}\n\n\tfor(type = ID_TYPE_UID; type <= ID_TYPE_GID; type++) {\n\t\tint left, fill;\n\t\tint had_entry = 0;\n\t\tif (!buf) {\n\t\t\tbuf = pos = malloc(4096);\n\t\t\tif (!buf)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tpos = buf;\n\t\tif (use_shadow)\n\t\t\tpos += sprintf(buf, \"new%cidmap %d\",\n\t\t\t\ttype == ID_TYPE_UID ? 'u' : 'g',\n\t\t\t\tpid);\n\n\t\tlxc_list_for_each(iterator, idmap) {\n\t\t\t/* The kernel only takes <= 4k for writes to /proc/<nr>/[ug]id_map */\n\t\t\tmap = iterator->elem;\n\t\t\tif (map->idtype != type)\n\t\t\t\tcontinue;\n\n\t\t\thad_entry = 1;\n\t\t\tleft = 4096 - (pos - buf);\n\t\t\tfill = snprintf(pos, left, \"%s%lu %lu %lu%s\",\n\t\t\t\t\tuse_shadow ? \" \" : \"\",\n\t\t\t\t\tmap->nsid, map->hostid, map->range,\n\t\t\t\t\tuse_shadow ? \"\" : \"\\n\");\n\t\t\tif (fill <= 0 || fill >= left)\n\t\t\t\tSYSERROR(\"snprintf failed, too many mappings\");\n\t\t\tpos += fill;\n\t\t}\n\t\tif (!had_entry)\n\t\t\tcontinue;\n\n\t\tif (!use_shadow) {\n\t\t\tret = write_id_mapping(type, pid, buf, pos-buf);\n\t\t} else {\n\t\t\tleft = 4096 - (pos - buf);\n\t\t\tfill = snprintf(pos, left, \"\\n\");\n\t\t\tif (fill <= 0 || fill >= left)\n\t\t\t\tSYSERROR(\"snprintf failed, too many mappings\");\n\t\t\tpos += fill;\n\t\t\tret = system(buf);\n\t\t}\n\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tfree(buf);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_map_ids(struct lxc_list *idmap, pid_t pid)\n{\n\tstruct lxc_list *iterator;\n\tstruct id_map *map;\n\tint ret = 0, use_shadow = 0;\n\tenum idtype type;\n\tchar *buf = NULL, *pos, *cmdpath = NULL;\n\n\t/*\n\t * If newuidmap exists, that is, if shadow is handing out subuid\n\t * ranges, then insist that root also reserve ranges in subuid.  This\n\t * will protected it by preventing another user from being handed the\n\t * range by shadow.\n\t */\n\tcmdpath = on_path(\"newuidmap\", NULL);\n\tif (cmdpath) {\n\t\tuse_shadow = 1;\n\t\tfree(cmdpath);\n\t}\n\n\tif (!use_shadow && geteuid()) {\n\t\tERROR(\"Missing newuidmap/newgidmap\");\n\t\treturn -1;\n\t}\n\n\tfor(type = ID_TYPE_UID; type <= ID_TYPE_GID; type++) {\n\t\tint left, fill;\n\t\tint had_entry = 0;\n\t\tif (!buf) {\n\t\t\tbuf = pos = malloc(4096);\n\t\t\tif (!buf)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tpos = buf;\n\t\tif (use_shadow)\n\t\t\tpos += sprintf(buf, \"new%cidmap %d\",\n\t\t\t\ttype == ID_TYPE_UID ? 'u' : 'g',\n\t\t\t\tpid);\n\n\t\tlxc_list_for_each(iterator, idmap) {\n\t\t\t/* The kernel only takes <= 4k for writes to /proc/<nr>/[ug]id_map */\n\t\t\tmap = iterator->elem;\n\t\t\tif (map->idtype != type)\n\t\t\t\tcontinue;\n\n\t\t\thad_entry = 1;\n\t\t\tleft = 4096 - (pos - buf);\n\t\t\tfill = snprintf(pos, left, \"%s%lu %lu %lu%s\",\n\t\t\t\t\tuse_shadow ? \" \" : \"\",\n\t\t\t\t\tmap->nsid, map->hostid, map->range,\n\t\t\t\t\tuse_shadow ? \"\" : \"\\n\");\n\t\t\tif (fill <= 0 || fill >= left)\n\t\t\t\tSYSERROR(\"snprintf failed, too many mappings\");\n\t\t\tpos += fill;\n\t\t}\n\t\tif (!had_entry)\n\t\t\tcontinue;\n\n\t\tif (!use_shadow) {\n\t\t\tret = write_id_mapping(type, pid, buf, pos-buf);\n\t\t} else {\n\t\t\tleft = 4096 - (pos - buf);\n\t\t\tfill = snprintf(pos, left, \"\\n\");\n\t\t\tif (fill <= 0 || fill >= left)\n\t\t\t\tSYSERROR(\"snprintf failed, too many mappings\");\n\t\t\tpos += fill;\n\t\t\tret = system(buf);\n\t\t}\n\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tfree(buf);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error adding self to container uid/gid map\""
          ],
          "line": 4459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idmap_add_id",
          "args": [
            "conf",
            "geteuid()",
            "getegid()"
          ],
          "line": 4458
        },
        "resolved": true,
        "details": {
          "function_name": "idmap_add_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4353-4429",
          "snippet": "static struct lxc_list *idmap_add_id(struct lxc_conf *conf,\n\t\tuid_t uid, gid_t gid)\n{\n\tint hostuid_mapped = mapped_hostid(uid, conf, ID_TYPE_UID);\n\tint hostgid_mapped = mapped_hostid(gid, conf, ID_TYPE_GID);\n\tstruct lxc_list *new = NULL, *tmp, *it, *next;\n\tstruct id_map *entry;\n\n\tnew = malloc(sizeof(*new));\n\tif (!new) {\n\t\tERROR(\"Out of memory building id map\");\n\t\treturn NULL;\n\t}\n\tlxc_list_init(new);\n\n\tif (hostuid_mapped < 0) {\n\t\thostuid_mapped = find_unmapped_nsuid(conf, ID_TYPE_UID);\n\t\tif (hostuid_mapped < 0)\n\t\t\tgoto err;\n\t\ttmp = malloc(sizeof(*tmp));\n\t\tif (!tmp)\n\t\t\tgoto err;\n\t\tentry = malloc(sizeof(*entry));\n\t\tif (!entry) {\n\t\t\tfree(tmp);\n\t\t\tgoto err;\n\t\t}\n\t\ttmp->elem = entry;\n\t\tentry->idtype = ID_TYPE_UID;\n\t\tentry->nsid = hostuid_mapped;\n\t\tentry->hostid = (unsigned long) uid;\n\t\tentry->range = 1;\n\t\tlxc_list_add_tail(new, tmp);\n\t}\n\tif (hostgid_mapped < 0) {\n\t\thostgid_mapped = find_unmapped_nsuid(conf, ID_TYPE_GID);\n\t\tif (hostgid_mapped < 0)\n\t\t\tgoto err;\n\t\ttmp = malloc(sizeof(*tmp));\n\t\tif (!tmp)\n\t\t\tgoto err;\n\t\tentry = malloc(sizeof(*entry));\n\t\tif (!entry) {\n\t\t\tfree(tmp);\n\t\t\tgoto err;\n\t\t}\n\t\ttmp->elem = entry;\n\t\tentry->idtype = ID_TYPE_GID;\n\t\tentry->nsid = hostgid_mapped;\n\t\tentry->hostid = (unsigned long) gid;\n\t\tentry->range = 1;\n\t\tlxc_list_add_tail(new, tmp);\n\t}\n\tlxc_list_for_each_safe(it, &conf->id_map, next) {\n\t\ttmp = malloc(sizeof(*tmp));\n\t\tif (!tmp)\n\t\t\tgoto err;\n\t\tentry = malloc(sizeof(*entry));\n\t\tif (!entry) {\n\t\t\tfree(tmp);\n\t\t\tgoto err;\n\t\t}\n\t\tmemset(entry, 0, sizeof(*entry));\n\t\tmemcpy(entry, it->elem, sizeof(*entry));\n\t\ttmp->elem = entry;\n\t\tlxc_list_add_tail(new, tmp);\n\t}\n\n\treturn new;\n\nerr:\n\tERROR(\"Out of memory building a new uid/gid map\");\n\tif (new)\n\t\tlxc_free_idmap(new);\n\tfree(new);\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic struct lxc_list *idmap_add_id(struct lxc_conf *conf,\n\t\tuid_t uid, gid_t gid)\n{\n\tint hostuid_mapped = mapped_hostid(uid, conf, ID_TYPE_UID);\n\tint hostgid_mapped = mapped_hostid(gid, conf, ID_TYPE_GID);\n\tstruct lxc_list *new = NULL, *tmp, *it, *next;\n\tstruct id_map *entry;\n\n\tnew = malloc(sizeof(*new));\n\tif (!new) {\n\t\tERROR(\"Out of memory building id map\");\n\t\treturn NULL;\n\t}\n\tlxc_list_init(new);\n\n\tif (hostuid_mapped < 0) {\n\t\thostuid_mapped = find_unmapped_nsuid(conf, ID_TYPE_UID);\n\t\tif (hostuid_mapped < 0)\n\t\t\tgoto err;\n\t\ttmp = malloc(sizeof(*tmp));\n\t\tif (!tmp)\n\t\t\tgoto err;\n\t\tentry = malloc(sizeof(*entry));\n\t\tif (!entry) {\n\t\t\tfree(tmp);\n\t\t\tgoto err;\n\t\t}\n\t\ttmp->elem = entry;\n\t\tentry->idtype = ID_TYPE_UID;\n\t\tentry->nsid = hostuid_mapped;\n\t\tentry->hostid = (unsigned long) uid;\n\t\tentry->range = 1;\n\t\tlxc_list_add_tail(new, tmp);\n\t}\n\tif (hostgid_mapped < 0) {\n\t\thostgid_mapped = find_unmapped_nsuid(conf, ID_TYPE_GID);\n\t\tif (hostgid_mapped < 0)\n\t\t\tgoto err;\n\t\ttmp = malloc(sizeof(*tmp));\n\t\tif (!tmp)\n\t\t\tgoto err;\n\t\tentry = malloc(sizeof(*entry));\n\t\tif (!entry) {\n\t\t\tfree(tmp);\n\t\t\tgoto err;\n\t\t}\n\t\ttmp->elem = entry;\n\t\tentry->idtype = ID_TYPE_GID;\n\t\tentry->nsid = hostgid_mapped;\n\t\tentry->hostid = (unsigned long) gid;\n\t\tentry->range = 1;\n\t\tlxc_list_add_tail(new, tmp);\n\t}\n\tlxc_list_for_each_safe(it, &conf->id_map, next) {\n\t\ttmp = malloc(sizeof(*tmp));\n\t\tif (!tmp)\n\t\t\tgoto err;\n\t\tentry = malloc(sizeof(*entry));\n\t\tif (!entry) {\n\t\t\tfree(tmp);\n\t\t\tgoto err;\n\t\t}\n\t\tmemset(entry, 0, sizeof(*entry));\n\t\tmemcpy(entry, it->elem, sizeof(*entry));\n\t\ttmp->elem = entry;\n\t\tlxc_list_add_tail(new, tmp);\n\t}\n\n\treturn new;\n\nerr:\n\tERROR(\"Out of memory building a new uid/gid map\");\n\tif (new)\n\t\tlxc_free_idmap(new);\n\tfree(new);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getegid",
          "args": [],
          "line": 4458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 4458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_clone",
          "args": [
            "run_userns_fn",
            "&d",
            "CLONE_NEWUSER"
          ],
          "line": 4452
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_clone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/namespace.c",
          "lines": "49-70",
          "snippet": "pid_t lxc_clone(int (*fn)(void *), void *arg, int flags)\n{\n\tstruct clone_arg clone_arg = {\n\t\t.fn = fn,\n\t\t.arg = arg,\n\t};\n\n\tsize_t stack_size = sysconf(_SC_PAGESIZE);\n\tvoid *stack = alloca(stack_size);\n\tpid_t ret;\n\n#ifdef __ia64__\n\tret = __clone2(do_clone, stack,\n\t\t       stack_size, flags | SIGCHLD, &clone_arg);\n#else\n\tret = clone(do_clone, stack  + stack_size, flags | SIGCHLD, &clone_arg);\n#endif\n\tif (ret < 0)\n\t\tERROR(\"Failed to clone (%#x): %s.\", flags, strerror(errno));\n\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"namespace.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <alloca.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"namespace.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <signal.h>\n#include <errno.h>\n#include <alloca.h>\n#include <unistd.h>\n\npid_t lxc_clone(int (*fn)(void *), void *arg, int flags)\n{\n\tstruct clone_arg clone_arg = {\n\t\t.fn = fn,\n\t\t.arg = arg,\n\t};\n\n\tsize_t stack_size = sysconf(_SC_PAGESIZE);\n\tvoid *stack = alloca(stack_size);\n\tpid_t ret;\n\n#ifdef __ia64__\n\tret = __clone2(do_clone, stack,\n\t\t       stack_size, flags | SIGCHLD, &clone_arg);\n#else\n\tret = clone(do_clone, stack  + stack_size, flags | SIGCHLD, &clone_arg);\n#endif\n\tif (ret < 0)\n\t\tERROR(\"Failed to clone (%#x): %s.\", flags, strerror(errno));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"opening pipe\""
          ],
          "line": 4445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "p"
          ],
          "line": 4443
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint userns_exec_1(struct lxc_conf *conf, int (*fn)(void *), void *data)\n{\n\tint ret, pid;\n\tstruct userns_fn_data d;\n\tchar c = '1';\n\tint p[2];\n\tstruct lxc_list *idmap;\n\n\tret = pipe(p);\n\tif (ret < 0) {\n\t\tSYSERROR(\"opening pipe\");\n\t\treturn -1;\n\t}\n\td.fn = fn;\n\td.arg = data;\n\td.p[0] = p[0];\n\td.p[1] = p[1];\n\tpid = lxc_clone(run_userns_fn, &d, CLONE_NEWUSER);\n\tif (pid < 0)\n\t\tgoto err;\n\tclose(p[0]);\n\tp[0] = -1;\n\n\tif ((idmap = idmap_add_id(conf, geteuid(), getegid())) == NULL) {\n\t\tERROR(\"Error adding self to container uid/gid map\");\n\t\tgoto err;\n\t}\n\n\tret = lxc_map_ids(idmap, pid);\n\tlxc_free_idmap(idmap);\n\tfree(idmap);\n\tif (ret) {\n\t\tERROR(\"Error setting up child mappings\");\n\t\tgoto err;\n\t}\n\n\t// kick the child\n\tif (write(p[1], &c, 1) != 1) {\n\t\tSYSERROR(\"writing to pipe to child\");\n\t\tgoto err;\n\t}\n\n\tret = wait_for_pid(pid);\n\n\tclose(p[1]);\n\treturn ret;\n\nerr:\n\tif (p[0] != -1)\n\t\tclose(p[0]);\n\tclose(p[1]);\n\treturn -1;\n}"
  },
  {
    "function_name": "idmap_add_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "4353-4429",
    "snippet": "static struct lxc_list *idmap_add_id(struct lxc_conf *conf,\n\t\tuid_t uid, gid_t gid)\n{\n\tint hostuid_mapped = mapped_hostid(uid, conf, ID_TYPE_UID);\n\tint hostgid_mapped = mapped_hostid(gid, conf, ID_TYPE_GID);\n\tstruct lxc_list *new = NULL, *tmp, *it, *next;\n\tstruct id_map *entry;\n\n\tnew = malloc(sizeof(*new));\n\tif (!new) {\n\t\tERROR(\"Out of memory building id map\");\n\t\treturn NULL;\n\t}\n\tlxc_list_init(new);\n\n\tif (hostuid_mapped < 0) {\n\t\thostuid_mapped = find_unmapped_nsuid(conf, ID_TYPE_UID);\n\t\tif (hostuid_mapped < 0)\n\t\t\tgoto err;\n\t\ttmp = malloc(sizeof(*tmp));\n\t\tif (!tmp)\n\t\t\tgoto err;\n\t\tentry = malloc(sizeof(*entry));\n\t\tif (!entry) {\n\t\t\tfree(tmp);\n\t\t\tgoto err;\n\t\t}\n\t\ttmp->elem = entry;\n\t\tentry->idtype = ID_TYPE_UID;\n\t\tentry->nsid = hostuid_mapped;\n\t\tentry->hostid = (unsigned long) uid;\n\t\tentry->range = 1;\n\t\tlxc_list_add_tail(new, tmp);\n\t}\n\tif (hostgid_mapped < 0) {\n\t\thostgid_mapped = find_unmapped_nsuid(conf, ID_TYPE_GID);\n\t\tif (hostgid_mapped < 0)\n\t\t\tgoto err;\n\t\ttmp = malloc(sizeof(*tmp));\n\t\tif (!tmp)\n\t\t\tgoto err;\n\t\tentry = malloc(sizeof(*entry));\n\t\tif (!entry) {\n\t\t\tfree(tmp);\n\t\t\tgoto err;\n\t\t}\n\t\ttmp->elem = entry;\n\t\tentry->idtype = ID_TYPE_GID;\n\t\tentry->nsid = hostgid_mapped;\n\t\tentry->hostid = (unsigned long) gid;\n\t\tentry->range = 1;\n\t\tlxc_list_add_tail(new, tmp);\n\t}\n\tlxc_list_for_each_safe(it, &conf->id_map, next) {\n\t\ttmp = malloc(sizeof(*tmp));\n\t\tif (!tmp)\n\t\t\tgoto err;\n\t\tentry = malloc(sizeof(*entry));\n\t\tif (!entry) {\n\t\t\tfree(tmp);\n\t\t\tgoto err;\n\t\t}\n\t\tmemset(entry, 0, sizeof(*entry));\n\t\tmemcpy(entry, it->elem, sizeof(*entry));\n\t\ttmp->elem = entry;\n\t\tlxc_list_add_tail(new, tmp);\n\t}\n\n\treturn new;\n\nerr:\n\tERROR(\"Out of memory building a new uid/gid map\");\n\tif (new)\n\t\tlxc_free_idmap(new);\n\tfree(new);\n\treturn NULL;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "new"
          ],
          "line": 4427
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4619-4628",
          "snippet": "static void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_free_idmap",
          "args": [
            "new"
          ],
          "line": 4426
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_free_idmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4135-4144",
          "snippet": "static int lxc_free_idmap(struct lxc_list *id_map) {\n\tstruct lxc_list *it, *next;\n\n\tlxc_list_for_each_safe(it, id_map, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int lxc_free_idmap(struct lxc_list *id_map) {\n\tstruct lxc_list *it, *next;\n\n\tlxc_list_for_each_safe(it, id_map, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Out of memory building a new uid/gid map\""
          ],
          "line": 4424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_add_tail",
          "args": [
            "new",
            "tmp"
          ],
          "line": 4418
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_add_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "133-137",
          "snippet": "static inline void lxc_list_add_tail(struct lxc_list *head,\n\t\t\t\t     struct lxc_list *list)\n{\n\t__lxc_list_add(list, head->prev, head);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void lxc_list_add_tail(struct lxc_list *head,\n\t\t\t\t     struct lxc_list *list)\n{\n\t__lxc_list_add(list, head->prev, head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "entry",
            "it->elem",
            "sizeof(*entry)"
          ],
          "line": 4416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "entry",
            "0",
            "sizeof(*entry)"
          ],
          "line": 4415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*entry)"
          ],
          "line": 4410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*tmp)"
          ],
          "line": 4407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each_safe",
          "args": [
            "it",
            "&conf->id_map",
            "next"
          ],
          "line": 4406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*entry)"
          ],
          "line": 4394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*tmp)"
          ],
          "line": 4391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_unmapped_nsuid",
          "args": [
            "conf",
            "ID_TYPE_GID"
          ],
          "line": 4388
        },
        "resolved": true,
        "details": {
          "function_name": "find_unmapped_nsuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3344-3360",
          "snippet": "int find_unmapped_nsuid(struct lxc_conf *conf, enum idtype idtype)\n{\n\tstruct lxc_list *it;\n\tstruct id_map *map;\n\tunsigned int freeid = 0;\nagain:\n\tlxc_list_for_each(it, &conf->id_map) {\n\t\tmap = it->elem;\n\t\tif (map->idtype != idtype)\n\t\t\tcontinue;\n\t\tif (freeid >= map->nsid && freeid < map->nsid + map->range) {\n\t\t\tfreeid = map->nsid + map->range;\n\t\t\tgoto again;\n\t\t}\n\t}\n\treturn freeid;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint find_unmapped_nsuid(struct lxc_conf *conf, enum idtype idtype)\n{\n\tstruct lxc_list *it;\n\tstruct id_map *map;\n\tunsigned int freeid = 0;\nagain:\n\tlxc_list_for_each(it, &conf->id_map) {\n\t\tmap = it->elem;\n\t\tif (map->idtype != idtype)\n\t\t\tcontinue;\n\t\tif (freeid >= map->nsid && freeid < map->nsid + map->range) {\n\t\t\tfreeid = map->nsid + map->range;\n\t\t\tgoto again;\n\t\t}\n\t}\n\treturn freeid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*entry)"
          ],
          "line": 4375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*tmp)"
          ],
          "line": 4372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_init",
          "args": [
            "new"
          ],
          "line": 4366
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "68-72",
          "snippet": "static inline void lxc_list_init(struct lxc_list *list)\n{\n\tlist->elem = NULL;\n\tlist->next = list->prev = list;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void lxc_list_init(struct lxc_list *list)\n{\n\tlist->elem = NULL;\n\tlist->next = list->prev = list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Out of memory building id map\""
          ],
          "line": 4363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*new)"
          ],
          "line": 4361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapped_hostid",
          "args": [
            "gid",
            "conf",
            "ID_TYPE_GID"
          ],
          "line": 4357
        },
        "resolved": true,
        "details": {
          "function_name": "mapped_hostid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3330-3342",
          "snippet": "int mapped_hostid(unsigned id, struct lxc_conf *conf, enum idtype idtype)\n{\n\tstruct lxc_list *it;\n\tstruct id_map *map;\n\tlxc_list_for_each(it, &conf->id_map) {\n\t\tmap = it->elem;\n\t\tif (map->idtype != idtype)\n\t\t\tcontinue;\n\t\tif (id >= map->hostid && id < map->hostid + map->range)\n\t\t\treturn (id - map->hostid) + map->nsid;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint mapped_hostid(unsigned id, struct lxc_conf *conf, enum idtype idtype)\n{\n\tstruct lxc_list *it;\n\tstruct id_map *map;\n\tlxc_list_for_each(it, &conf->id_map) {\n\t\tmap = it->elem;\n\t\tif (map->idtype != idtype)\n\t\t\tcontinue;\n\t\tif (id >= map->hostid && id < map->hostid + map->range)\n\t\t\treturn (id - map->hostid) + map->nsid;\n\t}\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic struct lxc_list *idmap_add_id(struct lxc_conf *conf,\n\t\tuid_t uid, gid_t gid)\n{\n\tint hostuid_mapped = mapped_hostid(uid, conf, ID_TYPE_UID);\n\tint hostgid_mapped = mapped_hostid(gid, conf, ID_TYPE_GID);\n\tstruct lxc_list *new = NULL, *tmp, *it, *next;\n\tstruct id_map *entry;\n\n\tnew = malloc(sizeof(*new));\n\tif (!new) {\n\t\tERROR(\"Out of memory building id map\");\n\t\treturn NULL;\n\t}\n\tlxc_list_init(new);\n\n\tif (hostuid_mapped < 0) {\n\t\thostuid_mapped = find_unmapped_nsuid(conf, ID_TYPE_UID);\n\t\tif (hostuid_mapped < 0)\n\t\t\tgoto err;\n\t\ttmp = malloc(sizeof(*tmp));\n\t\tif (!tmp)\n\t\t\tgoto err;\n\t\tentry = malloc(sizeof(*entry));\n\t\tif (!entry) {\n\t\t\tfree(tmp);\n\t\t\tgoto err;\n\t\t}\n\t\ttmp->elem = entry;\n\t\tentry->idtype = ID_TYPE_UID;\n\t\tentry->nsid = hostuid_mapped;\n\t\tentry->hostid = (unsigned long) uid;\n\t\tentry->range = 1;\n\t\tlxc_list_add_tail(new, tmp);\n\t}\n\tif (hostgid_mapped < 0) {\n\t\thostgid_mapped = find_unmapped_nsuid(conf, ID_TYPE_GID);\n\t\tif (hostgid_mapped < 0)\n\t\t\tgoto err;\n\t\ttmp = malloc(sizeof(*tmp));\n\t\tif (!tmp)\n\t\t\tgoto err;\n\t\tentry = malloc(sizeof(*entry));\n\t\tif (!entry) {\n\t\t\tfree(tmp);\n\t\t\tgoto err;\n\t\t}\n\t\ttmp->elem = entry;\n\t\tentry->idtype = ID_TYPE_GID;\n\t\tentry->nsid = hostgid_mapped;\n\t\tentry->hostid = (unsigned long) gid;\n\t\tentry->range = 1;\n\t\tlxc_list_add_tail(new, tmp);\n\t}\n\tlxc_list_for_each_safe(it, &conf->id_map, next) {\n\t\ttmp = malloc(sizeof(*tmp));\n\t\tif (!tmp)\n\t\t\tgoto err;\n\t\tentry = malloc(sizeof(*entry));\n\t\tif (!entry) {\n\t\t\tfree(tmp);\n\t\t\tgoto err;\n\t\t}\n\t\tmemset(entry, 0, sizeof(*entry));\n\t\tmemcpy(entry, it->elem, sizeof(*entry));\n\t\ttmp->elem = entry;\n\t\tlxc_list_add_tail(new, tmp);\n\t}\n\n\treturn new;\n\nerr:\n\tERROR(\"Out of memory building a new uid/gid map\");\n\tif (new)\n\t\tlxc_free_idmap(new);\n\tfree(new);\n\treturn NULL;\n}"
  },
  {
    "function_name": "run_userns_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "4336-4347",
    "snippet": "static int run_userns_fn(void *data)\n{\n\tstruct userns_fn_data *d = data;\n\tchar c;\n\t// we're not sharing with the parent any more, if it was a thread\n\n\tclose(d->p[1]);\n\tif (read(d->p[0], &c, 1) != 1)\n\t\treturn -1;\n\tclose(d->p[0]);\n\treturn d->fn(d->arg);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d->fn",
          "args": [
            "d->arg"
          ],
          "line": 4346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "d->p[0]"
          ],
          "line": 4345
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "d->p[0]",
            "&c",
            "1"
          ],
          "line": 4343
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "962-990",
          "snippet": "int lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int run_userns_fn(void *data)\n{\n\tstruct userns_fn_data *d = data;\n\tchar c;\n\t// we're not sharing with the parent any more, if it was a thread\n\n\tclose(d->p[1]);\n\tif (read(d->p[0], &c, 1) != 1)\n\t\treturn -1;\n\tclose(d->p[0]);\n\treturn d->fn(d->arg);\n}"
  },
  {
    "function_name": "lxc_conf_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "4289-4328",
    "snippet": "void lxc_conf_free(struct lxc_conf *conf)\n{\n\tif (!conf)\n\t\treturn;\n\tif (current_config == conf)\n\t\tcurrent_config = NULL;\n\tfree(conf->console.log_path);\n\tfree(conf->console.path);\n\tfree(conf->rootfs.mount);\n\tfree(conf->rootfs.bdev_type);\n\tfree(conf->rootfs.options);\n\tfree(conf->rootfs.path);\n\tfree(conf->logfile);\n\tif (conf->logfd != -1)\n\t\tclose(conf->logfd);\n\tfree(conf->utsname);\n\tfree(conf->ttydir);\n\tfree(conf->fstab);\n\tfree(conf->rcfile);\n\tfree(conf->init_cmd);\n\tfree(conf->unexpanded_config);\n\tfree(conf->pty_names);\n\tfree(conf->syslog);\n\tlxc_clear_config_network(conf);\n\tfree(conf->lsm_aa_profile);\n\tfree(conf->lsm_se_context);\n\tlxc_seccomp_free(conf);\n\tlxc_clear_config_caps(conf);\n\tlxc_clear_config_keepcaps(conf);\n\tlxc_clear_cgroups(conf, \"lxc.cgroup\");\n\tlxc_clear_hooks(conf, \"lxc.hook\");\n\tlxc_clear_mount_entries(conf);\n\tlxc_clear_saved_nics(conf);\n\tlxc_clear_idmaps(conf);\n\tlxc_clear_groups(conf);\n\tlxc_clear_includes(conf);\n\tlxc_clear_aliens(conf);\n\tlxc_clear_environment(conf);\n\tfree(conf);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "conf"
          ],
          "line": 4327
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4619-4628",
          "snippet": "static void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_clear_environment",
          "args": [
            "conf"
          ],
          "line": 4326
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_clear_environment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4197-4207",
          "snippet": "int lxc_clear_environment(struct lxc_conf *c)\n{\n\tstruct lxc_list *it,*next;\n\n\tlxc_list_for_each_safe(it, &c->environment, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_clear_environment(struct lxc_conf *c)\n{\n\tstruct lxc_list *it,*next;\n\n\tlxc_list_for_each_safe(it, &c->environment, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_clear_aliens",
          "args": [
            "conf"
          ],
          "line": 4325
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_clear_aliens",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4267-4276",
          "snippet": "static inline void lxc_clear_aliens(struct lxc_conf *conf)\n{\n\tstruct lxc_list *it,*next;\n\n\tlxc_list_for_each_safe(it, &conf->aliens, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic inline void lxc_clear_aliens(struct lxc_conf *conf)\n{\n\tstruct lxc_list *it,*next;\n\n\tlxc_list_for_each_safe(it, &conf->aliens, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_clear_includes",
          "args": [
            "conf"
          ],
          "line": 4324
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_clear_includes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4278-4287",
          "snippet": "static inline void lxc_clear_includes(struct lxc_conf *conf)\n{\n\tstruct lxc_list *it,*next;\n\n\tlxc_list_for_each_safe(it, &conf->includes, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic inline void lxc_clear_includes(struct lxc_conf *conf)\n{\n\tstruct lxc_list *it,*next;\n\n\tlxc_list_for_each_safe(it, &conf->includes, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_clear_groups",
          "args": [
            "conf"
          ],
          "line": 4323
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_clear_groups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4185-4195",
          "snippet": "int lxc_clear_groups(struct lxc_conf *c)\n{\n\tstruct lxc_list *it,*next;\n\n\tlxc_list_for_each_safe(it, &c->groups, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_clear_groups(struct lxc_conf *c)\n{\n\tstruct lxc_list *it,*next;\n\n\tlxc_list_for_each_safe(it, &c->groups, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_clear_idmaps",
          "args": [
            "conf"
          ],
          "line": 4322
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_clear_idmaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4146-4149",
          "snippet": "int lxc_clear_idmaps(struct lxc_conf *c)\n{\n\treturn lxc_free_idmap(&c->id_map);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_clear_idmaps(struct lxc_conf *c)\n{\n\treturn lxc_free_idmap(&c->id_map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_clear_saved_nics",
          "args": [
            "conf"
          ],
          "line": 4321
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_clear_saved_nics",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4256-4265",
          "snippet": "static void lxc_clear_saved_nics(struct lxc_conf *conf)\n{\n\tint i;\n\n\tif (!conf->saved_nics)\n\t\treturn;\n\tfor (i=0; i < conf->num_savednics; i++)\n\t\tfree(conf->saved_nics[i].orig_name);\n\tfree(conf->saved_nics);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void lxc_clear_saved_nics(struct lxc_conf *conf)\n{\n\tint i;\n\n\tif (!conf->saved_nics)\n\t\treturn;\n\tfor (i=0; i < conf->num_savednics; i++)\n\t\tfree(conf->saved_nics[i].orig_name);\n\tfree(conf->saved_nics);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_clear_mount_entries",
          "args": [
            "conf"
          ],
          "line": 4320
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_clear_mount_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4210-4220",
          "snippet": "int lxc_clear_mount_entries(struct lxc_conf *c)\n{\n\tstruct lxc_list *it,*next;\n\n\tlxc_list_for_each_safe(it, &c->mount_list, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_clear_mount_entries(struct lxc_conf *c)\n{\n\tstruct lxc_list *it,*next;\n\n\tlxc_list_for_each_safe(it, &c->mount_list, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_clear_hooks",
          "args": [
            "conf",
            "\"lxc.hook\""
          ],
          "line": 4319
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_clear_hooks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4228-4254",
          "snippet": "int lxc_clear_hooks(struct lxc_conf *c, const char *key)\n{\n\tstruct lxc_list *it,*next;\n\tbool all = false, done = false;\n\tconst char *k = key + 9;\n\tint i;\n\n\tif (strcmp(key, \"lxc.hook\") == 0)\n\t\tall = true;\n\n\tfor (i=0; i<NUM_LXC_HOOKS; i++) {\n\t\tif (all || strcmp(k, lxchook_names[i]) == 0) {\n\t\t\tlxc_list_for_each_safe(it, &c->hooks[i], next) {\n\t\t\t\tlxc_list_del(it);\n\t\t\t\tfree(it->elem);\n\t\t\t\tfree(it);\n\t\t\t}\n\t\t\tdone = true;\n\t\t}\n\t}\n\n\tif (!done) {\n\t\tERROR(\"Invalid hook key: %s\", key);\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *lxchook_names[NUM_LXC_HOOKS] = {\n\t\"pre-start\", \"pre-mount\", \"mount\", \"autodev\", \"start\", \"stop\", \"post-stop\", \"clone\", \"destroy\" };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *lxchook_names[NUM_LXC_HOOKS] = {\n\t\"pre-start\", \"pre-mount\", \"mount\", \"autodev\", \"start\", \"stop\", \"post-stop\", \"clone\", \"destroy\" };\n\nint lxc_clear_hooks(struct lxc_conf *c, const char *key)\n{\n\tstruct lxc_list *it,*next;\n\tbool all = false, done = false;\n\tconst char *k = key + 9;\n\tint i;\n\n\tif (strcmp(key, \"lxc.hook\") == 0)\n\t\tall = true;\n\n\tfor (i=0; i<NUM_LXC_HOOKS; i++) {\n\t\tif (all || strcmp(k, lxchook_names[i]) == 0) {\n\t\t\tlxc_list_for_each_safe(it, &c->hooks[i], next) {\n\t\t\t\tlxc_list_del(it);\n\t\t\t\tfree(it->elem);\n\t\t\t\tfree(it);\n\t\t\t}\n\t\t\tdone = true;\n\t\t}\n\t}\n\n\tif (!done) {\n\t\tERROR(\"Invalid hook key: %s\", key);\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_clear_cgroups",
          "args": [
            "conf",
            "\"lxc.cgroup\""
          ],
          "line": 4318
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_clear_cgroups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4163-4183",
          "snippet": "int lxc_clear_cgroups(struct lxc_conf *c, const char *key)\n{\n\tstruct lxc_list *it,*next;\n\tbool all = false;\n\tconst char *k = key + 11;\n\n\tif (strcmp(key, \"lxc.cgroup\") == 0)\n\t\tall = true;\n\n\tlxc_list_for_each_safe(it, &c->cgroup, next) {\n\t\tstruct lxc_cgroup *cg = it->elem;\n\t\tif (!all && strcmp(cg->subsystem, k) != 0)\n\t\t\tcontinue;\n\t\tlxc_list_del(it);\n\t\tfree(cg->subsystem);\n\t\tfree(cg->value);\n\t\tfree(cg);\n\t\tfree(it);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_clear_cgroups(struct lxc_conf *c, const char *key)\n{\n\tstruct lxc_list *it,*next;\n\tbool all = false;\n\tconst char *k = key + 11;\n\n\tif (strcmp(key, \"lxc.cgroup\") == 0)\n\t\tall = true;\n\n\tlxc_list_for_each_safe(it, &c->cgroup, next) {\n\t\tstruct lxc_cgroup *cg = it->elem;\n\t\tif (!all && strcmp(cg->subsystem, k) != 0)\n\t\t\tcontinue;\n\t\tlxc_list_del(it);\n\t\tfree(cg->subsystem);\n\t\tfree(cg->value);\n\t\tfree(cg);\n\t\tfree(it);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_clear_config_keepcaps",
          "args": [
            "conf"
          ],
          "line": 4317
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_clear_config_keepcaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4151-4161",
          "snippet": "int lxc_clear_config_keepcaps(struct lxc_conf *c)\n{\n\tstruct lxc_list *it,*next;\n\n\tlxc_list_for_each_safe(it, &c->keepcaps, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_clear_config_keepcaps(struct lxc_conf *c)\n{\n\tstruct lxc_list *it,*next;\n\n\tlxc_list_for_each_safe(it, &c->keepcaps, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_clear_config_caps",
          "args": [
            "conf"
          ],
          "line": 4316
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_clear_config_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4123-4133",
          "snippet": "int lxc_clear_config_caps(struct lxc_conf *c)\n{\n\tstruct lxc_list *it,*next;\n\n\tlxc_list_for_each_safe(it, &c->caps, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int in_caplist(int cap, struct lxc_list *caps);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int in_caplist(int cap, struct lxc_list *caps);\n\nint lxc_clear_config_caps(struct lxc_conf *c)\n{\n\tstruct lxc_list *it,*next;\n\n\tlxc_list_for_each_safe(it, &c->caps, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_seccomp_free",
          "args": [
            "conf"
          ],
          "line": 4315
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_clear_config_network",
          "args": [
            "conf"
          ],
          "line": 4312
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_clear_config_network",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4114-4121",
          "snippet": "int lxc_clear_config_network(struct lxc_conf *c)\n{\n\tstruct lxc_list *it,*next;\n\tlxc_list_for_each_safe(it, &c->network, next) {\n\t\tlxc_remove_nic(it);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_clear_config_network(struct lxc_conf *c)\n{\n\tstruct lxc_list *it,*next;\n\tlxc_list_for_each_safe(it, &c->network, next) {\n\t\tlxc_remove_nic(it);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "conf->logfd"
          ],
          "line": 4303
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid lxc_conf_free(struct lxc_conf *conf)\n{\n\tif (!conf)\n\t\treturn;\n\tif (current_config == conf)\n\t\tcurrent_config = NULL;\n\tfree(conf->console.log_path);\n\tfree(conf->console.path);\n\tfree(conf->rootfs.mount);\n\tfree(conf->rootfs.bdev_type);\n\tfree(conf->rootfs.options);\n\tfree(conf->rootfs.path);\n\tfree(conf->logfile);\n\tif (conf->logfd != -1)\n\t\tclose(conf->logfd);\n\tfree(conf->utsname);\n\tfree(conf->ttydir);\n\tfree(conf->fstab);\n\tfree(conf->rcfile);\n\tfree(conf->init_cmd);\n\tfree(conf->unexpanded_config);\n\tfree(conf->pty_names);\n\tfree(conf->syslog);\n\tlxc_clear_config_network(conf);\n\tfree(conf->lsm_aa_profile);\n\tfree(conf->lsm_se_context);\n\tlxc_seccomp_free(conf);\n\tlxc_clear_config_caps(conf);\n\tlxc_clear_config_keepcaps(conf);\n\tlxc_clear_cgroups(conf, \"lxc.cgroup\");\n\tlxc_clear_hooks(conf, \"lxc.hook\");\n\tlxc_clear_mount_entries(conf);\n\tlxc_clear_saved_nics(conf);\n\tlxc_clear_idmaps(conf);\n\tlxc_clear_groups(conf);\n\tlxc_clear_includes(conf);\n\tlxc_clear_aliens(conf);\n\tlxc_clear_environment(conf);\n\tfree(conf);\n}"
  },
  {
    "function_name": "lxc_clear_includes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "4278-4287",
    "snippet": "static inline void lxc_clear_includes(struct lxc_conf *conf)\n{\n\tstruct lxc_list *it,*next;\n\n\tlxc_list_for_each_safe(it, &conf->includes, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "it"
          ],
          "line": 4285
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4619-4628",
          "snippet": "static void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_del",
          "args": [
            "it"
          ],
          "line": 4283
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "148-156",
          "snippet": "static inline void lxc_list_del(struct lxc_list *list)\n{\n\tstruct lxc_list *next, *prev;\n\n\tnext = list->next;\n\tprev = list->prev;\n\tnext->prev = prev;\n\tprev->next = next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void lxc_list_del(struct lxc_list *list)\n{\n\tstruct lxc_list *next, *prev;\n\n\tnext = list->next;\n\tprev = list->prev;\n\tnext->prev = prev;\n\tprev->next = next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each_safe",
          "args": [
            "it",
            "&conf->includes",
            "next"
          ],
          "line": 4282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic inline void lxc_clear_includes(struct lxc_conf *conf)\n{\n\tstruct lxc_list *it,*next;\n\n\tlxc_list_for_each_safe(it, &conf->includes, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n}"
  },
  {
    "function_name": "lxc_clear_aliens",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "4267-4276",
    "snippet": "static inline void lxc_clear_aliens(struct lxc_conf *conf)\n{\n\tstruct lxc_list *it,*next;\n\n\tlxc_list_for_each_safe(it, &conf->aliens, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "it"
          ],
          "line": 4274
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4619-4628",
          "snippet": "static void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_del",
          "args": [
            "it"
          ],
          "line": 4272
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "148-156",
          "snippet": "static inline void lxc_list_del(struct lxc_list *list)\n{\n\tstruct lxc_list *next, *prev;\n\n\tnext = list->next;\n\tprev = list->prev;\n\tnext->prev = prev;\n\tprev->next = next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void lxc_list_del(struct lxc_list *list)\n{\n\tstruct lxc_list *next, *prev;\n\n\tnext = list->next;\n\tprev = list->prev;\n\tnext->prev = prev;\n\tprev->next = next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each_safe",
          "args": [
            "it",
            "&conf->aliens",
            "next"
          ],
          "line": 4271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic inline void lxc_clear_aliens(struct lxc_conf *conf)\n{\n\tstruct lxc_list *it,*next;\n\n\tlxc_list_for_each_safe(it, &conf->aliens, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n}"
  },
  {
    "function_name": "lxc_clear_saved_nics",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "4256-4265",
    "snippet": "static void lxc_clear_saved_nics(struct lxc_conf *conf)\n{\n\tint i;\n\n\tif (!conf->saved_nics)\n\t\treturn;\n\tfor (i=0; i < conf->num_savednics; i++)\n\t\tfree(conf->saved_nics[i].orig_name);\n\tfree(conf->saved_nics);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "conf->saved_nics"
          ],
          "line": 4264
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4619-4628",
          "snippet": "static void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void lxc_clear_saved_nics(struct lxc_conf *conf)\n{\n\tint i;\n\n\tif (!conf->saved_nics)\n\t\treturn;\n\tfor (i=0; i < conf->num_savednics; i++)\n\t\tfree(conf->saved_nics[i].orig_name);\n\tfree(conf->saved_nics);\n}"
  },
  {
    "function_name": "lxc_clear_hooks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "4228-4254",
    "snippet": "int lxc_clear_hooks(struct lxc_conf *c, const char *key)\n{\n\tstruct lxc_list *it,*next;\n\tbool all = false, done = false;\n\tconst char *k = key + 9;\n\tint i;\n\n\tif (strcmp(key, \"lxc.hook\") == 0)\n\t\tall = true;\n\n\tfor (i=0; i<NUM_LXC_HOOKS; i++) {\n\t\tif (all || strcmp(k, lxchook_names[i]) == 0) {\n\t\t\tlxc_list_for_each_safe(it, &c->hooks[i], next) {\n\t\t\t\tlxc_list_del(it);\n\t\t\t\tfree(it->elem);\n\t\t\t\tfree(it);\n\t\t\t}\n\t\t\tdone = true;\n\t\t}\n\t}\n\n\tif (!done) {\n\t\tERROR(\"Invalid hook key: %s\", key);\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *lxchook_names[NUM_LXC_HOOKS] = {\n\t\"pre-start\", \"pre-mount\", \"mount\", \"autodev\", \"start\", \"stop\", \"post-stop\", \"clone\", \"destroy\" };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Invalid hook key: %s\"",
            "key"
          ],
          "line": 4250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "it"
          ],
          "line": 4243
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4619-4628",
          "snippet": "static void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_del",
          "args": [
            "it"
          ],
          "line": 4241
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "148-156",
          "snippet": "static inline void lxc_list_del(struct lxc_list *list)\n{\n\tstruct lxc_list *next, *prev;\n\n\tnext = list->next;\n\tprev = list->prev;\n\tnext->prev = prev;\n\tprev->next = next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void lxc_list_del(struct lxc_list *list)\n{\n\tstruct lxc_list *next, *prev;\n\n\tnext = list->next;\n\tprev = list->prev;\n\tnext->prev = prev;\n\tprev->next = next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each_safe",
          "args": [
            "it",
            "&c->hooks[i]",
            "next"
          ],
          "line": 4240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "k",
            "lxchook_names[i]"
          ],
          "line": 4239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "key",
            "\"lxc.hook\""
          ],
          "line": 4235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *lxchook_names[NUM_LXC_HOOKS] = {\n\t\"pre-start\", \"pre-mount\", \"mount\", \"autodev\", \"start\", \"stop\", \"post-stop\", \"clone\", \"destroy\" };\n\nint lxc_clear_hooks(struct lxc_conf *c, const char *key)\n{\n\tstruct lxc_list *it,*next;\n\tbool all = false, done = false;\n\tconst char *k = key + 9;\n\tint i;\n\n\tif (strcmp(key, \"lxc.hook\") == 0)\n\t\tall = true;\n\n\tfor (i=0; i<NUM_LXC_HOOKS; i++) {\n\t\tif (all || strcmp(k, lxchook_names[i]) == 0) {\n\t\t\tlxc_list_for_each_safe(it, &c->hooks[i], next) {\n\t\t\t\tlxc_list_del(it);\n\t\t\t\tfree(it->elem);\n\t\t\t\tfree(it);\n\t\t\t}\n\t\t\tdone = true;\n\t\t}\n\t}\n\n\tif (!done) {\n\t\tERROR(\"Invalid hook key: %s\", key);\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_clear_automounts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "4222-4226",
    "snippet": "int lxc_clear_automounts(struct lxc_conf *c)\n{\n\tc->auto_mounts = 0;\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_clear_automounts(struct lxc_conf *c)\n{\n\tc->auto_mounts = 0;\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_clear_mount_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "4210-4220",
    "snippet": "int lxc_clear_mount_entries(struct lxc_conf *c)\n{\n\tstruct lxc_list *it,*next;\n\n\tlxc_list_for_each_safe(it, &c->mount_list, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "it"
          ],
          "line": 4217
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4619-4628",
          "snippet": "static void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_del",
          "args": [
            "it"
          ],
          "line": 4215
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "148-156",
          "snippet": "static inline void lxc_list_del(struct lxc_list *list)\n{\n\tstruct lxc_list *next, *prev;\n\n\tnext = list->next;\n\tprev = list->prev;\n\tnext->prev = prev;\n\tprev->next = next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void lxc_list_del(struct lxc_list *list)\n{\n\tstruct lxc_list *next, *prev;\n\n\tnext = list->next;\n\tprev = list->prev;\n\tnext->prev = prev;\n\tprev->next = next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each_safe",
          "args": [
            "it",
            "&c->mount_list",
            "next"
          ],
          "line": 4214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_clear_mount_entries(struct lxc_conf *c)\n{\n\tstruct lxc_list *it,*next;\n\n\tlxc_list_for_each_safe(it, &c->mount_list, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_clear_environment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "4197-4207",
    "snippet": "int lxc_clear_environment(struct lxc_conf *c)\n{\n\tstruct lxc_list *it,*next;\n\n\tlxc_list_for_each_safe(it, &c->environment, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "it"
          ],
          "line": 4204
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4619-4628",
          "snippet": "static void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_del",
          "args": [
            "it"
          ],
          "line": 4202
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "148-156",
          "snippet": "static inline void lxc_list_del(struct lxc_list *list)\n{\n\tstruct lxc_list *next, *prev;\n\n\tnext = list->next;\n\tprev = list->prev;\n\tnext->prev = prev;\n\tprev->next = next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void lxc_list_del(struct lxc_list *list)\n{\n\tstruct lxc_list *next, *prev;\n\n\tnext = list->next;\n\tprev = list->prev;\n\tnext->prev = prev;\n\tprev->next = next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each_safe",
          "args": [
            "it",
            "&c->environment",
            "next"
          ],
          "line": 4201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_clear_environment(struct lxc_conf *c)\n{\n\tstruct lxc_list *it,*next;\n\n\tlxc_list_for_each_safe(it, &c->environment, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_clear_groups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "4185-4195",
    "snippet": "int lxc_clear_groups(struct lxc_conf *c)\n{\n\tstruct lxc_list *it,*next;\n\n\tlxc_list_for_each_safe(it, &c->groups, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "it"
          ],
          "line": 4192
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4619-4628",
          "snippet": "static void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_del",
          "args": [
            "it"
          ],
          "line": 4190
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "148-156",
          "snippet": "static inline void lxc_list_del(struct lxc_list *list)\n{\n\tstruct lxc_list *next, *prev;\n\n\tnext = list->next;\n\tprev = list->prev;\n\tnext->prev = prev;\n\tprev->next = next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void lxc_list_del(struct lxc_list *list)\n{\n\tstruct lxc_list *next, *prev;\n\n\tnext = list->next;\n\tprev = list->prev;\n\tnext->prev = prev;\n\tprev->next = next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each_safe",
          "args": [
            "it",
            "&c->groups",
            "next"
          ],
          "line": 4189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_clear_groups(struct lxc_conf *c)\n{\n\tstruct lxc_list *it,*next;\n\n\tlxc_list_for_each_safe(it, &c->groups, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_clear_cgroups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "4163-4183",
    "snippet": "int lxc_clear_cgroups(struct lxc_conf *c, const char *key)\n{\n\tstruct lxc_list *it,*next;\n\tbool all = false;\n\tconst char *k = key + 11;\n\n\tif (strcmp(key, \"lxc.cgroup\") == 0)\n\t\tall = true;\n\n\tlxc_list_for_each_safe(it, &c->cgroup, next) {\n\t\tstruct lxc_cgroup *cg = it->elem;\n\t\tif (!all && strcmp(cg->subsystem, k) != 0)\n\t\t\tcontinue;\n\t\tlxc_list_del(it);\n\t\tfree(cg->subsystem);\n\t\tfree(cg->value);\n\t\tfree(cg);\n\t\tfree(it);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "it"
          ],
          "line": 4180
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4619-4628",
          "snippet": "static void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_del",
          "args": [
            "it"
          ],
          "line": 4176
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "148-156",
          "snippet": "static inline void lxc_list_del(struct lxc_list *list)\n{\n\tstruct lxc_list *next, *prev;\n\n\tnext = list->next;\n\tprev = list->prev;\n\tnext->prev = prev;\n\tprev->next = next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void lxc_list_del(struct lxc_list *list)\n{\n\tstruct lxc_list *next, *prev;\n\n\tnext = list->next;\n\tprev = list->prev;\n\tnext->prev = prev;\n\tprev->next = next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cg->subsystem",
            "k"
          ],
          "line": 4174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each_safe",
          "args": [
            "it",
            "&c->cgroup",
            "next"
          ],
          "line": 4172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "key",
            "\"lxc.cgroup\""
          ],
          "line": 4169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_clear_cgroups(struct lxc_conf *c, const char *key)\n{\n\tstruct lxc_list *it,*next;\n\tbool all = false;\n\tconst char *k = key + 11;\n\n\tif (strcmp(key, \"lxc.cgroup\") == 0)\n\t\tall = true;\n\n\tlxc_list_for_each_safe(it, &c->cgroup, next) {\n\t\tstruct lxc_cgroup *cg = it->elem;\n\t\tif (!all && strcmp(cg->subsystem, k) != 0)\n\t\t\tcontinue;\n\t\tlxc_list_del(it);\n\t\tfree(cg->subsystem);\n\t\tfree(cg->value);\n\t\tfree(cg);\n\t\tfree(it);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_clear_config_keepcaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "4151-4161",
    "snippet": "int lxc_clear_config_keepcaps(struct lxc_conf *c)\n{\n\tstruct lxc_list *it,*next;\n\n\tlxc_list_for_each_safe(it, &c->keepcaps, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "it"
          ],
          "line": 4158
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4619-4628",
          "snippet": "static void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_del",
          "args": [
            "it"
          ],
          "line": 4156
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "148-156",
          "snippet": "static inline void lxc_list_del(struct lxc_list *list)\n{\n\tstruct lxc_list *next, *prev;\n\n\tnext = list->next;\n\tprev = list->prev;\n\tnext->prev = prev;\n\tprev->next = next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void lxc_list_del(struct lxc_list *list)\n{\n\tstruct lxc_list *next, *prev;\n\n\tnext = list->next;\n\tprev = list->prev;\n\tnext->prev = prev;\n\tprev->next = next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each_safe",
          "args": [
            "it",
            "&c->keepcaps",
            "next"
          ],
          "line": 4155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_clear_config_keepcaps(struct lxc_conf *c)\n{\n\tstruct lxc_list *it,*next;\n\n\tlxc_list_for_each_safe(it, &c->keepcaps, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_clear_idmaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "4146-4149",
    "snippet": "int lxc_clear_idmaps(struct lxc_conf *c)\n{\n\treturn lxc_free_idmap(&c->id_map);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_free_idmap",
          "args": [
            "&c->id_map"
          ],
          "line": 4148
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_free_idmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4135-4144",
          "snippet": "static int lxc_free_idmap(struct lxc_list *id_map) {\n\tstruct lxc_list *it, *next;\n\n\tlxc_list_for_each_safe(it, id_map, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int lxc_free_idmap(struct lxc_list *id_map) {\n\tstruct lxc_list *it, *next;\n\n\tlxc_list_for_each_safe(it, id_map, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_clear_idmaps(struct lxc_conf *c)\n{\n\treturn lxc_free_idmap(&c->id_map);\n}"
  },
  {
    "function_name": "lxc_free_idmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "4135-4144",
    "snippet": "static int lxc_free_idmap(struct lxc_list *id_map) {\n\tstruct lxc_list *it, *next;\n\n\tlxc_list_for_each_safe(it, id_map, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "it"
          ],
          "line": 4141
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4619-4628",
          "snippet": "static void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_del",
          "args": [
            "it"
          ],
          "line": 4139
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "148-156",
          "snippet": "static inline void lxc_list_del(struct lxc_list *list)\n{\n\tstruct lxc_list *next, *prev;\n\n\tnext = list->next;\n\tprev = list->prev;\n\tnext->prev = prev;\n\tprev->next = next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void lxc_list_del(struct lxc_list *list)\n{\n\tstruct lxc_list *next, *prev;\n\n\tnext = list->next;\n\tprev = list->prev;\n\tnext->prev = prev;\n\tprev->next = next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each_safe",
          "args": [
            "it",
            "id_map",
            "next"
          ],
          "line": 4138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int lxc_free_idmap(struct lxc_list *id_map) {\n\tstruct lxc_list *it, *next;\n\n\tlxc_list_for_each_safe(it, id_map, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_clear_config_caps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "4123-4133",
    "snippet": "int lxc_clear_config_caps(struct lxc_conf *c)\n{\n\tstruct lxc_list *it,*next;\n\n\tlxc_list_for_each_safe(it, &c->caps, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int in_caplist(int cap, struct lxc_list *caps);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "it"
          ],
          "line": 4130
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4619-4628",
          "snippet": "static void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_del",
          "args": [
            "it"
          ],
          "line": 4128
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "148-156",
          "snippet": "static inline void lxc_list_del(struct lxc_list *list)\n{\n\tstruct lxc_list *next, *prev;\n\n\tnext = list->next;\n\tprev = list->prev;\n\tnext->prev = prev;\n\tprev->next = next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void lxc_list_del(struct lxc_list *list)\n{\n\tstruct lxc_list *next, *prev;\n\n\tnext = list->next;\n\tprev = list->prev;\n\tnext->prev = prev;\n\tprev->next = next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each_safe",
          "args": [
            "it",
            "&c->caps",
            "next"
          ],
          "line": 4127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int in_caplist(int cap, struct lxc_list *caps);\n\nint lxc_clear_config_caps(struct lxc_conf *c)\n{\n\tstruct lxc_list *it,*next;\n\n\tlxc_list_for_each_safe(it, &c->caps, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_clear_config_network",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "4114-4121",
    "snippet": "int lxc_clear_config_network(struct lxc_conf *c)\n{\n\tstruct lxc_list *it,*next;\n\tlxc_list_for_each_safe(it, &c->network, next) {\n\t\tlxc_remove_nic(it);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_remove_nic",
          "args": [
            "it"
          ],
          "line": 4118
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_remove_nic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4031-4059",
          "snippet": "static void lxc_remove_nic(struct lxc_list *it)\n{\n\tstruct lxc_netdev *netdev = it->elem;\n\tstruct lxc_list *it2,*next;\n\n\tlxc_list_del(it);\n\n\tfree(netdev->link);\n\tfree(netdev->name);\n\tif (netdev->type == LXC_NET_VETH)\n\t\tfree(netdev->priv.veth_attr.pair);\n\tfree(netdev->upscript);\n\tfree(netdev->hwaddr);\n\tfree(netdev->mtu);\n\tfree(netdev->ipv4_gateway);\n\tfree(netdev->ipv6_gateway);\n\tlxc_list_for_each_safe(it2, &netdev->ipv4, next) {\n\t\tlxc_list_del(it2);\n\t\tfree(it2->elem);\n\t\tfree(it2);\n\t}\n\tlxc_list_for_each_safe(it2, &netdev->ipv6, next) {\n\t\tlxc_list_del(it2);\n\t\tfree(it2->elem);\n\t\tfree(it2);\n\t}\n\tfree(netdev);\n\tfree(it);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_none(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_none(struct lxc_handler *, struct lxc_netdev *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_none(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_none(struct lxc_handler *, struct lxc_netdev *);\n\nstatic void lxc_remove_nic(struct lxc_list *it)\n{\n\tstruct lxc_netdev *netdev = it->elem;\n\tstruct lxc_list *it2,*next;\n\n\tlxc_list_del(it);\n\n\tfree(netdev->link);\n\tfree(netdev->name);\n\tif (netdev->type == LXC_NET_VETH)\n\t\tfree(netdev->priv.veth_attr.pair);\n\tfree(netdev->upscript);\n\tfree(netdev->hwaddr);\n\tfree(netdev->mtu);\n\tfree(netdev->ipv4_gateway);\n\tfree(netdev->ipv6_gateway);\n\tlxc_list_for_each_safe(it2, &netdev->ipv4, next) {\n\t\tlxc_list_del(it2);\n\t\tfree(it2->elem);\n\t\tfree(it2);\n\t}\n\tlxc_list_for_each_safe(it2, &netdev->ipv6, next) {\n\t\tlxc_list_del(it2);\n\t\tfree(it2->elem);\n\t\tfree(it2);\n\t}\n\tfree(netdev);\n\tfree(it);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each_safe",
          "args": [
            "it",
            "&c->network",
            "next"
          ],
          "line": 4117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_clear_config_network(struct lxc_conf *c)\n{\n\tstruct lxc_list *it,*next;\n\tlxc_list_for_each_safe(it, &c->network, next) {\n\t\tlxc_remove_nic(it);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_clear_nic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "4062-4112",
    "snippet": "int lxc_clear_nic(struct lxc_conf *c, const char *key)\n{\n\tchar *p1;\n\tint ret, idx, i;\n\tstruct lxc_list *it;\n\tstruct lxc_netdev *netdev;\n\n\tp1 = strchr(key, '.');\n\tif (!p1 || *(p1+1) == '\\0')\n\t\tp1 = NULL;\n\n\tret = sscanf(key, \"%d\", &idx);\n\tif (ret != 1) return -1;\n\tif (idx < 0)\n\t\treturn -1;\n\n\ti = 0;\n\tlxc_list_for_each(it, &c->network) {\n\t\tif (i == idx)\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i < idx)  // we don't have that many nics defined\n\t\treturn -1;\n\n\tif (!it || !it->elem)\n\t\treturn -1;\n\n\tnetdev = it->elem;\n\n\tif (!p1) {\n\t\tlxc_remove_nic(it);\n\t} else if (strcmp(p1, \".ipv4\") == 0) {\n\t\tstruct lxc_list *it2,*next;\n\t\tlxc_list_for_each_safe(it2, &netdev->ipv4, next) {\n\t\t\tlxc_list_del(it2);\n\t\t\tfree(it2->elem);\n\t\t\tfree(it2);\n\t\t}\n\t} else if (strcmp(p1, \".ipv6\") == 0) {\n\t\tstruct lxc_list *it2,*next;\n\t\tlxc_list_for_each_safe(it2, &netdev->ipv6, next) {\n\t\t\tlxc_list_del(it2);\n\t\t\tfree(it2->elem);\n\t\t\tfree(it2);\n\t\t}\n\t}\n\t\telse return -1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_none(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_none(struct lxc_handler *, struct lxc_netdev *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "it2"
          ],
          "line": 4106
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4619-4628",
          "snippet": "static void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_del",
          "args": [
            "it2"
          ],
          "line": 4104
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "148-156",
          "snippet": "static inline void lxc_list_del(struct lxc_list *list)\n{\n\tstruct lxc_list *next, *prev;\n\n\tnext = list->next;\n\tprev = list->prev;\n\tnext->prev = prev;\n\tprev->next = next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void lxc_list_del(struct lxc_list *list)\n{\n\tstruct lxc_list *next, *prev;\n\n\tnext = list->next;\n\tprev = list->prev;\n\tnext->prev = prev;\n\tprev->next = next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each_safe",
          "args": [
            "it2",
            "&netdev->ipv6",
            "next"
          ],
          "line": 4103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p1",
            "\".ipv6\""
          ],
          "line": 4101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each_safe",
          "args": [
            "it2",
            "&netdev->ipv4",
            "next"
          ],
          "line": 4096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p1",
            "\".ipv4\""
          ],
          "line": 4094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_remove_nic",
          "args": [
            "it"
          ],
          "line": 4093
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_remove_nic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4031-4059",
          "snippet": "static void lxc_remove_nic(struct lxc_list *it)\n{\n\tstruct lxc_netdev *netdev = it->elem;\n\tstruct lxc_list *it2,*next;\n\n\tlxc_list_del(it);\n\n\tfree(netdev->link);\n\tfree(netdev->name);\n\tif (netdev->type == LXC_NET_VETH)\n\t\tfree(netdev->priv.veth_attr.pair);\n\tfree(netdev->upscript);\n\tfree(netdev->hwaddr);\n\tfree(netdev->mtu);\n\tfree(netdev->ipv4_gateway);\n\tfree(netdev->ipv6_gateway);\n\tlxc_list_for_each_safe(it2, &netdev->ipv4, next) {\n\t\tlxc_list_del(it2);\n\t\tfree(it2->elem);\n\t\tfree(it2);\n\t}\n\tlxc_list_for_each_safe(it2, &netdev->ipv6, next) {\n\t\tlxc_list_del(it2);\n\t\tfree(it2->elem);\n\t\tfree(it2);\n\t}\n\tfree(netdev);\n\tfree(it);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_none(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_none(struct lxc_handler *, struct lxc_netdev *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_none(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_none(struct lxc_handler *, struct lxc_netdev *);\n\nstatic void lxc_remove_nic(struct lxc_list *it)\n{\n\tstruct lxc_netdev *netdev = it->elem;\n\tstruct lxc_list *it2,*next;\n\n\tlxc_list_del(it);\n\n\tfree(netdev->link);\n\tfree(netdev->name);\n\tif (netdev->type == LXC_NET_VETH)\n\t\tfree(netdev->priv.veth_attr.pair);\n\tfree(netdev->upscript);\n\tfree(netdev->hwaddr);\n\tfree(netdev->mtu);\n\tfree(netdev->ipv4_gateway);\n\tfree(netdev->ipv6_gateway);\n\tlxc_list_for_each_safe(it2, &netdev->ipv4, next) {\n\t\tlxc_list_del(it2);\n\t\tfree(it2->elem);\n\t\tfree(it2);\n\t}\n\tlxc_list_for_each_safe(it2, &netdev->ipv6, next) {\n\t\tlxc_list_del(it2);\n\t\tfree(it2->elem);\n\t\tfree(it2);\n\t}\n\tfree(netdev);\n\tfree(it);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "it",
            "&c->network"
          ],
          "line": 4079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "key",
            "\"%d\"",
            "&idx"
          ],
          "line": 4073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "key",
            "'.'"
          ],
          "line": 4069
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_none(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_none(struct lxc_handler *, struct lxc_netdev *);\n\nint lxc_clear_nic(struct lxc_conf *c, const char *key)\n{\n\tchar *p1;\n\tint ret, idx, i;\n\tstruct lxc_list *it;\n\tstruct lxc_netdev *netdev;\n\n\tp1 = strchr(key, '.');\n\tif (!p1 || *(p1+1) == '\\0')\n\t\tp1 = NULL;\n\n\tret = sscanf(key, \"%d\", &idx);\n\tif (ret != 1) return -1;\n\tif (idx < 0)\n\t\treturn -1;\n\n\ti = 0;\n\tlxc_list_for_each(it, &c->network) {\n\t\tif (i == idx)\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i < idx)  // we don't have that many nics defined\n\t\treturn -1;\n\n\tif (!it || !it->elem)\n\t\treturn -1;\n\n\tnetdev = it->elem;\n\n\tif (!p1) {\n\t\tlxc_remove_nic(it);\n\t} else if (strcmp(p1, \".ipv4\") == 0) {\n\t\tstruct lxc_list *it2,*next;\n\t\tlxc_list_for_each_safe(it2, &netdev->ipv4, next) {\n\t\t\tlxc_list_del(it2);\n\t\t\tfree(it2->elem);\n\t\t\tfree(it2);\n\t\t}\n\t} else if (strcmp(p1, \".ipv6\") == 0) {\n\t\tstruct lxc_list *it2,*next;\n\t\tlxc_list_for_each_safe(it2, &netdev->ipv6, next) {\n\t\t\tlxc_list_del(it2);\n\t\t\tfree(it2->elem);\n\t\t\tfree(it2);\n\t\t}\n\t}\n\t\telse return -1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_remove_nic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "4031-4059",
    "snippet": "static void lxc_remove_nic(struct lxc_list *it)\n{\n\tstruct lxc_netdev *netdev = it->elem;\n\tstruct lxc_list *it2,*next;\n\n\tlxc_list_del(it);\n\n\tfree(netdev->link);\n\tfree(netdev->name);\n\tif (netdev->type == LXC_NET_VETH)\n\t\tfree(netdev->priv.veth_attr.pair);\n\tfree(netdev->upscript);\n\tfree(netdev->hwaddr);\n\tfree(netdev->mtu);\n\tfree(netdev->ipv4_gateway);\n\tfree(netdev->ipv6_gateway);\n\tlxc_list_for_each_safe(it2, &netdev->ipv4, next) {\n\t\tlxc_list_del(it2);\n\t\tfree(it2->elem);\n\t\tfree(it2);\n\t}\n\tlxc_list_for_each_safe(it2, &netdev->ipv6, next) {\n\t\tlxc_list_del(it2);\n\t\tfree(it2->elem);\n\t\tfree(it2);\n\t}\n\tfree(netdev);\n\tfree(it);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_none(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_none(struct lxc_handler *, struct lxc_netdev *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "it"
          ],
          "line": 4058
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4619-4628",
          "snippet": "static void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_del",
          "args": [
            "it2"
          ],
          "line": 4053
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "148-156",
          "snippet": "static inline void lxc_list_del(struct lxc_list *list)\n{\n\tstruct lxc_list *next, *prev;\n\n\tnext = list->next;\n\tprev = list->prev;\n\tnext->prev = prev;\n\tprev->next = next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void lxc_list_del(struct lxc_list *list)\n{\n\tstruct lxc_list *next, *prev;\n\n\tnext = list->next;\n\tprev = list->prev;\n\tnext->prev = prev;\n\tprev->next = next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each_safe",
          "args": [
            "it2",
            "&netdev->ipv6",
            "next"
          ],
          "line": 4052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each_safe",
          "args": [
            "it2",
            "&netdev->ipv4",
            "next"
          ],
          "line": 4047
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_none(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_none(struct lxc_handler *, struct lxc_netdev *);\n\nstatic void lxc_remove_nic(struct lxc_list *it)\n{\n\tstruct lxc_netdev *netdev = it->elem;\n\tstruct lxc_list *it2,*next;\n\n\tlxc_list_del(it);\n\n\tfree(netdev->link);\n\tfree(netdev->name);\n\tif (netdev->type == LXC_NET_VETH)\n\t\tfree(netdev->priv.veth_attr.pair);\n\tfree(netdev->upscript);\n\tfree(netdev->hwaddr);\n\tfree(netdev->mtu);\n\tfree(netdev->ipv4_gateway);\n\tfree(netdev->ipv6_gateway);\n\tlxc_list_for_each_safe(it2, &netdev->ipv4, next) {\n\t\tlxc_list_del(it2);\n\t\tfree(it2->elem);\n\t\tfree(it2);\n\t}\n\tlxc_list_for_each_safe(it2, &netdev->ipv6, next) {\n\t\tlxc_list_del(it2);\n\t\tfree(it2->elem);\n\t\tfree(it2);\n\t}\n\tfree(netdev);\n\tfree(it);\n}"
  },
  {
    "function_name": "run_lxc_hooks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "3995-4029",
    "snippet": "int run_lxc_hooks(const char *name, char *hook, struct lxc_conf *conf,\n\t\t  const char *lxcpath, char *argv[])\n{\n\tint which = -1;\n\tstruct lxc_list *it;\n\n\tif (strcmp(hook, \"pre-start\") == 0)\n\t\twhich = LXCHOOK_PRESTART;\n\telse if (strcmp(hook, \"pre-mount\") == 0)\n\t\twhich = LXCHOOK_PREMOUNT;\n\telse if (strcmp(hook, \"mount\") == 0)\n\t\twhich = LXCHOOK_MOUNT;\n\telse if (strcmp(hook, \"autodev\") == 0)\n\t\twhich = LXCHOOK_AUTODEV;\n\telse if (strcmp(hook, \"start\") == 0)\n\t\twhich = LXCHOOK_START;\n\telse if (strcmp(hook, \"stop\") == 0)\n\t\twhich = LXCHOOK_STOP;\n\telse if (strcmp(hook, \"post-stop\") == 0)\n\t\twhich = LXCHOOK_POSTSTOP;\n\telse if (strcmp(hook, \"clone\") == 0)\n\t\twhich = LXCHOOK_CLONE;\n\telse if (strcmp(hook, \"destroy\") == 0)\n\t\twhich = LXCHOOK_DESTROY;\n\telse\n\t\treturn -1;\n\tlxc_list_for_each(it, &conf->hooks[which]) {\n\t\tint ret;\n\t\tchar *hookname = it->elem;\n\t\tret = run_script_argv(name, \"lxc\", hookname, hook, lxcpath, argv);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "run_script_argv",
          "args": [
            "name",
            "\"lxc\"",
            "hookname",
            "hook",
            "lxcpath",
            "argv"
          ],
          "line": 4024
        },
        "resolved": true,
        "details": {
          "function_name": "run_script_argv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "415-464",
          "snippet": "static int run_script_argv(const char *name, const char *section,\n\t\t\t   const char *script, const char *hook,\n\t\t\t   const char *lxcpath, char **argsin)\n{\n\tint ret, i;\n\tchar *buffer;\n\tsize_t size = 0;\n\n\tINFO(\"Executing script \\\"%s\\\" for container \\\"%s\\\", config section \\\"%s\\\".\",\n\t     script, name, section);\n\n\tfor (i = 0; argsin && argsin[i]; i++)\n\t\tsize += strlen(argsin[i]) + 1;\n\n\tsize += strlen(hook) + 1;\n\n\tsize += strlen(script);\n\tsize += strlen(name);\n\tsize += strlen(section);\n\tsize += 3;\n\n\tif (size > INT_MAX)\n\t\treturn -1;\n\n\tbuffer = alloca(size);\n\tif (!buffer) {\n\t\tERROR(\"Failed to allocate memory.\");\n\t\treturn -1;\n\t}\n\n\tret =\n\t    snprintf(buffer, size, \"%s %s %s %s\", script, name, section, hook);\n\tif (ret < 0 || (size_t)ret >= size) {\n\t\tERROR(\"Script name too long.\");\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; argsin && argsin[i]; i++) {\n\t\tint len = size - ret;\n\t\tint rc;\n\t\trc = snprintf(buffer + ret, len, \" %s\", argsin[i]);\n\t\tif (rc < 0 || rc >= len) {\n\t\t\tERROR(\"Script args too long.\");\n\t\t\treturn -1;\n\t\t}\n\t\tret += rc;\n\t}\n\n\treturn run_buffer(buffer);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int run_script_argv(const char *name, const char *section,\n\t\t\t   const char *script, const char *hook,\n\t\t\t   const char *lxcpath, char **argsin)\n{\n\tint ret, i;\n\tchar *buffer;\n\tsize_t size = 0;\n\n\tINFO(\"Executing script \\\"%s\\\" for container \\\"%s\\\", config section \\\"%s\\\".\",\n\t     script, name, section);\n\n\tfor (i = 0; argsin && argsin[i]; i++)\n\t\tsize += strlen(argsin[i]) + 1;\n\n\tsize += strlen(hook) + 1;\n\n\tsize += strlen(script);\n\tsize += strlen(name);\n\tsize += strlen(section);\n\tsize += 3;\n\n\tif (size > INT_MAX)\n\t\treturn -1;\n\n\tbuffer = alloca(size);\n\tif (!buffer) {\n\t\tERROR(\"Failed to allocate memory.\");\n\t\treturn -1;\n\t}\n\n\tret =\n\t    snprintf(buffer, size, \"%s %s %s %s\", script, name, section, hook);\n\tif (ret < 0 || (size_t)ret >= size) {\n\t\tERROR(\"Script name too long.\");\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; argsin && argsin[i]; i++) {\n\t\tint len = size - ret;\n\t\tint rc;\n\t\trc = snprintf(buffer + ret, len, \" %s\", argsin[i]);\n\t\tif (rc < 0 || rc >= len) {\n\t\t\tERROR(\"Script args too long.\");\n\t\t\treturn -1;\n\t\t}\n\t\tret += rc;\n\t}\n\n\treturn run_buffer(buffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "it",
            "&conf->hooks[which]"
          ],
          "line": 4021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "hook",
            "\"destroy\""
          ],
          "line": 4017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "hook",
            "\"clone\""
          ],
          "line": 4015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "hook",
            "\"post-stop\""
          ],
          "line": 4013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "hook",
            "\"stop\""
          ],
          "line": 4011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "hook",
            "\"start\""
          ],
          "line": 4009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "hook",
            "\"autodev\""
          ],
          "line": 4007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "hook",
            "\"mount\""
          ],
          "line": 4005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "hook",
            "\"pre-mount\""
          ],
          "line": 4003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "hook",
            "\"pre-start\""
          ],
          "line": 4001
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint run_lxc_hooks(const char *name, char *hook, struct lxc_conf *conf,\n\t\t  const char *lxcpath, char *argv[])\n{\n\tint which = -1;\n\tstruct lxc_list *it;\n\n\tif (strcmp(hook, \"pre-start\") == 0)\n\t\twhich = LXCHOOK_PRESTART;\n\telse if (strcmp(hook, \"pre-mount\") == 0)\n\t\twhich = LXCHOOK_PREMOUNT;\n\telse if (strcmp(hook, \"mount\") == 0)\n\t\twhich = LXCHOOK_MOUNT;\n\telse if (strcmp(hook, \"autodev\") == 0)\n\t\twhich = LXCHOOK_AUTODEV;\n\telse if (strcmp(hook, \"start\") == 0)\n\t\twhich = LXCHOOK_START;\n\telse if (strcmp(hook, \"stop\") == 0)\n\t\twhich = LXCHOOK_STOP;\n\telse if (strcmp(hook, \"post-stop\") == 0)\n\t\twhich = LXCHOOK_POSTSTOP;\n\telse if (strcmp(hook, \"clone\") == 0)\n\t\twhich = LXCHOOK_CLONE;\n\telse if (strcmp(hook, \"destroy\") == 0)\n\t\twhich = LXCHOOK_DESTROY;\n\telse\n\t\treturn -1;\n\tlxc_list_for_each(it, &conf->hooks[which]) {\n\t\tint ret;\n\t\tchar *hookname = it->elem;\n\t\tret = run_script_argv(name, \"lxc\", hookname, hook, lxcpath, argv);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "3838-3993",
    "snippet": "int lxc_setup(struct lxc_handler *handler)\n{\n\tconst char *name = handler->name;\n\tstruct lxc_conf *lxc_conf = handler->conf;\n\tconst char *lxcpath = handler->lxcpath;\n\n\tif (do_rootfs_setup(lxc_conf, name, lxcpath) < 0) {\n\t\tERROR(\"Error setting up rootfs mount after spawn\");\n\t\treturn -1;\n\t}\n\n\tif (lxc_conf->inherit_ns_fd[LXC_NS_UTS] == -1) {\n\t\tif (setup_utsname(lxc_conf->utsname)) {\n\t\t\tERROR(\"failed to setup the utsname for '%s'\", name);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (setup_network(&lxc_conf->network)) {\n\t\tERROR(\"failed to setup the network for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tif (lxc_conf->autodev > 0) {\n\t\tif (mount_autodev(name, &lxc_conf->rootfs, lxcpath)) {\n\t\t\tERROR(\"failed to mount /dev in the container\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* do automatic mounts (mainly /proc and /sys), but exclude\n\t * those that need to wait until other stuff has finished\n\t */\n\tif (lxc_mount_auto_mounts(lxc_conf, lxc_conf->auto_mounts & ~LXC_AUTO_CGROUP_MASK, handler) < 0) {\n\t\tERROR(\"failed to setup the automatic mounts for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tif (setup_mount(&lxc_conf->rootfs, lxc_conf->fstab, name, lxcpath)) {\n\t\tERROR(\"failed to setup the mounts for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tif (!lxc_list_empty(&lxc_conf->mount_list) && setup_mount_entries(&lxc_conf->rootfs, &lxc_conf->mount_list, name, lxcpath)) {\n\t\tERROR(\"failed to setup the mount entries for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\t/* Make sure any start hooks are in the container */\n\tif (!verify_start_hooks(lxc_conf))\n\t\treturn -1;\n\n\tif (lxc_conf->is_execute)\n\t\tlxc_execute_bind_init(lxc_conf);\n\n\t/* now mount only cgroup, if wanted;\n\t * before, /sys could not have been mounted\n\t * (is either mounted automatically or via fstab entries)\n\t */\n\tif (lxc_mount_auto_mounts(lxc_conf, lxc_conf->auto_mounts & LXC_AUTO_CGROUP_MASK, handler) < 0) {\n\t\tERROR(\"failed to setup the automatic mounts for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tif (run_lxc_hooks(name, \"mount\", lxc_conf, lxcpath, NULL)) {\n\t\tERROR(\"failed to run mount hooks for container '%s'.\", name);\n\t\treturn -1;\n\t}\n\n\tif (lxc_conf->autodev > 0) {\n\t\tbool mount_console = lxc_conf->console.path && !strcmp(lxc_conf->console.path, \"none\");\n\n\t\tif (run_lxc_hooks(name, \"autodev\", lxc_conf, lxcpath, NULL)) {\n\t\t\tERROR(\"failed to run autodev hooks for container '%s'.\", name);\n\t\t\treturn -1;\n\t\t}\n\t\tif (fill_autodev(&lxc_conf->rootfs, mount_console)) {\n\t\t\tERROR(\"failed to populate /dev in the container\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!lxc_conf->is_execute && setup_console(&lxc_conf->rootfs, &lxc_conf->console, lxc_conf->ttydir)) {\n\t\tERROR(\"failed to setup the console for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tif (lxc_conf->kmsg) {\n\t\tif (setup_kmsg(&lxc_conf->rootfs, &lxc_conf->console))  // don't fail\n\t\t\tERROR(\"failed to setup kmsg for '%s'\", name);\n\t}\n\n\tif (!lxc_conf->is_execute && setup_dev_symlinks(&lxc_conf->rootfs)) {\n\t\tERROR(\"failed to setup /dev symlinks for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\t/* mount /proc if it's not already there */\n\tif (tmp_proc_mount(lxc_conf) < 0) {\n\t\tERROR(\"failed to LSM mount proc for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tif (setup_pivot_root(&lxc_conf->rootfs)) {\n\t\tERROR(\"failed to set rootfs for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tif (setup_pts(lxc_conf->pts)) {\n\t\tERROR(\"failed to setup the new pts instance\");\n\t\treturn -1;\n\t}\n\n\tif (lxc_create_tty(name, lxc_conf)) {\n\t\tERROR(\"failed to create the ttys\");\n\t\treturn -1;\n\t}\n\n\tif (send_ttys_to_parent(handler) < 0) {\n\t\tERROR(\"failure sending console info to parent\");\n\t\treturn -1;\n\t}\n\n\n\tif (!lxc_conf->is_execute && setup_tty(lxc_conf)) {\n\t\tERROR(\"failed to setup the ttys for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tif (lxc_conf->pty_names && setenv(\"container_ttys\", lxc_conf->pty_names, 1))\n\t\tSYSERROR(\"failed to set environment variable for container ptys\");\n\n\n\tif (setup_personality(lxc_conf->personality)) {\n\t\tERROR(\"failed to setup personality\");\n\t\treturn -1;\n\t}\n\n\tif (!lxc_list_empty(&lxc_conf->keepcaps)) {\n\t\tif (!lxc_list_empty(&lxc_conf->caps)) {\n\t\t\tERROR(\"Container requests lxc.cap.drop and lxc.cap.keep: either use lxc.cap.drop or lxc.cap.keep, not both.\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (dropcaps_except(&lxc_conf->keepcaps)) {\n\t\t\tERROR(\"failed to keep requested caps\");\n\t\t\treturn -1;\n\t\t}\n\t} else if (setup_caps(&lxc_conf->caps)) {\n\t\tERROR(\"failed to drop capabilities\");\n\t\treturn -1;\n\t}\n\n\tNOTICE(\"'%s' is setup.\", name);\n\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int in_caplist(int cap, struct lxc_list *caps);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NOTICE",
          "args": [
            "\"'%s' is setup.\"",
            "name"
          ],
          "line": 3990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to drop capabilities\""
          ],
          "line": 3986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_caps",
          "args": [
            "&lxc_conf->caps"
          ],
          "line": 3985
        },
        "resolved": true,
        "details": {
          "function_name": "setup_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "2118-2147",
          "snippet": "static int setup_caps(struct lxc_list *caps)\n{\n\tstruct lxc_list *iterator;\n\tchar *drop_entry;\n\tint capid;\n\n\tlxc_list_for_each(iterator, caps) {\n\n\t\tdrop_entry = iterator->elem;\n\n\t\tcapid = parse_cap(drop_entry);\n\n\t        if (capid < 0) {\n\t\t\tERROR(\"unknown capability %s\", drop_entry);\n\t\t\treturn -1;\n\t\t}\n\n\t\tDEBUG(\"drop capability '%s' (%d)\", drop_entry, capid);\n\n\t\tif (prctl(PR_CAPBSET_DROP, capid, 0, 0, 0)) {\n\t\t\tSYSERROR(\"failed to remove %s capability\", drop_entry);\n\t\t\treturn -1;\n\t\t}\n\n\t}\n\n\tDEBUG(\"capabilities have been setup\");\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PR_CAPBSET_DROP 24"
          ],
          "globals_used": [
            "static int in_caplist(int cap, struct lxc_list *caps);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\n#define PR_CAPBSET_DROP 24\n\nstatic int in_caplist(int cap, struct lxc_list *caps);\n\nstatic int setup_caps(struct lxc_list *caps)\n{\n\tstruct lxc_list *iterator;\n\tchar *drop_entry;\n\tint capid;\n\n\tlxc_list_for_each(iterator, caps) {\n\n\t\tdrop_entry = iterator->elem;\n\n\t\tcapid = parse_cap(drop_entry);\n\n\t        if (capid < 0) {\n\t\t\tERROR(\"unknown capability %s\", drop_entry);\n\t\t\treturn -1;\n\t\t}\n\n\t\tDEBUG(\"drop capability '%s' (%d)\", drop_entry, capid);\n\n\t\tif (prctl(PR_CAPBSET_DROP, capid, 0, 0, 0)) {\n\t\t\tSYSERROR(\"failed to remove %s capability\", drop_entry);\n\t\t\treturn -1;\n\t\t}\n\n\t}\n\n\tDEBUG(\"capabilities have been setup\");\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to keep requested caps\""
          ],
          "line": 3982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dropcaps_except",
          "args": [
            "&lxc_conf->keepcaps"
          ],
          "line": 3981
        },
        "resolved": true,
        "details": {
          "function_name": "dropcaps_except",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "2149-2194",
          "snippet": "static int dropcaps_except(struct lxc_list *caps)\n{\n\tstruct lxc_list *iterator;\n\tchar *keep_entry;\n\tint i, capid;\n\tint numcaps = lxc_caps_last_cap() + 1;\n\tINFO(\"found %d capabilities\", numcaps);\n\n\tif (numcaps <= 0 || numcaps > 200)\n\t\treturn -1;\n\n\t// caplist[i] is 1 if we keep capability i\n\tint *caplist = alloca(numcaps * sizeof(int));\n\tmemset(caplist, 0, numcaps * sizeof(int));\n\n\tlxc_list_for_each(iterator, caps) {\n\n\t\tkeep_entry = iterator->elem;\n\n\t\tcapid = parse_cap(keep_entry);\n\n\t\tif (capid == -2)\n\t\t\tcontinue;\n\n\t        if (capid < 0) {\n\t\t\tERROR(\"unknown capability %s\", keep_entry);\n\t\t\treturn -1;\n\t\t}\n\n\t\tDEBUG(\"keep capability '%s' (%d)\", keep_entry, capid);\n\n\t\tcaplist[capid] = 1;\n\t}\n\tfor (i=0; i<numcaps; i++) {\n\t\tif (caplist[i])\n\t\t\tcontinue;\n\t\tif (prctl(PR_CAPBSET_DROP, i, 0, 0, 0)) {\n\t\t\tSYSERROR(\"failed to remove capability %d\", i);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tDEBUG(\"capabilities have been setup\");\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PR_CAPBSET_DROP 24"
          ],
          "globals_used": [
            "static int in_caplist(int cap, struct lxc_list *caps);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\n#define PR_CAPBSET_DROP 24\n\nstatic int in_caplist(int cap, struct lxc_list *caps);\n\nstatic int dropcaps_except(struct lxc_list *caps)\n{\n\tstruct lxc_list *iterator;\n\tchar *keep_entry;\n\tint i, capid;\n\tint numcaps = lxc_caps_last_cap() + 1;\n\tINFO(\"found %d capabilities\", numcaps);\n\n\tif (numcaps <= 0 || numcaps > 200)\n\t\treturn -1;\n\n\t// caplist[i] is 1 if we keep capability i\n\tint *caplist = alloca(numcaps * sizeof(int));\n\tmemset(caplist, 0, numcaps * sizeof(int));\n\n\tlxc_list_for_each(iterator, caps) {\n\n\t\tkeep_entry = iterator->elem;\n\n\t\tcapid = parse_cap(keep_entry);\n\n\t\tif (capid == -2)\n\t\t\tcontinue;\n\n\t        if (capid < 0) {\n\t\t\tERROR(\"unknown capability %s\", keep_entry);\n\t\t\treturn -1;\n\t\t}\n\n\t\tDEBUG(\"keep capability '%s' (%d)\", keep_entry, capid);\n\n\t\tcaplist[capid] = 1;\n\t}\n\tfor (i=0; i<numcaps; i++) {\n\t\tif (caplist[i])\n\t\t\tcontinue;\n\t\tif (prctl(PR_CAPBSET_DROP, i, 0, 0, 0)) {\n\t\t\tSYSERROR(\"failed to remove capability %d\", i);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tDEBUG(\"capabilities have been setup\");\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Container requests lxc.cap.drop and lxc.cap.keep: either use lxc.cap.drop or lxc.cap.keep, not both.\""
          ],
          "line": 3978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_empty",
          "args": [
            "&lxc_conf->caps"
          ],
          "line": 3977
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "94-97",
          "snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to setup personality\""
          ],
          "line": 3972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_personality",
          "args": [
            "lxc_conf->personality"
          ],
          "line": 3971
        },
        "resolved": true,
        "details": {
          "function_name": "setup_personality",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1440-1455",
          "snippet": "static int setup_personality(int persona)\n{\n\t#if HAVE_SYS_PERSONALITY_H\n\tif (persona == -1)\n\t\treturn 0;\n\n\tif (personality(persona) < 0) {\n\t\tSYSERROR(\"failed to set personality to '0x%x'\", persona);\n\t\treturn -1;\n\t}\n\n\tINFO(\"set personality to '0x%x'\", persona);\n\t#endif\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int setup_personality(int persona)\n{\n\t#if HAVE_SYS_PERSONALITY_H\n\tif (persona == -1)\n\t\treturn 0;\n\n\tif (personality(persona) < 0) {\n\t\tSYSERROR(\"failed to set personality to '0x%x'\", persona);\n\t\treturn -1;\n\t}\n\n\tINFO(\"set personality to '0x%x'\", persona);\n\t#endif\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to set environment variable for container ptys\""
          ],
          "line": 3968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"container_ttys\"",
            "lxc_conf->pty_names",
            "1"
          ],
          "line": 3967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to setup the ttys for '%s'\"",
            "name"
          ],
          "line": 3963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_tty",
          "args": [
            "lxc_conf"
          ],
          "line": 3962
        },
        "resolved": true,
        "details": {
          "function_name": "setup_tty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "976-1056",
          "snippet": "static int setup_tty(struct lxc_conf *conf)\n{\n\tconst struct lxc_tty_info *tty_info = &conf->tty_info;\n\tchar *ttydir = conf->ttydir;\n\tchar path[MAXPATHLEN], lxcpath[MAXPATHLEN];\n\tint i, ret;\n\n\tif (!conf->rootfs.path)\n\t\treturn 0;\n\n\tfor (i = 0; i < tty_info->nbtty; i++) {\n\n\t\tstruct lxc_pty_info *pty_info = &tty_info->pty_info[i];\n\n\t\tret = snprintf(path, sizeof(path), \"/dev/tty%d\", i + 1);\n\t\tif (ret >= sizeof(path)) {\n\t\t\tERROR(\"pathname too long for ttys\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (ttydir) {\n\t\t\t/* create dev/lxc/tty%d\" */\n\t\t\tret = snprintf(lxcpath, sizeof(lxcpath), \"/dev/%s/tty%d\", ttydir, i + 1);\n\t\t\tif (ret >= sizeof(lxcpath)) {\n\t\t\t\tERROR(\"pathname too long for ttys\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tret = creat(lxcpath, 0660);\n\t\t\tif (ret==-1 && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"error creating %s\", lxcpath);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (ret >= 0)\n\t\t\t\tclose(ret);\n\t\t\tret = unlink(path);\n\t\t\tif (ret && errno != ENOENT) {\n\t\t\t\tSYSERROR(\"error unlinking %s\", path);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (mount(pty_info->name, lxcpath, \"none\", MS_BIND, 0)) {\n\t\t\t\tWARN(\"failed to mount '%s'->'%s'\",\n\t\t\t\t     pty_info->name, path);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = snprintf(lxcpath, sizeof(lxcpath), \"%s/tty%d\", ttydir, i+1);\n\t\t\tif (ret >= sizeof(lxcpath)) {\n\t\t\t\tERROR(\"tty pathname too long\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tret = symlink(lxcpath, path);\n\t\t\tif (ret) {\n\t\t\t\tSYSERROR(\"failed to create symlink for tty %d\", i+1);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\t/* If we populated /dev, then we need to create /dev/ttyN */\n\t\t\tif (access(path, F_OK)) {\n\t\t\t\tret = creat(path, 0660);\n\t\t\t\tif (ret==-1) {\n\t\t\t\t\tSYSERROR(\"error creating %s\", path);\n\t\t\t\t\t/* this isn't fatal, continue */\n\t\t\t\t} else {\n\t\t\t\t\tclose(ret);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mount(pty_info->name, path, \"none\", MS_BIND, 0)) {\n\t\t\t\tSYSERROR(\"failed to mount '%s'->'%s'\", pty_info->name, path);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (!append_ptyname(&conf->pty_names, pty_info->name)) {\n\t\t\tERROR(\"Error setting up container_ttys string\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tINFO(\"%d tty(s) has been setup\", tty_info->nbtty);\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int setup_tty(struct lxc_conf *conf)\n{\n\tconst struct lxc_tty_info *tty_info = &conf->tty_info;\n\tchar *ttydir = conf->ttydir;\n\tchar path[MAXPATHLEN], lxcpath[MAXPATHLEN];\n\tint i, ret;\n\n\tif (!conf->rootfs.path)\n\t\treturn 0;\n\n\tfor (i = 0; i < tty_info->nbtty; i++) {\n\n\t\tstruct lxc_pty_info *pty_info = &tty_info->pty_info[i];\n\n\t\tret = snprintf(path, sizeof(path), \"/dev/tty%d\", i + 1);\n\t\tif (ret >= sizeof(path)) {\n\t\t\tERROR(\"pathname too long for ttys\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (ttydir) {\n\t\t\t/* create dev/lxc/tty%d\" */\n\t\t\tret = snprintf(lxcpath, sizeof(lxcpath), \"/dev/%s/tty%d\", ttydir, i + 1);\n\t\t\tif (ret >= sizeof(lxcpath)) {\n\t\t\t\tERROR(\"pathname too long for ttys\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tret = creat(lxcpath, 0660);\n\t\t\tif (ret==-1 && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"error creating %s\", lxcpath);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (ret >= 0)\n\t\t\t\tclose(ret);\n\t\t\tret = unlink(path);\n\t\t\tif (ret && errno != ENOENT) {\n\t\t\t\tSYSERROR(\"error unlinking %s\", path);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (mount(pty_info->name, lxcpath, \"none\", MS_BIND, 0)) {\n\t\t\t\tWARN(\"failed to mount '%s'->'%s'\",\n\t\t\t\t     pty_info->name, path);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = snprintf(lxcpath, sizeof(lxcpath), \"%s/tty%d\", ttydir, i+1);\n\t\t\tif (ret >= sizeof(lxcpath)) {\n\t\t\t\tERROR(\"tty pathname too long\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tret = symlink(lxcpath, path);\n\t\t\tif (ret) {\n\t\t\t\tSYSERROR(\"failed to create symlink for tty %d\", i+1);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\t/* If we populated /dev, then we need to create /dev/ttyN */\n\t\t\tif (access(path, F_OK)) {\n\t\t\t\tret = creat(path, 0660);\n\t\t\t\tif (ret==-1) {\n\t\t\t\t\tSYSERROR(\"error creating %s\", path);\n\t\t\t\t\t/* this isn't fatal, continue */\n\t\t\t\t} else {\n\t\t\t\t\tclose(ret);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mount(pty_info->name, path, \"none\", MS_BIND, 0)) {\n\t\t\t\tSYSERROR(\"failed to mount '%s'->'%s'\", pty_info->name, path);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (!append_ptyname(&conf->pty_names, pty_info->name)) {\n\t\t\tERROR(\"Error setting up container_ttys string\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tINFO(\"%d tty(s) has been setup\", tty_info->nbtty);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failure sending console info to parent\""
          ],
          "line": 3957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_ttys_to_parent",
          "args": [
            "handler"
          ],
          "line": 3956
        },
        "resolved": true,
        "details": {
          "function_name": "send_ttys_to_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3809-3836",
          "snippet": "static int send_ttys_to_parent(struct lxc_handler *handler)\n{\n\tstruct lxc_conf *conf = handler->conf;\n\tconst struct lxc_tty_info *tty_info = &conf->tty_info;\n\tint i;\n\tint sock = handler->ttysock[0];\n\n\tfor (i = 0; i < tty_info->nbtty; i++) {\n\t\tstruct lxc_pty_info *pty_info = &tty_info->pty_info[i];\n\t\tif (send_fd(sock, pty_info->slave) < 0)\n\t\t\tgoto bad;\n\t\tclose(pty_info->slave);\n\t\tpty_info->slave = -1;\n\t\tif (send_fd(sock, pty_info->master) < 0)\n\t\t\tgoto bad;\n\t\tclose(pty_info->master);\n\t\tpty_info->master = -1;\n\t}\n\n\tclose(handler->ttysock[0]);\n\tclose(handler->ttysock[1]);\n\n\treturn 0;\n\nbad:\n\tERROR(\"Error writing tty fd to parent\");\n\treturn -1;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int send_ttys_to_parent(struct lxc_handler *handler)\n{\n\tstruct lxc_conf *conf = handler->conf;\n\tconst struct lxc_tty_info *tty_info = &conf->tty_info;\n\tint i;\n\tint sock = handler->ttysock[0];\n\n\tfor (i = 0; i < tty_info->nbtty; i++) {\n\t\tstruct lxc_pty_info *pty_info = &tty_info->pty_info[i];\n\t\tif (send_fd(sock, pty_info->slave) < 0)\n\t\t\tgoto bad;\n\t\tclose(pty_info->slave);\n\t\tpty_info->slave = -1;\n\t\tif (send_fd(sock, pty_info->master) < 0)\n\t\t\tgoto bad;\n\t\tclose(pty_info->master);\n\t\tpty_info->master = -1;\n\t}\n\n\tclose(handler->ttysock[0]);\n\tclose(handler->ttysock[1]);\n\n\treturn 0;\n\nbad:\n\tERROR(\"Error writing tty fd to parent\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to create the ttys\""
          ],
          "line": 3952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_create_tty",
          "args": [
            "name",
            "lxc_conf"
          ],
          "line": 3951
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_create_tty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3410-3456",
          "snippet": "int lxc_create_tty(const char *name, struct lxc_conf *conf)\n{\n\tstruct lxc_tty_info *tty_info = &conf->tty_info;\n\tint i, ret;\n\n\t/* no tty in the configuration */\n\tif (!conf->tty)\n\t\treturn 0;\n\n\ttty_info->pty_info =\n\t\tmalloc(sizeof(*tty_info->pty_info)*conf->tty);\n\tif (!tty_info->pty_info) {\n\t\tSYSERROR(\"failed to allocate pty_info\");\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < conf->tty; i++) {\n\n\t\tstruct lxc_pty_info *pty_info = &tty_info->pty_info[i];\n\n\t\tprocess_lock();\n\t\tret = openpty(&pty_info->master, &pty_info->slave,\n\t\t\t    pty_info->name, NULL, NULL);\n\t\tprocess_unlock();\n\t\tif (ret) {\n\t\t\tSYSERROR(\"failed to create pty #%d\", i);\n\t\t\ttty_info->nbtty = i;\n\t\t\tlxc_delete_tty(tty_info);\n\t\t\treturn -1;\n\t\t}\n\n\t\tDEBUG(\"allocated pty '%s' (%d/%d)\",\n\t\t      pty_info->name, pty_info->master, pty_info->slave);\n\n\t\t/* Prevent leaking the file descriptors to the container */\n\t\tfcntl(pty_info->master, F_SETFD, FD_CLOEXEC);\n\t\tfcntl(pty_info->slave, F_SETFD, FD_CLOEXEC);\n\n\t\tpty_info->busy = 0;\n\t}\n\n\ttty_info->nbtty = conf->tty;\n\n\tINFO(\"tty's configured\");\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_create_tty(const char *name, struct lxc_conf *conf)\n{\n\tstruct lxc_tty_info *tty_info = &conf->tty_info;\n\tint i, ret;\n\n\t/* no tty in the configuration */\n\tif (!conf->tty)\n\t\treturn 0;\n\n\ttty_info->pty_info =\n\t\tmalloc(sizeof(*tty_info->pty_info)*conf->tty);\n\tif (!tty_info->pty_info) {\n\t\tSYSERROR(\"failed to allocate pty_info\");\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < conf->tty; i++) {\n\n\t\tstruct lxc_pty_info *pty_info = &tty_info->pty_info[i];\n\n\t\tprocess_lock();\n\t\tret = openpty(&pty_info->master, &pty_info->slave,\n\t\t\t    pty_info->name, NULL, NULL);\n\t\tprocess_unlock();\n\t\tif (ret) {\n\t\t\tSYSERROR(\"failed to create pty #%d\", i);\n\t\t\ttty_info->nbtty = i;\n\t\t\tlxc_delete_tty(tty_info);\n\t\t\treturn -1;\n\t\t}\n\n\t\tDEBUG(\"allocated pty '%s' (%d/%d)\",\n\t\t      pty_info->name, pty_info->master, pty_info->slave);\n\n\t\t/* Prevent leaking the file descriptors to the container */\n\t\tfcntl(pty_info->master, F_SETFD, FD_CLOEXEC);\n\t\tfcntl(pty_info->slave, F_SETFD, FD_CLOEXEC);\n\n\t\tpty_info->busy = 0;\n\t}\n\n\ttty_info->nbtty = conf->tty;\n\n\tINFO(\"tty's configured\");\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to setup the new pts instance\""
          ],
          "line": 3947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_pts",
          "args": [
            "lxc_conf->pts"
          ],
          "line": 3946
        },
        "resolved": true,
        "details": {
          "function_name": "setup_pts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1393-1438",
          "snippet": "static int setup_pts(int pts)\n{\n\tchar target[PATH_MAX];\n\n\tif (!pts)\n\t\treturn 0;\n\n\tif (!access(\"/dev/pts/ptmx\", F_OK) && umount(\"/dev/pts\")) {\n\t\tSYSERROR(\"failed to umount 'dev/pts'\");\n\t\treturn -1;\n\t}\n\n\tif (mkdir(\"/dev/pts\", 0755)) {\n\t\tif ( errno != EEXIST ) {\n\t\t    SYSERROR(\"failed to create '/dev/pts'\");\n\t\t    return -1;\n\t\t}\n\t}\n\n\tif (mount(\"devpts\", \"/dev/pts\", \"devpts\", MS_MGC_VAL,\n\t\t  \"newinstance,ptmxmode=0666,mode=0620,gid=5\")) {\n\t\tSYSERROR(\"failed to mount a new instance of '/dev/pts'\");\n\t\treturn -1;\n\t}\n\n\tif (access(\"/dev/ptmx\", F_OK)) {\n\t\tif (!symlink(\"/dev/pts/ptmx\", \"/dev/ptmx\"))\n\t\t\tgoto out;\n\t\tSYSERROR(\"failed to symlink '/dev/pts/ptmx'->'/dev/ptmx'\");\n\t\treturn -1;\n\t}\n\n\tif (realpath(\"/dev/ptmx\", target) && !strcmp(target, \"/dev/pts/ptmx\"))\n\t\tgoto out;\n\n\t/* fallback here, /dev/pts/ptmx exists just mount bind */\n\tif (mount(\"/dev/pts/ptmx\", \"/dev/ptmx\", \"none\", MS_BIND, 0)) {\n\t\tSYSERROR(\"mount failed '/dev/pts/ptmx'->'/dev/ptmx'\");\n\t\treturn -1;\n\t}\n\n\tINFO(\"created new pts instance\");\n\nout:\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int setup_pts(int pts)\n{\n\tchar target[PATH_MAX];\n\n\tif (!pts)\n\t\treturn 0;\n\n\tif (!access(\"/dev/pts/ptmx\", F_OK) && umount(\"/dev/pts\")) {\n\t\tSYSERROR(\"failed to umount 'dev/pts'\");\n\t\treturn -1;\n\t}\n\n\tif (mkdir(\"/dev/pts\", 0755)) {\n\t\tif ( errno != EEXIST ) {\n\t\t    SYSERROR(\"failed to create '/dev/pts'\");\n\t\t    return -1;\n\t\t}\n\t}\n\n\tif (mount(\"devpts\", \"/dev/pts\", \"devpts\", MS_MGC_VAL,\n\t\t  \"newinstance,ptmxmode=0666,mode=0620,gid=5\")) {\n\t\tSYSERROR(\"failed to mount a new instance of '/dev/pts'\");\n\t\treturn -1;\n\t}\n\n\tif (access(\"/dev/ptmx\", F_OK)) {\n\t\tif (!symlink(\"/dev/pts/ptmx\", \"/dev/ptmx\"))\n\t\t\tgoto out;\n\t\tSYSERROR(\"failed to symlink '/dev/pts/ptmx'->'/dev/ptmx'\");\n\t\treturn -1;\n\t}\n\n\tif (realpath(\"/dev/ptmx\", target) && !strcmp(target, \"/dev/pts/ptmx\"))\n\t\tgoto out;\n\n\t/* fallback here, /dev/pts/ptmx exists just mount bind */\n\tif (mount(\"/dev/pts/ptmx\", \"/dev/ptmx\", \"none\", MS_BIND, 0)) {\n\t\tSYSERROR(\"mount failed '/dev/pts/ptmx'->'/dev/ptmx'\");\n\t\treturn -1;\n\t}\n\n\tINFO(\"created new pts instance\");\n\nout:\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to set rootfs for '%s'\"",
            "name"
          ],
          "line": 3942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_pivot_root",
          "args": [
            "&lxc_conf->rootfs"
          ],
          "line": 3941
        },
        "resolved": true,
        "details": {
          "function_name": "setup_pivot_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1377-1391",
          "snippet": "static int setup_pivot_root(const struct lxc_rootfs *rootfs)\n{\n\tif (!rootfs->path)\n\t\treturn 0;\n\n\tif (detect_ramfs_rootfs()) {\n\t\tif (prepare_ramfs_root(rootfs->mount))\n\t\t\treturn -1;\n\t} else if (setup_rootfs_pivot_root(rootfs->mount)) {\n\t\tERROR(\"failed to setup pivot root\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int setup_pivot_root(const struct lxc_rootfs *rootfs)\n{\n\tif (!rootfs->path)\n\t\treturn 0;\n\n\tif (detect_ramfs_rootfs()) {\n\t\tif (prepare_ramfs_root(rootfs->mount))\n\t\t\treturn -1;\n\t} else if (setup_rootfs_pivot_root(rootfs->mount)) {\n\t\tERROR(\"failed to setup pivot root\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to LSM mount proc for '%s'\"",
            "name"
          ],
          "line": 3937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tmp_proc_mount",
          "args": [
            "lxc_conf"
          ],
          "line": 3936
        },
        "resolved": true,
        "details": {
          "function_name": "tmp_proc_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3634-3648",
          "snippet": "int tmp_proc_mount(struct lxc_conf *lxc_conf)\n{\n\tint mounted;\n\n\tmounted = mount_proc_if_needed(lxc_conf->rootfs.path ? lxc_conf->rootfs.mount : \"\");\n\tif (mounted == -1) {\n\t\tSYSERROR(\"failed to mount /proc in the container.\");\n\t\t/* continue only if there is no rootfs */\n\t\tif (lxc_conf->rootfs.path)\n\t\t\treturn -1;\n\t} else if (mounted == 1) {\n\t\tlxc_conf->tmp_umount_proc = 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint tmp_proc_mount(struct lxc_conf *lxc_conf)\n{\n\tint mounted;\n\n\tmounted = mount_proc_if_needed(lxc_conf->rootfs.path ? lxc_conf->rootfs.mount : \"\");\n\tif (mounted == -1) {\n\t\tSYSERROR(\"failed to mount /proc in the container.\");\n\t\t/* continue only if there is no rootfs */\n\t\tif (lxc_conf->rootfs.path)\n\t\t\treturn -1;\n\t} else if (mounted == 1) {\n\t\tlxc_conf->tmp_umount_proc = 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to setup /dev symlinks for '%s'\"",
            "name"
          ],
          "line": 3931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_dev_symlinks",
          "args": [
            "&lxc_conf->rootfs"
          ],
          "line": 3930
        },
        "resolved": true,
        "details": {
          "function_name": "setup_dev_symlinks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "918-951",
          "snippet": "static int setup_dev_symlinks(const struct lxc_rootfs *rootfs)\n{\n\tchar path[MAXPATHLEN];\n\tint ret,i;\n\tstruct stat s;\n\n\n\tfor (i = 0; i < sizeof(dev_symlinks) / sizeof(dev_symlinks[0]); i++) {\n\t\tconst struct dev_symlinks *d = &dev_symlinks[i];\n\t\tret = snprintf(path, sizeof(path), \"%s/dev/%s\", rootfs->path ? rootfs->mount : \"\", d->name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn -1;\n\n\t\t/*\n\t\t * Stat the path first.  If we don't get an error\n\t\t * accept it as is and don't try to create it\n\t\t */\n\t\tif (!stat(path, &s)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = symlink(d->oldpath, path);\n\n\t\tif (ret && errno != EEXIST) {\n\t\t\tif ( errno == EROFS ) {\n\t\t\t\tWARN(\"Warning: Read Only file system while creating %s\", path);\n\t\t\t} else {\n\t\t\t\tSYSERROR(\"Error creating %s\", path);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct dev_symlinks dev_symlinks[] = {\n\t{\"/proc/self/fd\",\t\"fd\"},\n\t{\"/proc/self/fd/0\",\t\"stdin\"},\n\t{\"/proc/self/fd/1\",\t\"stdout\"},\n\t{\"/proc/self/fd/2\",\t\"stderr\"},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic const struct dev_symlinks dev_symlinks[] = {\n\t{\"/proc/self/fd\",\t\"fd\"},\n\t{\"/proc/self/fd/0\",\t\"stdin\"},\n\t{\"/proc/self/fd/1\",\t\"stdout\"},\n\t{\"/proc/self/fd/2\",\t\"stderr\"},\n};\n\nstatic int setup_dev_symlinks(const struct lxc_rootfs *rootfs)\n{\n\tchar path[MAXPATHLEN];\n\tint ret,i;\n\tstruct stat s;\n\n\n\tfor (i = 0; i < sizeof(dev_symlinks) / sizeof(dev_symlinks[0]); i++) {\n\t\tconst struct dev_symlinks *d = &dev_symlinks[i];\n\t\tret = snprintf(path, sizeof(path), \"%s/dev/%s\", rootfs->path ? rootfs->mount : \"\", d->name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn -1;\n\n\t\t/*\n\t\t * Stat the path first.  If we don't get an error\n\t\t * accept it as is and don't try to create it\n\t\t */\n\t\tif (!stat(path, &s)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = symlink(d->oldpath, path);\n\n\t\tif (ret && errno != EEXIST) {\n\t\t\tif ( errno == EROFS ) {\n\t\t\t\tWARN(\"Warning: Read Only file system while creating %s\", path);\n\t\t\t} else {\n\t\t\t\tSYSERROR(\"Error creating %s\", path);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to setup kmsg for '%s'\"",
            "name"
          ],
          "line": 3927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_kmsg",
          "args": [
            "&lxc_conf->rootfs",
            "&lxc_conf->console"
          ],
          "line": 3926
        },
        "resolved": true,
        "details": {
          "function_name": "setup_kmsg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1580-1605",
          "snippet": "static int setup_kmsg(const struct lxc_rootfs *rootfs,\n\t\t       const struct lxc_console *console)\n{\n\tchar kpath[MAXPATHLEN];\n\tint ret;\n\n\tif (!rootfs->path)\n\t\treturn 0;\n\tret = snprintf(kpath, sizeof(kpath), \"%s/dev/kmsg\", rootfs->mount);\n\tif (ret < 0 || ret >= sizeof(kpath))\n\t\treturn -1;\n\n\tret = unlink(kpath);\n\tif (ret && errno != ENOENT) {\n\t\tSYSERROR(\"error unlinking %s\", kpath);\n\t\treturn -1;\n\t}\n\n\tret = symlink(\"console\", kpath);\n\tif (ret) {\n\t\tSYSERROR(\"failed to create symlink for kmsg\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int setup_kmsg(const struct lxc_rootfs *rootfs,\n\t\t       const struct lxc_console *console)\n{\n\tchar kpath[MAXPATHLEN];\n\tint ret;\n\n\tif (!rootfs->path)\n\t\treturn 0;\n\tret = snprintf(kpath, sizeof(kpath), \"%s/dev/kmsg\", rootfs->mount);\n\tif (ret < 0 || ret >= sizeof(kpath))\n\t\treturn -1;\n\n\tret = unlink(kpath);\n\tif (ret && errno != ENOENT) {\n\t\tSYSERROR(\"error unlinking %s\", kpath);\n\t\treturn -1;\n\t}\n\n\tret = symlink(\"console\", kpath);\n\tif (ret) {\n\t\tSYSERROR(\"failed to create symlink for kmsg\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to setup the console for '%s'\"",
            "name"
          ],
          "line": 3921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_console",
          "args": [
            "&lxc_conf->rootfs",
            "&lxc_conf->console",
            "lxc_conf->ttydir"
          ],
          "line": 3920
        },
        "resolved": true,
        "details": {
          "function_name": "setup_console",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1567-1578",
          "snippet": "static int setup_console(const struct lxc_rootfs *rootfs,\n\t\t\t const struct lxc_console *console,\n\t\t\t char *ttydir)\n{\n\t/* We don't have a rootfs, /dev/console will be shared */\n\tif (!rootfs->path)\n\t\treturn 0;\n\tif (!ttydir)\n\t\treturn setup_dev_console(rootfs, console);\n\n\treturn setup_ttydir_console(rootfs, console, ttydir);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int setup_console(const struct lxc_rootfs *rootfs,\n\t\t\t const struct lxc_console *console,\n\t\t\t char *ttydir)\n{\n\t/* We don't have a rootfs, /dev/console will be shared */\n\tif (!rootfs->path)\n\t\treturn 0;\n\tif (!ttydir)\n\t\treturn setup_dev_console(rootfs, console);\n\n\treturn setup_ttydir_console(rootfs, console, ttydir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to populate /dev in the container\""
          ],
          "line": 3915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_autodev",
          "args": [
            "&lxc_conf->rootfs",
            "mount_console"
          ],
          "line": 3914
        },
        "resolved": true,
        "details": {
          "function_name": "fill_autodev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1192-1249",
          "snippet": "static int fill_autodev(const struct lxc_rootfs *rootfs, bool mount_console)\n{\n\tint ret;\n\tchar path[MAXPATHLEN];\n\tint i;\n\tmode_t cmask;\n\n\tINFO(\"Creating initial consoles under container /dev\");\n\n\tret = snprintf(path, MAXPATHLEN, \"%s/dev\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tERROR(\"Error calculating container /dev location\");\n\t\treturn -1;\n\t}\n\n\tif (!dir_exists(path)) // ignore, just don't try to fill in\n\t\treturn 0;\n\n\tINFO(\"Populating container /dev\");\n\tcmask = umask(S_IXUSR | S_IXGRP | S_IXOTH);\n\tfor (i = 0; i < sizeof(lxc_devs) / sizeof(lxc_devs[0]); i++) {\n\t\tconst struct lxc_devs *d = &lxc_devs[i];\n\n\t\tif (!strcmp(d->name, \"console\") && !mount_console)\n\t\t\tcontinue;\n\n\t\tret = snprintf(path, MAXPATHLEN, \"%s/dev/%s\", rootfs->path ? rootfs->mount : \"\", d->name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn -1;\n\t\tret = mknod(path, d->mode, makedev(d->maj, d->min));\n\t\tif (ret && errno != EEXIST) {\n\t\t\tchar hostpath[MAXPATHLEN];\n\t\t\tFILE *pathfile;\n\n\t\t\t// Unprivileged containers cannot create devices, so\n\t\t\t// bind mount the device from the host\n\t\t\tret = snprintf(hostpath, MAXPATHLEN, \"/dev/%s\", d->name);\n\t\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\t\treturn -1;\n\t\t\tpathfile = fopen(path, \"wb\");\n\t\t\tif (!pathfile) {\n\t\t\t\tSYSERROR(\"Failed to create device mount target '%s'\", path);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfclose(pathfile);\n\t\t\tif (safe_mount(hostpath, path, 0, MS_BIND, NULL,\n\t\t\t\t\t\trootfs->path ? rootfs->mount : NULL) != 0) {\n\t\t\t\tSYSERROR(\"Failed bind mounting device %s from host into container\",\n\t\t\t\t\td->name);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\tumask(cmask);\n\n\tINFO(\"Populated container /dev\");\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct lxc_devs lxc_devs[] = {\n\t{ \"null\",\tS_IFCHR | S_IRWXU | S_IRWXG | S_IRWXO, 1, 3\t},\n\t{ \"zero\",\tS_IFCHR | S_IRWXU | S_IRWXG | S_IRWXO, 1, 5\t},\n\t{ \"full\",\tS_IFCHR | S_IRWXU | S_IRWXG | S_IRWXO, 1, 7\t},\n\t{ \"urandom\",\tS_IFCHR | S_IRWXU | S_IRWXG | S_IRWXO, 1, 9\t},\n\t{ \"random\",\tS_IFCHR | S_IRWXU | S_IRWXG | S_IRWXO, 1, 8\t},\n\t{ \"tty\",\tS_IFCHR | S_IRWXU | S_IRWXG | S_IRWXO, 5, 0\t},\n\t{ \"console\",\tS_IFCHR | S_IRUSR | S_IWUSR,\t       5, 1\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic const struct lxc_devs lxc_devs[] = {\n\t{ \"null\",\tS_IFCHR | S_IRWXU | S_IRWXG | S_IRWXO, 1, 3\t},\n\t{ \"zero\",\tS_IFCHR | S_IRWXU | S_IRWXG | S_IRWXO, 1, 5\t},\n\t{ \"full\",\tS_IFCHR | S_IRWXU | S_IRWXG | S_IRWXO, 1, 7\t},\n\t{ \"urandom\",\tS_IFCHR | S_IRWXU | S_IRWXG | S_IRWXO, 1, 9\t},\n\t{ \"random\",\tS_IFCHR | S_IRWXU | S_IRWXG | S_IRWXO, 1, 8\t},\n\t{ \"tty\",\tS_IFCHR | S_IRWXU | S_IRWXG | S_IRWXO, 5, 0\t},\n\t{ \"console\",\tS_IFCHR | S_IRUSR | S_IWUSR,\t       5, 1\t},\n};\n\nstatic int fill_autodev(const struct lxc_rootfs *rootfs, bool mount_console)\n{\n\tint ret;\n\tchar path[MAXPATHLEN];\n\tint i;\n\tmode_t cmask;\n\n\tINFO(\"Creating initial consoles under container /dev\");\n\n\tret = snprintf(path, MAXPATHLEN, \"%s/dev\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tERROR(\"Error calculating container /dev location\");\n\t\treturn -1;\n\t}\n\n\tif (!dir_exists(path)) // ignore, just don't try to fill in\n\t\treturn 0;\n\n\tINFO(\"Populating container /dev\");\n\tcmask = umask(S_IXUSR | S_IXGRP | S_IXOTH);\n\tfor (i = 0; i < sizeof(lxc_devs) / sizeof(lxc_devs[0]); i++) {\n\t\tconst struct lxc_devs *d = &lxc_devs[i];\n\n\t\tif (!strcmp(d->name, \"console\") && !mount_console)\n\t\t\tcontinue;\n\n\t\tret = snprintf(path, MAXPATHLEN, \"%s/dev/%s\", rootfs->path ? rootfs->mount : \"\", d->name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn -1;\n\t\tret = mknod(path, d->mode, makedev(d->maj, d->min));\n\t\tif (ret && errno != EEXIST) {\n\t\t\tchar hostpath[MAXPATHLEN];\n\t\t\tFILE *pathfile;\n\n\t\t\t// Unprivileged containers cannot create devices, so\n\t\t\t// bind mount the device from the host\n\t\t\tret = snprintf(hostpath, MAXPATHLEN, \"/dev/%s\", d->name);\n\t\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\t\treturn -1;\n\t\t\tpathfile = fopen(path, \"wb\");\n\t\t\tif (!pathfile) {\n\t\t\t\tSYSERROR(\"Failed to create device mount target '%s'\", path);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfclose(pathfile);\n\t\t\tif (safe_mount(hostpath, path, 0, MS_BIND, NULL,\n\t\t\t\t\t\trootfs->path ? rootfs->mount : NULL) != 0) {\n\t\t\t\tSYSERROR(\"Failed bind mounting device %s from host into container\",\n\t\t\t\t\td->name);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\tumask(cmask);\n\n\tINFO(\"Populated container /dev\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to run autodev hooks for container '%s'.\"",
            "name"
          ],
          "line": 3911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run_lxc_hooks",
          "args": [
            "name",
            "\"autodev\"",
            "lxc_conf",
            "lxcpath",
            "NULL"
          ],
          "line": 3910
        },
        "resolved": true,
        "details": {
          "function_name": "run_lxc_hooks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3995-4029",
          "snippet": "int run_lxc_hooks(const char *name, char *hook, struct lxc_conf *conf,\n\t\t  const char *lxcpath, char *argv[])\n{\n\tint which = -1;\n\tstruct lxc_list *it;\n\n\tif (strcmp(hook, \"pre-start\") == 0)\n\t\twhich = LXCHOOK_PRESTART;\n\telse if (strcmp(hook, \"pre-mount\") == 0)\n\t\twhich = LXCHOOK_PREMOUNT;\n\telse if (strcmp(hook, \"mount\") == 0)\n\t\twhich = LXCHOOK_MOUNT;\n\telse if (strcmp(hook, \"autodev\") == 0)\n\t\twhich = LXCHOOK_AUTODEV;\n\telse if (strcmp(hook, \"start\") == 0)\n\t\twhich = LXCHOOK_START;\n\telse if (strcmp(hook, \"stop\") == 0)\n\t\twhich = LXCHOOK_STOP;\n\telse if (strcmp(hook, \"post-stop\") == 0)\n\t\twhich = LXCHOOK_POSTSTOP;\n\telse if (strcmp(hook, \"clone\") == 0)\n\t\twhich = LXCHOOK_CLONE;\n\telse if (strcmp(hook, \"destroy\") == 0)\n\t\twhich = LXCHOOK_DESTROY;\n\telse\n\t\treturn -1;\n\tlxc_list_for_each(it, &conf->hooks[which]) {\n\t\tint ret;\n\t\tchar *hookname = it->elem;\n\t\tret = run_script_argv(name, \"lxc\", hookname, hook, lxcpath, argv);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint run_lxc_hooks(const char *name, char *hook, struct lxc_conf *conf,\n\t\t  const char *lxcpath, char *argv[])\n{\n\tint which = -1;\n\tstruct lxc_list *it;\n\n\tif (strcmp(hook, \"pre-start\") == 0)\n\t\twhich = LXCHOOK_PRESTART;\n\telse if (strcmp(hook, \"pre-mount\") == 0)\n\t\twhich = LXCHOOK_PREMOUNT;\n\telse if (strcmp(hook, \"mount\") == 0)\n\t\twhich = LXCHOOK_MOUNT;\n\telse if (strcmp(hook, \"autodev\") == 0)\n\t\twhich = LXCHOOK_AUTODEV;\n\telse if (strcmp(hook, \"start\") == 0)\n\t\twhich = LXCHOOK_START;\n\telse if (strcmp(hook, \"stop\") == 0)\n\t\twhich = LXCHOOK_STOP;\n\telse if (strcmp(hook, \"post-stop\") == 0)\n\t\twhich = LXCHOOK_POSTSTOP;\n\telse if (strcmp(hook, \"clone\") == 0)\n\t\twhich = LXCHOOK_CLONE;\n\telse if (strcmp(hook, \"destroy\") == 0)\n\t\twhich = LXCHOOK_DESTROY;\n\telse\n\t\treturn -1;\n\tlxc_list_for_each(it, &conf->hooks[which]) {\n\t\tint ret;\n\t\tchar *hookname = it->elem;\n\t\tret = run_script_argv(name, \"lxc\", hookname, hook, lxcpath, argv);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "lxc_conf->console.path",
            "\"none\""
          ],
          "line": 3908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to run mount hooks for container '%s'.\"",
            "name"
          ],
          "line": 3903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to setup the automatic mounts for '%s'\"",
            "name"
          ],
          "line": 3898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_mount_auto_mounts",
          "args": [
            "lxc_conf",
            "lxc_conf->auto_mounts & LXC_AUTO_CGROUP_MASK",
            "handler"
          ],
          "line": 3897
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_mount_auto_mounts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "719-845",
          "snippet": "static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_handler *handler)\n{\n\tint r;\n\tint i;\n\tstatic struct {\n\t\tint match_mask;\n\t\tint match_flag;\n\t\tconst char *source;\n\t\tconst char *destination;\n\t\tconst char *fstype;\n\t\tunsigned long flags;\n\t\tconst char *options;\n\t} default_mounts[] = {\n\t\t/* Read-only bind-mounting... In older kernels, doing that required\n\t\t * to do one MS_BIND mount and then MS_REMOUNT|MS_RDONLY the same\n\t\t * one. According to mount(2) manpage, MS_BIND honors MS_RDONLY from\n\t\t * kernel 2.6.26 onwards. However, this apparently does not work on\n\t\t * kernel 3.8. Unfortunately, on that very same kernel, doing the\n\t\t * same trick as above doesn't seem to work either, there one needs\n\t\t * to ALSO specify MS_BIND for the remount, otherwise the entire\n\t\t * fs is remounted read-only or the mount fails because it's busy...\n\t\t * MS_REMOUNT|MS_BIND|MS_RDONLY seems to work for kernels as low as\n\t\t * 2.6.32...\n\t\t */\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"proc\",                                              \"%r/proc\",                      \"proc\",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n\t\t/* proc/tty is used as a temporary placeholder for proc/sys/net which we'll move back in a few steps */\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys/net\",                                   \"%r/proc/tty\",                  NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys\",                                       \"%r/proc/sys\",                  NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \"%r/proc/sys\",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/tty\",                                       \"%r/proc/sys/net\",              NULL,       MS_MOVE,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sysrq-trigger\",                             \"%r/proc/sysrq-trigger\",        NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \"%r/proc/sysrq-trigger\",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    \"proc\",                                              \"%r/proc\",                      \"proc\",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_RW,     \"sysfs\",                                             \"%r/sys\",                       \"sysfs\",    0,                              NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_RO,     \"sysfs\",                                             \"%r/sys\",                       \"sysfs\",    MS_RDONLY,                      NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  \"sysfs\",                                             \"%r/sys\",                       \"sysfs\",    MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  \"%r/sys\",                                            \"%r/sys\",                       NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  NULL,                                                \"%r/sys\",                       NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  \"sysfs\",                                             \"%r/sys/devices/virtual/net\",   \"sysfs\",    0,                              NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  \"%r/sys/devices/virtual/net/devices/virtual/net\",    \"%r/sys/devices/virtual/net\",   NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  NULL,                                                \"%r/sys/devices/virtual/net\",   NULL,       MS_REMOUNT|MS_BIND|MS_NOSUID|MS_NODEV|MS_NOEXEC,   NULL },\n\t\t{ 0,                  0,                   NULL,                                                NULL,                           NULL,       0,                              NULL }\n\t};\n\n\tfor (i = 0; default_mounts[i].match_mask; i++) {\n\t\tif ((flags & default_mounts[i].match_mask) == default_mounts[i].match_flag) {\n\t\t\tchar *source = NULL;\n\t\t\tchar *destination = NULL;\n\t\t\tint saved_errno;\n\t\t\tunsigned long mflags;\n\n\t\t\tif (default_mounts[i].source) {\n\t\t\t\t/* will act like strdup if %r is not present */\n\t\t\t\tsource = lxc_string_replace(\"%r\", conf->rootfs.path ? conf->rootfs.mount : \"\", default_mounts[i].source);\n\t\t\t\tif (!source) {\n\t\t\t\t\tSYSERROR(\"memory allocation error\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!default_mounts[i].destination) {\n\t\t\t\tERROR(\"BUG: auto mounts destination %d was NULL\", i);\n\t\t\t\tfree(source);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t/* will act like strdup if %r is not present */\n\t\t\tdestination = lxc_string_replace(\"%r\", conf->rootfs.path ? conf->rootfs.mount : \"\", default_mounts[i].destination);\n\t\t\tif (!destination) {\n\t\t\t\tsaved_errno = errno;\n\t\t\t\tSYSERROR(\"memory allocation error\");\n\t\t\t\tfree(source);\n\t\t\t\terrno = saved_errno;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmflags = add_required_remount_flags(source, destination,\n\t\t\t\t\tdefault_mounts[i].flags);\n\t\t\tr = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);\n\t\t\tsaved_errno = errno;\n\t\t\tif (r < 0 && errno == ENOENT) {\n\t\t\t\tINFO(\"Mount source or target for %s on %s doesn't exist. Skipping.\", source, destination);\n\t\t\t\tr = 0;\n\t\t\t}\n\t\t\telse if (r < 0)\n\t\t\t\tSYSERROR(\"error mounting %s on %s flags %lu\", source, destination, mflags);\n\n\t\t\tfree(source);\n\t\t\tfree(destination);\n\t\t\tif (r < 0) {\n\t\t\t\terrno = saved_errno;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (flags & LXC_AUTO_CGROUP_MASK) {\n\t\tint cg_flags;\n\n\t\tcg_flags = flags & LXC_AUTO_CGROUP_MASK;\n\t\t/* If the type of cgroup mount was not specified, it depends on the\n\t\t * container's capabilities as to what makes sense: if we have\n\t\t * CAP_SYS_ADMIN, the read-only part can be remounted read-write\n\t\t * anyway, so we may as well default to read-write; then the admin\n\t\t * will not be given a false sense of security. (And if they really\n\t\t * want mixed r/o r/w, then they can explicitly specify :mixed.)\n\t\t * OTOH, if the container lacks CAP_SYS_ADMIN, do only default to\n\t\t * :mixed, because then the container can't remount it read-write. */\n\t\tif (cg_flags == LXC_AUTO_CGROUP_NOSPEC || cg_flags == LXC_AUTO_CGROUP_FULL_NOSPEC) {\n\t\t\tint has_sys_admin = 0;\n\t\t\tif (!lxc_list_empty(&conf->keepcaps)) {\n\t\t\t\thas_sys_admin = in_caplist(CAP_SYS_ADMIN, &conf->keepcaps);\n\t\t\t} else {\n\t\t\t\thas_sys_admin = !in_caplist(CAP_SYS_ADMIN, &conf->caps);\n\t\t\t}\n\t\t\tif (cg_flags == LXC_AUTO_CGROUP_NOSPEC) {\n\t\t\t\tcg_flags = has_sys_admin ? LXC_AUTO_CGROUP_RW : LXC_AUTO_CGROUP_MIXED;\n\t\t\t} else {\n\t\t\t\tcg_flags = has_sys_admin ? LXC_AUTO_CGROUP_FULL_RW : LXC_AUTO_CGROUP_FULL_MIXED;\n\t\t\t}\n\t\t}\n\n\t\tif (!cgroup_mount(conf->rootfs.path ? conf->rootfs.mount : \"\", handler, cg_flags)) {\n\t\t\tSYSERROR(\"error mounting /sys/fs/cgroup\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CAP_SYS_ADMIN 21"
          ],
          "globals_used": [
            "static int in_caplist(int cap, struct lxc_list *caps);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\n#define CAP_SYS_ADMIN 21\n\nstatic int in_caplist(int cap, struct lxc_list *caps);\n\nstatic int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_handler *handler)\n{\n\tint r;\n\tint i;\n\tstatic struct {\n\t\tint match_mask;\n\t\tint match_flag;\n\t\tconst char *source;\n\t\tconst char *destination;\n\t\tconst char *fstype;\n\t\tunsigned long flags;\n\t\tconst char *options;\n\t} default_mounts[] = {\n\t\t/* Read-only bind-mounting... In older kernels, doing that required\n\t\t * to do one MS_BIND mount and then MS_REMOUNT|MS_RDONLY the same\n\t\t * one. According to mount(2) manpage, MS_BIND honors MS_RDONLY from\n\t\t * kernel 2.6.26 onwards. However, this apparently does not work on\n\t\t * kernel 3.8. Unfortunately, on that very same kernel, doing the\n\t\t * same trick as above doesn't seem to work either, there one needs\n\t\t * to ALSO specify MS_BIND for the remount, otherwise the entire\n\t\t * fs is remounted read-only or the mount fails because it's busy...\n\t\t * MS_REMOUNT|MS_BIND|MS_RDONLY seems to work for kernels as low as\n\t\t * 2.6.32...\n\t\t */\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"proc\",                                              \"%r/proc\",                      \"proc\",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n\t\t/* proc/tty is used as a temporary placeholder for proc/sys/net which we'll move back in a few steps */\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys/net\",                                   \"%r/proc/tty\",                  NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys\",                                       \"%r/proc/sys\",                  NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \"%r/proc/sys\",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/tty\",                                       \"%r/proc/sys/net\",              NULL,       MS_MOVE,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sysrq-trigger\",                             \"%r/proc/sysrq-trigger\",        NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \"%r/proc/sysrq-trigger\",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    \"proc\",                                              \"%r/proc\",                      \"proc\",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_RW,     \"sysfs\",                                             \"%r/sys\",                       \"sysfs\",    0,                              NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_RO,     \"sysfs\",                                             \"%r/sys\",                       \"sysfs\",    MS_RDONLY,                      NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  \"sysfs\",                                             \"%r/sys\",                       \"sysfs\",    MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  \"%r/sys\",                                            \"%r/sys\",                       NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  NULL,                                                \"%r/sys\",                       NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  \"sysfs\",                                             \"%r/sys/devices/virtual/net\",   \"sysfs\",    0,                              NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  \"%r/sys/devices/virtual/net/devices/virtual/net\",    \"%r/sys/devices/virtual/net\",   NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  NULL,                                                \"%r/sys/devices/virtual/net\",   NULL,       MS_REMOUNT|MS_BIND|MS_NOSUID|MS_NODEV|MS_NOEXEC,   NULL },\n\t\t{ 0,                  0,                   NULL,                                                NULL,                           NULL,       0,                              NULL }\n\t};\n\n\tfor (i = 0; default_mounts[i].match_mask; i++) {\n\t\tif ((flags & default_mounts[i].match_mask) == default_mounts[i].match_flag) {\n\t\t\tchar *source = NULL;\n\t\t\tchar *destination = NULL;\n\t\t\tint saved_errno;\n\t\t\tunsigned long mflags;\n\n\t\t\tif (default_mounts[i].source) {\n\t\t\t\t/* will act like strdup if %r is not present */\n\t\t\t\tsource = lxc_string_replace(\"%r\", conf->rootfs.path ? conf->rootfs.mount : \"\", default_mounts[i].source);\n\t\t\t\tif (!source) {\n\t\t\t\t\tSYSERROR(\"memory allocation error\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!default_mounts[i].destination) {\n\t\t\t\tERROR(\"BUG: auto mounts destination %d was NULL\", i);\n\t\t\t\tfree(source);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t/* will act like strdup if %r is not present */\n\t\t\tdestination = lxc_string_replace(\"%r\", conf->rootfs.path ? conf->rootfs.mount : \"\", default_mounts[i].destination);\n\t\t\tif (!destination) {\n\t\t\t\tsaved_errno = errno;\n\t\t\t\tSYSERROR(\"memory allocation error\");\n\t\t\t\tfree(source);\n\t\t\t\terrno = saved_errno;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmflags = add_required_remount_flags(source, destination,\n\t\t\t\t\tdefault_mounts[i].flags);\n\t\t\tr = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);\n\t\t\tsaved_errno = errno;\n\t\t\tif (r < 0 && errno == ENOENT) {\n\t\t\t\tINFO(\"Mount source or target for %s on %s doesn't exist. Skipping.\", source, destination);\n\t\t\t\tr = 0;\n\t\t\t}\n\t\t\telse if (r < 0)\n\t\t\t\tSYSERROR(\"error mounting %s on %s flags %lu\", source, destination, mflags);\n\n\t\t\tfree(source);\n\t\t\tfree(destination);\n\t\t\tif (r < 0) {\n\t\t\t\terrno = saved_errno;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (flags & LXC_AUTO_CGROUP_MASK) {\n\t\tint cg_flags;\n\n\t\tcg_flags = flags & LXC_AUTO_CGROUP_MASK;\n\t\t/* If the type of cgroup mount was not specified, it depends on the\n\t\t * container's capabilities as to what makes sense: if we have\n\t\t * CAP_SYS_ADMIN, the read-only part can be remounted read-write\n\t\t * anyway, so we may as well default to read-write; then the admin\n\t\t * will not be given a false sense of security. (And if they really\n\t\t * want mixed r/o r/w, then they can explicitly specify :mixed.)\n\t\t * OTOH, if the container lacks CAP_SYS_ADMIN, do only default to\n\t\t * :mixed, because then the container can't remount it read-write. */\n\t\tif (cg_flags == LXC_AUTO_CGROUP_NOSPEC || cg_flags == LXC_AUTO_CGROUP_FULL_NOSPEC) {\n\t\t\tint has_sys_admin = 0;\n\t\t\tif (!lxc_list_empty(&conf->keepcaps)) {\n\t\t\t\thas_sys_admin = in_caplist(CAP_SYS_ADMIN, &conf->keepcaps);\n\t\t\t} else {\n\t\t\t\thas_sys_admin = !in_caplist(CAP_SYS_ADMIN, &conf->caps);\n\t\t\t}\n\t\t\tif (cg_flags == LXC_AUTO_CGROUP_NOSPEC) {\n\t\t\t\tcg_flags = has_sys_admin ? LXC_AUTO_CGROUP_RW : LXC_AUTO_CGROUP_MIXED;\n\t\t\t} else {\n\t\t\t\tcg_flags = has_sys_admin ? LXC_AUTO_CGROUP_FULL_RW : LXC_AUTO_CGROUP_FULL_MIXED;\n\t\t\t}\n\t\t}\n\n\t\tif (!cgroup_mount(conf->rootfs.path ? conf->rootfs.mount : \"\", handler, cg_flags)) {\n\t\t\tSYSERROR(\"error mounting /sys/fs/cgroup\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_execute_bind_init",
          "args": [
            "lxc_conf"
          ],
          "line": 3891
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_execute_bind_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3692-3734",
          "snippet": "void lxc_execute_bind_init(struct lxc_conf *conf)\n{\n\tint ret;\n\tchar path[PATH_MAX], destpath[PATH_MAX], *p;\n\n\t/* If init exists in the container, don't bind mount a static one */\n\tp = choose_init(conf->rootfs.mount);\n\tif (p) {\n\t\tfree(p);\n\t\treturn;\n\t}\n\n\tret = snprintf(path, PATH_MAX, SBINDIR \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Path name too long searching for lxc.init.static\");\n\t\treturn;\n\t}\n\n\tif (!file_exists(path)) {\n\t\tINFO(\"%s does not exist on host\", path);\n\t\treturn;\n\t}\n\n\tret = snprintf(destpath, PATH_MAX, \"%s%s\", conf->rootfs.mount, \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Path name too long for container's lxc.init.static\");\n\t\treturn;\n\t}\n\n\tif (!file_exists(destpath)) {\n\t\tFILE * pathfile = fopen(destpath, \"wb\");\n\t\tif (!pathfile) {\n\t\t\tSYSERROR(\"Failed to create mount target '%s'\", destpath);\n\t\t\treturn;\n\t\t}\n\t\tfclose(pathfile);\n\t}\n\n\tret = safe_mount(path, destpath, \"none\", MS_BIND, NULL, conf->rootfs.mount);\n\tif (ret < 0)\n\t\tSYSERROR(\"Failed to bind lxc.init.static into container\");\n\tINFO(\"lxc.init.static bound into container at %s\", path);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid lxc_execute_bind_init(struct lxc_conf *conf)\n{\n\tint ret;\n\tchar path[PATH_MAX], destpath[PATH_MAX], *p;\n\n\t/* If init exists in the container, don't bind mount a static one */\n\tp = choose_init(conf->rootfs.mount);\n\tif (p) {\n\t\tfree(p);\n\t\treturn;\n\t}\n\n\tret = snprintf(path, PATH_MAX, SBINDIR \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Path name too long searching for lxc.init.static\");\n\t\treturn;\n\t}\n\n\tif (!file_exists(path)) {\n\t\tINFO(\"%s does not exist on host\", path);\n\t\treturn;\n\t}\n\n\tret = snprintf(destpath, PATH_MAX, \"%s%s\", conf->rootfs.mount, \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Path name too long for container's lxc.init.static\");\n\t\treturn;\n\t}\n\n\tif (!file_exists(destpath)) {\n\t\tFILE * pathfile = fopen(destpath, \"wb\");\n\t\tif (!pathfile) {\n\t\t\tSYSERROR(\"Failed to create mount target '%s'\", destpath);\n\t\t\treturn;\n\t\t}\n\t\tfclose(pathfile);\n\t}\n\n\tret = safe_mount(path, destpath, \"none\", MS_BIND, NULL, conf->rootfs.mount);\n\tif (ret < 0)\n\t\tSYSERROR(\"Failed to bind lxc.init.static into container\");\n\tINFO(\"lxc.init.static bound into container at %s\", path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify_start_hooks",
          "args": [
            "lxc_conf"
          ],
          "line": 3887
        },
        "resolved": true,
        "details": {
          "function_name": "verify_start_hooks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3771-3794",
          "snippet": "static bool verify_start_hooks(struct lxc_conf *conf)\n{\n\tstruct lxc_list *it;\n\tchar path[MAXPATHLEN];\n\tlxc_list_for_each(it, &conf->hooks[LXCHOOK_START]) {\n\t\tchar *hookname = it->elem;\n\t\tstruct stat st;\n\t\tint ret;\n\n\t\tret = snprintf(path, MAXPATHLEN, \"%s%s\",\n\t\t\tconf->rootfs.path ? conf->rootfs.mount : \"\", hookname);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn false;\n\t\tret = stat(path, &st);\n\t\tif (ret) {\n\t\t\tSYSERROR(\"Start hook %s not found in container\",\n\t\t\t\t\thookname);\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic bool verify_start_hooks(struct lxc_conf *conf)\n{\n\tstruct lxc_list *it;\n\tchar path[MAXPATHLEN];\n\tlxc_list_for_each(it, &conf->hooks[LXCHOOK_START]) {\n\t\tchar *hookname = it->elem;\n\t\tstruct stat st;\n\t\tint ret;\n\n\t\tret = snprintf(path, MAXPATHLEN, \"%s%s\",\n\t\t\tconf->rootfs.path ? conf->rootfs.mount : \"\", hookname);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn false;\n\t\tret = stat(path, &st);\n\t\tif (ret) {\n\t\t\tSYSERROR(\"Start hook %s not found in container\",\n\t\t\t\t\thookname);\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to setup the mount entries for '%s'\"",
            "name"
          ],
          "line": 3882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_mount_entries",
          "args": [
            "&lxc_conf->rootfs",
            "&lxc_conf->mount_list",
            "name",
            "lxcpath"
          ],
          "line": 3881
        },
        "resolved": true,
        "details": {
          "function_name": "setup_mount_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "2051-2066",
          "snippet": "static int setup_mount_entries(const struct lxc_rootfs *rootfs,\n\t\t\t       struct lxc_list *mount, const char *lxc_name,\n\t\t\t       const char *lxc_path)\n{\n\tFILE *file;\n\tint ret;\n\n\tfile = make_anonymous_mount_file(mount);\n\tif (!file)\n\t\treturn -1;\n\n\tret = mount_file_entries(rootfs, file, lxc_name, lxc_path);\n\n\tfclose(file);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int setup_mount_entries(const struct lxc_rootfs *rootfs,\n\t\t\t       struct lxc_list *mount, const char *lxc_name,\n\t\t\t       const char *lxc_path)\n{\n\tFILE *file;\n\tint ret;\n\n\tfile = make_anonymous_mount_file(mount);\n\tif (!file)\n\t\treturn -1;\n\n\tret = mount_file_entries(rootfs, file, lxc_name, lxc_path);\n\n\tfclose(file);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to setup the mounts for '%s'\"",
            "name"
          ],
          "line": 3877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to setup the automatic mounts for '%s'\"",
            "name"
          ],
          "line": 3872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to mount /dev in the container\""
          ],
          "line": 3863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount_autodev",
          "args": [
            "name",
            "&lxc_conf->rootfs",
            "lxcpath"
          ],
          "line": 3862
        },
        "resolved": true,
        "details": {
          "function_name": "mount_autodev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1124-1173",
          "snippet": "static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, const char *lxcpath)\n{\n\tint ret;\n\tsize_t clen;\n\tchar *path;\n\n\tINFO(\"Mounting container /dev\");\n\n\t/* $(rootfs->mount) + \"/dev/pts\" + '\\0' */\n\tclen = (rootfs->path ? strlen(rootfs->mount) : 0) + 9;\n\tpath = alloca(clen);\n\n\tret = snprintf(path, clen, \"%s/dev\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= clen)\n\t\treturn -1;\n\n\tif (!dir_exists(path)) {\n\t\tWARN(\"No /dev in container.\");\n\t\tWARN(\"Proceeding without autodev setup\");\n\t\treturn 0;\n\t}\n\n\tret = safe_mount(\"none\", path, \"tmpfs\", 0, \"size=500000,mode=755\",\n\t\t\trootfs->path ? rootfs->mount : NULL);\n\tif (ret != 0) {\n\t\tSYSERROR(\"Failed mounting tmpfs onto %s\\n\", path);\n\t\treturn -1;\n\t}\n\n\tINFO(\"Mounted tmpfs onto %s\",  path);\n\n\tret = snprintf(path, clen, \"%s/dev/pts\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= clen)\n\t\treturn -1;\n\n\t/*\n\t * If we are running on a devtmpfs mapping, dev/pts may already exist.\n\t * If not, then create it and exit if that fails...\n\t */\n\tif (!dir_exists(path)) {\n\t\tret = mkdir(path, S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);\n\t\tif (ret) {\n\t\t\tSYSERROR(\"Failed to create /dev/pts in container\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tINFO(\"Mounted container /dev\");\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, const char *lxcpath)\n{\n\tint ret;\n\tsize_t clen;\n\tchar *path;\n\n\tINFO(\"Mounting container /dev\");\n\n\t/* $(rootfs->mount) + \"/dev/pts\" + '\\0' */\n\tclen = (rootfs->path ? strlen(rootfs->mount) : 0) + 9;\n\tpath = alloca(clen);\n\n\tret = snprintf(path, clen, \"%s/dev\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= clen)\n\t\treturn -1;\n\n\tif (!dir_exists(path)) {\n\t\tWARN(\"No /dev in container.\");\n\t\tWARN(\"Proceeding without autodev setup\");\n\t\treturn 0;\n\t}\n\n\tret = safe_mount(\"none\", path, \"tmpfs\", 0, \"size=500000,mode=755\",\n\t\t\trootfs->path ? rootfs->mount : NULL);\n\tif (ret != 0) {\n\t\tSYSERROR(\"Failed mounting tmpfs onto %s\\n\", path);\n\t\treturn -1;\n\t}\n\n\tINFO(\"Mounted tmpfs onto %s\",  path);\n\n\tret = snprintf(path, clen, \"%s/dev/pts\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= clen)\n\t\treturn -1;\n\n\t/*\n\t * If we are running on a devtmpfs mapping, dev/pts may already exist.\n\t * If not, then create it and exit if that fails...\n\t */\n\tif (!dir_exists(path)) {\n\t\tret = mkdir(path, S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);\n\t\tif (ret) {\n\t\t\tSYSERROR(\"Failed to create /dev/pts in container\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tINFO(\"Mounted container /dev\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to setup the network for '%s'\"",
            "name"
          ],
          "line": 3857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_network",
          "args": [
            "&lxc_conf->network"
          ],
          "line": 3856
        },
        "resolved": true,
        "details": {
          "function_name": "setup_network",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "2457-2476",
          "snippet": "static int setup_network(struct lxc_list *network)\n{\n\tstruct lxc_list *iterator;\n\tstruct lxc_netdev *netdev;\n\n\tlxc_list_for_each(iterator, network) {\n\n\t\tnetdev = iterator->elem;\n\n\t\tif (setup_netdev(netdev)) {\n\t\t\tERROR(\"failed to setup netdev\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!lxc_list_empty(network))\n\t\tINFO(\"network has been setup\");\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_none(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_none(struct lxc_handler *, struct lxc_netdev *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_none(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_none(struct lxc_handler *, struct lxc_netdev *);\n\nstatic int setup_network(struct lxc_list *network)\n{\n\tstruct lxc_list *iterator;\n\tstruct lxc_netdev *netdev;\n\n\tlxc_list_for_each(iterator, network) {\n\n\t\tnetdev = iterator->elem;\n\n\t\tif (setup_netdev(netdev)) {\n\t\t\tERROR(\"failed to setup netdev\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!lxc_list_empty(network))\n\t\tINFO(\"network has been setup\");\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to setup the utsname for '%s'\"",
            "name"
          ],
          "line": 3851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_utsname",
          "args": [
            "lxc_conf->utsname"
          ],
          "line": 3850
        },
        "resolved": true,
        "details": {
          "function_name": "setup_utsname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "891-904",
          "snippet": "static int setup_utsname(struct utsname *utsname)\n{\n\tif (!utsname)\n\t\treturn 0;\n\n\tif (sethostname(utsname->nodename, strlen(utsname->nodename))) {\n\t\tSYSERROR(\"failed to set the hostname to '%s'\", utsname->nodename);\n\t\treturn -1;\n\t}\n\n\tINFO(\"'%s' hostname has been setup\", utsname->nodename);\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int setup_utsname(struct utsname *utsname)\n{\n\tif (!utsname)\n\t\treturn 0;\n\n\tif (sethostname(utsname->nodename, strlen(utsname->nodename))) {\n\t\tSYSERROR(\"failed to set the hostname to '%s'\", utsname->nodename);\n\t\treturn -1;\n\t}\n\n\tINFO(\"'%s' hostname has been setup\", utsname->nodename);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error setting up rootfs mount after spawn\""
          ],
          "line": 3845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_rootfs_setup",
          "args": [
            "lxc_conf",
            "name",
            "lxcpath"
          ],
          "line": 3844
        },
        "resolved": true,
        "details": {
          "function_name": "do_rootfs_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3740-3769",
          "snippet": "int do_rootfs_setup(struct lxc_conf *conf, const char *name, const char *lxcpath)\n{\n\tif (conf->rootfs_setup) {\n\t\t/*\n\t\t * rootfs was set up in another namespace.  bind-mount it\n\t\t * to give us a mount in our own ns so we can pivot_root to it\n\t\t */\n\t\tconst char *path = conf->rootfs.mount;\n\t\tif (mount(path, path, \"rootfs\", MS_BIND, NULL) < 0) {\n\t\t\tERROR(\"Failed to bind-mount container / onto itself\");\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tremount_all_slave();\n\n\tif (run_lxc_hooks(name, \"pre-mount\", conf, lxcpath, NULL)) {\n\t\tERROR(\"failed to run pre-mount hooks for container '%s'.\", name);\n\t\treturn -1;\n\t}\n\n\tif (setup_rootfs(conf)) {\n\t\tERROR(\"failed to setup rootfs for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tconf->rootfs_setup = true;\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint do_rootfs_setup(struct lxc_conf *conf, const char *name, const char *lxcpath)\n{\n\tif (conf->rootfs_setup) {\n\t\t/*\n\t\t * rootfs was set up in another namespace.  bind-mount it\n\t\t * to give us a mount in our own ns so we can pivot_root to it\n\t\t */\n\t\tconst char *path = conf->rootfs.mount;\n\t\tif (mount(path, path, \"rootfs\", MS_BIND, NULL) < 0) {\n\t\t\tERROR(\"Failed to bind-mount container / onto itself\");\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tremount_all_slave();\n\n\tif (run_lxc_hooks(name, \"pre-mount\", conf, lxcpath, NULL)) {\n\t\tERROR(\"failed to run pre-mount hooks for container '%s'.\", name);\n\t\treturn -1;\n\t}\n\n\tif (setup_rootfs(conf)) {\n\t\tERROR(\"failed to setup rootfs for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tconf->rootfs_setup = true;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int in_caplist(int cap, struct lxc_list *caps);\n\nint lxc_setup(struct lxc_handler *handler)\n{\n\tconst char *name = handler->name;\n\tstruct lxc_conf *lxc_conf = handler->conf;\n\tconst char *lxcpath = handler->lxcpath;\n\n\tif (do_rootfs_setup(lxc_conf, name, lxcpath) < 0) {\n\t\tERROR(\"Error setting up rootfs mount after spawn\");\n\t\treturn -1;\n\t}\n\n\tif (lxc_conf->inherit_ns_fd[LXC_NS_UTS] == -1) {\n\t\tif (setup_utsname(lxc_conf->utsname)) {\n\t\t\tERROR(\"failed to setup the utsname for '%s'\", name);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (setup_network(&lxc_conf->network)) {\n\t\tERROR(\"failed to setup the network for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tif (lxc_conf->autodev > 0) {\n\t\tif (mount_autodev(name, &lxc_conf->rootfs, lxcpath)) {\n\t\t\tERROR(\"failed to mount /dev in the container\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* do automatic mounts (mainly /proc and /sys), but exclude\n\t * those that need to wait until other stuff has finished\n\t */\n\tif (lxc_mount_auto_mounts(lxc_conf, lxc_conf->auto_mounts & ~LXC_AUTO_CGROUP_MASK, handler) < 0) {\n\t\tERROR(\"failed to setup the automatic mounts for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tif (setup_mount(&lxc_conf->rootfs, lxc_conf->fstab, name, lxcpath)) {\n\t\tERROR(\"failed to setup the mounts for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tif (!lxc_list_empty(&lxc_conf->mount_list) && setup_mount_entries(&lxc_conf->rootfs, &lxc_conf->mount_list, name, lxcpath)) {\n\t\tERROR(\"failed to setup the mount entries for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\t/* Make sure any start hooks are in the container */\n\tif (!verify_start_hooks(lxc_conf))\n\t\treturn -1;\n\n\tif (lxc_conf->is_execute)\n\t\tlxc_execute_bind_init(lxc_conf);\n\n\t/* now mount only cgroup, if wanted;\n\t * before, /sys could not have been mounted\n\t * (is either mounted automatically or via fstab entries)\n\t */\n\tif (lxc_mount_auto_mounts(lxc_conf, lxc_conf->auto_mounts & LXC_AUTO_CGROUP_MASK, handler) < 0) {\n\t\tERROR(\"failed to setup the automatic mounts for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tif (run_lxc_hooks(name, \"mount\", lxc_conf, lxcpath, NULL)) {\n\t\tERROR(\"failed to run mount hooks for container '%s'.\", name);\n\t\treturn -1;\n\t}\n\n\tif (lxc_conf->autodev > 0) {\n\t\tbool mount_console = lxc_conf->console.path && !strcmp(lxc_conf->console.path, \"none\");\n\n\t\tif (run_lxc_hooks(name, \"autodev\", lxc_conf, lxcpath, NULL)) {\n\t\t\tERROR(\"failed to run autodev hooks for container '%s'.\", name);\n\t\t\treturn -1;\n\t\t}\n\t\tif (fill_autodev(&lxc_conf->rootfs, mount_console)) {\n\t\t\tERROR(\"failed to populate /dev in the container\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!lxc_conf->is_execute && setup_console(&lxc_conf->rootfs, &lxc_conf->console, lxc_conf->ttydir)) {\n\t\tERROR(\"failed to setup the console for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tif (lxc_conf->kmsg) {\n\t\tif (setup_kmsg(&lxc_conf->rootfs, &lxc_conf->console))  // don't fail\n\t\t\tERROR(\"failed to setup kmsg for '%s'\", name);\n\t}\n\n\tif (!lxc_conf->is_execute && setup_dev_symlinks(&lxc_conf->rootfs)) {\n\t\tERROR(\"failed to setup /dev symlinks for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\t/* mount /proc if it's not already there */\n\tif (tmp_proc_mount(lxc_conf) < 0) {\n\t\tERROR(\"failed to LSM mount proc for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tif (setup_pivot_root(&lxc_conf->rootfs)) {\n\t\tERROR(\"failed to set rootfs for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tif (setup_pts(lxc_conf->pts)) {\n\t\tERROR(\"failed to setup the new pts instance\");\n\t\treturn -1;\n\t}\n\n\tif (lxc_create_tty(name, lxc_conf)) {\n\t\tERROR(\"failed to create the ttys\");\n\t\treturn -1;\n\t}\n\n\tif (send_ttys_to_parent(handler) < 0) {\n\t\tERROR(\"failure sending console info to parent\");\n\t\treturn -1;\n\t}\n\n\n\tif (!lxc_conf->is_execute && setup_tty(lxc_conf)) {\n\t\tERROR(\"failed to setup the ttys for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tif (lxc_conf->pty_names && setenv(\"container_ttys\", lxc_conf->pty_names, 1))\n\t\tSYSERROR(\"failed to set environment variable for container ptys\");\n\n\n\tif (setup_personality(lxc_conf->personality)) {\n\t\tERROR(\"failed to setup personality\");\n\t\treturn -1;\n\t}\n\n\tif (!lxc_list_empty(&lxc_conf->keepcaps)) {\n\t\tif (!lxc_list_empty(&lxc_conf->caps)) {\n\t\t\tERROR(\"Container requests lxc.cap.drop and lxc.cap.keep: either use lxc.cap.drop or lxc.cap.keep, not both.\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (dropcaps_except(&lxc_conf->keepcaps)) {\n\t\t\tERROR(\"failed to keep requested caps\");\n\t\t\treturn -1;\n\t\t}\n\t} else if (setup_caps(&lxc_conf->caps)) {\n\t\tERROR(\"failed to drop capabilities\");\n\t\treturn -1;\n\t}\n\n\tNOTICE(\"'%s' is setup.\", name);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "send_ttys_to_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "3809-3836",
    "snippet": "static int send_ttys_to_parent(struct lxc_handler *handler)\n{\n\tstruct lxc_conf *conf = handler->conf;\n\tconst struct lxc_tty_info *tty_info = &conf->tty_info;\n\tint i;\n\tint sock = handler->ttysock[0];\n\n\tfor (i = 0; i < tty_info->nbtty; i++) {\n\t\tstruct lxc_pty_info *pty_info = &tty_info->pty_info[i];\n\t\tif (send_fd(sock, pty_info->slave) < 0)\n\t\t\tgoto bad;\n\t\tclose(pty_info->slave);\n\t\tpty_info->slave = -1;\n\t\tif (send_fd(sock, pty_info->master) < 0)\n\t\t\tgoto bad;\n\t\tclose(pty_info->master);\n\t\tpty_info->master = -1;\n\t}\n\n\tclose(handler->ttysock[0]);\n\tclose(handler->ttysock[1]);\n\n\treturn 0;\n\nbad:\n\tERROR(\"Error writing tty fd to parent\");\n\treturn -1;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error writing tty fd to parent\""
          ],
          "line": 3834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "handler->ttysock[1]"
          ],
          "line": 3829
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_fd",
          "args": [
            "sock",
            "pty_info->master"
          ],
          "line": 3822
        },
        "resolved": true,
        "details": {
          "function_name": "send_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3796-3807",
          "snippet": "static int send_fd(int sock, int fd)\n{\n\tint ret = lxc_abstract_unix_send_fd(sock, fd, NULL, 0);\n\n\n\tif (ret < 0) {\n\t\tSYSERROR(\"Error sending tty fd to parent\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int send_fd(int sock, int fd)\n{\n\tint ret = lxc_abstract_unix_send_fd(sock, fd, NULL, 0);\n\n\n\tif (ret < 0) {\n\t\tSYSERROR(\"Error sending tty fd to parent\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int send_ttys_to_parent(struct lxc_handler *handler)\n{\n\tstruct lxc_conf *conf = handler->conf;\n\tconst struct lxc_tty_info *tty_info = &conf->tty_info;\n\tint i;\n\tint sock = handler->ttysock[0];\n\n\tfor (i = 0; i < tty_info->nbtty; i++) {\n\t\tstruct lxc_pty_info *pty_info = &tty_info->pty_info[i];\n\t\tif (send_fd(sock, pty_info->slave) < 0)\n\t\t\tgoto bad;\n\t\tclose(pty_info->slave);\n\t\tpty_info->slave = -1;\n\t\tif (send_fd(sock, pty_info->master) < 0)\n\t\t\tgoto bad;\n\t\tclose(pty_info->master);\n\t\tpty_info->master = -1;\n\t}\n\n\tclose(handler->ttysock[0]);\n\tclose(handler->ttysock[1]);\n\n\treturn 0;\n\nbad:\n\tERROR(\"Error writing tty fd to parent\");\n\treturn -1;\n}"
  },
  {
    "function_name": "send_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "3796-3807",
    "snippet": "static int send_fd(int sock, int fd)\n{\n\tint ret = lxc_abstract_unix_send_fd(sock, fd, NULL, 0);\n\n\n\tif (ret < 0) {\n\t\tSYSERROR(\"Error sending tty fd to parent\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error sending tty fd to parent\""
          ],
          "line": 3802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_abstract_unix_send_fd",
          "args": [
            "sock",
            "fd",
            "NULL",
            "0"
          ],
          "line": 3798
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_send_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "134-162",
          "snippet": "int lxc_abstract_unix_send_fd(int fd, int sendfd, void *data, size_t size)\n{\n\tstruct msghdr msg = { 0 };\n\tstruct iovec iov;\n\tstruct cmsghdr *cmsg;\n\tchar cmsgbuf[CMSG_SPACE(sizeof(int))];\n\tchar buf[1];\n\tint *val;\n\n\tmsg.msg_control = cmsgbuf;\n\tmsg.msg_controllen = sizeof(cmsgbuf);\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(int));\n\tcmsg->cmsg_level = SOL_SOCKET;\n\tcmsg->cmsg_type = SCM_RIGHTS;\n\tval = (int *)(CMSG_DATA(cmsg));\n\t*val = sendfd;\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_namelen = 0;\n\n\tiov.iov_base = data ? data : buf;\n\tiov.iov_len = data ? size : sizeof(buf);\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\treturn sendmsg(fd, &msg, MSG_NOSIGNAL);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_send_fd(int fd, int sendfd, void *data, size_t size)\n{\n\tstruct msghdr msg = { 0 };\n\tstruct iovec iov;\n\tstruct cmsghdr *cmsg;\n\tchar cmsgbuf[CMSG_SPACE(sizeof(int))];\n\tchar buf[1];\n\tint *val;\n\n\tmsg.msg_control = cmsgbuf;\n\tmsg.msg_controllen = sizeof(cmsgbuf);\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(int));\n\tcmsg->cmsg_level = SOL_SOCKET;\n\tcmsg->cmsg_type = SCM_RIGHTS;\n\tval = (int *)(CMSG_DATA(cmsg));\n\t*val = sendfd;\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_namelen = 0;\n\n\tiov.iov_base = data ? data : buf;\n\tiov.iov_len = data ? size : sizeof(buf);\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\treturn sendmsg(fd, &msg, MSG_NOSIGNAL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int send_fd(int sock, int fd)\n{\n\tint ret = lxc_abstract_unix_send_fd(sock, fd, NULL, 0);\n\n\n\tif (ret < 0) {\n\t\tSYSERROR(\"Error sending tty fd to parent\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "verify_start_hooks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "3771-3794",
    "snippet": "static bool verify_start_hooks(struct lxc_conf *conf)\n{\n\tstruct lxc_list *it;\n\tchar path[MAXPATHLEN];\n\tlxc_list_for_each(it, &conf->hooks[LXCHOOK_START]) {\n\t\tchar *hookname = it->elem;\n\t\tstruct stat st;\n\t\tint ret;\n\n\t\tret = snprintf(path, MAXPATHLEN, \"%s%s\",\n\t\t\tconf->rootfs.path ? conf->rootfs.mount : \"\", hookname);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn false;\n\t\tret = stat(path, &st);\n\t\tif (ret) {\n\t\t\tSYSERROR(\"Start hook %s not found in container\",\n\t\t\t\t\thookname);\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Start hook %s not found in container\"",
            "hookname"
          ],
          "line": 3786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "path",
            "&st"
          ],
          "line": 3784
        },
        "resolved": true,
        "details": {
          "function_name": "freezer_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/freezer.c",
          "lines": "42-51",
          "snippet": "lxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}",
          "includes": [
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"monitor.h\"",
            "#include \"state.h\"",
            "#include \"error.h\"",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxc.h\"\n#include \"log.h\"\n#include \"monitor.h\"\n#include \"state.h\"\n#include \"error.h\"\n#include <sys/param.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nlxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "MAXPATHLEN",
            "\"%s%s\"",
            "conf->rootfs.path ? conf->rootfs.mount : \"\"",
            "hookname"
          ],
          "line": 3780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "it",
            "&conf->hooks[LXCHOOK_START]"
          ],
          "line": 3775
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic bool verify_start_hooks(struct lxc_conf *conf)\n{\n\tstruct lxc_list *it;\n\tchar path[MAXPATHLEN];\n\tlxc_list_for_each(it, &conf->hooks[LXCHOOK_START]) {\n\t\tchar *hookname = it->elem;\n\t\tstruct stat st;\n\t\tint ret;\n\n\t\tret = snprintf(path, MAXPATHLEN, \"%s%s\",\n\t\t\tconf->rootfs.path ? conf->rootfs.mount : \"\", hookname);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn false;\n\t\tret = stat(path, &st);\n\t\tif (ret) {\n\t\t\tSYSERROR(\"Start hook %s not found in container\",\n\t\t\t\t\thookname);\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "do_rootfs_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "3740-3769",
    "snippet": "int do_rootfs_setup(struct lxc_conf *conf, const char *name, const char *lxcpath)\n{\n\tif (conf->rootfs_setup) {\n\t\t/*\n\t\t * rootfs was set up in another namespace.  bind-mount it\n\t\t * to give us a mount in our own ns so we can pivot_root to it\n\t\t */\n\t\tconst char *path = conf->rootfs.mount;\n\t\tif (mount(path, path, \"rootfs\", MS_BIND, NULL) < 0) {\n\t\t\tERROR(\"Failed to bind-mount container / onto itself\");\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tremount_all_slave();\n\n\tif (run_lxc_hooks(name, \"pre-mount\", conf, lxcpath, NULL)) {\n\t\tERROR(\"failed to run pre-mount hooks for container '%s'.\", name);\n\t\treturn -1;\n\t}\n\n\tif (setup_rootfs(conf)) {\n\t\tERROR(\"failed to setup rootfs for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tconf->rootfs_setup = true;\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to setup rootfs for '%s'\"",
            "name"
          ],
          "line": 3763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_rootfs",
          "args": [
            "conf"
          ],
          "line": 3762
        },
        "resolved": true,
        "details": {
          "function_name": "setup_rootfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1251-1286",
          "snippet": "static int setup_rootfs(struct lxc_conf *conf)\n{\n\tconst struct lxc_rootfs *rootfs = &conf->rootfs;\n\n\tif (!rootfs->path) {\n\t\tif (mount(\"\", \"/\", NULL, MS_SLAVE|MS_REC, 0)) {\n\t\t\tSYSERROR(\"Failed to make / rslave\");\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (access(rootfs->mount, F_OK)) {\n\t\tSYSERROR(\"failed to access to '%s', check it is present\",\n\t\t\t rootfs->mount);\n\t\treturn -1;\n\t}\n\n\t// First try mounting rootfs using a bdev\n\tstruct bdev *bdev = bdev_init(conf, rootfs->path, rootfs->mount, rootfs->options);\n\tif (bdev && bdev->ops->mount(bdev) == 0) {\n\t\tbdev_put(bdev);\n\t\tDEBUG(\"mounted '%s' on '%s'\", rootfs->path, rootfs->mount);\n\t\treturn 0;\n\t}\n\tif (bdev)\n\t\tbdev_put(bdev);\n\tif (mount_rootfs(rootfs->path, rootfs->mount, rootfs->options)) {\n\t\tERROR(\"failed to mount rootfs\");\n\t\treturn -1;\n\t}\n\n\tDEBUG(\"mounted '%s' on '%s'\", rootfs->path, rootfs->mount);\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int setup_rootfs(struct lxc_conf *conf)\n{\n\tconst struct lxc_rootfs *rootfs = &conf->rootfs;\n\n\tif (!rootfs->path) {\n\t\tif (mount(\"\", \"/\", NULL, MS_SLAVE|MS_REC, 0)) {\n\t\t\tSYSERROR(\"Failed to make / rslave\");\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (access(rootfs->mount, F_OK)) {\n\t\tSYSERROR(\"failed to access to '%s', check it is present\",\n\t\t\t rootfs->mount);\n\t\treturn -1;\n\t}\n\n\t// First try mounting rootfs using a bdev\n\tstruct bdev *bdev = bdev_init(conf, rootfs->path, rootfs->mount, rootfs->options);\n\tif (bdev && bdev->ops->mount(bdev) == 0) {\n\t\tbdev_put(bdev);\n\t\tDEBUG(\"mounted '%s' on '%s'\", rootfs->path, rootfs->mount);\n\t\treturn 0;\n\t}\n\tif (bdev)\n\t\tbdev_put(bdev);\n\tif (mount_rootfs(rootfs->path, rootfs->mount, rootfs->options)) {\n\t\tERROR(\"failed to mount rootfs\");\n\t\treturn -1;\n\t}\n\n\tDEBUG(\"mounted '%s' on '%s'\", rootfs->path, rootfs->mount);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to run pre-mount hooks for container '%s'.\"",
            "name"
          ],
          "line": 3758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run_lxc_hooks",
          "args": [
            "name",
            "\"pre-mount\"",
            "conf",
            "lxcpath",
            "NULL"
          ],
          "line": 3757
        },
        "resolved": true,
        "details": {
          "function_name": "run_lxc_hooks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3995-4029",
          "snippet": "int run_lxc_hooks(const char *name, char *hook, struct lxc_conf *conf,\n\t\t  const char *lxcpath, char *argv[])\n{\n\tint which = -1;\n\tstruct lxc_list *it;\n\n\tif (strcmp(hook, \"pre-start\") == 0)\n\t\twhich = LXCHOOK_PRESTART;\n\telse if (strcmp(hook, \"pre-mount\") == 0)\n\t\twhich = LXCHOOK_PREMOUNT;\n\telse if (strcmp(hook, \"mount\") == 0)\n\t\twhich = LXCHOOK_MOUNT;\n\telse if (strcmp(hook, \"autodev\") == 0)\n\t\twhich = LXCHOOK_AUTODEV;\n\telse if (strcmp(hook, \"start\") == 0)\n\t\twhich = LXCHOOK_START;\n\telse if (strcmp(hook, \"stop\") == 0)\n\t\twhich = LXCHOOK_STOP;\n\telse if (strcmp(hook, \"post-stop\") == 0)\n\t\twhich = LXCHOOK_POSTSTOP;\n\telse if (strcmp(hook, \"clone\") == 0)\n\t\twhich = LXCHOOK_CLONE;\n\telse if (strcmp(hook, \"destroy\") == 0)\n\t\twhich = LXCHOOK_DESTROY;\n\telse\n\t\treturn -1;\n\tlxc_list_for_each(it, &conf->hooks[which]) {\n\t\tint ret;\n\t\tchar *hookname = it->elem;\n\t\tret = run_script_argv(name, \"lxc\", hookname, hook, lxcpath, argv);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint run_lxc_hooks(const char *name, char *hook, struct lxc_conf *conf,\n\t\t  const char *lxcpath, char *argv[])\n{\n\tint which = -1;\n\tstruct lxc_list *it;\n\n\tif (strcmp(hook, \"pre-start\") == 0)\n\t\twhich = LXCHOOK_PRESTART;\n\telse if (strcmp(hook, \"pre-mount\") == 0)\n\t\twhich = LXCHOOK_PREMOUNT;\n\telse if (strcmp(hook, \"mount\") == 0)\n\t\twhich = LXCHOOK_MOUNT;\n\telse if (strcmp(hook, \"autodev\") == 0)\n\t\twhich = LXCHOOK_AUTODEV;\n\telse if (strcmp(hook, \"start\") == 0)\n\t\twhich = LXCHOOK_START;\n\telse if (strcmp(hook, \"stop\") == 0)\n\t\twhich = LXCHOOK_STOP;\n\telse if (strcmp(hook, \"post-stop\") == 0)\n\t\twhich = LXCHOOK_POSTSTOP;\n\telse if (strcmp(hook, \"clone\") == 0)\n\t\twhich = LXCHOOK_CLONE;\n\telse if (strcmp(hook, \"destroy\") == 0)\n\t\twhich = LXCHOOK_DESTROY;\n\telse\n\t\treturn -1;\n\tlxc_list_for_each(it, &conf->hooks[which]) {\n\t\tint ret;\n\t\tchar *hookname = it->elem;\n\t\tret = run_script_argv(name, \"lxc\", hookname, hook, lxcpath, argv);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remount_all_slave",
          "args": [],
          "line": 3755
        },
        "resolved": true,
        "details": {
          "function_name": "remount_all_slave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3658-3690",
          "snippet": "void remount_all_slave(void)\n{\n\t/* walk /proc/mounts and change any shared entries to slave */\n\tFILE *f = fopen(\"/proc/self/mountinfo\", \"r\");\n\tchar *line = NULL;\n\tsize_t len = 0;\n\n\tif (!f) {\n\t\tSYSERROR(\"Failed to open /proc/self/mountinfo to mark all shared\");\n\t\tERROR(\"Continuing container startup...\");\n\t\treturn;\n\t}\n\n\twhile (getline(&line, &len, f) != -1) {\n\t\tchar *target, *opts;\n\t\ttarget = get_field(line, 4);\n\t\tif (!target)\n\t\t\tcontinue;\n\t\topts = get_field(target, 2);\n\t\tif (!opts)\n\t\t\tcontinue;\n\t\tnull_endofword(opts);\n\t\tif (!strstr(opts, \"shared\"))\n\t\t\tcontinue;\n\t\tnull_endofword(target);\n\t\tif (mount(NULL, target, NULL, MS_SLAVE, NULL)) {\n\t\t\tSYSERROR(\"Failed to make %s rslave\", target);\n\t\t\tERROR(\"Continuing...\");\n\t\t}\n\t}\n\tfclose(f);\n\tfree(line);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid remount_all_slave(void)\n{\n\t/* walk /proc/mounts and change any shared entries to slave */\n\tFILE *f = fopen(\"/proc/self/mountinfo\", \"r\");\n\tchar *line = NULL;\n\tsize_t len = 0;\n\n\tif (!f) {\n\t\tSYSERROR(\"Failed to open /proc/self/mountinfo to mark all shared\");\n\t\tERROR(\"Continuing container startup...\");\n\t\treturn;\n\t}\n\n\twhile (getline(&line, &len, f) != -1) {\n\t\tchar *target, *opts;\n\t\ttarget = get_field(line, 4);\n\t\tif (!target)\n\t\t\tcontinue;\n\t\topts = get_field(target, 2);\n\t\tif (!opts)\n\t\t\tcontinue;\n\t\tnull_endofword(opts);\n\t\tif (!strstr(opts, \"shared\"))\n\t\t\tcontinue;\n\t\tnull_endofword(target);\n\t\tif (mount(NULL, target, NULL, MS_SLAVE, NULL)) {\n\t\t\tSYSERROR(\"Failed to make %s rslave\", target);\n\t\t\tERROR(\"Continuing...\");\n\t\t}\n\t}\n\tfclose(f);\n\tfree(line);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to bind-mount container / onto itself\""
          ],
          "line": 3749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "path",
            "path",
            "\"rootfs\"",
            "MS_BIND",
            "NULL"
          ],
          "line": 3748
        },
        "resolved": true,
        "details": {
          "function_name": "mount_entry_on_generic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1838-1869",
          "snippet": "static inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint do_rootfs_setup(struct lxc_conf *conf, const char *name, const char *lxcpath)\n{\n\tif (conf->rootfs_setup) {\n\t\t/*\n\t\t * rootfs was set up in another namespace.  bind-mount it\n\t\t * to give us a mount in our own ns so we can pivot_root to it\n\t\t */\n\t\tconst char *path = conf->rootfs.mount;\n\t\tif (mount(path, path, \"rootfs\", MS_BIND, NULL) < 0) {\n\t\t\tERROR(\"Failed to bind-mount container / onto itself\");\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tremount_all_slave();\n\n\tif (run_lxc_hooks(name, \"pre-mount\", conf, lxcpath, NULL)) {\n\t\tERROR(\"failed to run pre-mount hooks for container '%s'.\", name);\n\t\treturn -1;\n\t}\n\n\tif (setup_rootfs(conf)) {\n\t\tERROR(\"failed to setup rootfs for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tconf->rootfs_setup = true;\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_execute_bind_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "3692-3734",
    "snippet": "void lxc_execute_bind_init(struct lxc_conf *conf)\n{\n\tint ret;\n\tchar path[PATH_MAX], destpath[PATH_MAX], *p;\n\n\t/* If init exists in the container, don't bind mount a static one */\n\tp = choose_init(conf->rootfs.mount);\n\tif (p) {\n\t\tfree(p);\n\t\treturn;\n\t}\n\n\tret = snprintf(path, PATH_MAX, SBINDIR \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Path name too long searching for lxc.init.static\");\n\t\treturn;\n\t}\n\n\tif (!file_exists(path)) {\n\t\tINFO(\"%s does not exist on host\", path);\n\t\treturn;\n\t}\n\n\tret = snprintf(destpath, PATH_MAX, \"%s%s\", conf->rootfs.mount, \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Path name too long for container's lxc.init.static\");\n\t\treturn;\n\t}\n\n\tif (!file_exists(destpath)) {\n\t\tFILE * pathfile = fopen(destpath, \"wb\");\n\t\tif (!pathfile) {\n\t\t\tSYSERROR(\"Failed to create mount target '%s'\", destpath);\n\t\t\treturn;\n\t\t}\n\t\tfclose(pathfile);\n\t}\n\n\tret = safe_mount(path, destpath, \"none\", MS_BIND, NULL, conf->rootfs.mount);\n\tif (ret < 0)\n\t\tSYSERROR(\"Failed to bind lxc.init.static into container\");\n\tINFO(\"lxc.init.static bound into container at %s\", path);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"lxc.init.static bound into container at %s\"",
            "path"
          ],
          "line": 3733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to bind lxc.init.static into container\""
          ],
          "line": 3732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_mount",
          "args": [
            "path",
            "destpath",
            "\"none\"",
            "MS_BIND",
            "NULL",
            "conf->rootfs.mount"
          ],
          "line": 3730
        },
        "resolved": true,
        "details": {
          "function_name": "safe_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1687-1743",
          "snippet": "int safe_mount(const char *src, const char *dest, const char *fstype,\n\t\tunsigned long flags, const void *data, const char *rootfs)\n{\n\tint srcfd = -1, destfd, ret, saved_errno;\n\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n\tconst char *mntsrc = src;\n\n\tif (!rootfs)\n\t\trootfs = \"\";\n\n\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n\tif (flags & MS_BIND && src && src[0] != '/') {\n\t\tINFO(\"this is a relative bind mount\");\n\t\tsrcfd = open_without_symlink(src, NULL);\n\t\tif (srcfd < 0)\n\t\t\treturn srcfd;\n\t\tret = snprintf(srcbuf, 50, \"/proc/self/fd/%d\", srcfd);\n\t\tif (ret < 0 || ret > 50) {\n\t\t\tclose(srcfd);\n\t\t\tERROR(\"Out of memory\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmntsrc = srcbuf;\n\t}\n\n\tdestfd = open_without_symlink(dest, rootfs);\n\tif (destfd < 0) {\n\t\tif (srcfd != -1) {\n\t\t\tsaved_errno = errno;\n\t\t\tclose(srcfd);\n\t\t\terrno = saved_errno;\n\t\t}\n\t\treturn destfd;\n\t}\n\n\tret = snprintf(destbuf, 50, \"/proc/self/fd/%d\", destfd);\n\tif (ret < 0 || ret > 50) {\n\t\tif (srcfd != -1)\n\t\t\tclose(srcfd);\n\t\tclose(destfd);\n\t\tERROR(\"Out of memory\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = mount(mntsrc, destbuf, fstype, flags, data);\n\tsaved_errno = errno;\n\tif (srcfd != -1)\n\t\tclose(srcfd);\n\tclose(destfd);\n\tif (ret < 0) {\n\t\terrno = saved_errno;\n\t\tSYSERROR(\"Failed to mount %s onto %s\", src, dest);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint safe_mount(const char *src, const char *dest, const char *fstype,\n\t\tunsigned long flags, const void *data, const char *rootfs)\n{\n\tint srcfd = -1, destfd, ret, saved_errno;\n\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n\tconst char *mntsrc = src;\n\n\tif (!rootfs)\n\t\trootfs = \"\";\n\n\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n\tif (flags & MS_BIND && src && src[0] != '/') {\n\t\tINFO(\"this is a relative bind mount\");\n\t\tsrcfd = open_without_symlink(src, NULL);\n\t\tif (srcfd < 0)\n\t\t\treturn srcfd;\n\t\tret = snprintf(srcbuf, 50, \"/proc/self/fd/%d\", srcfd);\n\t\tif (ret < 0 || ret > 50) {\n\t\t\tclose(srcfd);\n\t\t\tERROR(\"Out of memory\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmntsrc = srcbuf;\n\t}\n\n\tdestfd = open_without_symlink(dest, rootfs);\n\tif (destfd < 0) {\n\t\tif (srcfd != -1) {\n\t\t\tsaved_errno = errno;\n\t\t\tclose(srcfd);\n\t\t\terrno = saved_errno;\n\t\t}\n\t\treturn destfd;\n\t}\n\n\tret = snprintf(destbuf, 50, \"/proc/self/fd/%d\", destfd);\n\tif (ret < 0 || ret > 50) {\n\t\tif (srcfd != -1)\n\t\t\tclose(srcfd);\n\t\tclose(destfd);\n\t\tERROR(\"Out of memory\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = mount(mntsrc, destbuf, fstype, flags, data);\n\tsaved_errno = errno;\n\tif (srcfd != -1)\n\t\tclose(srcfd);\n\tclose(destfd);\n\tif (ret < 0) {\n\t\terrno = saved_errno;\n\t\tSYSERROR(\"Failed to mount %s onto %s\", src, dest);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "pathfile"
          ],
          "line": 3727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to create mount target '%s'\"",
            "destpath"
          ],
          "line": 3724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "destpath",
            "\"wb\""
          ],
          "line": 3722
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_exists",
          "args": [
            "destpath"
          ],
          "line": 3721
        },
        "resolved": true,
        "details": {
          "function_name": "file_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1240-1245",
          "snippet": "bool file_exists(const char *f)\n{\n\tstruct stat statbuf;\n\n\treturn stat(f, &statbuf) == 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool file_exists(const char *f)\n{\n\tstruct stat statbuf;\n\n\treturn stat(f, &statbuf) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Path name too long for container's lxc.init.static\""
          ],
          "line": 3717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "destpath",
            "PATH_MAX",
            "\"%s%s\"",
            "conf->rootfs.mount",
            "\"/init.lxc.static\""
          ],
          "line": 3715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"%s does not exist on host\"",
            "path"
          ],
          "line": 3711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Path name too long searching for lxc.init.static\""
          ],
          "line": 3706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "PATH_MAX",
            "SBINDIR \"/init.lxc.static\""
          ],
          "line": 3704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "p"
          ],
          "line": 3700
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4619-4628",
          "snippet": "static void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "choose_init",
          "args": [
            "conf->rootfs.mount"
          ],
          "line": 3698
        },
        "resolved": true,
        "details": {
          "function_name": "choose_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1255-1348",
          "snippet": "char *choose_init(const char *rootfs)\n{\n\tchar *retv = NULL;\n\tconst char *empty = \"\",\n\t\t   *tmp;\n\tint ret, env_set = 0;\n\tstruct stat mystat;\n\n\tif (!getenv(\"PATH\")) {\n\t\tif (setenv(\"PATH\", \"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", 0))\n\t\t\tSYSERROR(\"Failed to setenv\");\n\t\tenv_set = 1;\n\t}\n\n\tretv = on_path(\"init.lxc\", rootfs);\n\n\tif (env_set) {\n\t\tif (unsetenv(\"PATH\"))\n\t\t\tSYSERROR(\"Failed to unsetenv\");\n\t}\n\n\tif (retv)\n\t\treturn retv;\n\n\tretv = malloc(PATH_MAX);\n\tif (!retv)\n\t\treturn NULL;\n\n\tif (rootfs)\n\t\ttmp = rootfs;\n\telse\n\t\ttmp = empty;\n\n\tret = snprintf(retv, PATH_MAX, \"%s/%s/%s\", tmp, SBINDIR, \"/init.lxc\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tERROR(\"pathname too long\");\n\t\tgoto out1;\n\t}\n\n\tret = stat(retv, &mystat);\n\tif (ret == 0)\n\t\treturn retv;\n\n\tret = snprintf(retv, PATH_MAX, \"%s/%s/%s\", tmp, LXCINITDIR, \"/lxc/lxc-init\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tERROR(\"pathname too long\");\n\t\tgoto out1;\n\t}\n\n\tret = stat(retv, &mystat);\n\tif (ret == 0)\n\t\treturn retv;\n\n\tret = snprintf(retv, PATH_MAX, \"%s/usr/lib/lxc/lxc-init\", tmp);\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tERROR(\"pathname too long\");\n\t\tgoto out1;\n\t}\n\tret = stat(retv, &mystat);\n\tif (ret == 0)\n\t\treturn retv;\n\n\tret = snprintf(retv, PATH_MAX, \"%s/sbin/lxc-init\", tmp);\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tERROR(\"pathname too long\");\n\t\tgoto out1;\n\t}\n\tret = stat(retv, &mystat);\n\tif (ret == 0)\n\t\treturn retv;\n\n\t/*\n\t * Last resort, look for the statically compiled init.lxc which we\n\t * hopefully bind-mounted in.\n\t * If we are called during container setup, and we get to this point,\n\t * then the init.lxc.static from the host will need to be bind-mounted\n\t * in.  So we return NULL here to indicate that.\n\t */\n\tif (rootfs)\n\t\tgoto out1;\n\n\tret = snprintf(retv, PATH_MAX, \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Nonsense - name /lxc.init.static too long\");\n\t\tgoto out1;\n\t}\n\tret = stat(retv, &mystat);\n\tif (ret == 0)\n\t\treturn retv;\n\nout1:\n\tfree(retv);\n\treturn NULL;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *choose_init(const char *rootfs)\n{\n\tchar *retv = NULL;\n\tconst char *empty = \"\",\n\t\t   *tmp;\n\tint ret, env_set = 0;\n\tstruct stat mystat;\n\n\tif (!getenv(\"PATH\")) {\n\t\tif (setenv(\"PATH\", \"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", 0))\n\t\t\tSYSERROR(\"Failed to setenv\");\n\t\tenv_set = 1;\n\t}\n\n\tretv = on_path(\"init.lxc\", rootfs);\n\n\tif (env_set) {\n\t\tif (unsetenv(\"PATH\"))\n\t\t\tSYSERROR(\"Failed to unsetenv\");\n\t}\n\n\tif (retv)\n\t\treturn retv;\n\n\tretv = malloc(PATH_MAX);\n\tif (!retv)\n\t\treturn NULL;\n\n\tif (rootfs)\n\t\ttmp = rootfs;\n\telse\n\t\ttmp = empty;\n\n\tret = snprintf(retv, PATH_MAX, \"%s/%s/%s\", tmp, SBINDIR, \"/init.lxc\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tERROR(\"pathname too long\");\n\t\tgoto out1;\n\t}\n\n\tret = stat(retv, &mystat);\n\tif (ret == 0)\n\t\treturn retv;\n\n\tret = snprintf(retv, PATH_MAX, \"%s/%s/%s\", tmp, LXCINITDIR, \"/lxc/lxc-init\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tERROR(\"pathname too long\");\n\t\tgoto out1;\n\t}\n\n\tret = stat(retv, &mystat);\n\tif (ret == 0)\n\t\treturn retv;\n\n\tret = snprintf(retv, PATH_MAX, \"%s/usr/lib/lxc/lxc-init\", tmp);\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tERROR(\"pathname too long\");\n\t\tgoto out1;\n\t}\n\tret = stat(retv, &mystat);\n\tif (ret == 0)\n\t\treturn retv;\n\n\tret = snprintf(retv, PATH_MAX, \"%s/sbin/lxc-init\", tmp);\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tERROR(\"pathname too long\");\n\t\tgoto out1;\n\t}\n\tret = stat(retv, &mystat);\n\tif (ret == 0)\n\t\treturn retv;\n\n\t/*\n\t * Last resort, look for the statically compiled init.lxc which we\n\t * hopefully bind-mounted in.\n\t * If we are called during container setup, and we get to this point,\n\t * then the init.lxc.static from the host will need to be bind-mounted\n\t * in.  So we return NULL here to indicate that.\n\t */\n\tif (rootfs)\n\t\tgoto out1;\n\n\tret = snprintf(retv, PATH_MAX, \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Nonsense - name /lxc.init.static too long\");\n\t\tgoto out1;\n\t}\n\tret = stat(retv, &mystat);\n\tif (ret == 0)\n\t\treturn retv;\n\nout1:\n\tfree(retv);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid lxc_execute_bind_init(struct lxc_conf *conf)\n{\n\tint ret;\n\tchar path[PATH_MAX], destpath[PATH_MAX], *p;\n\n\t/* If init exists in the container, don't bind mount a static one */\n\tp = choose_init(conf->rootfs.mount);\n\tif (p) {\n\t\tfree(p);\n\t\treturn;\n\t}\n\n\tret = snprintf(path, PATH_MAX, SBINDIR \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Path name too long searching for lxc.init.static\");\n\t\treturn;\n\t}\n\n\tif (!file_exists(path)) {\n\t\tINFO(\"%s does not exist on host\", path);\n\t\treturn;\n\t}\n\n\tret = snprintf(destpath, PATH_MAX, \"%s%s\", conf->rootfs.mount, \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Path name too long for container's lxc.init.static\");\n\t\treturn;\n\t}\n\n\tif (!file_exists(destpath)) {\n\t\tFILE * pathfile = fopen(destpath, \"wb\");\n\t\tif (!pathfile) {\n\t\t\tSYSERROR(\"Failed to create mount target '%s'\", destpath);\n\t\t\treturn;\n\t\t}\n\t\tfclose(pathfile);\n\t}\n\n\tret = safe_mount(path, destpath, \"none\", MS_BIND, NULL, conf->rootfs.mount);\n\tif (ret < 0)\n\t\tSYSERROR(\"Failed to bind lxc.init.static into container\");\n\tINFO(\"lxc.init.static bound into container at %s\", path);\n}"
  },
  {
    "function_name": "remount_all_slave",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "3658-3690",
    "snippet": "void remount_all_slave(void)\n{\n\t/* walk /proc/mounts and change any shared entries to slave */\n\tFILE *f = fopen(\"/proc/self/mountinfo\", \"r\");\n\tchar *line = NULL;\n\tsize_t len = 0;\n\n\tif (!f) {\n\t\tSYSERROR(\"Failed to open /proc/self/mountinfo to mark all shared\");\n\t\tERROR(\"Continuing container startup...\");\n\t\treturn;\n\t}\n\n\twhile (getline(&line, &len, f) != -1) {\n\t\tchar *target, *opts;\n\t\ttarget = get_field(line, 4);\n\t\tif (!target)\n\t\t\tcontinue;\n\t\topts = get_field(target, 2);\n\t\tif (!opts)\n\t\t\tcontinue;\n\t\tnull_endofword(opts);\n\t\tif (!strstr(opts, \"shared\"))\n\t\t\tcontinue;\n\t\tnull_endofword(target);\n\t\tif (mount(NULL, target, NULL, MS_SLAVE, NULL)) {\n\t\t\tSYSERROR(\"Failed to make %s rslave\", target);\n\t\t\tERROR(\"Continuing...\");\n\t\t}\n\t}\n\tfclose(f);\n\tfree(line);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "line"
          ],
          "line": 3689
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4619-4628",
          "snippet": "static void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 3688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Continuing...\""
          ],
          "line": 3685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to make %s rslave\"",
            "target"
          ],
          "line": 3684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "NULL",
            "target",
            "NULL",
            "MS_SLAVE",
            "NULL"
          ],
          "line": 3683
        },
        "resolved": true,
        "details": {
          "function_name": "mount_entry_on_generic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1838-1869",
          "snippet": "static inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "null_endofword",
          "args": [
            "target"
          ],
          "line": 3682
        },
        "resolved": true,
        "details": {
          "function_name": "null_endofword",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1668-1673",
          "snippet": "static void null_endofword(char *word)\n{\n\twhile (*word && *word != ' ' && *word != '\\t')\n\t\tword++;\n\t*word = '\\0';\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void null_endofword(char *word)\n{\n\twhile (*word && *word != ' ' && *word != '\\t')\n\t\tword++;\n\t*word = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "opts",
            "\"shared\""
          ],
          "line": 3680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_field",
          "args": [
            "target",
            "2"
          ],
          "line": 3676
        },
        "resolved": true,
        "details": {
          "function_name": "get_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1678-1691",
          "snippet": "static char *get_field(char *src, int nfields)\n{\n\tchar *p = src;\n\tint i;\n\n\tfor (i = 0; i < nfields; i++) {\n\t\twhile (*p && *p != ' ' && *p != '\\t')\n\t\t\tp++;\n\t\tif (!*p)\n\t\t\tbreak;\n\t\tp++;\n\t}\n\treturn p;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic char *get_field(char *src, int nfields)\n{\n\tchar *p = src;\n\tint i;\n\n\tfor (i = 0; i < nfields; i++) {\n\t\twhile (*p && *p != ' ' && *p != '\\t')\n\t\t\tp++;\n\t\tif (!*p)\n\t\t\tbreak;\n\t\tp++;\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&line",
            "&len",
            "f"
          ],
          "line": 3671
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getline.c",
          "lines": "39-60",
          "snippet": "ssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Continuing container startup...\""
          ],
          "line": 3667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to open /proc/self/mountinfo to mark all shared\""
          ],
          "line": 3666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "\"/proc/self/mountinfo\"",
            "\"r\""
          ],
          "line": 3661
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid remount_all_slave(void)\n{\n\t/* walk /proc/mounts and change any shared entries to slave */\n\tFILE *f = fopen(\"/proc/self/mountinfo\", \"r\");\n\tchar *line = NULL;\n\tsize_t len = 0;\n\n\tif (!f) {\n\t\tSYSERROR(\"Failed to open /proc/self/mountinfo to mark all shared\");\n\t\tERROR(\"Continuing container startup...\");\n\t\treturn;\n\t}\n\n\twhile (getline(&line, &len, f) != -1) {\n\t\tchar *target, *opts;\n\t\ttarget = get_field(line, 4);\n\t\tif (!target)\n\t\t\tcontinue;\n\t\topts = get_field(target, 2);\n\t\tif (!opts)\n\t\t\tcontinue;\n\t\tnull_endofword(opts);\n\t\tif (!strstr(opts, \"shared\"))\n\t\t\tcontinue;\n\t\tnull_endofword(target);\n\t\tif (mount(NULL, target, NULL, MS_SLAVE, NULL)) {\n\t\t\tSYSERROR(\"Failed to make %s rslave\", target);\n\t\t\tERROR(\"Continuing...\");\n\t\t}\n\t}\n\tfclose(f);\n\tfree(line);\n}"
  },
  {
    "function_name": "tmp_proc_unmount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "3650-3656",
    "snippet": "void tmp_proc_unmount(struct lxc_conf *lxc_conf)\n{\n\tif (lxc_conf->tmp_umount_proc == 1) {\n\t\tumount(\"/proc\");\n\t\tlxc_conf->tmp_umount_proc = 0;\n\t}\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "umount",
          "args": [
            "\"/proc\""
          ],
          "line": 3653
        },
        "resolved": true,
        "details": {
          "function_name": "rbd_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcrbd.c",
          "lines": "174-181",
          "snippet": "int rbd_umount(struct bdev *bdev)\n{\n\tif (strcmp(bdev->type, \"rbd\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\treturn umount(bdev->dest);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <inttypes.h> /* Required for PRIu64 to work. */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h> /* Required for PRIu64 to work. */\n\nint rbd_umount(struct bdev *bdev)\n{\n\tif (strcmp(bdev->type, \"rbd\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\treturn umount(bdev->dest);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid tmp_proc_unmount(struct lxc_conf *lxc_conf)\n{\n\tif (lxc_conf->tmp_umount_proc == 1) {\n\t\tumount(\"/proc\");\n\t\tlxc_conf->tmp_umount_proc = 0;\n\t}\n}"
  },
  {
    "function_name": "tmp_proc_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "3634-3648",
    "snippet": "int tmp_proc_mount(struct lxc_conf *lxc_conf)\n{\n\tint mounted;\n\n\tmounted = mount_proc_if_needed(lxc_conf->rootfs.path ? lxc_conf->rootfs.mount : \"\");\n\tif (mounted == -1) {\n\t\tSYSERROR(\"failed to mount /proc in the container.\");\n\t\t/* continue only if there is no rootfs */\n\t\tif (lxc_conf->rootfs.path)\n\t\t\treturn -1;\n\t} else if (mounted == 1) {\n\t\tlxc_conf->tmp_umount_proc = 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to mount /proc in the container.\""
          ],
          "line": 3640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount_proc_if_needed",
          "args": [
            "lxc_conf->rootfs.path ? lxc_conf->rootfs.mount : \"\""
          ],
          "line": 3638
        },
        "resolved": true,
        "details": {
          "function_name": "mount_proc_if_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1757-1801",
          "snippet": "int mount_proc_if_needed(const char *rootfs)\n{\n\tchar path[MAXPATHLEN];\n\tchar link[20];\n\tint link_to_pid, linklen, ret;\n\tint mypid;\n\n\tret = snprintf(path, MAXPATHLEN, \"%s/proc/self\", rootfs);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"proc path name too long\");\n\t\treturn -1;\n\t}\n\tmemset(link, 0, 20);\n\tlinklen = readlink(path, link, 20);\n\tmypid = (int)getpid();\n\tINFO(\"I am %d, /proc/self points to '%s'\", mypid, link);\n\tret = snprintf(path, MAXPATHLEN, \"%s/proc\", rootfs);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"proc path name too long\");\n\t\treturn -1;\n\t}\n\tif (linklen < 0) /* /proc not mounted */\n\t\tgoto domount;\n\tif (lxc_safe_int(link, &link_to_pid) < 0)\n\t\treturn -1;\n\tif (link_to_pid != mypid) {\n\t\t/* wrong /procs mounted */\n\t\tumount2(path, MNT_DETACH); /* ignore failure */\n\t\tgoto domount;\n\t}\n\t/* the right proc is already mounted */\n\treturn 0;\n\ndomount:\n\tif (!strcmp(rootfs,\"\")) /* rootfs is NULL */\n\t\tret = mount(\"proc\", path, \"proc\", 0, NULL);\n\telse\n\t\tret = safe_mount(\"proc\", path, \"proc\", 0, NULL, rootfs);\n\n\tif (ret < 0)\n\t\treturn -1;\n\n\tINFO(\"Mounted /proc in container for security transition\");\n\treturn 1;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool btrfs_try_remove_subvol(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nint mount_proc_if_needed(const char *rootfs)\n{\n\tchar path[MAXPATHLEN];\n\tchar link[20];\n\tint link_to_pid, linklen, ret;\n\tint mypid;\n\n\tret = snprintf(path, MAXPATHLEN, \"%s/proc/self\", rootfs);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"proc path name too long\");\n\t\treturn -1;\n\t}\n\tmemset(link, 0, 20);\n\tlinklen = readlink(path, link, 20);\n\tmypid = (int)getpid();\n\tINFO(\"I am %d, /proc/self points to '%s'\", mypid, link);\n\tret = snprintf(path, MAXPATHLEN, \"%s/proc\", rootfs);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"proc path name too long\");\n\t\treturn -1;\n\t}\n\tif (linklen < 0) /* /proc not mounted */\n\t\tgoto domount;\n\tif (lxc_safe_int(link, &link_to_pid) < 0)\n\t\treturn -1;\n\tif (link_to_pid != mypid) {\n\t\t/* wrong /procs mounted */\n\t\tumount2(path, MNT_DETACH); /* ignore failure */\n\t\tgoto domount;\n\t}\n\t/* the right proc is already mounted */\n\treturn 0;\n\ndomount:\n\tif (!strcmp(rootfs,\"\")) /* rootfs is NULL */\n\t\tret = mount(\"proc\", path, \"proc\", 0, NULL);\n\telse\n\t\tret = safe_mount(\"proc\", path, \"proc\", 0, NULL, rootfs);\n\n\tif (ret < 0)\n\t\treturn -1;\n\n\tINFO(\"Mounted /proc in container for security transition\");\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint tmp_proc_mount(struct lxc_conf *lxc_conf)\n{\n\tint mounted;\n\n\tmounted = mount_proc_if_needed(lxc_conf->rootfs.path ? lxc_conf->rootfs.mount : \"\");\n\tif (mounted == -1) {\n\t\tSYSERROR(\"failed to mount /proc in the container.\");\n\t\t/* continue only if there is no rootfs */\n\t\tif (lxc_conf->rootfs.path)\n\t\t\treturn -1;\n\t} else if (mounted == 1) {\n\t\tlxc_conf->tmp_umount_proc = 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ttys_shift_ids",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "3620-3631",
    "snippet": "int ttys_shift_ids(struct lxc_conf *c)\n{\n\tif (lxc_list_empty(&c->id_map))\n\t\treturn 0;\n\n\tif (strcmp(c->console.name, \"\") !=0 && chown_mapped_root(c->console.name, c) < 0) {\n\t\tERROR(\"Failed to chown %s\", c->console.name);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to chown %s\"",
            "c->console.name"
          ],
          "line": 3626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chown_mapped_root",
          "args": [
            "c->console.name",
            "c"
          ],
          "line": 3625
        },
        "resolved": true,
        "details": {
          "function_name": "chown_mapped_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3482-3618",
          "snippet": "int chown_mapped_root(char *path, struct lxc_conf *conf)\n{\n\tuid_t rootuid;\n\tgid_t rootgid;\n\tpid_t pid;\n\tunsigned long val;\n\tchar *chownpath = path;\n\n\tif (!get_mapped_rootid(conf, ID_TYPE_UID, &val)) {\n\t\tERROR(\"No mapping for container root\");\n\t\treturn -1;\n\t}\n\trootuid = (uid_t) val;\n\tif (!get_mapped_rootid(conf, ID_TYPE_GID, &val)) {\n\t\tERROR(\"No mapping for container root\");\n\t\treturn -1;\n\t}\n\trootgid = (gid_t) val;\n\n\t/*\n\t * In case of overlay, we want only the writeable layer\n\t * to be chowned\n\t */\n\tif (strncmp(path, \"overlayfs:\", 10) == 0 || strncmp(path, \"aufs:\", 5) == 0) {\n\t\tchownpath = strchr(path, ':');\n\t\tif (!chownpath) {\n\t\t\tERROR(\"Bad overlay path: %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tchownpath = strchr(chownpath+1, ':');\n\t\tif (!chownpath) {\n\t\t\tERROR(\"Bad overlay path: %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tchownpath++;\n\t}\n\tpath = chownpath;\n\tif (geteuid() == 0) {\n\t\tif (chown(path, rootuid, rootgid) < 0) {\n\t\t\tERROR(\"Error chowning %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (rootuid == geteuid()) {\n\t\t// nothing to do\n\t\tINFO(\"%s: container root is our uid;  no need to chown\" ,__func__);\n\t\treturn 0;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"Failed forking\");\n\t\treturn -1;\n\t}\n\tif (!pid) {\n\t\tint hostuid = geteuid(), hostgid = getegid(), ret;\n\t\tstruct stat sb;\n\t\tchar map1[100], map2[100], map3[100], map4[100], map5[100];\n\t\tchar ugid[100];\n\t\tchar *args1[] = { \"lxc-usernsexec\", \"-m\", map1, \"-m\", map2,\n\t\t\t\t\"-m\", map3, \"-m\", map5,\n\t\t\t\t\"--\", \"chown\", ugid, path, NULL };\n\t\tchar *args2[] = { \"lxc-usernsexec\", \"-m\", map1, \"-m\", map2,\n\t\t\t\t\"-m\", map3, \"-m\", map4, \"-m\", map5,\n\t\t\t\t\"--\", \"chown\", ugid, path, NULL };\n\n\t\t// save the current gid of \"path\"\n\t\tif (stat(path, &sb) < 0) {\n\t\t\tERROR(\"Error stat %s\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * A file has to be group-owned by a gid mapped into the\n\t\t * container, or the container won't be privileged over it.\n\t\t */\n\t\tif (sb.st_uid == geteuid() &&\n\t\t\t\tmapped_hostid(sb.st_gid, conf, ID_TYPE_GID) < 0 &&\n\t\t\t\tchown(path, -1, hostgid) < 0) {\n\t\t\tERROR(\"Failed chgrping %s\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"u:0:rootuid:1\"\n\t\tret = snprintf(map1, 100, \"u:0:%d:1\", rootuid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error uid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"u:hostuid:hostuid:1\"\n\t\tret = snprintf(map2, 100, \"u:%d:%d:1\", hostuid, hostuid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error uid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:0:rootgid:1\"\n\t\tret = snprintf(map3, 100, \"g:0:%d:1\", rootgid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:pathgid:rootgid+pathgid:1\"\n\t\tret = snprintf(map4, 100, \"g:%d:%d:1\", (gid_t)sb.st_gid,\n\t\t\t\trootgid + (gid_t)sb.st_gid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:hostgid:hostgid:1\"\n\t\tret = snprintf(map5, 100, \"g:%d:%d:1\", hostgid, hostgid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"0:pathgid\" (chown)\n\t\tret = snprintf(ugid, 100, \"0:%d\", (gid_t)sb.st_gid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error owner printing format string for chown\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (hostgid == sb.st_gid)\n\t\t\tret = execvp(\"lxc-usernsexec\", args1);\n\t\telse\n\t\t\tret = execvp(\"lxc-usernsexec\", args2);\n\t\tSYSERROR(\"Failed executing usernsexec\");\n\t\texit(1);\n\t}\n\treturn wait_for_pid(pid);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint chown_mapped_root(char *path, struct lxc_conf *conf)\n{\n\tuid_t rootuid;\n\tgid_t rootgid;\n\tpid_t pid;\n\tunsigned long val;\n\tchar *chownpath = path;\n\n\tif (!get_mapped_rootid(conf, ID_TYPE_UID, &val)) {\n\t\tERROR(\"No mapping for container root\");\n\t\treturn -1;\n\t}\n\trootuid = (uid_t) val;\n\tif (!get_mapped_rootid(conf, ID_TYPE_GID, &val)) {\n\t\tERROR(\"No mapping for container root\");\n\t\treturn -1;\n\t}\n\trootgid = (gid_t) val;\n\n\t/*\n\t * In case of overlay, we want only the writeable layer\n\t * to be chowned\n\t */\n\tif (strncmp(path, \"overlayfs:\", 10) == 0 || strncmp(path, \"aufs:\", 5) == 0) {\n\t\tchownpath = strchr(path, ':');\n\t\tif (!chownpath) {\n\t\t\tERROR(\"Bad overlay path: %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tchownpath = strchr(chownpath+1, ':');\n\t\tif (!chownpath) {\n\t\t\tERROR(\"Bad overlay path: %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tchownpath++;\n\t}\n\tpath = chownpath;\n\tif (geteuid() == 0) {\n\t\tif (chown(path, rootuid, rootgid) < 0) {\n\t\t\tERROR(\"Error chowning %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (rootuid == geteuid()) {\n\t\t// nothing to do\n\t\tINFO(\"%s: container root is our uid;  no need to chown\" ,__func__);\n\t\treturn 0;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"Failed forking\");\n\t\treturn -1;\n\t}\n\tif (!pid) {\n\t\tint hostuid = geteuid(), hostgid = getegid(), ret;\n\t\tstruct stat sb;\n\t\tchar map1[100], map2[100], map3[100], map4[100], map5[100];\n\t\tchar ugid[100];\n\t\tchar *args1[] = { \"lxc-usernsexec\", \"-m\", map1, \"-m\", map2,\n\t\t\t\t\"-m\", map3, \"-m\", map5,\n\t\t\t\t\"--\", \"chown\", ugid, path, NULL };\n\t\tchar *args2[] = { \"lxc-usernsexec\", \"-m\", map1, \"-m\", map2,\n\t\t\t\t\"-m\", map3, \"-m\", map4, \"-m\", map5,\n\t\t\t\t\"--\", \"chown\", ugid, path, NULL };\n\n\t\t// save the current gid of \"path\"\n\t\tif (stat(path, &sb) < 0) {\n\t\t\tERROR(\"Error stat %s\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * A file has to be group-owned by a gid mapped into the\n\t\t * container, or the container won't be privileged over it.\n\t\t */\n\t\tif (sb.st_uid == geteuid() &&\n\t\t\t\tmapped_hostid(sb.st_gid, conf, ID_TYPE_GID) < 0 &&\n\t\t\t\tchown(path, -1, hostgid) < 0) {\n\t\t\tERROR(\"Failed chgrping %s\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"u:0:rootuid:1\"\n\t\tret = snprintf(map1, 100, \"u:0:%d:1\", rootuid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error uid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"u:hostuid:hostuid:1\"\n\t\tret = snprintf(map2, 100, \"u:%d:%d:1\", hostuid, hostuid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error uid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:0:rootgid:1\"\n\t\tret = snprintf(map3, 100, \"g:0:%d:1\", rootgid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:pathgid:rootgid+pathgid:1\"\n\t\tret = snprintf(map4, 100, \"g:%d:%d:1\", (gid_t)sb.st_gid,\n\t\t\t\trootgid + (gid_t)sb.st_gid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:hostgid:hostgid:1\"\n\t\tret = snprintf(map5, 100, \"g:%d:%d:1\", hostgid, hostgid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"0:pathgid\" (chown)\n\t\tret = snprintf(ugid, 100, \"0:%d\", (gid_t)sb.st_gid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error owner printing format string for chown\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (hostgid == sb.st_gid)\n\t\t\tret = execvp(\"lxc-usernsexec\", args1);\n\t\telse\n\t\t\tret = execvp(\"lxc-usernsexec\", args2);\n\t\tSYSERROR(\"Failed executing usernsexec\");\n\t\texit(1);\n\t}\n\treturn wait_for_pid(pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "c->console.name",
            "\"\""
          ],
          "line": 3625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_empty",
          "args": [
            "&c->id_map"
          ],
          "line": 3622
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "94-97",
          "snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint ttys_shift_ids(struct lxc_conf *c)\n{\n\tif (lxc_list_empty(&c->id_map))\n\t\treturn 0;\n\n\tif (strcmp(c->console.name, \"\") !=0 && chown_mapped_root(c->console.name, c) < 0) {\n\t\tERROR(\"Failed to chown %s\", c->console.name);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "chown_mapped_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "3482-3618",
    "snippet": "int chown_mapped_root(char *path, struct lxc_conf *conf)\n{\n\tuid_t rootuid;\n\tgid_t rootgid;\n\tpid_t pid;\n\tunsigned long val;\n\tchar *chownpath = path;\n\n\tif (!get_mapped_rootid(conf, ID_TYPE_UID, &val)) {\n\t\tERROR(\"No mapping for container root\");\n\t\treturn -1;\n\t}\n\trootuid = (uid_t) val;\n\tif (!get_mapped_rootid(conf, ID_TYPE_GID, &val)) {\n\t\tERROR(\"No mapping for container root\");\n\t\treturn -1;\n\t}\n\trootgid = (gid_t) val;\n\n\t/*\n\t * In case of overlay, we want only the writeable layer\n\t * to be chowned\n\t */\n\tif (strncmp(path, \"overlayfs:\", 10) == 0 || strncmp(path, \"aufs:\", 5) == 0) {\n\t\tchownpath = strchr(path, ':');\n\t\tif (!chownpath) {\n\t\t\tERROR(\"Bad overlay path: %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tchownpath = strchr(chownpath+1, ':');\n\t\tif (!chownpath) {\n\t\t\tERROR(\"Bad overlay path: %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tchownpath++;\n\t}\n\tpath = chownpath;\n\tif (geteuid() == 0) {\n\t\tif (chown(path, rootuid, rootgid) < 0) {\n\t\t\tERROR(\"Error chowning %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (rootuid == geteuid()) {\n\t\t// nothing to do\n\t\tINFO(\"%s: container root is our uid;  no need to chown\" ,__func__);\n\t\treturn 0;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"Failed forking\");\n\t\treturn -1;\n\t}\n\tif (!pid) {\n\t\tint hostuid = geteuid(), hostgid = getegid(), ret;\n\t\tstruct stat sb;\n\t\tchar map1[100], map2[100], map3[100], map4[100], map5[100];\n\t\tchar ugid[100];\n\t\tchar *args1[] = { \"lxc-usernsexec\", \"-m\", map1, \"-m\", map2,\n\t\t\t\t\"-m\", map3, \"-m\", map5,\n\t\t\t\t\"--\", \"chown\", ugid, path, NULL };\n\t\tchar *args2[] = { \"lxc-usernsexec\", \"-m\", map1, \"-m\", map2,\n\t\t\t\t\"-m\", map3, \"-m\", map4, \"-m\", map5,\n\t\t\t\t\"--\", \"chown\", ugid, path, NULL };\n\n\t\t// save the current gid of \"path\"\n\t\tif (stat(path, &sb) < 0) {\n\t\t\tERROR(\"Error stat %s\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * A file has to be group-owned by a gid mapped into the\n\t\t * container, or the container won't be privileged over it.\n\t\t */\n\t\tif (sb.st_uid == geteuid() &&\n\t\t\t\tmapped_hostid(sb.st_gid, conf, ID_TYPE_GID) < 0 &&\n\t\t\t\tchown(path, -1, hostgid) < 0) {\n\t\t\tERROR(\"Failed chgrping %s\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"u:0:rootuid:1\"\n\t\tret = snprintf(map1, 100, \"u:0:%d:1\", rootuid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error uid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"u:hostuid:hostuid:1\"\n\t\tret = snprintf(map2, 100, \"u:%d:%d:1\", hostuid, hostuid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error uid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:0:rootgid:1\"\n\t\tret = snprintf(map3, 100, \"g:0:%d:1\", rootgid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:pathgid:rootgid+pathgid:1\"\n\t\tret = snprintf(map4, 100, \"g:%d:%d:1\", (gid_t)sb.st_gid,\n\t\t\t\trootgid + (gid_t)sb.st_gid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:hostgid:hostgid:1\"\n\t\tret = snprintf(map5, 100, \"g:%d:%d:1\", hostgid, hostgid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"0:pathgid\" (chown)\n\t\tret = snprintf(ugid, 100, \"0:%d\", (gid_t)sb.st_gid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error owner printing format string for chown\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (hostgid == sb.st_gid)\n\t\t\tret = execvp(\"lxc-usernsexec\", args1);\n\t\telse\n\t\t\tret = execvp(\"lxc-usernsexec\", args2);\n\t\tSYSERROR(\"Failed executing usernsexec\");\n\t\texit(1);\n\t}\n\treturn wait_for_pid(pid);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_for_pid",
          "args": [
            "pid"
          ],
          "line": 3617
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "311-325",
          "snippet": "int lxc_wait_for_pid_status(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\treturn status;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_wait_for_pid_status(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 3615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed executing usernsexec\""
          ],
          "line": 3614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "\"lxc-usernsexec\"",
            "args2"
          ],
          "line": 3613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "\"lxc-usernsexec\"",
            "args1"
          ],
          "line": 3611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error owner printing format string for chown\""
          ],
          "line": 3606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "ugid",
            "100",
            "\"0:%d\"",
            "(gid_t)sb.st_gid"
          ],
          "line": 3604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error gid printing map string\""
          ],
          "line": 3599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "map5",
            "100",
            "\"g:%d:%d:1\"",
            "hostgid",
            "hostgid"
          ],
          "line": 3597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error gid printing map string\""
          ],
          "line": 3592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "map4",
            "100",
            "\"g:%d:%d:1\"",
            "(gid_t)sb.st_gid",
            "rootgid + (gid_t)sb.st_gid"
          ],
          "line": 3589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error gid printing map string\""
          ],
          "line": 3584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "map3",
            "100",
            "\"g:0:%d:1\"",
            "rootgid"
          ],
          "line": 3582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error uid printing map string\""
          ],
          "line": 3577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "map2",
            "100",
            "\"u:%d:%d:1\"",
            "hostuid",
            "hostuid"
          ],
          "line": 3575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error uid printing map string\""
          ],
          "line": 3570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "map1",
            "100",
            "\"u:0:%d:1\"",
            "rootuid"
          ],
          "line": 3568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed chgrping %s\"",
            "path"
          ],
          "line": 3563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chown",
          "args": [
            "path",
            "-1",
            "hostgid"
          ],
          "line": 3562
        },
        "resolved": true,
        "details": {
          "function_name": "do_chown_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "357-430",
          "snippet": "static int do_chown_cgroup(const char *controller, const char *cgroup_path,\n\t\tuid_t newuid)\n{\n\tint sv[2] = {-1, -1}, optval = 1, ret = -1;\n\tchar buf[1];\n\tstruct pollfd fds;\n\n\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, sv) < 0) {\n\t\tSYSERROR(\"Error creating socketpair\");\n\t\tgoto out;\n\t}\n\tif (setsockopt(sv[1], SOL_SOCKET, SO_PASSCRED, &optval, sizeof(optval)) == -1) {\n\t\tSYSERROR(\"setsockopt failed\");\n\t\tgoto out;\n\t}\n\tif (setsockopt(sv[0], SOL_SOCKET, SO_PASSCRED, &optval, sizeof(optval)) == -1) {\n\t\tSYSERROR(\"setsockopt failed\");\n\t\tgoto out;\n\t}\n\tif ( cgmanager_chown_scm_sync(NULL, cgroup_manager, controller,\n\t\t\t\t       cgroup_path, sv[1]) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_chown_scm_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tgoto out;\n\t}\n\t/* now send credentials */\n\n\tfds.fd = sv[0];\n\tfds.events = POLLIN;\n\tfds.revents = 0;\n\tif (poll(&fds, 1, -1) <= 0) {\n\t\tERROR(\"Error getting go-ahead from server: %s\", strerror(errno));\n\t\tgoto out;\n\t}\n\tif (read(sv[0], &buf, 1) != 1) {\n\t\tERROR(\"Error getting reply from server over socketpair\");\n\t\tgoto out;\n\t}\n\tif (send_creds(sv[0], getpid(), getuid(), getgid())) {\n\t\tSYSERROR(\"%s: Error sending pid over SCM_CREDENTIAL\", __func__);\n\t\tgoto out;\n\t}\n\tfds.fd = sv[0];\n\tfds.events = POLLIN;\n\tfds.revents = 0;\n\tif (poll(&fds, 1, -1) <= 0) {\n\t\tERROR(\"Error getting go-ahead from server: %s\", strerror(errno));\n\t\tgoto out;\n\t}\n\tif (read(sv[0], &buf, 1) != 1) {\n\t\tERROR(\"Error getting reply from server over socketpair\");\n\t\tgoto out;\n\t}\n\tif (send_creds(sv[0], getpid(), newuid, 0)) {\n\t\tSYSERROR(\"%s: Error sending pid over SCM_CREDENTIAL\", __func__);\n\t\tgoto out;\n\t}\n\tfds.fd = sv[0];\n\tfds.events = POLLIN;\n\tfds.revents = 0;\n\tif (poll(&fds, 1, -1) <= 0) {\n\t\tERROR(\"Error getting go-ahead from server: %s\", strerror(errno));\n\t\tgoto out;\n\t}\n\tret = read(sv[0], buf, 1);\nout:\n\tclose(sv[0]);\n\tclose(sv[1]);\n\tif (ret == 1 && *buf == '1')\n\t\treturn 0;\n\treturn -1;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int do_chown_cgroup(const char *controller, const char *cgroup_path,\n\t\tuid_t newuid)\n{\n\tint sv[2] = {-1, -1}, optval = 1, ret = -1;\n\tchar buf[1];\n\tstruct pollfd fds;\n\n\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, sv) < 0) {\n\t\tSYSERROR(\"Error creating socketpair\");\n\t\tgoto out;\n\t}\n\tif (setsockopt(sv[1], SOL_SOCKET, SO_PASSCRED, &optval, sizeof(optval)) == -1) {\n\t\tSYSERROR(\"setsockopt failed\");\n\t\tgoto out;\n\t}\n\tif (setsockopt(sv[0], SOL_SOCKET, SO_PASSCRED, &optval, sizeof(optval)) == -1) {\n\t\tSYSERROR(\"setsockopt failed\");\n\t\tgoto out;\n\t}\n\tif ( cgmanager_chown_scm_sync(NULL, cgroup_manager, controller,\n\t\t\t\t       cgroup_path, sv[1]) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_chown_scm_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tgoto out;\n\t}\n\t/* now send credentials */\n\n\tfds.fd = sv[0];\n\tfds.events = POLLIN;\n\tfds.revents = 0;\n\tif (poll(&fds, 1, -1) <= 0) {\n\t\tERROR(\"Error getting go-ahead from server: %s\", strerror(errno));\n\t\tgoto out;\n\t}\n\tif (read(sv[0], &buf, 1) != 1) {\n\t\tERROR(\"Error getting reply from server over socketpair\");\n\t\tgoto out;\n\t}\n\tif (send_creds(sv[0], getpid(), getuid(), getgid())) {\n\t\tSYSERROR(\"%s: Error sending pid over SCM_CREDENTIAL\", __func__);\n\t\tgoto out;\n\t}\n\tfds.fd = sv[0];\n\tfds.events = POLLIN;\n\tfds.revents = 0;\n\tif (poll(&fds, 1, -1) <= 0) {\n\t\tERROR(\"Error getting go-ahead from server: %s\", strerror(errno));\n\t\tgoto out;\n\t}\n\tif (read(sv[0], &buf, 1) != 1) {\n\t\tERROR(\"Error getting reply from server over socketpair\");\n\t\tgoto out;\n\t}\n\tif (send_creds(sv[0], getpid(), newuid, 0)) {\n\t\tSYSERROR(\"%s: Error sending pid over SCM_CREDENTIAL\", __func__);\n\t\tgoto out;\n\t}\n\tfds.fd = sv[0];\n\tfds.events = POLLIN;\n\tfds.revents = 0;\n\tif (poll(&fds, 1, -1) <= 0) {\n\t\tERROR(\"Error getting go-ahead from server: %s\", strerror(errno));\n\t\tgoto out;\n\t}\n\tret = read(sv[0], buf, 1);\nout:\n\tclose(sv[0]);\n\tclose(sv[1]);\n\tif (ret == 1 && *buf == '1')\n\t\treturn 0;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapped_hostid",
          "args": [
            "sb.st_gid",
            "conf",
            "ID_TYPE_GID"
          ],
          "line": 3561
        },
        "resolved": true,
        "details": {
          "function_name": "mapped_hostid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3330-3342",
          "snippet": "int mapped_hostid(unsigned id, struct lxc_conf *conf, enum idtype idtype)\n{\n\tstruct lxc_list *it;\n\tstruct id_map *map;\n\tlxc_list_for_each(it, &conf->id_map) {\n\t\tmap = it->elem;\n\t\tif (map->idtype != idtype)\n\t\t\tcontinue;\n\t\tif (id >= map->hostid && id < map->hostid + map->range)\n\t\t\treturn (id - map->hostid) + map->nsid;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint mapped_hostid(unsigned id, struct lxc_conf *conf, enum idtype idtype)\n{\n\tstruct lxc_list *it;\n\tstruct id_map *map;\n\tlxc_list_for_each(it, &conf->id_map) {\n\t\tmap = it->elem;\n\t\tif (map->idtype != idtype)\n\t\t\tcontinue;\n\t\tif (id >= map->hostid && id < map->hostid + map->range)\n\t\t\treturn (id - map->hostid) + map->nsid;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 3560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error stat %s\"",
            "path"
          ],
          "line": 3552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "path",
            "&sb"
          ],
          "line": 3551
        },
        "resolved": true,
        "details": {
          "function_name": "freezer_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/freezer.c",
          "lines": "42-51",
          "snippet": "lxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}",
          "includes": [
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"monitor.h\"",
            "#include \"state.h\"",
            "#include \"error.h\"",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxc.h\"\n#include \"log.h\"\n#include \"monitor.h\"\n#include \"state.h\"\n#include \"error.h\"\n#include <sys/param.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nlxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getegid",
          "args": [],
          "line": 3539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 3539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed forking\""
          ],
          "line": 3535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 3533
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"%s: container root is our uid;  no need to chown\"",
            "__func__"
          ],
          "line": 3529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 3527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error chowning %s\"",
            "path"
          ],
          "line": 3521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 3519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Bad overlay path: %s\"",
            "path"
          ],
          "line": 3513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "chownpath+1",
            "':'"
          ],
          "line": 3511
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Bad overlay path: %s\"",
            "path"
          ],
          "line": 3508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "path",
            "\"aufs:\"",
            "5"
          ],
          "line": 3505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "path",
            "\"overlayfs:\"",
            "10"
          ],
          "line": 3505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"No mapping for container root\""
          ],
          "line": 3496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mapped_rootid",
          "args": [
            "conf",
            "ID_TYPE_GID",
            "&val"
          ],
          "line": 3495
        },
        "resolved": true,
        "details": {
          "function_name": "get_mapped_rootid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3312-3328",
          "snippet": "bool get_mapped_rootid(struct lxc_conf *conf, enum idtype idtype,\n\t\t\tunsigned long *val)\n{\n\tstruct lxc_list *it;\n\tstruct id_map *map;\n\n\tlxc_list_for_each(it, &conf->id_map) {\n\t\tmap = it->elem;\n\t\tif (map->idtype != idtype)\n\t\t\tcontinue;\n\t\tif (map->nsid != 0)\n\t\t\tcontinue;\n\t\t*val = map->hostid;\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool get_mapped_rootid(struct lxc_conf *conf, enum idtype idtype,\n\t\t\tunsigned long *val)\n{\n\tstruct lxc_list *it;\n\tstruct id_map *map;\n\n\tlxc_list_for_each(it, &conf->id_map) {\n\t\tmap = it->elem;\n\t\tif (map->idtype != idtype)\n\t\t\tcontinue;\n\t\tif (map->nsid != 0)\n\t\t\tcontinue;\n\t\t*val = map->hostid;\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"No mapping for container root\""
          ],
          "line": 3491
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint chown_mapped_root(char *path, struct lxc_conf *conf)\n{\n\tuid_t rootuid;\n\tgid_t rootgid;\n\tpid_t pid;\n\tunsigned long val;\n\tchar *chownpath = path;\n\n\tif (!get_mapped_rootid(conf, ID_TYPE_UID, &val)) {\n\t\tERROR(\"No mapping for container root\");\n\t\treturn -1;\n\t}\n\trootuid = (uid_t) val;\n\tif (!get_mapped_rootid(conf, ID_TYPE_GID, &val)) {\n\t\tERROR(\"No mapping for container root\");\n\t\treturn -1;\n\t}\n\trootgid = (gid_t) val;\n\n\t/*\n\t * In case of overlay, we want only the writeable layer\n\t * to be chowned\n\t */\n\tif (strncmp(path, \"overlayfs:\", 10) == 0 || strncmp(path, \"aufs:\", 5) == 0) {\n\t\tchownpath = strchr(path, ':');\n\t\tif (!chownpath) {\n\t\t\tERROR(\"Bad overlay path: %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tchownpath = strchr(chownpath+1, ':');\n\t\tif (!chownpath) {\n\t\t\tERROR(\"Bad overlay path: %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tchownpath++;\n\t}\n\tpath = chownpath;\n\tif (geteuid() == 0) {\n\t\tif (chown(path, rootuid, rootgid) < 0) {\n\t\t\tERROR(\"Error chowning %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (rootuid == geteuid()) {\n\t\t// nothing to do\n\t\tINFO(\"%s: container root is our uid;  no need to chown\" ,__func__);\n\t\treturn 0;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"Failed forking\");\n\t\treturn -1;\n\t}\n\tif (!pid) {\n\t\tint hostuid = geteuid(), hostgid = getegid(), ret;\n\t\tstruct stat sb;\n\t\tchar map1[100], map2[100], map3[100], map4[100], map5[100];\n\t\tchar ugid[100];\n\t\tchar *args1[] = { \"lxc-usernsexec\", \"-m\", map1, \"-m\", map2,\n\t\t\t\t\"-m\", map3, \"-m\", map5,\n\t\t\t\t\"--\", \"chown\", ugid, path, NULL };\n\t\tchar *args2[] = { \"lxc-usernsexec\", \"-m\", map1, \"-m\", map2,\n\t\t\t\t\"-m\", map3, \"-m\", map4, \"-m\", map5,\n\t\t\t\t\"--\", \"chown\", ugid, path, NULL };\n\n\t\t// save the current gid of \"path\"\n\t\tif (stat(path, &sb) < 0) {\n\t\t\tERROR(\"Error stat %s\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * A file has to be group-owned by a gid mapped into the\n\t\t * container, or the container won't be privileged over it.\n\t\t */\n\t\tif (sb.st_uid == geteuid() &&\n\t\t\t\tmapped_hostid(sb.st_gid, conf, ID_TYPE_GID) < 0 &&\n\t\t\t\tchown(path, -1, hostgid) < 0) {\n\t\t\tERROR(\"Failed chgrping %s\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"u:0:rootuid:1\"\n\t\tret = snprintf(map1, 100, \"u:0:%d:1\", rootuid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error uid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"u:hostuid:hostuid:1\"\n\t\tret = snprintf(map2, 100, \"u:%d:%d:1\", hostuid, hostuid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error uid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:0:rootgid:1\"\n\t\tret = snprintf(map3, 100, \"g:0:%d:1\", rootgid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:pathgid:rootgid+pathgid:1\"\n\t\tret = snprintf(map4, 100, \"g:%d:%d:1\", (gid_t)sb.st_gid,\n\t\t\t\trootgid + (gid_t)sb.st_gid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:hostgid:hostgid:1\"\n\t\tret = snprintf(map5, 100, \"g:%d:%d:1\", hostgid, hostgid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"0:pathgid\" (chown)\n\t\tret = snprintf(ugid, 100, \"0:%d\", (gid_t)sb.st_gid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error owner printing format string for chown\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (hostgid == sb.st_gid)\n\t\t\tret = execvp(\"lxc-usernsexec\", args1);\n\t\telse\n\t\t\tret = execvp(\"lxc-usernsexec\", args2);\n\t\tSYSERROR(\"Failed executing usernsexec\");\n\t\texit(1);\n\t}\n\treturn wait_for_pid(pid);\n}"
  },
  {
    "function_name": "lxc_delete_tty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "3458-3472",
    "snippet": "void lxc_delete_tty(struct lxc_tty_info *tty_info)\n{\n\tint i;\n\n\tfor (i = 0; i < tty_info->nbtty; i++) {\n\t\tstruct lxc_pty_info *pty_info = &tty_info->pty_info[i];\n\n\t\tclose(pty_info->master);\n\t\tclose(pty_info->slave);\n\t}\n\n\tfree(tty_info->pty_info);\n\ttty_info->pty_info = NULL;\n\ttty_info->nbtty = 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tty_info->pty_info"
          ],
          "line": 3469
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4619-4628",
          "snippet": "static void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "pty_info->slave"
          ],
          "line": 3466
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid lxc_delete_tty(struct lxc_tty_info *tty_info)\n{\n\tint i;\n\n\tfor (i = 0; i < tty_info->nbtty; i++) {\n\t\tstruct lxc_pty_info *pty_info = &tty_info->pty_info[i];\n\n\t\tclose(pty_info->master);\n\t\tclose(pty_info->slave);\n\t}\n\n\tfree(tty_info->pty_info);\n\ttty_info->pty_info = NULL;\n\ttty_info->nbtty = 0;\n}"
  },
  {
    "function_name": "lxc_create_tty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "3410-3456",
    "snippet": "int lxc_create_tty(const char *name, struct lxc_conf *conf)\n{\n\tstruct lxc_tty_info *tty_info = &conf->tty_info;\n\tint i, ret;\n\n\t/* no tty in the configuration */\n\tif (!conf->tty)\n\t\treturn 0;\n\n\ttty_info->pty_info =\n\t\tmalloc(sizeof(*tty_info->pty_info)*conf->tty);\n\tif (!tty_info->pty_info) {\n\t\tSYSERROR(\"failed to allocate pty_info\");\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < conf->tty; i++) {\n\n\t\tstruct lxc_pty_info *pty_info = &tty_info->pty_info[i];\n\n\t\tprocess_lock();\n\t\tret = openpty(&pty_info->master, &pty_info->slave,\n\t\t\t    pty_info->name, NULL, NULL);\n\t\tprocess_unlock();\n\t\tif (ret) {\n\t\t\tSYSERROR(\"failed to create pty #%d\", i);\n\t\t\ttty_info->nbtty = i;\n\t\t\tlxc_delete_tty(tty_info);\n\t\t\treturn -1;\n\t\t}\n\n\t\tDEBUG(\"allocated pty '%s' (%d/%d)\",\n\t\t      pty_info->name, pty_info->master, pty_info->slave);\n\n\t\t/* Prevent leaking the file descriptors to the container */\n\t\tfcntl(pty_info->master, F_SETFD, FD_CLOEXEC);\n\t\tfcntl(pty_info->slave, F_SETFD, FD_CLOEXEC);\n\n\t\tpty_info->busy = 0;\n\t}\n\n\ttty_info->nbtty = conf->tty;\n\n\tINFO(\"tty's configured\");\n\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"tty's configured\""
          ],
          "line": 3453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "pty_info->slave",
            "F_SETFD",
            "FD_CLOEXEC"
          ],
          "line": 3446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "pty_info->master",
            "F_SETFD",
            "FD_CLOEXEC"
          ],
          "line": 3445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"allocated pty '%s' (%d/%d)\"",
            "pty_info->name",
            "pty_info->master",
            "pty_info->slave"
          ],
          "line": 3441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_delete_tty",
          "args": [
            "tty_info"
          ],
          "line": 3437
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_delete_tty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3458-3472",
          "snippet": "void lxc_delete_tty(struct lxc_tty_info *tty_info)\n{\n\tint i;\n\n\tfor (i = 0; i < tty_info->nbtty; i++) {\n\t\tstruct lxc_pty_info *pty_info = &tty_info->pty_info[i];\n\n\t\tclose(pty_info->master);\n\t\tclose(pty_info->slave);\n\t}\n\n\tfree(tty_info->pty_info);\n\ttty_info->pty_info = NULL;\n\ttty_info->nbtty = 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid lxc_delete_tty(struct lxc_tty_info *tty_info)\n{\n\tint i;\n\n\tfor (i = 0; i < tty_info->nbtty; i++) {\n\t\tstruct lxc_pty_info *pty_info = &tty_info->pty_info[i];\n\n\t\tclose(pty_info->master);\n\t\tclose(pty_info->slave);\n\t}\n\n\tfree(tty_info->pty_info);\n\ttty_info->pty_info = NULL;\n\ttty_info->nbtty = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to create pty #%d\"",
            "i"
          ],
          "line": 3435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_unlock",
          "args": [],
          "line": 3433
        },
        "resolved": true,
        "details": {
          "function_name": "process_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "320-323",
          "snippet": "void process_unlock(void)\n{\n\tunlock_mutex(&thread_mutex);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nvoid process_unlock(void)\n{\n\tunlock_mutex(&thread_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "openpty",
          "args": [
            "&pty_info->master",
            "&pty_info->slave",
            "pty_info->name",
            "NULL",
            "NULL"
          ],
          "line": 3431
        },
        "resolved": true,
        "details": {
          "function_name": "openpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/openpty.c",
          "lines": "37-76",
          "snippet": "int openpty (int *amaster, int *aslave, char *name, struct termios *termp,\n       struct winsize *winp)\n{\n   char buf[PATH_MAX];\n   int master, slave;\n\n   master = open(_PATH_DEVPTMX, O_RDWR);\n   if (master == -1)\n       return -1;\n\n   if (grantpt(master))\n       goto fail;\n\n   if (unlockpt(master))\n       goto fail;\n\n   if (ptsname_r(master, buf, sizeof buf))\n       goto fail;\n\n   slave = open(buf, O_RDWR | O_NOCTTY);\n   if (slave == -1)\n       goto fail;\n\n   /* XXX Should we ignore errors here?  */\n   if (termp)\n       tcsetattr(slave, TCSAFLUSH, termp);\n   if (winp)\n       ioctl(slave, TIOCSWINSZ, winp);\n\n   *amaster = master;\n   *aslave = slave;\n   if (name != NULL)\n       strcpy(name, buf);\n\n   return 0;\n\nfail:\n   close(master);\n   return -1;\n}",
          "includes": [
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [
            "#define _PATH_DEVPTMX \"/dev/ptmx\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/ioctl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define _PATH_DEVPTMX \"/dev/ptmx\"\n\nint openpty (int *amaster, int *aslave, char *name, struct termios *termp,\n       struct winsize *winp)\n{\n   char buf[PATH_MAX];\n   int master, slave;\n\n   master = open(_PATH_DEVPTMX, O_RDWR);\n   if (master == -1)\n       return -1;\n\n   if (grantpt(master))\n       goto fail;\n\n   if (unlockpt(master))\n       goto fail;\n\n   if (ptsname_r(master, buf, sizeof buf))\n       goto fail;\n\n   slave = open(buf, O_RDWR | O_NOCTTY);\n   if (slave == -1)\n       goto fail;\n\n   /* XXX Should we ignore errors here?  */\n   if (termp)\n       tcsetattr(slave, TCSAFLUSH, termp);\n   if (winp)\n       ioctl(slave, TIOCSWINSZ, winp);\n\n   *amaster = master;\n   *aslave = slave;\n   if (name != NULL)\n       strcpy(name, buf);\n\n   return 0;\n\nfail:\n   close(master);\n   return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_lock",
          "args": [],
          "line": 3430
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to allocate pty_info\""
          ],
          "line": 3422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*tty_info->pty_info)*conf->tty"
          ],
          "line": 3420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_create_tty(const char *name, struct lxc_conf *conf)\n{\n\tstruct lxc_tty_info *tty_info = &conf->tty_info;\n\tint i, ret;\n\n\t/* no tty in the configuration */\n\tif (!conf->tty)\n\t\treturn 0;\n\n\ttty_info->pty_info =\n\t\tmalloc(sizeof(*tty_info->pty_info)*conf->tty);\n\tif (!tty_info->pty_info) {\n\t\tSYSERROR(\"failed to allocate pty_info\");\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < conf->tty; i++) {\n\n\t\tstruct lxc_pty_info *pty_info = &tty_info->pty_info[i];\n\n\t\tprocess_lock();\n\t\tret = openpty(&pty_info->master, &pty_info->slave,\n\t\t\t    pty_info->name, NULL, NULL);\n\t\tprocess_unlock();\n\t\tif (ret) {\n\t\t\tSYSERROR(\"failed to create pty #%d\", i);\n\t\t\ttty_info->nbtty = i;\n\t\t\tlxc_delete_tty(tty_info);\n\t\t\treturn -1;\n\t\t}\n\n\t\tDEBUG(\"allocated pty '%s' (%d/%d)\",\n\t\t      pty_info->name, pty_info->master, pty_info->slave);\n\n\t\t/* Prevent leaking the file descriptors to the container */\n\t\tfcntl(pty_info->master, F_SETFD, FD_CLOEXEC);\n\t\tfcntl(pty_info->slave, F_SETFD, FD_CLOEXEC);\n\n\t\tpty_info->busy = 0;\n\t}\n\n\ttty_info->nbtty = conf->tty;\n\n\tINFO(\"tty's configured\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_find_gateway_addresses",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "3362-3408",
    "snippet": "int lxc_find_gateway_addresses(struct lxc_handler *handler)\n{\n\tstruct lxc_list *network = &handler->conf->network;\n\tstruct lxc_list *iterator;\n\tstruct lxc_netdev *netdev;\n\tint link_index;\n\n\tlxc_list_for_each(iterator, network) {\n\t\tnetdev = iterator->elem;\n\n\t\tif (!netdev->ipv4_gateway_auto && !netdev->ipv6_gateway_auto)\n\t\t\tcontinue;\n\n\t\tif (netdev->type != LXC_NET_VETH && netdev->type != LXC_NET_MACVLAN) {\n\t\t\tERROR(\"gateway = auto only supported for \"\n\t\t\t      \"veth and macvlan\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (!netdev->link) {\n\t\t\tERROR(\"gateway = auto needs a link interface\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tlink_index = if_nametoindex(netdev->link);\n\t\tif (!link_index)\n\t\t\treturn -EINVAL;\n\n\t\tif (netdev->ipv4_gateway_auto) {\n\t\t\tif (lxc_ipv4_addr_get(link_index, &netdev->ipv4_gateway)) {\n\t\t\t\tERROR(\"failed to automatically find ipv4 gateway \"\n\t\t\t\t      \"address from link interface '%s'\", netdev->link);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (netdev->ipv6_gateway_auto) {\n\t\t\tif (lxc_ipv6_addr_get(link_index, &netdev->ipv6_gateway)) {\n\t\t\t\tERROR(\"failed to automatically find ipv6 gateway \"\n\t\t\t\t      \"address from link interface '%s'\", netdev->link);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_none(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_none(struct lxc_handler *, struct lxc_netdev *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to automatically find ipv6 gateway \"\n\t\t\t\t      \"address from link interface '%s'\"",
            "netdev->link"
          ],
          "line": 3400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_ipv6_addr_get",
          "args": [
            "link_index",
            "&netdev->ipv6_gateway"
          ],
          "line": 3399
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_ipv6_addr_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "1259-1262",
          "snippet": "int lxc_ipv6_addr_get(int ifindex, struct in6_addr **res)\n{\n\treturn ip_addr_get(AF_INET6, ifindex, (void**)res);\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_ipv6_addr_get(int ifindex, struct in6_addr **res)\n{\n\treturn ip_addr_get(AF_INET6, ifindex, (void**)res);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to automatically find ipv4 gateway \"\n\t\t\t\t      \"address from link interface '%s'\"",
            "netdev->link"
          ],
          "line": 3392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_ipv4_addr_get",
          "args": [
            "link_index",
            "&netdev->ipv4_gateway"
          ],
          "line": 3391
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_ipv4_addr_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "1264-1267",
          "snippet": "int lxc_ipv4_addr_get(int ifindex, struct in_addr** res)\n{\n\treturn ip_addr_get(AF_INET, ifindex, (void**)res);\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_ipv4_addr_get(int ifindex, struct in_addr** res)\n{\n\treturn ip_addr_get(AF_INET, ifindex, (void**)res);\n}"
        }
      },
      {
        "call_info": {
          "callee": "if_nametoindex",
          "args": [
            "netdev->link"
          ],
          "line": 3386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"gateway = auto needs a link interface\""
          ],
          "line": 3382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"gateway = auto only supported for \"\n\t\t\t      \"veth and macvlan\""
          ],
          "line": 3376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "iterator",
            "network"
          ],
          "line": 3369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_none(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_none(struct lxc_handler *, struct lxc_netdev *);\n\nint lxc_find_gateway_addresses(struct lxc_handler *handler)\n{\n\tstruct lxc_list *network = &handler->conf->network;\n\tstruct lxc_list *iterator;\n\tstruct lxc_netdev *netdev;\n\tint link_index;\n\n\tlxc_list_for_each(iterator, network) {\n\t\tnetdev = iterator->elem;\n\n\t\tif (!netdev->ipv4_gateway_auto && !netdev->ipv6_gateway_auto)\n\t\t\tcontinue;\n\n\t\tif (netdev->type != LXC_NET_VETH && netdev->type != LXC_NET_MACVLAN) {\n\t\t\tERROR(\"gateway = auto only supported for \"\n\t\t\t      \"veth and macvlan\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (!netdev->link) {\n\t\t\tERROR(\"gateway = auto needs a link interface\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tlink_index = if_nametoindex(netdev->link);\n\t\tif (!link_index)\n\t\t\treturn -EINVAL;\n\n\t\tif (netdev->ipv4_gateway_auto) {\n\t\t\tif (lxc_ipv4_addr_get(link_index, &netdev->ipv4_gateway)) {\n\t\t\t\tERROR(\"failed to automatically find ipv4 gateway \"\n\t\t\t\t      \"address from link interface '%s'\", netdev->link);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (netdev->ipv6_gateway_auto) {\n\t\t\tif (lxc_ipv6_addr_get(link_index, &netdev->ipv6_gateway)) {\n\t\t\t\tERROR(\"failed to automatically find ipv6 gateway \"\n\t\t\t\t      \"address from link interface '%s'\", netdev->link);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "find_unmapped_nsuid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "3344-3360",
    "snippet": "int find_unmapped_nsuid(struct lxc_conf *conf, enum idtype idtype)\n{\n\tstruct lxc_list *it;\n\tstruct id_map *map;\n\tunsigned int freeid = 0;\nagain:\n\tlxc_list_for_each(it, &conf->id_map) {\n\t\tmap = it->elem;\n\t\tif (map->idtype != idtype)\n\t\t\tcontinue;\n\t\tif (freeid >= map->nsid && freeid < map->nsid + map->range) {\n\t\t\tfreeid = map->nsid + map->range;\n\t\t\tgoto again;\n\t\t}\n\t}\n\treturn freeid;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "it",
            "&conf->id_map"
          ],
          "line": 3350
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint find_unmapped_nsuid(struct lxc_conf *conf, enum idtype idtype)\n{\n\tstruct lxc_list *it;\n\tstruct id_map *map;\n\tunsigned int freeid = 0;\nagain:\n\tlxc_list_for_each(it, &conf->id_map) {\n\t\tmap = it->elem;\n\t\tif (map->idtype != idtype)\n\t\t\tcontinue;\n\t\tif (freeid >= map->nsid && freeid < map->nsid + map->range) {\n\t\t\tfreeid = map->nsid + map->range;\n\t\t\tgoto again;\n\t\t}\n\t}\n\treturn freeid;\n}"
  },
  {
    "function_name": "mapped_hostid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "3330-3342",
    "snippet": "int mapped_hostid(unsigned id, struct lxc_conf *conf, enum idtype idtype)\n{\n\tstruct lxc_list *it;\n\tstruct id_map *map;\n\tlxc_list_for_each(it, &conf->id_map) {\n\t\tmap = it->elem;\n\t\tif (map->idtype != idtype)\n\t\t\tcontinue;\n\t\tif (id >= map->hostid && id < map->hostid + map->range)\n\t\t\treturn (id - map->hostid) + map->nsid;\n\t}\n\treturn -1;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "it",
            "&conf->id_map"
          ],
          "line": 3334
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint mapped_hostid(unsigned id, struct lxc_conf *conf, enum idtype idtype)\n{\n\tstruct lxc_list *it;\n\tstruct id_map *map;\n\tlxc_list_for_each(it, &conf->id_map) {\n\t\tmap = it->elem;\n\t\tif (map->idtype != idtype)\n\t\t\tcontinue;\n\t\tif (id >= map->hostid && id < map->hostid + map->range)\n\t\t\treturn (id - map->hostid) + map->nsid;\n\t}\n\treturn -1;\n}"
  },
  {
    "function_name": "get_mapped_rootid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "3312-3328",
    "snippet": "bool get_mapped_rootid(struct lxc_conf *conf, enum idtype idtype,\n\t\t\tunsigned long *val)\n{\n\tstruct lxc_list *it;\n\tstruct id_map *map;\n\n\tlxc_list_for_each(it, &conf->id_map) {\n\t\tmap = it->elem;\n\t\tif (map->idtype != idtype)\n\t\t\tcontinue;\n\t\tif (map->nsid != 0)\n\t\t\tcontinue;\n\t\t*val = map->hostid;\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "it",
            "&conf->id_map"
          ],
          "line": 3318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool get_mapped_rootid(struct lxc_conf *conf, enum idtype idtype,\n\t\t\tunsigned long *val)\n{\n\tstruct lxc_list *it;\n\tstruct id_map *map;\n\n\tlxc_list_for_each(it, &conf->id_map) {\n\t\tmap = it->elem;\n\t\tif (map->idtype != idtype)\n\t\t\tcontinue;\n\t\tif (map->nsid != 0)\n\t\t\tcontinue;\n\t\t*val = map->hostid;\n\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "lxc_map_ids",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "3230-3305",
    "snippet": "int lxc_map_ids(struct lxc_list *idmap, pid_t pid)\n{\n\tstruct lxc_list *iterator;\n\tstruct id_map *map;\n\tint ret = 0, use_shadow = 0;\n\tenum idtype type;\n\tchar *buf = NULL, *pos, *cmdpath = NULL;\n\n\t/*\n\t * If newuidmap exists, that is, if shadow is handing out subuid\n\t * ranges, then insist that root also reserve ranges in subuid.  This\n\t * will protected it by preventing another user from being handed the\n\t * range by shadow.\n\t */\n\tcmdpath = on_path(\"newuidmap\", NULL);\n\tif (cmdpath) {\n\t\tuse_shadow = 1;\n\t\tfree(cmdpath);\n\t}\n\n\tif (!use_shadow && geteuid()) {\n\t\tERROR(\"Missing newuidmap/newgidmap\");\n\t\treturn -1;\n\t}\n\n\tfor(type = ID_TYPE_UID; type <= ID_TYPE_GID; type++) {\n\t\tint left, fill;\n\t\tint had_entry = 0;\n\t\tif (!buf) {\n\t\t\tbuf = pos = malloc(4096);\n\t\t\tif (!buf)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tpos = buf;\n\t\tif (use_shadow)\n\t\t\tpos += sprintf(buf, \"new%cidmap %d\",\n\t\t\t\ttype == ID_TYPE_UID ? 'u' : 'g',\n\t\t\t\tpid);\n\n\t\tlxc_list_for_each(iterator, idmap) {\n\t\t\t/* The kernel only takes <= 4k for writes to /proc/<nr>/[ug]id_map */\n\t\t\tmap = iterator->elem;\n\t\t\tif (map->idtype != type)\n\t\t\t\tcontinue;\n\n\t\t\thad_entry = 1;\n\t\t\tleft = 4096 - (pos - buf);\n\t\t\tfill = snprintf(pos, left, \"%s%lu %lu %lu%s\",\n\t\t\t\t\tuse_shadow ? \" \" : \"\",\n\t\t\t\t\tmap->nsid, map->hostid, map->range,\n\t\t\t\t\tuse_shadow ? \"\" : \"\\n\");\n\t\t\tif (fill <= 0 || fill >= left)\n\t\t\t\tSYSERROR(\"snprintf failed, too many mappings\");\n\t\t\tpos += fill;\n\t\t}\n\t\tif (!had_entry)\n\t\t\tcontinue;\n\n\t\tif (!use_shadow) {\n\t\t\tret = write_id_mapping(type, pid, buf, pos-buf);\n\t\t} else {\n\t\t\tleft = 4096 - (pos - buf);\n\t\t\tfill = snprintf(pos, left, \"\\n\");\n\t\t\tif (fill <= 0 || fill >= left)\n\t\t\t\tSYSERROR(\"snprintf failed, too many mappings\");\n\t\t\tpos += fill;\n\t\t\tret = system(buf);\n\t\t}\n\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tfree(buf);\n\treturn ret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "buf"
          ],
          "line": 3303
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4619-4628",
          "snippet": "static void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "buf"
          ],
          "line": 3296
        },
        "resolved": true,
        "details": {
          "function_name": "mount_entry_on_systemfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1871-1889",
          "snippet": "static inline int mount_entry_on_systemfs(struct mntent *mntent)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\n\t/* For containers created without a rootfs all mounts are treated as\n\t * absolute paths starting at / on the host. */\n\tif (mntent->mnt_dir[0] != '/')\n\t\tret = snprintf(path, sizeof(path), \"/%s\", mntent->mnt_dir);\n\telse\n\t\tret = snprintf(path, sizeof(path), \"%s\", mntent->mnt_dir);\n\n\tif (ret < 0 || ret >= sizeof(path)) {\n\t\tERROR(\"path name too long\");\n\t\treturn -1;\n\t}\n\n\treturn mount_entry_on_generic(mntent, path, NULL, NULL, NULL);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic inline int mount_entry_on_systemfs(struct mntent *mntent)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\n\t/* For containers created without a rootfs all mounts are treated as\n\t * absolute paths starting at / on the host. */\n\tif (mntent->mnt_dir[0] != '/')\n\t\tret = snprintf(path, sizeof(path), \"/%s\", mntent->mnt_dir);\n\telse\n\t\tret = snprintf(path, sizeof(path), \"%s\", mntent->mnt_dir);\n\n\tif (ret < 0 || ret >= sizeof(path)) {\n\t\tERROR(\"path name too long\");\n\t\treturn -1;\n\t}\n\n\treturn mount_entry_on_generic(mntent, path, NULL, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"snprintf failed, too many mappings\""
          ],
          "line": 3294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "pos",
            "left",
            "\"\\n\""
          ],
          "line": 3292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_id_mapping",
          "args": [
            "type",
            "pid",
            "buf",
            "pos-buf"
          ],
          "line": 3289
        },
        "resolved": true,
        "details": {
          "function_name": "write_id_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3204-3228",
          "snippet": "static int write_id_mapping(enum idtype idtype, pid_t pid, const char *buf,\n\t\t\t    size_t buf_size)\n{\n\tchar path[PATH_MAX];\n\tint ret, closeret;\n\tFILE *f;\n\n\tret = snprintf(path, PATH_MAX, \"/proc/%d/%cid_map\", pid, idtype == ID_TYPE_UID ? 'u' : 'g');\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tfprintf(stderr, \"%s: path name too long\\n\", __func__);\n\t\treturn -E2BIG;\n\t}\n\tf = fopen(path, \"w\");\n\tif (!f) {\n\t\tperror(\"open\");\n\t\treturn -EINVAL;\n\t}\n\tret = fwrite(buf, buf_size, 1, f);\n\tif (ret < 0)\n\t\tSYSERROR(\"writing id mapping\");\n\tcloseret = fclose(f);\n\tif (closeret)\n\t\tSYSERROR(\"writing id mapping\");\n\treturn ret < 0 ? ret : closeret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int write_id_mapping(enum idtype idtype, pid_t pid, const char *buf,\n\t\t\t    size_t buf_size)\n{\n\tchar path[PATH_MAX];\n\tint ret, closeret;\n\tFILE *f;\n\n\tret = snprintf(path, PATH_MAX, \"/proc/%d/%cid_map\", pid, idtype == ID_TYPE_UID ? 'u' : 'g');\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tfprintf(stderr, \"%s: path name too long\\n\", __func__);\n\t\treturn -E2BIG;\n\t}\n\tf = fopen(path, \"w\");\n\tif (!f) {\n\t\tperror(\"open\");\n\t\treturn -EINVAL;\n\t}\n\tret = fwrite(buf, buf_size, 1, f);\n\tif (ret < 0)\n\t\tSYSERROR(\"writing id mapping\");\n\tcloseret = fclose(f);\n\tif (closeret)\n\t\tSYSERROR(\"writing id mapping\");\n\treturn ret < 0 ? ret : closeret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"snprintf failed, too many mappings\""
          ],
          "line": 3282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "pos",
            "left",
            "\"%s%lu %lu %lu%s\"",
            "use_shadow ? \" \" : \"\"",
            "map->nsid",
            "map->hostid",
            "map->range",
            "use_shadow ? \"\" : \"\\n\""
          ],
          "line": 3277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "iterator",
            "idmap"
          ],
          "line": 3269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"new%cidmap %d\"",
            "type == ID_TYPE_UID ? 'u' : 'g'",
            "pid"
          ],
          "line": 3265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "4096"
          ],
          "line": 3259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Missing newuidmap/newgidmap\""
          ],
          "line": 3251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 3250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on_path",
          "args": [
            "\"newuidmap\"",
            "NULL"
          ],
          "line": 3244
        },
        "resolved": true,
        "details": {
          "function_name": "on_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1202-1238",
          "snippet": "char *on_path(char *cmd, const char *rootfs) {\n\tchar *path = NULL;\n\tchar *entry = NULL;\n\tchar *saveptr = NULL;\n\tchar cmdpath[MAXPATHLEN];\n\tint ret;\n\n\tpath = getenv(\"PATH\");\n\tif (!path)\n\t\treturn NULL;\n\n\tpath = strdup(path);\n\tif (!path)\n\t\treturn NULL;\n\n\tentry = strtok_r(path, \":\", &saveptr);\n\twhile (entry) {\n\t\tif (rootfs)\n\t\t\tret = snprintf(cmdpath, MAXPATHLEN, \"%s/%s/%s\", rootfs, entry, cmd);\n\t\telse\n\t\t\tret = snprintf(cmdpath, MAXPATHLEN, \"%s/%s\", entry, cmd);\n\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\tgoto next_loop;\n\n\t\tif (access(cmdpath, X_OK) == 0) {\n\t\t\tfree(path);\n\t\t\treturn strdup(cmdpath);\n\t\t}\n\nnext_loop:\n\t\tentry = strtok_r(NULL, \":\", &saveptr);\n\t}\n\n\tfree(path);\n\treturn NULL;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool btrfs_try_remove_subvol(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nchar *on_path(char *cmd, const char *rootfs) {\n\tchar *path = NULL;\n\tchar *entry = NULL;\n\tchar *saveptr = NULL;\n\tchar cmdpath[MAXPATHLEN];\n\tint ret;\n\n\tpath = getenv(\"PATH\");\n\tif (!path)\n\t\treturn NULL;\n\n\tpath = strdup(path);\n\tif (!path)\n\t\treturn NULL;\n\n\tentry = strtok_r(path, \":\", &saveptr);\n\twhile (entry) {\n\t\tif (rootfs)\n\t\t\tret = snprintf(cmdpath, MAXPATHLEN, \"%s/%s/%s\", rootfs, entry, cmd);\n\t\telse\n\t\t\tret = snprintf(cmdpath, MAXPATHLEN, \"%s/%s\", entry, cmd);\n\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\tgoto next_loop;\n\n\t\tif (access(cmdpath, X_OK) == 0) {\n\t\t\tfree(path);\n\t\t\treturn strdup(cmdpath);\n\t\t}\n\nnext_loop:\n\t\tentry = strtok_r(NULL, \":\", &saveptr);\n\t}\n\n\tfree(path);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_map_ids(struct lxc_list *idmap, pid_t pid)\n{\n\tstruct lxc_list *iterator;\n\tstruct id_map *map;\n\tint ret = 0, use_shadow = 0;\n\tenum idtype type;\n\tchar *buf = NULL, *pos, *cmdpath = NULL;\n\n\t/*\n\t * If newuidmap exists, that is, if shadow is handing out subuid\n\t * ranges, then insist that root also reserve ranges in subuid.  This\n\t * will protected it by preventing another user from being handed the\n\t * range by shadow.\n\t */\n\tcmdpath = on_path(\"newuidmap\", NULL);\n\tif (cmdpath) {\n\t\tuse_shadow = 1;\n\t\tfree(cmdpath);\n\t}\n\n\tif (!use_shadow && geteuid()) {\n\t\tERROR(\"Missing newuidmap/newgidmap\");\n\t\treturn -1;\n\t}\n\n\tfor(type = ID_TYPE_UID; type <= ID_TYPE_GID; type++) {\n\t\tint left, fill;\n\t\tint had_entry = 0;\n\t\tif (!buf) {\n\t\t\tbuf = pos = malloc(4096);\n\t\t\tif (!buf)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tpos = buf;\n\t\tif (use_shadow)\n\t\t\tpos += sprintf(buf, \"new%cidmap %d\",\n\t\t\t\ttype == ID_TYPE_UID ? 'u' : 'g',\n\t\t\t\tpid);\n\n\t\tlxc_list_for_each(iterator, idmap) {\n\t\t\t/* The kernel only takes <= 4k for writes to /proc/<nr>/[ug]id_map */\n\t\t\tmap = iterator->elem;\n\t\t\tif (map->idtype != type)\n\t\t\t\tcontinue;\n\n\t\t\thad_entry = 1;\n\t\t\tleft = 4096 - (pos - buf);\n\t\t\tfill = snprintf(pos, left, \"%s%lu %lu %lu%s\",\n\t\t\t\t\tuse_shadow ? \" \" : \"\",\n\t\t\t\t\tmap->nsid, map->hostid, map->range,\n\t\t\t\t\tuse_shadow ? \"\" : \"\\n\");\n\t\t\tif (fill <= 0 || fill >= left)\n\t\t\t\tSYSERROR(\"snprintf failed, too many mappings\");\n\t\t\tpos += fill;\n\t\t}\n\t\tif (!had_entry)\n\t\t\tcontinue;\n\n\t\tif (!use_shadow) {\n\t\t\tret = write_id_mapping(type, pid, buf, pos-buf);\n\t\t} else {\n\t\t\tleft = 4096 - (pos - buf);\n\t\t\tfill = snprintf(pos, left, \"\\n\");\n\t\t\tif (fill <= 0 || fill >= left)\n\t\t\t\tSYSERROR(\"snprintf failed, too many mappings\");\n\t\t\tpos += fill;\n\t\t\tret = system(buf);\n\t\t}\n\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tfree(buf);\n\treturn ret;\n}"
  },
  {
    "function_name": "write_id_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "3204-3228",
    "snippet": "static int write_id_mapping(enum idtype idtype, pid_t pid, const char *buf,\n\t\t\t    size_t buf_size)\n{\n\tchar path[PATH_MAX];\n\tint ret, closeret;\n\tFILE *f;\n\n\tret = snprintf(path, PATH_MAX, \"/proc/%d/%cid_map\", pid, idtype == ID_TYPE_UID ? 'u' : 'g');\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tfprintf(stderr, \"%s: path name too long\\n\", __func__);\n\t\treturn -E2BIG;\n\t}\n\tf = fopen(path, \"w\");\n\tif (!f) {\n\t\tperror(\"open\");\n\t\treturn -EINVAL;\n\t}\n\tret = fwrite(buf, buf_size, 1, f);\n\tif (ret < 0)\n\t\tSYSERROR(\"writing id mapping\");\n\tcloseret = fclose(f);\n\tif (closeret)\n\t\tSYSERROR(\"writing id mapping\");\n\treturn ret < 0 ? ret : closeret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"writing id mapping\""
          ],
          "line": 3226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 3224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"writing id mapping\""
          ],
          "line": 3223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fwrite",
          "args": [
            "buf",
            "buf_size",
            "1",
            "f"
          ],
          "line": 3221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"open\""
          ],
          "line": 3218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "path",
            "\"w\""
          ],
          "line": 3216
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: path name too long\\n\"",
            "__func__"
          ],
          "line": 3213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "PATH_MAX",
            "\"/proc/%d/%cid_map\"",
            "pid",
            "idtype == ID_TYPE_UID ? 'u' : 'g'"
          ],
          "line": 3211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int write_id_mapping(enum idtype idtype, pid_t pid, const char *buf,\n\t\t\t    size_t buf_size)\n{\n\tchar path[PATH_MAX];\n\tint ret, closeret;\n\tFILE *f;\n\n\tret = snprintf(path, PATH_MAX, \"/proc/%d/%cid_map\", pid, idtype == ID_TYPE_UID ? 'u' : 'g');\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tfprintf(stderr, \"%s: path name too long\\n\", __func__);\n\t\treturn -E2BIG;\n\t}\n\tf = fopen(path, \"w\");\n\tif (!f) {\n\t\tperror(\"open\");\n\t\treturn -EINVAL;\n\t}\n\tret = fwrite(buf, buf_size, 1, f);\n\tif (ret < 0)\n\t\tSYSERROR(\"writing id mapping\");\n\tcloseret = fclose(f);\n\tif (closeret)\n\t\tSYSERROR(\"writing id mapping\");\n\treturn ret < 0 ? ret : closeret;\n}"
  },
  {
    "function_name": "lxc_assign_network",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "3159-3202",
    "snippet": "int lxc_assign_network(const char *lxcpath, char *lxcname,\n\t\t       struct lxc_list *network, pid_t pid)\n{\n\tstruct lxc_list *iterator;\n\tstruct lxc_netdev *netdev;\n\tchar ifname[IFNAMSIZ];\n\tint am_root = (getuid() == 0);\n\tint err;\n\n\tlxc_list_for_each(iterator, network) {\n\n\t\tnetdev = iterator->elem;\n\n\t\tif (netdev->type == LXC_NET_VETH && !am_root) {\n\t\t\tif (unpriv_assign_nic(lxcpath, lxcname, netdev, pid))\n\t\t\t\treturn -1;\n\t\t\t// lxc-user-nic has moved the nic to the new ns.\n\t\t\t// unpriv_assign_nic() fills in netdev->name.\n\t\t\t// netdev->ifindex will be filed in at setup_netdev.\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* empty network namespace, nothing to move */\n\t\tif (!netdev->ifindex)\n\t\t\tcontinue;\n\n\t\t/* retrieve the name of the interface */\n\t\tif (!if_indextoname(netdev->ifindex, ifname)) {\n\t\t\tERROR(\"no interface corresponding to index '%d'\", netdev->ifindex);\n\t\t\treturn -1;\n\t\t}\n\n\t\terr = lxc_netdev_move_by_name(ifname, pid, NULL);\n\t\tif (err) {\n\t\t\tERROR(\"failed to move '%s' to the container : %s\",\n\t\t\t      netdev->link, strerror(-err));\n\t\t\treturn -1;\n\t\t}\n\n\t\tDEBUG(\"move '%s'/'%s' to '%d': .\", ifname, netdev->name, pid);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_none(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_none(struct lxc_handler *, struct lxc_netdev *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"move '%s'/'%s' to '%d': .\"",
            "ifname",
            "netdev->name",
            "pid"
          ],
          "line": 3198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to move '%s' to the container : %s\"",
            "netdev->link",
            "strerror(-err)"
          ],
          "line": 3193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "-err"
          ],
          "line": 3194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_netdev_move_by_name",
          "args": [
            "ifname",
            "pid",
            "NULL"
          ],
          "line": 3191
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_netdev_move_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "240-256",
          "snippet": "int lxc_netdev_move_by_name(const char *ifname, pid_t pid, const char* newname)\n{\n\tint index;\n\tchar *physname;\n\n\tif (!ifname)\n\t\treturn -EINVAL;\n\n\tindex = if_nametoindex(ifname);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\tif ((physname = is_wlan(ifname)))\n\t\treturn lxc_netdev_move_wlan(physname, ifname, pid, newname);\n\n\treturn lxc_netdev_move_by_index(index, pid, newname);\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_netdev_move_by_name(const char *ifname, pid_t pid, const char* newname)\n{\n\tint index;\n\tchar *physname;\n\n\tif (!ifname)\n\t\treturn -EINVAL;\n\n\tindex = if_nametoindex(ifname);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\tif ((physname = is_wlan(ifname)))\n\t\treturn lxc_netdev_move_wlan(physname, ifname, pid, newname);\n\n\treturn lxc_netdev_move_by_index(index, pid, newname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"no interface corresponding to index '%d'\"",
            "netdev->ifindex"
          ],
          "line": 3187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_indextoname",
          "args": [
            "netdev->ifindex",
            "ifname"
          ],
          "line": 3186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpriv_assign_nic",
          "args": [
            "lxcpath",
            "lxcname",
            "netdev",
            "pid"
          ],
          "line": 3173
        },
        "resolved": true,
        "details": {
          "function_name": "unpriv_assign_nic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3054-3157",
          "snippet": "static int unpriv_assign_nic(const char *lxcpath, char *lxcname,\n\t\t\t     struct lxc_netdev *netdev, pid_t pid)\n{\n\tpid_t child;\n\tint bytes, pipefd[2];\n\tchar *token, *saveptr = NULL;\n\tchar buffer[MAX_BUFFER_SIZE];\n\tchar netdev_link[IFNAMSIZ + 1];\n\n\tif (netdev->type != LXC_NET_VETH) {\n\t\tERROR(\"nic type %d not support for unprivileged use\",\n\t\t      netdev->type);\n\t\treturn -1;\n\t}\n\n\tif (pipe(pipefd) < 0) {\n\t\tSYSERROR(\"pipe failed\");\n\t\treturn -1;\n\t}\n\n\tchild = fork();\n\tif (child < 0) {\n\t\tSYSERROR(\"fork\");\n\t\tclose(pipefd[0]);\n\t\tclose(pipefd[1]);\n\t\treturn -1;\n\t}\n\n\tif (child == 0) { // child\n\t\t/* Call lxc-user-nic pid type bridge. */\n\t\tint ret;\n\t\tchar pidstr[LXC_NUMSTRLEN64];\n\n\t\tclose(pipefd[0]); /* Close the read-end of the pipe. */\n\n\t\t/* Redirect stdout to write-end of the pipe. */\n\t\tret = dup2(pipefd[1], STDOUT_FILENO);\n\t\tclose(pipefd[1]); /* Close the write-end of the pipe. */\n\t\tif (ret < 0) {\n\t\t\tSYSERROR(\"Failed to dup2() to redirect stdout to pipe file descriptor.\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tif (netdev->link)\n\t\t\tstrncpy(netdev_link, netdev->link, IFNAMSIZ);\n\t\telse\n\t\t\tstrncpy(netdev_link, \"none\", IFNAMSIZ);\n\n\t\tret = snprintf(pidstr, LXC_NUMSTRLEN64, \"%d\", pid);\n\t\tif (ret < 0 || ret >= LXC_NUMSTRLEN64)\n\t\t\texit(EXIT_FAILURE);\n\t\tpidstr[LXC_NUMSTRLEN64 - 1] = '\\0';\n\n\t\tINFO(\"Execing lxc-user-nic %s %s %s veth %s %s\", lxcpath,\n\t\t     lxcname, pidstr, netdev_link, netdev->name);\n\t\texeclp(LXC_USERNIC_PATH, LXC_USERNIC_PATH, lxcpath, lxcname,\n\t\t       pidstr, \"veth\", netdev_link, netdev->name, NULL);\n\n\t\tSYSERROR(\"Failed to exec lxc-user-nic.\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t/* close the write-end of the pipe */\n\tclose(pipefd[1]);\n\n\tbytes = read(pipefd[0], &buffer, MAX_BUFFER_SIZE);\n\tif (bytes < 0)\n\t\tSYSERROR(\"Failed to read from pipe file descriptor.\");\n\tbuffer[bytes - 1] = '\\0';\n\n\tif (wait_for_pid(child) != 0) {\n\t\tclose(pipefd[0]);\n\t\treturn -1;\n\t}\n\n\t/* close the read-end of the pipe */\n\tclose(pipefd[0]);\n\n\t/* fill netdev->name field */\n\ttoken = strtok_r(buffer, \":\", &saveptr);\n\tif (!token)\n\t\treturn -1;\n\n\tnetdev->name = malloc(IFNAMSIZ + 1);\n\tif (!netdev->name) {\n\t\tSYSERROR(\"Failed to allocate memory.\");\n\t\treturn -1;\n\t}\n\tmemset(netdev->name, 0, IFNAMSIZ + 1);\n\tstrncpy(netdev->name, token, IFNAMSIZ);\n\n\t/* fill netdev->veth_attr.pair field */\n\ttoken = strtok_r(NULL, \":\", &saveptr);\n\tif (!token)\n\t\treturn -1;\n\n\tnetdev->priv.veth_attr.pair = strdup(token);\n\tif (!netdev->priv.veth_attr.pair) {\n\t\tERROR(\"Failed to allocate memory.\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MAX_BUFFER_SIZE IFNAMSIZ * 2 + 2",
            "#define LXC_USERNIC_PATH LIBEXECDIR \"/lxc/lxc-user-nic\""
          ],
          "globals_used": [
            "static int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_none(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_none(struct lxc_handler *, struct lxc_netdev *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\n#define MAX_BUFFER_SIZE IFNAMSIZ * 2 + 2\n#define LXC_USERNIC_PATH LIBEXECDIR \"/lxc/lxc-user-nic\"\n\nstatic int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_none(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_none(struct lxc_handler *, struct lxc_netdev *);\n\nstatic int unpriv_assign_nic(const char *lxcpath, char *lxcname,\n\t\t\t     struct lxc_netdev *netdev, pid_t pid)\n{\n\tpid_t child;\n\tint bytes, pipefd[2];\n\tchar *token, *saveptr = NULL;\n\tchar buffer[MAX_BUFFER_SIZE];\n\tchar netdev_link[IFNAMSIZ + 1];\n\n\tif (netdev->type != LXC_NET_VETH) {\n\t\tERROR(\"nic type %d not support for unprivileged use\",\n\t\t      netdev->type);\n\t\treturn -1;\n\t}\n\n\tif (pipe(pipefd) < 0) {\n\t\tSYSERROR(\"pipe failed\");\n\t\treturn -1;\n\t}\n\n\tchild = fork();\n\tif (child < 0) {\n\t\tSYSERROR(\"fork\");\n\t\tclose(pipefd[0]);\n\t\tclose(pipefd[1]);\n\t\treturn -1;\n\t}\n\n\tif (child == 0) { // child\n\t\t/* Call lxc-user-nic pid type bridge. */\n\t\tint ret;\n\t\tchar pidstr[LXC_NUMSTRLEN64];\n\n\t\tclose(pipefd[0]); /* Close the read-end of the pipe. */\n\n\t\t/* Redirect stdout to write-end of the pipe. */\n\t\tret = dup2(pipefd[1], STDOUT_FILENO);\n\t\tclose(pipefd[1]); /* Close the write-end of the pipe. */\n\t\tif (ret < 0) {\n\t\t\tSYSERROR(\"Failed to dup2() to redirect stdout to pipe file descriptor.\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tif (netdev->link)\n\t\t\tstrncpy(netdev_link, netdev->link, IFNAMSIZ);\n\t\telse\n\t\t\tstrncpy(netdev_link, \"none\", IFNAMSIZ);\n\n\t\tret = snprintf(pidstr, LXC_NUMSTRLEN64, \"%d\", pid);\n\t\tif (ret < 0 || ret >= LXC_NUMSTRLEN64)\n\t\t\texit(EXIT_FAILURE);\n\t\tpidstr[LXC_NUMSTRLEN64 - 1] = '\\0';\n\n\t\tINFO(\"Execing lxc-user-nic %s %s %s veth %s %s\", lxcpath,\n\t\t     lxcname, pidstr, netdev_link, netdev->name);\n\t\texeclp(LXC_USERNIC_PATH, LXC_USERNIC_PATH, lxcpath, lxcname,\n\t\t       pidstr, \"veth\", netdev_link, netdev->name, NULL);\n\n\t\tSYSERROR(\"Failed to exec lxc-user-nic.\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t/* close the write-end of the pipe */\n\tclose(pipefd[1]);\n\n\tbytes = read(pipefd[0], &buffer, MAX_BUFFER_SIZE);\n\tif (bytes < 0)\n\t\tSYSERROR(\"Failed to read from pipe file descriptor.\");\n\tbuffer[bytes - 1] = '\\0';\n\n\tif (wait_for_pid(child) != 0) {\n\t\tclose(pipefd[0]);\n\t\treturn -1;\n\t}\n\n\t/* close the read-end of the pipe */\n\tclose(pipefd[0]);\n\n\t/* fill netdev->name field */\n\ttoken = strtok_r(buffer, \":\", &saveptr);\n\tif (!token)\n\t\treturn -1;\n\n\tnetdev->name = malloc(IFNAMSIZ + 1);\n\tif (!netdev->name) {\n\t\tSYSERROR(\"Failed to allocate memory.\");\n\t\treturn -1;\n\t}\n\tmemset(netdev->name, 0, IFNAMSIZ + 1);\n\tstrncpy(netdev->name, token, IFNAMSIZ);\n\n\t/* fill netdev->veth_attr.pair field */\n\ttoken = strtok_r(NULL, \":\", &saveptr);\n\tif (!token)\n\t\treturn -1;\n\n\tnetdev->priv.veth_attr.pair = strdup(token);\n\tif (!netdev->priv.veth_attr.pair) {\n\t\tERROR(\"Failed to allocate memory.\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "iterator",
            "network"
          ],
          "line": 3168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 3165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_none(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_none(struct lxc_handler *, struct lxc_netdev *);\n\nint lxc_assign_network(const char *lxcpath, char *lxcname,\n\t\t       struct lxc_list *network, pid_t pid)\n{\n\tstruct lxc_list *iterator;\n\tstruct lxc_netdev *netdev;\n\tchar ifname[IFNAMSIZ];\n\tint am_root = (getuid() == 0);\n\tint err;\n\n\tlxc_list_for_each(iterator, network) {\n\n\t\tnetdev = iterator->elem;\n\n\t\tif (netdev->type == LXC_NET_VETH && !am_root) {\n\t\t\tif (unpriv_assign_nic(lxcpath, lxcname, netdev, pid))\n\t\t\t\treturn -1;\n\t\t\t// lxc-user-nic has moved the nic to the new ns.\n\t\t\t// unpriv_assign_nic() fills in netdev->name.\n\t\t\t// netdev->ifindex will be filed in at setup_netdev.\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* empty network namespace, nothing to move */\n\t\tif (!netdev->ifindex)\n\t\t\tcontinue;\n\n\t\t/* retrieve the name of the interface */\n\t\tif (!if_indextoname(netdev->ifindex, ifname)) {\n\t\t\tERROR(\"no interface corresponding to index '%d'\", netdev->ifindex);\n\t\t\treturn -1;\n\t\t}\n\n\t\terr = lxc_netdev_move_by_name(ifname, pid, NULL);\n\t\tif (err) {\n\t\t\tERROR(\"failed to move '%s' to the container : %s\",\n\t\t\t      netdev->link, strerror(-err));\n\t\t\treturn -1;\n\t\t}\n\n\t\tDEBUG(\"move '%s'/'%s' to '%d': .\", ifname, netdev->name, pid);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "unpriv_assign_nic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "3054-3157",
    "snippet": "static int unpriv_assign_nic(const char *lxcpath, char *lxcname,\n\t\t\t     struct lxc_netdev *netdev, pid_t pid)\n{\n\tpid_t child;\n\tint bytes, pipefd[2];\n\tchar *token, *saveptr = NULL;\n\tchar buffer[MAX_BUFFER_SIZE];\n\tchar netdev_link[IFNAMSIZ + 1];\n\n\tif (netdev->type != LXC_NET_VETH) {\n\t\tERROR(\"nic type %d not support for unprivileged use\",\n\t\t      netdev->type);\n\t\treturn -1;\n\t}\n\n\tif (pipe(pipefd) < 0) {\n\t\tSYSERROR(\"pipe failed\");\n\t\treturn -1;\n\t}\n\n\tchild = fork();\n\tif (child < 0) {\n\t\tSYSERROR(\"fork\");\n\t\tclose(pipefd[0]);\n\t\tclose(pipefd[1]);\n\t\treturn -1;\n\t}\n\n\tif (child == 0) { // child\n\t\t/* Call lxc-user-nic pid type bridge. */\n\t\tint ret;\n\t\tchar pidstr[LXC_NUMSTRLEN64];\n\n\t\tclose(pipefd[0]); /* Close the read-end of the pipe. */\n\n\t\t/* Redirect stdout to write-end of the pipe. */\n\t\tret = dup2(pipefd[1], STDOUT_FILENO);\n\t\tclose(pipefd[1]); /* Close the write-end of the pipe. */\n\t\tif (ret < 0) {\n\t\t\tSYSERROR(\"Failed to dup2() to redirect stdout to pipe file descriptor.\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tif (netdev->link)\n\t\t\tstrncpy(netdev_link, netdev->link, IFNAMSIZ);\n\t\telse\n\t\t\tstrncpy(netdev_link, \"none\", IFNAMSIZ);\n\n\t\tret = snprintf(pidstr, LXC_NUMSTRLEN64, \"%d\", pid);\n\t\tif (ret < 0 || ret >= LXC_NUMSTRLEN64)\n\t\t\texit(EXIT_FAILURE);\n\t\tpidstr[LXC_NUMSTRLEN64 - 1] = '\\0';\n\n\t\tINFO(\"Execing lxc-user-nic %s %s %s veth %s %s\", lxcpath,\n\t\t     lxcname, pidstr, netdev_link, netdev->name);\n\t\texeclp(LXC_USERNIC_PATH, LXC_USERNIC_PATH, lxcpath, lxcname,\n\t\t       pidstr, \"veth\", netdev_link, netdev->name, NULL);\n\n\t\tSYSERROR(\"Failed to exec lxc-user-nic.\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t/* close the write-end of the pipe */\n\tclose(pipefd[1]);\n\n\tbytes = read(pipefd[0], &buffer, MAX_BUFFER_SIZE);\n\tif (bytes < 0)\n\t\tSYSERROR(\"Failed to read from pipe file descriptor.\");\n\tbuffer[bytes - 1] = '\\0';\n\n\tif (wait_for_pid(child) != 0) {\n\t\tclose(pipefd[0]);\n\t\treturn -1;\n\t}\n\n\t/* close the read-end of the pipe */\n\tclose(pipefd[0]);\n\n\t/* fill netdev->name field */\n\ttoken = strtok_r(buffer, \":\", &saveptr);\n\tif (!token)\n\t\treturn -1;\n\n\tnetdev->name = malloc(IFNAMSIZ + 1);\n\tif (!netdev->name) {\n\t\tSYSERROR(\"Failed to allocate memory.\");\n\t\treturn -1;\n\t}\n\tmemset(netdev->name, 0, IFNAMSIZ + 1);\n\tstrncpy(netdev->name, token, IFNAMSIZ);\n\n\t/* fill netdev->veth_attr.pair field */\n\ttoken = strtok_r(NULL, \":\", &saveptr);\n\tif (!token)\n\t\treturn -1;\n\n\tnetdev->priv.veth_attr.pair = strdup(token);\n\tif (!netdev->priv.veth_attr.pair) {\n\t\tERROR(\"Failed to allocate memory.\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define MAX_BUFFER_SIZE IFNAMSIZ * 2 + 2",
      "#define LXC_USERNIC_PATH LIBEXECDIR \"/lxc/lxc-user-nic\""
    ],
    "globals_used": [
      "static int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_none(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_none(struct lxc_handler *, struct lxc_netdev *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to allocate memory.\""
          ],
          "line": 3152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "token"
          ],
          "line": 3150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "NULL",
            "\":\"",
            "&saveptr"
          ],
          "line": 3146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "netdev->name",
            "token",
            "IFNAMSIZ"
          ],
          "line": 3143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "netdev->name",
            "0",
            "IFNAMSIZ + 1"
          ],
          "line": 3142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to allocate memory.\""
          ],
          "line": 3139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "IFNAMSIZ + 1"
          ],
          "line": 3137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "buffer",
            "\":\"",
            "&saveptr"
          ],
          "line": 3133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "pipefd[0]"
          ],
          "line": 3130
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_pid",
          "args": [
            "child"
          ],
          "line": 3124
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "311-325",
          "snippet": "int lxc_wait_for_pid_status(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\treturn status;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_wait_for_pid_status(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to read from pipe file descriptor.\""
          ],
          "line": 3121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "pipefd[0]",
            "&buffer",
            "MAX_BUFFER_SIZE"
          ],
          "line": 3119
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "962-990",
          "snippet": "int lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 3113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to exec lxc-user-nic.\""
          ],
          "line": 3112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "LXC_USERNIC_PATH",
            "LXC_USERNIC_PATH",
            "lxcpath",
            "lxcname",
            "pidstr",
            "\"veth\"",
            "netdev_link",
            "netdev->name",
            "NULL"
          ],
          "line": 3109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Execing lxc-user-nic %s %s %s veth %s %s\"",
            "lxcpath",
            "lxcname",
            "pidstr",
            "netdev_link",
            "netdev->name"
          ],
          "line": 3107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 3104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "pidstr",
            "LXC_NUMSTRLEN64",
            "\"%d\"",
            "pid"
          ],
          "line": 3102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "netdev_link",
            "\"none\"",
            "IFNAMSIZ"
          ],
          "line": 3100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "netdev_link",
            "netdev->link",
            "IFNAMSIZ"
          ],
          "line": 3098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 3094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to dup2() to redirect stdout to pipe file descriptor.\""
          ],
          "line": 3093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "pipefd[1]",
            "STDOUT_FILENO"
          ],
          "line": 3090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"fork\""
          ],
          "line": 3076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 3074
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"pipe failed\""
          ],
          "line": 3070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "pipefd"
          ],
          "line": 3069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"nic type %d not support for unprivileged use\"",
            "netdev->type"
          ],
          "line": 3064
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\n#define MAX_BUFFER_SIZE IFNAMSIZ * 2 + 2\n#define LXC_USERNIC_PATH LIBEXECDIR \"/lxc/lxc-user-nic\"\n\nstatic int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_none(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_none(struct lxc_handler *, struct lxc_netdev *);\n\nstatic int unpriv_assign_nic(const char *lxcpath, char *lxcname,\n\t\t\t     struct lxc_netdev *netdev, pid_t pid)\n{\n\tpid_t child;\n\tint bytes, pipefd[2];\n\tchar *token, *saveptr = NULL;\n\tchar buffer[MAX_BUFFER_SIZE];\n\tchar netdev_link[IFNAMSIZ + 1];\n\n\tif (netdev->type != LXC_NET_VETH) {\n\t\tERROR(\"nic type %d not support for unprivileged use\",\n\t\t      netdev->type);\n\t\treturn -1;\n\t}\n\n\tif (pipe(pipefd) < 0) {\n\t\tSYSERROR(\"pipe failed\");\n\t\treturn -1;\n\t}\n\n\tchild = fork();\n\tif (child < 0) {\n\t\tSYSERROR(\"fork\");\n\t\tclose(pipefd[0]);\n\t\tclose(pipefd[1]);\n\t\treturn -1;\n\t}\n\n\tif (child == 0) { // child\n\t\t/* Call lxc-user-nic pid type bridge. */\n\t\tint ret;\n\t\tchar pidstr[LXC_NUMSTRLEN64];\n\n\t\tclose(pipefd[0]); /* Close the read-end of the pipe. */\n\n\t\t/* Redirect stdout to write-end of the pipe. */\n\t\tret = dup2(pipefd[1], STDOUT_FILENO);\n\t\tclose(pipefd[1]); /* Close the write-end of the pipe. */\n\t\tif (ret < 0) {\n\t\t\tSYSERROR(\"Failed to dup2() to redirect stdout to pipe file descriptor.\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tif (netdev->link)\n\t\t\tstrncpy(netdev_link, netdev->link, IFNAMSIZ);\n\t\telse\n\t\t\tstrncpy(netdev_link, \"none\", IFNAMSIZ);\n\n\t\tret = snprintf(pidstr, LXC_NUMSTRLEN64, \"%d\", pid);\n\t\tif (ret < 0 || ret >= LXC_NUMSTRLEN64)\n\t\t\texit(EXIT_FAILURE);\n\t\tpidstr[LXC_NUMSTRLEN64 - 1] = '\\0';\n\n\t\tINFO(\"Execing lxc-user-nic %s %s %s veth %s %s\", lxcpath,\n\t\t     lxcname, pidstr, netdev_link, netdev->name);\n\t\texeclp(LXC_USERNIC_PATH, LXC_USERNIC_PATH, lxcpath, lxcname,\n\t\t       pidstr, \"veth\", netdev_link, netdev->name, NULL);\n\n\t\tSYSERROR(\"Failed to exec lxc-user-nic.\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t/* close the write-end of the pipe */\n\tclose(pipefd[1]);\n\n\tbytes = read(pipefd[0], &buffer, MAX_BUFFER_SIZE);\n\tif (bytes < 0)\n\t\tSYSERROR(\"Failed to read from pipe file descriptor.\");\n\tbuffer[bytes - 1] = '\\0';\n\n\tif (wait_for_pid(child) != 0) {\n\t\tclose(pipefd[0]);\n\t\treturn -1;\n\t}\n\n\t/* close the read-end of the pipe */\n\tclose(pipefd[0]);\n\n\t/* fill netdev->name field */\n\ttoken = strtok_r(buffer, \":\", &saveptr);\n\tif (!token)\n\t\treturn -1;\n\n\tnetdev->name = malloc(IFNAMSIZ + 1);\n\tif (!netdev->name) {\n\t\tSYSERROR(\"Failed to allocate memory.\");\n\t\treturn -1;\n\t}\n\tmemset(netdev->name, 0, IFNAMSIZ + 1);\n\tstrncpy(netdev->name, token, IFNAMSIZ);\n\n\t/* fill netdev->veth_attr.pair field */\n\ttoken = strtok_r(NULL, \":\", &saveptr);\n\tif (!token)\n\t\treturn -1;\n\n\tnetdev->priv.veth_attr.pair = strdup(token);\n\tif (!netdev->priv.veth_attr.pair) {\n\t\tERROR(\"Failed to allocate memory.\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_delete_network",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "2971-3048",
    "snippet": "bool lxc_delete_network(struct lxc_handler *handler)\n{\n\tint ret;\n\tstruct lxc_list *network = &handler->conf->network;\n\tstruct lxc_list *iterator;\n\tstruct lxc_netdev *netdev;\n\tbool deleted_all = true;\n\n\tlxc_list_for_each(iterator, network) {\n\t\tnetdev = iterator->elem;\n\n\t\tif (netdev->ifindex != 0 && netdev->type == LXC_NET_PHYS) {\n\t\t\tif (lxc_netdev_rename_by_index(netdev->ifindex, netdev->link))\n\t\t\t\tWARN(\"Failed to rename interface with index %d \"\n\t\t\t\t     \"to its initial name \\\"%s\\\".\",\n\t\t\t\t     netdev->ifindex, netdev->link);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (netdev_deconf[netdev->type](handler, netdev)) {\n\t\t\tWARN(\"Failed to destroy netdev\");\n\t\t}\n\n\t\t/* Recent kernel remove the virtual interfaces when the network\n\t\t * namespace is destroyed but in case we did not moved the\n\t\t * interface to the network namespace, we have to destroy it\n\t\t */\n\t\tif (netdev->ifindex != 0) {\n\t\t\tret = lxc_netdev_delete_by_index(netdev->ifindex);\n\t\t\tif (-ret == ENODEV) {\n\t\t\t\tINFO(\"Interface \\\"%s\\\" with index %d already \"\n\t\t\t\t     \"deleted or existing in different network \"\n\t\t\t\t     \"namespace.\",\n\t\t\t\t     netdev->name ? netdev->name : \"(null)\",\n\t\t\t\t     netdev->ifindex);\n\t\t\t} else if (ret < 0) {\n\t\t\t\tdeleted_all = false;\n\t\t\t\tWARN(\"Failed to remove interface \\\"%s\\\" with \"\n\t\t\t\t     \"index %d: %s.\",\n\t\t\t\t     netdev->name ? netdev->name : \"(null)\",\n\t\t\t\t     netdev->ifindex, strerror(-ret));\n\t\t\t} else {\n\t\t\t\tINFO(\"Removed interface \\\"%s\\\" with index %d.\",\n\t\t\t\t     netdev->name ? netdev->name : \"(null)\",\n\t\t\t\t     netdev->ifindex);\n\t\t\t}\n\t\t}\n\n\t\t/* Explicitly delete host veth device to prevent lingering\n\t\t * devices. We had issues in LXD around this.\n\t\t */\n\t\tif (netdev->type == LXC_NET_VETH) {\n\t\t\tchar *hostveth;\n\t\t\tif (netdev->priv.veth_attr.pair) {\n\t\t\t\thostveth = netdev->priv.veth_attr.pair;\n\t\t\t\tret = lxc_netdev_delete_by_name(hostveth);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tWARN(\"Failed to remove interface \\\"%s\\\" from host: %s.\", hostveth, strerror(-ret));\n\t\t\t\t} else {\n\t\t\t\t\tINFO(\"Removed interface \\\"%s\\\" from host.\", hostveth);\n\t\t\t\t\tfree(netdev->priv.veth_attr.pair);\n\t\t\t\t\tnetdev->priv.veth_attr.pair = NULL;\n\t\t\t\t}\n\t\t\t} else if (strlen(netdev->priv.veth_attr.veth1) > 0) {\n\t\t\t\thostveth = netdev->priv.veth_attr.veth1;\n\t\t\t\tret = lxc_netdev_delete_by_name(hostveth);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tWARN(\"Failed to remove \\\"%s\\\" from host: %s.\", hostveth, strerror(-ret));\n\t\t\t\t} else {\n\t\t\t\t\tINFO(\"Removed interface \\\"%s\\\" from host.\", hostveth);\n\t\t\t\t\tmemset((void *)&netdev->priv.veth_attr.veth1, 0, sizeof(netdev->priv.veth_attr.veth1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn deleted_all;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_none(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_none(struct lxc_handler *, struct lxc_netdev *);",
      "static  instantiate_cb netdev_deconf[LXC_NET_MAXCONFTYPE + 1] = {\n\t[LXC_NET_VETH]    = shutdown_veth,\n\t[LXC_NET_MACVLAN] = shutdown_macvlan,\n\t[LXC_NET_VLAN]    = shutdown_vlan,\n\t[LXC_NET_PHYS]    = shutdown_phys,\n\t[LXC_NET_EMPTY]   = shutdown_empty,\n\t[LXC_NET_NONE]    = shutdown_none,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(void *)&netdev->priv.veth_attr.veth1",
            "0",
            "sizeof(netdev->priv.veth_attr.veth1)"
          ],
          "line": 3041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Removed interface \\\"%s\\\" from host.\"",
            "hostveth"
          ],
          "line": 3040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to remove \\\"%s\\\" from host: %s.\"",
            "hostveth",
            "strerror(-ret)"
          ],
          "line": 3038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "-ret"
          ],
          "line": 3038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_netdev_delete_by_name",
          "args": [
            "hostveth"
          ],
          "line": 3036
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_netdev_delete_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "295-304",
          "snippet": "int lxc_netdev_delete_by_name(const char *name)\n{\n\tint index;\n\n\tindex = if_nametoindex(name);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\treturn lxc_netdev_delete_by_index(index);\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_netdev_delete_by_name(const char *name)\n{\n\tint index;\n\n\tindex = if_nametoindex(name);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\treturn lxc_netdev_delete_by_index(index);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "netdev->priv.veth_attr.veth1"
          ],
          "line": 3034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "netdev->priv.veth_attr.pair"
          ],
          "line": 3031
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4619-4628",
          "snippet": "static void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Removed interface \\\"%s\\\" from host.\"",
            "hostveth"
          ],
          "line": 3030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to remove interface \\\"%s\\\" from host: %s.\"",
            "hostveth",
            "strerror(-ret)"
          ],
          "line": 3028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "-ret"
          ],
          "line": 3028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Removed interface \\\"%s\\\" with index %d.\"",
            "netdev->name ? netdev->name : \"(null)\"",
            "netdev->ifindex"
          ],
          "line": 3013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to remove interface \\\"%s\\\" with \"\n\t\t\t\t     \"index %d: %s.\"",
            "netdev->name ? netdev->name : \"(null)\"",
            "netdev->ifindex",
            "strerror(-ret)"
          ],
          "line": 3008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "-ret"
          ],
          "line": 3011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Interface \\\"%s\\\" with index %d already \"\n\t\t\t\t     \"deleted or existing in different network \"\n\t\t\t\t     \"namespace.\"",
            "netdev->name ? netdev->name : \"(null)\"",
            "netdev->ifindex"
          ],
          "line": 3001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_netdev_delete_by_index",
          "args": [
            "netdev->ifindex"
          ],
          "line": 2999
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_netdev_delete_by_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "258-293",
          "snippet": "int lxc_netdev_delete_by_index(int ifindex)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tint err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_ACK|NLM_F_REQUEST;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_DELLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi)\n\t\tgoto out;\n\tifi->ifi_family = AF_UNSPEC;\n\tifi->ifi_index = ifindex;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_netdev_delete_by_index(int ifindex)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tint err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_ACK|NLM_F_REQUEST;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_DELLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi)\n\t\tgoto out;\n\tifi->ifi_family = AF_UNSPEC;\n\tifi->ifi_index = ifindex;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to destroy netdev\""
          ],
          "line": 2991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netdev_deconf[netdev->type]",
          "args": [
            "handler",
            "netdev"
          ],
          "line": 2990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to rename interface with index %d \"\n\t\t\t\t     \"to its initial name \\\"%s\\\".\"",
            "netdev->ifindex",
            "netdev->link"
          ],
          "line": 2984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_netdev_rename_by_index",
          "args": [
            "netdev->ifindex",
            "netdev->link"
          ],
          "line": 2983
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_netdev_rename_by_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "306-348",
          "snippet": "int lxc_netdev_rename_by_index(int ifindex, const char *newname)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tint len, err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\tlen = strlen(newname);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_ACK|NLM_F_REQUEST;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi)\n\t\tgoto out;\n\tifi->ifi_family = AF_UNSPEC;\n\tifi->ifi_index = ifindex;\n\n\tif (nla_put_string(nlmsg, IFLA_IFNAME, newname))\n\t\tgoto out;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_netdev_rename_by_index(int ifindex, const char *newname)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tint len, err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\tlen = strlen(newname);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_ACK|NLM_F_REQUEST;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi)\n\t\tgoto out;\n\tifi->ifi_family = AF_UNSPEC;\n\tifi->ifi_index = ifindex;\n\n\tif (nla_put_string(nlmsg, IFLA_IFNAME, newname))\n\t\tgoto out;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "iterator",
            "network"
          ],
          "line": 2979
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_none(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_none(struct lxc_handler *, struct lxc_netdev *);\nstatic  instantiate_cb netdev_deconf[LXC_NET_MAXCONFTYPE + 1] = {\n\t[LXC_NET_VETH]    = shutdown_veth,\n\t[LXC_NET_MACVLAN] = shutdown_macvlan,\n\t[LXC_NET_VLAN]    = shutdown_vlan,\n\t[LXC_NET_PHYS]    = shutdown_phys,\n\t[LXC_NET_EMPTY]   = shutdown_empty,\n\t[LXC_NET_NONE]    = shutdown_none,\n};\n\nbool lxc_delete_network(struct lxc_handler *handler)\n{\n\tint ret;\n\tstruct lxc_list *network = &handler->conf->network;\n\tstruct lxc_list *iterator;\n\tstruct lxc_netdev *netdev;\n\tbool deleted_all = true;\n\n\tlxc_list_for_each(iterator, network) {\n\t\tnetdev = iterator->elem;\n\n\t\tif (netdev->ifindex != 0 && netdev->type == LXC_NET_PHYS) {\n\t\t\tif (lxc_netdev_rename_by_index(netdev->ifindex, netdev->link))\n\t\t\t\tWARN(\"Failed to rename interface with index %d \"\n\t\t\t\t     \"to its initial name \\\"%s\\\".\",\n\t\t\t\t     netdev->ifindex, netdev->link);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (netdev_deconf[netdev->type](handler, netdev)) {\n\t\t\tWARN(\"Failed to destroy netdev\");\n\t\t}\n\n\t\t/* Recent kernel remove the virtual interfaces when the network\n\t\t * namespace is destroyed but in case we did not moved the\n\t\t * interface to the network namespace, we have to destroy it\n\t\t */\n\t\tif (netdev->ifindex != 0) {\n\t\t\tret = lxc_netdev_delete_by_index(netdev->ifindex);\n\t\t\tif (-ret == ENODEV) {\n\t\t\t\tINFO(\"Interface \\\"%s\\\" with index %d already \"\n\t\t\t\t     \"deleted or existing in different network \"\n\t\t\t\t     \"namespace.\",\n\t\t\t\t     netdev->name ? netdev->name : \"(null)\",\n\t\t\t\t     netdev->ifindex);\n\t\t\t} else if (ret < 0) {\n\t\t\t\tdeleted_all = false;\n\t\t\t\tWARN(\"Failed to remove interface \\\"%s\\\" with \"\n\t\t\t\t     \"index %d: %s.\",\n\t\t\t\t     netdev->name ? netdev->name : \"(null)\",\n\t\t\t\t     netdev->ifindex, strerror(-ret));\n\t\t\t} else {\n\t\t\t\tINFO(\"Removed interface \\\"%s\\\" with index %d.\",\n\t\t\t\t     netdev->name ? netdev->name : \"(null)\",\n\t\t\t\t     netdev->ifindex);\n\t\t\t}\n\t\t}\n\n\t\t/* Explicitly delete host veth device to prevent lingering\n\t\t * devices. We had issues in LXD around this.\n\t\t */\n\t\tif (netdev->type == LXC_NET_VETH) {\n\t\t\tchar *hostveth;\n\t\t\tif (netdev->priv.veth_attr.pair) {\n\t\t\t\thostveth = netdev->priv.veth_attr.pair;\n\t\t\t\tret = lxc_netdev_delete_by_name(hostveth);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tWARN(\"Failed to remove interface \\\"%s\\\" from host: %s.\", hostveth, strerror(-ret));\n\t\t\t\t} else {\n\t\t\t\t\tINFO(\"Removed interface \\\"%s\\\" from host.\", hostveth);\n\t\t\t\t\tfree(netdev->priv.veth_attr.pair);\n\t\t\t\t\tnetdev->priv.veth_attr.pair = NULL;\n\t\t\t\t}\n\t\t\t} else if (strlen(netdev->priv.veth_attr.veth1) > 0) {\n\t\t\t\thostveth = netdev->priv.veth_attr.veth1;\n\t\t\t\tret = lxc_netdev_delete_by_name(hostveth);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tWARN(\"Failed to remove \\\"%s\\\" from host: %s.\", hostveth, strerror(-ret));\n\t\t\t\t} else {\n\t\t\t\t\tINFO(\"Removed interface \\\"%s\\\" from host.\", hostveth);\n\t\t\t\t\tmemset((void *)&netdev->priv.veth_attr.veth1, 0, sizeof(netdev->priv.veth_attr.veth1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn deleted_all;\n}"
  },
  {
    "function_name": "lxc_create_network",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "2941-2969",
    "snippet": "int lxc_create_network(struct lxc_handler *handler)\n{\n\tstruct lxc_list *network = &handler->conf->network;\n\tstruct lxc_list *iterator;\n\tstruct lxc_netdev *netdev;\n\tint am_root = (getuid() == 0);\n\n\tif (!am_root)\n\t\treturn 0;\n\n\tlxc_list_for_each(iterator, network) {\n\n\t\tnetdev = iterator->elem;\n\n\t\tif (netdev->type < 0 || netdev->type > LXC_NET_MAXCONFTYPE) {\n\t\t\tERROR(\"invalid network configuration type '%d'\",\n\t\t\t      netdev->type);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (netdev_conf[netdev->type](handler, netdev)) {\n\t\t\tERROR(\"failed to create netdev\");\n\t\t\treturn -1;\n\t\t}\n\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_none(struct lxc_handler *, struct lxc_netdev *);",
      "static  instantiate_cb netdev_conf[LXC_NET_MAXCONFTYPE + 1] = {\n\t[LXC_NET_VETH]    = instantiate_veth,\n\t[LXC_NET_MACVLAN] = instantiate_macvlan,\n\t[LXC_NET_VLAN]    = instantiate_vlan,\n\t[LXC_NET_PHYS]    = instantiate_phys,\n\t[LXC_NET_EMPTY]   = instantiate_empty,\n\t[LXC_NET_NONE]    = instantiate_none,\n};",
      "static int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_none(struct lxc_handler *, struct lxc_netdev *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to create netdev\""
          ],
          "line": 2962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netdev_conf[netdev->type]",
          "args": [
            "handler",
            "netdev"
          ],
          "line": 2961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"invalid network configuration type '%d'\"",
            "netdev->type"
          ],
          "line": 2956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "iterator",
            "network"
          ],
          "line": 2951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 2946
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_none(struct lxc_handler *, struct lxc_netdev *);\nstatic  instantiate_cb netdev_conf[LXC_NET_MAXCONFTYPE + 1] = {\n\t[LXC_NET_VETH]    = instantiate_veth,\n\t[LXC_NET_MACVLAN] = instantiate_macvlan,\n\t[LXC_NET_VLAN]    = instantiate_vlan,\n\t[LXC_NET_PHYS]    = instantiate_phys,\n\t[LXC_NET_EMPTY]   = instantiate_empty,\n\t[LXC_NET_NONE]    = instantiate_none,\n};\nstatic int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_none(struct lxc_handler *, struct lxc_netdev *);\n\nint lxc_create_network(struct lxc_handler *handler)\n{\n\tstruct lxc_list *network = &handler->conf->network;\n\tstruct lxc_list *iterator;\n\tstruct lxc_netdev *netdev;\n\tint am_root = (getuid() == 0);\n\n\tif (!am_root)\n\t\treturn 0;\n\n\tlxc_list_for_each(iterator, network) {\n\n\t\tnetdev = iterator->elem;\n\n\t\tif (netdev->type < 0 || netdev->type > LXC_NET_MAXCONFTYPE) {\n\t\t\tERROR(\"invalid network configuration type '%d'\",\n\t\t\t      netdev->type);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (netdev_conf[netdev->type](handler, netdev)) {\n\t\t\tERROR(\"failed to create netdev\");\n\t\t\treturn -1;\n\t\t}\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_requests_empty_network",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "2917-2939",
    "snippet": "int lxc_requests_empty_network(struct lxc_handler *handler)\n{\n\tstruct lxc_list *network = &handler->conf->network;\n\tstruct lxc_list *iterator;\n\tstruct lxc_netdev *netdev;\n\tbool found_none = false, found_nic = false;\n\n\tif (lxc_list_empty(network))\n\t\treturn 0;\n\n\tlxc_list_for_each(iterator, network) {\n\n\t\tnetdev = iterator->elem;\n\n\t\tif (netdev->type == LXC_NET_NONE)\n\t\t\tfound_none = true;\n\t\telse\n\t\t\tfound_nic = true;\n\t}\n\tif (found_none && !found_nic)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_none(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_none(struct lxc_handler *, struct lxc_netdev *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "iterator",
            "network"
          ],
          "line": 2927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_empty",
          "args": [
            "network"
          ],
          "line": 2924
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "94-97",
          "snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_none(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_none(struct lxc_handler *, struct lxc_netdev *);\n\nint lxc_requests_empty_network(struct lxc_handler *handler)\n{\n\tstruct lxc_list *network = &handler->conf->network;\n\tstruct lxc_list *iterator;\n\tstruct lxc_netdev *netdev;\n\tbool found_none = false, found_nic = false;\n\n\tif (lxc_list_empty(network))\n\t\treturn 0;\n\n\tlxc_list_for_each(iterator, network) {\n\n\t\tnetdev = iterator->elem;\n\n\t\tif (netdev->type == LXC_NET_NONE)\n\t\t\tfound_none = true;\n\t\telse\n\t\t\tfound_nic = true;\n\t}\n\tif (found_none && !found_nic)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "shutdown_none",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "2912-2915",
    "snippet": "static int shutdown_none(struct lxc_handler *handler, struct lxc_netdev *netdev)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_none(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_none(struct lxc_handler *, struct lxc_netdev *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_none(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_none(struct lxc_handler *, struct lxc_netdev *);\n\nstatic int shutdown_none(struct lxc_handler *handler, struct lxc_netdev *netdev)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "shutdown_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "2899-2910",
    "snippet": "static int shutdown_empty(struct lxc_handler *handler, struct lxc_netdev *netdev)\n{\n\tint err;\n\n\tif (netdev->downscript) {\n\t\terr = run_script(handler->name, \"net\", netdev->downscript,\n\t\t\t\t \"down\", \"empty\", (char*) NULL);\n\t\tif (err)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_none(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_none(struct lxc_handler *, struct lxc_netdev *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "run_script",
          "args": [
            "handler->name",
            "\"net\"",
            "netdev->downscript",
            "\"down\"",
            "\"empty\"",
            "(char*) NULL"
          ],
          "line": 2904
        },
        "resolved": true,
        "details": {
          "function_name": "run_script",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "466-516",
          "snippet": "static int run_script(const char *name, const char *section, const char *script,\n\t\t      ...)\n{\n\tint ret;\n\tchar *buffer, *p;\n\tsize_t size = 0;\n\tva_list ap;\n\n\tINFO(\"Executing script \\\"%s\\\" for container \\\"%s\\\", config section \\\"%s\\\".\",\n\t     script, name, section);\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *)))\n\t\tsize += strlen(p) + 1;\n\tva_end(ap);\n\n\tsize += strlen(script);\n\tsize += strlen(name);\n\tsize += strlen(section);\n\tsize += 3;\n\n\tif (size > INT_MAX)\n\t\treturn -1;\n\n\tbuffer = alloca(size);\n\tif (!buffer) {\n\t\tERROR(\"Failed to allocate memory.\");\n\t\treturn -1;\n\t}\n\n\tret = snprintf(buffer, size, \"%s %s %s\", script, name, section);\n\tif (ret < 0 || ret >= size) {\n\t\tERROR(\"Script name too long.\");\n\t\treturn -1;\n\t}\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *))) {\n\t\tint len = size - ret;\n\t\tint rc;\n\t\trc = snprintf(buffer + ret, len, \" %s\", p);\n\t\tif (rc < 0 || rc >= len) {\n\t\t\tERROR(\"Script args too long.\");\n\t\t\treturn -1;\n\t\t}\n\t\tret += rc;\n\t}\n\tva_end(ap);\n\n\treturn run_buffer(buffer);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int run_script(const char *name, const char *section, const char *script,\n\t\t      ...)\n{\n\tint ret;\n\tchar *buffer, *p;\n\tsize_t size = 0;\n\tva_list ap;\n\n\tINFO(\"Executing script \\\"%s\\\" for container \\\"%s\\\", config section \\\"%s\\\".\",\n\t     script, name, section);\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *)))\n\t\tsize += strlen(p) + 1;\n\tva_end(ap);\n\n\tsize += strlen(script);\n\tsize += strlen(name);\n\tsize += strlen(section);\n\tsize += 3;\n\n\tif (size > INT_MAX)\n\t\treturn -1;\n\n\tbuffer = alloca(size);\n\tif (!buffer) {\n\t\tERROR(\"Failed to allocate memory.\");\n\t\treturn -1;\n\t}\n\n\tret = snprintf(buffer, size, \"%s %s %s\", script, name, section);\n\tif (ret < 0 || ret >= size) {\n\t\tERROR(\"Script name too long.\");\n\t\treturn -1;\n\t}\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *))) {\n\t\tint len = size - ret;\n\t\tint rc;\n\t\trc = snprintf(buffer + ret, len, \" %s\", p);\n\t\tif (rc < 0 || rc >= len) {\n\t\t\tERROR(\"Script args too long.\");\n\t\t\treturn -1;\n\t\t}\n\t\tret += rc;\n\t}\n\tva_end(ap);\n\n\treturn run_buffer(buffer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_none(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_none(struct lxc_handler *, struct lxc_netdev *);\n\nstatic int shutdown_empty(struct lxc_handler *handler, struct lxc_netdev *netdev)\n{\n\tint err;\n\n\tif (netdev->downscript) {\n\t\terr = run_script(handler->name, \"net\", netdev->downscript,\n\t\t\t\t \"down\", \"empty\", (char*) NULL);\n\t\tif (err)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "instantiate_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "2886-2897",
    "snippet": "static int instantiate_empty(struct lxc_handler *handler, struct lxc_netdev *netdev)\n{\n\tnetdev->ifindex = 0;\n\tif (netdev->upscript) {\n\t\tint err;\n\t\terr = run_script(handler->name, \"net\", netdev->upscript,\n\t\t\t\t \"up\", \"empty\", (char*) NULL);\n\t\tif (err)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_none(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_none(struct lxc_handler *, struct lxc_netdev *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "run_script",
          "args": [
            "handler->name",
            "\"net\"",
            "netdev->upscript",
            "\"up\"",
            "\"empty\"",
            "(char*) NULL"
          ],
          "line": 2891
        },
        "resolved": true,
        "details": {
          "function_name": "run_script",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "466-516",
          "snippet": "static int run_script(const char *name, const char *section, const char *script,\n\t\t      ...)\n{\n\tint ret;\n\tchar *buffer, *p;\n\tsize_t size = 0;\n\tva_list ap;\n\n\tINFO(\"Executing script \\\"%s\\\" for container \\\"%s\\\", config section \\\"%s\\\".\",\n\t     script, name, section);\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *)))\n\t\tsize += strlen(p) + 1;\n\tva_end(ap);\n\n\tsize += strlen(script);\n\tsize += strlen(name);\n\tsize += strlen(section);\n\tsize += 3;\n\n\tif (size > INT_MAX)\n\t\treturn -1;\n\n\tbuffer = alloca(size);\n\tif (!buffer) {\n\t\tERROR(\"Failed to allocate memory.\");\n\t\treturn -1;\n\t}\n\n\tret = snprintf(buffer, size, \"%s %s %s\", script, name, section);\n\tif (ret < 0 || ret >= size) {\n\t\tERROR(\"Script name too long.\");\n\t\treturn -1;\n\t}\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *))) {\n\t\tint len = size - ret;\n\t\tint rc;\n\t\trc = snprintf(buffer + ret, len, \" %s\", p);\n\t\tif (rc < 0 || rc >= len) {\n\t\t\tERROR(\"Script args too long.\");\n\t\t\treturn -1;\n\t\t}\n\t\tret += rc;\n\t}\n\tva_end(ap);\n\n\treturn run_buffer(buffer);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int run_script(const char *name, const char *section, const char *script,\n\t\t      ...)\n{\n\tint ret;\n\tchar *buffer, *p;\n\tsize_t size = 0;\n\tva_list ap;\n\n\tINFO(\"Executing script \\\"%s\\\" for container \\\"%s\\\", config section \\\"%s\\\".\",\n\t     script, name, section);\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *)))\n\t\tsize += strlen(p) + 1;\n\tva_end(ap);\n\n\tsize += strlen(script);\n\tsize += strlen(name);\n\tsize += strlen(section);\n\tsize += 3;\n\n\tif (size > INT_MAX)\n\t\treturn -1;\n\n\tbuffer = alloca(size);\n\tif (!buffer) {\n\t\tERROR(\"Failed to allocate memory.\");\n\t\treturn -1;\n\t}\n\n\tret = snprintf(buffer, size, \"%s %s %s\", script, name, section);\n\tif (ret < 0 || ret >= size) {\n\t\tERROR(\"Script name too long.\");\n\t\treturn -1;\n\t}\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *))) {\n\t\tint len = size - ret;\n\t\tint rc;\n\t\trc = snprintf(buffer + ret, len, \" %s\", p);\n\t\tif (rc < 0 || rc >= len) {\n\t\t\tERROR(\"Script args too long.\");\n\t\t\treturn -1;\n\t\t}\n\t\tret += rc;\n\t}\n\tva_end(ap);\n\n\treturn run_buffer(buffer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_none(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_none(struct lxc_handler *, struct lxc_netdev *);\n\nstatic int instantiate_empty(struct lxc_handler *handler, struct lxc_netdev *netdev)\n{\n\tnetdev->ifindex = 0;\n\tif (netdev->upscript) {\n\t\tint err;\n\t\terr = run_script(handler->name, \"net\", netdev->upscript,\n\t\t\t\t \"up\", \"empty\", (char*) NULL);\n\t\tif (err)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "instantiate_none",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "2880-2884",
    "snippet": "static int instantiate_none(struct lxc_handler *handler, struct lxc_netdev *netdev)\n{\n\tnetdev->ifindex = 0;\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_none(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_none(struct lxc_handler *, struct lxc_netdev *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_none(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_none(struct lxc_handler *, struct lxc_netdev *);\n\nstatic int instantiate_none(struct lxc_handler *handler, struct lxc_netdev *netdev)\n{\n\tnetdev->ifindex = 0;\n\treturn 0;\n}"
  },
  {
    "function_name": "shutdown_phys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "2867-2878",
    "snippet": "static int shutdown_phys(struct lxc_handler *handler, struct lxc_netdev *netdev)\n{\n\tint err;\n\n\tif (netdev->downscript) {\n\t\terr = run_script(handler->name, \"net\", netdev->downscript,\n\t\t\t\t \"down\", \"phys\", netdev->link, (char*) NULL);\n\t\tif (err)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_none(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_none(struct lxc_handler *, struct lxc_netdev *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "run_script",
          "args": [
            "handler->name",
            "\"net\"",
            "netdev->downscript",
            "\"down\"",
            "\"phys\"",
            "netdev->link",
            "(char*) NULL"
          ],
          "line": 2872
        },
        "resolved": true,
        "details": {
          "function_name": "run_script",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "466-516",
          "snippet": "static int run_script(const char *name, const char *section, const char *script,\n\t\t      ...)\n{\n\tint ret;\n\tchar *buffer, *p;\n\tsize_t size = 0;\n\tva_list ap;\n\n\tINFO(\"Executing script \\\"%s\\\" for container \\\"%s\\\", config section \\\"%s\\\".\",\n\t     script, name, section);\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *)))\n\t\tsize += strlen(p) + 1;\n\tva_end(ap);\n\n\tsize += strlen(script);\n\tsize += strlen(name);\n\tsize += strlen(section);\n\tsize += 3;\n\n\tif (size > INT_MAX)\n\t\treturn -1;\n\n\tbuffer = alloca(size);\n\tif (!buffer) {\n\t\tERROR(\"Failed to allocate memory.\");\n\t\treturn -1;\n\t}\n\n\tret = snprintf(buffer, size, \"%s %s %s\", script, name, section);\n\tif (ret < 0 || ret >= size) {\n\t\tERROR(\"Script name too long.\");\n\t\treturn -1;\n\t}\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *))) {\n\t\tint len = size - ret;\n\t\tint rc;\n\t\trc = snprintf(buffer + ret, len, \" %s\", p);\n\t\tif (rc < 0 || rc >= len) {\n\t\t\tERROR(\"Script args too long.\");\n\t\t\treturn -1;\n\t\t}\n\t\tret += rc;\n\t}\n\tva_end(ap);\n\n\treturn run_buffer(buffer);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int run_script(const char *name, const char *section, const char *script,\n\t\t      ...)\n{\n\tint ret;\n\tchar *buffer, *p;\n\tsize_t size = 0;\n\tva_list ap;\n\n\tINFO(\"Executing script \\\"%s\\\" for container \\\"%s\\\", config section \\\"%s\\\".\",\n\t     script, name, section);\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *)))\n\t\tsize += strlen(p) + 1;\n\tva_end(ap);\n\n\tsize += strlen(script);\n\tsize += strlen(name);\n\tsize += strlen(section);\n\tsize += 3;\n\n\tif (size > INT_MAX)\n\t\treturn -1;\n\n\tbuffer = alloca(size);\n\tif (!buffer) {\n\t\tERROR(\"Failed to allocate memory.\");\n\t\treturn -1;\n\t}\n\n\tret = snprintf(buffer, size, \"%s %s %s\", script, name, section);\n\tif (ret < 0 || ret >= size) {\n\t\tERROR(\"Script name too long.\");\n\t\treturn -1;\n\t}\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *))) {\n\t\tint len = size - ret;\n\t\tint rc;\n\t\trc = snprintf(buffer + ret, len, \" %s\", p);\n\t\tif (rc < 0 || rc >= len) {\n\t\t\tERROR(\"Script args too long.\");\n\t\t\treturn -1;\n\t\t}\n\t\tret += rc;\n\t}\n\tva_end(ap);\n\n\treturn run_buffer(buffer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_none(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_none(struct lxc_handler *, struct lxc_netdev *);\n\nstatic int shutdown_phys(struct lxc_handler *handler, struct lxc_netdev *netdev)\n{\n\tint err;\n\n\tif (netdev->downscript) {\n\t\terr = run_script(handler->name, \"net\", netdev->downscript,\n\t\t\t\t \"down\", \"phys\", netdev->link, (char*) NULL);\n\t\tif (err)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "instantiate_phys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "2843-2865",
    "snippet": "static int instantiate_phys(struct lxc_handler *handler, struct lxc_netdev *netdev)\n{\n\tif (!netdev->link) {\n\t\tERROR(\"no link specified for the physical interface\");\n\t\treturn -1;\n\t}\n\n\tnetdev->ifindex = if_nametoindex(netdev->link);\n\tif (!netdev->ifindex) {\n\t\tERROR(\"failed to retrieve the index for %s\", netdev->link);\n\t\treturn -1;\n\t}\n\n\tif (netdev->upscript) {\n\t\tint err;\n\t\terr = run_script(handler->name, \"net\", netdev->upscript,\n\t\t\t\t \"up\", \"phys\", netdev->link, (char*) NULL);\n\t\tif (err)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_none(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_none(struct lxc_handler *, struct lxc_netdev *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "run_script",
          "args": [
            "handler->name",
            "\"net\"",
            "netdev->upscript",
            "\"up\"",
            "\"phys\"",
            "netdev->link",
            "(char*) NULL"
          ],
          "line": 2858
        },
        "resolved": true,
        "details": {
          "function_name": "run_script",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "466-516",
          "snippet": "static int run_script(const char *name, const char *section, const char *script,\n\t\t      ...)\n{\n\tint ret;\n\tchar *buffer, *p;\n\tsize_t size = 0;\n\tva_list ap;\n\n\tINFO(\"Executing script \\\"%s\\\" for container \\\"%s\\\", config section \\\"%s\\\".\",\n\t     script, name, section);\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *)))\n\t\tsize += strlen(p) + 1;\n\tva_end(ap);\n\n\tsize += strlen(script);\n\tsize += strlen(name);\n\tsize += strlen(section);\n\tsize += 3;\n\n\tif (size > INT_MAX)\n\t\treturn -1;\n\n\tbuffer = alloca(size);\n\tif (!buffer) {\n\t\tERROR(\"Failed to allocate memory.\");\n\t\treturn -1;\n\t}\n\n\tret = snprintf(buffer, size, \"%s %s %s\", script, name, section);\n\tif (ret < 0 || ret >= size) {\n\t\tERROR(\"Script name too long.\");\n\t\treturn -1;\n\t}\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *))) {\n\t\tint len = size - ret;\n\t\tint rc;\n\t\trc = snprintf(buffer + ret, len, \" %s\", p);\n\t\tif (rc < 0 || rc >= len) {\n\t\t\tERROR(\"Script args too long.\");\n\t\t\treturn -1;\n\t\t}\n\t\tret += rc;\n\t}\n\tva_end(ap);\n\n\treturn run_buffer(buffer);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int run_script(const char *name, const char *section, const char *script,\n\t\t      ...)\n{\n\tint ret;\n\tchar *buffer, *p;\n\tsize_t size = 0;\n\tva_list ap;\n\n\tINFO(\"Executing script \\\"%s\\\" for container \\\"%s\\\", config section \\\"%s\\\".\",\n\t     script, name, section);\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *)))\n\t\tsize += strlen(p) + 1;\n\tva_end(ap);\n\n\tsize += strlen(script);\n\tsize += strlen(name);\n\tsize += strlen(section);\n\tsize += 3;\n\n\tif (size > INT_MAX)\n\t\treturn -1;\n\n\tbuffer = alloca(size);\n\tif (!buffer) {\n\t\tERROR(\"Failed to allocate memory.\");\n\t\treturn -1;\n\t}\n\n\tret = snprintf(buffer, size, \"%s %s %s\", script, name, section);\n\tif (ret < 0 || ret >= size) {\n\t\tERROR(\"Script name too long.\");\n\t\treturn -1;\n\t}\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *))) {\n\t\tint len = size - ret;\n\t\tint rc;\n\t\trc = snprintf(buffer + ret, len, \" %s\", p);\n\t\tif (rc < 0 || rc >= len) {\n\t\t\tERROR(\"Script args too long.\");\n\t\t\treturn -1;\n\t\t}\n\t\tret += rc;\n\t}\n\tva_end(ap);\n\n\treturn run_buffer(buffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to retrieve the index for %s\"",
            "netdev->link"
          ],
          "line": 2852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_nametoindex",
          "args": [
            "netdev->link"
          ],
          "line": 2850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"no link specified for the physical interface\""
          ],
          "line": 2846
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_none(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_none(struct lxc_handler *, struct lxc_netdev *);\n\nstatic int instantiate_phys(struct lxc_handler *handler, struct lxc_netdev *netdev)\n{\n\tif (!netdev->link) {\n\t\tERROR(\"no link specified for the physical interface\");\n\t\treturn -1;\n\t}\n\n\tnetdev->ifindex = if_nametoindex(netdev->link);\n\tif (!netdev->ifindex) {\n\t\tERROR(\"failed to retrieve the index for %s\", netdev->link);\n\t\treturn -1;\n\t}\n\n\tif (netdev->upscript) {\n\t\tint err;\n\t\terr = run_script(handler->name, \"net\", netdev->upscript,\n\t\t\t\t \"up\", \"phys\", netdev->link, (char*) NULL);\n\t\tif (err)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "shutdown_vlan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "2838-2841",
    "snippet": "static int shutdown_vlan(struct lxc_handler *handler, struct lxc_netdev *netdev)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_none(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_none(struct lxc_handler *, struct lxc_netdev *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_none(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_none(struct lxc_handler *, struct lxc_netdev *);\n\nstatic int shutdown_vlan(struct lxc_handler *handler, struct lxc_netdev *netdev)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "instantiate_vlan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "2786-2836",
    "snippet": "static int instantiate_vlan(struct lxc_handler *handler, struct lxc_netdev *netdev)\n{\n\tchar peer[IFNAMSIZ];\n\tint err;\n\tstatic uint16_t vlan_cntr = 0;\n\tunsigned int mtu = 0;\n\n\tif (!netdev->link) {\n\t\tERROR(\"no link specified for vlan netdev\");\n\t\treturn -1;\n\t}\n\n\terr = snprintf(peer, sizeof(peer), \"vlan%d-%d\", netdev->priv.vlan_attr.vid, vlan_cntr++);\n\tif (err >= sizeof(peer)) {\n\t\tERROR(\"peer name too long\");\n\t\treturn -1;\n\t}\n\n\terr = lxc_vlan_create(netdev->link, peer, netdev->priv.vlan_attr.vid);\n\tif (err) {\n\t\tERROR(\"failed to create vlan interface '%s' on '%s' : %s\",\n\t\t      peer, netdev->link, strerror(-err));\n\t\treturn -1;\n\t}\n\n\tnetdev->ifindex = if_nametoindex(peer);\n\tif (!netdev->ifindex) {\n\t\tERROR(\"failed to retrieve the ifindex for %s\", peer);\n\t\tlxc_netdev_delete_by_name(peer);\n\t\treturn -1;\n\t}\n\n\tDEBUG(\"instantiated vlan '%s', ifindex is '%d'\", \" vlan1000\",\n\t      netdev->ifindex);\n\tif (netdev->mtu) {\n\t\tif (lxc_safe_uint(netdev->mtu, &mtu) < 0) {\n\t\t\tERROR(\"Failed to retrieve mtu from: '%d'/'%s'.\",\n\t\t\t      netdev->ifindex, netdev->name);\n\t\t\treturn -1;\n\t\t}\n\t\terr = lxc_netdev_set_mtu(peer, mtu);\n\t\tif (err) {\n\t\t\tERROR(\"failed to set mtu '%s' for %s : %s\",\n\t\t\t      netdev->mtu, peer, strerror(-err));\n\t\t\tlxc_netdev_delete_by_name(peer);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_none(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_none(struct lxc_handler *, struct lxc_netdev *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_netdev_delete_by_name",
          "args": [
            "peer"
          ],
          "line": 2830
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_netdev_delete_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "295-304",
          "snippet": "int lxc_netdev_delete_by_name(const char *name)\n{\n\tint index;\n\n\tindex = if_nametoindex(name);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\treturn lxc_netdev_delete_by_index(index);\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_netdev_delete_by_name(const char *name)\n{\n\tint index;\n\n\tindex = if_nametoindex(name);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\treturn lxc_netdev_delete_by_index(index);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to set mtu '%s' for %s : %s\"",
            "netdev->mtu",
            "peer",
            "strerror(-err)"
          ],
          "line": 2828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "-err"
          ],
          "line": 2829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_netdev_set_mtu",
          "args": [
            "peer",
            "mtu"
          ],
          "line": 2826
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_netdev_set_mtu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "610-660",
          "snippet": "int lxc_netdev_set_mtu(const char *name, int mtu)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tint index, len, err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tlen = strlen(name);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tindex = if_nametoindex(name);\n\tif (!index)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_REQUEST|NLM_F_ACK;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tifi->ifi_family = AF_UNSPEC;\n\tifi->ifi_index = index;\n\n\tif (nla_put_u32(nlmsg, IFLA_MTU, mtu))\n\t\tgoto out;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(nlmsg);\n\tnlmsg_free(answer);\n\treturn err;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_netdev_set_mtu(const char *name, int mtu)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tint index, len, err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tlen = strlen(name);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tindex = if_nametoindex(name);\n\tif (!index)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_REQUEST|NLM_F_ACK;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tifi->ifi_family = AF_UNSPEC;\n\tifi->ifi_index = index;\n\n\tif (nla_put_u32(nlmsg, IFLA_MTU, mtu))\n\t\tgoto out;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(nlmsg);\n\tnlmsg_free(answer);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to retrieve mtu from: '%d'/'%s'.\"",
            "netdev->ifindex",
            "netdev->name"
          ],
          "line": 2822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_safe_uint",
          "args": [
            "netdev->mtu",
            "&mtu"
          ],
          "line": 2821
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_safe_uint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1985-2003",
          "snippet": "int lxc_safe_uint(const char *numstr, unsigned int *converted)\n{\n\tchar *err = NULL;\n\tunsigned long int uli;\n\n\terrno = 0;\n\tuli = strtoul(numstr, &err, 0);\n\tif (errno > 0)\n\t\treturn -errno;\n\n\tif (!err || err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\n\tif (uli > UINT_MAX)\n\t\treturn -ERANGE;\n\n\t*converted = (unsigned int)uli;\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_safe_uint(const char *numstr, unsigned int *converted)\n{\n\tchar *err = NULL;\n\tunsigned long int uli;\n\n\terrno = 0;\n\tuli = strtoul(numstr, &err, 0);\n\tif (errno > 0)\n\t\treturn -errno;\n\n\tif (!err || err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\n\tif (uli > UINT_MAX)\n\t\treturn -ERANGE;\n\n\t*converted = (unsigned int)uli;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"instantiated vlan '%s', ifindex is '%d'\"",
            "\" vlan1000\"",
            "netdev->ifindex"
          ],
          "line": 2818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to retrieve the ifindex for %s\"",
            "peer"
          ],
          "line": 2813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_nametoindex",
          "args": [
            "peer"
          ],
          "line": 2811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to create vlan interface '%s' on '%s' : %s\"",
            "peer",
            "netdev->link",
            "strerror(-err)"
          ],
          "line": 2806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "-err"
          ],
          "line": 2807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_vlan_create",
          "args": [
            "netdev->link",
            "peer",
            "netdev->priv.vlan_attr.vid"
          ],
          "line": 2804
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_vlan_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "754-832",
          "snippet": "int lxc_vlan_create(const char *master, const char *name, unsigned short vlanid)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tstruct rtattr *nest, *nest2;\n\tint lindex, len, err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tlen = strlen(master);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto err3;\n\n\tlen = strlen(name);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto err3;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto err3;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto err2;\n\n\terr = -EINVAL;\n\tlindex = if_nametoindex(master);\n\tif (!lindex)\n\t\tgoto err1;\n\n\tnlmsg->nlmsghdr->nlmsg_flags =\n\t\tNLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL|NLM_F_ACK;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi) {\n\t\terr = -ENOMEM;\n\t\tgoto err1;\n\t}\n\tifi->ifi_family = AF_UNSPEC;\n\n\tnest = nla_begin_nested(nlmsg, IFLA_LINKINFO);\n\tif (!nest)\n\t\tgoto err1;\n\n\tif (nla_put_string(nlmsg, IFLA_INFO_KIND, \"vlan\"))\n\t\tgoto err1;\n\n\tnest2 = nla_begin_nested(nlmsg, IFLA_INFO_DATA);\n\tif (!nest2)\n\t\tgoto err1;\n\n\tif (nla_put_u16(nlmsg, IFLA_VLAN_ID, vlanid))\n\t\tgoto err1;\n\n\tnla_end_nested(nlmsg, nest2);\n\n\tnla_end_nested(nlmsg, nest);\n\n\tif (nla_put_u32(nlmsg, IFLA_LINK, lindex))\n\t\tgoto err1;\n\n\tif (nla_put_string(nlmsg, IFLA_IFNAME, name))\n\t\tgoto err1;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nerr1:\n\tnlmsg_free(answer);\nerr2:\n\tnlmsg_free(nlmsg);\nerr3:\n\tnetlink_close(&nlh);\n\treturn err;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_vlan_create(const char *master, const char *name, unsigned short vlanid)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tstruct rtattr *nest, *nest2;\n\tint lindex, len, err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tlen = strlen(master);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto err3;\n\n\tlen = strlen(name);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto err3;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto err3;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto err2;\n\n\terr = -EINVAL;\n\tlindex = if_nametoindex(master);\n\tif (!lindex)\n\t\tgoto err1;\n\n\tnlmsg->nlmsghdr->nlmsg_flags =\n\t\tNLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL|NLM_F_ACK;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi) {\n\t\terr = -ENOMEM;\n\t\tgoto err1;\n\t}\n\tifi->ifi_family = AF_UNSPEC;\n\n\tnest = nla_begin_nested(nlmsg, IFLA_LINKINFO);\n\tif (!nest)\n\t\tgoto err1;\n\n\tif (nla_put_string(nlmsg, IFLA_INFO_KIND, \"vlan\"))\n\t\tgoto err1;\n\n\tnest2 = nla_begin_nested(nlmsg, IFLA_INFO_DATA);\n\tif (!nest2)\n\t\tgoto err1;\n\n\tif (nla_put_u16(nlmsg, IFLA_VLAN_ID, vlanid))\n\t\tgoto err1;\n\n\tnla_end_nested(nlmsg, nest2);\n\n\tnla_end_nested(nlmsg, nest);\n\n\tif (nla_put_u32(nlmsg, IFLA_LINK, lindex))\n\t\tgoto err1;\n\n\tif (nla_put_string(nlmsg, IFLA_IFNAME, name))\n\t\tgoto err1;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nerr1:\n\tnlmsg_free(answer);\nerr2:\n\tnlmsg_free(nlmsg);\nerr3:\n\tnetlink_close(&nlh);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"peer name too long\""
          ],
          "line": 2800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "peer",
            "sizeof(peer)",
            "\"vlan%d-%d\"",
            "netdev->priv.vlan_attr.vid",
            "vlan_cntr++"
          ],
          "line": 2798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"no link specified for vlan netdev\""
          ],
          "line": 2794
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_none(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_none(struct lxc_handler *, struct lxc_netdev *);\n\nstatic int instantiate_vlan(struct lxc_handler *handler, struct lxc_netdev *netdev)\n{\n\tchar peer[IFNAMSIZ];\n\tint err;\n\tstatic uint16_t vlan_cntr = 0;\n\tunsigned int mtu = 0;\n\n\tif (!netdev->link) {\n\t\tERROR(\"no link specified for vlan netdev\");\n\t\treturn -1;\n\t}\n\n\terr = snprintf(peer, sizeof(peer), \"vlan%d-%d\", netdev->priv.vlan_attr.vid, vlan_cntr++);\n\tif (err >= sizeof(peer)) {\n\t\tERROR(\"peer name too long\");\n\t\treturn -1;\n\t}\n\n\terr = lxc_vlan_create(netdev->link, peer, netdev->priv.vlan_attr.vid);\n\tif (err) {\n\t\tERROR(\"failed to create vlan interface '%s' on '%s' : %s\",\n\t\t      peer, netdev->link, strerror(-err));\n\t\treturn -1;\n\t}\n\n\tnetdev->ifindex = if_nametoindex(peer);\n\tif (!netdev->ifindex) {\n\t\tERROR(\"failed to retrieve the ifindex for %s\", peer);\n\t\tlxc_netdev_delete_by_name(peer);\n\t\treturn -1;\n\t}\n\n\tDEBUG(\"instantiated vlan '%s', ifindex is '%d'\", \" vlan1000\",\n\t      netdev->ifindex);\n\tif (netdev->mtu) {\n\t\tif (lxc_safe_uint(netdev->mtu, &mtu) < 0) {\n\t\t\tERROR(\"Failed to retrieve mtu from: '%d'/'%s'.\",\n\t\t\t      netdev->ifindex, netdev->name);\n\t\t\treturn -1;\n\t\t}\n\t\terr = lxc_netdev_set_mtu(peer, mtu);\n\t\tif (err) {\n\t\t\tERROR(\"failed to set mtu '%s' for %s : %s\",\n\t\t\t      netdev->mtu, peer, strerror(-err));\n\t\t\tlxc_netdev_delete_by_name(peer);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "shutdown_macvlan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "2771-2783",
    "snippet": "static int shutdown_macvlan(struct lxc_handler *handler, struct lxc_netdev *netdev)\n{\n\tint err;\n\n\tif (netdev->downscript) {\n\t\terr = run_script(handler->name, \"net\", netdev->downscript,\n\t\t\t\t \"down\", \"macvlan\", netdev->link,\n\t\t\t\t (char*) NULL);\n\t\tif (err)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_none(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_none(struct lxc_handler *, struct lxc_netdev *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "run_script",
          "args": [
            "handler->name",
            "\"net\"",
            "netdev->downscript",
            "\"down\"",
            "\"macvlan\"",
            "netdev->link",
            "(char*) NULL"
          ],
          "line": 2776
        },
        "resolved": true,
        "details": {
          "function_name": "run_script",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "466-516",
          "snippet": "static int run_script(const char *name, const char *section, const char *script,\n\t\t      ...)\n{\n\tint ret;\n\tchar *buffer, *p;\n\tsize_t size = 0;\n\tva_list ap;\n\n\tINFO(\"Executing script \\\"%s\\\" for container \\\"%s\\\", config section \\\"%s\\\".\",\n\t     script, name, section);\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *)))\n\t\tsize += strlen(p) + 1;\n\tva_end(ap);\n\n\tsize += strlen(script);\n\tsize += strlen(name);\n\tsize += strlen(section);\n\tsize += 3;\n\n\tif (size > INT_MAX)\n\t\treturn -1;\n\n\tbuffer = alloca(size);\n\tif (!buffer) {\n\t\tERROR(\"Failed to allocate memory.\");\n\t\treturn -1;\n\t}\n\n\tret = snprintf(buffer, size, \"%s %s %s\", script, name, section);\n\tif (ret < 0 || ret >= size) {\n\t\tERROR(\"Script name too long.\");\n\t\treturn -1;\n\t}\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *))) {\n\t\tint len = size - ret;\n\t\tint rc;\n\t\trc = snprintf(buffer + ret, len, \" %s\", p);\n\t\tif (rc < 0 || rc >= len) {\n\t\t\tERROR(\"Script args too long.\");\n\t\t\treturn -1;\n\t\t}\n\t\tret += rc;\n\t}\n\tva_end(ap);\n\n\treturn run_buffer(buffer);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int run_script(const char *name, const char *section, const char *script,\n\t\t      ...)\n{\n\tint ret;\n\tchar *buffer, *p;\n\tsize_t size = 0;\n\tva_list ap;\n\n\tINFO(\"Executing script \\\"%s\\\" for container \\\"%s\\\", config section \\\"%s\\\".\",\n\t     script, name, section);\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *)))\n\t\tsize += strlen(p) + 1;\n\tva_end(ap);\n\n\tsize += strlen(script);\n\tsize += strlen(name);\n\tsize += strlen(section);\n\tsize += 3;\n\n\tif (size > INT_MAX)\n\t\treturn -1;\n\n\tbuffer = alloca(size);\n\tif (!buffer) {\n\t\tERROR(\"Failed to allocate memory.\");\n\t\treturn -1;\n\t}\n\n\tret = snprintf(buffer, size, \"%s %s %s\", script, name, section);\n\tif (ret < 0 || ret >= size) {\n\t\tERROR(\"Script name too long.\");\n\t\treturn -1;\n\t}\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *))) {\n\t\tint len = size - ret;\n\t\tint rc;\n\t\trc = snprintf(buffer + ret, len, \" %s\", p);\n\t\tif (rc < 0 || rc >= len) {\n\t\t\tERROR(\"Script args too long.\");\n\t\t\treturn -1;\n\t\t}\n\t\tret += rc;\n\t}\n\tva_end(ap);\n\n\treturn run_buffer(buffer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_none(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_none(struct lxc_handler *, struct lxc_netdev *);\n\nstatic int shutdown_macvlan(struct lxc_handler *handler, struct lxc_netdev *netdev)\n{\n\tint err;\n\n\tif (netdev->downscript) {\n\t\terr = run_script(handler->name, \"net\", netdev->downscript,\n\t\t\t\t \"down\", \"macvlan\", netdev->link,\n\t\t\t\t (char*) NULL);\n\t\tif (err)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "instantiate_macvlan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "2720-2769",
    "snippet": "static int instantiate_macvlan(struct lxc_handler *handler, struct lxc_netdev *netdev)\n{\n\tchar peerbuf[IFNAMSIZ], *peer;\n\tint err;\n\n\tif (!netdev->link) {\n\t\tERROR(\"no link specified for macvlan netdev\");\n\t\treturn -1;\n\t}\n\n\terr = snprintf(peerbuf, sizeof(peerbuf), \"mcXXXXXX\");\n\tif (err >= sizeof(peerbuf))\n\t\treturn -1;\n\n\tpeer = lxc_mkifname(peerbuf);\n\tif (!peer) {\n\t\tERROR(\"failed to make a temporary name\");\n\t\treturn -1;\n\t}\n\n\terr = lxc_macvlan_create(netdev->link, peer,\n\t\t\t\t netdev->priv.macvlan_attr.mode);\n\tif (err) {\n\t\tERROR(\"failed to create macvlan interface '%s' on '%s' : %s\",\n\t\t      peer, netdev->link, strerror(-err));\n\t\tgoto out;\n\t}\n\n\tnetdev->ifindex = if_nametoindex(peer);\n\tif (!netdev->ifindex) {\n\t\tERROR(\"failed to retrieve the index for %s\", peer);\n\t\tgoto out;\n\t}\n\n\tif (netdev->upscript) {\n\t\terr = run_script(handler->name, \"net\", netdev->upscript, \"up\",\n\t\t\t\t \"macvlan\", netdev->link, (char*) NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tDEBUG(\"instantiated macvlan '%s', index is '%d' and mode '%d'\",\n\t      peer, netdev->ifindex, netdev->priv.macvlan_attr.mode);\n\n\treturn 0;\nout:\n\tlxc_netdev_delete_by_name(peer);\n\tfree(peer);\n\treturn -1;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_none(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_none(struct lxc_handler *, struct lxc_netdev *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "peer"
          ],
          "line": 2767
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4619-4628",
          "snippet": "static void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_netdev_delete_by_name",
          "args": [
            "peer"
          ],
          "line": 2766
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_netdev_delete_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "295-304",
          "snippet": "int lxc_netdev_delete_by_name(const char *name)\n{\n\tint index;\n\n\tindex = if_nametoindex(name);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\treturn lxc_netdev_delete_by_index(index);\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_netdev_delete_by_name(const char *name)\n{\n\tint index;\n\n\tindex = if_nametoindex(name);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\treturn lxc_netdev_delete_by_index(index);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"instantiated macvlan '%s', index is '%d' and mode '%d'\"",
            "peer",
            "netdev->ifindex",
            "netdev->priv.macvlan_attr.mode"
          ],
          "line": 2761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run_script",
          "args": [
            "handler->name",
            "\"net\"",
            "netdev->upscript",
            "\"up\"",
            "\"macvlan\"",
            "netdev->link",
            "(char*) NULL"
          ],
          "line": 2755
        },
        "resolved": true,
        "details": {
          "function_name": "run_script",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "466-516",
          "snippet": "static int run_script(const char *name, const char *section, const char *script,\n\t\t      ...)\n{\n\tint ret;\n\tchar *buffer, *p;\n\tsize_t size = 0;\n\tva_list ap;\n\n\tINFO(\"Executing script \\\"%s\\\" for container \\\"%s\\\", config section \\\"%s\\\".\",\n\t     script, name, section);\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *)))\n\t\tsize += strlen(p) + 1;\n\tva_end(ap);\n\n\tsize += strlen(script);\n\tsize += strlen(name);\n\tsize += strlen(section);\n\tsize += 3;\n\n\tif (size > INT_MAX)\n\t\treturn -1;\n\n\tbuffer = alloca(size);\n\tif (!buffer) {\n\t\tERROR(\"Failed to allocate memory.\");\n\t\treturn -1;\n\t}\n\n\tret = snprintf(buffer, size, \"%s %s %s\", script, name, section);\n\tif (ret < 0 || ret >= size) {\n\t\tERROR(\"Script name too long.\");\n\t\treturn -1;\n\t}\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *))) {\n\t\tint len = size - ret;\n\t\tint rc;\n\t\trc = snprintf(buffer + ret, len, \" %s\", p);\n\t\tif (rc < 0 || rc >= len) {\n\t\t\tERROR(\"Script args too long.\");\n\t\t\treturn -1;\n\t\t}\n\t\tret += rc;\n\t}\n\tva_end(ap);\n\n\treturn run_buffer(buffer);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int run_script(const char *name, const char *section, const char *script,\n\t\t      ...)\n{\n\tint ret;\n\tchar *buffer, *p;\n\tsize_t size = 0;\n\tva_list ap;\n\n\tINFO(\"Executing script \\\"%s\\\" for container \\\"%s\\\", config section \\\"%s\\\".\",\n\t     script, name, section);\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *)))\n\t\tsize += strlen(p) + 1;\n\tva_end(ap);\n\n\tsize += strlen(script);\n\tsize += strlen(name);\n\tsize += strlen(section);\n\tsize += 3;\n\n\tif (size > INT_MAX)\n\t\treturn -1;\n\n\tbuffer = alloca(size);\n\tif (!buffer) {\n\t\tERROR(\"Failed to allocate memory.\");\n\t\treturn -1;\n\t}\n\n\tret = snprintf(buffer, size, \"%s %s %s\", script, name, section);\n\tif (ret < 0 || ret >= size) {\n\t\tERROR(\"Script name too long.\");\n\t\treturn -1;\n\t}\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *))) {\n\t\tint len = size - ret;\n\t\tint rc;\n\t\trc = snprintf(buffer + ret, len, \" %s\", p);\n\t\tif (rc < 0 || rc >= len) {\n\t\t\tERROR(\"Script args too long.\");\n\t\t\treturn -1;\n\t\t}\n\t\tret += rc;\n\t}\n\tva_end(ap);\n\n\treturn run_buffer(buffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to retrieve the index for %s\"",
            "peer"
          ],
          "line": 2750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_nametoindex",
          "args": [
            "peer"
          ],
          "line": 2748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to create macvlan interface '%s' on '%s' : %s\"",
            "peer",
            "netdev->link",
            "strerror(-err)"
          ],
          "line": 2743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "-err"
          ],
          "line": 2744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_macvlan_create",
          "args": [
            "netdev->link",
            "peer",
            "netdev->priv.macvlan_attr.mode"
          ],
          "line": 2740
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_macvlan_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "834-912",
          "snippet": "int lxc_macvlan_create(const char *master, const char *name, int mode)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tstruct rtattr *nest, *nest2;\n\tint index, len, err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tlen = strlen(master);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\tlen = strlen(name);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tindex = if_nametoindex(master);\n\tif (!index)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags =\n\t\tNLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL|NLM_F_ACK;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tifi->ifi_family = AF_UNSPEC;\n\n\tnest = nla_begin_nested(nlmsg, IFLA_LINKINFO);\n\tif (!nest)\n\t\tgoto out;\n\n\tif (nla_put_string(nlmsg, IFLA_INFO_KIND, \"macvlan\"))\n\t\tgoto out;\n\n\tif (mode) {\n\t\tnest2 = nla_begin_nested(nlmsg, IFLA_INFO_DATA);\n\t\tif (!nest2)\n\t\t\tgoto out;\n\n\t\tif (nla_put_u32(nlmsg, IFLA_MACVLAN_MODE, mode))\n\t\t\tgoto out;\n\n\t\tnla_end_nested(nlmsg, nest2);\n\t}\n\n\tnla_end_nested(nlmsg, nest);\n\n\tif (nla_put_u32(nlmsg, IFLA_LINK, index))\n\t\tgoto out;\n\n\tif (nla_put_string(nlmsg, IFLA_IFNAME, name))\n\t\tgoto out;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_macvlan_create(const char *master, const char *name, int mode)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tstruct rtattr *nest, *nest2;\n\tint index, len, err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tlen = strlen(master);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\tlen = strlen(name);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tindex = if_nametoindex(master);\n\tif (!index)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags =\n\t\tNLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL|NLM_F_ACK;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tifi->ifi_family = AF_UNSPEC;\n\n\tnest = nla_begin_nested(nlmsg, IFLA_LINKINFO);\n\tif (!nest)\n\t\tgoto out;\n\n\tif (nla_put_string(nlmsg, IFLA_INFO_KIND, \"macvlan\"))\n\t\tgoto out;\n\n\tif (mode) {\n\t\tnest2 = nla_begin_nested(nlmsg, IFLA_INFO_DATA);\n\t\tif (!nest2)\n\t\t\tgoto out;\n\n\t\tif (nla_put_u32(nlmsg, IFLA_MACVLAN_MODE, mode))\n\t\t\tgoto out;\n\n\t\tnla_end_nested(nlmsg, nest2);\n\t}\n\n\tnla_end_nested(nlmsg, nest);\n\n\tif (nla_put_u32(nlmsg, IFLA_LINK, index))\n\t\tgoto out;\n\n\tif (nla_put_string(nlmsg, IFLA_IFNAME, name))\n\t\tgoto out;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to make a temporary name\""
          ],
          "line": 2736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_mkifname",
          "args": [
            "peerbuf"
          ],
          "line": 2734
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_mkifname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "1507-1566",
          "snippet": "char *lxc_mkifname(char *template)\n{\n\tchar *name = NULL;\n\tsize_t i = 0;\n\tFILE *urandom;\n\tunsigned int seed;\n\tstruct ifaddrs *ifaddr, *ifa;\n\tint ifexists = 0;\n\n\t/* Get all the network interfaces */\n\tgetifaddrs(&ifaddr);\n\n\t/* Initialize the random number generator */\n\turandom = fopen (\"/dev/urandom\", \"r\");\n\tif (urandom != NULL) {\n\t\tif (fread (&seed, sizeof(seed), 1, urandom) <= 0)\n\t\t\tseed = time(0);\n\t\tfclose(urandom);\n\t}\n\telse\n\t\tseed = time(0);\n\n#ifndef HAVE_RAND_R\n\tsrand(seed);\n#endif\n\n\t/* Generate random names until we find one that doesn't exist */\n\twhile(1) {\n\t\tifexists = 0;\n\t\tname = strdup(template);\n\n\t\tif (name == NULL)\n\t\t\treturn NULL;\n\n\t\tfor (i = 0; i < strlen(name); i++) {\n\t\t\tif (name[i] == 'X') {\n#ifdef HAVE_RAND_R\n\t\t\t\tname[i] = padchar[rand_r(&seed) % (strlen(padchar) - 1)];\n#else\n\t\t\t\tname[i] = padchar[rand() % (strlen(padchar) - 1)];\n#endif\n\t\t\t}\n\t\t}\n\n\t\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n\t\t\tif (strcmp(ifa->ifa_name, name) == 0) {\n\t\t\t\tifexists = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ifexists == 0)\n\t\t\tbreak;\n\n\t\tfree(name);\n\t}\n\n\tfreeifaddrs(ifaddr);\n\treturn name;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char padchar[] =\n\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic const char padchar[] =\n\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\nchar *lxc_mkifname(char *template)\n{\n\tchar *name = NULL;\n\tsize_t i = 0;\n\tFILE *urandom;\n\tunsigned int seed;\n\tstruct ifaddrs *ifaddr, *ifa;\n\tint ifexists = 0;\n\n\t/* Get all the network interfaces */\n\tgetifaddrs(&ifaddr);\n\n\t/* Initialize the random number generator */\n\turandom = fopen (\"/dev/urandom\", \"r\");\n\tif (urandom != NULL) {\n\t\tif (fread (&seed, sizeof(seed), 1, urandom) <= 0)\n\t\t\tseed = time(0);\n\t\tfclose(urandom);\n\t}\n\telse\n\t\tseed = time(0);\n\n#ifndef HAVE_RAND_R\n\tsrand(seed);\n#endif\n\n\t/* Generate random names until we find one that doesn't exist */\n\twhile(1) {\n\t\tifexists = 0;\n\t\tname = strdup(template);\n\n\t\tif (name == NULL)\n\t\t\treturn NULL;\n\n\t\tfor (i = 0; i < strlen(name); i++) {\n\t\t\tif (name[i] == 'X') {\n#ifdef HAVE_RAND_R\n\t\t\t\tname[i] = padchar[rand_r(&seed) % (strlen(padchar) - 1)];\n#else\n\t\t\t\tname[i] = padchar[rand() % (strlen(padchar) - 1)];\n#endif\n\t\t\t}\n\t\t}\n\n\t\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n\t\t\tif (strcmp(ifa->ifa_name, name) == 0) {\n\t\t\t\tifexists = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ifexists == 0)\n\t\t\tbreak;\n\n\t\tfree(name);\n\t}\n\n\tfreeifaddrs(ifaddr);\n\treturn name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "peerbuf",
            "sizeof(peerbuf)",
            "\"mcXXXXXX\""
          ],
          "line": 2730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"no link specified for macvlan netdev\""
          ],
          "line": 2726
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_none(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_none(struct lxc_handler *, struct lxc_netdev *);\n\nstatic int instantiate_macvlan(struct lxc_handler *handler, struct lxc_netdev *netdev)\n{\n\tchar peerbuf[IFNAMSIZ], *peer;\n\tint err;\n\n\tif (!netdev->link) {\n\t\tERROR(\"no link specified for macvlan netdev\");\n\t\treturn -1;\n\t}\n\n\terr = snprintf(peerbuf, sizeof(peerbuf), \"mcXXXXXX\");\n\tif (err >= sizeof(peerbuf))\n\t\treturn -1;\n\n\tpeer = lxc_mkifname(peerbuf);\n\tif (!peer) {\n\t\tERROR(\"failed to make a temporary name\");\n\t\treturn -1;\n\t}\n\n\terr = lxc_macvlan_create(netdev->link, peer,\n\t\t\t\t netdev->priv.macvlan_attr.mode);\n\tif (err) {\n\t\tERROR(\"failed to create macvlan interface '%s' on '%s' : %s\",\n\t\t      peer, netdev->link, strerror(-err));\n\t\tgoto out;\n\t}\n\n\tnetdev->ifindex = if_nametoindex(peer);\n\tif (!netdev->ifindex) {\n\t\tERROR(\"failed to retrieve the index for %s\", peer);\n\t\tgoto out;\n\t}\n\n\tif (netdev->upscript) {\n\t\terr = run_script(handler->name, \"net\", netdev->upscript, \"up\",\n\t\t\t\t \"macvlan\", netdev->link, (char*) NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tDEBUG(\"instantiated macvlan '%s', index is '%d' and mode '%d'\",\n\t      peer, netdev->ifindex, netdev->priv.macvlan_attr.mode);\n\n\treturn 0;\nout:\n\tlxc_netdev_delete_by_name(peer);\n\tfree(peer);\n\treturn -1;\n}"
  },
  {
    "function_name": "shutdown_veth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "2701-2718",
    "snippet": "static int shutdown_veth(struct lxc_handler *handler, struct lxc_netdev *netdev)\n{\n\tchar *veth1;\n\tint err;\n\n\tif (netdev->priv.veth_attr.pair)\n\t\tveth1 = netdev->priv.veth_attr.pair;\n\telse\n\t\tveth1 = netdev->priv.veth_attr.veth1;\n\n\tif (netdev->downscript) {\n\t\terr = run_script(handler->name, \"net\", netdev->downscript,\n\t\t\t\t \"down\", \"veth\", veth1, (char*) NULL);\n\t\tif (err)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_none(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_none(struct lxc_handler *, struct lxc_netdev *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "run_script",
          "args": [
            "handler->name",
            "\"net\"",
            "netdev->downscript",
            "\"down\"",
            "\"veth\"",
            "veth1",
            "(char*) NULL"
          ],
          "line": 2712
        },
        "resolved": true,
        "details": {
          "function_name": "run_script",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "466-516",
          "snippet": "static int run_script(const char *name, const char *section, const char *script,\n\t\t      ...)\n{\n\tint ret;\n\tchar *buffer, *p;\n\tsize_t size = 0;\n\tva_list ap;\n\n\tINFO(\"Executing script \\\"%s\\\" for container \\\"%s\\\", config section \\\"%s\\\".\",\n\t     script, name, section);\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *)))\n\t\tsize += strlen(p) + 1;\n\tva_end(ap);\n\n\tsize += strlen(script);\n\tsize += strlen(name);\n\tsize += strlen(section);\n\tsize += 3;\n\n\tif (size > INT_MAX)\n\t\treturn -1;\n\n\tbuffer = alloca(size);\n\tif (!buffer) {\n\t\tERROR(\"Failed to allocate memory.\");\n\t\treturn -1;\n\t}\n\n\tret = snprintf(buffer, size, \"%s %s %s\", script, name, section);\n\tif (ret < 0 || ret >= size) {\n\t\tERROR(\"Script name too long.\");\n\t\treturn -1;\n\t}\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *))) {\n\t\tint len = size - ret;\n\t\tint rc;\n\t\trc = snprintf(buffer + ret, len, \" %s\", p);\n\t\tif (rc < 0 || rc >= len) {\n\t\t\tERROR(\"Script args too long.\");\n\t\t\treturn -1;\n\t\t}\n\t\tret += rc;\n\t}\n\tva_end(ap);\n\n\treturn run_buffer(buffer);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int run_script(const char *name, const char *section, const char *script,\n\t\t      ...)\n{\n\tint ret;\n\tchar *buffer, *p;\n\tsize_t size = 0;\n\tva_list ap;\n\n\tINFO(\"Executing script \\\"%s\\\" for container \\\"%s\\\", config section \\\"%s\\\".\",\n\t     script, name, section);\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *)))\n\t\tsize += strlen(p) + 1;\n\tva_end(ap);\n\n\tsize += strlen(script);\n\tsize += strlen(name);\n\tsize += strlen(section);\n\tsize += 3;\n\n\tif (size > INT_MAX)\n\t\treturn -1;\n\n\tbuffer = alloca(size);\n\tif (!buffer) {\n\t\tERROR(\"Failed to allocate memory.\");\n\t\treturn -1;\n\t}\n\n\tret = snprintf(buffer, size, \"%s %s %s\", script, name, section);\n\tif (ret < 0 || ret >= size) {\n\t\tERROR(\"Script name too long.\");\n\t\treturn -1;\n\t}\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *))) {\n\t\tint len = size - ret;\n\t\tint rc;\n\t\trc = snprintf(buffer + ret, len, \" %s\", p);\n\t\tif (rc < 0 || rc >= len) {\n\t\t\tERROR(\"Script args too long.\");\n\t\t\treturn -1;\n\t\t}\n\t\tret += rc;\n\t}\n\tva_end(ap);\n\n\treturn run_buffer(buffer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_none(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_none(struct lxc_handler *, struct lxc_netdev *);\n\nstatic int shutdown_veth(struct lxc_handler *handler, struct lxc_netdev *netdev)\n{\n\tchar *veth1;\n\tint err;\n\n\tif (netdev->priv.veth_attr.pair)\n\t\tveth1 = netdev->priv.veth_attr.pair;\n\telse\n\t\tveth1 = netdev->priv.veth_attr.veth1;\n\n\tif (netdev->downscript) {\n\t\terr = run_script(handler->name, \"net\", netdev->downscript,\n\t\t\t\t \"down\", \"veth\", veth1, (char*) NULL);\n\t\tif (err)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "instantiate_veth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "2582-2699",
    "snippet": "static int instantiate_veth(struct lxc_handler *handler, struct lxc_netdev *netdev)\n{\n\tchar veth1buf[IFNAMSIZ], *veth1;\n\tchar veth2buf[IFNAMSIZ], *veth2;\n\tint bridge_index, err;\n\tunsigned int mtu = 0;\n\n\tif (netdev->priv.veth_attr.pair) {\n\t\tveth1 = netdev->priv.veth_attr.pair;\n\t\tif (handler->conf->reboot)\n\t\t\tlxc_netdev_delete_by_name(veth1);\n\t} else {\n\t\terr = snprintf(veth1buf, sizeof(veth1buf), \"vethXXXXXX\");\n\t\tif (err >= sizeof(veth1buf)) { /* can't *really* happen, but... */\n\t\t\tERROR(\"veth1 name too long\");\n\t\t\treturn -1;\n\t\t}\n\t\tveth1 = lxc_mkifname(veth1buf);\n\t\tif (!veth1) {\n\t\t\tERROR(\"failed to allocate a temporary name\");\n\t\t\treturn -1;\n\t\t}\n\t\t/* store away for deconf */\n\t\tmemcpy(netdev->priv.veth_attr.veth1, veth1, IFNAMSIZ);\n\t}\n\n\tsnprintf(veth2buf, sizeof(veth2buf), \"vethXXXXXX\");\n\tveth2 = lxc_mkifname(veth2buf);\n\tif (!veth2) {\n\t\tERROR(\"failed to allocate a temporary name\");\n\t\tgoto out_delete;\n\t}\n\n\terr = lxc_veth_create(veth1, veth2);\n\tif (err) {\n\t\tERROR(\"failed to create veth pair (%s and %s): %s\", veth1, veth2,\n\t\t      strerror(-err));\n\t\tgoto out_delete;\n\t}\n\n\t/* changing the high byte of the mac address to 0xfe, the bridge interface\n\t * will always keep the host's mac address and not take the mac address\n\t * of a container */\n\terr = setup_private_host_hw_addr(veth1);\n\tif (err) {\n\t\tERROR(\"failed to change mac address of host interface '%s': %s\",\n\t\t\tveth1, strerror(-err));\n\t\tgoto out_delete;\n\t}\n\n\tnetdev->ifindex = if_nametoindex(veth2);\n\tif (!netdev->ifindex) {\n\t\tERROR(\"failed to retrieve the index for %s\", veth2);\n\t\tgoto out_delete;\n\t}\n\n\tif (netdev->mtu) {\n\t\tif (lxc_safe_uint(netdev->mtu, &mtu) < 0)\n\t\t\tWARN(\"Failed to parse mtu from.\");\n\t\telse\n\t\t\tINFO(\"Retrieved mtu %d\", mtu);\n\t} else if (netdev->link) {\n\t\tbridge_index = if_nametoindex(netdev->link);\n\t\tif (bridge_index) {\n\t\t\tmtu = netdev_get_mtu(bridge_index);\n\t\t\tINFO(\"Retrieved mtu %d from %s\", mtu, netdev->link);\n\t\t} else {\n\t\t\tmtu = netdev_get_mtu(netdev->ifindex);\n\t\t\tINFO(\"Retrieved mtu %d from %s\", mtu, veth2);\n\t\t}\n\t}\n\n\tif (mtu) {\n\t\terr = lxc_netdev_set_mtu(veth1, mtu);\n\t\tif (!err)\n\t\t\terr = lxc_netdev_set_mtu(veth2, mtu);\n\t\tif (err) {\n\t\t\tERROR(\"failed to set mtu '%i' for veth pair (%s and %s): %s\",\n\t\t\t      mtu, veth1, veth2, strerror(-err));\n\t\t\tgoto out_delete;\n\t\t}\n\t}\n\n\tif (netdev->link) {\n\t\terr = lxc_bridge_attach(handler->lxcpath, handler->name, netdev->link, veth1);\n\t\tif (err) {\n\t\t\tERROR(\"failed to attach '%s' to the bridge '%s': %s\",\n\t\t\t\t      veth1, netdev->link, strerror(-err));\n\t\t\tgoto out_delete;\n\t\t}\n\t\tINFO(\"Attached '%s': to the bridge '%s': \", veth1, netdev->link);\n\t}\n\n\terr = lxc_netdev_up(veth1);\n\tif (err) {\n\t\tERROR(\"failed to set %s up : %s\", veth1, strerror(-err));\n\t\tgoto out_delete;\n\t}\n\n\tif (netdev->upscript) {\n\t\terr = run_script(handler->name, \"net\", netdev->upscript, \"up\",\n\t\t\t\t \"veth\", veth1, (char*) NULL);\n\t\tif (err)\n\t\t\tgoto out_delete;\n\t}\n\n\tDEBUG(\"instantiated veth '%s/%s', index is '%d'\",\n\t      veth1, veth2, netdev->ifindex);\n\n\treturn 0;\n\nout_delete:\n\tlxc_netdev_delete_by_name(veth1);\n\tif (!netdev->priv.veth_attr.pair)\n\t\tfree(veth1);\n\tfree(veth2);\n\treturn -1;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_none(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_none(struct lxc_handler *, struct lxc_netdev *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "veth2"
          ],
          "line": 2697
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4619-4628",
          "snippet": "static void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_netdev_delete_by_name",
          "args": [
            "veth1"
          ],
          "line": 2694
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_netdev_delete_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "295-304",
          "snippet": "int lxc_netdev_delete_by_name(const char *name)\n{\n\tint index;\n\n\tindex = if_nametoindex(name);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\treturn lxc_netdev_delete_by_index(index);\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_netdev_delete_by_name(const char *name)\n{\n\tint index;\n\n\tindex = if_nametoindex(name);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\treturn lxc_netdev_delete_by_index(index);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"instantiated veth '%s/%s', index is '%d'\"",
            "veth1",
            "veth2",
            "netdev->ifindex"
          ],
          "line": 2688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run_script",
          "args": [
            "handler->name",
            "\"net\"",
            "netdev->upscript",
            "\"up\"",
            "\"veth\"",
            "veth1",
            "(char*) NULL"
          ],
          "line": 2682
        },
        "resolved": true,
        "details": {
          "function_name": "run_script",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "466-516",
          "snippet": "static int run_script(const char *name, const char *section, const char *script,\n\t\t      ...)\n{\n\tint ret;\n\tchar *buffer, *p;\n\tsize_t size = 0;\n\tva_list ap;\n\n\tINFO(\"Executing script \\\"%s\\\" for container \\\"%s\\\", config section \\\"%s\\\".\",\n\t     script, name, section);\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *)))\n\t\tsize += strlen(p) + 1;\n\tva_end(ap);\n\n\tsize += strlen(script);\n\tsize += strlen(name);\n\tsize += strlen(section);\n\tsize += 3;\n\n\tif (size > INT_MAX)\n\t\treturn -1;\n\n\tbuffer = alloca(size);\n\tif (!buffer) {\n\t\tERROR(\"Failed to allocate memory.\");\n\t\treturn -1;\n\t}\n\n\tret = snprintf(buffer, size, \"%s %s %s\", script, name, section);\n\tif (ret < 0 || ret >= size) {\n\t\tERROR(\"Script name too long.\");\n\t\treturn -1;\n\t}\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *))) {\n\t\tint len = size - ret;\n\t\tint rc;\n\t\trc = snprintf(buffer + ret, len, \" %s\", p);\n\t\tif (rc < 0 || rc >= len) {\n\t\t\tERROR(\"Script args too long.\");\n\t\t\treturn -1;\n\t\t}\n\t\tret += rc;\n\t}\n\tva_end(ap);\n\n\treturn run_buffer(buffer);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int run_script(const char *name, const char *section, const char *script,\n\t\t      ...)\n{\n\tint ret;\n\tchar *buffer, *p;\n\tsize_t size = 0;\n\tva_list ap;\n\n\tINFO(\"Executing script \\\"%s\\\" for container \\\"%s\\\", config section \\\"%s\\\".\",\n\t     script, name, section);\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *)))\n\t\tsize += strlen(p) + 1;\n\tva_end(ap);\n\n\tsize += strlen(script);\n\tsize += strlen(name);\n\tsize += strlen(section);\n\tsize += 3;\n\n\tif (size > INT_MAX)\n\t\treturn -1;\n\n\tbuffer = alloca(size);\n\tif (!buffer) {\n\t\tERROR(\"Failed to allocate memory.\");\n\t\treturn -1;\n\t}\n\n\tret = snprintf(buffer, size, \"%s %s %s\", script, name, section);\n\tif (ret < 0 || ret >= size) {\n\t\tERROR(\"Script name too long.\");\n\t\treturn -1;\n\t}\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *))) {\n\t\tint len = size - ret;\n\t\tint rc;\n\t\trc = snprintf(buffer + ret, len, \" %s\", p);\n\t\tif (rc < 0 || rc >= len) {\n\t\t\tERROR(\"Script args too long.\");\n\t\t\treturn -1;\n\t\t}\n\t\tret += rc;\n\t}\n\tva_end(ap);\n\n\treturn run_buffer(buffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to set %s up : %s\"",
            "veth1",
            "strerror(-err)"
          ],
          "line": 2677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "-err"
          ],
          "line": 2677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_netdev_up",
          "args": [
            "veth1"
          ],
          "line": 2675
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_netdev_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "662-665",
          "snippet": "int lxc_netdev_up(const char *name)\n{\n\treturn netdev_set_flag(name, IFF_UP);\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_netdev_up(const char *name)\n{\n\treturn netdev_set_flag(name, IFF_UP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Attached '%s': to the bridge '%s': \"",
            "veth1",
            "netdev->link"
          ],
          "line": 2672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to attach '%s' to the bridge '%s': %s\"",
            "veth1",
            "netdev->link",
            "strerror(-err)"
          ],
          "line": 2668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "-err"
          ],
          "line": 2669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_bridge_attach",
          "args": [
            "handler->lxcpath",
            "handler->name",
            "netdev->link",
            "veth1"
          ],
          "line": 2666
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_bridge_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "1458-1486",
          "snippet": "int lxc_bridge_attach(const char *lxcpath, const char *name, const char *bridge, const char *ifname)\n{\n\tint fd, index, err;\n\tstruct ifreq ifr;\n\n\tif (strlen(ifname) >= IFNAMSIZ)\n\t\treturn -EINVAL;\n\n\tindex = if_nametoindex(ifname);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\tif (is_ovs_bridge(bridge))\n\t\treturn attach_to_ovs_bridge(lxcpath, name, bridge, ifname);\n\n\tfd = socket(AF_INET, SOCK_STREAM, 0);\n\tif (fd < 0)\n\t\treturn -errno;\n\n\tstrncpy(ifr.ifr_name, bridge, IFNAMSIZ-1);\n\tifr.ifr_name[IFNAMSIZ-1] = '\\0';\n\tifr.ifr_ifindex = index;\n\terr = ioctl(fd, SIOCBRADDIF, &ifr);\n\tclose(fd);\n\tif (err)\n\t\terr = -errno;\n\n\treturn err;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_bridge_attach(const char *lxcpath, const char *name, const char *bridge, const char *ifname)\n{\n\tint fd, index, err;\n\tstruct ifreq ifr;\n\n\tif (strlen(ifname) >= IFNAMSIZ)\n\t\treturn -EINVAL;\n\n\tindex = if_nametoindex(ifname);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\tif (is_ovs_bridge(bridge))\n\t\treturn attach_to_ovs_bridge(lxcpath, name, bridge, ifname);\n\n\tfd = socket(AF_INET, SOCK_STREAM, 0);\n\tif (fd < 0)\n\t\treturn -errno;\n\n\tstrncpy(ifr.ifr_name, bridge, IFNAMSIZ-1);\n\tifr.ifr_name[IFNAMSIZ-1] = '\\0';\n\tifr.ifr_ifindex = index;\n\terr = ioctl(fd, SIOCBRADDIF, &ifr);\n\tclose(fd);\n\tif (err)\n\t\terr = -errno;\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to set mtu '%i' for veth pair (%s and %s): %s\"",
            "mtu",
            "veth1",
            "veth2",
            "strerror(-err)"
          ],
          "line": 2659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "-err"
          ],
          "line": 2660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_netdev_set_mtu",
          "args": [
            "veth2",
            "mtu"
          ],
          "line": 2657
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_netdev_set_mtu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "610-660",
          "snippet": "int lxc_netdev_set_mtu(const char *name, int mtu)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tint index, len, err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tlen = strlen(name);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tindex = if_nametoindex(name);\n\tif (!index)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_REQUEST|NLM_F_ACK;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tifi->ifi_family = AF_UNSPEC;\n\tifi->ifi_index = index;\n\n\tif (nla_put_u32(nlmsg, IFLA_MTU, mtu))\n\t\tgoto out;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(nlmsg);\n\tnlmsg_free(answer);\n\treturn err;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_netdev_set_mtu(const char *name, int mtu)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tint index, len, err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tlen = strlen(name);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tindex = if_nametoindex(name);\n\tif (!index)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_REQUEST|NLM_F_ACK;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tifi->ifi_family = AF_UNSPEC;\n\tifi->ifi_index = index;\n\n\tif (nla_put_u32(nlmsg, IFLA_MTU, mtu))\n\t\tgoto out;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(nlmsg);\n\tnlmsg_free(answer);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Retrieved mtu %d from %s\"",
            "mtu",
            "veth2"
          ],
          "line": 2650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netdev_get_mtu",
          "args": [
            "netdev->ifindex"
          ],
          "line": 2649
        },
        "resolved": true,
        "details": {
          "function_name": "netdev_get_mtu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "499-608",
          "snippet": "int netdev_get_mtu(int ifindex)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tstruct nlmsghdr *msg;\n\tint err, res;\n\tint recv_len = 0, answer_len;\n\tint readmore = 0;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\t/* Save the answer buffer length, since it will be overwritten\n\t * on the first receive (and we might need to receive more than\n\t * once. */\n\tanswer_len = answer->nlmsghdr->nlmsg_len;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_REQUEST|NLM_F_DUMP;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_GETLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi)\n\t\tgoto out;\n\tifi->ifi_family = AF_UNSPEC;\n\n\t/* Send the request for addresses, which returns all addresses\n\t * on all interfaces. */\n\terr = netlink_send(&nlh, nlmsg);\n\tif (err < 0)\n\t\tgoto out;\n\n\tdo {\n\t\t/* Restore the answer buffer length, it might have been\n\t\t * overwritten by a previous receive. */\n\t\tanswer->nlmsghdr->nlmsg_len = answer_len;\n\n\t\t/* Get the (next) batch of reply messages */\n\t\terr = netlink_rcv(&nlh, answer);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t\trecv_len = err;\n\t\terr = 0;\n\n\t\t/* Satisfy the typing for the netlink macros */\n\t\tmsg = answer->nlmsghdr;\n\n\t\twhile (NLMSG_OK(msg, recv_len)) {\n\n\t\t\t/* Stop reading if we see an error message */\n\t\t\tif (msg->nlmsg_type == NLMSG_ERROR) {\n\t\t\t\tstruct nlmsgerr *errmsg = (struct nlmsgerr*)NLMSG_DATA(msg);\n\t\t\t\terr = errmsg->error;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* Stop reading if we see a NLMSG_DONE message */\n\t\t\tif (msg->nlmsg_type == NLMSG_DONE) {\n\t\t\t\treadmore = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tifi = NLMSG_DATA(msg);\n\t\t\tif (ifi->ifi_index == ifindex) {\n\t\t\t\tstruct rtattr *rta = IFLA_RTA(ifi);\n\t\t\t\tint attr_len = msg->nlmsg_len - NLMSG_LENGTH(sizeof(*ifi));\n\t\t\t\tres = 0;\n\t\t\t\twhile(RTA_OK(rta, attr_len)) {\n\t\t\t\t\t/* Found a local address for the requested interface,\n\t\t\t\t\t * return it. */\n\t\t\t\t\tif (rta->rta_type == IFLA_MTU) {\n\t\t\t\t\t\tmemcpy(&res, RTA_DATA(rta), sizeof(int));\n\t\t\t\t\t\terr = res;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\trta = RTA_NEXT(rta, attr_len);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/* Keep reading more data from the socket if the\n\t\t\t * last message had the NLF_F_MULTI flag set */\n\t\t\treadmore = (msg->nlmsg_flags & NLM_F_MULTI);\n\n\t\t\t/* Look at the next message received in this buffer */\n\t\t\tmsg = NLMSG_NEXT(msg, recv_len);\n\t\t}\n\t} while (readmore);\n\n\t/* If we end up here, we didn't find any result, so signal an\n\t * error */\n\terr = -1;\n\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint netdev_get_mtu(int ifindex)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tstruct nlmsghdr *msg;\n\tint err, res;\n\tint recv_len = 0, answer_len;\n\tint readmore = 0;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\t/* Save the answer buffer length, since it will be overwritten\n\t * on the first receive (and we might need to receive more than\n\t * once. */\n\tanswer_len = answer->nlmsghdr->nlmsg_len;\n\n\tnlmsg->nlmsghdr->nlmsg_flags = NLM_F_REQUEST|NLM_F_DUMP;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_GETLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi)\n\t\tgoto out;\n\tifi->ifi_family = AF_UNSPEC;\n\n\t/* Send the request for addresses, which returns all addresses\n\t * on all interfaces. */\n\terr = netlink_send(&nlh, nlmsg);\n\tif (err < 0)\n\t\tgoto out;\n\n\tdo {\n\t\t/* Restore the answer buffer length, it might have been\n\t\t * overwritten by a previous receive. */\n\t\tanswer->nlmsghdr->nlmsg_len = answer_len;\n\n\t\t/* Get the (next) batch of reply messages */\n\t\terr = netlink_rcv(&nlh, answer);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t\trecv_len = err;\n\t\terr = 0;\n\n\t\t/* Satisfy the typing for the netlink macros */\n\t\tmsg = answer->nlmsghdr;\n\n\t\twhile (NLMSG_OK(msg, recv_len)) {\n\n\t\t\t/* Stop reading if we see an error message */\n\t\t\tif (msg->nlmsg_type == NLMSG_ERROR) {\n\t\t\t\tstruct nlmsgerr *errmsg = (struct nlmsgerr*)NLMSG_DATA(msg);\n\t\t\t\terr = errmsg->error;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* Stop reading if we see a NLMSG_DONE message */\n\t\t\tif (msg->nlmsg_type == NLMSG_DONE) {\n\t\t\t\treadmore = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tifi = NLMSG_DATA(msg);\n\t\t\tif (ifi->ifi_index == ifindex) {\n\t\t\t\tstruct rtattr *rta = IFLA_RTA(ifi);\n\t\t\t\tint attr_len = msg->nlmsg_len - NLMSG_LENGTH(sizeof(*ifi));\n\t\t\t\tres = 0;\n\t\t\t\twhile(RTA_OK(rta, attr_len)) {\n\t\t\t\t\t/* Found a local address for the requested interface,\n\t\t\t\t\t * return it. */\n\t\t\t\t\tif (rta->rta_type == IFLA_MTU) {\n\t\t\t\t\t\tmemcpy(&res, RTA_DATA(rta), sizeof(int));\n\t\t\t\t\t\terr = res;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\trta = RTA_NEXT(rta, attr_len);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/* Keep reading more data from the socket if the\n\t\t\t * last message had the NLF_F_MULTI flag set */\n\t\t\treadmore = (msg->nlmsg_flags & NLM_F_MULTI);\n\n\t\t\t/* Look at the next message received in this buffer */\n\t\t\tmsg = NLMSG_NEXT(msg, recv_len);\n\t\t}\n\t} while (readmore);\n\n\t/* If we end up here, we didn't find any result, so signal an\n\t * error */\n\terr = -1;\n\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Retrieved mtu %d from %s\"",
            "mtu",
            "netdev->link"
          ],
          "line": 2647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_nametoindex",
          "args": [
            "netdev->link"
          ],
          "line": 2644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Retrieved mtu %d\"",
            "mtu"
          ],
          "line": 2642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to parse mtu from.\""
          ],
          "line": 2640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_safe_uint",
          "args": [
            "netdev->mtu",
            "&mtu"
          ],
          "line": 2639
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_safe_uint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1985-2003",
          "snippet": "int lxc_safe_uint(const char *numstr, unsigned int *converted)\n{\n\tchar *err = NULL;\n\tunsigned long int uli;\n\n\terrno = 0;\n\tuli = strtoul(numstr, &err, 0);\n\tif (errno > 0)\n\t\treturn -errno;\n\n\tif (!err || err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\n\tif (uli > UINT_MAX)\n\t\treturn -ERANGE;\n\n\t*converted = (unsigned int)uli;\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_safe_uint(const char *numstr, unsigned int *converted)\n{\n\tchar *err = NULL;\n\tunsigned long int uli;\n\n\terrno = 0;\n\tuli = strtoul(numstr, &err, 0);\n\tif (errno > 0)\n\t\treturn -errno;\n\n\tif (!err || err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\n\tif (uli > UINT_MAX)\n\t\treturn -ERANGE;\n\n\t*converted = (unsigned int)uli;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to retrieve the index for %s\"",
            "veth2"
          ],
          "line": 2634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_nametoindex",
          "args": [
            "veth2"
          ],
          "line": 2632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to change mac address of host interface '%s': %s\"",
            "veth1",
            "strerror(-err)"
          ],
          "line": 2627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "-err"
          ],
          "line": 2628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_private_host_hw_addr",
          "args": [
            "veth1"
          ],
          "line": 2625
        },
        "resolved": true,
        "details": {
          "function_name": "setup_private_host_hw_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "1568-1592",
          "snippet": "int setup_private_host_hw_addr(char *veth1)\n{\n\tstruct ifreq ifr;\n\tint err;\n\tint sockfd;\n\n\tsockfd = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (sockfd < 0)\n\t\treturn -errno;\n\n\tsnprintf((char *)ifr.ifr_name, IFNAMSIZ, \"%s\", veth1);\n\terr = ioctl(sockfd, SIOCGIFHWADDR, &ifr);\n\tif (err < 0) {\n\t\tclose(sockfd);\n\t\treturn -errno;\n\t}\n\n\tifr.ifr_hwaddr.sa_data[0] = 0xfe;\n\terr = ioctl(sockfd, SIOCSIFHWADDR, &ifr);\n\tclose(sockfd);\n\tif (err < 0)\n\t\treturn -errno;\n\n\treturn 0;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint setup_private_host_hw_addr(char *veth1)\n{\n\tstruct ifreq ifr;\n\tint err;\n\tint sockfd;\n\n\tsockfd = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (sockfd < 0)\n\t\treturn -errno;\n\n\tsnprintf((char *)ifr.ifr_name, IFNAMSIZ, \"%s\", veth1);\n\terr = ioctl(sockfd, SIOCGIFHWADDR, &ifr);\n\tif (err < 0) {\n\t\tclose(sockfd);\n\t\treturn -errno;\n\t}\n\n\tifr.ifr_hwaddr.sa_data[0] = 0xfe;\n\terr = ioctl(sockfd, SIOCSIFHWADDR, &ifr);\n\tclose(sockfd);\n\tif (err < 0)\n\t\treturn -errno;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to create veth pair (%s and %s): %s\"",
            "veth1",
            "veth2",
            "strerror(-err)"
          ],
          "line": 2617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "-err"
          ],
          "line": 2618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_veth_create",
          "args": [
            "veth1",
            "veth2"
          ],
          "line": 2615
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_veth_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "672-751",
          "snippet": "int lxc_veth_create(const char *name1, const char *name2)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tstruct rtattr *nest1, *nest2, *nest3;\n\tint len, err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tlen = strlen(name1);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\tlen = strlen(name2);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags =\n\t\tNLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL|NLM_F_ACK;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi)\n\t\tgoto out;\n\tifi->ifi_family = AF_UNSPEC;\n\n\terr = -EINVAL;\n\tnest1 = nla_begin_nested(nlmsg, IFLA_LINKINFO);\n\tif (!nest1)\n\t\tgoto out;\n\n\tif (nla_put_string(nlmsg, IFLA_INFO_KIND, \"veth\"))\n\t\tgoto out;\n\n\tnest2 = nla_begin_nested(nlmsg, IFLA_INFO_DATA);\n\tif (!nest2)\n\t\tgoto out;\n\n\tnest3 = nla_begin_nested(nlmsg, VETH_INFO_PEER);\n\tif (!nest3)\n\t\tgoto out;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (nla_put_string(nlmsg, IFLA_IFNAME, name2))\n\t\tgoto out;\n\n\tnla_end_nested(nlmsg, nest3);\n\n\tnla_end_nested(nlmsg, nest2);\n\n\tnla_end_nested(nlmsg, nest1);\n\n\tif (nla_put_string(nlmsg, IFLA_IFNAME, name1))\n\t\tgoto out;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_veth_create(const char *name1, const char *name2)\n{\n\tstruct nl_handler nlh;\n\tstruct nlmsg *nlmsg = NULL, *answer = NULL;\n\tstruct ifinfomsg *ifi;\n\tstruct rtattr *nest1, *nest2, *nest3;\n\tint len, err;\n\n\terr = netlink_open(&nlh, NETLINK_ROUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tlen = strlen(name1);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\tlen = strlen(name2);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tnlmsg = nlmsg_alloc(NLMSG_GOOD_SIZE);\n\tif (!nlmsg)\n\t\tgoto out;\n\n\tanswer = nlmsg_alloc_reserve(NLMSG_GOOD_SIZE);\n\tif (!answer)\n\t\tgoto out;\n\n\tnlmsg->nlmsghdr->nlmsg_flags =\n\t\tNLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL|NLM_F_ACK;\n\tnlmsg->nlmsghdr->nlmsg_type = RTM_NEWLINK;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi)\n\t\tgoto out;\n\tifi->ifi_family = AF_UNSPEC;\n\n\terr = -EINVAL;\n\tnest1 = nla_begin_nested(nlmsg, IFLA_LINKINFO);\n\tif (!nest1)\n\t\tgoto out;\n\n\tif (nla_put_string(nlmsg, IFLA_INFO_KIND, \"veth\"))\n\t\tgoto out;\n\n\tnest2 = nla_begin_nested(nlmsg, IFLA_INFO_DATA);\n\tif (!nest2)\n\t\tgoto out;\n\n\tnest3 = nla_begin_nested(nlmsg, VETH_INFO_PEER);\n\tif (!nest3)\n\t\tgoto out;\n\n\tifi = nlmsg_reserve(nlmsg, sizeof(struct ifinfomsg));\n\tif (!ifi) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (nla_put_string(nlmsg, IFLA_IFNAME, name2))\n\t\tgoto out;\n\n\tnla_end_nested(nlmsg, nest3);\n\n\tnla_end_nested(nlmsg, nest2);\n\n\tnla_end_nested(nlmsg, nest1);\n\n\tif (nla_put_string(nlmsg, IFLA_IFNAME, name1))\n\t\tgoto out;\n\n\terr = netlink_transaction(&nlh, nlmsg, answer);\nout:\n\tnetlink_close(&nlh);\n\tnlmsg_free(answer);\n\tnlmsg_free(nlmsg);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to allocate a temporary name\""
          ],
          "line": 2611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_mkifname",
          "args": [
            "veth2buf"
          ],
          "line": 2609
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_mkifname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "1507-1566",
          "snippet": "char *lxc_mkifname(char *template)\n{\n\tchar *name = NULL;\n\tsize_t i = 0;\n\tFILE *urandom;\n\tunsigned int seed;\n\tstruct ifaddrs *ifaddr, *ifa;\n\tint ifexists = 0;\n\n\t/* Get all the network interfaces */\n\tgetifaddrs(&ifaddr);\n\n\t/* Initialize the random number generator */\n\turandom = fopen (\"/dev/urandom\", \"r\");\n\tif (urandom != NULL) {\n\t\tif (fread (&seed, sizeof(seed), 1, urandom) <= 0)\n\t\t\tseed = time(0);\n\t\tfclose(urandom);\n\t}\n\telse\n\t\tseed = time(0);\n\n#ifndef HAVE_RAND_R\n\tsrand(seed);\n#endif\n\n\t/* Generate random names until we find one that doesn't exist */\n\twhile(1) {\n\t\tifexists = 0;\n\t\tname = strdup(template);\n\n\t\tif (name == NULL)\n\t\t\treturn NULL;\n\n\t\tfor (i = 0; i < strlen(name); i++) {\n\t\t\tif (name[i] == 'X') {\n#ifdef HAVE_RAND_R\n\t\t\t\tname[i] = padchar[rand_r(&seed) % (strlen(padchar) - 1)];\n#else\n\t\t\t\tname[i] = padchar[rand() % (strlen(padchar) - 1)];\n#endif\n\t\t\t}\n\t\t}\n\n\t\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n\t\t\tif (strcmp(ifa->ifa_name, name) == 0) {\n\t\t\t\tifexists = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ifexists == 0)\n\t\t\tbreak;\n\n\t\tfree(name);\n\t}\n\n\tfreeifaddrs(ifaddr);\n\treturn name;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char padchar[] =\n\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic const char padchar[] =\n\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\nchar *lxc_mkifname(char *template)\n{\n\tchar *name = NULL;\n\tsize_t i = 0;\n\tFILE *urandom;\n\tunsigned int seed;\n\tstruct ifaddrs *ifaddr, *ifa;\n\tint ifexists = 0;\n\n\t/* Get all the network interfaces */\n\tgetifaddrs(&ifaddr);\n\n\t/* Initialize the random number generator */\n\turandom = fopen (\"/dev/urandom\", \"r\");\n\tif (urandom != NULL) {\n\t\tif (fread (&seed, sizeof(seed), 1, urandom) <= 0)\n\t\t\tseed = time(0);\n\t\tfclose(urandom);\n\t}\n\telse\n\t\tseed = time(0);\n\n#ifndef HAVE_RAND_R\n\tsrand(seed);\n#endif\n\n\t/* Generate random names until we find one that doesn't exist */\n\twhile(1) {\n\t\tifexists = 0;\n\t\tname = strdup(template);\n\n\t\tif (name == NULL)\n\t\t\treturn NULL;\n\n\t\tfor (i = 0; i < strlen(name); i++) {\n\t\t\tif (name[i] == 'X') {\n#ifdef HAVE_RAND_R\n\t\t\t\tname[i] = padchar[rand_r(&seed) % (strlen(padchar) - 1)];\n#else\n\t\t\t\tname[i] = padchar[rand() % (strlen(padchar) - 1)];\n#endif\n\t\t\t}\n\t\t}\n\n\t\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n\t\t\tif (strcmp(ifa->ifa_name, name) == 0) {\n\t\t\t\tifexists = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ifexists == 0)\n\t\t\tbreak;\n\n\t\tfree(name);\n\t}\n\n\tfreeifaddrs(ifaddr);\n\treturn name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "veth2buf",
            "sizeof(veth2buf)",
            "\"vethXXXXXX\""
          ],
          "line": 2608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "netdev->priv.veth_attr.veth1",
            "veth1",
            "IFNAMSIZ"
          ],
          "line": 2605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to allocate a temporary name\""
          ],
          "line": 2601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"veth1 name too long\""
          ],
          "line": 2596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "veth1buf",
            "sizeof(veth1buf)",
            "\"vethXXXXXX\""
          ],
          "line": 2594
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_none(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_none(struct lxc_handler *, struct lxc_netdev *);\n\nstatic int instantiate_veth(struct lxc_handler *handler, struct lxc_netdev *netdev)\n{\n\tchar veth1buf[IFNAMSIZ], *veth1;\n\tchar veth2buf[IFNAMSIZ], *veth2;\n\tint bridge_index, err;\n\tunsigned int mtu = 0;\n\n\tif (netdev->priv.veth_attr.pair) {\n\t\tveth1 = netdev->priv.veth_attr.pair;\n\t\tif (handler->conf->reboot)\n\t\t\tlxc_netdev_delete_by_name(veth1);\n\t} else {\n\t\terr = snprintf(veth1buf, sizeof(veth1buf), \"vethXXXXXX\");\n\t\tif (err >= sizeof(veth1buf)) { /* can't *really* happen, but... */\n\t\t\tERROR(\"veth1 name too long\");\n\t\t\treturn -1;\n\t\t}\n\t\tveth1 = lxc_mkifname(veth1buf);\n\t\tif (!veth1) {\n\t\t\tERROR(\"failed to allocate a temporary name\");\n\t\t\treturn -1;\n\t\t}\n\t\t/* store away for deconf */\n\t\tmemcpy(netdev->priv.veth_attr.veth1, veth1, IFNAMSIZ);\n\t}\n\n\tsnprintf(veth2buf, sizeof(veth2buf), \"vethXXXXXX\");\n\tveth2 = lxc_mkifname(veth2buf);\n\tif (!veth2) {\n\t\tERROR(\"failed to allocate a temporary name\");\n\t\tgoto out_delete;\n\t}\n\n\terr = lxc_veth_create(veth1, veth2);\n\tif (err) {\n\t\tERROR(\"failed to create veth pair (%s and %s): %s\", veth1, veth2,\n\t\t      strerror(-err));\n\t\tgoto out_delete;\n\t}\n\n\t/* changing the high byte of the mac address to 0xfe, the bridge interface\n\t * will always keep the host's mac address and not take the mac address\n\t * of a container */\n\terr = setup_private_host_hw_addr(veth1);\n\tif (err) {\n\t\tERROR(\"failed to change mac address of host interface '%s': %s\",\n\t\t\tveth1, strerror(-err));\n\t\tgoto out_delete;\n\t}\n\n\tnetdev->ifindex = if_nametoindex(veth2);\n\tif (!netdev->ifindex) {\n\t\tERROR(\"failed to retrieve the index for %s\", veth2);\n\t\tgoto out_delete;\n\t}\n\n\tif (netdev->mtu) {\n\t\tif (lxc_safe_uint(netdev->mtu, &mtu) < 0)\n\t\t\tWARN(\"Failed to parse mtu from.\");\n\t\telse\n\t\t\tINFO(\"Retrieved mtu %d\", mtu);\n\t} else if (netdev->link) {\n\t\tbridge_index = if_nametoindex(netdev->link);\n\t\tif (bridge_index) {\n\t\t\tmtu = netdev_get_mtu(bridge_index);\n\t\t\tINFO(\"Retrieved mtu %d from %s\", mtu, netdev->link);\n\t\t} else {\n\t\t\tmtu = netdev_get_mtu(netdev->ifindex);\n\t\t\tINFO(\"Retrieved mtu %d from %s\", mtu, veth2);\n\t\t}\n\t}\n\n\tif (mtu) {\n\t\terr = lxc_netdev_set_mtu(veth1, mtu);\n\t\tif (!err)\n\t\t\terr = lxc_netdev_set_mtu(veth2, mtu);\n\t\tif (err) {\n\t\t\tERROR(\"failed to set mtu '%i' for veth pair (%s and %s): %s\",\n\t\t\t      mtu, veth1, veth2, strerror(-err));\n\t\t\tgoto out_delete;\n\t\t}\n\t}\n\n\tif (netdev->link) {\n\t\terr = lxc_bridge_attach(handler->lxcpath, handler->name, netdev->link, veth1);\n\t\tif (err) {\n\t\t\tERROR(\"failed to attach '%s' to the bridge '%s': %s\",\n\t\t\t\t      veth1, netdev->link, strerror(-err));\n\t\t\tgoto out_delete;\n\t\t}\n\t\tINFO(\"Attached '%s': to the bridge '%s': \", veth1, netdev->link);\n\t}\n\n\terr = lxc_netdev_up(veth1);\n\tif (err) {\n\t\tERROR(\"failed to set %s up : %s\", veth1, strerror(-err));\n\t\tgoto out_delete;\n\t}\n\n\tif (netdev->upscript) {\n\t\terr = run_script(handler->name, \"net\", netdev->upscript, \"up\",\n\t\t\t\t \"veth\", veth1, (char*) NULL);\n\t\tif (err)\n\t\t\tgoto out_delete;\n\t}\n\n\tDEBUG(\"instantiated veth '%s/%s', index is '%d'\",\n\t      veth1, veth2, netdev->ifindex);\n\n\treturn 0;\n\nout_delete:\n\tlxc_netdev_delete_by_name(veth1);\n\tif (!netdev->priv.veth_attr.pair)\n\t\tfree(veth1);\n\tfree(veth2);\n\treturn -1;\n}"
  },
  {
    "function_name": "lxc_conf_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "2520-2580",
    "snippet": "struct lxc_conf *lxc_conf_init(void)\n{\n\tstruct lxc_conf *new;\n\tint i;\n\n\tnew = \tmalloc(sizeof(*new));\n\tif (!new) {\n\t\tERROR(\"lxc_conf_init : %m\");\n\t\treturn NULL;\n\t}\n\tmemset(new, 0, sizeof(*new));\n\n\tnew->loglevel = LXC_LOG_PRIORITY_NOTSET;\n\tnew->personality = -1;\n\tnew->autodev = 1;\n\tnew->console.log_path = NULL;\n\tnew->console.log_fd = -1;\n\tnew->console.path = NULL;\n\tnew->console.peer = -1;\n\tnew->console.peerpty.busy = -1;\n\tnew->console.peerpty.master = -1;\n\tnew->console.peerpty.slave = -1;\n\tnew->console.master = -1;\n\tnew->console.slave = -1;\n\tnew->console.name[0] = '\\0';\n\tnew->maincmd_fd = -1;\n\tnew->nbd_idx = -1;\n\tnew->rootfs.mount = strdup(default_rootfs_mount);\n\tif (!new->rootfs.mount) {\n\t\tERROR(\"lxc_conf_init : %m\");\n\t\tfree(new);\n\t\treturn NULL;\n\t}\n\tnew->kmsg = 0;\n\tnew->logfd = -1;\n\tlxc_list_init(&new->cgroup);\n\tlxc_list_init(&new->network);\n\tlxc_list_init(&new->mount_list);\n\tlxc_list_init(&new->caps);\n\tlxc_list_init(&new->keepcaps);\n\tlxc_list_init(&new->id_map);\n\tlxc_list_init(&new->includes);\n\tlxc_list_init(&new->aliens);\n\tlxc_list_init(&new->environment);\n\tfor (i=0; i<NUM_LXC_HOOKS; i++)\n\t\tlxc_list_init(&new->hooks[i]);\n\tlxc_list_init(&new->groups);\n\tnew->lsm_aa_profile = NULL;\n\tnew->lsm_se_context = NULL;\n\tnew->tmp_umount_proc = 0;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++)\n\t\tnew->inherit_ns_fd[i] = -1;\n\n\t/* if running in a new user namespace, init and COMMAND\n\t * default to running as UID/GID 0 when using lxc-execute */\n\tnew->init_uid = 0;\n\tnew->init_gid = 0;\n\n\treturn new;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int in_caplist(int cap, struct lxc_list *caps);",
      "static char *default_rootfs_mount = LXCROOTFSMOUNT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_list_init",
          "args": [
            "&new->groups"
          ],
          "line": 2566
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "68-72",
          "snippet": "static inline void lxc_list_init(struct lxc_list *list)\n{\n\tlist->elem = NULL;\n\tlist->next = list->prev = list;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void lxc_list_init(struct lxc_list *list)\n{\n\tlist->elem = NULL;\n\tlist->next = list->prev = list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "new"
          ],
          "line": 2550
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4619-4628",
          "snippet": "static void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"lxc_conf_init : %m\""
          ],
          "line": 2549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "default_rootfs_mount"
          ],
          "line": 2547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "new",
            "0",
            "sizeof(*new)"
          ],
          "line": 2530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"lxc_conf_init : %m\""
          ],
          "line": 2527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*new)"
          ],
          "line": 2525
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int in_caplist(int cap, struct lxc_list *caps);\nstatic char *default_rootfs_mount = LXCROOTFSMOUNT;\n\nstruct lxc_conf *lxc_conf_init(void)\n{\n\tstruct lxc_conf *new;\n\tint i;\n\n\tnew = \tmalloc(sizeof(*new));\n\tif (!new) {\n\t\tERROR(\"lxc_conf_init : %m\");\n\t\treturn NULL;\n\t}\n\tmemset(new, 0, sizeof(*new));\n\n\tnew->loglevel = LXC_LOG_PRIORITY_NOTSET;\n\tnew->personality = -1;\n\tnew->autodev = 1;\n\tnew->console.log_path = NULL;\n\tnew->console.log_fd = -1;\n\tnew->console.path = NULL;\n\tnew->console.peer = -1;\n\tnew->console.peerpty.busy = -1;\n\tnew->console.peerpty.master = -1;\n\tnew->console.peerpty.slave = -1;\n\tnew->console.master = -1;\n\tnew->console.slave = -1;\n\tnew->console.name[0] = '\\0';\n\tnew->maincmd_fd = -1;\n\tnew->nbd_idx = -1;\n\tnew->rootfs.mount = strdup(default_rootfs_mount);\n\tif (!new->rootfs.mount) {\n\t\tERROR(\"lxc_conf_init : %m\");\n\t\tfree(new);\n\t\treturn NULL;\n\t}\n\tnew->kmsg = 0;\n\tnew->logfd = -1;\n\tlxc_list_init(&new->cgroup);\n\tlxc_list_init(&new->network);\n\tlxc_list_init(&new->mount_list);\n\tlxc_list_init(&new->caps);\n\tlxc_list_init(&new->keepcaps);\n\tlxc_list_init(&new->id_map);\n\tlxc_list_init(&new->includes);\n\tlxc_list_init(&new->aliens);\n\tlxc_list_init(&new->environment);\n\tfor (i=0; i<NUM_LXC_HOOKS; i++)\n\t\tlxc_list_init(&new->hooks[i]);\n\tlxc_list_init(&new->groups);\n\tnew->lsm_aa_profile = NULL;\n\tnew->lsm_se_context = NULL;\n\tnew->tmp_umount_proc = 0;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++)\n\t\tnew->inherit_ns_fd[i] = -1;\n\n\t/* if running in a new user namespace, init and COMMAND\n\t * default to running as UID/GID 0 when using lxc-execute */\n\tnew->init_uid = 0;\n\tnew->init_gid = 0;\n\n\treturn new;\n}"
  },
  {
    "function_name": "lxc_restore_phys_nics_to_netns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "2479-2516",
    "snippet": "void lxc_restore_phys_nics_to_netns(int netnsfd, struct lxc_conf *conf)\n{\n\tint i, oldfd;\n\tchar ifname[IFNAMSIZ];\n\n\tif (netnsfd < 0 || conf->num_savednics == 0)\n\t\treturn;\n\n\tINFO(\"Running to reset %d nic names.\", conf->num_savednics);\n\n\toldfd = lxc_preserve_ns(getpid(), \"net\");\n\tif (oldfd < 0) {\n\t\tSYSERROR(\"Failed to open monitor netns fd.\");\n\t\treturn;\n\t}\n\n\tif (setns(netnsfd, 0) != 0) {\n\t\tSYSERROR(\"Failed to enter container netns to reset nics\");\n\t\tclose(oldfd);\n\t\treturn;\n\t}\n\tfor (i=0; i<conf->num_savednics; i++) {\n\t\tstruct saved_nic *s = &conf->saved_nics[i];\n\t\t/* retrieve the name of the interface */\n\t\tif (!if_indextoname(s->ifindex, ifname)) {\n\t\t\tWARN(\"no interface corresponding to index '%d'\", s->ifindex);\n\t\t\tcontinue;\n\t\t}\n\t\tif (lxc_netdev_move_by_name(ifname, 1, s->orig_name))\n\t\t\tWARN(\"Error moving nic name:%s back to host netns\", ifname);\n\t\tfree(s->orig_name);\n\t}\n\tconf->num_savednics = 0;\n\n\tif (setns(oldfd, 0) != 0)\n\t\tSYSERROR(\"Failed to re-enter monitor's netns\");\n\tclose(oldfd);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "oldfd"
          ],
          "line": 2515
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to re-enter monitor's netns\""
          ],
          "line": 2514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setns",
          "args": [
            "oldfd",
            "0"
          ],
          "line": 2513
        },
        "resolved": true,
        "details": {
          "function_name": "setns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.h",
          "lines": "58-68",
          "snippet": "static inline int setns(int fd, int nstype)\n{\n#ifdef __NR_setns\n\treturn syscall(__NR_setns, fd, nstype);\n#elif defined(__NR_set_ns)\n\treturn syscall(__NR_set_ns, fd, nstype);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}",
          "includes": [
            "#include <stdint.h>",
            "#  include <sys/signalfd.h>",
            "#include <../include/getline.h>",
            "#include \"initutils.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#  include <sys/signalfd.h>\n#include <../include/getline.h>\n#include \"initutils.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic inline int setns(int fd, int nstype)\n{\n#ifdef __NR_setns\n\treturn syscall(__NR_setns, fd, nstype);\n#elif defined(__NR_set_ns)\n\treturn syscall(__NR_set_ns, fd, nstype);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "s->orig_name"
          ],
          "line": 2509
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4619-4628",
          "snippet": "static void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Error moving nic name:%s back to host netns\"",
            "ifname"
          ],
          "line": 2508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_netdev_move_by_name",
          "args": [
            "ifname",
            "1",
            "s->orig_name"
          ],
          "line": 2507
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_netdev_move_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "240-256",
          "snippet": "int lxc_netdev_move_by_name(const char *ifname, pid_t pid, const char* newname)\n{\n\tint index;\n\tchar *physname;\n\n\tif (!ifname)\n\t\treturn -EINVAL;\n\n\tindex = if_nametoindex(ifname);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\tif ((physname = is_wlan(ifname)))\n\t\treturn lxc_netdev_move_wlan(physname, ifname, pid, newname);\n\n\treturn lxc_netdev_move_by_index(index, pid, newname);\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_netdev_move_by_name(const char *ifname, pid_t pid, const char* newname)\n{\n\tint index;\n\tchar *physname;\n\n\tif (!ifname)\n\t\treturn -EINVAL;\n\n\tindex = if_nametoindex(ifname);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\tif ((physname = is_wlan(ifname)))\n\t\treturn lxc_netdev_move_wlan(physname, ifname, pid, newname);\n\n\treturn lxc_netdev_move_by_index(index, pid, newname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"no interface corresponding to index '%d'\"",
            "s->ifindex"
          ],
          "line": 2504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_indextoname",
          "args": [
            "s->ifindex",
            "ifname"
          ],
          "line": 2503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to enter container netns to reset nics\""
          ],
          "line": 2496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to open monitor netns fd.\""
          ],
          "line": 2491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_preserve_ns",
          "args": [
            "getpid()",
            "\"net\""
          ],
          "line": 2489
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_preserve_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1965-1983",
          "snippet": "int lxc_preserve_ns(const int pid, const char *ns)\n{\n\tint ret;\n/* 5 /proc + 21 /int_as_str + 3 /ns + 20 /NS_NAME + 1 \\0 */\n#define __NS_PATH_LEN 50\n\tchar path[__NS_PATH_LEN];\n\n\t/* This way we can use this function to also check whether namespaces\n\t * are supported by the kernel by passing in the NULL or the empty\n\t * string.\n\t */\n\tret = snprintf(path, __NS_PATH_LEN, \"/proc/%d/ns%s%s\", pid,\n\t\t       !ns || strcmp(ns, \"\") == 0 ? \"\" : \"/\",\n\t\t       !ns || strcmp(ns, \"\") == 0 ? \"\" : ns);\n\tif (ret < 0 || (size_t)ret >= __NS_PATH_LEN)\n\t\treturn -1;\n\n\treturn open(path, O_RDONLY | O_CLOEXEC);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define __NS_PATH_LEN 50"
          ],
          "globals_used": [
            "extern bool btrfs_try_remove_subvol(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\n#define __NS_PATH_LEN 50\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nint lxc_preserve_ns(const int pid, const char *ns)\n{\n\tint ret;\n/* 5 /proc + 21 /int_as_str + 3 /ns + 20 /NS_NAME + 1 \\0 */\n#define __NS_PATH_LEN 50\n\tchar path[__NS_PATH_LEN];\n\n\t/* This way we can use this function to also check whether namespaces\n\t * are supported by the kernel by passing in the NULL or the empty\n\t * string.\n\t */\n\tret = snprintf(path, __NS_PATH_LEN, \"/proc/%d/ns%s%s\", pid,\n\t\t       !ns || strcmp(ns, \"\") == 0 ? \"\" : \"/\",\n\t\t       !ns || strcmp(ns, \"\") == 0 ? \"\" : ns);\n\tif (ret < 0 || (size_t)ret >= __NS_PATH_LEN)\n\t\treturn -1;\n\n\treturn open(path, O_RDONLY | O_CLOEXEC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 2489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Running to reset %d nic names.\"",
            "conf->num_savednics"
          ],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid lxc_restore_phys_nics_to_netns(int netnsfd, struct lxc_conf *conf)\n{\n\tint i, oldfd;\n\tchar ifname[IFNAMSIZ];\n\n\tif (netnsfd < 0 || conf->num_savednics == 0)\n\t\treturn;\n\n\tINFO(\"Running to reset %d nic names.\", conf->num_savednics);\n\n\toldfd = lxc_preserve_ns(getpid(), \"net\");\n\tif (oldfd < 0) {\n\t\tSYSERROR(\"Failed to open monitor netns fd.\");\n\t\treturn;\n\t}\n\n\tif (setns(netnsfd, 0) != 0) {\n\t\tSYSERROR(\"Failed to enter container netns to reset nics\");\n\t\tclose(oldfd);\n\t\treturn;\n\t}\n\tfor (i=0; i<conf->num_savednics; i++) {\n\t\tstruct saved_nic *s = &conf->saved_nics[i];\n\t\t/* retrieve the name of the interface */\n\t\tif (!if_indextoname(s->ifindex, ifname)) {\n\t\t\tWARN(\"no interface corresponding to index '%d'\", s->ifindex);\n\t\t\tcontinue;\n\t\t}\n\t\tif (lxc_netdev_move_by_name(ifname, 1, s->orig_name))\n\t\t\tWARN(\"Error moving nic name:%s back to host netns\", ifname);\n\t\tfree(s->orig_name);\n\t}\n\tconf->num_savednics = 0;\n\n\tif (setns(oldfd, 0) != 0)\n\t\tSYSERROR(\"Failed to re-enter monitor's netns\");\n\tclose(oldfd);\n}"
  },
  {
    "function_name": "setup_network",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "2457-2476",
    "snippet": "static int setup_network(struct lxc_list *network)\n{\n\tstruct lxc_list *iterator;\n\tstruct lxc_netdev *netdev;\n\n\tlxc_list_for_each(iterator, network) {\n\n\t\tnetdev = iterator->elem;\n\n\t\tif (setup_netdev(netdev)) {\n\t\t\tERROR(\"failed to setup netdev\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!lxc_list_empty(network))\n\t\tINFO(\"network has been setup\");\n\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_none(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_none(struct lxc_handler *, struct lxc_netdev *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"network has been setup\""
          ],
          "line": 2473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_empty",
          "args": [
            "network"
          ],
          "line": 2472
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "94-97",
          "snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to setup netdev\""
          ],
          "line": 2467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_netdev",
          "args": [
            "netdev"
          ],
          "line": 2466
        },
        "resolved": true,
        "details": {
          "function_name": "setup_netdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "2275-2455",
          "snippet": "static int setup_netdev(struct lxc_netdev *netdev)\n{\n\tchar ifname[IFNAMSIZ];\n\tchar *current_ifname = ifname;\n\tint err;\n\n\t/* empty network namespace */\n\tif (!netdev->ifindex) {\n\t\tif (netdev->flags & IFF_UP) {\n\t\t\terr = lxc_netdev_up(\"lo\");\n\t\t\tif (err) {\n\t\t\t\tERROR(\"failed to set the loopback up : %s\",\n\t\t\t\t      strerror(-err));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (netdev->type != LXC_NET_VETH)\n\t\t\treturn 0;\n\t\tnetdev->ifindex = if_nametoindex(netdev->name);\n\t}\n\n\t/* get the new ifindex in case of physical netdev */\n\tif (netdev->type == LXC_NET_PHYS) {\n\t\tif (!(netdev->ifindex = if_nametoindex(netdev->link))) {\n\t\t\tERROR(\"failed to get ifindex for %s\",\n\t\t\t\tnetdev->link);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* retrieve the name of the interface */\n\tif (!if_indextoname(netdev->ifindex, current_ifname)) {\n\t\tERROR(\"no interface corresponding to index '%d'\",\n\t\t      netdev->ifindex);\n\t\treturn -1;\n\t}\n\n\t/* default: let the system to choose one interface name */\n\tif (!netdev->name)\n\t\tnetdev->name = netdev->type == LXC_NET_PHYS ?\n\t\t\tnetdev->link : \"eth%d\";\n\n\t/* rename the interface name */\n\tif (strcmp(ifname, netdev->name) != 0) {\n\t\terr = lxc_netdev_rename_by_name(ifname, netdev->name);\n\t\tif (err) {\n\t\t\tERROR(\"failed to rename %s->%s : %s\", ifname, netdev->name,\n\t\t\t      strerror(-err));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Re-read the name of the interface because its name has changed\n\t * and would be automatically allocated by the system\n\t */\n\tif (!if_indextoname(netdev->ifindex, current_ifname)) {\n\t\tERROR(\"no interface corresponding to index '%d'\",\n\t\t      netdev->ifindex);\n\t\treturn -1;\n\t}\n\n\t/* set a mac address */\n\tif (netdev->hwaddr) {\n\t\tif (setup_hw_addr(netdev->hwaddr, current_ifname)) {\n\t\t\tERROR(\"failed to setup hw address for '%s'\",\n\t\t\t      current_ifname);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* setup ipv4 addresses on the interface */\n\tif (setup_ipv4_addr(&netdev->ipv4, netdev->ifindex)) {\n\t\tERROR(\"failed to setup ip addresses for '%s'\",\n\t\t\t      ifname);\n\t\treturn -1;\n\t}\n\n\t/* setup ipv6 addresses on the interface */\n\tif (setup_ipv6_addr(&netdev->ipv6, netdev->ifindex)) {\n\t\tERROR(\"failed to setup ipv6 addresses for '%s'\",\n\t\t\t      ifname);\n\t\treturn -1;\n\t}\n\n\t/* set the network device up */\n\tif (netdev->flags & IFF_UP) {\n\t\tint err;\n\n\t\terr = lxc_netdev_up(current_ifname);\n\t\tif (err) {\n\t\t\tERROR(\"failed to set '%s' up : %s\", current_ifname,\n\t\t\t      strerror(-err));\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* the network is up, make the loopback up too */\n\t\terr = lxc_netdev_up(\"lo\");\n\t\tif (err) {\n\t\t\tERROR(\"failed to set the loopback up : %s\",\n\t\t\t      strerror(-err));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* We can only set up the default routes after bringing\n\t * up the interface, sine bringing up the interface adds\n\t * the link-local routes and we can't add a default\n\t * route if the gateway is not reachable. */\n\n\t/* setup ipv4 gateway on the interface */\n\tif (netdev->ipv4_gateway) {\n\t\tif (!(netdev->flags & IFF_UP)) {\n\t\t\tERROR(\"Cannot add ipv4 gateway for %s when not bringing up the interface\", ifname);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (lxc_list_empty(&netdev->ipv4)) {\n\t\t\tERROR(\"Cannot add ipv4 gateway for %s when not assigning an address\", ifname);\n\t\t\treturn -1;\n\t\t}\n\n\t\terr = lxc_ipv4_gateway_add(netdev->ifindex, netdev->ipv4_gateway);\n\t\tif (err) {\n\t\t\terr = lxc_ipv4_dest_add(netdev->ifindex, netdev->ipv4_gateway);\n\t\t\tif (err) {\n\t\t\t\tERROR(\"failed to add ipv4 dest for '%s': %s\",\n\t\t\t\t\t      ifname, strerror(-err));\n\t\t\t}\n\n\t\t\terr = lxc_ipv4_gateway_add(netdev->ifindex, netdev->ipv4_gateway);\n\t\t\tif (err) {\n\t\t\t\tERROR(\"failed to setup ipv4 gateway for '%s': %s\",\n\t\t\t\t\t      ifname, strerror(-err));\n\t\t\t\tif (netdev->ipv4_gateway_auto) {\n\t\t\t\t\tchar buf[INET_ADDRSTRLEN];\n\t\t\t\t\tinet_ntop(AF_INET, netdev->ipv4_gateway, buf, sizeof(buf));\n\t\t\t\t\tERROR(\"tried to set autodetected ipv4 gateway '%s'\", buf);\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* setup ipv6 gateway on the interface */\n\tif (netdev->ipv6_gateway) {\n\t\tif (!(netdev->flags & IFF_UP)) {\n\t\t\tERROR(\"Cannot add ipv6 gateway for %s when not bringing up the interface\", ifname);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (lxc_list_empty(&netdev->ipv6) && !IN6_IS_ADDR_LINKLOCAL(netdev->ipv6_gateway)) {\n\t\t\tERROR(\"Cannot add ipv6 gateway for %s when not assigning an address\", ifname);\n\t\t\treturn -1;\n\t\t}\n\n\t\terr = lxc_ipv6_gateway_add(netdev->ifindex, netdev->ipv6_gateway);\n\t\tif (err) {\n\t\t\terr = lxc_ipv6_dest_add(netdev->ifindex, netdev->ipv6_gateway);\n\t\t\tif (err) {\n\t\t\t\tERROR(\"failed to add ipv6 dest for '%s': %s\",\n\t\t\t\t      ifname, strerror(-err));\n\t\t\t}\n\n\t\t\terr = lxc_ipv6_gateway_add(netdev->ifindex, netdev->ipv6_gateway);\n\t\t\tif (err) {\n\t\t\t\tERROR(\"failed to setup ipv6 gateway for '%s': %s\",\n\t\t\t\t\t      ifname, strerror(-err));\n\t\t\t\tif (netdev->ipv6_gateway_auto) {\n\t\t\t\t\tchar buf[INET6_ADDRSTRLEN];\n\t\t\t\t\tinet_ntop(AF_INET6, netdev->ipv6_gateway, buf, sizeof(buf));\n\t\t\t\t\tERROR(\"tried to set autodetected ipv6 gateway '%s'\", buf);\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tDEBUG(\"'%s' has been setup\", current_ifname);\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_none(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_none(struct lxc_handler *, struct lxc_netdev *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_none(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_none(struct lxc_handler *, struct lxc_netdev *);\n\nstatic int setup_netdev(struct lxc_netdev *netdev)\n{\n\tchar ifname[IFNAMSIZ];\n\tchar *current_ifname = ifname;\n\tint err;\n\n\t/* empty network namespace */\n\tif (!netdev->ifindex) {\n\t\tif (netdev->flags & IFF_UP) {\n\t\t\terr = lxc_netdev_up(\"lo\");\n\t\t\tif (err) {\n\t\t\t\tERROR(\"failed to set the loopback up : %s\",\n\t\t\t\t      strerror(-err));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (netdev->type != LXC_NET_VETH)\n\t\t\treturn 0;\n\t\tnetdev->ifindex = if_nametoindex(netdev->name);\n\t}\n\n\t/* get the new ifindex in case of physical netdev */\n\tif (netdev->type == LXC_NET_PHYS) {\n\t\tif (!(netdev->ifindex = if_nametoindex(netdev->link))) {\n\t\t\tERROR(\"failed to get ifindex for %s\",\n\t\t\t\tnetdev->link);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* retrieve the name of the interface */\n\tif (!if_indextoname(netdev->ifindex, current_ifname)) {\n\t\tERROR(\"no interface corresponding to index '%d'\",\n\t\t      netdev->ifindex);\n\t\treturn -1;\n\t}\n\n\t/* default: let the system to choose one interface name */\n\tif (!netdev->name)\n\t\tnetdev->name = netdev->type == LXC_NET_PHYS ?\n\t\t\tnetdev->link : \"eth%d\";\n\n\t/* rename the interface name */\n\tif (strcmp(ifname, netdev->name) != 0) {\n\t\terr = lxc_netdev_rename_by_name(ifname, netdev->name);\n\t\tif (err) {\n\t\t\tERROR(\"failed to rename %s->%s : %s\", ifname, netdev->name,\n\t\t\t      strerror(-err));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Re-read the name of the interface because its name has changed\n\t * and would be automatically allocated by the system\n\t */\n\tif (!if_indextoname(netdev->ifindex, current_ifname)) {\n\t\tERROR(\"no interface corresponding to index '%d'\",\n\t\t      netdev->ifindex);\n\t\treturn -1;\n\t}\n\n\t/* set a mac address */\n\tif (netdev->hwaddr) {\n\t\tif (setup_hw_addr(netdev->hwaddr, current_ifname)) {\n\t\t\tERROR(\"failed to setup hw address for '%s'\",\n\t\t\t      current_ifname);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* setup ipv4 addresses on the interface */\n\tif (setup_ipv4_addr(&netdev->ipv4, netdev->ifindex)) {\n\t\tERROR(\"failed to setup ip addresses for '%s'\",\n\t\t\t      ifname);\n\t\treturn -1;\n\t}\n\n\t/* setup ipv6 addresses on the interface */\n\tif (setup_ipv6_addr(&netdev->ipv6, netdev->ifindex)) {\n\t\tERROR(\"failed to setup ipv6 addresses for '%s'\",\n\t\t\t      ifname);\n\t\treturn -1;\n\t}\n\n\t/* set the network device up */\n\tif (netdev->flags & IFF_UP) {\n\t\tint err;\n\n\t\terr = lxc_netdev_up(current_ifname);\n\t\tif (err) {\n\t\t\tERROR(\"failed to set '%s' up : %s\", current_ifname,\n\t\t\t      strerror(-err));\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* the network is up, make the loopback up too */\n\t\terr = lxc_netdev_up(\"lo\");\n\t\tif (err) {\n\t\t\tERROR(\"failed to set the loopback up : %s\",\n\t\t\t      strerror(-err));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* We can only set up the default routes after bringing\n\t * up the interface, sine bringing up the interface adds\n\t * the link-local routes and we can't add a default\n\t * route if the gateway is not reachable. */\n\n\t/* setup ipv4 gateway on the interface */\n\tif (netdev->ipv4_gateway) {\n\t\tif (!(netdev->flags & IFF_UP)) {\n\t\t\tERROR(\"Cannot add ipv4 gateway for %s when not bringing up the interface\", ifname);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (lxc_list_empty(&netdev->ipv4)) {\n\t\t\tERROR(\"Cannot add ipv4 gateway for %s when not assigning an address\", ifname);\n\t\t\treturn -1;\n\t\t}\n\n\t\terr = lxc_ipv4_gateway_add(netdev->ifindex, netdev->ipv4_gateway);\n\t\tif (err) {\n\t\t\terr = lxc_ipv4_dest_add(netdev->ifindex, netdev->ipv4_gateway);\n\t\t\tif (err) {\n\t\t\t\tERROR(\"failed to add ipv4 dest for '%s': %s\",\n\t\t\t\t\t      ifname, strerror(-err));\n\t\t\t}\n\n\t\t\terr = lxc_ipv4_gateway_add(netdev->ifindex, netdev->ipv4_gateway);\n\t\t\tif (err) {\n\t\t\t\tERROR(\"failed to setup ipv4 gateway for '%s': %s\",\n\t\t\t\t\t      ifname, strerror(-err));\n\t\t\t\tif (netdev->ipv4_gateway_auto) {\n\t\t\t\t\tchar buf[INET_ADDRSTRLEN];\n\t\t\t\t\tinet_ntop(AF_INET, netdev->ipv4_gateway, buf, sizeof(buf));\n\t\t\t\t\tERROR(\"tried to set autodetected ipv4 gateway '%s'\", buf);\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* setup ipv6 gateway on the interface */\n\tif (netdev->ipv6_gateway) {\n\t\tif (!(netdev->flags & IFF_UP)) {\n\t\t\tERROR(\"Cannot add ipv6 gateway for %s when not bringing up the interface\", ifname);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (lxc_list_empty(&netdev->ipv6) && !IN6_IS_ADDR_LINKLOCAL(netdev->ipv6_gateway)) {\n\t\t\tERROR(\"Cannot add ipv6 gateway for %s when not assigning an address\", ifname);\n\t\t\treturn -1;\n\t\t}\n\n\t\terr = lxc_ipv6_gateway_add(netdev->ifindex, netdev->ipv6_gateway);\n\t\tif (err) {\n\t\t\terr = lxc_ipv6_dest_add(netdev->ifindex, netdev->ipv6_gateway);\n\t\t\tif (err) {\n\t\t\t\tERROR(\"failed to add ipv6 dest for '%s': %s\",\n\t\t\t\t      ifname, strerror(-err));\n\t\t\t}\n\n\t\t\terr = lxc_ipv6_gateway_add(netdev->ifindex, netdev->ipv6_gateway);\n\t\t\tif (err) {\n\t\t\t\tERROR(\"failed to setup ipv6 gateway for '%s': %s\",\n\t\t\t\t\t      ifname, strerror(-err));\n\t\t\t\tif (netdev->ipv6_gateway_auto) {\n\t\t\t\t\tchar buf[INET6_ADDRSTRLEN];\n\t\t\t\t\tinet_ntop(AF_INET6, netdev->ipv6_gateway, buf, sizeof(buf));\n\t\t\t\t\tERROR(\"tried to set autodetected ipv6 gateway '%s'\", buf);\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tDEBUG(\"'%s' has been setup\", current_ifname);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "iterator",
            "network"
          ],
          "line": 2462
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_none(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_none(struct lxc_handler *, struct lxc_netdev *);\n\nstatic int setup_network(struct lxc_list *network)\n{\n\tstruct lxc_list *iterator;\n\tstruct lxc_netdev *netdev;\n\n\tlxc_list_for_each(iterator, network) {\n\n\t\tnetdev = iterator->elem;\n\n\t\tif (setup_netdev(netdev)) {\n\t\t\tERROR(\"failed to setup netdev\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!lxc_list_empty(network))\n\t\tINFO(\"network has been setup\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "setup_netdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "2275-2455",
    "snippet": "static int setup_netdev(struct lxc_netdev *netdev)\n{\n\tchar ifname[IFNAMSIZ];\n\tchar *current_ifname = ifname;\n\tint err;\n\n\t/* empty network namespace */\n\tif (!netdev->ifindex) {\n\t\tif (netdev->flags & IFF_UP) {\n\t\t\terr = lxc_netdev_up(\"lo\");\n\t\t\tif (err) {\n\t\t\t\tERROR(\"failed to set the loopback up : %s\",\n\t\t\t\t      strerror(-err));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (netdev->type != LXC_NET_VETH)\n\t\t\treturn 0;\n\t\tnetdev->ifindex = if_nametoindex(netdev->name);\n\t}\n\n\t/* get the new ifindex in case of physical netdev */\n\tif (netdev->type == LXC_NET_PHYS) {\n\t\tif (!(netdev->ifindex = if_nametoindex(netdev->link))) {\n\t\t\tERROR(\"failed to get ifindex for %s\",\n\t\t\t\tnetdev->link);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* retrieve the name of the interface */\n\tif (!if_indextoname(netdev->ifindex, current_ifname)) {\n\t\tERROR(\"no interface corresponding to index '%d'\",\n\t\t      netdev->ifindex);\n\t\treturn -1;\n\t}\n\n\t/* default: let the system to choose one interface name */\n\tif (!netdev->name)\n\t\tnetdev->name = netdev->type == LXC_NET_PHYS ?\n\t\t\tnetdev->link : \"eth%d\";\n\n\t/* rename the interface name */\n\tif (strcmp(ifname, netdev->name) != 0) {\n\t\terr = lxc_netdev_rename_by_name(ifname, netdev->name);\n\t\tif (err) {\n\t\t\tERROR(\"failed to rename %s->%s : %s\", ifname, netdev->name,\n\t\t\t      strerror(-err));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Re-read the name of the interface because its name has changed\n\t * and would be automatically allocated by the system\n\t */\n\tif (!if_indextoname(netdev->ifindex, current_ifname)) {\n\t\tERROR(\"no interface corresponding to index '%d'\",\n\t\t      netdev->ifindex);\n\t\treturn -1;\n\t}\n\n\t/* set a mac address */\n\tif (netdev->hwaddr) {\n\t\tif (setup_hw_addr(netdev->hwaddr, current_ifname)) {\n\t\t\tERROR(\"failed to setup hw address for '%s'\",\n\t\t\t      current_ifname);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* setup ipv4 addresses on the interface */\n\tif (setup_ipv4_addr(&netdev->ipv4, netdev->ifindex)) {\n\t\tERROR(\"failed to setup ip addresses for '%s'\",\n\t\t\t      ifname);\n\t\treturn -1;\n\t}\n\n\t/* setup ipv6 addresses on the interface */\n\tif (setup_ipv6_addr(&netdev->ipv6, netdev->ifindex)) {\n\t\tERROR(\"failed to setup ipv6 addresses for '%s'\",\n\t\t\t      ifname);\n\t\treturn -1;\n\t}\n\n\t/* set the network device up */\n\tif (netdev->flags & IFF_UP) {\n\t\tint err;\n\n\t\terr = lxc_netdev_up(current_ifname);\n\t\tif (err) {\n\t\t\tERROR(\"failed to set '%s' up : %s\", current_ifname,\n\t\t\t      strerror(-err));\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* the network is up, make the loopback up too */\n\t\terr = lxc_netdev_up(\"lo\");\n\t\tif (err) {\n\t\t\tERROR(\"failed to set the loopback up : %s\",\n\t\t\t      strerror(-err));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* We can only set up the default routes after bringing\n\t * up the interface, sine bringing up the interface adds\n\t * the link-local routes and we can't add a default\n\t * route if the gateway is not reachable. */\n\n\t/* setup ipv4 gateway on the interface */\n\tif (netdev->ipv4_gateway) {\n\t\tif (!(netdev->flags & IFF_UP)) {\n\t\t\tERROR(\"Cannot add ipv4 gateway for %s when not bringing up the interface\", ifname);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (lxc_list_empty(&netdev->ipv4)) {\n\t\t\tERROR(\"Cannot add ipv4 gateway for %s when not assigning an address\", ifname);\n\t\t\treturn -1;\n\t\t}\n\n\t\terr = lxc_ipv4_gateway_add(netdev->ifindex, netdev->ipv4_gateway);\n\t\tif (err) {\n\t\t\terr = lxc_ipv4_dest_add(netdev->ifindex, netdev->ipv4_gateway);\n\t\t\tif (err) {\n\t\t\t\tERROR(\"failed to add ipv4 dest for '%s': %s\",\n\t\t\t\t\t      ifname, strerror(-err));\n\t\t\t}\n\n\t\t\terr = lxc_ipv4_gateway_add(netdev->ifindex, netdev->ipv4_gateway);\n\t\t\tif (err) {\n\t\t\t\tERROR(\"failed to setup ipv4 gateway for '%s': %s\",\n\t\t\t\t\t      ifname, strerror(-err));\n\t\t\t\tif (netdev->ipv4_gateway_auto) {\n\t\t\t\t\tchar buf[INET_ADDRSTRLEN];\n\t\t\t\t\tinet_ntop(AF_INET, netdev->ipv4_gateway, buf, sizeof(buf));\n\t\t\t\t\tERROR(\"tried to set autodetected ipv4 gateway '%s'\", buf);\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* setup ipv6 gateway on the interface */\n\tif (netdev->ipv6_gateway) {\n\t\tif (!(netdev->flags & IFF_UP)) {\n\t\t\tERROR(\"Cannot add ipv6 gateway for %s when not bringing up the interface\", ifname);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (lxc_list_empty(&netdev->ipv6) && !IN6_IS_ADDR_LINKLOCAL(netdev->ipv6_gateway)) {\n\t\t\tERROR(\"Cannot add ipv6 gateway for %s when not assigning an address\", ifname);\n\t\t\treturn -1;\n\t\t}\n\n\t\terr = lxc_ipv6_gateway_add(netdev->ifindex, netdev->ipv6_gateway);\n\t\tif (err) {\n\t\t\terr = lxc_ipv6_dest_add(netdev->ifindex, netdev->ipv6_gateway);\n\t\t\tif (err) {\n\t\t\t\tERROR(\"failed to add ipv6 dest for '%s': %s\",\n\t\t\t\t      ifname, strerror(-err));\n\t\t\t}\n\n\t\t\terr = lxc_ipv6_gateway_add(netdev->ifindex, netdev->ipv6_gateway);\n\t\t\tif (err) {\n\t\t\t\tERROR(\"failed to setup ipv6 gateway for '%s': %s\",\n\t\t\t\t\t      ifname, strerror(-err));\n\t\t\t\tif (netdev->ipv6_gateway_auto) {\n\t\t\t\t\tchar buf[INET6_ADDRSTRLEN];\n\t\t\t\t\tinet_ntop(AF_INET6, netdev->ipv6_gateway, buf, sizeof(buf));\n\t\t\t\t\tERROR(\"tried to set autodetected ipv6 gateway '%s'\", buf);\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tDEBUG(\"'%s' has been setup\", current_ifname);\n\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int instantiate_none(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);",
      "static int shutdown_none(struct lxc_handler *, struct lxc_netdev *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"'%s' has been setup\"",
            "current_ifname"
          ],
          "line": 2452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"tried to set autodetected ipv6 gateway '%s'\"",
            "buf"
          ],
          "line": 2445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_ntop",
          "args": [
            "AF_INET6",
            "netdev->ipv6_gateway",
            "buf",
            "sizeof(buf)"
          ],
          "line": 2444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to setup ipv6 gateway for '%s': %s\"",
            "ifname",
            "strerror(-err)"
          ],
          "line": 2440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "-err"
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_ipv6_gateway_add",
          "args": [
            "netdev->ifindex",
            "netdev->ipv6_gateway"
          ],
          "line": 2438
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_ipv6_gateway_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "1330-1333",
          "snippet": "int lxc_ipv6_gateway_add(int ifindex, struct in6_addr *gw)\n{\n\treturn ip_gateway_add(AF_INET6, ifindex, gw);\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_ipv6_gateway_add(int ifindex, struct in6_addr *gw)\n{\n\treturn ip_gateway_add(AF_INET6, ifindex, gw);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to add ipv6 dest for '%s': %s\"",
            "ifname",
            "strerror(-err)"
          ],
          "line": 2434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "-err"
          ],
          "line": 2435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_ipv6_dest_add",
          "args": [
            "netdev->ifindex",
            "netdev->ipv6_gateway"
          ],
          "line": 2432
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_ipv6_dest_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "1391-1394",
          "snippet": "int lxc_ipv6_dest_add(int ifindex, struct in6_addr *dest)\n{\n\treturn ip_route_dest_add(AF_INET6, ifindex, dest);\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_ipv6_dest_add(int ifindex, struct in6_addr *dest)\n{\n\treturn ip_route_dest_add(AF_INET6, ifindex, dest);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Cannot add ipv6 gateway for %s when not assigning an address\"",
            "ifname"
          ],
          "line": 2426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IN6_IS_ADDR_LINKLOCAL",
          "args": [
            "netdev->ipv6_gateway"
          ],
          "line": 2425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_empty",
          "args": [
            "&netdev->ipv6"
          ],
          "line": 2425
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "94-97",
          "snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Cannot add ipv6 gateway for %s when not bringing up the interface\"",
            "ifname"
          ],
          "line": 2421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"tried to set autodetected ipv4 gateway '%s'\"",
            "buf"
          ],
          "line": 2411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_ntop",
          "args": [
            "AF_INET",
            "netdev->ipv4_gateway",
            "buf",
            "sizeof(buf)"
          ],
          "line": 2410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to setup ipv4 gateway for '%s': %s\"",
            "ifname",
            "strerror(-err)"
          ],
          "line": 2406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "-err"
          ],
          "line": 2407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_ipv4_gateway_add",
          "args": [
            "netdev->ifindex",
            "netdev->ipv4_gateway"
          ],
          "line": 2404
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_ipv4_gateway_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "1325-1328",
          "snippet": "int lxc_ipv4_gateway_add(int ifindex, struct in_addr *gw)\n{\n\treturn ip_gateway_add(AF_INET, ifindex, gw);\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_ipv4_gateway_add(int ifindex, struct in_addr *gw)\n{\n\treturn ip_gateway_add(AF_INET, ifindex, gw);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to add ipv4 dest for '%s': %s\"",
            "ifname",
            "strerror(-err)"
          ],
          "line": 2400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "-err"
          ],
          "line": 2401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_ipv4_dest_add",
          "args": [
            "netdev->ifindex",
            "netdev->ipv4_gateway"
          ],
          "line": 2398
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_ipv4_dest_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "1386-1389",
          "snippet": "int lxc_ipv4_dest_add(int ifindex, struct in_addr *dest)\n{\n\treturn ip_route_dest_add(AF_INET, ifindex, dest);\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_ipv4_dest_add(int ifindex, struct in_addr *dest)\n{\n\treturn ip_route_dest_add(AF_INET, ifindex, dest);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Cannot add ipv4 gateway for %s when not assigning an address\"",
            "ifname"
          ],
          "line": 2392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Cannot add ipv4 gateway for %s when not bringing up the interface\"",
            "ifname"
          ],
          "line": 2387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to set the loopback up : %s\"",
            "strerror(-err)"
          ],
          "line": 2373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "-err"
          ],
          "line": 2374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_netdev_up",
          "args": [
            "\"lo\""
          ],
          "line": 2371
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_netdev_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "662-665",
          "snippet": "int lxc_netdev_up(const char *name)\n{\n\treturn netdev_set_flag(name, IFF_UP);\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_netdev_up(const char *name)\n{\n\treturn netdev_set_flag(name, IFF_UP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to set '%s' up : %s\"",
            "current_ifname",
            "strerror(-err)"
          ],
          "line": 2365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "-err"
          ],
          "line": 2366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to setup ipv6 addresses for '%s'\"",
            "ifname"
          ],
          "line": 2354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_ipv6_addr",
          "args": [
            "&netdev->ipv6",
            "netdev->ifindex"
          ],
          "line": 2353
        },
        "resolved": true,
        "details": {
          "function_name": "setup_ipv6_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "2252-2273",
          "snippet": "static int setup_ipv6_addr(struct lxc_list *ip, int ifindex)\n{\n\tstruct lxc_list *iterator;\n\tstruct lxc_inet6dev *inet6dev;\n\tint err;\n\n\tlxc_list_for_each(iterator, ip) {\n\n\t\tinet6dev = iterator->elem;\n\n\t\terr = lxc_ipv6_addr_add(ifindex, &inet6dev->addr,\n\t\t\t\t\t&inet6dev->mcast, &inet6dev->acast,\n\t\t\t\t\tinet6dev->prefix);\n\t\tif (err) {\n\t\t\tERROR(\"failed to setup_ipv6_addr ifindex %d : %s\",\n\t\t\t      ifindex, strerror(-err));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int setup_ipv6_addr(struct lxc_list *ip, int ifindex)\n{\n\tstruct lxc_list *iterator;\n\tstruct lxc_inet6dev *inet6dev;\n\tint err;\n\n\tlxc_list_for_each(iterator, ip) {\n\n\t\tinet6dev = iterator->elem;\n\n\t\terr = lxc_ipv6_addr_add(ifindex, &inet6dev->addr,\n\t\t\t\t\t&inet6dev->mcast, &inet6dev->acast,\n\t\t\t\t\tinet6dev->prefix);\n\t\tif (err) {\n\t\t\tERROR(\"failed to setup_ipv6_addr ifindex %d : %s\",\n\t\t\t      ifindex, strerror(-err));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to setup ip addresses for '%s'\"",
            "ifname"
          ],
          "line": 2347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_ipv4_addr",
          "args": [
            "&netdev->ipv4",
            "netdev->ifindex"
          ],
          "line": 2346
        },
        "resolved": true,
        "details": {
          "function_name": "setup_ipv4_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "2230-2250",
          "snippet": "static int setup_ipv4_addr(struct lxc_list *ip, int ifindex)\n{\n\tstruct lxc_list *iterator;\n\tstruct lxc_inetdev *inetdev;\n\tint err;\n\n\tlxc_list_for_each(iterator, ip) {\n\n\t\tinetdev = iterator->elem;\n\n\t\terr = lxc_ipv4_addr_add(ifindex, &inetdev->addr,\n\t\t\t\t\t&inetdev->bcast, inetdev->prefix);\n\t\tif (err) {\n\t\t\tERROR(\"failed to setup_ipv4_addr ifindex %d : %s\",\n\t\t\t      ifindex, strerror(-err));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int setup_ipv4_addr(struct lxc_list *ip, int ifindex)\n{\n\tstruct lxc_list *iterator;\n\tstruct lxc_inetdev *inetdev;\n\tint err;\n\n\tlxc_list_for_each(iterator, ip) {\n\n\t\tinetdev = iterator->elem;\n\n\t\terr = lxc_ipv4_addr_add(ifindex, &inetdev->addr,\n\t\t\t\t\t&inetdev->bcast, inetdev->prefix);\n\t\tif (err) {\n\t\t\tERROR(\"failed to setup_ipv4_addr ifindex %d : %s\",\n\t\t\t      ifindex, strerror(-err));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to setup hw address for '%s'\"",
            "current_ifname"
          ],
          "line": 2339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_hw_addr",
          "args": [
            "netdev->hwaddr",
            "current_ifname"
          ],
          "line": 2338
        },
        "resolved": true,
        "details": {
          "function_name": "setup_hw_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "2196-2228",
          "snippet": "static int setup_hw_addr(char *hwaddr, const char *ifname)\n{\n\tstruct sockaddr sockaddr;\n\tstruct ifreq ifr;\n\tint ret, fd, saved_errno;\n\n\tret = lxc_convert_mac(hwaddr, &sockaddr);\n\tif (ret) {\n\t\tERROR(\"mac address '%s' conversion failed : %s\",\n\t\t      hwaddr, strerror(-ret));\n\t\treturn -1;\n\t}\n\n\tmemcpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_name[IFNAMSIZ-1] = '\\0';\n\tmemcpy((char *) &ifr.ifr_hwaddr, (char *) &sockaddr, sizeof(sockaddr));\n\n\tfd = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (fd < 0) {\n\t\tERROR(\"socket failure : %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tret = ioctl(fd, SIOCSIFHWADDR, &ifr);\n\tsaved_errno = errno;\n\tclose(fd);\n\tif (ret)\n\t\tERROR(\"ioctl failure : %s\", strerror(saved_errno));\n\n\tDEBUG(\"mac address '%s' on '%s' has been setup\", hwaddr, ifr.ifr_name);\n\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int setup_hw_addr(char *hwaddr, const char *ifname)\n{\n\tstruct sockaddr sockaddr;\n\tstruct ifreq ifr;\n\tint ret, fd, saved_errno;\n\n\tret = lxc_convert_mac(hwaddr, &sockaddr);\n\tif (ret) {\n\t\tERROR(\"mac address '%s' conversion failed : %s\",\n\t\t      hwaddr, strerror(-ret));\n\t\treturn -1;\n\t}\n\n\tmemcpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_name[IFNAMSIZ-1] = '\\0';\n\tmemcpy((char *) &ifr.ifr_hwaddr, (char *) &sockaddr, sizeof(sockaddr));\n\n\tfd = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (fd < 0) {\n\t\tERROR(\"socket failure : %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tret = ioctl(fd, SIOCSIFHWADDR, &ifr);\n\tsaved_errno = errno;\n\tclose(fd);\n\tif (ret)\n\t\tERROR(\"ioctl failure : %s\", strerror(saved_errno));\n\n\tDEBUG(\"mac address '%s' on '%s' has been setup\", hwaddr, ifr.ifr_name);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"no interface corresponding to index '%d'\"",
            "netdev->ifindex"
          ],
          "line": 2331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_indextoname",
          "args": [
            "netdev->ifindex",
            "current_ifname"
          ],
          "line": 2330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to rename %s->%s : %s\"",
            "ifname",
            "netdev->name",
            "strerror(-err)"
          ],
          "line": 2321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "-err"
          ],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_netdev_rename_by_name",
          "args": [
            "ifname",
            "netdev->name"
          ],
          "line": 2319
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_netdev_rename_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "350-363",
          "snippet": "int lxc_netdev_rename_by_name(const char *oldname, const char *newname)\n{\n\tint len, index;\n\n\tlen = strlen(oldname);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\treturn -EINVAL;\n\n\tindex = if_nametoindex(oldname);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\treturn lxc_netdev_rename_by_index(index, newname);\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_netdev_rename_by_name(const char *oldname, const char *newname)\n{\n\tint len, index;\n\n\tlen = strlen(oldname);\n\tif (len == 1 || len >= IFNAMSIZ)\n\t\treturn -EINVAL;\n\n\tindex = if_nametoindex(oldname);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\treturn lxc_netdev_rename_by_index(index, newname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ifname",
            "netdev->name"
          ],
          "line": 2318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"no interface corresponding to index '%d'\"",
            "netdev->ifindex"
          ],
          "line": 2307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_indextoname",
          "args": [
            "netdev->ifindex",
            "current_ifname"
          ],
          "line": 2306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to get ifindex for %s\"",
            "netdev->link"
          ],
          "line": 2299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_nametoindex",
          "args": [
            "netdev->link"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_nametoindex",
          "args": [
            "netdev->name"
          ],
          "line": 2293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to set the loopback up : %s\"",
            "strerror(-err)"
          ],
          "line": 2286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "-err"
          ],
          "line": 2287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_none(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_none(struct lxc_handler *, struct lxc_netdev *);\n\nstatic int setup_netdev(struct lxc_netdev *netdev)\n{\n\tchar ifname[IFNAMSIZ];\n\tchar *current_ifname = ifname;\n\tint err;\n\n\t/* empty network namespace */\n\tif (!netdev->ifindex) {\n\t\tif (netdev->flags & IFF_UP) {\n\t\t\terr = lxc_netdev_up(\"lo\");\n\t\t\tif (err) {\n\t\t\t\tERROR(\"failed to set the loopback up : %s\",\n\t\t\t\t      strerror(-err));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (netdev->type != LXC_NET_VETH)\n\t\t\treturn 0;\n\t\tnetdev->ifindex = if_nametoindex(netdev->name);\n\t}\n\n\t/* get the new ifindex in case of physical netdev */\n\tif (netdev->type == LXC_NET_PHYS) {\n\t\tif (!(netdev->ifindex = if_nametoindex(netdev->link))) {\n\t\t\tERROR(\"failed to get ifindex for %s\",\n\t\t\t\tnetdev->link);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* retrieve the name of the interface */\n\tif (!if_indextoname(netdev->ifindex, current_ifname)) {\n\t\tERROR(\"no interface corresponding to index '%d'\",\n\t\t      netdev->ifindex);\n\t\treturn -1;\n\t}\n\n\t/* default: let the system to choose one interface name */\n\tif (!netdev->name)\n\t\tnetdev->name = netdev->type == LXC_NET_PHYS ?\n\t\t\tnetdev->link : \"eth%d\";\n\n\t/* rename the interface name */\n\tif (strcmp(ifname, netdev->name) != 0) {\n\t\terr = lxc_netdev_rename_by_name(ifname, netdev->name);\n\t\tif (err) {\n\t\t\tERROR(\"failed to rename %s->%s : %s\", ifname, netdev->name,\n\t\t\t      strerror(-err));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Re-read the name of the interface because its name has changed\n\t * and would be automatically allocated by the system\n\t */\n\tif (!if_indextoname(netdev->ifindex, current_ifname)) {\n\t\tERROR(\"no interface corresponding to index '%d'\",\n\t\t      netdev->ifindex);\n\t\treturn -1;\n\t}\n\n\t/* set a mac address */\n\tif (netdev->hwaddr) {\n\t\tif (setup_hw_addr(netdev->hwaddr, current_ifname)) {\n\t\t\tERROR(\"failed to setup hw address for '%s'\",\n\t\t\t      current_ifname);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* setup ipv4 addresses on the interface */\n\tif (setup_ipv4_addr(&netdev->ipv4, netdev->ifindex)) {\n\t\tERROR(\"failed to setup ip addresses for '%s'\",\n\t\t\t      ifname);\n\t\treturn -1;\n\t}\n\n\t/* setup ipv6 addresses on the interface */\n\tif (setup_ipv6_addr(&netdev->ipv6, netdev->ifindex)) {\n\t\tERROR(\"failed to setup ipv6 addresses for '%s'\",\n\t\t\t      ifname);\n\t\treturn -1;\n\t}\n\n\t/* set the network device up */\n\tif (netdev->flags & IFF_UP) {\n\t\tint err;\n\n\t\terr = lxc_netdev_up(current_ifname);\n\t\tif (err) {\n\t\t\tERROR(\"failed to set '%s' up : %s\", current_ifname,\n\t\t\t      strerror(-err));\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* the network is up, make the loopback up too */\n\t\terr = lxc_netdev_up(\"lo\");\n\t\tif (err) {\n\t\t\tERROR(\"failed to set the loopback up : %s\",\n\t\t\t      strerror(-err));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* We can only set up the default routes after bringing\n\t * up the interface, sine bringing up the interface adds\n\t * the link-local routes and we can't add a default\n\t * route if the gateway is not reachable. */\n\n\t/* setup ipv4 gateway on the interface */\n\tif (netdev->ipv4_gateway) {\n\t\tif (!(netdev->flags & IFF_UP)) {\n\t\t\tERROR(\"Cannot add ipv4 gateway for %s when not bringing up the interface\", ifname);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (lxc_list_empty(&netdev->ipv4)) {\n\t\t\tERROR(\"Cannot add ipv4 gateway for %s when not assigning an address\", ifname);\n\t\t\treturn -1;\n\t\t}\n\n\t\terr = lxc_ipv4_gateway_add(netdev->ifindex, netdev->ipv4_gateway);\n\t\tif (err) {\n\t\t\terr = lxc_ipv4_dest_add(netdev->ifindex, netdev->ipv4_gateway);\n\t\t\tif (err) {\n\t\t\t\tERROR(\"failed to add ipv4 dest for '%s': %s\",\n\t\t\t\t\t      ifname, strerror(-err));\n\t\t\t}\n\n\t\t\terr = lxc_ipv4_gateway_add(netdev->ifindex, netdev->ipv4_gateway);\n\t\t\tif (err) {\n\t\t\t\tERROR(\"failed to setup ipv4 gateway for '%s': %s\",\n\t\t\t\t\t      ifname, strerror(-err));\n\t\t\t\tif (netdev->ipv4_gateway_auto) {\n\t\t\t\t\tchar buf[INET_ADDRSTRLEN];\n\t\t\t\t\tinet_ntop(AF_INET, netdev->ipv4_gateway, buf, sizeof(buf));\n\t\t\t\t\tERROR(\"tried to set autodetected ipv4 gateway '%s'\", buf);\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* setup ipv6 gateway on the interface */\n\tif (netdev->ipv6_gateway) {\n\t\tif (!(netdev->flags & IFF_UP)) {\n\t\t\tERROR(\"Cannot add ipv6 gateway for %s when not bringing up the interface\", ifname);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (lxc_list_empty(&netdev->ipv6) && !IN6_IS_ADDR_LINKLOCAL(netdev->ipv6_gateway)) {\n\t\t\tERROR(\"Cannot add ipv6 gateway for %s when not assigning an address\", ifname);\n\t\t\treturn -1;\n\t\t}\n\n\t\terr = lxc_ipv6_gateway_add(netdev->ifindex, netdev->ipv6_gateway);\n\t\tif (err) {\n\t\t\terr = lxc_ipv6_dest_add(netdev->ifindex, netdev->ipv6_gateway);\n\t\t\tif (err) {\n\t\t\t\tERROR(\"failed to add ipv6 dest for '%s': %s\",\n\t\t\t\t      ifname, strerror(-err));\n\t\t\t}\n\n\t\t\terr = lxc_ipv6_gateway_add(netdev->ifindex, netdev->ipv6_gateway);\n\t\t\tif (err) {\n\t\t\t\tERROR(\"failed to setup ipv6 gateway for '%s': %s\",\n\t\t\t\t\t      ifname, strerror(-err));\n\t\t\t\tif (netdev->ipv6_gateway_auto) {\n\t\t\t\t\tchar buf[INET6_ADDRSTRLEN];\n\t\t\t\t\tinet_ntop(AF_INET6, netdev->ipv6_gateway, buf, sizeof(buf));\n\t\t\t\t\tERROR(\"tried to set autodetected ipv6 gateway '%s'\", buf);\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tDEBUG(\"'%s' has been setup\", current_ifname);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "setup_ipv6_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "2252-2273",
    "snippet": "static int setup_ipv6_addr(struct lxc_list *ip, int ifindex)\n{\n\tstruct lxc_list *iterator;\n\tstruct lxc_inet6dev *inet6dev;\n\tint err;\n\n\tlxc_list_for_each(iterator, ip) {\n\n\t\tinet6dev = iterator->elem;\n\n\t\terr = lxc_ipv6_addr_add(ifindex, &inet6dev->addr,\n\t\t\t\t\t&inet6dev->mcast, &inet6dev->acast,\n\t\t\t\t\tinet6dev->prefix);\n\t\tif (err) {\n\t\t\tERROR(\"failed to setup_ipv6_addr ifindex %d : %s\",\n\t\t\t      ifindex, strerror(-err));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to setup_ipv6_addr ifindex %d : %s\"",
            "ifindex",
            "strerror(-err)"
          ],
          "line": 2266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "-err"
          ],
          "line": 2267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_ipv6_addr_add",
          "args": [
            "ifindex",
            "&inet6dev->addr",
            "&inet6dev->mcast",
            "&inet6dev->acast",
            "inet6dev->prefix"
          ],
          "line": 2262
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_ipv6_addr_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "1091-1096",
          "snippet": "int lxc_ipv6_addr_add(int ifindex, struct in6_addr *addr,\n\t\t      struct in6_addr *mcast,\n\t\t      struct in6_addr *acast, int prefix)\n{\n\treturn ip_addr_add(AF_INET6, ifindex, addr, mcast, acast, prefix);\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_ipv6_addr_add(int ifindex, struct in6_addr *addr,\n\t\t      struct in6_addr *mcast,\n\t\t      struct in6_addr *acast, int prefix)\n{\n\treturn ip_addr_add(AF_INET6, ifindex, addr, mcast, acast, prefix);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "iterator",
            "ip"
          ],
          "line": 2258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int setup_ipv6_addr(struct lxc_list *ip, int ifindex)\n{\n\tstruct lxc_list *iterator;\n\tstruct lxc_inet6dev *inet6dev;\n\tint err;\n\n\tlxc_list_for_each(iterator, ip) {\n\n\t\tinet6dev = iterator->elem;\n\n\t\terr = lxc_ipv6_addr_add(ifindex, &inet6dev->addr,\n\t\t\t\t\t&inet6dev->mcast, &inet6dev->acast,\n\t\t\t\t\tinet6dev->prefix);\n\t\tif (err) {\n\t\t\tERROR(\"failed to setup_ipv6_addr ifindex %d : %s\",\n\t\t\t      ifindex, strerror(-err));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "setup_ipv4_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "2230-2250",
    "snippet": "static int setup_ipv4_addr(struct lxc_list *ip, int ifindex)\n{\n\tstruct lxc_list *iterator;\n\tstruct lxc_inetdev *inetdev;\n\tint err;\n\n\tlxc_list_for_each(iterator, ip) {\n\n\t\tinetdev = iterator->elem;\n\n\t\terr = lxc_ipv4_addr_add(ifindex, &inetdev->addr,\n\t\t\t\t\t&inetdev->bcast, inetdev->prefix);\n\t\tif (err) {\n\t\t\tERROR(\"failed to setup_ipv4_addr ifindex %d : %s\",\n\t\t\t      ifindex, strerror(-err));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to setup_ipv4_addr ifindex %d : %s\"",
            "ifindex",
            "strerror(-err)"
          ],
          "line": 2243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "-err"
          ],
          "line": 2244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_ipv4_addr_add",
          "args": [
            "ifindex",
            "&inetdev->addr",
            "&inetdev->bcast",
            "inetdev->prefix"
          ],
          "line": 2240
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_ipv4_addr_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "1098-1102",
          "snippet": "int lxc_ipv4_addr_add(int ifindex, struct in_addr *addr,\n\t\t      struct in_addr *bcast, int prefix)\n{\n\treturn ip_addr_add(AF_INET, ifindex, addr, bcast, NULL, prefix);\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_ipv4_addr_add(int ifindex, struct in_addr *addr,\n\t\t      struct in_addr *bcast, int prefix)\n{\n\treturn ip_addr_add(AF_INET, ifindex, addr, bcast, NULL, prefix);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "iterator",
            "ip"
          ],
          "line": 2236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int setup_ipv4_addr(struct lxc_list *ip, int ifindex)\n{\n\tstruct lxc_list *iterator;\n\tstruct lxc_inetdev *inetdev;\n\tint err;\n\n\tlxc_list_for_each(iterator, ip) {\n\n\t\tinetdev = iterator->elem;\n\n\t\terr = lxc_ipv4_addr_add(ifindex, &inetdev->addr,\n\t\t\t\t\t&inetdev->bcast, inetdev->prefix);\n\t\tif (err) {\n\t\t\tERROR(\"failed to setup_ipv4_addr ifindex %d : %s\",\n\t\t\t      ifindex, strerror(-err));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "setup_hw_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "2196-2228",
    "snippet": "static int setup_hw_addr(char *hwaddr, const char *ifname)\n{\n\tstruct sockaddr sockaddr;\n\tstruct ifreq ifr;\n\tint ret, fd, saved_errno;\n\n\tret = lxc_convert_mac(hwaddr, &sockaddr);\n\tif (ret) {\n\t\tERROR(\"mac address '%s' conversion failed : %s\",\n\t\t      hwaddr, strerror(-ret));\n\t\treturn -1;\n\t}\n\n\tmemcpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_name[IFNAMSIZ-1] = '\\0';\n\tmemcpy((char *) &ifr.ifr_hwaddr, (char *) &sockaddr, sizeof(sockaddr));\n\n\tfd = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (fd < 0) {\n\t\tERROR(\"socket failure : %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tret = ioctl(fd, SIOCSIFHWADDR, &ifr);\n\tsaved_errno = errno;\n\tclose(fd);\n\tif (ret)\n\t\tERROR(\"ioctl failure : %s\", strerror(saved_errno));\n\n\tDEBUG(\"mac address '%s' on '%s' has been setup\", hwaddr, ifr.ifr_name);\n\n\treturn ret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"mac address '%s' on '%s' has been setup\"",
            "hwaddr",
            "ifr.ifr_name"
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"ioctl failure : %s\"",
            "strerror(saved_errno)"
          ],
          "line": 2223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "saved_errno"
          ],
          "line": 2223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 2221
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "SIOCSIFHWADDR",
            "&ifr"
          ],
          "line": 2219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"socket failure : %s\"",
            "strerror(errno)"
          ],
          "line": 2215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 2215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET",
            "SOCK_DGRAM",
            "0"
          ],
          "line": 2213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *) &ifr.ifr_hwaddr",
            "(char *) &sockaddr",
            "sizeof(sockaddr)"
          ],
          "line": 2211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ifr.ifr_name",
            "ifname",
            "IFNAMSIZ"
          ],
          "line": 2209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"mac address '%s' conversion failed : %s\"",
            "hwaddr",
            "strerror(-ret)"
          ],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "-ret"
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_convert_mac",
          "args": [
            "hwaddr",
            "&sockaddr"
          ],
          "line": 2202
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_convert_mac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "982-1027",
          "snippet": "int lxc_convert_mac(char *macaddr, struct sockaddr *sockaddr)\n{\n\tunsigned char *data;\n\tchar c;\n\tint i = 0;\n\tunsigned val;\n\n\tsockaddr->sa_family = ARPHRD_ETHER;\n\tdata = (unsigned char *)sockaddr->sa_data;\n\n\twhile ((*macaddr != '\\0') && (i < ETH_ALEN)) {\n\t    val = 0;\n\t    c = *macaddr++;\n\t    if (isdigit(c))\n\t\t    val = c - '0';\n\t    else if (c >= 'a' && c <= 'f')\n\t\t    val = c - 'a' + 10;\n\t    else if (c >= 'A' && c <= 'F')\n\t\t    val = c - 'A' + 10;\n\t    else {\n\t\t    return -EINVAL;\n\t    }\n\t    val <<= 4;\n\t    c = *macaddr;\n\t    if (isdigit(c))\n\t\t    val |= c - '0';\n\t    else if (c >= 'a' && c <= 'f')\n\t\t    val |= c - 'a' + 10;\n\t    else if (c >= 'A' && c <= 'F')\n\t\t    val |= c - 'A' + 10;\n\t    else if (c == ':' || c == 0)\n\t\t    val >>= 4;\n\t    else {\n\t\t    return -EINVAL;\n\t    }\n\t    if (c != 0)\n\t\t    macaddr++;\n\t    *data++ = (unsigned char) (val & 0377);\n\t    i++;\n\n\t    if (*macaddr == ':')\n\t\t    macaddr++;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_convert_mac(char *macaddr, struct sockaddr *sockaddr)\n{\n\tunsigned char *data;\n\tchar c;\n\tint i = 0;\n\tunsigned val;\n\n\tsockaddr->sa_family = ARPHRD_ETHER;\n\tdata = (unsigned char *)sockaddr->sa_data;\n\n\twhile ((*macaddr != '\\0') && (i < ETH_ALEN)) {\n\t    val = 0;\n\t    c = *macaddr++;\n\t    if (isdigit(c))\n\t\t    val = c - '0';\n\t    else if (c >= 'a' && c <= 'f')\n\t\t    val = c - 'a' + 10;\n\t    else if (c >= 'A' && c <= 'F')\n\t\t    val = c - 'A' + 10;\n\t    else {\n\t\t    return -EINVAL;\n\t    }\n\t    val <<= 4;\n\t    c = *macaddr;\n\t    if (isdigit(c))\n\t\t    val |= c - '0';\n\t    else if (c >= 'a' && c <= 'f')\n\t\t    val |= c - 'a' + 10;\n\t    else if (c >= 'A' && c <= 'F')\n\t\t    val |= c - 'A' + 10;\n\t    else if (c == ':' || c == 0)\n\t\t    val >>= 4;\n\t    else {\n\t\t    return -EINVAL;\n\t    }\n\t    if (c != 0)\n\t\t    macaddr++;\n\t    *data++ = (unsigned char) (val & 0377);\n\t    i++;\n\n\t    if (*macaddr == ':')\n\t\t    macaddr++;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int setup_hw_addr(char *hwaddr, const char *ifname)\n{\n\tstruct sockaddr sockaddr;\n\tstruct ifreq ifr;\n\tint ret, fd, saved_errno;\n\n\tret = lxc_convert_mac(hwaddr, &sockaddr);\n\tif (ret) {\n\t\tERROR(\"mac address '%s' conversion failed : %s\",\n\t\t      hwaddr, strerror(-ret));\n\t\treturn -1;\n\t}\n\n\tmemcpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_name[IFNAMSIZ-1] = '\\0';\n\tmemcpy((char *) &ifr.ifr_hwaddr, (char *) &sockaddr, sizeof(sockaddr));\n\n\tfd = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (fd < 0) {\n\t\tERROR(\"socket failure : %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tret = ioctl(fd, SIOCSIFHWADDR, &ifr);\n\tsaved_errno = errno;\n\tclose(fd);\n\tif (ret)\n\t\tERROR(\"ioctl failure : %s\", strerror(saved_errno));\n\n\tDEBUG(\"mac address '%s' on '%s' has been setup\", hwaddr, ifr.ifr_name);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "dropcaps_except",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "2149-2194",
    "snippet": "static int dropcaps_except(struct lxc_list *caps)\n{\n\tstruct lxc_list *iterator;\n\tchar *keep_entry;\n\tint i, capid;\n\tint numcaps = lxc_caps_last_cap() + 1;\n\tINFO(\"found %d capabilities\", numcaps);\n\n\tif (numcaps <= 0 || numcaps > 200)\n\t\treturn -1;\n\n\t// caplist[i] is 1 if we keep capability i\n\tint *caplist = alloca(numcaps * sizeof(int));\n\tmemset(caplist, 0, numcaps * sizeof(int));\n\n\tlxc_list_for_each(iterator, caps) {\n\n\t\tkeep_entry = iterator->elem;\n\n\t\tcapid = parse_cap(keep_entry);\n\n\t\tif (capid == -2)\n\t\t\tcontinue;\n\n\t        if (capid < 0) {\n\t\t\tERROR(\"unknown capability %s\", keep_entry);\n\t\t\treturn -1;\n\t\t}\n\n\t\tDEBUG(\"keep capability '%s' (%d)\", keep_entry, capid);\n\n\t\tcaplist[capid] = 1;\n\t}\n\tfor (i=0; i<numcaps; i++) {\n\t\tif (caplist[i])\n\t\t\tcontinue;\n\t\tif (prctl(PR_CAPBSET_DROP, i, 0, 0, 0)) {\n\t\t\tSYSERROR(\"failed to remove capability %d\", i);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tDEBUG(\"capabilities have been setup\");\n\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define PR_CAPBSET_DROP 24"
    ],
    "globals_used": [
      "static int in_caplist(int cap, struct lxc_list *caps);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"capabilities have been setup\""
          ],
          "line": 2191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to remove capability %d\"",
            "i"
          ],
          "line": 2186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prctl",
          "args": [
            "PR_CAPBSET_DROP",
            "i",
            "0",
            "0",
            "0"
          ],
          "line": 2185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"keep capability '%s' (%d)\"",
            "keep_entry",
            "capid"
          ],
          "line": 2178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"unknown capability %s\"",
            "keep_entry"
          ],
          "line": 2174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_cap",
          "args": [
            "keep_entry"
          ],
          "line": 2168
        },
        "resolved": true,
        "details": {
          "function_name": "parse_cap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "2068-2102",
          "snippet": "static int parse_cap(const char *cap)\n{\n\tchar *ptr = NULL;\n\tsize_t i;\n\tint capid = -1;\n\n\tif (!strcmp(cap, \"none\"))\n\t\treturn -2;\n\n\tfor (i = 0; i < sizeof(caps_opt)/sizeof(caps_opt[0]); i++) {\n\n\t\tif (strcmp(cap, caps_opt[i].name))\n\t\t\tcontinue;\n\n\t\tcapid = caps_opt[i].value;\n\t\tbreak;\n\t}\n\n\tif (capid < 0) {\n\t\t/* try to see if it's numeric, so the user may specify\n\t\t * capabilities  that the running kernel knows about but\n\t\t * we don't */\n\t\terrno = 0;\n\t\tcapid = strtol(cap, &ptr, 10);\n\t\tif (!ptr || *ptr != '\\0' || errno != 0)\n\t\t\t/* not a valid number */\n\t\t\tcapid = -1;\n\t\telse if (capid > lxc_caps_last_cap())\n\t\t\t/* we have a number but it's not a valid\n\t\t\t * capability */\n\t\t\tcapid = -1;\n\t}\n\n\treturn capid;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int parse_cap(const char *cap)\n{\n\tchar *ptr = NULL;\n\tsize_t i;\n\tint capid = -1;\n\n\tif (!strcmp(cap, \"none\"))\n\t\treturn -2;\n\n\tfor (i = 0; i < sizeof(caps_opt)/sizeof(caps_opt[0]); i++) {\n\n\t\tif (strcmp(cap, caps_opt[i].name))\n\t\t\tcontinue;\n\n\t\tcapid = caps_opt[i].value;\n\t\tbreak;\n\t}\n\n\tif (capid < 0) {\n\t\t/* try to see if it's numeric, so the user may specify\n\t\t * capabilities  that the running kernel knows about but\n\t\t * we don't */\n\t\terrno = 0;\n\t\tcapid = strtol(cap, &ptr, 10);\n\t\tif (!ptr || *ptr != '\\0' || errno != 0)\n\t\t\t/* not a valid number */\n\t\t\tcapid = -1;\n\t\telse if (capid > lxc_caps_last_cap())\n\t\t\t/* we have a number but it's not a valid\n\t\t\t * capability */\n\t\t\tcapid = -1;\n\t}\n\n\treturn capid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "iterator",
            "caps"
          ],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "caplist",
            "0",
            "numcaps * sizeof(int)"
          ],
          "line": 2162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "numcaps * sizeof(int)"
          ],
          "line": 2161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"found %d capabilities\"",
            "numcaps"
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_caps_last_cap",
          "args": [],
          "line": 2154
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_caps_last_cap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/caps.h",
          "lines": "51-53",
          "snippet": "static inline int lxc_caps_last_cap(void) {\n\treturn 0;\n}",
          "includes": [
            "#include <sys/capability.h>",
            "#include <stdbool.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/capability.h>\n#include <stdbool.h>\n#include \"config.h\"\n\nstatic inline int lxc_caps_last_cap(void) {\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\n#define PR_CAPBSET_DROP 24\n\nstatic int in_caplist(int cap, struct lxc_list *caps);\n\nstatic int dropcaps_except(struct lxc_list *caps)\n{\n\tstruct lxc_list *iterator;\n\tchar *keep_entry;\n\tint i, capid;\n\tint numcaps = lxc_caps_last_cap() + 1;\n\tINFO(\"found %d capabilities\", numcaps);\n\n\tif (numcaps <= 0 || numcaps > 200)\n\t\treturn -1;\n\n\t// caplist[i] is 1 if we keep capability i\n\tint *caplist = alloca(numcaps * sizeof(int));\n\tmemset(caplist, 0, numcaps * sizeof(int));\n\n\tlxc_list_for_each(iterator, caps) {\n\n\t\tkeep_entry = iterator->elem;\n\n\t\tcapid = parse_cap(keep_entry);\n\n\t\tif (capid == -2)\n\t\t\tcontinue;\n\n\t        if (capid < 0) {\n\t\t\tERROR(\"unknown capability %s\", keep_entry);\n\t\t\treturn -1;\n\t\t}\n\n\t\tDEBUG(\"keep capability '%s' (%d)\", keep_entry, capid);\n\n\t\tcaplist[capid] = 1;\n\t}\n\tfor (i=0; i<numcaps; i++) {\n\t\tif (caplist[i])\n\t\t\tcontinue;\n\t\tif (prctl(PR_CAPBSET_DROP, i, 0, 0, 0)) {\n\t\t\tSYSERROR(\"failed to remove capability %d\", i);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tDEBUG(\"capabilities have been setup\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "setup_caps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "2118-2147",
    "snippet": "static int setup_caps(struct lxc_list *caps)\n{\n\tstruct lxc_list *iterator;\n\tchar *drop_entry;\n\tint capid;\n\n\tlxc_list_for_each(iterator, caps) {\n\n\t\tdrop_entry = iterator->elem;\n\n\t\tcapid = parse_cap(drop_entry);\n\n\t        if (capid < 0) {\n\t\t\tERROR(\"unknown capability %s\", drop_entry);\n\t\t\treturn -1;\n\t\t}\n\n\t\tDEBUG(\"drop capability '%s' (%d)\", drop_entry, capid);\n\n\t\tif (prctl(PR_CAPBSET_DROP, capid, 0, 0, 0)) {\n\t\t\tSYSERROR(\"failed to remove %s capability\", drop_entry);\n\t\t\treturn -1;\n\t\t}\n\n\t}\n\n\tDEBUG(\"capabilities have been setup\");\n\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define PR_CAPBSET_DROP 24"
    ],
    "globals_used": [
      "static int in_caplist(int cap, struct lxc_list *caps);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"capabilities have been setup\""
          ],
          "line": 2144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to remove %s capability\"",
            "drop_entry"
          ],
          "line": 2138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prctl",
          "args": [
            "PR_CAPBSET_DROP",
            "capid",
            "0",
            "0",
            "0"
          ],
          "line": 2137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"drop capability '%s' (%d)\"",
            "drop_entry",
            "capid"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"unknown capability %s\"",
            "drop_entry"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_cap",
          "args": [
            "drop_entry"
          ],
          "line": 2128
        },
        "resolved": true,
        "details": {
          "function_name": "parse_cap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "2068-2102",
          "snippet": "static int parse_cap(const char *cap)\n{\n\tchar *ptr = NULL;\n\tsize_t i;\n\tint capid = -1;\n\n\tif (!strcmp(cap, \"none\"))\n\t\treturn -2;\n\n\tfor (i = 0; i < sizeof(caps_opt)/sizeof(caps_opt[0]); i++) {\n\n\t\tif (strcmp(cap, caps_opt[i].name))\n\t\t\tcontinue;\n\n\t\tcapid = caps_opt[i].value;\n\t\tbreak;\n\t}\n\n\tif (capid < 0) {\n\t\t/* try to see if it's numeric, so the user may specify\n\t\t * capabilities  that the running kernel knows about but\n\t\t * we don't */\n\t\terrno = 0;\n\t\tcapid = strtol(cap, &ptr, 10);\n\t\tif (!ptr || *ptr != '\\0' || errno != 0)\n\t\t\t/* not a valid number */\n\t\t\tcapid = -1;\n\t\telse if (capid > lxc_caps_last_cap())\n\t\t\t/* we have a number but it's not a valid\n\t\t\t * capability */\n\t\t\tcapid = -1;\n\t}\n\n\treturn capid;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int parse_cap(const char *cap)\n{\n\tchar *ptr = NULL;\n\tsize_t i;\n\tint capid = -1;\n\n\tif (!strcmp(cap, \"none\"))\n\t\treturn -2;\n\n\tfor (i = 0; i < sizeof(caps_opt)/sizeof(caps_opt[0]); i++) {\n\n\t\tif (strcmp(cap, caps_opt[i].name))\n\t\t\tcontinue;\n\n\t\tcapid = caps_opt[i].value;\n\t\tbreak;\n\t}\n\n\tif (capid < 0) {\n\t\t/* try to see if it's numeric, so the user may specify\n\t\t * capabilities  that the running kernel knows about but\n\t\t * we don't */\n\t\terrno = 0;\n\t\tcapid = strtol(cap, &ptr, 10);\n\t\tif (!ptr || *ptr != '\\0' || errno != 0)\n\t\t\t/* not a valid number */\n\t\t\tcapid = -1;\n\t\telse if (capid > lxc_caps_last_cap())\n\t\t\t/* we have a number but it's not a valid\n\t\t\t * capability */\n\t\t\tcapid = -1;\n\t}\n\n\treturn capid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "iterator",
            "caps"
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\n#define PR_CAPBSET_DROP 24\n\nstatic int in_caplist(int cap, struct lxc_list *caps);\n\nstatic int setup_caps(struct lxc_list *caps)\n{\n\tstruct lxc_list *iterator;\n\tchar *drop_entry;\n\tint capid;\n\n\tlxc_list_for_each(iterator, caps) {\n\n\t\tdrop_entry = iterator->elem;\n\n\t\tcapid = parse_cap(drop_entry);\n\n\t        if (capid < 0) {\n\t\t\tERROR(\"unknown capability %s\", drop_entry);\n\t\t\treturn -1;\n\t\t}\n\n\t\tDEBUG(\"drop capability '%s' (%d)\", drop_entry, capid);\n\n\t\tif (prctl(PR_CAPBSET_DROP, capid, 0, 0, 0)) {\n\t\t\tSYSERROR(\"failed to remove %s capability\", drop_entry);\n\t\t\treturn -1;\n\t\t}\n\n\t}\n\n\tDEBUG(\"capabilities have been setup\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "in_caplist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "2104-2116",
    "snippet": "int in_caplist(int cap, struct lxc_list *caps)\n{\n\tstruct lxc_list *iterator;\n\tint capid;\n\n\tlxc_list_for_each(iterator, caps) {\n\t\tcapid = parse_cap(iterator->elem);\n\t\tif (capid == cap)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int in_caplist(int cap, struct lxc_list *caps);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "parse_cap",
          "args": [
            "iterator->elem"
          ],
          "line": 2110
        },
        "resolved": true,
        "details": {
          "function_name": "parse_cap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "2068-2102",
          "snippet": "static int parse_cap(const char *cap)\n{\n\tchar *ptr = NULL;\n\tsize_t i;\n\tint capid = -1;\n\n\tif (!strcmp(cap, \"none\"))\n\t\treturn -2;\n\n\tfor (i = 0; i < sizeof(caps_opt)/sizeof(caps_opt[0]); i++) {\n\n\t\tif (strcmp(cap, caps_opt[i].name))\n\t\t\tcontinue;\n\n\t\tcapid = caps_opt[i].value;\n\t\tbreak;\n\t}\n\n\tif (capid < 0) {\n\t\t/* try to see if it's numeric, so the user may specify\n\t\t * capabilities  that the running kernel knows about but\n\t\t * we don't */\n\t\terrno = 0;\n\t\tcapid = strtol(cap, &ptr, 10);\n\t\tif (!ptr || *ptr != '\\0' || errno != 0)\n\t\t\t/* not a valid number */\n\t\t\tcapid = -1;\n\t\telse if (capid > lxc_caps_last_cap())\n\t\t\t/* we have a number but it's not a valid\n\t\t\t * capability */\n\t\t\tcapid = -1;\n\t}\n\n\treturn capid;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int parse_cap(const char *cap)\n{\n\tchar *ptr = NULL;\n\tsize_t i;\n\tint capid = -1;\n\n\tif (!strcmp(cap, \"none\"))\n\t\treturn -2;\n\n\tfor (i = 0; i < sizeof(caps_opt)/sizeof(caps_opt[0]); i++) {\n\n\t\tif (strcmp(cap, caps_opt[i].name))\n\t\t\tcontinue;\n\n\t\tcapid = caps_opt[i].value;\n\t\tbreak;\n\t}\n\n\tif (capid < 0) {\n\t\t/* try to see if it's numeric, so the user may specify\n\t\t * capabilities  that the running kernel knows about but\n\t\t * we don't */\n\t\terrno = 0;\n\t\tcapid = strtol(cap, &ptr, 10);\n\t\tif (!ptr || *ptr != '\\0' || errno != 0)\n\t\t\t/* not a valid number */\n\t\t\tcapid = -1;\n\t\telse if (capid > lxc_caps_last_cap())\n\t\t\t/* we have a number but it's not a valid\n\t\t\t * capability */\n\t\t\tcapid = -1;\n\t}\n\n\treturn capid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "iterator",
            "caps"
          ],
          "line": 2109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int in_caplist(int cap, struct lxc_list *caps);\n\nint in_caplist(int cap, struct lxc_list *caps)\n{\n\tstruct lxc_list *iterator;\n\tint capid;\n\n\tlxc_list_for_each(iterator, caps) {\n\t\tcapid = parse_cap(iterator->elem);\n\t\tif (capid == cap)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "parse_cap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "2068-2102",
    "snippet": "static int parse_cap(const char *cap)\n{\n\tchar *ptr = NULL;\n\tsize_t i;\n\tint capid = -1;\n\n\tif (!strcmp(cap, \"none\"))\n\t\treturn -2;\n\n\tfor (i = 0; i < sizeof(caps_opt)/sizeof(caps_opt[0]); i++) {\n\n\t\tif (strcmp(cap, caps_opt[i].name))\n\t\t\tcontinue;\n\n\t\tcapid = caps_opt[i].value;\n\t\tbreak;\n\t}\n\n\tif (capid < 0) {\n\t\t/* try to see if it's numeric, so the user may specify\n\t\t * capabilities  that the running kernel knows about but\n\t\t * we don't */\n\t\terrno = 0;\n\t\tcapid = strtol(cap, &ptr, 10);\n\t\tif (!ptr || *ptr != '\\0' || errno != 0)\n\t\t\t/* not a valid number */\n\t\t\tcapid = -1;\n\t\telse if (capid > lxc_caps_last_cap())\n\t\t\t/* we have a number but it's not a valid\n\t\t\t * capability */\n\t\t\tcapid = -1;\n\t}\n\n\treturn capid;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_caps_last_cap",
          "args": [],
          "line": 2095
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_caps_last_cap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/caps.h",
          "lines": "51-53",
          "snippet": "static inline int lxc_caps_last_cap(void) {\n\treturn 0;\n}",
          "includes": [
            "#include <sys/capability.h>",
            "#include <stdbool.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/capability.h>\n#include <stdbool.h>\n#include \"config.h\"\n\nstatic inline int lxc_caps_last_cap(void) {\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "cap",
            "&ptr",
            "10"
          ],
          "line": 2091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cap",
            "caps_opt[i].name"
          ],
          "line": 2079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cap",
            "\"none\""
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int parse_cap(const char *cap)\n{\n\tchar *ptr = NULL;\n\tsize_t i;\n\tint capid = -1;\n\n\tif (!strcmp(cap, \"none\"))\n\t\treturn -2;\n\n\tfor (i = 0; i < sizeof(caps_opt)/sizeof(caps_opt[0]); i++) {\n\n\t\tif (strcmp(cap, caps_opt[i].name))\n\t\t\tcontinue;\n\n\t\tcapid = caps_opt[i].value;\n\t\tbreak;\n\t}\n\n\tif (capid < 0) {\n\t\t/* try to see if it's numeric, so the user may specify\n\t\t * capabilities  that the running kernel knows about but\n\t\t * we don't */\n\t\terrno = 0;\n\t\tcapid = strtol(cap, &ptr, 10);\n\t\tif (!ptr || *ptr != '\\0' || errno != 0)\n\t\t\t/* not a valid number */\n\t\t\tcapid = -1;\n\t\telse if (capid > lxc_caps_last_cap())\n\t\t\t/* we have a number but it's not a valid\n\t\t\t * capability */\n\t\t\tcapid = -1;\n\t}\n\n\treturn capid;\n}"
  },
  {
    "function_name": "setup_mount_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "2051-2066",
    "snippet": "static int setup_mount_entries(const struct lxc_rootfs *rootfs,\n\t\t\t       struct lxc_list *mount, const char *lxc_name,\n\t\t\t       const char *lxc_path)\n{\n\tFILE *file;\n\tint ret;\n\n\tfile = make_anonymous_mount_file(mount);\n\tif (!file)\n\t\treturn -1;\n\n\tret = mount_file_entries(rootfs, file, lxc_name, lxc_path);\n\n\tfclose(file);\n\treturn ret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "file"
          ],
          "line": 2064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount_file_entries",
          "args": [
            "rootfs",
            "file",
            "lxc_name",
            "lxc_path"
          ],
          "line": 2062
        },
        "resolved": true,
        "details": {
          "function_name": "mount_file_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1957-1988",
          "snippet": "static int mount_file_entries(const struct lxc_rootfs *rootfs, FILE *file,\n\tconst char *lxc_name, const char *lxc_path)\n{\n\tstruct mntent mntent;\n\tchar buf[4096];\n\tint ret = -1;\n\n\twhile (getmntent_r(file, &mntent, buf, sizeof(buf))) {\n\n\t\tif (!rootfs->path) {\n\t\t\tif (mount_entry_on_systemfs(&mntent))\n\t\t\t\tgoto out;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* We have a separate root, mounts are relative to it */\n\t\tif (mntent.mnt_dir[0] != '/') {\n\t\t\tif (mount_entry_on_relative_rootfs(&mntent, rootfs, lxc_name, lxc_path))\n\t\t\t\tgoto out;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (mount_entry_on_absolute_rootfs(&mntent, rootfs, lxc_name, lxc_path))\n\t\t\tgoto out;\n\t}\n\n\tret = 0;\n\n\tINFO(\"mount points have been setup\");\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int mount_file_entries(const struct lxc_rootfs *rootfs, FILE *file,\n\tconst char *lxc_name, const char *lxc_path)\n{\n\tstruct mntent mntent;\n\tchar buf[4096];\n\tint ret = -1;\n\n\twhile (getmntent_r(file, &mntent, buf, sizeof(buf))) {\n\n\t\tif (!rootfs->path) {\n\t\t\tif (mount_entry_on_systemfs(&mntent))\n\t\t\t\tgoto out;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* We have a separate root, mounts are relative to it */\n\t\tif (mntent.mnt_dir[0] != '/') {\n\t\t\tif (mount_entry_on_relative_rootfs(&mntent, rootfs, lxc_name, lxc_path))\n\t\t\t\tgoto out;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (mount_entry_on_absolute_rootfs(&mntent, rootfs, lxc_name, lxc_path))\n\t\t\tgoto out;\n\t}\n\n\tret = 0;\n\n\tINFO(\"mount points have been setup\");\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_anonymous_mount_file",
          "args": [
            "mount"
          ],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "make_anonymous_mount_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "2011-2049",
          "snippet": "FILE *make_anonymous_mount_file(struct lxc_list *mount)\n{\n\tint ret;\n\tchar *mount_entry;\n\tstruct lxc_list *iterator;\n\tFILE *file;\n\tint fd = -1;\n\n\tfd = memfd_create(\"lxc_mount_file\", MFD_CLOEXEC);\n\tif (fd < 0) {\n\t\tif (errno != ENOSYS)\n\t\t\treturn NULL;\n\t\tfile = tmpfile();\n\t} else {\n\t\tfile = fdopen(fd, \"r+\");\n\t}\n\n\tif (!file) {\n\t\tint saved_errno = errno;\n\t\tif (fd != -1)\n\t\t\tclose(fd);\n\t\tERROR(\"Could not create mount entry file: %s.\", strerror(saved_errno));\n\t\treturn NULL;\n\t}\n\n\tlxc_list_for_each(iterator, mount) {\n\t\tmount_entry = iterator->elem;\n\t\tret = fprintf(file, \"%s\\n\", mount_entry);\n\t\tif (ret < strlen(mount_entry))\n\t\t\tWARN(\"Could not write mount entry to anonymous mount file.\");\n\t}\n\n\tif (fseek(file, 0, SEEK_SET) < 0) {\n\t\tfclose(file);\n\t\treturn NULL;\n\t}\n\n\treturn file;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MFD_CLOEXEC 0x0001U"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\n#define MFD_CLOEXEC 0x0001U\n\nFILE *make_anonymous_mount_file(struct lxc_list *mount)\n{\n\tint ret;\n\tchar *mount_entry;\n\tstruct lxc_list *iterator;\n\tFILE *file;\n\tint fd = -1;\n\n\tfd = memfd_create(\"lxc_mount_file\", MFD_CLOEXEC);\n\tif (fd < 0) {\n\t\tif (errno != ENOSYS)\n\t\t\treturn NULL;\n\t\tfile = tmpfile();\n\t} else {\n\t\tfile = fdopen(fd, \"r+\");\n\t}\n\n\tif (!file) {\n\t\tint saved_errno = errno;\n\t\tif (fd != -1)\n\t\t\tclose(fd);\n\t\tERROR(\"Could not create mount entry file: %s.\", strerror(saved_errno));\n\t\treturn NULL;\n\t}\n\n\tlxc_list_for_each(iterator, mount) {\n\t\tmount_entry = iterator->elem;\n\t\tret = fprintf(file, \"%s\\n\", mount_entry);\n\t\tif (ret < strlen(mount_entry))\n\t\t\tWARN(\"Could not write mount entry to anonymous mount file.\");\n\t}\n\n\tif (fseek(file, 0, SEEK_SET) < 0) {\n\t\tfclose(file);\n\t\treturn NULL;\n\t}\n\n\treturn file;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int setup_mount_entries(const struct lxc_rootfs *rootfs,\n\t\t\t       struct lxc_list *mount, const char *lxc_name,\n\t\t\t       const char *lxc_path)\n{\n\tFILE *file;\n\tint ret;\n\n\tfile = make_anonymous_mount_file(mount);\n\tif (!file)\n\t\treturn -1;\n\n\tret = mount_file_entries(rootfs, file, lxc_name, lxc_path);\n\n\tfclose(file);\n\treturn ret;\n}"
  },
  {
    "function_name": "make_anonymous_mount_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "2011-2049",
    "snippet": "FILE *make_anonymous_mount_file(struct lxc_list *mount)\n{\n\tint ret;\n\tchar *mount_entry;\n\tstruct lxc_list *iterator;\n\tFILE *file;\n\tint fd = -1;\n\n\tfd = memfd_create(\"lxc_mount_file\", MFD_CLOEXEC);\n\tif (fd < 0) {\n\t\tif (errno != ENOSYS)\n\t\t\treturn NULL;\n\t\tfile = tmpfile();\n\t} else {\n\t\tfile = fdopen(fd, \"r+\");\n\t}\n\n\tif (!file) {\n\t\tint saved_errno = errno;\n\t\tif (fd != -1)\n\t\t\tclose(fd);\n\t\tERROR(\"Could not create mount entry file: %s.\", strerror(saved_errno));\n\t\treturn NULL;\n\t}\n\n\tlxc_list_for_each(iterator, mount) {\n\t\tmount_entry = iterator->elem;\n\t\tret = fprintf(file, \"%s\\n\", mount_entry);\n\t\tif (ret < strlen(mount_entry))\n\t\t\tWARN(\"Could not write mount entry to anonymous mount file.\");\n\t}\n\n\tif (fseek(file, 0, SEEK_SET) < 0) {\n\t\tfclose(file);\n\t\treturn NULL;\n\t}\n\n\treturn file;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define MFD_CLOEXEC 0x0001U"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "file"
          ],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fseek",
          "args": [
            "file",
            "0",
            "SEEK_SET"
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Could not write mount entry to anonymous mount file.\""
          ],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "mount_entry"
          ],
          "line": 2039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "file",
            "\"%s\\n\"",
            "mount_entry"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "iterator",
            "mount"
          ],
          "line": 2036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Could not create mount entry file: %s.\"",
            "strerror(saved_errno)"
          ],
          "line": 2032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "saved_errno"
          ],
          "line": 2032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 2031
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdopen",
          "args": [
            "fd",
            "\"r+\""
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tmpfile",
          "args": [],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memfd_create",
          "args": [
            "\"lxc_mount_file\"",
            "MFD_CLOEXEC"
          ],
          "line": 2019
        },
        "resolved": true,
        "details": {
          "function_name": "memfd_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "185-223",
          "snippet": "static int memfd_create(const char *name, unsigned int flags) {\n\t#ifndef __NR_memfd_create\n\t\t#if defined __i386__\n\t\t\t#define __NR_memfd_create 356\n\t\t#elif defined __x86_64__\n\t\t\t#define __NR_memfd_create 319\n\t\t#elif defined __arm__\n\t\t\t#define __NR_memfd_create 385\n\t\t#elif defined __aarch64__\n\t\t\t#define __NR_memfd_create 279\n\t\t#elif defined __s390__\n\t\t\t#define __NR_memfd_create 350\n\t\t#elif defined __powerpc__\n\t\t\t#define __NR_memfd_create 360\n\t\t#elif defined __sparc__\n\t\t\t#define __NR_memfd_create 348\n\t\t#elif defined __blackfin__\n\t\t\t#define __NR_memfd_create 390\n\t\t#elif defined __ia64__\n\t\t\t#define __NR_memfd_create 1340\n\t\t#elif defined _MIPS_SIM\n\t\t\t#if _MIPS_SIM == _MIPS_SIM_ABI32\n\t\t\t\t#define __NR_memfd_create 4354\n\t\t\t#endif\n\t\t\t#if _MIPS_SIM == _MIPS_SIM_NABI32\n\t\t\t\t#define __NR_memfd_create 6318\n\t\t\t#endif\n\t\t\t#if _MIPS_SIM == _MIPS_SIM_ABI64\n\t\t\t\t#define __NR_memfd_create 5314\n\t\t\t#endif\n\t\t#endif\n\t#endif\n\t#ifdef __NR_memfd_create\n\treturn syscall(__NR_memfd_create, name, flags);\n\t#else\n\terrno = ENOSYS;\n\treturn -1;\n\t#endif\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define __NR_memfd_create 5314",
            "#define __NR_memfd_create 6318",
            "#define __NR_memfd_create 4354",
            "#define __NR_memfd_create 1340",
            "#define __NR_memfd_create 390",
            "#define __NR_memfd_create 348",
            "#define __NR_memfd_create 360",
            "#define __NR_memfd_create 350",
            "#define __NR_memfd_create 279",
            "#define __NR_memfd_create 385",
            "#define __NR_memfd_create 319",
            "#define __NR_memfd_create 356"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\n#define __NR_memfd_create 5314\n#define __NR_memfd_create 6318\n#define __NR_memfd_create 4354\n#define __NR_memfd_create 1340\n#define __NR_memfd_create 390\n#define __NR_memfd_create 348\n#define __NR_memfd_create 360\n#define __NR_memfd_create 350\n#define __NR_memfd_create 279\n#define __NR_memfd_create 385\n#define __NR_memfd_create 319\n#define __NR_memfd_create 356\n\nstatic int memfd_create(const char *name, unsigned int flags) {\n\t#ifndef __NR_memfd_create\n\t\t#if defined __i386__\n\t\t\t#define __NR_memfd_create 356\n\t\t#elif defined __x86_64__\n\t\t\t#define __NR_memfd_create 319\n\t\t#elif defined __arm__\n\t\t\t#define __NR_memfd_create 385\n\t\t#elif defined __aarch64__\n\t\t\t#define __NR_memfd_create 279\n\t\t#elif defined __s390__\n\t\t\t#define __NR_memfd_create 350\n\t\t#elif defined __powerpc__\n\t\t\t#define __NR_memfd_create 360\n\t\t#elif defined __sparc__\n\t\t\t#define __NR_memfd_create 348\n\t\t#elif defined __blackfin__\n\t\t\t#define __NR_memfd_create 390\n\t\t#elif defined __ia64__\n\t\t\t#define __NR_memfd_create 1340\n\t\t#elif defined _MIPS_SIM\n\t\t\t#if _MIPS_SIM == _MIPS_SIM_ABI32\n\t\t\t\t#define __NR_memfd_create 4354\n\t\t\t#endif\n\t\t\t#if _MIPS_SIM == _MIPS_SIM_NABI32\n\t\t\t\t#define __NR_memfd_create 6318\n\t\t\t#endif\n\t\t\t#if _MIPS_SIM == _MIPS_SIM_ABI64\n\t\t\t\t#define __NR_memfd_create 5314\n\t\t\t#endif\n\t\t#endif\n\t#endif\n\t#ifdef __NR_memfd_create\n\treturn syscall(__NR_memfd_create, name, flags);\n\t#else\n\terrno = ENOSYS;\n\treturn -1;\n\t#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\n#define MFD_CLOEXEC 0x0001U\n\nFILE *make_anonymous_mount_file(struct lxc_list *mount)\n{\n\tint ret;\n\tchar *mount_entry;\n\tstruct lxc_list *iterator;\n\tFILE *file;\n\tint fd = -1;\n\n\tfd = memfd_create(\"lxc_mount_file\", MFD_CLOEXEC);\n\tif (fd < 0) {\n\t\tif (errno != ENOSYS)\n\t\t\treturn NULL;\n\t\tfile = tmpfile();\n\t} else {\n\t\tfile = fdopen(fd, \"r+\");\n\t}\n\n\tif (!file) {\n\t\tint saved_errno = errno;\n\t\tif (fd != -1)\n\t\t\tclose(fd);\n\t\tERROR(\"Could not create mount entry file: %s.\", strerror(saved_errno));\n\t\treturn NULL;\n\t}\n\n\tlxc_list_for_each(iterator, mount) {\n\t\tmount_entry = iterator->elem;\n\t\tret = fprintf(file, \"%s\\n\", mount_entry);\n\t\tif (ret < strlen(mount_entry))\n\t\t\tWARN(\"Could not write mount entry to anonymous mount file.\");\n\t}\n\n\tif (fseek(file, 0, SEEK_SET) < 0) {\n\t\tfclose(file);\n\t\treturn NULL;\n\t}\n\n\treturn file;\n}"
  },
  {
    "function_name": "setup_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "1990-2009",
    "snippet": "static int setup_mount(const struct lxc_rootfs *rootfs, const char *fstab,\n\tconst char *lxc_name, const char *lxc_path)\n{\n\tFILE *file;\n\tint ret;\n\n\tif (!fstab)\n\t\treturn 0;\n\n\tfile = setmntent(fstab, \"r\");\n\tif (!file) {\n\t\tSYSERROR(\"failed to use '%s'\", fstab);\n\t\treturn -1;\n\t}\n\n\tret = mount_file_entries(rootfs, file, lxc_name, lxc_path);\n\n\tendmntent(file);\n\treturn ret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "endmntent",
          "args": [
            "file"
          ],
          "line": 2007
        },
        "resolved": true,
        "details": {
          "function_name": "endmntent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/lxcmntent.c",
          "lines": "166-171",
          "snippet": "int endmntent (FILE *stream)\n{\n    if (stream) /* SunOS 4.x allows for NULL stream */\n    fclose (stream);\n    return 1; /* SunOS 4.x says to always return 1 */\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <string.h>\n#include <stdio.h>\n\nint endmntent (FILE *stream)\n{\n    if (stream) /* SunOS 4.x allows for NULL stream */\n    fclose (stream);\n    return 1; /* SunOS 4.x says to always return 1 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "mount_file_entries",
          "args": [
            "rootfs",
            "file",
            "lxc_name",
            "lxc_path"
          ],
          "line": 2005
        },
        "resolved": true,
        "details": {
          "function_name": "mount_file_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1957-1988",
          "snippet": "static int mount_file_entries(const struct lxc_rootfs *rootfs, FILE *file,\n\tconst char *lxc_name, const char *lxc_path)\n{\n\tstruct mntent mntent;\n\tchar buf[4096];\n\tint ret = -1;\n\n\twhile (getmntent_r(file, &mntent, buf, sizeof(buf))) {\n\n\t\tif (!rootfs->path) {\n\t\t\tif (mount_entry_on_systemfs(&mntent))\n\t\t\t\tgoto out;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* We have a separate root, mounts are relative to it */\n\t\tif (mntent.mnt_dir[0] != '/') {\n\t\t\tif (mount_entry_on_relative_rootfs(&mntent, rootfs, lxc_name, lxc_path))\n\t\t\t\tgoto out;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (mount_entry_on_absolute_rootfs(&mntent, rootfs, lxc_name, lxc_path))\n\t\t\tgoto out;\n\t}\n\n\tret = 0;\n\n\tINFO(\"mount points have been setup\");\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int mount_file_entries(const struct lxc_rootfs *rootfs, FILE *file,\n\tconst char *lxc_name, const char *lxc_path)\n{\n\tstruct mntent mntent;\n\tchar buf[4096];\n\tint ret = -1;\n\n\twhile (getmntent_r(file, &mntent, buf, sizeof(buf))) {\n\n\t\tif (!rootfs->path) {\n\t\t\tif (mount_entry_on_systemfs(&mntent))\n\t\t\t\tgoto out;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* We have a separate root, mounts are relative to it */\n\t\tif (mntent.mnt_dir[0] != '/') {\n\t\t\tif (mount_entry_on_relative_rootfs(&mntent, rootfs, lxc_name, lxc_path))\n\t\t\t\tgoto out;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (mount_entry_on_absolute_rootfs(&mntent, rootfs, lxc_name, lxc_path))\n\t\t\tgoto out;\n\t}\n\n\tret = 0;\n\n\tINFO(\"mount points have been setup\");\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to use '%s'\"",
            "fstab"
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setmntent",
          "args": [
            "fstab",
            "\"r\""
          ],
          "line": 1999
        },
        "resolved": true,
        "details": {
          "function_name": "setmntent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/lxcmntent.c",
          "lines": "151-162",
          "snippet": "FILE *setmntent (const char *file, const char *mode)\n{\n    /* Extend the mode parameter with \"c\" to disable cancellation in the\n    I/O functions and \"e\" to set FD_CLOEXEC. */\n    size_t modelen = strlen (mode);\n    char newmode[modelen + 3];\n    memcpy (newmode, mode, modelen);\n    memcpy (newmode + modelen, \"ce\", 3);\n    FILE *result = fopen (file, newmode);\n\n    return result;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <string.h>\n#include <stdio.h>\n\nFILE *setmntent (const char *file, const char *mode)\n{\n    /* Extend the mode parameter with \"c\" to disable cancellation in the\n    I/O functions and \"e\" to set FD_CLOEXEC. */\n    size_t modelen = strlen (mode);\n    char newmode[modelen + 3];\n    memcpy (newmode, mode, modelen);\n    memcpy (newmode + modelen, \"ce\", 3);\n    FILE *result = fopen (file, newmode);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int setup_mount(const struct lxc_rootfs *rootfs, const char *fstab,\n\tconst char *lxc_name, const char *lxc_path)\n{\n\tFILE *file;\n\tint ret;\n\n\tif (!fstab)\n\t\treturn 0;\n\n\tfile = setmntent(fstab, \"r\");\n\tif (!file) {\n\t\tSYSERROR(\"failed to use '%s'\", fstab);\n\t\treturn -1;\n\t}\n\n\tret = mount_file_entries(rootfs, file, lxc_name, lxc_path);\n\n\tendmntent(file);\n\treturn ret;\n}"
  },
  {
    "function_name": "mount_file_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "1957-1988",
    "snippet": "static int mount_file_entries(const struct lxc_rootfs *rootfs, FILE *file,\n\tconst char *lxc_name, const char *lxc_path)\n{\n\tstruct mntent mntent;\n\tchar buf[4096];\n\tint ret = -1;\n\n\twhile (getmntent_r(file, &mntent, buf, sizeof(buf))) {\n\n\t\tif (!rootfs->path) {\n\t\t\tif (mount_entry_on_systemfs(&mntent))\n\t\t\t\tgoto out;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* We have a separate root, mounts are relative to it */\n\t\tif (mntent.mnt_dir[0] != '/') {\n\t\t\tif (mount_entry_on_relative_rootfs(&mntent, rootfs, lxc_name, lxc_path))\n\t\t\t\tgoto out;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (mount_entry_on_absolute_rootfs(&mntent, rootfs, lxc_name, lxc_path))\n\t\t\tgoto out;\n\t}\n\n\tret = 0;\n\n\tINFO(\"mount points have been setup\");\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"mount points have been setup\""
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount_entry_on_absolute_rootfs",
          "args": [
            "&mntent",
            "rootfs",
            "lxc_name",
            "lxc_path"
          ],
          "line": 1979
        },
        "resolved": true,
        "details": {
          "function_name": "mount_entry_on_absolute_rootfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1891-1937",
          "snippet": "static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n\t\t\t\t\t  const struct lxc_rootfs *rootfs,\n\t\t\t\t\t  const char *lxc_name,\n\t\t\t\t\t  const char *lxc_path)\n{\n\tchar *aux;\n\tchar path[MAXPATHLEN];\n\tint r, ret = 0, offset;\n\tconst char *lxcpath;\n\n\tlxcpath = lxc_global_config_value(\"lxc.lxcpath\");\n\tif (!lxcpath) {\n\t\tERROR(\"Out of memory\");\n\t\treturn -1;\n\t}\n\n\t/* if rootfs->path is a blockdev path, allow container fstab to\n\t * use $lxcpath/CN/rootfs as the target prefix */\n\tr = snprintf(path, MAXPATHLEN, \"%s/%s/rootfs\", lxcpath, lxc_name);\n\tif (r < 0 || r >= MAXPATHLEN)\n\t\tgoto skipvarlib;\n\n\taux = strstr(mntent->mnt_dir, path);\n\tif (aux) {\n\t\toffset = strlen(path);\n\t\tgoto skipabs;\n\t}\n\nskipvarlib:\n\taux = strstr(mntent->mnt_dir, rootfs->path);\n\tif (!aux) {\n\t\tWARN(\"ignoring mount point '%s'\", mntent->mnt_dir);\n\t\treturn ret;\n\t}\n\toffset = strlen(rootfs->path);\n\nskipabs:\n\n\tr = snprintf(path, MAXPATHLEN, \"%s/%s\", rootfs->mount,\n\t\t aux + offset);\n\tif (r < 0 || r >= MAXPATHLEN) {\n\t\tWARN(\"pathnme too long for '%s'\", mntent->mnt_dir);\n\t\treturn -1;\n\t}\n\n\treturn mount_entry_on_generic(mntent, path, rootfs, lxc_name, lxc_path);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n\t\t\t\t\t  const struct lxc_rootfs *rootfs,\n\t\t\t\t\t  const char *lxc_name,\n\t\t\t\t\t  const char *lxc_path)\n{\n\tchar *aux;\n\tchar path[MAXPATHLEN];\n\tint r, ret = 0, offset;\n\tconst char *lxcpath;\n\n\tlxcpath = lxc_global_config_value(\"lxc.lxcpath\");\n\tif (!lxcpath) {\n\t\tERROR(\"Out of memory\");\n\t\treturn -1;\n\t}\n\n\t/* if rootfs->path is a blockdev path, allow container fstab to\n\t * use $lxcpath/CN/rootfs as the target prefix */\n\tr = snprintf(path, MAXPATHLEN, \"%s/%s/rootfs\", lxcpath, lxc_name);\n\tif (r < 0 || r >= MAXPATHLEN)\n\t\tgoto skipvarlib;\n\n\taux = strstr(mntent->mnt_dir, path);\n\tif (aux) {\n\t\toffset = strlen(path);\n\t\tgoto skipabs;\n\t}\n\nskipvarlib:\n\taux = strstr(mntent->mnt_dir, rootfs->path);\n\tif (!aux) {\n\t\tWARN(\"ignoring mount point '%s'\", mntent->mnt_dir);\n\t\treturn ret;\n\t}\n\toffset = strlen(rootfs->path);\n\nskipabs:\n\n\tr = snprintf(path, MAXPATHLEN, \"%s/%s\", rootfs->mount,\n\t\t aux + offset);\n\tif (r < 0 || r >= MAXPATHLEN) {\n\t\tWARN(\"pathnme too long for '%s'\", mntent->mnt_dir);\n\t\treturn -1;\n\t}\n\n\treturn mount_entry_on_generic(mntent, path, rootfs, lxc_name, lxc_path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mount_entry_on_relative_rootfs",
          "args": [
            "&mntent",
            "rootfs",
            "lxc_name",
            "lxc_path"
          ],
          "line": 1974
        },
        "resolved": true,
        "details": {
          "function_name": "mount_entry_on_relative_rootfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1939-1955",
          "snippet": "static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n\t\t\t\t\t  const struct lxc_rootfs *rootfs,\n\t\t\t\t\t  const char *lxc_name,\n\t\t\t\t\t  const char *lxc_path)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\n\t/* relative to root mount point */\n\tret = snprintf(path, sizeof(path), \"%s/%s\", rootfs->mount, mntent->mnt_dir);\n\tif (ret < 0 || ret >= sizeof(path)) {\n\t\tERROR(\"path name too long\");\n\t\treturn -1;\n\t}\n\n\treturn mount_entry_on_generic(mntent, path, rootfs, lxc_name, lxc_path);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int mount_entry_on_relative_rootfs(struct mntent *mntent,\n\t\t\t\t\t  const struct lxc_rootfs *rootfs,\n\t\t\t\t\t  const char *lxc_name,\n\t\t\t\t\t  const char *lxc_path)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\n\t/* relative to root mount point */\n\tret = snprintf(path, sizeof(path), \"%s/%s\", rootfs->mount, mntent->mnt_dir);\n\tif (ret < 0 || ret >= sizeof(path)) {\n\t\tERROR(\"path name too long\");\n\t\treturn -1;\n\t}\n\n\treturn mount_entry_on_generic(mntent, path, rootfs, lxc_name, lxc_path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mount_entry_on_systemfs",
          "args": [
            "&mntent"
          ],
          "line": 1967
        },
        "resolved": true,
        "details": {
          "function_name": "mount_entry_on_systemfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1871-1889",
          "snippet": "static inline int mount_entry_on_systemfs(struct mntent *mntent)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\n\t/* For containers created without a rootfs all mounts are treated as\n\t * absolute paths starting at / on the host. */\n\tif (mntent->mnt_dir[0] != '/')\n\t\tret = snprintf(path, sizeof(path), \"/%s\", mntent->mnt_dir);\n\telse\n\t\tret = snprintf(path, sizeof(path), \"%s\", mntent->mnt_dir);\n\n\tif (ret < 0 || ret >= sizeof(path)) {\n\t\tERROR(\"path name too long\");\n\t\treturn -1;\n\t}\n\n\treturn mount_entry_on_generic(mntent, path, NULL, NULL, NULL);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic inline int mount_entry_on_systemfs(struct mntent *mntent)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\n\t/* For containers created without a rootfs all mounts are treated as\n\t * absolute paths starting at / on the host. */\n\tif (mntent->mnt_dir[0] != '/')\n\t\tret = snprintf(path, sizeof(path), \"/%s\", mntent->mnt_dir);\n\telse\n\t\tret = snprintf(path, sizeof(path), \"%s\", mntent->mnt_dir);\n\n\tif (ret < 0 || ret >= sizeof(path)) {\n\t\tERROR(\"path name too long\");\n\t\treturn -1;\n\t}\n\n\treturn mount_entry_on_generic(mntent, path, NULL, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getmntent_r",
          "args": [
            "file",
            "&mntent",
            "buf",
            "sizeof(buf)"
          ],
          "line": 1964
        },
        "resolved": true,
        "details": {
          "function_name": "getmntent_r",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/lxcmntent.c",
          "lines": "76-132",
          "snippet": "struct mntent *getmntent_r (FILE *stream, struct mntent *mp, char *buffer, int bufsiz)\n{\n    char *cp;\n    char *head;\n\n    do\n    {\n        char *end_ptr;\n\n        if (fgets (buffer, bufsiz, stream) == NULL)\n        {\n            return NULL;\n        }\n\n        end_ptr = strchr (buffer, '\\n');\n        if (end_ptr != NULL) /* chop newline */\n            *end_ptr = '\\0';\n        else\n        {\n            /* Not the whole line was read. Do it now but forget it. */\n            char tmp[1024];\n            while (fgets (tmp, sizeof tmp, stream) != NULL)\n                if (strchr (tmp, '\\n') != NULL)\n                    break;\n        }\n\n        head = buffer + strspn (buffer, \" \\t\");\n        /* skip empty lines and comment lines: */\n    }\n    while (head[0] == '\\0' || head[0] == '#');\n\n    cp = strsep (&head, \" \\t\");\n    mp->mnt_fsname = cp != NULL ? decode_name (cp) : (char *) \"\";\n    if (head)\n        head += strspn (head, \" \\t\");\n    cp = strsep (&head, \" \\t\");\n    mp->mnt_dir = cp != NULL ? decode_name (cp) : (char *) \"\";\n    if (head)\n        head += strspn (head, \" \\t\");\n    cp = strsep (&head, \" \\t\");\n    mp->mnt_type = cp != NULL ? decode_name (cp) : (char *) \"\";\n    if (head)\n        head += strspn (head, \" \\t\");\n    cp = strsep (&head, \" \\t\");\n    mp->mnt_opts = cp != NULL ? decode_name (cp) : (char *) \"\";\n    switch (head ? sscanf (head, \" %d %d \", &mp->mnt_freq, &mp->mnt_passno) : 0)\n    {\n        case 0:\n            mp->mnt_freq = 0;\n        case 1:\n            mp->mnt_passno = 0;\n        case 2:\n            break;\n    }\n\n    return mp;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <string.h>\n#include <stdio.h>\n\nstruct mntent *getmntent_r (FILE *stream, struct mntent *mp, char *buffer, int bufsiz)\n{\n    char *cp;\n    char *head;\n\n    do\n    {\n        char *end_ptr;\n\n        if (fgets (buffer, bufsiz, stream) == NULL)\n        {\n            return NULL;\n        }\n\n        end_ptr = strchr (buffer, '\\n');\n        if (end_ptr != NULL) /* chop newline */\n            *end_ptr = '\\0';\n        else\n        {\n            /* Not the whole line was read. Do it now but forget it. */\n            char tmp[1024];\n            while (fgets (tmp, sizeof tmp, stream) != NULL)\n                if (strchr (tmp, '\\n') != NULL)\n                    break;\n        }\n\n        head = buffer + strspn (buffer, \" \\t\");\n        /* skip empty lines and comment lines: */\n    }\n    while (head[0] == '\\0' || head[0] == '#');\n\n    cp = strsep (&head, \" \\t\");\n    mp->mnt_fsname = cp != NULL ? decode_name (cp) : (char *) \"\";\n    if (head)\n        head += strspn (head, \" \\t\");\n    cp = strsep (&head, \" \\t\");\n    mp->mnt_dir = cp != NULL ? decode_name (cp) : (char *) \"\";\n    if (head)\n        head += strspn (head, \" \\t\");\n    cp = strsep (&head, \" \\t\");\n    mp->mnt_type = cp != NULL ? decode_name (cp) : (char *) \"\";\n    if (head)\n        head += strspn (head, \" \\t\");\n    cp = strsep (&head, \" \\t\");\n    mp->mnt_opts = cp != NULL ? decode_name (cp) : (char *) \"\";\n    switch (head ? sscanf (head, \" %d %d \", &mp->mnt_freq, &mp->mnt_passno) : 0)\n    {\n        case 0:\n            mp->mnt_freq = 0;\n        case 1:\n            mp->mnt_passno = 0;\n        case 2:\n            break;\n    }\n\n    return mp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int mount_file_entries(const struct lxc_rootfs *rootfs, FILE *file,\n\tconst char *lxc_name, const char *lxc_path)\n{\n\tstruct mntent mntent;\n\tchar buf[4096];\n\tint ret = -1;\n\n\twhile (getmntent_r(file, &mntent, buf, sizeof(buf))) {\n\n\t\tif (!rootfs->path) {\n\t\t\tif (mount_entry_on_systemfs(&mntent))\n\t\t\t\tgoto out;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* We have a separate root, mounts are relative to it */\n\t\tif (mntent.mnt_dir[0] != '/') {\n\t\t\tif (mount_entry_on_relative_rootfs(&mntent, rootfs, lxc_name, lxc_path))\n\t\t\t\tgoto out;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (mount_entry_on_absolute_rootfs(&mntent, rootfs, lxc_name, lxc_path))\n\t\t\tgoto out;\n\t}\n\n\tret = 0;\n\n\tINFO(\"mount points have been setup\");\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "mount_entry_on_relative_rootfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "1939-1955",
    "snippet": "static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n\t\t\t\t\t  const struct lxc_rootfs *rootfs,\n\t\t\t\t\t  const char *lxc_name,\n\t\t\t\t\t  const char *lxc_path)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\n\t/* relative to root mount point */\n\tret = snprintf(path, sizeof(path), \"%s/%s\", rootfs->mount, mntent->mnt_dir);\n\tif (ret < 0 || ret >= sizeof(path)) {\n\t\tERROR(\"path name too long\");\n\t\treturn -1;\n\t}\n\n\treturn mount_entry_on_generic(mntent, path, rootfs, lxc_name, lxc_path);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_entry_on_generic",
          "args": [
            "mntent",
            "path",
            "rootfs",
            "lxc_name",
            "lxc_path"
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "mount_entry_on_generic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1838-1869",
          "snippet": "static inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"path name too long\""
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "sizeof(path)",
            "\"%s/%s\"",
            "rootfs->mount",
            "mntent->mnt_dir"
          ],
          "line": 1948
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int mount_entry_on_relative_rootfs(struct mntent *mntent,\n\t\t\t\t\t  const struct lxc_rootfs *rootfs,\n\t\t\t\t\t  const char *lxc_name,\n\t\t\t\t\t  const char *lxc_path)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\n\t/* relative to root mount point */\n\tret = snprintf(path, sizeof(path), \"%s/%s\", rootfs->mount, mntent->mnt_dir);\n\tif (ret < 0 || ret >= sizeof(path)) {\n\t\tERROR(\"path name too long\");\n\t\treturn -1;\n\t}\n\n\treturn mount_entry_on_generic(mntent, path, rootfs, lxc_name, lxc_path);\n}"
  },
  {
    "function_name": "mount_entry_on_absolute_rootfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "1891-1937",
    "snippet": "static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n\t\t\t\t\t  const struct lxc_rootfs *rootfs,\n\t\t\t\t\t  const char *lxc_name,\n\t\t\t\t\t  const char *lxc_path)\n{\n\tchar *aux;\n\tchar path[MAXPATHLEN];\n\tint r, ret = 0, offset;\n\tconst char *lxcpath;\n\n\tlxcpath = lxc_global_config_value(\"lxc.lxcpath\");\n\tif (!lxcpath) {\n\t\tERROR(\"Out of memory\");\n\t\treturn -1;\n\t}\n\n\t/* if rootfs->path is a blockdev path, allow container fstab to\n\t * use $lxcpath/CN/rootfs as the target prefix */\n\tr = snprintf(path, MAXPATHLEN, \"%s/%s/rootfs\", lxcpath, lxc_name);\n\tif (r < 0 || r >= MAXPATHLEN)\n\t\tgoto skipvarlib;\n\n\taux = strstr(mntent->mnt_dir, path);\n\tif (aux) {\n\t\toffset = strlen(path);\n\t\tgoto skipabs;\n\t}\n\nskipvarlib:\n\taux = strstr(mntent->mnt_dir, rootfs->path);\n\tif (!aux) {\n\t\tWARN(\"ignoring mount point '%s'\", mntent->mnt_dir);\n\t\treturn ret;\n\t}\n\toffset = strlen(rootfs->path);\n\nskipabs:\n\n\tr = snprintf(path, MAXPATHLEN, \"%s/%s\", rootfs->mount,\n\t\t aux + offset);\n\tif (r < 0 || r >= MAXPATHLEN) {\n\t\tWARN(\"pathnme too long for '%s'\", mntent->mnt_dir);\n\t\treturn -1;\n\t}\n\n\treturn mount_entry_on_generic(mntent, path, rootfs, lxc_name, lxc_path);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_entry_on_generic",
          "args": [
            "mntent",
            "path",
            "rootfs",
            "lxc_name",
            "lxc_path"
          ],
          "line": 1936
        },
        "resolved": true,
        "details": {
          "function_name": "mount_entry_on_generic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1838-1869",
          "snippet": "static inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"pathnme too long for '%s'\"",
            "mntent->mnt_dir"
          ],
          "line": 1932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "MAXPATHLEN",
            "\"%s/%s\"",
            "rootfs->mount",
            "aux + offset"
          ],
          "line": 1929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "rootfs->path"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"ignoring mount point '%s'\"",
            "mntent->mnt_dir"
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "mntent->mnt_dir",
            "rootfs->path"
          ],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "mntent->mnt_dir",
            "path"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "MAXPATHLEN",
            "\"%s/%s/rootfs\"",
            "lxcpath",
            "lxc_name"
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Out of memory\""
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_global_config_value",
          "args": [
            "\"lxc.lxcpath\""
          ],
          "line": 1901
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_global_config_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "88-247",
          "snippet": "const char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nconst char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n\t\t\t\t\t  const struct lxc_rootfs *rootfs,\n\t\t\t\t\t  const char *lxc_name,\n\t\t\t\t\t  const char *lxc_path)\n{\n\tchar *aux;\n\tchar path[MAXPATHLEN];\n\tint r, ret = 0, offset;\n\tconst char *lxcpath;\n\n\tlxcpath = lxc_global_config_value(\"lxc.lxcpath\");\n\tif (!lxcpath) {\n\t\tERROR(\"Out of memory\");\n\t\treturn -1;\n\t}\n\n\t/* if rootfs->path is a blockdev path, allow container fstab to\n\t * use $lxcpath/CN/rootfs as the target prefix */\n\tr = snprintf(path, MAXPATHLEN, \"%s/%s/rootfs\", lxcpath, lxc_name);\n\tif (r < 0 || r >= MAXPATHLEN)\n\t\tgoto skipvarlib;\n\n\taux = strstr(mntent->mnt_dir, path);\n\tif (aux) {\n\t\toffset = strlen(path);\n\t\tgoto skipabs;\n\t}\n\nskipvarlib:\n\taux = strstr(mntent->mnt_dir, rootfs->path);\n\tif (!aux) {\n\t\tWARN(\"ignoring mount point '%s'\", mntent->mnt_dir);\n\t\treturn ret;\n\t}\n\toffset = strlen(rootfs->path);\n\nskipabs:\n\n\tr = snprintf(path, MAXPATHLEN, \"%s/%s\", rootfs->mount,\n\t\t aux + offset);\n\tif (r < 0 || r >= MAXPATHLEN) {\n\t\tWARN(\"pathnme too long for '%s'\", mntent->mnt_dir);\n\t\treturn -1;\n\t}\n\n\treturn mount_entry_on_generic(mntent, path, rootfs, lxc_name, lxc_path);\n}"
  },
  {
    "function_name": "mount_entry_on_systemfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "1871-1889",
    "snippet": "static inline int mount_entry_on_systemfs(struct mntent *mntent)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\n\t/* For containers created without a rootfs all mounts are treated as\n\t * absolute paths starting at / on the host. */\n\tif (mntent->mnt_dir[0] != '/')\n\t\tret = snprintf(path, sizeof(path), \"/%s\", mntent->mnt_dir);\n\telse\n\t\tret = snprintf(path, sizeof(path), \"%s\", mntent->mnt_dir);\n\n\tif (ret < 0 || ret >= sizeof(path)) {\n\t\tERROR(\"path name too long\");\n\t\treturn -1;\n\t}\n\n\treturn mount_entry_on_generic(mntent, path, NULL, NULL, NULL);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_entry_on_generic",
          "args": [
            "mntent",
            "path",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 1888
        },
        "resolved": true,
        "details": {
          "function_name": "mount_entry_on_generic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1838-1869",
          "snippet": "static inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"path name too long\""
          ],
          "line": 1884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "sizeof(path)",
            "\"%s\"",
            "mntent->mnt_dir"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "sizeof(path)",
            "\"/%s\"",
            "mntent->mnt_dir"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic inline int mount_entry_on_systemfs(struct mntent *mntent)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\n\t/* For containers created without a rootfs all mounts are treated as\n\t * absolute paths starting at / on the host. */\n\tif (mntent->mnt_dir[0] != '/')\n\t\tret = snprintf(path, sizeof(path), \"/%s\", mntent->mnt_dir);\n\telse\n\t\tret = snprintf(path, sizeof(path), \"%s\", mntent->mnt_dir);\n\n\tif (ret < 0 || ret >= sizeof(path)) {\n\t\tERROR(\"path name too long\");\n\t\treturn -1;\n\t}\n\n\treturn mount_entry_on_generic(mntent, path, NULL, NULL, NULL);\n}"
  },
  {
    "function_name": "mount_entry_on_generic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "1838-1869",
    "snippet": "static inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "mntdata"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4619-4628",
          "snippet": "static void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mount_entry",
          "args": [
            "mntent->mnt_fsname",
            "path",
            "mntent->mnt_type",
            "mntflags",
            "mntdata",
            "optional",
            "dev",
            "rootfs_path"
          ],
          "line": 1864
        },
        "resolved": true,
        "details": {
          "function_name": "mount_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1693-1768",
          "snippet": "static int mount_entry(const char *fsname, const char *target,\n\t\t       const char *fstype, unsigned long mountflags,\n\t\t       const char *data, int optional, int dev, const char *rootfs)\n{\n#ifdef HAVE_STATVFS\n\tstruct statvfs sb;\n#endif\n\n\tif (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {\n\t\tif (optional) {\n\t\t\tINFO(\"failed to mount '%s' on '%s' (optional): %s\", fsname,\n\t\t\t     target, strerror(errno));\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tSYSERROR(\"failed to mount '%s' on '%s'\", fsname, target);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif ((mountflags & MS_REMOUNT) || (mountflags & MS_BIND)) {\n\t\tDEBUG(\"remounting %s on %s to respect bind or remount options\",\n\t\t      fsname ? fsname : \"(none)\", target ? target : \"(none)\");\n\t\tunsigned long rqd_flags = 0;\n\t\tif (mountflags & MS_RDONLY)\n\t\t\trqd_flags |= MS_RDONLY;\n#ifdef HAVE_STATVFS\n\t\tif (statvfs(fsname, &sb) == 0) {\n\t\t\tunsigned long required_flags = rqd_flags;\n\t\t\tif (sb.f_flag & MS_NOSUID)\n\t\t\t\trequired_flags |= MS_NOSUID;\n\t\t\tif (sb.f_flag & MS_NODEV && !dev)\n\t\t\t\trequired_flags |= MS_NODEV;\n\t\t\tif (sb.f_flag & MS_RDONLY)\n\t\t\t\trequired_flags |= MS_RDONLY;\n\t\t\tif (sb.f_flag & MS_NOEXEC)\n\t\t\t\trequired_flags |= MS_NOEXEC;\n\t\t\tDEBUG(\"(at remount) flags for %s was %lu, required extra flags are %lu\", fsname, sb.f_flag, required_flags);\n\t\t\t/*\n\t\t\t * If this was a bind mount request, and required_flags\n\t\t\t * does not have any flags which are not already in\n\t\t\t * mountflags, then skip the remount\n\t\t\t */\n\t\t\tif (!(mountflags & MS_REMOUNT)) {\n\t\t\t\tif (!(required_flags & ~mountflags) && rqd_flags == 0) {\n\t\t\t\t\tDEBUG(\"mountflags already was %lu, skipping remount\",\n\t\t\t\t\t\tmountflags);\n\t\t\t\t\tgoto skipremount;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmountflags |= required_flags;\n\t\t}\n#endif\n\n\t\tif (mount(fsname, target, fstype,\n\t\t\t  mountflags | MS_REMOUNT, data) < 0) {\n\t\t\tif (optional) {\n\t\t\t\tINFO(\"failed to mount '%s' on '%s' (optional): %s\",\n\t\t\t\t\t fsname, target, strerror(errno));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSYSERROR(\"failed to mount '%s' on '%s'\",\n\t\t\t\t\t fsname, target);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef HAVE_STATVFS\nskipremount:\n#endif\n\tDEBUG(\"mounted '%s' on '%s', type '%s'\", fsname, target, fstype);\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int mount_entry(const char *fsname, const char *target,\n\t\t       const char *fstype, unsigned long mountflags,\n\t\t       const char *data, int optional, int dev, const char *rootfs)\n{\n#ifdef HAVE_STATVFS\n\tstruct statvfs sb;\n#endif\n\n\tif (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {\n\t\tif (optional) {\n\t\t\tINFO(\"failed to mount '%s' on '%s' (optional): %s\", fsname,\n\t\t\t     target, strerror(errno));\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tSYSERROR(\"failed to mount '%s' on '%s'\", fsname, target);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif ((mountflags & MS_REMOUNT) || (mountflags & MS_BIND)) {\n\t\tDEBUG(\"remounting %s on %s to respect bind or remount options\",\n\t\t      fsname ? fsname : \"(none)\", target ? target : \"(none)\");\n\t\tunsigned long rqd_flags = 0;\n\t\tif (mountflags & MS_RDONLY)\n\t\t\trqd_flags |= MS_RDONLY;\n#ifdef HAVE_STATVFS\n\t\tif (statvfs(fsname, &sb) == 0) {\n\t\t\tunsigned long required_flags = rqd_flags;\n\t\t\tif (sb.f_flag & MS_NOSUID)\n\t\t\t\trequired_flags |= MS_NOSUID;\n\t\t\tif (sb.f_flag & MS_NODEV && !dev)\n\t\t\t\trequired_flags |= MS_NODEV;\n\t\t\tif (sb.f_flag & MS_RDONLY)\n\t\t\t\trequired_flags |= MS_RDONLY;\n\t\t\tif (sb.f_flag & MS_NOEXEC)\n\t\t\t\trequired_flags |= MS_NOEXEC;\n\t\t\tDEBUG(\"(at remount) flags for %s was %lu, required extra flags are %lu\", fsname, sb.f_flag, required_flags);\n\t\t\t/*\n\t\t\t * If this was a bind mount request, and required_flags\n\t\t\t * does not have any flags which are not already in\n\t\t\t * mountflags, then skip the remount\n\t\t\t */\n\t\t\tif (!(mountflags & MS_REMOUNT)) {\n\t\t\t\tif (!(required_flags & ~mountflags) && rqd_flags == 0) {\n\t\t\t\t\tDEBUG(\"mountflags already was %lu, skipping remount\",\n\t\t\t\t\t\tmountflags);\n\t\t\t\t\tgoto skipremount;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmountflags |= required_flags;\n\t\t}\n#endif\n\n\t\tif (mount(fsname, target, fstype,\n\t\t\t  mountflags | MS_REMOUNT, data) < 0) {\n\t\t\tif (optional) {\n\t\t\t\tINFO(\"failed to mount '%s' on '%s' (optional): %s\",\n\t\t\t\t\t fsname, target, strerror(errno));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSYSERROR(\"failed to mount '%s' on '%s'\",\n\t\t\t\t\t fsname, target);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef HAVE_STATVFS\nskipremount:\n#endif\n\tDEBUG(\"mounted '%s' on '%s', type '%s'\", fsname, target, fstype);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_mntopts",
          "args": [
            "mntent->mnt_opts",
            "&mntflags",
            "&mntdata"
          ],
          "line": 1859
        },
        "resolved": true,
        "details": {
          "function_name": "parse_mntopts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1629-1666",
          "snippet": "int parse_mntopts(const char *mntopts, unsigned long *mntflags,\n\t\t\t char **mntdata)\n{\n\tchar *s, *data;\n\tchar *p, *saveptr = NULL;\n\n\t*mntdata = NULL;\n\t*mntflags = 0L;\n\n\tif (!mntopts)\n\t\treturn 0;\n\n\ts = strdup(mntopts);\n\tif (!s) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\treturn -1;\n\t}\n\n\tdata = malloc(strlen(s) + 1);\n\tif (!data) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\tfree(s);\n\t\treturn -1;\n\t}\n\t*data = 0;\n\n\tfor (p = strtok_r(s, \",\", &saveptr); p != NULL;\n\t     p = strtok_r(NULL, \",\", &saveptr))\n\t\tparse_mntopt(p, mntflags, &data);\n\n\tif (*data)\n\t\t*mntdata = data;\n\telse\n\t\tfree(data);\n\tfree(s);\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint parse_mntopts(const char *mntopts, unsigned long *mntflags,\n\t\t\t char **mntdata)\n{\n\tchar *s, *data;\n\tchar *p, *saveptr = NULL;\n\n\t*mntdata = NULL;\n\t*mntflags = 0L;\n\n\tif (!mntopts)\n\t\treturn 0;\n\n\ts = strdup(mntopts);\n\tif (!s) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\treturn -1;\n\t}\n\n\tdata = malloc(strlen(s) + 1);\n\tif (!data) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\tfree(s);\n\t\treturn -1;\n\t}\n\t*data = 0;\n\n\tfor (p = strtok_r(s, \",\", &saveptr); p != NULL;\n\t     p = strtok_r(NULL, \",\", &saveptr))\n\t\tparse_mntopt(p, mntflags, &data);\n\n\tif (*data)\n\t\t*mntdata = data;\n\telse\n\t\tfree(data);\n\tfree(s);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cull_mntent_opt",
          "args": [
            "mntent"
          ],
          "line": 1857
        },
        "resolved": true,
        "details": {
          "function_name": "cull_mntent_opt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1773-1793",
          "snippet": "static void cull_mntent_opt(struct mntent *mntent)\n{\n\tint i;\n\tchar *p, *p2;\n\tchar *list[] = {\"create=dir\",\n\t\t\t\"create=file\",\n\t\t\t\"optional\",\n\t\t\tNULL };\n\n\tfor (i=0; list[i]; i++) {\n\t\tif (!(p = strstr(mntent->mnt_opts, list[i])))\n\t\t\tcontinue;\n\t\tp2 = strchr(p, ',');\n\t\tif (!p2) {\n\t\t\t/* no more mntopts, so just chop it here */\n\t\t\t*p = '\\0';\n\t\t\tcontinue;\n\t\t}\n\t\tmemmove(p, p2+1, strlen(p2+1)+1);\n\t}\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void cull_mntent_opt(struct mntent *mntent)\n{\n\tint i;\n\tchar *p, *p2;\n\tchar *list[] = {\"create=dir\",\n\t\t\t\"create=file\",\n\t\t\t\"optional\",\n\t\t\tNULL };\n\n\tfor (i=0; list[i]; i++) {\n\t\tif (!(p = strstr(mntent->mnt_opts, list[i])))\n\t\t\tcontinue;\n\t\tp2 = strchr(p, ',');\n\t\tif (!p2) {\n\t\t\t/* no more mntopts, so just chop it here */\n\t\t\t*p = '\\0';\n\t\t\tcontinue;\n\t\t}\n\t\tmemmove(p, p2+1, strlen(p2+1)+1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mount_entry_create_dir_file",
          "args": [
            "mntent",
            "path",
            "rootfs",
            "lxc_name",
            "lxc_path"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "mount_entry_create_dir_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1795-1834",
          "snippet": "static int mount_entry_create_dir_file(const struct mntent *mntent,\n\t\t\t\t       const char* path, const struct lxc_rootfs *rootfs,\n\t\t\t\t       const char *lxc_name, const char *lxc_path)\n{\n\tchar *pathdirname = NULL;\n\tint ret = 0;\n\tFILE *pathfile = NULL;\n\n\tif (strncmp(mntent->mnt_type, \"overlay\", 7) == 0) {\n\t\tif (ovl_mkdir(mntent, rootfs, lxc_name, lxc_path) < 0)\n\t\t\treturn -1;\n\t} else if (strncmp(mntent->mnt_type, \"aufs\", 4) == 0) {\n\t\tif (aufs_mkdir(mntent, rootfs, lxc_name, lxc_path) < 0)\n\t\t\treturn -1;\n\t}\n\n\tif (hasmntopt(mntent, \"create=dir\")) {\n\t\tif (mkdir_p(path, 0755) < 0) {\n\t\t\tWARN(\"Failed to create mount target '%s'\", path);\n\t\t\tret = -1;\n\t\t}\n\t}\n\n\tif (hasmntopt(mntent, \"create=file\") && access(path, F_OK)) {\n\t\tpathdirname = strdup(path);\n\t\tpathdirname = dirname(pathdirname);\n\t\tif (mkdir_p(pathdirname, 0755) < 0) {\n\t\t\tWARN(\"Failed to create target directory\");\n\t\t}\n\t\tpathfile = fopen(path, \"wb\");\n\t\tif (!pathfile) {\n\t\t\tWARN(\"Failed to create mount target '%s'\", path);\n\t\t\tret = -1;\n\t\t} else {\n\t\t\tfclose(pathfile);\n\t\t}\n\t}\n\tfree(pathdirname);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int mount_entry_create_dir_file(const struct mntent *mntent,\n\t\t\t\t       const char* path, const struct lxc_rootfs *rootfs,\n\t\t\t\t       const char *lxc_name, const char *lxc_path)\n{\n\tchar *pathdirname = NULL;\n\tint ret = 0;\n\tFILE *pathfile = NULL;\n\n\tif (strncmp(mntent->mnt_type, \"overlay\", 7) == 0) {\n\t\tif (ovl_mkdir(mntent, rootfs, lxc_name, lxc_path) < 0)\n\t\t\treturn -1;\n\t} else if (strncmp(mntent->mnt_type, \"aufs\", 4) == 0) {\n\t\tif (aufs_mkdir(mntent, rootfs, lxc_name, lxc_path) < 0)\n\t\t\treturn -1;\n\t}\n\n\tif (hasmntopt(mntent, \"create=dir\")) {\n\t\tif (mkdir_p(path, 0755) < 0) {\n\t\t\tWARN(\"Failed to create mount target '%s'\", path);\n\t\t\tret = -1;\n\t\t}\n\t}\n\n\tif (hasmntopt(mntent, \"create=file\") && access(path, F_OK)) {\n\t\tpathdirname = strdup(path);\n\t\tpathdirname = dirname(pathdirname);\n\t\tif (mkdir_p(pathdirname, 0755) < 0) {\n\t\t\tWARN(\"Failed to create target directory\");\n\t\t}\n\t\tpathfile = fopen(path, \"wb\");\n\t\tif (!pathfile) {\n\t\t\tWARN(\"Failed to create mount target '%s'\", path);\n\t\t\tret = -1;\n\t\t} else {\n\t\t\tfclose(pathfile);\n\t\t}\n\t}\n\tfree(pathdirname);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hasmntopt",
          "args": [
            "mntent",
            "\"dev\""
          ],
          "line": 1846
        },
        "resolved": true,
        "details": {
          "function_name": "hasmntopt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/lxcmntent.c",
          "lines": "175-193",
          "snippet": "char *hasmntopt (const struct mntent *mnt, const char *opt)\n{\n    const size_t optlen = strlen (opt);\n    char *rest = mnt->mnt_opts, *p;\n\n    while ((p = strstr (rest, opt)) != NULL)\n    {\n        if ((p == rest || p[-1] == ',')\n            && (p[optlen] == '\\0' || p[optlen] == '=' || p[optlen] == ','))\n            return p;\n\n        rest = strchr (p, ',');\n        if (rest == NULL)\n            break;\n        ++rest;\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <string.h>\n#include <stdio.h>\n\nchar *hasmntopt (const struct mntent *mnt, const char *opt)\n{\n    const size_t optlen = strlen (opt);\n    char *rest = mnt->mnt_opts, *p;\n\n    while ((p = strstr (rest, opt)) != NULL)\n    {\n        if ((p == rest || p[-1] == ',')\n            && (p[optlen] == '\\0' || p[optlen] == '=' || p[optlen] == ','))\n            return p;\n\n        rest = strchr (p, ',');\n        if (rest == NULL)\n            break;\n        ++rest;\n    }\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}"
  },
  {
    "function_name": "mount_entry_create_dir_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "1795-1834",
    "snippet": "static int mount_entry_create_dir_file(const struct mntent *mntent,\n\t\t\t\t       const char* path, const struct lxc_rootfs *rootfs,\n\t\t\t\t       const char *lxc_name, const char *lxc_path)\n{\n\tchar *pathdirname = NULL;\n\tint ret = 0;\n\tFILE *pathfile = NULL;\n\n\tif (strncmp(mntent->mnt_type, \"overlay\", 7) == 0) {\n\t\tif (ovl_mkdir(mntent, rootfs, lxc_name, lxc_path) < 0)\n\t\t\treturn -1;\n\t} else if (strncmp(mntent->mnt_type, \"aufs\", 4) == 0) {\n\t\tif (aufs_mkdir(mntent, rootfs, lxc_name, lxc_path) < 0)\n\t\t\treturn -1;\n\t}\n\n\tif (hasmntopt(mntent, \"create=dir\")) {\n\t\tif (mkdir_p(path, 0755) < 0) {\n\t\t\tWARN(\"Failed to create mount target '%s'\", path);\n\t\t\tret = -1;\n\t\t}\n\t}\n\n\tif (hasmntopt(mntent, \"create=file\") && access(path, F_OK)) {\n\t\tpathdirname = strdup(path);\n\t\tpathdirname = dirname(pathdirname);\n\t\tif (mkdir_p(pathdirname, 0755) < 0) {\n\t\t\tWARN(\"Failed to create target directory\");\n\t\t}\n\t\tpathfile = fopen(path, \"wb\");\n\t\tif (!pathfile) {\n\t\t\tWARN(\"Failed to create mount target '%s'\", path);\n\t\t\tret = -1;\n\t\t} else {\n\t\t\tfclose(pathfile);\n\t\t}\n\t}\n\tfree(pathdirname);\n\treturn ret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pathdirname"
          ],
          "line": 1832
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4619-4628",
          "snippet": "static void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "pathfile"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to create mount target '%s'\"",
            "path"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "path",
            "\"wb\""
          ],
          "line": 1824
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to create target directory\""
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir_p",
          "args": [
            "pathdirname",
            "0755"
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "241-262",
          "snippet": "extern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dirname",
          "args": [
            "pathdirname"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_util_dirname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lua-lxc/core.c",
          "lines": "569-573",
          "snippet": "static int lxc_util_dirname(lua_State *L) {\n    char *path = strdupa(luaL_checkstring(L, 1));\n    lua_pushstring(L, dirname(path));\n    return 1;\n}",
          "includes": [
            "#include \"lxc/commands.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <libgen.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <assert.h>",
            "#include <lauxlib.h>",
            "#include <lua.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxc/commands.h\"\n#include <lxc/lxccontainer.h>\n#include <libgen.h>\n#include <unistd.h>\n#include <string.h>\n#include <assert.h>\n#include <lauxlib.h>\n#include <lua.h>\n\nstatic int lxc_util_dirname(lua_State *L) {\n    char *path = strdupa(luaL_checkstring(L, 1));\n    lua_pushstring(L, dirname(path));\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "path"
          ],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "path",
            "F_OK"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hasmntopt",
          "args": [
            "mntent",
            "\"create=file\""
          ],
          "line": 1818
        },
        "resolved": true,
        "details": {
          "function_name": "hasmntopt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/lxcmntent.c",
          "lines": "175-193",
          "snippet": "char *hasmntopt (const struct mntent *mnt, const char *opt)\n{\n    const size_t optlen = strlen (opt);\n    char *rest = mnt->mnt_opts, *p;\n\n    while ((p = strstr (rest, opt)) != NULL)\n    {\n        if ((p == rest || p[-1] == ',')\n            && (p[optlen] == '\\0' || p[optlen] == '=' || p[optlen] == ','))\n            return p;\n\n        rest = strchr (p, ',');\n        if (rest == NULL)\n            break;\n        ++rest;\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <string.h>\n#include <stdio.h>\n\nchar *hasmntopt (const struct mntent *mnt, const char *opt)\n{\n    const size_t optlen = strlen (opt);\n    char *rest = mnt->mnt_opts, *p;\n\n    while ((p = strstr (rest, opt)) != NULL)\n    {\n        if ((p == rest || p[-1] == ',')\n            && (p[optlen] == '\\0' || p[optlen] == '=' || p[optlen] == ','))\n            return p;\n\n        rest = strchr (p, ',');\n        if (rest == NULL)\n            break;\n        ++rest;\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to create mount target '%s'\"",
            "path"
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aufs_mkdir",
          "args": [
            "mntent",
            "rootfs",
            "lxc_name",
            "lxc_path"
          ],
          "line": 1807
        },
        "resolved": true,
        "details": {
          "function_name": "aufs_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcaufs.c",
          "lines": "352-419",
          "snippet": "int aufs_mkdir(const struct mntent *mntent, const struct lxc_rootfs *rootfs,\n\t\tconst char *lxc_name, const char *lxc_path)\n{\n\tchar lxcpath[MAXPATHLEN];\n\tchar *rootfs_path = NULL;\n\tchar *rootfsdir = NULL;\n\tchar *scratch = NULL;\n\tchar *tmp = NULL;\n\tchar *upperdir = NULL;\n\tchar **opts = NULL;\n\tint fret = -1;\n\tint ret = 0;\n\tsize_t arrlen = 0;\n\tsize_t i;\n\tsize_t len = 0;\n\tsize_t rootfslen = 0;\n\n\t/* When rootfs == NULL we have a container without a rootfs. */\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->path;\n\n\topts = lxc_string_split(mntent->mnt_opts, ',');\n\tif (opts)\n\t\tarrlen = lxc_array_len((void **)opts);\n\telse\n\t\tgoto err;\n\n\tfor (i = 0; i < arrlen; i++) {\n\t\tif (strstr(opts[i], \"br=\") && (strlen(opts[i]) > (len = strlen(\"br=\"))))\n\t\t\ttmp = opts[i] + len;\n\t}\n\tif (!tmp)\n\t\tgoto err;\n\n\tupperdir = strtok_r(tmp, \":=\", &scratch);\n\tif (!upperdir)\n\t\tgoto err;\n\n\tif (rootfs_path) {\n\t\tret = snprintf(lxcpath, MAXPATHLEN, \"%s/%s\", lxc_path, lxc_name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\tgoto err;\n\n\t\trootfsdir = aufs_get_rootfs(rootfs->path, &rootfslen);\n\t\tif (!rootfsdir)\n\t\t\tgoto err;\n\t}\n\n\t/*\n\t * We neither allow users to create upperdirs and workdirs outside the\n\t * containerdir nor inside the rootfs. The latter might be debatable.\n\t * When we have a container without a rootfs we skip the checks.\n\t */\n\tret = 0;\n\tif (!rootfs_path)\n\t\tret = mkdir_p(upperdir, 0755);\n\telse if ((strncmp(upperdir, lxcpath, strlen(lxcpath)) == 0) && (strncmp(upperdir, rootfsdir, rootfslen) != 0))\n\t\tret = mkdir_p(upperdir, 0755);\n\tif (ret < 0)\n\t\tWARN(\"Failed to create upperdir\");\n\n\tfret = 0;\n\nerr:\n\tfree(rootfsdir);\n\tlxc_free_array((void **)opts, free);\n\treturn fret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdint.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *dir_new_path(char *src, const char *oldname, const char *name,\n\t\tconst char *oldpath, const char *lxcpath);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdint.h>\n#include <errno.h>\n\nextern char *dir_new_path(char *src, const char *oldname, const char *name,\n\t\tconst char *oldpath, const char *lxcpath);\n\nint aufs_mkdir(const struct mntent *mntent, const struct lxc_rootfs *rootfs,\n\t\tconst char *lxc_name, const char *lxc_path)\n{\n\tchar lxcpath[MAXPATHLEN];\n\tchar *rootfs_path = NULL;\n\tchar *rootfsdir = NULL;\n\tchar *scratch = NULL;\n\tchar *tmp = NULL;\n\tchar *upperdir = NULL;\n\tchar **opts = NULL;\n\tint fret = -1;\n\tint ret = 0;\n\tsize_t arrlen = 0;\n\tsize_t i;\n\tsize_t len = 0;\n\tsize_t rootfslen = 0;\n\n\t/* When rootfs == NULL we have a container without a rootfs. */\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->path;\n\n\topts = lxc_string_split(mntent->mnt_opts, ',');\n\tif (opts)\n\t\tarrlen = lxc_array_len((void **)opts);\n\telse\n\t\tgoto err;\n\n\tfor (i = 0; i < arrlen; i++) {\n\t\tif (strstr(opts[i], \"br=\") && (strlen(opts[i]) > (len = strlen(\"br=\"))))\n\t\t\ttmp = opts[i] + len;\n\t}\n\tif (!tmp)\n\t\tgoto err;\n\n\tupperdir = strtok_r(tmp, \":=\", &scratch);\n\tif (!upperdir)\n\t\tgoto err;\n\n\tif (rootfs_path) {\n\t\tret = snprintf(lxcpath, MAXPATHLEN, \"%s/%s\", lxc_path, lxc_name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\tgoto err;\n\n\t\trootfsdir = aufs_get_rootfs(rootfs->path, &rootfslen);\n\t\tif (!rootfsdir)\n\t\t\tgoto err;\n\t}\n\n\t/*\n\t * We neither allow users to create upperdirs and workdirs outside the\n\t * containerdir nor inside the rootfs. The latter might be debatable.\n\t * When we have a container without a rootfs we skip the checks.\n\t */\n\tret = 0;\n\tif (!rootfs_path)\n\t\tret = mkdir_p(upperdir, 0755);\n\telse if ((strncmp(upperdir, lxcpath, strlen(lxcpath)) == 0) && (strncmp(upperdir, rootfsdir, rootfslen) != 0))\n\t\tret = mkdir_p(upperdir, 0755);\n\tif (ret < 0)\n\t\tWARN(\"Failed to create upperdir\");\n\n\tfret = 0;\n\nerr:\n\tfree(rootfsdir);\n\tlxc_free_array((void **)opts, free);\n\treturn fret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "mntent->mnt_type",
            "\"aufs\"",
            "4"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_mkdir",
          "args": [
            "mntent",
            "rootfs",
            "lxc_name",
            "lxc_path"
          ],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcoverlay.c",
          "lines": "485-562",
          "snippet": "int ovl_mkdir(const struct mntent *mntent, const struct lxc_rootfs *rootfs,\n\t      const char *lxc_name, const char *lxc_path)\n{\n\tchar lxcpath[MAXPATHLEN];\n\tchar *rootfs_path = NULL;\n\tchar *rootfsdir = NULL;\n\tchar *upperdir = NULL;\n\tchar *workdir = NULL;\n\tchar **opts = NULL;\n\tint fret = -1;\n\tint ret = 0;\n\tsize_t arrlen = 0;\n\tsize_t dirlen = 0;\n\tsize_t i;\n\tsize_t len = 0;\n\tsize_t rootfslen = 0;\n\n\t/* When rootfs == NULL we have a container without a rootfs. */\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->path;\n\n\topts = lxc_string_split(mntent->mnt_opts, ',');\n\tif (opts)\n\t\tarrlen = lxc_array_len((void **)opts);\n\telse\n\t\tgoto err;\n\n\tfor (i = 0; i < arrlen; i++) {\n\t\tif (strstr(opts[i], \"upperdir=\") && (strlen(opts[i]) > (len = strlen(\"upperdir=\"))))\n\t\t\tupperdir = opts[i] + len;\n\t\telse if (strstr(opts[i], \"workdir=\") && (strlen(opts[i]) > (len = strlen(\"workdir=\"))))\n\t\t\tworkdir = opts[i] + len;\n\t}\n\n\tif (rootfs_path) {\n\t\tret = snprintf(lxcpath, MAXPATHLEN, \"%s/%s\", lxc_path, lxc_name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\tgoto err;\n\n\t\trootfsdir = ovl_get_rootfs(rootfs_path, &rootfslen);\n\t\tif (!rootfsdir)\n\t\t\tgoto err;\n\n\t\tdirlen = strlen(lxcpath);\n\t}\n\n\t/*\n\t * We neither allow users to create upperdirs and workdirs outside the\n\t * containerdir nor inside the rootfs. The latter might be debatable.\n\t * When we have a container without a rootfs we skip the checks.\n\t */\n\tret = 0;\n\tif (upperdir) {\n\t\tif (!rootfs_path)\n\t\t\tret = mkdir_p(upperdir, 0755);\n\t\telse if ((strncmp(upperdir, lxcpath, dirlen) == 0) && (strncmp(upperdir, rootfsdir, rootfslen) != 0))\n\t\t\tret = mkdir_p(upperdir, 0755);\n\t\tif (ret < 0)\n\t\t\tWARN(\"Failed to create upperdir\");\n\t}\n\n\tret = 0;\n\tif (workdir) {\n\t\tif (!rootfs_path)\n\t\t\tret = mkdir_p(workdir, 0755);\n\t\telse if ((strncmp(workdir, lxcpath, dirlen) == 0) && (strncmp(workdir, rootfsdir, rootfslen) != 0))\n\t\t\tret = mkdir_p(workdir, 0755);\n\t\tif (ret < 0)\n\t\t\tWARN(\"Failed to create workdir\");\n\t}\n\n\tfret = 0;\n\nerr:\n\tfree(rootfsdir);\n\tlxc_free_array((void **)opts, free);\n\treturn fret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *dir_new_path(char *src, const char *oldname, const char *name,\n\t\t\t  const char *oldpath, const char *lxcpath);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcoverlay.h\"\n#include \"lxccontainer.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nextern char *dir_new_path(char *src, const char *oldname, const char *name,\n\t\t\t  const char *oldpath, const char *lxcpath);\n\nint ovl_mkdir(const struct mntent *mntent, const struct lxc_rootfs *rootfs,\n\t      const char *lxc_name, const char *lxc_path)\n{\n\tchar lxcpath[MAXPATHLEN];\n\tchar *rootfs_path = NULL;\n\tchar *rootfsdir = NULL;\n\tchar *upperdir = NULL;\n\tchar *workdir = NULL;\n\tchar **opts = NULL;\n\tint fret = -1;\n\tint ret = 0;\n\tsize_t arrlen = 0;\n\tsize_t dirlen = 0;\n\tsize_t i;\n\tsize_t len = 0;\n\tsize_t rootfslen = 0;\n\n\t/* When rootfs == NULL we have a container without a rootfs. */\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->path;\n\n\topts = lxc_string_split(mntent->mnt_opts, ',');\n\tif (opts)\n\t\tarrlen = lxc_array_len((void **)opts);\n\telse\n\t\tgoto err;\n\n\tfor (i = 0; i < arrlen; i++) {\n\t\tif (strstr(opts[i], \"upperdir=\") && (strlen(opts[i]) > (len = strlen(\"upperdir=\"))))\n\t\t\tupperdir = opts[i] + len;\n\t\telse if (strstr(opts[i], \"workdir=\") && (strlen(opts[i]) > (len = strlen(\"workdir=\"))))\n\t\t\tworkdir = opts[i] + len;\n\t}\n\n\tif (rootfs_path) {\n\t\tret = snprintf(lxcpath, MAXPATHLEN, \"%s/%s\", lxc_path, lxc_name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\tgoto err;\n\n\t\trootfsdir = ovl_get_rootfs(rootfs_path, &rootfslen);\n\t\tif (!rootfsdir)\n\t\t\tgoto err;\n\n\t\tdirlen = strlen(lxcpath);\n\t}\n\n\t/*\n\t * We neither allow users to create upperdirs and workdirs outside the\n\t * containerdir nor inside the rootfs. The latter might be debatable.\n\t * When we have a container without a rootfs we skip the checks.\n\t */\n\tret = 0;\n\tif (upperdir) {\n\t\tif (!rootfs_path)\n\t\t\tret = mkdir_p(upperdir, 0755);\n\t\telse if ((strncmp(upperdir, lxcpath, dirlen) == 0) && (strncmp(upperdir, rootfsdir, rootfslen) != 0))\n\t\t\tret = mkdir_p(upperdir, 0755);\n\t\tif (ret < 0)\n\t\t\tWARN(\"Failed to create upperdir\");\n\t}\n\n\tret = 0;\n\tif (workdir) {\n\t\tif (!rootfs_path)\n\t\t\tret = mkdir_p(workdir, 0755);\n\t\telse if ((strncmp(workdir, lxcpath, dirlen) == 0) && (strncmp(workdir, rootfsdir, rootfslen) != 0))\n\t\t\tret = mkdir_p(workdir, 0755);\n\t\tif (ret < 0)\n\t\t\tWARN(\"Failed to create workdir\");\n\t}\n\n\tfret = 0;\n\nerr:\n\tfree(rootfsdir);\n\tlxc_free_array((void **)opts, free);\n\treturn fret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "mntent->mnt_type",
            "\"overlay\"",
            "7"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int mount_entry_create_dir_file(const struct mntent *mntent,\n\t\t\t\t       const char* path, const struct lxc_rootfs *rootfs,\n\t\t\t\t       const char *lxc_name, const char *lxc_path)\n{\n\tchar *pathdirname = NULL;\n\tint ret = 0;\n\tFILE *pathfile = NULL;\n\n\tif (strncmp(mntent->mnt_type, \"overlay\", 7) == 0) {\n\t\tif (ovl_mkdir(mntent, rootfs, lxc_name, lxc_path) < 0)\n\t\t\treturn -1;\n\t} else if (strncmp(mntent->mnt_type, \"aufs\", 4) == 0) {\n\t\tif (aufs_mkdir(mntent, rootfs, lxc_name, lxc_path) < 0)\n\t\t\treturn -1;\n\t}\n\n\tif (hasmntopt(mntent, \"create=dir\")) {\n\t\tif (mkdir_p(path, 0755) < 0) {\n\t\t\tWARN(\"Failed to create mount target '%s'\", path);\n\t\t\tret = -1;\n\t\t}\n\t}\n\n\tif (hasmntopt(mntent, \"create=file\") && access(path, F_OK)) {\n\t\tpathdirname = strdup(path);\n\t\tpathdirname = dirname(pathdirname);\n\t\tif (mkdir_p(pathdirname, 0755) < 0) {\n\t\t\tWARN(\"Failed to create target directory\");\n\t\t}\n\t\tpathfile = fopen(path, \"wb\");\n\t\tif (!pathfile) {\n\t\t\tWARN(\"Failed to create mount target '%s'\", path);\n\t\t\tret = -1;\n\t\t} else {\n\t\t\tfclose(pathfile);\n\t\t}\n\t}\n\tfree(pathdirname);\n\treturn ret;\n}"
  },
  {
    "function_name": "cull_mntent_opt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "1773-1793",
    "snippet": "static void cull_mntent_opt(struct mntent *mntent)\n{\n\tint i;\n\tchar *p, *p2;\n\tchar *list[] = {\"create=dir\",\n\t\t\t\"create=file\",\n\t\t\t\"optional\",\n\t\t\tNULL };\n\n\tfor (i=0; list[i]; i++) {\n\t\tif (!(p = strstr(mntent->mnt_opts, list[i])))\n\t\t\tcontinue;\n\t\tp2 = strchr(p, ',');\n\t\tif (!p2) {\n\t\t\t/* no more mntopts, so just chop it here */\n\t\t\t*p = '\\0';\n\t\t\tcontinue;\n\t\t}\n\t\tmemmove(p, p2+1, strlen(p2+1)+1);\n\t}\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "p",
            "p2+1",
            "strlen(p2+1)+1"
          ],
          "line": 1791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p2+1"
          ],
          "line": 1791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "','"
          ],
          "line": 1785
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "mntent->mnt_opts",
            "list[i]"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void cull_mntent_opt(struct mntent *mntent)\n{\n\tint i;\n\tchar *p, *p2;\n\tchar *list[] = {\"create=dir\",\n\t\t\t\"create=file\",\n\t\t\t\"optional\",\n\t\t\tNULL };\n\n\tfor (i=0; list[i]; i++) {\n\t\tif (!(p = strstr(mntent->mnt_opts, list[i])))\n\t\t\tcontinue;\n\t\tp2 = strchr(p, ',');\n\t\tif (!p2) {\n\t\t\t/* no more mntopts, so just chop it here */\n\t\t\t*p = '\\0';\n\t\t\tcontinue;\n\t\t}\n\t\tmemmove(p, p2+1, strlen(p2+1)+1);\n\t}\n}"
  },
  {
    "function_name": "mount_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "1693-1768",
    "snippet": "static int mount_entry(const char *fsname, const char *target,\n\t\t       const char *fstype, unsigned long mountflags,\n\t\t       const char *data, int optional, int dev, const char *rootfs)\n{\n#ifdef HAVE_STATVFS\n\tstruct statvfs sb;\n#endif\n\n\tif (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {\n\t\tif (optional) {\n\t\t\tINFO(\"failed to mount '%s' on '%s' (optional): %s\", fsname,\n\t\t\t     target, strerror(errno));\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tSYSERROR(\"failed to mount '%s' on '%s'\", fsname, target);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif ((mountflags & MS_REMOUNT) || (mountflags & MS_BIND)) {\n\t\tDEBUG(\"remounting %s on %s to respect bind or remount options\",\n\t\t      fsname ? fsname : \"(none)\", target ? target : \"(none)\");\n\t\tunsigned long rqd_flags = 0;\n\t\tif (mountflags & MS_RDONLY)\n\t\t\trqd_flags |= MS_RDONLY;\n#ifdef HAVE_STATVFS\n\t\tif (statvfs(fsname, &sb) == 0) {\n\t\t\tunsigned long required_flags = rqd_flags;\n\t\t\tif (sb.f_flag & MS_NOSUID)\n\t\t\t\trequired_flags |= MS_NOSUID;\n\t\t\tif (sb.f_flag & MS_NODEV && !dev)\n\t\t\t\trequired_flags |= MS_NODEV;\n\t\t\tif (sb.f_flag & MS_RDONLY)\n\t\t\t\trequired_flags |= MS_RDONLY;\n\t\t\tif (sb.f_flag & MS_NOEXEC)\n\t\t\t\trequired_flags |= MS_NOEXEC;\n\t\t\tDEBUG(\"(at remount) flags for %s was %lu, required extra flags are %lu\", fsname, sb.f_flag, required_flags);\n\t\t\t/*\n\t\t\t * If this was a bind mount request, and required_flags\n\t\t\t * does not have any flags which are not already in\n\t\t\t * mountflags, then skip the remount\n\t\t\t */\n\t\t\tif (!(mountflags & MS_REMOUNT)) {\n\t\t\t\tif (!(required_flags & ~mountflags) && rqd_flags == 0) {\n\t\t\t\t\tDEBUG(\"mountflags already was %lu, skipping remount\",\n\t\t\t\t\t\tmountflags);\n\t\t\t\t\tgoto skipremount;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmountflags |= required_flags;\n\t\t}\n#endif\n\n\t\tif (mount(fsname, target, fstype,\n\t\t\t  mountflags | MS_REMOUNT, data) < 0) {\n\t\t\tif (optional) {\n\t\t\t\tINFO(\"failed to mount '%s' on '%s' (optional): %s\",\n\t\t\t\t\t fsname, target, strerror(errno));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSYSERROR(\"failed to mount '%s' on '%s'\",\n\t\t\t\t\t fsname, target);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef HAVE_STATVFS\nskipremount:\n#endif\n\tDEBUG(\"mounted '%s' on '%s', type '%s'\", fsname, target, fstype);\n\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"mounted '%s' on '%s', type '%s'\"",
            "fsname",
            "target",
            "fstype"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to mount '%s' on '%s'\"",
            "fsname",
            "target"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"failed to mount '%s' on '%s' (optional): %s\"",
            "fsname",
            "target",
            "strerror(errno)"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "fsname",
            "target",
            "fstype",
            "mountflags | MS_REMOUNT",
            "data"
          ],
          "line": 1747
        },
        "resolved": true,
        "details": {
          "function_name": "mount_entry_on_generic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1838-1869",
          "snippet": "static inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"mountflags already was %lu, skipping remount\"",
            "mountflags"
          ],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"(at remount) flags for %s was %lu, required extra flags are %lu\"",
            "fsname",
            "sb.f_flag",
            "required_flags"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "statvfs",
          "args": [
            "fsname",
            "&sb"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"remounting %s on %s to respect bind or remount options\"",
            "fsname ? fsname : \"(none)\"",
            "target ? target : \"(none)\""
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to mount '%s' on '%s'\"",
            "fsname",
            "target"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"failed to mount '%s' on '%s' (optional): %s\"",
            "fsname",
            "target",
            "strerror(errno)"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_mount",
          "args": [
            "fsname",
            "target",
            "fstype",
            "mountflags & ~MS_REMOUNT",
            "data",
            "rootfs"
          ],
          "line": 1701
        },
        "resolved": true,
        "details": {
          "function_name": "safe_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1687-1743",
          "snippet": "int safe_mount(const char *src, const char *dest, const char *fstype,\n\t\tunsigned long flags, const void *data, const char *rootfs)\n{\n\tint srcfd = -1, destfd, ret, saved_errno;\n\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n\tconst char *mntsrc = src;\n\n\tif (!rootfs)\n\t\trootfs = \"\";\n\n\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n\tif (flags & MS_BIND && src && src[0] != '/') {\n\t\tINFO(\"this is a relative bind mount\");\n\t\tsrcfd = open_without_symlink(src, NULL);\n\t\tif (srcfd < 0)\n\t\t\treturn srcfd;\n\t\tret = snprintf(srcbuf, 50, \"/proc/self/fd/%d\", srcfd);\n\t\tif (ret < 0 || ret > 50) {\n\t\t\tclose(srcfd);\n\t\t\tERROR(\"Out of memory\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmntsrc = srcbuf;\n\t}\n\n\tdestfd = open_without_symlink(dest, rootfs);\n\tif (destfd < 0) {\n\t\tif (srcfd != -1) {\n\t\t\tsaved_errno = errno;\n\t\t\tclose(srcfd);\n\t\t\terrno = saved_errno;\n\t\t}\n\t\treturn destfd;\n\t}\n\n\tret = snprintf(destbuf, 50, \"/proc/self/fd/%d\", destfd);\n\tif (ret < 0 || ret > 50) {\n\t\tif (srcfd != -1)\n\t\t\tclose(srcfd);\n\t\tclose(destfd);\n\t\tERROR(\"Out of memory\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = mount(mntsrc, destbuf, fstype, flags, data);\n\tsaved_errno = errno;\n\tif (srcfd != -1)\n\t\tclose(srcfd);\n\tclose(destfd);\n\tif (ret < 0) {\n\t\terrno = saved_errno;\n\t\tSYSERROR(\"Failed to mount %s onto %s\", src, dest);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint safe_mount(const char *src, const char *dest, const char *fstype,\n\t\tunsigned long flags, const void *data, const char *rootfs)\n{\n\tint srcfd = -1, destfd, ret, saved_errno;\n\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n\tconst char *mntsrc = src;\n\n\tif (!rootfs)\n\t\trootfs = \"\";\n\n\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n\tif (flags & MS_BIND && src && src[0] != '/') {\n\t\tINFO(\"this is a relative bind mount\");\n\t\tsrcfd = open_without_symlink(src, NULL);\n\t\tif (srcfd < 0)\n\t\t\treturn srcfd;\n\t\tret = snprintf(srcbuf, 50, \"/proc/self/fd/%d\", srcfd);\n\t\tif (ret < 0 || ret > 50) {\n\t\t\tclose(srcfd);\n\t\t\tERROR(\"Out of memory\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmntsrc = srcbuf;\n\t}\n\n\tdestfd = open_without_symlink(dest, rootfs);\n\tif (destfd < 0) {\n\t\tif (srcfd != -1) {\n\t\t\tsaved_errno = errno;\n\t\t\tclose(srcfd);\n\t\t\terrno = saved_errno;\n\t\t}\n\t\treturn destfd;\n\t}\n\n\tret = snprintf(destbuf, 50, \"/proc/self/fd/%d\", destfd);\n\tif (ret < 0 || ret > 50) {\n\t\tif (srcfd != -1)\n\t\t\tclose(srcfd);\n\t\tclose(destfd);\n\t\tERROR(\"Out of memory\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = mount(mntsrc, destbuf, fstype, flags, data);\n\tsaved_errno = errno;\n\tif (srcfd != -1)\n\t\tclose(srcfd);\n\tclose(destfd);\n\tif (ret < 0) {\n\t\terrno = saved_errno;\n\t\tSYSERROR(\"Failed to mount %s onto %s\", src, dest);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int mount_entry(const char *fsname, const char *target,\n\t\t       const char *fstype, unsigned long mountflags,\n\t\t       const char *data, int optional, int dev, const char *rootfs)\n{\n#ifdef HAVE_STATVFS\n\tstruct statvfs sb;\n#endif\n\n\tif (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {\n\t\tif (optional) {\n\t\t\tINFO(\"failed to mount '%s' on '%s' (optional): %s\", fsname,\n\t\t\t     target, strerror(errno));\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tSYSERROR(\"failed to mount '%s' on '%s'\", fsname, target);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif ((mountflags & MS_REMOUNT) || (mountflags & MS_BIND)) {\n\t\tDEBUG(\"remounting %s on %s to respect bind or remount options\",\n\t\t      fsname ? fsname : \"(none)\", target ? target : \"(none)\");\n\t\tunsigned long rqd_flags = 0;\n\t\tif (mountflags & MS_RDONLY)\n\t\t\trqd_flags |= MS_RDONLY;\n#ifdef HAVE_STATVFS\n\t\tif (statvfs(fsname, &sb) == 0) {\n\t\t\tunsigned long required_flags = rqd_flags;\n\t\t\tif (sb.f_flag & MS_NOSUID)\n\t\t\t\trequired_flags |= MS_NOSUID;\n\t\t\tif (sb.f_flag & MS_NODEV && !dev)\n\t\t\t\trequired_flags |= MS_NODEV;\n\t\t\tif (sb.f_flag & MS_RDONLY)\n\t\t\t\trequired_flags |= MS_RDONLY;\n\t\t\tif (sb.f_flag & MS_NOEXEC)\n\t\t\t\trequired_flags |= MS_NOEXEC;\n\t\t\tDEBUG(\"(at remount) flags for %s was %lu, required extra flags are %lu\", fsname, sb.f_flag, required_flags);\n\t\t\t/*\n\t\t\t * If this was a bind mount request, and required_flags\n\t\t\t * does not have any flags which are not already in\n\t\t\t * mountflags, then skip the remount\n\t\t\t */\n\t\t\tif (!(mountflags & MS_REMOUNT)) {\n\t\t\t\tif (!(required_flags & ~mountflags) && rqd_flags == 0) {\n\t\t\t\t\tDEBUG(\"mountflags already was %lu, skipping remount\",\n\t\t\t\t\t\tmountflags);\n\t\t\t\t\tgoto skipremount;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmountflags |= required_flags;\n\t\t}\n#endif\n\n\t\tif (mount(fsname, target, fstype,\n\t\t\t  mountflags | MS_REMOUNT, data) < 0) {\n\t\t\tif (optional) {\n\t\t\t\tINFO(\"failed to mount '%s' on '%s' (optional): %s\",\n\t\t\t\t\t fsname, target, strerror(errno));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSYSERROR(\"failed to mount '%s' on '%s'\",\n\t\t\t\t\t fsname, target);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef HAVE_STATVFS\nskipremount:\n#endif\n\tDEBUG(\"mounted '%s' on '%s', type '%s'\", fsname, target, fstype);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "get_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "1678-1691",
    "snippet": "static char *get_field(char *src, int nfields)\n{\n\tchar *p = src;\n\tint i;\n\n\tfor (i = 0; i < nfields; i++) {\n\t\twhile (*p && *p != ' ' && *p != '\\t')\n\t\t\tp++;\n\t\tif (!*p)\n\t\t\tbreak;\n\t\tp++;\n\t}\n\treturn p;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic char *get_field(char *src, int nfields)\n{\n\tchar *p = src;\n\tint i;\n\n\tfor (i = 0; i < nfields; i++) {\n\t\twhile (*p && *p != ' ' && *p != '\\t')\n\t\t\tp++;\n\t\tif (!*p)\n\t\t\tbreak;\n\t\tp++;\n\t}\n\treturn p;\n}"
  },
  {
    "function_name": "null_endofword",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "1668-1673",
    "snippet": "static void null_endofword(char *word)\n{\n\twhile (*word && *word != ' ' && *word != '\\t')\n\t\tword++;\n\t*word = '\\0';\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void null_endofword(char *word)\n{\n\twhile (*word && *word != ' ' && *word != '\\t')\n\t\tword++;\n\t*word = '\\0';\n}"
  },
  {
    "function_name": "parse_mntopts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "1629-1666",
    "snippet": "int parse_mntopts(const char *mntopts, unsigned long *mntflags,\n\t\t\t char **mntdata)\n{\n\tchar *s, *data;\n\tchar *p, *saveptr = NULL;\n\n\t*mntdata = NULL;\n\t*mntflags = 0L;\n\n\tif (!mntopts)\n\t\treturn 0;\n\n\ts = strdup(mntopts);\n\tif (!s) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\treturn -1;\n\t}\n\n\tdata = malloc(strlen(s) + 1);\n\tif (!data) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\tfree(s);\n\t\treturn -1;\n\t}\n\t*data = 0;\n\n\tfor (p = strtok_r(s, \",\", &saveptr); p != NULL;\n\t     p = strtok_r(NULL, \",\", &saveptr))\n\t\tparse_mntopt(p, mntflags, &data);\n\n\tif (*data)\n\t\t*mntdata = data;\n\telse\n\t\tfree(data);\n\tfree(s);\n\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "s"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4619-4628",
          "snippet": "static void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_mntopt",
          "args": [
            "p",
            "mntflags",
            "&data"
          ],
          "line": 1657
        },
        "resolved": true,
        "details": {
          "function_name": "parse_mntopts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1629-1666",
          "snippet": "int parse_mntopts(const char *mntopts, unsigned long *mntflags,\n\t\t\t char **mntdata)\n{\n\tchar *s, *data;\n\tchar *p, *saveptr = NULL;\n\n\t*mntdata = NULL;\n\t*mntflags = 0L;\n\n\tif (!mntopts)\n\t\treturn 0;\n\n\ts = strdup(mntopts);\n\tif (!s) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\treturn -1;\n\t}\n\n\tdata = malloc(strlen(s) + 1);\n\tif (!data) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\tfree(s);\n\t\treturn -1;\n\t}\n\t*data = 0;\n\n\tfor (p = strtok_r(s, \",\", &saveptr); p != NULL;\n\t     p = strtok_r(NULL, \",\", &saveptr))\n\t\tparse_mntopt(p, mntflags, &data);\n\n\tif (*data)\n\t\t*mntdata = data;\n\telse\n\t\tfree(data);\n\tfree(s);\n\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "NULL",
            "\",\"",
            "&saveptr"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "s",
            "\",\"",
            "&saveptr"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to allocate memory\""
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(s) + 1"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to allocate memory\""
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "mntopts"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint parse_mntopts(const char *mntopts, unsigned long *mntflags,\n\t\t\t char **mntdata)\n{\n\tchar *s, *data;\n\tchar *p, *saveptr = NULL;\n\n\t*mntdata = NULL;\n\t*mntflags = 0L;\n\n\tif (!mntopts)\n\t\treturn 0;\n\n\ts = strdup(mntopts);\n\tif (!s) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\treturn -1;\n\t}\n\n\tdata = malloc(strlen(s) + 1);\n\tif (!data) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\tfree(s);\n\t\treturn -1;\n\t}\n\t*data = 0;\n\n\tfor (p = strtok_r(s, \",\", &saveptr); p != NULL;\n\t     p = strtok_r(NULL, \",\", &saveptr))\n\t\tparse_mntopt(p, mntflags, &data);\n\n\tif (*data)\n\t\t*mntdata = data;\n\telse\n\t\tfree(data);\n\tfree(s);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "parse_mntopt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "1607-1627",
    "snippet": "static void parse_mntopt(char *opt, unsigned long *flags, char **data)\n{\n\tstruct mount_opt *mo;\n\n\t/* If opt is found in mount_opt, set or clear flags.\n\t * Otherwise append it to data. */\n\n\tfor (mo = &mount_opt[0]; mo->name != NULL; mo++) {\n\t\tif (!strncmp(opt, mo->name, strlen(mo->name))) {\n\t\t\tif (mo->clear)\n\t\t\t\t*flags &= ~mo->flag;\n\t\t\telse\n\t\t\t\t*flags |= mo->flag;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (strlen(*data))\n\t\tstrcat(*data, \",\");\n\tstrcat(*data, opt);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct mount_opt mount_opt[] = {\n\t{ \"defaults\",      0, 0              },\n\t{ \"ro\",            0, MS_RDONLY      },\n\t{ \"rw\",            1, MS_RDONLY      },\n\t{ \"suid\",          1, MS_NOSUID      },\n\t{ \"nosuid\",        0, MS_NOSUID      },\n\t{ \"dev\",           1, MS_NODEV       },\n\t{ \"nodev\",         0, MS_NODEV       },\n\t{ \"exec\",          1, MS_NOEXEC      },\n\t{ \"noexec\",        0, MS_NOEXEC      },\n\t{ \"sync\",          0, MS_SYNCHRONOUS },\n\t{ \"async\",         1, MS_SYNCHRONOUS },\n\t{ \"dirsync\",       0, MS_DIRSYNC     },\n\t{ \"remount\",       0, MS_REMOUNT     },\n\t{ \"mand\",          0, MS_MANDLOCK    },\n\t{ \"nomand\",        1, MS_MANDLOCK    },\n\t{ \"atime\",         1, MS_NOATIME     },\n\t{ \"noatime\",       0, MS_NOATIME     },\n\t{ \"diratime\",      1, MS_NODIRATIME  },\n\t{ \"nodiratime\",    0, MS_NODIRATIME  },\n\t{ \"bind\",          0, MS_BIND        },\n\t{ \"rbind\",         0, MS_BIND|MS_REC },\n\t{ \"relatime\",      0, MS_RELATIME    },\n\t{ \"norelatime\",    1, MS_RELATIME    },\n\t{ \"strictatime\",   0, MS_STRICTATIME },\n\t{ \"nostrictatime\", 1, MS_STRICTATIME },\n\t{ NULL,            0, 0              },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "*data",
            "opt"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "*data",
            "\",\""
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "*data"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "opt",
            "mo->name",
            "strlen(mo->name)"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "mo->name"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic struct mount_opt mount_opt[] = {\n\t{ \"defaults\",      0, 0              },\n\t{ \"ro\",            0, MS_RDONLY      },\n\t{ \"rw\",            1, MS_RDONLY      },\n\t{ \"suid\",          1, MS_NOSUID      },\n\t{ \"nosuid\",        0, MS_NOSUID      },\n\t{ \"dev\",           1, MS_NODEV       },\n\t{ \"nodev\",         0, MS_NODEV       },\n\t{ \"exec\",          1, MS_NOEXEC      },\n\t{ \"noexec\",        0, MS_NOEXEC      },\n\t{ \"sync\",          0, MS_SYNCHRONOUS },\n\t{ \"async\",         1, MS_SYNCHRONOUS },\n\t{ \"dirsync\",       0, MS_DIRSYNC     },\n\t{ \"remount\",       0, MS_REMOUNT     },\n\t{ \"mand\",          0, MS_MANDLOCK    },\n\t{ \"nomand\",        1, MS_MANDLOCK    },\n\t{ \"atime\",         1, MS_NOATIME     },\n\t{ \"noatime\",       0, MS_NOATIME     },\n\t{ \"diratime\",      1, MS_NODIRATIME  },\n\t{ \"nodiratime\",    0, MS_NODIRATIME  },\n\t{ \"bind\",          0, MS_BIND        },\n\t{ \"rbind\",         0, MS_BIND|MS_REC },\n\t{ \"relatime\",      0, MS_RELATIME    },\n\t{ \"norelatime\",    1, MS_RELATIME    },\n\t{ \"strictatime\",   0, MS_STRICTATIME },\n\t{ \"nostrictatime\", 1, MS_STRICTATIME },\n\t{ NULL,            0, 0              },\n};\n\nstatic void parse_mntopt(char *opt, unsigned long *flags, char **data)\n{\n\tstruct mount_opt *mo;\n\n\t/* If opt is found in mount_opt, set or clear flags.\n\t * Otherwise append it to data. */\n\n\tfor (mo = &mount_opt[0]; mo->name != NULL; mo++) {\n\t\tif (!strncmp(opt, mo->name, strlen(mo->name))) {\n\t\t\tif (mo->clear)\n\t\t\t\t*flags &= ~mo->flag;\n\t\t\telse\n\t\t\t\t*flags |= mo->flag;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (strlen(*data))\n\t\tstrcat(*data, \",\");\n\tstrcat(*data, opt);\n}"
  },
  {
    "function_name": "setup_kmsg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "1580-1605",
    "snippet": "static int setup_kmsg(const struct lxc_rootfs *rootfs,\n\t\t       const struct lxc_console *console)\n{\n\tchar kpath[MAXPATHLEN];\n\tint ret;\n\n\tif (!rootfs->path)\n\t\treturn 0;\n\tret = snprintf(kpath, sizeof(kpath), \"%s/dev/kmsg\", rootfs->mount);\n\tif (ret < 0 || ret >= sizeof(kpath))\n\t\treturn -1;\n\n\tret = unlink(kpath);\n\tif (ret && errno != ENOENT) {\n\t\tSYSERROR(\"error unlinking %s\", kpath);\n\t\treturn -1;\n\t}\n\n\tret = symlink(\"console\", kpath);\n\tif (ret) {\n\t\tSYSERROR(\"failed to create symlink for kmsg\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to create symlink for kmsg\""
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "symlink",
          "args": [
            "\"console\"",
            "kpath"
          ],
          "line": 1598
        },
        "resolved": true,
        "details": {
          "function_name": "open_without_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1616-1677",
          "snippet": "static int open_without_symlink(const char *target, const char *prefix_skip)\n{\n\tint curlen = 0, dirfd, fulllen, i;\n\tchar *dup = NULL;\n\n\tfulllen = strlen(target);\n\n\t/* make sure prefix-skip makes sense */\n\tif (prefix_skip && strlen(prefix_skip) > 0) {\n\t\tcurlen = strlen(prefix_skip);\n\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n\t\t\tERROR(\"WHOA there - target '%s' didn't start with prefix '%s'\",\n\t\t\t\ttarget, prefix_skip);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/*\n\t\t * get_nextpath() expects the curlen argument to be\n\t\t * on a  (turned into \\0) / or before it, so decrement\n\t\t * curlen to make sure that happens\n\t\t */\n\t\tif (curlen)\n\t\t\tcurlen--;\n\t} else {\n\t\tprefix_skip = \"/\";\n\t\tcurlen = 0;\n\t}\n\n\t/* Make a copy of target which we can hack up, and tokenize it */\n\tif ((dup = strdup(target)) == NULL) {\n\t\tSYSERROR(\"Out of memory checking for symbolic link\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < fulllen; i++) {\n\t\tif (dup[i] == '/')\n\t\t\tdup[i] = '\\0';\n\t}\n\n\tdirfd = open(prefix_skip, O_RDONLY);\n\tif (dirfd < 0)\n\t\tgoto out;\n\twhile (1) {\n\t\tint newfd, saved_errno;\n\t\tchar *nextpath;\n\n\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n\t\t\tgoto out;\n\t\tnewfd = open_if_safe(dirfd, nextpath);\n\t\tsaved_errno = errno;\n\t\tclose(dirfd);\n\t\tdirfd = newfd;\n\t\tif (newfd < 0) {\n\t\t\terrno = saved_errno;\n\t\t\tif (errno == ELOOP)\n\t\t\t\tSYSERROR(\"%s in %s was a symbolic link!\", nextpath, target);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfree(dup);\n\treturn dirfd;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int open_without_symlink(const char *target, const char *prefix_skip)\n{\n\tint curlen = 0, dirfd, fulllen, i;\n\tchar *dup = NULL;\n\n\tfulllen = strlen(target);\n\n\t/* make sure prefix-skip makes sense */\n\tif (prefix_skip && strlen(prefix_skip) > 0) {\n\t\tcurlen = strlen(prefix_skip);\n\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n\t\t\tERROR(\"WHOA there - target '%s' didn't start with prefix '%s'\",\n\t\t\t\ttarget, prefix_skip);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/*\n\t\t * get_nextpath() expects the curlen argument to be\n\t\t * on a  (turned into \\0) / or before it, so decrement\n\t\t * curlen to make sure that happens\n\t\t */\n\t\tif (curlen)\n\t\t\tcurlen--;\n\t} else {\n\t\tprefix_skip = \"/\";\n\t\tcurlen = 0;\n\t}\n\n\t/* Make a copy of target which we can hack up, and tokenize it */\n\tif ((dup = strdup(target)) == NULL) {\n\t\tSYSERROR(\"Out of memory checking for symbolic link\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < fulllen; i++) {\n\t\tif (dup[i] == '/')\n\t\t\tdup[i] = '\\0';\n\t}\n\n\tdirfd = open(prefix_skip, O_RDONLY);\n\tif (dirfd < 0)\n\t\tgoto out;\n\twhile (1) {\n\t\tint newfd, saved_errno;\n\t\tchar *nextpath;\n\n\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n\t\t\tgoto out;\n\t\tnewfd = open_if_safe(dirfd, nextpath);\n\t\tsaved_errno = errno;\n\t\tclose(dirfd);\n\t\tdirfd = newfd;\n\t\tif (newfd < 0) {\n\t\t\terrno = saved_errno;\n\t\t\tif (errno == ELOOP)\n\t\t\t\tSYSERROR(\"%s in %s was a symbolic link!\", nextpath, target);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfree(dup);\n\treturn dirfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"error unlinking %s\"",
            "kpath"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "kpath"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "kpath",
            "sizeof(kpath)",
            "\"%s/dev/kmsg\"",
            "rootfs->mount"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int setup_kmsg(const struct lxc_rootfs *rootfs,\n\t\t       const struct lxc_console *console)\n{\n\tchar kpath[MAXPATHLEN];\n\tint ret;\n\n\tif (!rootfs->path)\n\t\treturn 0;\n\tret = snprintf(kpath, sizeof(kpath), \"%s/dev/kmsg\", rootfs->mount);\n\tif (ret < 0 || ret >= sizeof(kpath))\n\t\treturn -1;\n\n\tret = unlink(kpath);\n\tif (ret && errno != ENOENT) {\n\t\tSYSERROR(\"error unlinking %s\", kpath);\n\t\treturn -1;\n\t}\n\n\tret = symlink(\"console\", kpath);\n\tif (ret) {\n\t\tSYSERROR(\"failed to create symlink for kmsg\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "setup_console",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "1567-1578",
    "snippet": "static int setup_console(const struct lxc_rootfs *rootfs,\n\t\t\t const struct lxc_console *console,\n\t\t\t char *ttydir)\n{\n\t/* We don't have a rootfs, /dev/console will be shared */\n\tif (!rootfs->path)\n\t\treturn 0;\n\tif (!ttydir)\n\t\treturn setup_dev_console(rootfs, console);\n\n\treturn setup_ttydir_console(rootfs, console, ttydir);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setup_ttydir_console",
          "args": [
            "rootfs",
            "console",
            "ttydir"
          ],
          "line": 1577
        },
        "resolved": true,
        "details": {
          "function_name": "setup_ttydir_console",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1499-1565",
          "snippet": "static int setup_ttydir_console(const struct lxc_rootfs *rootfs,\n\t\t\t const struct lxc_console *console,\n\t\t\t char *ttydir)\n{\n\tchar path[MAXPATHLEN], lxcpath[MAXPATHLEN];\n\tint ret;\n\n\t/* create rootfs/dev/<ttydir> directory */\n\tret = snprintf(path, sizeof(path), \"%s/dev/%s\", rootfs->mount,\n\t\t       ttydir);\n\tif (ret >= sizeof(path))\n\t\treturn -1;\n\tret = mkdir(path, 0755);\n\tif (ret && errno != EEXIST) {\n\t\tSYSERROR(\"failed with errno %d to create %s\", errno, path);\n\t\treturn -1;\n\t}\n\tINFO(\"created %s\", path);\n\n\tret = snprintf(lxcpath, sizeof(lxcpath), \"%s/dev/%s/console\",\n\t\t       rootfs->mount, ttydir);\n\tif (ret >= sizeof(lxcpath)) {\n\t\tERROR(\"console path too long\");\n\t\treturn -1;\n\t}\n\n\tsnprintf(path, sizeof(path), \"%s/dev/console\", rootfs->mount);\n\tret = unlink(path);\n\tif (ret && errno != ENOENT) {\n\t\tSYSERROR(\"error unlinking %s\", path);\n\t\treturn -1;\n\t}\n\n\tret = creat(lxcpath, 0660);\n\tif (ret==-1 && errno != EEXIST) {\n\t\tSYSERROR(\"error %d creating %s\", errno, lxcpath);\n\t\treturn -1;\n\t}\n\tif (ret >= 0)\n\t\tclose(ret);\n\n\tif (console->master < 0) {\n\t\tINFO(\"no console\");\n\t\treturn 0;\n\t}\n\n\tif (safe_mount(console->name, lxcpath, \"none\", MS_BIND, 0, rootfs->mount)) {\n\t\tERROR(\"failed to mount '%s' on '%s'\", console->name, lxcpath);\n\t\treturn -1;\n\t}\n\n\t/* create symlink from rootfs/dev/console to 'lxc/console' */\n\tret = snprintf(lxcpath, sizeof(lxcpath), \"%s/console\", ttydir);\n\tif (ret >= sizeof(lxcpath)) {\n\t\tERROR(\"lxc/console path too long\");\n\t\treturn -1;\n\t}\n\tret = symlink(lxcpath, path);\n\tif (ret) {\n\t\tSYSERROR(\"failed to create symlink for console\");\n\t\treturn -1;\n\t}\n\n\tINFO(\"console has been setup on %s\", lxcpath);\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int setup_ttydir_console(const struct lxc_rootfs *rootfs,\n\t\t\t const struct lxc_console *console,\n\t\t\t char *ttydir)\n{\n\tchar path[MAXPATHLEN], lxcpath[MAXPATHLEN];\n\tint ret;\n\n\t/* create rootfs/dev/<ttydir> directory */\n\tret = snprintf(path, sizeof(path), \"%s/dev/%s\", rootfs->mount,\n\t\t       ttydir);\n\tif (ret >= sizeof(path))\n\t\treturn -1;\n\tret = mkdir(path, 0755);\n\tif (ret && errno != EEXIST) {\n\t\tSYSERROR(\"failed with errno %d to create %s\", errno, path);\n\t\treturn -1;\n\t}\n\tINFO(\"created %s\", path);\n\n\tret = snprintf(lxcpath, sizeof(lxcpath), \"%s/dev/%s/console\",\n\t\t       rootfs->mount, ttydir);\n\tif (ret >= sizeof(lxcpath)) {\n\t\tERROR(\"console path too long\");\n\t\treturn -1;\n\t}\n\n\tsnprintf(path, sizeof(path), \"%s/dev/console\", rootfs->mount);\n\tret = unlink(path);\n\tif (ret && errno != ENOENT) {\n\t\tSYSERROR(\"error unlinking %s\", path);\n\t\treturn -1;\n\t}\n\n\tret = creat(lxcpath, 0660);\n\tif (ret==-1 && errno != EEXIST) {\n\t\tSYSERROR(\"error %d creating %s\", errno, lxcpath);\n\t\treturn -1;\n\t}\n\tif (ret >= 0)\n\t\tclose(ret);\n\n\tif (console->master < 0) {\n\t\tINFO(\"no console\");\n\t\treturn 0;\n\t}\n\n\tif (safe_mount(console->name, lxcpath, \"none\", MS_BIND, 0, rootfs->mount)) {\n\t\tERROR(\"failed to mount '%s' on '%s'\", console->name, lxcpath);\n\t\treturn -1;\n\t}\n\n\t/* create symlink from rootfs/dev/console to 'lxc/console' */\n\tret = snprintf(lxcpath, sizeof(lxcpath), \"%s/console\", ttydir);\n\tif (ret >= sizeof(lxcpath)) {\n\t\tERROR(\"lxc/console path too long\");\n\t\treturn -1;\n\t}\n\tret = symlink(lxcpath, path);\n\tif (ret) {\n\t\tSYSERROR(\"failed to create symlink for console\");\n\t\treturn -1;\n\t}\n\n\tINFO(\"console has been setup on %s\", lxcpath);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_dev_console",
          "args": [
            "rootfs",
            "console"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "setup_dev_console",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1457-1497",
          "snippet": "static int setup_dev_console(const struct lxc_rootfs *rootfs,\n\t\t\t const struct lxc_console *console)\n{\n\tchar path[MAXPATHLEN];\n\tint ret, fd;\n\n\tret = snprintf(path, sizeof(path), \"%s/dev/console\", rootfs->mount);\n\tif (ret >= sizeof(path)) {\n\t\tERROR(\"console path too long\");\n\t\treturn -1;\n\t}\n\n\tfd = open(path, O_CREAT | O_EXCL, S_IXUSR | S_IXGRP | S_IXOTH);\n\tif (fd < 0) {\n\t\tif (errno != EEXIST) {\n\t\t\tSYSERROR(\"failed to create console\");\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tclose(fd);\n\t}\n\n\tif (console->master < 0) {\n\t\tINFO(\"no console\");\n\t\treturn 0;\n\t}\n\n\tif (chmod(console->name, S_IXUSR | S_IXGRP | S_IXOTH)) {\n\t\tSYSERROR(\"failed to set mode '0%o' to '%s'\",\n\t\t\t S_IXUSR | S_IXGRP | S_IXOTH, console->name);\n\t\treturn -1;\n\t}\n\n\tif (safe_mount(console->name, path, \"none\", MS_BIND, 0, rootfs->mount)) {\n\t\tERROR(\"failed to mount '%s' on '%s'\", console->name, path);\n\t\treturn -1;\n\t}\n\n\tINFO(\"console has been setup\");\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int setup_dev_console(const struct lxc_rootfs *rootfs,\n\t\t\t const struct lxc_console *console)\n{\n\tchar path[MAXPATHLEN];\n\tint ret, fd;\n\n\tret = snprintf(path, sizeof(path), \"%s/dev/console\", rootfs->mount);\n\tif (ret >= sizeof(path)) {\n\t\tERROR(\"console path too long\");\n\t\treturn -1;\n\t}\n\n\tfd = open(path, O_CREAT | O_EXCL, S_IXUSR | S_IXGRP | S_IXOTH);\n\tif (fd < 0) {\n\t\tif (errno != EEXIST) {\n\t\t\tSYSERROR(\"failed to create console\");\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tclose(fd);\n\t}\n\n\tif (console->master < 0) {\n\t\tINFO(\"no console\");\n\t\treturn 0;\n\t}\n\n\tif (chmod(console->name, S_IXUSR | S_IXGRP | S_IXOTH)) {\n\t\tSYSERROR(\"failed to set mode '0%o' to '%s'\",\n\t\t\t S_IXUSR | S_IXGRP | S_IXOTH, console->name);\n\t\treturn -1;\n\t}\n\n\tif (safe_mount(console->name, path, \"none\", MS_BIND, 0, rootfs->mount)) {\n\t\tERROR(\"failed to mount '%s' on '%s'\", console->name, path);\n\t\treturn -1;\n\t}\n\n\tINFO(\"console has been setup\");\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int setup_console(const struct lxc_rootfs *rootfs,\n\t\t\t const struct lxc_console *console,\n\t\t\t char *ttydir)\n{\n\t/* We don't have a rootfs, /dev/console will be shared */\n\tif (!rootfs->path)\n\t\treturn 0;\n\tif (!ttydir)\n\t\treturn setup_dev_console(rootfs, console);\n\n\treturn setup_ttydir_console(rootfs, console, ttydir);\n}"
  },
  {
    "function_name": "setup_ttydir_console",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "1499-1565",
    "snippet": "static int setup_ttydir_console(const struct lxc_rootfs *rootfs,\n\t\t\t const struct lxc_console *console,\n\t\t\t char *ttydir)\n{\n\tchar path[MAXPATHLEN], lxcpath[MAXPATHLEN];\n\tint ret;\n\n\t/* create rootfs/dev/<ttydir> directory */\n\tret = snprintf(path, sizeof(path), \"%s/dev/%s\", rootfs->mount,\n\t\t       ttydir);\n\tif (ret >= sizeof(path))\n\t\treturn -1;\n\tret = mkdir(path, 0755);\n\tif (ret && errno != EEXIST) {\n\t\tSYSERROR(\"failed with errno %d to create %s\", errno, path);\n\t\treturn -1;\n\t}\n\tINFO(\"created %s\", path);\n\n\tret = snprintf(lxcpath, sizeof(lxcpath), \"%s/dev/%s/console\",\n\t\t       rootfs->mount, ttydir);\n\tif (ret >= sizeof(lxcpath)) {\n\t\tERROR(\"console path too long\");\n\t\treturn -1;\n\t}\n\n\tsnprintf(path, sizeof(path), \"%s/dev/console\", rootfs->mount);\n\tret = unlink(path);\n\tif (ret && errno != ENOENT) {\n\t\tSYSERROR(\"error unlinking %s\", path);\n\t\treturn -1;\n\t}\n\n\tret = creat(lxcpath, 0660);\n\tif (ret==-1 && errno != EEXIST) {\n\t\tSYSERROR(\"error %d creating %s\", errno, lxcpath);\n\t\treturn -1;\n\t}\n\tif (ret >= 0)\n\t\tclose(ret);\n\n\tif (console->master < 0) {\n\t\tINFO(\"no console\");\n\t\treturn 0;\n\t}\n\n\tif (safe_mount(console->name, lxcpath, \"none\", MS_BIND, 0, rootfs->mount)) {\n\t\tERROR(\"failed to mount '%s' on '%s'\", console->name, lxcpath);\n\t\treturn -1;\n\t}\n\n\t/* create symlink from rootfs/dev/console to 'lxc/console' */\n\tret = snprintf(lxcpath, sizeof(lxcpath), \"%s/console\", ttydir);\n\tif (ret >= sizeof(lxcpath)) {\n\t\tERROR(\"lxc/console path too long\");\n\t\treturn -1;\n\t}\n\tret = symlink(lxcpath, path);\n\tif (ret) {\n\t\tSYSERROR(\"failed to create symlink for console\");\n\t\treturn -1;\n\t}\n\n\tINFO(\"console has been setup on %s\", lxcpath);\n\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"console has been setup on %s\"",
            "lxcpath"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to create symlink for console\""
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "symlink",
          "args": [
            "lxcpath",
            "path"
          ],
          "line": 1556
        },
        "resolved": true,
        "details": {
          "function_name": "open_without_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1616-1677",
          "snippet": "static int open_without_symlink(const char *target, const char *prefix_skip)\n{\n\tint curlen = 0, dirfd, fulllen, i;\n\tchar *dup = NULL;\n\n\tfulllen = strlen(target);\n\n\t/* make sure prefix-skip makes sense */\n\tif (prefix_skip && strlen(prefix_skip) > 0) {\n\t\tcurlen = strlen(prefix_skip);\n\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n\t\t\tERROR(\"WHOA there - target '%s' didn't start with prefix '%s'\",\n\t\t\t\ttarget, prefix_skip);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/*\n\t\t * get_nextpath() expects the curlen argument to be\n\t\t * on a  (turned into \\0) / or before it, so decrement\n\t\t * curlen to make sure that happens\n\t\t */\n\t\tif (curlen)\n\t\t\tcurlen--;\n\t} else {\n\t\tprefix_skip = \"/\";\n\t\tcurlen = 0;\n\t}\n\n\t/* Make a copy of target which we can hack up, and tokenize it */\n\tif ((dup = strdup(target)) == NULL) {\n\t\tSYSERROR(\"Out of memory checking for symbolic link\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < fulllen; i++) {\n\t\tif (dup[i] == '/')\n\t\t\tdup[i] = '\\0';\n\t}\n\n\tdirfd = open(prefix_skip, O_RDONLY);\n\tif (dirfd < 0)\n\t\tgoto out;\n\twhile (1) {\n\t\tint newfd, saved_errno;\n\t\tchar *nextpath;\n\n\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n\t\t\tgoto out;\n\t\tnewfd = open_if_safe(dirfd, nextpath);\n\t\tsaved_errno = errno;\n\t\tclose(dirfd);\n\t\tdirfd = newfd;\n\t\tif (newfd < 0) {\n\t\t\terrno = saved_errno;\n\t\t\tif (errno == ELOOP)\n\t\t\t\tSYSERROR(\"%s in %s was a symbolic link!\", nextpath, target);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfree(dup);\n\treturn dirfd;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int open_without_symlink(const char *target, const char *prefix_skip)\n{\n\tint curlen = 0, dirfd, fulllen, i;\n\tchar *dup = NULL;\n\n\tfulllen = strlen(target);\n\n\t/* make sure prefix-skip makes sense */\n\tif (prefix_skip && strlen(prefix_skip) > 0) {\n\t\tcurlen = strlen(prefix_skip);\n\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n\t\t\tERROR(\"WHOA there - target '%s' didn't start with prefix '%s'\",\n\t\t\t\ttarget, prefix_skip);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/*\n\t\t * get_nextpath() expects the curlen argument to be\n\t\t * on a  (turned into \\0) / or before it, so decrement\n\t\t * curlen to make sure that happens\n\t\t */\n\t\tif (curlen)\n\t\t\tcurlen--;\n\t} else {\n\t\tprefix_skip = \"/\";\n\t\tcurlen = 0;\n\t}\n\n\t/* Make a copy of target which we can hack up, and tokenize it */\n\tif ((dup = strdup(target)) == NULL) {\n\t\tSYSERROR(\"Out of memory checking for symbolic link\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < fulllen; i++) {\n\t\tif (dup[i] == '/')\n\t\t\tdup[i] = '\\0';\n\t}\n\n\tdirfd = open(prefix_skip, O_RDONLY);\n\tif (dirfd < 0)\n\t\tgoto out;\n\twhile (1) {\n\t\tint newfd, saved_errno;\n\t\tchar *nextpath;\n\n\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n\t\t\tgoto out;\n\t\tnewfd = open_if_safe(dirfd, nextpath);\n\t\tsaved_errno = errno;\n\t\tclose(dirfd);\n\t\tdirfd = newfd;\n\t\tif (newfd < 0) {\n\t\t\terrno = saved_errno;\n\t\t\tif (errno == ELOOP)\n\t\t\t\tSYSERROR(\"%s in %s was a symbolic link!\", nextpath, target);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfree(dup);\n\treturn dirfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"lxc/console path too long\""
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "lxcpath",
            "sizeof(lxcpath)",
            "\"%s/console\"",
            "ttydir"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to mount '%s' on '%s'\"",
            "console->name",
            "lxcpath"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_mount",
          "args": [
            "console->name",
            "lxcpath",
            "\"none\"",
            "MS_BIND",
            "0",
            "rootfs->mount"
          ],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "safe_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1687-1743",
          "snippet": "int safe_mount(const char *src, const char *dest, const char *fstype,\n\t\tunsigned long flags, const void *data, const char *rootfs)\n{\n\tint srcfd = -1, destfd, ret, saved_errno;\n\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n\tconst char *mntsrc = src;\n\n\tif (!rootfs)\n\t\trootfs = \"\";\n\n\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n\tif (flags & MS_BIND && src && src[0] != '/') {\n\t\tINFO(\"this is a relative bind mount\");\n\t\tsrcfd = open_without_symlink(src, NULL);\n\t\tif (srcfd < 0)\n\t\t\treturn srcfd;\n\t\tret = snprintf(srcbuf, 50, \"/proc/self/fd/%d\", srcfd);\n\t\tif (ret < 0 || ret > 50) {\n\t\t\tclose(srcfd);\n\t\t\tERROR(\"Out of memory\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmntsrc = srcbuf;\n\t}\n\n\tdestfd = open_without_symlink(dest, rootfs);\n\tif (destfd < 0) {\n\t\tif (srcfd != -1) {\n\t\t\tsaved_errno = errno;\n\t\t\tclose(srcfd);\n\t\t\terrno = saved_errno;\n\t\t}\n\t\treturn destfd;\n\t}\n\n\tret = snprintf(destbuf, 50, \"/proc/self/fd/%d\", destfd);\n\tif (ret < 0 || ret > 50) {\n\t\tif (srcfd != -1)\n\t\t\tclose(srcfd);\n\t\tclose(destfd);\n\t\tERROR(\"Out of memory\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = mount(mntsrc, destbuf, fstype, flags, data);\n\tsaved_errno = errno;\n\tif (srcfd != -1)\n\t\tclose(srcfd);\n\tclose(destfd);\n\tif (ret < 0) {\n\t\terrno = saved_errno;\n\t\tSYSERROR(\"Failed to mount %s onto %s\", src, dest);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint safe_mount(const char *src, const char *dest, const char *fstype,\n\t\tunsigned long flags, const void *data, const char *rootfs)\n{\n\tint srcfd = -1, destfd, ret, saved_errno;\n\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n\tconst char *mntsrc = src;\n\n\tif (!rootfs)\n\t\trootfs = \"\";\n\n\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n\tif (flags & MS_BIND && src && src[0] != '/') {\n\t\tINFO(\"this is a relative bind mount\");\n\t\tsrcfd = open_without_symlink(src, NULL);\n\t\tif (srcfd < 0)\n\t\t\treturn srcfd;\n\t\tret = snprintf(srcbuf, 50, \"/proc/self/fd/%d\", srcfd);\n\t\tif (ret < 0 || ret > 50) {\n\t\t\tclose(srcfd);\n\t\t\tERROR(\"Out of memory\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmntsrc = srcbuf;\n\t}\n\n\tdestfd = open_without_symlink(dest, rootfs);\n\tif (destfd < 0) {\n\t\tif (srcfd != -1) {\n\t\t\tsaved_errno = errno;\n\t\t\tclose(srcfd);\n\t\t\terrno = saved_errno;\n\t\t}\n\t\treturn destfd;\n\t}\n\n\tret = snprintf(destbuf, 50, \"/proc/self/fd/%d\", destfd);\n\tif (ret < 0 || ret > 50) {\n\t\tif (srcfd != -1)\n\t\t\tclose(srcfd);\n\t\tclose(destfd);\n\t\tERROR(\"Out of memory\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = mount(mntsrc, destbuf, fstype, flags, data);\n\tsaved_errno = errno;\n\tif (srcfd != -1)\n\t\tclose(srcfd);\n\tclose(destfd);\n\tif (ret < 0) {\n\t\terrno = saved_errno;\n\t\tSYSERROR(\"Failed to mount %s onto %s\", src, dest);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"no console\""
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "ret"
          ],
          "line": 1538
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"error %d creating %s\"",
            "errno",
            "lxcpath"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "creat",
          "args": [
            "lxcpath",
            "0660"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_create_tty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3410-3456",
          "snippet": "int lxc_create_tty(const char *name, struct lxc_conf *conf)\n{\n\tstruct lxc_tty_info *tty_info = &conf->tty_info;\n\tint i, ret;\n\n\t/* no tty in the configuration */\n\tif (!conf->tty)\n\t\treturn 0;\n\n\ttty_info->pty_info =\n\t\tmalloc(sizeof(*tty_info->pty_info)*conf->tty);\n\tif (!tty_info->pty_info) {\n\t\tSYSERROR(\"failed to allocate pty_info\");\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < conf->tty; i++) {\n\n\t\tstruct lxc_pty_info *pty_info = &tty_info->pty_info[i];\n\n\t\tprocess_lock();\n\t\tret = openpty(&pty_info->master, &pty_info->slave,\n\t\t\t    pty_info->name, NULL, NULL);\n\t\tprocess_unlock();\n\t\tif (ret) {\n\t\t\tSYSERROR(\"failed to create pty #%d\", i);\n\t\t\ttty_info->nbtty = i;\n\t\t\tlxc_delete_tty(tty_info);\n\t\t\treturn -1;\n\t\t}\n\n\t\tDEBUG(\"allocated pty '%s' (%d/%d)\",\n\t\t      pty_info->name, pty_info->master, pty_info->slave);\n\n\t\t/* Prevent leaking the file descriptors to the container */\n\t\tfcntl(pty_info->master, F_SETFD, FD_CLOEXEC);\n\t\tfcntl(pty_info->slave, F_SETFD, FD_CLOEXEC);\n\n\t\tpty_info->busy = 0;\n\t}\n\n\ttty_info->nbtty = conf->tty;\n\n\tINFO(\"tty's configured\");\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_create_tty(const char *name, struct lxc_conf *conf)\n{\n\tstruct lxc_tty_info *tty_info = &conf->tty_info;\n\tint i, ret;\n\n\t/* no tty in the configuration */\n\tif (!conf->tty)\n\t\treturn 0;\n\n\ttty_info->pty_info =\n\t\tmalloc(sizeof(*tty_info->pty_info)*conf->tty);\n\tif (!tty_info->pty_info) {\n\t\tSYSERROR(\"failed to allocate pty_info\");\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < conf->tty; i++) {\n\n\t\tstruct lxc_pty_info *pty_info = &tty_info->pty_info[i];\n\n\t\tprocess_lock();\n\t\tret = openpty(&pty_info->master, &pty_info->slave,\n\t\t\t    pty_info->name, NULL, NULL);\n\t\tprocess_unlock();\n\t\tif (ret) {\n\t\t\tSYSERROR(\"failed to create pty #%d\", i);\n\t\t\ttty_info->nbtty = i;\n\t\t\tlxc_delete_tty(tty_info);\n\t\t\treturn -1;\n\t\t}\n\n\t\tDEBUG(\"allocated pty '%s' (%d/%d)\",\n\t\t      pty_info->name, pty_info->master, pty_info->slave);\n\n\t\t/* Prevent leaking the file descriptors to the container */\n\t\tfcntl(pty_info->master, F_SETFD, FD_CLOEXEC);\n\t\tfcntl(pty_info->slave, F_SETFD, FD_CLOEXEC);\n\n\t\tpty_info->busy = 0;\n\t}\n\n\ttty_info->nbtty = conf->tty;\n\n\tINFO(\"tty's configured\");\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"error unlinking %s\"",
            "path"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "path"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "sizeof(path)",
            "\"%s/dev/console\"",
            "rootfs->mount"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"console path too long\""
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "lxcpath",
            "sizeof(lxcpath)",
            "\"%s/dev/%s/console\"",
            "rootfs->mount",
            "ttydir"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"created %s\"",
            "path"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed with errno %d to create %s\"",
            "errno",
            "path"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "path",
            "0755"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "241-262",
          "snippet": "extern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "sizeof(path)",
            "\"%s/dev/%s\"",
            "rootfs->mount",
            "ttydir"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int setup_ttydir_console(const struct lxc_rootfs *rootfs,\n\t\t\t const struct lxc_console *console,\n\t\t\t char *ttydir)\n{\n\tchar path[MAXPATHLEN], lxcpath[MAXPATHLEN];\n\tint ret;\n\n\t/* create rootfs/dev/<ttydir> directory */\n\tret = snprintf(path, sizeof(path), \"%s/dev/%s\", rootfs->mount,\n\t\t       ttydir);\n\tif (ret >= sizeof(path))\n\t\treturn -1;\n\tret = mkdir(path, 0755);\n\tif (ret && errno != EEXIST) {\n\t\tSYSERROR(\"failed with errno %d to create %s\", errno, path);\n\t\treturn -1;\n\t}\n\tINFO(\"created %s\", path);\n\n\tret = snprintf(lxcpath, sizeof(lxcpath), \"%s/dev/%s/console\",\n\t\t       rootfs->mount, ttydir);\n\tif (ret >= sizeof(lxcpath)) {\n\t\tERROR(\"console path too long\");\n\t\treturn -1;\n\t}\n\n\tsnprintf(path, sizeof(path), \"%s/dev/console\", rootfs->mount);\n\tret = unlink(path);\n\tif (ret && errno != ENOENT) {\n\t\tSYSERROR(\"error unlinking %s\", path);\n\t\treturn -1;\n\t}\n\n\tret = creat(lxcpath, 0660);\n\tif (ret==-1 && errno != EEXIST) {\n\t\tSYSERROR(\"error %d creating %s\", errno, lxcpath);\n\t\treturn -1;\n\t}\n\tif (ret >= 0)\n\t\tclose(ret);\n\n\tif (console->master < 0) {\n\t\tINFO(\"no console\");\n\t\treturn 0;\n\t}\n\n\tif (safe_mount(console->name, lxcpath, \"none\", MS_BIND, 0, rootfs->mount)) {\n\t\tERROR(\"failed to mount '%s' on '%s'\", console->name, lxcpath);\n\t\treturn -1;\n\t}\n\n\t/* create symlink from rootfs/dev/console to 'lxc/console' */\n\tret = snprintf(lxcpath, sizeof(lxcpath), \"%s/console\", ttydir);\n\tif (ret >= sizeof(lxcpath)) {\n\t\tERROR(\"lxc/console path too long\");\n\t\treturn -1;\n\t}\n\tret = symlink(lxcpath, path);\n\tif (ret) {\n\t\tSYSERROR(\"failed to create symlink for console\");\n\t\treturn -1;\n\t}\n\n\tINFO(\"console has been setup on %s\", lxcpath);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "setup_dev_console",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "1457-1497",
    "snippet": "static int setup_dev_console(const struct lxc_rootfs *rootfs,\n\t\t\t const struct lxc_console *console)\n{\n\tchar path[MAXPATHLEN];\n\tint ret, fd;\n\n\tret = snprintf(path, sizeof(path), \"%s/dev/console\", rootfs->mount);\n\tif (ret >= sizeof(path)) {\n\t\tERROR(\"console path too long\");\n\t\treturn -1;\n\t}\n\n\tfd = open(path, O_CREAT | O_EXCL, S_IXUSR | S_IXGRP | S_IXOTH);\n\tif (fd < 0) {\n\t\tif (errno != EEXIST) {\n\t\t\tSYSERROR(\"failed to create console\");\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tclose(fd);\n\t}\n\n\tif (console->master < 0) {\n\t\tINFO(\"no console\");\n\t\treturn 0;\n\t}\n\n\tif (chmod(console->name, S_IXUSR | S_IXGRP | S_IXOTH)) {\n\t\tSYSERROR(\"failed to set mode '0%o' to '%s'\",\n\t\t\t S_IXUSR | S_IXGRP | S_IXOTH, console->name);\n\t\treturn -1;\n\t}\n\n\tif (safe_mount(console->name, path, \"none\", MS_BIND, 0, rootfs->mount)) {\n\t\tERROR(\"failed to mount '%s' on '%s'\", console->name, path);\n\t\treturn -1;\n\t}\n\n\tINFO(\"console has been setup\");\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"console has been setup\""
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to mount '%s' on '%s'\"",
            "console->name",
            "path"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_mount",
          "args": [
            "console->name",
            "path",
            "\"none\"",
            "MS_BIND",
            "0",
            "rootfs->mount"
          ],
          "line": 1490
        },
        "resolved": true,
        "details": {
          "function_name": "safe_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1687-1743",
          "snippet": "int safe_mount(const char *src, const char *dest, const char *fstype,\n\t\tunsigned long flags, const void *data, const char *rootfs)\n{\n\tint srcfd = -1, destfd, ret, saved_errno;\n\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n\tconst char *mntsrc = src;\n\n\tif (!rootfs)\n\t\trootfs = \"\";\n\n\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n\tif (flags & MS_BIND && src && src[0] != '/') {\n\t\tINFO(\"this is a relative bind mount\");\n\t\tsrcfd = open_without_symlink(src, NULL);\n\t\tif (srcfd < 0)\n\t\t\treturn srcfd;\n\t\tret = snprintf(srcbuf, 50, \"/proc/self/fd/%d\", srcfd);\n\t\tif (ret < 0 || ret > 50) {\n\t\t\tclose(srcfd);\n\t\t\tERROR(\"Out of memory\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmntsrc = srcbuf;\n\t}\n\n\tdestfd = open_without_symlink(dest, rootfs);\n\tif (destfd < 0) {\n\t\tif (srcfd != -1) {\n\t\t\tsaved_errno = errno;\n\t\t\tclose(srcfd);\n\t\t\terrno = saved_errno;\n\t\t}\n\t\treturn destfd;\n\t}\n\n\tret = snprintf(destbuf, 50, \"/proc/self/fd/%d\", destfd);\n\tif (ret < 0 || ret > 50) {\n\t\tif (srcfd != -1)\n\t\t\tclose(srcfd);\n\t\tclose(destfd);\n\t\tERROR(\"Out of memory\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = mount(mntsrc, destbuf, fstype, flags, data);\n\tsaved_errno = errno;\n\tif (srcfd != -1)\n\t\tclose(srcfd);\n\tclose(destfd);\n\tif (ret < 0) {\n\t\terrno = saved_errno;\n\t\tSYSERROR(\"Failed to mount %s onto %s\", src, dest);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint safe_mount(const char *src, const char *dest, const char *fstype,\n\t\tunsigned long flags, const void *data, const char *rootfs)\n{\n\tint srcfd = -1, destfd, ret, saved_errno;\n\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n\tconst char *mntsrc = src;\n\n\tif (!rootfs)\n\t\trootfs = \"\";\n\n\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n\tif (flags & MS_BIND && src && src[0] != '/') {\n\t\tINFO(\"this is a relative bind mount\");\n\t\tsrcfd = open_without_symlink(src, NULL);\n\t\tif (srcfd < 0)\n\t\t\treturn srcfd;\n\t\tret = snprintf(srcbuf, 50, \"/proc/self/fd/%d\", srcfd);\n\t\tif (ret < 0 || ret > 50) {\n\t\t\tclose(srcfd);\n\t\t\tERROR(\"Out of memory\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmntsrc = srcbuf;\n\t}\n\n\tdestfd = open_without_symlink(dest, rootfs);\n\tif (destfd < 0) {\n\t\tif (srcfd != -1) {\n\t\t\tsaved_errno = errno;\n\t\t\tclose(srcfd);\n\t\t\terrno = saved_errno;\n\t\t}\n\t\treturn destfd;\n\t}\n\n\tret = snprintf(destbuf, 50, \"/proc/self/fd/%d\", destfd);\n\tif (ret < 0 || ret > 50) {\n\t\tif (srcfd != -1)\n\t\t\tclose(srcfd);\n\t\tclose(destfd);\n\t\tERROR(\"Out of memory\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = mount(mntsrc, destbuf, fstype, flags, data);\n\tsaved_errno = errno;\n\tif (srcfd != -1)\n\t\tclose(srcfd);\n\tclose(destfd);\n\tif (ret < 0) {\n\t\terrno = saved_errno;\n\t\tSYSERROR(\"Failed to mount %s onto %s\", src, dest);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to set mode '0%o' to '%s'\"",
            "S_IXUSR | S_IXGRP | S_IXOTH",
            "console->name"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "console->name",
            "S_IXUSR | S_IXGRP | S_IXOTH"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"no console\""
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to create console\""
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "path",
            "O_CREAT | O_EXCL",
            "S_IXUSR | S_IXGRP | S_IXOTH"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "37-82",
          "snippet": "int lxc_abstract_unix_open(const char *path, int type, int flags)\n{\n\tint fd;\n\tsize_t len;\n\tstruct sockaddr_un addr;\n\n\tif (flags & O_TRUNC)\n\t\tunlink(path);\n\n\tfd = socket(PF_UNIX, type, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\n\t/* Clear address structure */\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (!path)\n\t\treturn fd;\n\n\taddr.sun_family = AF_UNIX;\n\n\tlen = strlen(&path[1]) + 1;\n\tif (len >= sizeof(addr.sun_path) - 1) {\n\t\tclose(fd);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\t/* addr.sun_path[0] has already been set to 0 by memset() */\n\tstrncpy(&addr.sun_path[1], &path[1], strlen(&path[1]));\n\n\tif (bind(fd, (struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path) + len)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\tif (type == SOCK_STREAM && listen(fd, 100)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_open(const char *path, int type, int flags)\n{\n\tint fd;\n\tsize_t len;\n\tstruct sockaddr_un addr;\n\n\tif (flags & O_TRUNC)\n\t\tunlink(path);\n\n\tfd = socket(PF_UNIX, type, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\n\t/* Clear address structure */\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (!path)\n\t\treturn fd;\n\n\taddr.sun_family = AF_UNIX;\n\n\tlen = strlen(&path[1]) + 1;\n\tif (len >= sizeof(addr.sun_path) - 1) {\n\t\tclose(fd);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\t/* addr.sun_path[0] has already been set to 0 by memset() */\n\tstrncpy(&addr.sun_path[1], &path[1], strlen(&path[1]));\n\n\tif (bind(fd, (struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path) + len)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\tif (type == SOCK_STREAM && listen(fd, 100)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"console path too long\""
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "sizeof(path)",
            "\"%s/dev/console\"",
            "rootfs->mount"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int setup_dev_console(const struct lxc_rootfs *rootfs,\n\t\t\t const struct lxc_console *console)\n{\n\tchar path[MAXPATHLEN];\n\tint ret, fd;\n\n\tret = snprintf(path, sizeof(path), \"%s/dev/console\", rootfs->mount);\n\tif (ret >= sizeof(path)) {\n\t\tERROR(\"console path too long\");\n\t\treturn -1;\n\t}\n\n\tfd = open(path, O_CREAT | O_EXCL, S_IXUSR | S_IXGRP | S_IXOTH);\n\tif (fd < 0) {\n\t\tif (errno != EEXIST) {\n\t\t\tSYSERROR(\"failed to create console\");\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tclose(fd);\n\t}\n\n\tif (console->master < 0) {\n\t\tINFO(\"no console\");\n\t\treturn 0;\n\t}\n\n\tif (chmod(console->name, S_IXUSR | S_IXGRP | S_IXOTH)) {\n\t\tSYSERROR(\"failed to set mode '0%o' to '%s'\",\n\t\t\t S_IXUSR | S_IXGRP | S_IXOTH, console->name);\n\t\treturn -1;\n\t}\n\n\tif (safe_mount(console->name, path, \"none\", MS_BIND, 0, rootfs->mount)) {\n\t\tERROR(\"failed to mount '%s' on '%s'\", console->name, path);\n\t\treturn -1;\n\t}\n\n\tINFO(\"console has been setup\");\n\treturn 0;\n}"
  },
  {
    "function_name": "setup_personality",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "1440-1455",
    "snippet": "static int setup_personality(int persona)\n{\n\t#if HAVE_SYS_PERSONALITY_H\n\tif (persona == -1)\n\t\treturn 0;\n\n\tif (personality(persona) < 0) {\n\t\tSYSERROR(\"failed to set personality to '0x%x'\", persona);\n\t\treturn -1;\n\t}\n\n\tINFO(\"set personality to '0x%x'\", persona);\n\t#endif\n\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"set personality to '0x%x'\"",
            "persona"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to set personality to '0x%x'\"",
            "persona"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "personality",
          "args": [
            "persona"
          ],
          "line": 1446
        },
        "resolved": true,
        "details": {
          "function_name": "setup_personality",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1440-1455",
          "snippet": "static int setup_personality(int persona)\n{\n\t#if HAVE_SYS_PERSONALITY_H\n\tif (persona == -1)\n\t\treturn 0;\n\n\tif (personality(persona) < 0) {\n\t\tSYSERROR(\"failed to set personality to '0x%x'\", persona);\n\t\treturn -1;\n\t}\n\n\tINFO(\"set personality to '0x%x'\", persona);\n\t#endif\n\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int setup_personality(int persona)\n{\n\t#if HAVE_SYS_PERSONALITY_H\n\tif (persona == -1)\n\t\treturn 0;\n\n\tif (personality(persona) < 0) {\n\t\tSYSERROR(\"failed to set personality to '0x%x'\", persona);\n\t\treturn -1;\n\t}\n\n\tINFO(\"set personality to '0x%x'\", persona);\n\t#endif\n\n\treturn 0;\n}"
  },
  {
    "function_name": "setup_pts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "1393-1438",
    "snippet": "static int setup_pts(int pts)\n{\n\tchar target[PATH_MAX];\n\n\tif (!pts)\n\t\treturn 0;\n\n\tif (!access(\"/dev/pts/ptmx\", F_OK) && umount(\"/dev/pts\")) {\n\t\tSYSERROR(\"failed to umount 'dev/pts'\");\n\t\treturn -1;\n\t}\n\n\tif (mkdir(\"/dev/pts\", 0755)) {\n\t\tif ( errno != EEXIST ) {\n\t\t    SYSERROR(\"failed to create '/dev/pts'\");\n\t\t    return -1;\n\t\t}\n\t}\n\n\tif (mount(\"devpts\", \"/dev/pts\", \"devpts\", MS_MGC_VAL,\n\t\t  \"newinstance,ptmxmode=0666,mode=0620,gid=5\")) {\n\t\tSYSERROR(\"failed to mount a new instance of '/dev/pts'\");\n\t\treturn -1;\n\t}\n\n\tif (access(\"/dev/ptmx\", F_OK)) {\n\t\tif (!symlink(\"/dev/pts/ptmx\", \"/dev/ptmx\"))\n\t\t\tgoto out;\n\t\tSYSERROR(\"failed to symlink '/dev/pts/ptmx'->'/dev/ptmx'\");\n\t\treturn -1;\n\t}\n\n\tif (realpath(\"/dev/ptmx\", target) && !strcmp(target, \"/dev/pts/ptmx\"))\n\t\tgoto out;\n\n\t/* fallback here, /dev/pts/ptmx exists just mount bind */\n\tif (mount(\"/dev/pts/ptmx\", \"/dev/ptmx\", \"none\", MS_BIND, 0)) {\n\t\tSYSERROR(\"mount failed '/dev/pts/ptmx'->'/dev/ptmx'\");\n\t\treturn -1;\n\t}\n\n\tINFO(\"created new pts instance\");\n\nout:\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"created new pts instance\""
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"mount failed '/dev/pts/ptmx'->'/dev/ptmx'\""
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"/dev/pts/ptmx\"",
            "\"/dev/ptmx\"",
            "\"none\"",
            "MS_BIND",
            "0"
          ],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "mount_entry_on_generic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1838-1869",
          "snippet": "static inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "target",
            "\"/dev/pts/ptmx\""
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realpath",
          "args": [
            "\"/dev/ptmx\"",
            "target"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to symlink '/dev/pts/ptmx'->'/dev/ptmx'\""
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "symlink",
          "args": [
            "\"/dev/pts/ptmx\"",
            "\"/dev/ptmx\""
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "open_without_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1616-1677",
          "snippet": "static int open_without_symlink(const char *target, const char *prefix_skip)\n{\n\tint curlen = 0, dirfd, fulllen, i;\n\tchar *dup = NULL;\n\n\tfulllen = strlen(target);\n\n\t/* make sure prefix-skip makes sense */\n\tif (prefix_skip && strlen(prefix_skip) > 0) {\n\t\tcurlen = strlen(prefix_skip);\n\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n\t\t\tERROR(\"WHOA there - target '%s' didn't start with prefix '%s'\",\n\t\t\t\ttarget, prefix_skip);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/*\n\t\t * get_nextpath() expects the curlen argument to be\n\t\t * on a  (turned into \\0) / or before it, so decrement\n\t\t * curlen to make sure that happens\n\t\t */\n\t\tif (curlen)\n\t\t\tcurlen--;\n\t} else {\n\t\tprefix_skip = \"/\";\n\t\tcurlen = 0;\n\t}\n\n\t/* Make a copy of target which we can hack up, and tokenize it */\n\tif ((dup = strdup(target)) == NULL) {\n\t\tSYSERROR(\"Out of memory checking for symbolic link\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < fulllen; i++) {\n\t\tif (dup[i] == '/')\n\t\t\tdup[i] = '\\0';\n\t}\n\n\tdirfd = open(prefix_skip, O_RDONLY);\n\tif (dirfd < 0)\n\t\tgoto out;\n\twhile (1) {\n\t\tint newfd, saved_errno;\n\t\tchar *nextpath;\n\n\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n\t\t\tgoto out;\n\t\tnewfd = open_if_safe(dirfd, nextpath);\n\t\tsaved_errno = errno;\n\t\tclose(dirfd);\n\t\tdirfd = newfd;\n\t\tif (newfd < 0) {\n\t\t\terrno = saved_errno;\n\t\t\tif (errno == ELOOP)\n\t\t\t\tSYSERROR(\"%s in %s was a symbolic link!\", nextpath, target);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfree(dup);\n\treturn dirfd;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int open_without_symlink(const char *target, const char *prefix_skip)\n{\n\tint curlen = 0, dirfd, fulllen, i;\n\tchar *dup = NULL;\n\n\tfulllen = strlen(target);\n\n\t/* make sure prefix-skip makes sense */\n\tif (prefix_skip && strlen(prefix_skip) > 0) {\n\t\tcurlen = strlen(prefix_skip);\n\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n\t\t\tERROR(\"WHOA there - target '%s' didn't start with prefix '%s'\",\n\t\t\t\ttarget, prefix_skip);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/*\n\t\t * get_nextpath() expects the curlen argument to be\n\t\t * on a  (turned into \\0) / or before it, so decrement\n\t\t * curlen to make sure that happens\n\t\t */\n\t\tif (curlen)\n\t\t\tcurlen--;\n\t} else {\n\t\tprefix_skip = \"/\";\n\t\tcurlen = 0;\n\t}\n\n\t/* Make a copy of target which we can hack up, and tokenize it */\n\tif ((dup = strdup(target)) == NULL) {\n\t\tSYSERROR(\"Out of memory checking for symbolic link\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < fulllen; i++) {\n\t\tif (dup[i] == '/')\n\t\t\tdup[i] = '\\0';\n\t}\n\n\tdirfd = open(prefix_skip, O_RDONLY);\n\tif (dirfd < 0)\n\t\tgoto out;\n\twhile (1) {\n\t\tint newfd, saved_errno;\n\t\tchar *nextpath;\n\n\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n\t\t\tgoto out;\n\t\tnewfd = open_if_safe(dirfd, nextpath);\n\t\tsaved_errno = errno;\n\t\tclose(dirfd);\n\t\tdirfd = newfd;\n\t\tif (newfd < 0) {\n\t\t\terrno = saved_errno;\n\t\t\tif (errno == ELOOP)\n\t\t\t\tSYSERROR(\"%s in %s was a symbolic link!\", nextpath, target);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfree(dup);\n\treturn dirfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "\"/dev/ptmx\"",
            "F_OK"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to mount a new instance of '/dev/pts'\""
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to create '/dev/pts'\""
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "\"/dev/pts\"",
            "0755"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "241-262",
          "snippet": "extern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to umount 'dev/pts'\""
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umount",
          "args": [
            "\"/dev/pts\""
          ],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "rbd_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcrbd.c",
          "lines": "174-181",
          "snippet": "int rbd_umount(struct bdev *bdev)\n{\n\tif (strcmp(bdev->type, \"rbd\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\treturn umount(bdev->dest);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <inttypes.h> /* Required for PRIu64 to work. */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h> /* Required for PRIu64 to work. */\n\nint rbd_umount(struct bdev *bdev)\n{\n\tif (strcmp(bdev->type, \"rbd\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\treturn umount(bdev->dest);\n}"
        }
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "\"/dev/pts/ptmx\"",
            "F_OK"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int setup_pts(int pts)\n{\n\tchar target[PATH_MAX];\n\n\tif (!pts)\n\t\treturn 0;\n\n\tif (!access(\"/dev/pts/ptmx\", F_OK) && umount(\"/dev/pts\")) {\n\t\tSYSERROR(\"failed to umount 'dev/pts'\");\n\t\treturn -1;\n\t}\n\n\tif (mkdir(\"/dev/pts\", 0755)) {\n\t\tif ( errno != EEXIST ) {\n\t\t    SYSERROR(\"failed to create '/dev/pts'\");\n\t\t    return -1;\n\t\t}\n\t}\n\n\tif (mount(\"devpts\", \"/dev/pts\", \"devpts\", MS_MGC_VAL,\n\t\t  \"newinstance,ptmxmode=0666,mode=0620,gid=5\")) {\n\t\tSYSERROR(\"failed to mount a new instance of '/dev/pts'\");\n\t\treturn -1;\n\t}\n\n\tif (access(\"/dev/ptmx\", F_OK)) {\n\t\tif (!symlink(\"/dev/pts/ptmx\", \"/dev/ptmx\"))\n\t\t\tgoto out;\n\t\tSYSERROR(\"failed to symlink '/dev/pts/ptmx'->'/dev/ptmx'\");\n\t\treturn -1;\n\t}\n\n\tif (realpath(\"/dev/ptmx\", target) && !strcmp(target, \"/dev/pts/ptmx\"))\n\t\tgoto out;\n\n\t/* fallback here, /dev/pts/ptmx exists just mount bind */\n\tif (mount(\"/dev/pts/ptmx\", \"/dev/ptmx\", \"none\", MS_BIND, 0)) {\n\t\tSYSERROR(\"mount failed '/dev/pts/ptmx'->'/dev/ptmx'\");\n\t\treturn -1;\n\t}\n\n\tINFO(\"created new pts instance\");\n\nout:\n\treturn 0;\n}"
  },
  {
    "function_name": "setup_pivot_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "1377-1391",
    "snippet": "static int setup_pivot_root(const struct lxc_rootfs *rootfs)\n{\n\tif (!rootfs->path)\n\t\treturn 0;\n\n\tif (detect_ramfs_rootfs()) {\n\t\tif (prepare_ramfs_root(rootfs->mount))\n\t\t\treturn -1;\n\t} else if (setup_rootfs_pivot_root(rootfs->mount)) {\n\t\tERROR(\"failed to setup pivot root\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to setup pivot root\""
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_rootfs_pivot_root",
          "args": [
            "rootfs->mount"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "setup_rootfs_pivot_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1059-1118",
          "snippet": "static int setup_rootfs_pivot_root(const char *rootfs)\n{\n\tint oldroot = -1, newroot = -1;\n\n\toldroot = open(\"/\", O_DIRECTORY | O_RDONLY);\n\tif (oldroot < 0) {\n\t\tSYSERROR(\"Error opening old-/ for fchdir\");\n\t\treturn -1;\n\t}\n\tnewroot = open(rootfs, O_DIRECTORY | O_RDONLY);\n\tif (newroot < 0) {\n\t\tSYSERROR(\"Error opening new-/ for fchdir\");\n\t\tgoto fail;\n\t}\n\n\t/* change into new root fs */\n\tif (fchdir(newroot)) {\n\t\tSYSERROR(\"can't chdir to new rootfs '%s'\", rootfs);\n\t\tgoto fail;\n\t}\n\n\t/* pivot_root into our new root fs */\n\tif (pivot_root(\".\", \".\")) {\n\t\tSYSERROR(\"pivot_root syscall failed\");\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * at this point the old-root is mounted on top of our new-root\n\t * To unmounted it we must not be chdir'd into it, so escape back\n\t * to old-root\n\t */\n\tif (fchdir(oldroot) < 0) {\n\t\tSYSERROR(\"Error entering oldroot\");\n\t\tgoto fail;\n\t}\n\tif (umount2(\".\", MNT_DETACH) < 0) {\n\t\tSYSERROR(\"Error detaching old root\");\n\t\tgoto fail;\n\t}\n\n\tif (fchdir(newroot) < 0) {\n\t\tSYSERROR(\"Error re-entering newroot\");\n\t\tgoto fail;\n\t}\n\n\tclose(oldroot);\n\tclose(newroot);\n\n\tDEBUG(\"pivot_root syscall to '%s' successful\", rootfs);\n\n\treturn 0;\n\nfail:\n\tif (oldroot != -1)\n\t\tclose(oldroot);\n\tif (newroot != -1)\n\t\tclose(newroot);\n\treturn -1;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int setup_rootfs_pivot_root(const char *rootfs)\n{\n\tint oldroot = -1, newroot = -1;\n\n\toldroot = open(\"/\", O_DIRECTORY | O_RDONLY);\n\tif (oldroot < 0) {\n\t\tSYSERROR(\"Error opening old-/ for fchdir\");\n\t\treturn -1;\n\t}\n\tnewroot = open(rootfs, O_DIRECTORY | O_RDONLY);\n\tif (newroot < 0) {\n\t\tSYSERROR(\"Error opening new-/ for fchdir\");\n\t\tgoto fail;\n\t}\n\n\t/* change into new root fs */\n\tif (fchdir(newroot)) {\n\t\tSYSERROR(\"can't chdir to new rootfs '%s'\", rootfs);\n\t\tgoto fail;\n\t}\n\n\t/* pivot_root into our new root fs */\n\tif (pivot_root(\".\", \".\")) {\n\t\tSYSERROR(\"pivot_root syscall failed\");\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * at this point the old-root is mounted on top of our new-root\n\t * To unmounted it we must not be chdir'd into it, so escape back\n\t * to old-root\n\t */\n\tif (fchdir(oldroot) < 0) {\n\t\tSYSERROR(\"Error entering oldroot\");\n\t\tgoto fail;\n\t}\n\tif (umount2(\".\", MNT_DETACH) < 0) {\n\t\tSYSERROR(\"Error detaching old root\");\n\t\tgoto fail;\n\t}\n\n\tif (fchdir(newroot) < 0) {\n\t\tSYSERROR(\"Error re-entering newroot\");\n\t\tgoto fail;\n\t}\n\n\tclose(oldroot);\n\tclose(newroot);\n\n\tDEBUG(\"pivot_root syscall to '%s' successful\", rootfs);\n\n\treturn 0;\n\nfail:\n\tif (oldroot != -1)\n\t\tclose(oldroot);\n\tif (newroot != -1)\n\t\tclose(newroot);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_ramfs_root",
          "args": [
            "rootfs->mount"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_ramfs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1288-1375",
          "snippet": "int prepare_ramfs_root(char *root)\n{\n\tchar buf[LXC_LINELEN], *p;\n\tchar nroot[PATH_MAX];\n\tFILE *f;\n\tint i;\n\tchar *p2;\n\n\tif (realpath(root, nroot) == NULL)\n\t\treturn -1;\n\n\tif (chdir(\"/\") == -1)\n\t\treturn -1;\n\n\t/*\n\t * We could use here MS_MOVE, but in userns this mount is\n\t * locked and can't be moved.\n\t */\n\tif (mount(root, \"/\", NULL, MS_REC | MS_BIND, NULL)) {\n\t\tSYSERROR(\"Failed to move %s into /\", root);\n\t\treturn -1;\n\t}\n\n\tif (mount(NULL, \"/\", NULL, MS_REC | MS_PRIVATE, NULL)) {\n\t\tSYSERROR(\"Failed to make . rprivate\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * The following code cleans up inhereted mounts which are not\n\t * required for CT.\n\t *\n\t * The mountinfo file shows not all mounts, if a few points have been\n\t * unmounted between read operations from the mountinfo. So we need to\n\t * read mountinfo a few times.\n\t *\n\t * This loop can be skipped if a container uses unserns, because all\n\t * inherited mounts are locked and we should live with all this trash.\n\t */\n\twhile (1) {\n\t\tint progress = 0;\n\n\t\tf = fopen(\"./proc/self/mountinfo\", \"r\");\n\t\tif (!f) {\n\t\t\tSYSERROR(\"Unable to open /proc/self/mountinfo\");\n\t\t\treturn -1;\n\t\t}\n\t\twhile (fgets(buf, LXC_LINELEN, f)) {\n\t\t\tfor (p = buf, i=0; p && i < 4; i++)\n\t\t\t\tp = strchr(p+1, ' ');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\tp2 = strchr(p+1, ' ');\n\t\t\tif (!p2)\n\t\t\t\tcontinue;\n\n\t\t\t*p2 = '\\0';\n\t\t\t*p = '.';\n\n\t\t\tif (strcmp(p + 1, \"/\") == 0)\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(p + 1, \"/proc\") == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (umount2(p, MNT_DETACH) == 0)\n\t\t\t\tprogress++;\n\t\t}\n\t\tfclose(f);\n\t\tif (!progress)\n\t\t\tbreak;\n\t}\n\n\t/* This also can be skipped if a container uses unserns */\n\tumount2(\"./proc\", MNT_DETACH);\n\n\t/* It is weird, but chdir(\"..\") moves us in a new root */\n\tif (chdir(\"..\") == -1) {\n\t\tSYSERROR(\"Unable to change working directory\");\n\t\treturn -1;\n\t}\n\n\tif (chroot(\".\") == -1) {\n\t\tSYSERROR(\"Unable to chroot\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MS_PRIVATE (1<<18)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\n#define MS_PRIVATE (1<<18)\n\nint prepare_ramfs_root(char *root)\n{\n\tchar buf[LXC_LINELEN], *p;\n\tchar nroot[PATH_MAX];\n\tFILE *f;\n\tint i;\n\tchar *p2;\n\n\tif (realpath(root, nroot) == NULL)\n\t\treturn -1;\n\n\tif (chdir(\"/\") == -1)\n\t\treturn -1;\n\n\t/*\n\t * We could use here MS_MOVE, but in userns this mount is\n\t * locked and can't be moved.\n\t */\n\tif (mount(root, \"/\", NULL, MS_REC | MS_BIND, NULL)) {\n\t\tSYSERROR(\"Failed to move %s into /\", root);\n\t\treturn -1;\n\t}\n\n\tif (mount(NULL, \"/\", NULL, MS_REC | MS_PRIVATE, NULL)) {\n\t\tSYSERROR(\"Failed to make . rprivate\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * The following code cleans up inhereted mounts which are not\n\t * required for CT.\n\t *\n\t * The mountinfo file shows not all mounts, if a few points have been\n\t * unmounted between read operations from the mountinfo. So we need to\n\t * read mountinfo a few times.\n\t *\n\t * This loop can be skipped if a container uses unserns, because all\n\t * inherited mounts are locked and we should live with all this trash.\n\t */\n\twhile (1) {\n\t\tint progress = 0;\n\n\t\tf = fopen(\"./proc/self/mountinfo\", \"r\");\n\t\tif (!f) {\n\t\t\tSYSERROR(\"Unable to open /proc/self/mountinfo\");\n\t\t\treturn -1;\n\t\t}\n\t\twhile (fgets(buf, LXC_LINELEN, f)) {\n\t\t\tfor (p = buf, i=0; p && i < 4; i++)\n\t\t\t\tp = strchr(p+1, ' ');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\tp2 = strchr(p+1, ' ');\n\t\t\tif (!p2)\n\t\t\t\tcontinue;\n\n\t\t\t*p2 = '\\0';\n\t\t\t*p = '.';\n\n\t\t\tif (strcmp(p + 1, \"/\") == 0)\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(p + 1, \"/proc\") == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (umount2(p, MNT_DETACH) == 0)\n\t\t\t\tprogress++;\n\t\t}\n\t\tfclose(f);\n\t\tif (!progress)\n\t\t\tbreak;\n\t}\n\n\t/* This also can be skipped if a container uses unserns */\n\tumount2(\"./proc\", MNT_DETACH);\n\n\t/* It is weird, but chdir(\"..\") moves us in a new root */\n\tif (chdir(\"..\") == -1) {\n\t\tSYSERROR(\"Unable to change working directory\");\n\t\treturn -1;\n\t}\n\n\tif (chroot(\".\") == -1) {\n\t\tSYSERROR(\"Unable to chroot\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "detect_ramfs_rootfs",
          "args": [],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "detect_ramfs_rootfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1166-1200",
          "snippet": "bool detect_ramfs_rootfs(void)\n{\n\tFILE *f;\n\tchar *p, *p2;\n\tchar *line = NULL;\n\tsize_t len = 0;\n\tint i;\n\n\tf = fopen(\"/proc/self/mountinfo\", \"r\");\n\tif (!f)\n\t\treturn false;\n\n\twhile (getline(&line, &len, f) != -1) {\n\t\tfor (p = line, i = 0; p && i < 4; i++)\n\t\t\tp = strchr(p + 1, ' ');\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tp2 = strchr(p + 1, ' ');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\t\tif (strcmp(p + 1, \"/\") == 0) {\n\t\t\t// this is '/'.  is it the ramfs?\n\t\t\tp = strchr(p2 + 1, '-');\n\t\t\tif (p && strncmp(p, \"- rootfs rootfs \", 16) == 0) {\n\t\t\t\tfree(line);\n\t\t\t\tfclose(f);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tfree(line);\n\tfclose(f);\n\treturn false;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool detect_ramfs_rootfs(void)\n{\n\tFILE *f;\n\tchar *p, *p2;\n\tchar *line = NULL;\n\tsize_t len = 0;\n\tint i;\n\n\tf = fopen(\"/proc/self/mountinfo\", \"r\");\n\tif (!f)\n\t\treturn false;\n\n\twhile (getline(&line, &len, f) != -1) {\n\t\tfor (p = line, i = 0; p && i < 4; i++)\n\t\t\tp = strchr(p + 1, ' ');\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tp2 = strchr(p + 1, ' ');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\t\tif (strcmp(p + 1, \"/\") == 0) {\n\t\t\t// this is '/'.  is it the ramfs?\n\t\t\tp = strchr(p2 + 1, '-');\n\t\t\tif (p && strncmp(p, \"- rootfs rootfs \", 16) == 0) {\n\t\t\t\tfree(line);\n\t\t\t\tfclose(f);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tfree(line);\n\tfclose(f);\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int setup_pivot_root(const struct lxc_rootfs *rootfs)\n{\n\tif (!rootfs->path)\n\t\treturn 0;\n\n\tif (detect_ramfs_rootfs()) {\n\t\tif (prepare_ramfs_root(rootfs->mount))\n\t\t\treturn -1;\n\t} else if (setup_rootfs_pivot_root(rootfs->mount)) {\n\t\tERROR(\"failed to setup pivot root\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "prepare_ramfs_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "1288-1375",
    "snippet": "int prepare_ramfs_root(char *root)\n{\n\tchar buf[LXC_LINELEN], *p;\n\tchar nroot[PATH_MAX];\n\tFILE *f;\n\tint i;\n\tchar *p2;\n\n\tif (realpath(root, nroot) == NULL)\n\t\treturn -1;\n\n\tif (chdir(\"/\") == -1)\n\t\treturn -1;\n\n\t/*\n\t * We could use here MS_MOVE, but in userns this mount is\n\t * locked and can't be moved.\n\t */\n\tif (mount(root, \"/\", NULL, MS_REC | MS_BIND, NULL)) {\n\t\tSYSERROR(\"Failed to move %s into /\", root);\n\t\treturn -1;\n\t}\n\n\tif (mount(NULL, \"/\", NULL, MS_REC | MS_PRIVATE, NULL)) {\n\t\tSYSERROR(\"Failed to make . rprivate\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * The following code cleans up inhereted mounts which are not\n\t * required for CT.\n\t *\n\t * The mountinfo file shows not all mounts, if a few points have been\n\t * unmounted between read operations from the mountinfo. So we need to\n\t * read mountinfo a few times.\n\t *\n\t * This loop can be skipped if a container uses unserns, because all\n\t * inherited mounts are locked and we should live with all this trash.\n\t */\n\twhile (1) {\n\t\tint progress = 0;\n\n\t\tf = fopen(\"./proc/self/mountinfo\", \"r\");\n\t\tif (!f) {\n\t\t\tSYSERROR(\"Unable to open /proc/self/mountinfo\");\n\t\t\treturn -1;\n\t\t}\n\t\twhile (fgets(buf, LXC_LINELEN, f)) {\n\t\t\tfor (p = buf, i=0; p && i < 4; i++)\n\t\t\t\tp = strchr(p+1, ' ');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\tp2 = strchr(p+1, ' ');\n\t\t\tif (!p2)\n\t\t\t\tcontinue;\n\n\t\t\t*p2 = '\\0';\n\t\t\t*p = '.';\n\n\t\t\tif (strcmp(p + 1, \"/\") == 0)\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(p + 1, \"/proc\") == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (umount2(p, MNT_DETACH) == 0)\n\t\t\t\tprogress++;\n\t\t}\n\t\tfclose(f);\n\t\tif (!progress)\n\t\t\tbreak;\n\t}\n\n\t/* This also can be skipped if a container uses unserns */\n\tumount2(\"./proc\", MNT_DETACH);\n\n\t/* It is weird, but chdir(\"..\") moves us in a new root */\n\tif (chdir(\"..\") == -1) {\n\t\tSYSERROR(\"Unable to change working directory\");\n\t\treturn -1;\n\t}\n\n\tif (chroot(\".\") == -1) {\n\t\tSYSERROR(\"Unable to chroot\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define MS_PRIVATE (1<<18)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Unable to chroot\""
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chroot",
          "args": [
            "\".\""
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Unable to change working directory\""
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "\"..\""
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umount2",
          "args": [
            "\"./proc\"",
            "MNT_DETACH"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umount2",
          "args": [
            "p",
            "MNT_DETACH"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p + 1",
            "\"/proc\""
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p + 1",
            "\"/\""
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p+1",
            "' '"
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "LXC_LINELEN",
            "f"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Unable to open /proc/self/mountinfo\""
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "\"./proc/self/mountinfo\"",
            "\"r\""
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to make . rprivate\""
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "NULL",
            "\"/\"",
            "NULL",
            "MS_REC | MS_PRIVATE",
            "NULL"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "mount_entry_on_generic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1838-1869",
          "snippet": "static inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to move %s into /\"",
            "root"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "\"/\""
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realpath",
          "args": [
            "root",
            "nroot"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\n#define MS_PRIVATE (1<<18)\n\nint prepare_ramfs_root(char *root)\n{\n\tchar buf[LXC_LINELEN], *p;\n\tchar nroot[PATH_MAX];\n\tFILE *f;\n\tint i;\n\tchar *p2;\n\n\tif (realpath(root, nroot) == NULL)\n\t\treturn -1;\n\n\tif (chdir(\"/\") == -1)\n\t\treturn -1;\n\n\t/*\n\t * We could use here MS_MOVE, but in userns this mount is\n\t * locked and can't be moved.\n\t */\n\tif (mount(root, \"/\", NULL, MS_REC | MS_BIND, NULL)) {\n\t\tSYSERROR(\"Failed to move %s into /\", root);\n\t\treturn -1;\n\t}\n\n\tif (mount(NULL, \"/\", NULL, MS_REC | MS_PRIVATE, NULL)) {\n\t\tSYSERROR(\"Failed to make . rprivate\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * The following code cleans up inhereted mounts which are not\n\t * required for CT.\n\t *\n\t * The mountinfo file shows not all mounts, if a few points have been\n\t * unmounted between read operations from the mountinfo. So we need to\n\t * read mountinfo a few times.\n\t *\n\t * This loop can be skipped if a container uses unserns, because all\n\t * inherited mounts are locked and we should live with all this trash.\n\t */\n\twhile (1) {\n\t\tint progress = 0;\n\n\t\tf = fopen(\"./proc/self/mountinfo\", \"r\");\n\t\tif (!f) {\n\t\t\tSYSERROR(\"Unable to open /proc/self/mountinfo\");\n\t\t\treturn -1;\n\t\t}\n\t\twhile (fgets(buf, LXC_LINELEN, f)) {\n\t\t\tfor (p = buf, i=0; p && i < 4; i++)\n\t\t\t\tp = strchr(p+1, ' ');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\tp2 = strchr(p+1, ' ');\n\t\t\tif (!p2)\n\t\t\t\tcontinue;\n\n\t\t\t*p2 = '\\0';\n\t\t\t*p = '.';\n\n\t\t\tif (strcmp(p + 1, \"/\") == 0)\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(p + 1, \"/proc\") == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (umount2(p, MNT_DETACH) == 0)\n\t\t\t\tprogress++;\n\t\t}\n\t\tfclose(f);\n\t\tif (!progress)\n\t\t\tbreak;\n\t}\n\n\t/* This also can be skipped if a container uses unserns */\n\tumount2(\"./proc\", MNT_DETACH);\n\n\t/* It is weird, but chdir(\"..\") moves us in a new root */\n\tif (chdir(\"..\") == -1) {\n\t\tSYSERROR(\"Unable to change working directory\");\n\t\treturn -1;\n\t}\n\n\tif (chroot(\".\") == -1) {\n\t\tSYSERROR(\"Unable to chroot\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "setup_rootfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "1251-1286",
    "snippet": "static int setup_rootfs(struct lxc_conf *conf)\n{\n\tconst struct lxc_rootfs *rootfs = &conf->rootfs;\n\n\tif (!rootfs->path) {\n\t\tif (mount(\"\", \"/\", NULL, MS_SLAVE|MS_REC, 0)) {\n\t\t\tSYSERROR(\"Failed to make / rslave\");\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (access(rootfs->mount, F_OK)) {\n\t\tSYSERROR(\"failed to access to '%s', check it is present\",\n\t\t\t rootfs->mount);\n\t\treturn -1;\n\t}\n\n\t// First try mounting rootfs using a bdev\n\tstruct bdev *bdev = bdev_init(conf, rootfs->path, rootfs->mount, rootfs->options);\n\tif (bdev && bdev->ops->mount(bdev) == 0) {\n\t\tbdev_put(bdev);\n\t\tDEBUG(\"mounted '%s' on '%s'\", rootfs->path, rootfs->mount);\n\t\treturn 0;\n\t}\n\tif (bdev)\n\t\tbdev_put(bdev);\n\tif (mount_rootfs(rootfs->path, rootfs->mount, rootfs->options)) {\n\t\tERROR(\"failed to mount rootfs\");\n\t\treturn -1;\n\t}\n\n\tDEBUG(\"mounted '%s' on '%s'\", rootfs->path, rootfs->mount);\n\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"mounted '%s' on '%s'\"",
            "rootfs->path",
            "rootfs->mount"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to mount rootfs\""
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount_rootfs",
          "args": [
            "rootfs->path",
            "rootfs->mount",
            "rootfs->options"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "mount_rootfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "847-889",
          "snippet": "static int mount_rootfs(const char *rootfs, const char *target, const char *options)\n{\n\tchar absrootfs[MAXPATHLEN];\n\tstruct stat s;\n\tint i;\n\n\ttypedef int (*rootfs_cb)(const char *, const char *, const char *);\n\n\tstruct rootfs_type {\n\t\tint type;\n\t\trootfs_cb cb;\n\t} rtfs_type[] = {\n\t\t{ S_IFDIR, mount_rootfs_dir },\n\t\t{ S_IFBLK, mount_rootfs_block },\n\t\t{ S_IFREG, mount_rootfs_file },\n\t};\n\n\tif (!realpath(rootfs, absrootfs)) {\n\t\tSYSERROR(\"failed to get real path for '%s'\", rootfs);\n\t\treturn -1;\n\t}\n\n\tif (access(absrootfs, F_OK)) {\n\t\tSYSERROR(\"'%s' is not accessible\", absrootfs);\n\t\treturn -1;\n\t}\n\n\tif (stat(absrootfs, &s)) {\n\t\tSYSERROR(\"failed to stat '%s'\", absrootfs);\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < sizeof(rtfs_type)/sizeof(rtfs_type[0]); i++) {\n\n\t\tif (!__S_ISTYPE(s.st_mode, rtfs_type[i].type))\n\t\t\tcontinue;\n\n\t\treturn rtfs_type[i].cb(absrootfs, target, options);\n\t}\n\n\tERROR(\"unsupported rootfs type for '%s'\", absrootfs);\n\treturn -1;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int mount_rootfs(const char *rootfs, const char *target, const char *options)\n{\n\tchar absrootfs[MAXPATHLEN];\n\tstruct stat s;\n\tint i;\n\n\ttypedef int (*rootfs_cb)(const char *, const char *, const char *);\n\n\tstruct rootfs_type {\n\t\tint type;\n\t\trootfs_cb cb;\n\t} rtfs_type[] = {\n\t\t{ S_IFDIR, mount_rootfs_dir },\n\t\t{ S_IFBLK, mount_rootfs_block },\n\t\t{ S_IFREG, mount_rootfs_file },\n\t};\n\n\tif (!realpath(rootfs, absrootfs)) {\n\t\tSYSERROR(\"failed to get real path for '%s'\", rootfs);\n\t\treturn -1;\n\t}\n\n\tif (access(absrootfs, F_OK)) {\n\t\tSYSERROR(\"'%s' is not accessible\", absrootfs);\n\t\treturn -1;\n\t}\n\n\tif (stat(absrootfs, &s)) {\n\t\tSYSERROR(\"failed to stat '%s'\", absrootfs);\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < sizeof(rtfs_type)/sizeof(rtfs_type[0]); i++) {\n\n\t\tif (!__S_ISTYPE(s.st_mode, rtfs_type[i].type))\n\t\t\tcontinue;\n\n\t\treturn rtfs_type[i].cb(absrootfs, target, options);\n\t}\n\n\tERROR(\"unsupported rootfs type for '%s'\", absrootfs);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_put",
          "args": [
            "bdev"
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "579-585",
          "snippet": "void bdev_put(struct bdev *bdev)\n{\n\tfree(bdev->mntopts);\n\tfree(bdev->src);\n\tfree(bdev->dest);\n\tfree(bdev);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);",
            "static char *linkderef(char *path, char *dest);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);\nstatic char *linkderef(char *path, char *dest);\n\nvoid bdev_put(struct bdev *bdev)\n{\n\tfree(bdev->mntopts);\n\tfree(bdev->src);\n\tfree(bdev->dest);\n\tfree(bdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"mounted '%s' on '%s'\"",
            "rootfs->path",
            "rootfs->mount"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev->ops->mount",
          "args": [
            "bdev"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_init",
          "args": [
            "conf",
            "rootfs->path",
            "rootfs->mount",
            "rootfs->options"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "533-565",
          "snippet": "struct bdev *bdev_init(struct lxc_conf *conf, const char *src, const char *dst,\n\t\tconst char *mntopts)\n{\n\tstruct bdev *bdev;\n\tconst struct bdev_type *q;\n\n\tif (!src)\n\t\tsrc = conf->rootfs.path;\n\n\tif (!src)\n\t\treturn NULL;\n\n\tq = bdev_query(conf, src);\n\tif (!q)\n\t\treturn NULL;\n\n\tbdev = malloc(sizeof(struct bdev));\n\tif (!bdev)\n\t\treturn NULL;\n\tmemset(bdev, 0, sizeof(struct bdev));\n\tbdev->ops = q->ops;\n\tbdev->type = q->name;\n\tif (mntopts)\n\t\tbdev->mntopts = strdup(mntopts);\n\tif (src)\n\t\tbdev->src = strdup(src);\n\tif (dst)\n\t\tbdev->dest = strdup(dst);\n\tif (strcmp(bdev->type, \"nbd\") == 0)\n\t\tbdev->nbd_idx = conf->nbd_idx;\n\n\treturn bdev;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);",
            "static struct bdev *bdev_get(const char *type);",
            "static char *linkderef(char *path, char *dest);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);\nstatic struct bdev *bdev_get(const char *type);\nstatic char *linkderef(char *path, char *dest);\n\nstruct bdev *bdev_init(struct lxc_conf *conf, const char *src, const char *dst,\n\t\tconst char *mntopts)\n{\n\tstruct bdev *bdev;\n\tconst struct bdev_type *q;\n\n\tif (!src)\n\t\tsrc = conf->rootfs.path;\n\n\tif (!src)\n\t\treturn NULL;\n\n\tq = bdev_query(conf, src);\n\tif (!q)\n\t\treturn NULL;\n\n\tbdev = malloc(sizeof(struct bdev));\n\tif (!bdev)\n\t\treturn NULL;\n\tmemset(bdev, 0, sizeof(struct bdev));\n\tbdev->ops = q->ops;\n\tbdev->type = q->name;\n\tif (mntopts)\n\t\tbdev->mntopts = strdup(mntopts);\n\tif (src)\n\t\tbdev->src = strdup(src);\n\tif (dst)\n\t\tbdev->dest = strdup(dst);\n\tif (strcmp(bdev->type, \"nbd\") == 0)\n\t\tbdev->nbd_idx = conf->nbd_idx;\n\n\treturn bdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to access to '%s', check it is present\"",
            "rootfs->mount"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "rootfs->mount",
            "F_OK"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to make / rslave\""
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"\"",
            "\"/\"",
            "NULL",
            "MS_SLAVE|MS_REC",
            "0"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "mount_entry_on_generic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1838-1869",
          "snippet": "static inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int setup_rootfs(struct lxc_conf *conf)\n{\n\tconst struct lxc_rootfs *rootfs = &conf->rootfs;\n\n\tif (!rootfs->path) {\n\t\tif (mount(\"\", \"/\", NULL, MS_SLAVE|MS_REC, 0)) {\n\t\t\tSYSERROR(\"Failed to make / rslave\");\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (access(rootfs->mount, F_OK)) {\n\t\tSYSERROR(\"failed to access to '%s', check it is present\",\n\t\t\t rootfs->mount);\n\t\treturn -1;\n\t}\n\n\t// First try mounting rootfs using a bdev\n\tstruct bdev *bdev = bdev_init(conf, rootfs->path, rootfs->mount, rootfs->options);\n\tif (bdev && bdev->ops->mount(bdev) == 0) {\n\t\tbdev_put(bdev);\n\t\tDEBUG(\"mounted '%s' on '%s'\", rootfs->path, rootfs->mount);\n\t\treturn 0;\n\t}\n\tif (bdev)\n\t\tbdev_put(bdev);\n\tif (mount_rootfs(rootfs->path, rootfs->mount, rootfs->options)) {\n\t\tERROR(\"failed to mount rootfs\");\n\t\treturn -1;\n\t}\n\n\tDEBUG(\"mounted '%s' on '%s'\", rootfs->path, rootfs->mount);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fill_autodev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "1192-1249",
    "snippet": "static int fill_autodev(const struct lxc_rootfs *rootfs, bool mount_console)\n{\n\tint ret;\n\tchar path[MAXPATHLEN];\n\tint i;\n\tmode_t cmask;\n\n\tINFO(\"Creating initial consoles under container /dev\");\n\n\tret = snprintf(path, MAXPATHLEN, \"%s/dev\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tERROR(\"Error calculating container /dev location\");\n\t\treturn -1;\n\t}\n\n\tif (!dir_exists(path)) // ignore, just don't try to fill in\n\t\treturn 0;\n\n\tINFO(\"Populating container /dev\");\n\tcmask = umask(S_IXUSR | S_IXGRP | S_IXOTH);\n\tfor (i = 0; i < sizeof(lxc_devs) / sizeof(lxc_devs[0]); i++) {\n\t\tconst struct lxc_devs *d = &lxc_devs[i];\n\n\t\tif (!strcmp(d->name, \"console\") && !mount_console)\n\t\t\tcontinue;\n\n\t\tret = snprintf(path, MAXPATHLEN, \"%s/dev/%s\", rootfs->path ? rootfs->mount : \"\", d->name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn -1;\n\t\tret = mknod(path, d->mode, makedev(d->maj, d->min));\n\t\tif (ret && errno != EEXIST) {\n\t\t\tchar hostpath[MAXPATHLEN];\n\t\t\tFILE *pathfile;\n\n\t\t\t// Unprivileged containers cannot create devices, so\n\t\t\t// bind mount the device from the host\n\t\t\tret = snprintf(hostpath, MAXPATHLEN, \"/dev/%s\", d->name);\n\t\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\t\treturn -1;\n\t\t\tpathfile = fopen(path, \"wb\");\n\t\t\tif (!pathfile) {\n\t\t\t\tSYSERROR(\"Failed to create device mount target '%s'\", path);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfclose(pathfile);\n\t\t\tif (safe_mount(hostpath, path, 0, MS_BIND, NULL,\n\t\t\t\t\t\trootfs->path ? rootfs->mount : NULL) != 0) {\n\t\t\t\tSYSERROR(\"Failed bind mounting device %s from host into container\",\n\t\t\t\t\td->name);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\tumask(cmask);\n\n\tINFO(\"Populated container /dev\");\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct lxc_devs lxc_devs[] = {\n\t{ \"null\",\tS_IFCHR | S_IRWXU | S_IRWXG | S_IRWXO, 1, 3\t},\n\t{ \"zero\",\tS_IFCHR | S_IRWXU | S_IRWXG | S_IRWXO, 1, 5\t},\n\t{ \"full\",\tS_IFCHR | S_IRWXU | S_IRWXG | S_IRWXO, 1, 7\t},\n\t{ \"urandom\",\tS_IFCHR | S_IRWXU | S_IRWXG | S_IRWXO, 1, 9\t},\n\t{ \"random\",\tS_IFCHR | S_IRWXU | S_IRWXG | S_IRWXO, 1, 8\t},\n\t{ \"tty\",\tS_IFCHR | S_IRWXU | S_IRWXG | S_IRWXO, 5, 0\t},\n\t{ \"console\",\tS_IFCHR | S_IRUSR | S_IWUSR,\t       5, 1\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Populated container /dev\""
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "cmask"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed bind mounting device %s from host into container\"",
            "d->name"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_mount",
          "args": [
            "hostpath",
            "path",
            "0",
            "MS_BIND",
            "NULL",
            "rootfs->path ? rootfs->mount : NULL"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "safe_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1687-1743",
          "snippet": "int safe_mount(const char *src, const char *dest, const char *fstype,\n\t\tunsigned long flags, const void *data, const char *rootfs)\n{\n\tint srcfd = -1, destfd, ret, saved_errno;\n\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n\tconst char *mntsrc = src;\n\n\tif (!rootfs)\n\t\trootfs = \"\";\n\n\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n\tif (flags & MS_BIND && src && src[0] != '/') {\n\t\tINFO(\"this is a relative bind mount\");\n\t\tsrcfd = open_without_symlink(src, NULL);\n\t\tif (srcfd < 0)\n\t\t\treturn srcfd;\n\t\tret = snprintf(srcbuf, 50, \"/proc/self/fd/%d\", srcfd);\n\t\tif (ret < 0 || ret > 50) {\n\t\t\tclose(srcfd);\n\t\t\tERROR(\"Out of memory\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmntsrc = srcbuf;\n\t}\n\n\tdestfd = open_without_symlink(dest, rootfs);\n\tif (destfd < 0) {\n\t\tif (srcfd != -1) {\n\t\t\tsaved_errno = errno;\n\t\t\tclose(srcfd);\n\t\t\terrno = saved_errno;\n\t\t}\n\t\treturn destfd;\n\t}\n\n\tret = snprintf(destbuf, 50, \"/proc/self/fd/%d\", destfd);\n\tif (ret < 0 || ret > 50) {\n\t\tif (srcfd != -1)\n\t\t\tclose(srcfd);\n\t\tclose(destfd);\n\t\tERROR(\"Out of memory\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = mount(mntsrc, destbuf, fstype, flags, data);\n\tsaved_errno = errno;\n\tif (srcfd != -1)\n\t\tclose(srcfd);\n\tclose(destfd);\n\tif (ret < 0) {\n\t\terrno = saved_errno;\n\t\tSYSERROR(\"Failed to mount %s onto %s\", src, dest);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint safe_mount(const char *src, const char *dest, const char *fstype,\n\t\tunsigned long flags, const void *data, const char *rootfs)\n{\n\tint srcfd = -1, destfd, ret, saved_errno;\n\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n\tconst char *mntsrc = src;\n\n\tif (!rootfs)\n\t\trootfs = \"\";\n\n\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n\tif (flags & MS_BIND && src && src[0] != '/') {\n\t\tINFO(\"this is a relative bind mount\");\n\t\tsrcfd = open_without_symlink(src, NULL);\n\t\tif (srcfd < 0)\n\t\t\treturn srcfd;\n\t\tret = snprintf(srcbuf, 50, \"/proc/self/fd/%d\", srcfd);\n\t\tif (ret < 0 || ret > 50) {\n\t\t\tclose(srcfd);\n\t\t\tERROR(\"Out of memory\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmntsrc = srcbuf;\n\t}\n\n\tdestfd = open_without_symlink(dest, rootfs);\n\tif (destfd < 0) {\n\t\tif (srcfd != -1) {\n\t\t\tsaved_errno = errno;\n\t\t\tclose(srcfd);\n\t\t\terrno = saved_errno;\n\t\t}\n\t\treturn destfd;\n\t}\n\n\tret = snprintf(destbuf, 50, \"/proc/self/fd/%d\", destfd);\n\tif (ret < 0 || ret > 50) {\n\t\tif (srcfd != -1)\n\t\t\tclose(srcfd);\n\t\tclose(destfd);\n\t\tERROR(\"Out of memory\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = mount(mntsrc, destbuf, fstype, flags, data);\n\tsaved_errno = errno;\n\tif (srcfd != -1)\n\t\tclose(srcfd);\n\tclose(destfd);\n\tif (ret < 0) {\n\t\terrno = saved_errno;\n\t\tSYSERROR(\"Failed to mount %s onto %s\", src, dest);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "pathfile"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to create device mount target '%s'\"",
            "path"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "path",
            "\"wb\""
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "hostpath",
            "MAXPATHLEN",
            "\"/dev/%s\"",
            "d->name"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mknod",
          "args": [
            "path",
            "d->mode",
            "makedev(d->maj, d->min)"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makedev",
          "args": [
            "d->maj",
            "d->min"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "MAXPATHLEN",
            "\"%s/dev/%s\"",
            "rootfs->path ? rootfs->mount : \"\"",
            "d->name"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "d->name",
            "\"console\""
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "S_IXUSR | S_IXGRP | S_IXOTH"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Populating container /dev\""
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_exists",
          "args": [
            "path"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "dir_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1059-1069",
          "snippet": "bool dir_exists(const char *path)\n{\n\tstruct stat sb;\n\tint ret;\n\n\tret = stat(path, &sb);\n\tif (ret < 0)\n\t\t// could be something other than eexist, just say no\n\t\treturn false;\n\treturn S_ISDIR(sb.st_mode);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool btrfs_try_remove_subvol(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nbool dir_exists(const char *path)\n{\n\tstruct stat sb;\n\tint ret;\n\n\tret = stat(path, &sb);\n\tif (ret < 0)\n\t\t// could be something other than eexist, just say no\n\t\treturn false;\n\treturn S_ISDIR(sb.st_mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error calculating container /dev location\""
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "MAXPATHLEN",
            "\"%s/dev\"",
            "rootfs->path ? rootfs->mount : \"\""
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Creating initial consoles under container /dev\""
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic const struct lxc_devs lxc_devs[] = {\n\t{ \"null\",\tS_IFCHR | S_IRWXU | S_IRWXG | S_IRWXO, 1, 3\t},\n\t{ \"zero\",\tS_IFCHR | S_IRWXU | S_IRWXG | S_IRWXO, 1, 5\t},\n\t{ \"full\",\tS_IFCHR | S_IRWXU | S_IRWXG | S_IRWXO, 1, 7\t},\n\t{ \"urandom\",\tS_IFCHR | S_IRWXU | S_IRWXG | S_IRWXO, 1, 9\t},\n\t{ \"random\",\tS_IFCHR | S_IRWXU | S_IRWXG | S_IRWXO, 1, 8\t},\n\t{ \"tty\",\tS_IFCHR | S_IRWXU | S_IRWXG | S_IRWXO, 5, 0\t},\n\t{ \"console\",\tS_IFCHR | S_IRUSR | S_IWUSR,\t       5, 1\t},\n};\n\nstatic int fill_autodev(const struct lxc_rootfs *rootfs, bool mount_console)\n{\n\tint ret;\n\tchar path[MAXPATHLEN];\n\tint i;\n\tmode_t cmask;\n\n\tINFO(\"Creating initial consoles under container /dev\");\n\n\tret = snprintf(path, MAXPATHLEN, \"%s/dev\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tERROR(\"Error calculating container /dev location\");\n\t\treturn -1;\n\t}\n\n\tif (!dir_exists(path)) // ignore, just don't try to fill in\n\t\treturn 0;\n\n\tINFO(\"Populating container /dev\");\n\tcmask = umask(S_IXUSR | S_IXGRP | S_IXOTH);\n\tfor (i = 0; i < sizeof(lxc_devs) / sizeof(lxc_devs[0]); i++) {\n\t\tconst struct lxc_devs *d = &lxc_devs[i];\n\n\t\tif (!strcmp(d->name, \"console\") && !mount_console)\n\t\t\tcontinue;\n\n\t\tret = snprintf(path, MAXPATHLEN, \"%s/dev/%s\", rootfs->path ? rootfs->mount : \"\", d->name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn -1;\n\t\tret = mknod(path, d->mode, makedev(d->maj, d->min));\n\t\tif (ret && errno != EEXIST) {\n\t\t\tchar hostpath[MAXPATHLEN];\n\t\t\tFILE *pathfile;\n\n\t\t\t// Unprivileged containers cannot create devices, so\n\t\t\t// bind mount the device from the host\n\t\t\tret = snprintf(hostpath, MAXPATHLEN, \"/dev/%s\", d->name);\n\t\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\t\treturn -1;\n\t\t\tpathfile = fopen(path, \"wb\");\n\t\t\tif (!pathfile) {\n\t\t\t\tSYSERROR(\"Failed to create device mount target '%s'\", path);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfclose(pathfile);\n\t\t\tif (safe_mount(hostpath, path, 0, MS_BIND, NULL,\n\t\t\t\t\t\trootfs->path ? rootfs->mount : NULL) != 0) {\n\t\t\t\tSYSERROR(\"Failed bind mounting device %s from host into container\",\n\t\t\t\t\td->name);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\tumask(cmask);\n\n\tINFO(\"Populated container /dev\");\n\treturn 0;\n}"
  },
  {
    "function_name": "mount_autodev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "1124-1173",
    "snippet": "static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, const char *lxcpath)\n{\n\tint ret;\n\tsize_t clen;\n\tchar *path;\n\n\tINFO(\"Mounting container /dev\");\n\n\t/* $(rootfs->mount) + \"/dev/pts\" + '\\0' */\n\tclen = (rootfs->path ? strlen(rootfs->mount) : 0) + 9;\n\tpath = alloca(clen);\n\n\tret = snprintf(path, clen, \"%s/dev\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= clen)\n\t\treturn -1;\n\n\tif (!dir_exists(path)) {\n\t\tWARN(\"No /dev in container.\");\n\t\tWARN(\"Proceeding without autodev setup\");\n\t\treturn 0;\n\t}\n\n\tret = safe_mount(\"none\", path, \"tmpfs\", 0, \"size=500000,mode=755\",\n\t\t\trootfs->path ? rootfs->mount : NULL);\n\tif (ret != 0) {\n\t\tSYSERROR(\"Failed mounting tmpfs onto %s\\n\", path);\n\t\treturn -1;\n\t}\n\n\tINFO(\"Mounted tmpfs onto %s\",  path);\n\n\tret = snprintf(path, clen, \"%s/dev/pts\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= clen)\n\t\treturn -1;\n\n\t/*\n\t * If we are running on a devtmpfs mapping, dev/pts may already exist.\n\t * If not, then create it and exit if that fails...\n\t */\n\tif (!dir_exists(path)) {\n\t\tret = mkdir(path, S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);\n\t\tif (ret) {\n\t\t\tSYSERROR(\"Failed to create /dev/pts in container\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tINFO(\"Mounted container /dev\");\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Mounted container /dev\""
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to create /dev/pts in container\""
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "path",
            "S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "241-262",
          "snippet": "extern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_exists",
          "args": [
            "path"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "dir_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1059-1069",
          "snippet": "bool dir_exists(const char *path)\n{\n\tstruct stat sb;\n\tint ret;\n\n\tret = stat(path, &sb);\n\tif (ret < 0)\n\t\t// could be something other than eexist, just say no\n\t\treturn false;\n\treturn S_ISDIR(sb.st_mode);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool btrfs_try_remove_subvol(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nbool dir_exists(const char *path)\n{\n\tstruct stat sb;\n\tint ret;\n\n\tret = stat(path, &sb);\n\tif (ret < 0)\n\t\t// could be something other than eexist, just say no\n\t\treturn false;\n\treturn S_ISDIR(sb.st_mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "clen",
            "\"%s/dev/pts\"",
            "rootfs->path ? rootfs->mount : \"\""
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Mounted tmpfs onto %s\"",
            "path"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed mounting tmpfs onto %s\\n\"",
            "path"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_mount",
          "args": [
            "\"none\"",
            "path",
            "\"tmpfs\"",
            "0",
            "\"size=500000,mode=755\"",
            "rootfs->path ? rootfs->mount : NULL"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "safe_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1687-1743",
          "snippet": "int safe_mount(const char *src, const char *dest, const char *fstype,\n\t\tunsigned long flags, const void *data, const char *rootfs)\n{\n\tint srcfd = -1, destfd, ret, saved_errno;\n\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n\tconst char *mntsrc = src;\n\n\tif (!rootfs)\n\t\trootfs = \"\";\n\n\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n\tif (flags & MS_BIND && src && src[0] != '/') {\n\t\tINFO(\"this is a relative bind mount\");\n\t\tsrcfd = open_without_symlink(src, NULL);\n\t\tif (srcfd < 0)\n\t\t\treturn srcfd;\n\t\tret = snprintf(srcbuf, 50, \"/proc/self/fd/%d\", srcfd);\n\t\tif (ret < 0 || ret > 50) {\n\t\t\tclose(srcfd);\n\t\t\tERROR(\"Out of memory\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmntsrc = srcbuf;\n\t}\n\n\tdestfd = open_without_symlink(dest, rootfs);\n\tif (destfd < 0) {\n\t\tif (srcfd != -1) {\n\t\t\tsaved_errno = errno;\n\t\t\tclose(srcfd);\n\t\t\terrno = saved_errno;\n\t\t}\n\t\treturn destfd;\n\t}\n\n\tret = snprintf(destbuf, 50, \"/proc/self/fd/%d\", destfd);\n\tif (ret < 0 || ret > 50) {\n\t\tif (srcfd != -1)\n\t\t\tclose(srcfd);\n\t\tclose(destfd);\n\t\tERROR(\"Out of memory\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = mount(mntsrc, destbuf, fstype, flags, data);\n\tsaved_errno = errno;\n\tif (srcfd != -1)\n\t\tclose(srcfd);\n\tclose(destfd);\n\tif (ret < 0) {\n\t\terrno = saved_errno;\n\t\tSYSERROR(\"Failed to mount %s onto %s\", src, dest);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint safe_mount(const char *src, const char *dest, const char *fstype,\n\t\tunsigned long flags, const void *data, const char *rootfs)\n{\n\tint srcfd = -1, destfd, ret, saved_errno;\n\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n\tconst char *mntsrc = src;\n\n\tif (!rootfs)\n\t\trootfs = \"\";\n\n\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n\tif (flags & MS_BIND && src && src[0] != '/') {\n\t\tINFO(\"this is a relative bind mount\");\n\t\tsrcfd = open_without_symlink(src, NULL);\n\t\tif (srcfd < 0)\n\t\t\treturn srcfd;\n\t\tret = snprintf(srcbuf, 50, \"/proc/self/fd/%d\", srcfd);\n\t\tif (ret < 0 || ret > 50) {\n\t\t\tclose(srcfd);\n\t\t\tERROR(\"Out of memory\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmntsrc = srcbuf;\n\t}\n\n\tdestfd = open_without_symlink(dest, rootfs);\n\tif (destfd < 0) {\n\t\tif (srcfd != -1) {\n\t\t\tsaved_errno = errno;\n\t\t\tclose(srcfd);\n\t\t\terrno = saved_errno;\n\t\t}\n\t\treturn destfd;\n\t}\n\n\tret = snprintf(destbuf, 50, \"/proc/self/fd/%d\", destfd);\n\tif (ret < 0 || ret > 50) {\n\t\tif (srcfd != -1)\n\t\t\tclose(srcfd);\n\t\tclose(destfd);\n\t\tERROR(\"Out of memory\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = mount(mntsrc, destbuf, fstype, flags, data);\n\tsaved_errno = errno;\n\tif (srcfd != -1)\n\t\tclose(srcfd);\n\tclose(destfd);\n\tif (ret < 0) {\n\t\terrno = saved_errno;\n\t\tSYSERROR(\"Failed to mount %s onto %s\", src, dest);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Proceeding without autodev setup\""
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"No /dev in container.\""
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "clen",
            "\"%s/dev\"",
            "rootfs->path ? rootfs->mount : \"\""
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "clen"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "rootfs->mount"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Mounting container /dev\""
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, const char *lxcpath)\n{\n\tint ret;\n\tsize_t clen;\n\tchar *path;\n\n\tINFO(\"Mounting container /dev\");\n\n\t/* $(rootfs->mount) + \"/dev/pts\" + '\\0' */\n\tclen = (rootfs->path ? strlen(rootfs->mount) : 0) + 9;\n\tpath = alloca(clen);\n\n\tret = snprintf(path, clen, \"%s/dev\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= clen)\n\t\treturn -1;\n\n\tif (!dir_exists(path)) {\n\t\tWARN(\"No /dev in container.\");\n\t\tWARN(\"Proceeding without autodev setup\");\n\t\treturn 0;\n\t}\n\n\tret = safe_mount(\"none\", path, \"tmpfs\", 0, \"size=500000,mode=755\",\n\t\t\trootfs->path ? rootfs->mount : NULL);\n\tif (ret != 0) {\n\t\tSYSERROR(\"Failed mounting tmpfs onto %s\\n\", path);\n\t\treturn -1;\n\t}\n\n\tINFO(\"Mounted tmpfs onto %s\",  path);\n\n\tret = snprintf(path, clen, \"%s/dev/pts\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= clen)\n\t\treturn -1;\n\n\t/*\n\t * If we are running on a devtmpfs mapping, dev/pts may already exist.\n\t * If not, then create it and exit if that fails...\n\t */\n\tif (!dir_exists(path)) {\n\t\tret = mkdir(path, S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);\n\t\tif (ret) {\n\t\t\tSYSERROR(\"Failed to create /dev/pts in container\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tINFO(\"Mounted container /dev\");\n\treturn 0;\n}"
  },
  {
    "function_name": "setup_rootfs_pivot_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "1059-1118",
    "snippet": "static int setup_rootfs_pivot_root(const char *rootfs)\n{\n\tint oldroot = -1, newroot = -1;\n\n\toldroot = open(\"/\", O_DIRECTORY | O_RDONLY);\n\tif (oldroot < 0) {\n\t\tSYSERROR(\"Error opening old-/ for fchdir\");\n\t\treturn -1;\n\t}\n\tnewroot = open(rootfs, O_DIRECTORY | O_RDONLY);\n\tif (newroot < 0) {\n\t\tSYSERROR(\"Error opening new-/ for fchdir\");\n\t\tgoto fail;\n\t}\n\n\t/* change into new root fs */\n\tif (fchdir(newroot)) {\n\t\tSYSERROR(\"can't chdir to new rootfs '%s'\", rootfs);\n\t\tgoto fail;\n\t}\n\n\t/* pivot_root into our new root fs */\n\tif (pivot_root(\".\", \".\")) {\n\t\tSYSERROR(\"pivot_root syscall failed\");\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * at this point the old-root is mounted on top of our new-root\n\t * To unmounted it we must not be chdir'd into it, so escape back\n\t * to old-root\n\t */\n\tif (fchdir(oldroot) < 0) {\n\t\tSYSERROR(\"Error entering oldroot\");\n\t\tgoto fail;\n\t}\n\tif (umount2(\".\", MNT_DETACH) < 0) {\n\t\tSYSERROR(\"Error detaching old root\");\n\t\tgoto fail;\n\t}\n\n\tif (fchdir(newroot) < 0) {\n\t\tSYSERROR(\"Error re-entering newroot\");\n\t\tgoto fail;\n\t}\n\n\tclose(oldroot);\n\tclose(newroot);\n\n\tDEBUG(\"pivot_root syscall to '%s' successful\", rootfs);\n\n\treturn 0;\n\nfail:\n\tif (oldroot != -1)\n\t\tclose(oldroot);\n\tif (newroot != -1)\n\t\tclose(newroot);\n\treturn -1;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "newroot"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"pivot_root syscall to '%s' successful\"",
            "rootfs"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error re-entering newroot\""
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchdir",
          "args": [
            "newroot"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error detaching old root\""
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umount2",
          "args": [
            "\".\"",
            "MNT_DETACH"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error entering oldroot\""
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchdir",
          "args": [
            "oldroot"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"pivot_root syscall failed\""
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pivot_root",
          "args": [
            "\".\"",
            "\".\""
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "pivot_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "140-148",
          "snippet": "static int pivot_root(const char * new_root, const char * put_old)\n{\n#ifdef __NR_pivot_root\n\treturn syscall(__NR_pivot_root, new_root, put_old);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int pivot_root(const char * new_root, const char * put_old)\n{\n#ifdef __NR_pivot_root\n\treturn syscall(__NR_pivot_root, new_root, put_old);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"can't chdir to new rootfs '%s'\"",
            "rootfs"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchdir",
          "args": [
            "newroot"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error opening new-/ for fchdir\""
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "rootfs",
            "O_DIRECTORY | O_RDONLY"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "genetlink_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/genl.c",
          "lines": "106-116",
          "snippet": "extern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"genl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/genetlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"genl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error opening old-/ for fchdir\""
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int setup_rootfs_pivot_root(const char *rootfs)\n{\n\tint oldroot = -1, newroot = -1;\n\n\toldroot = open(\"/\", O_DIRECTORY | O_RDONLY);\n\tif (oldroot < 0) {\n\t\tSYSERROR(\"Error opening old-/ for fchdir\");\n\t\treturn -1;\n\t}\n\tnewroot = open(rootfs, O_DIRECTORY | O_RDONLY);\n\tif (newroot < 0) {\n\t\tSYSERROR(\"Error opening new-/ for fchdir\");\n\t\tgoto fail;\n\t}\n\n\t/* change into new root fs */\n\tif (fchdir(newroot)) {\n\t\tSYSERROR(\"can't chdir to new rootfs '%s'\", rootfs);\n\t\tgoto fail;\n\t}\n\n\t/* pivot_root into our new root fs */\n\tif (pivot_root(\".\", \".\")) {\n\t\tSYSERROR(\"pivot_root syscall failed\");\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * at this point the old-root is mounted on top of our new-root\n\t * To unmounted it we must not be chdir'd into it, so escape back\n\t * to old-root\n\t */\n\tif (fchdir(oldroot) < 0) {\n\t\tSYSERROR(\"Error entering oldroot\");\n\t\tgoto fail;\n\t}\n\tif (umount2(\".\", MNT_DETACH) < 0) {\n\t\tSYSERROR(\"Error detaching old root\");\n\t\tgoto fail;\n\t}\n\n\tif (fchdir(newroot) < 0) {\n\t\tSYSERROR(\"Error re-entering newroot\");\n\t\tgoto fail;\n\t}\n\n\tclose(oldroot);\n\tclose(newroot);\n\n\tDEBUG(\"pivot_root syscall to '%s' successful\", rootfs);\n\n\treturn 0;\n\nfail:\n\tif (oldroot != -1)\n\t\tclose(oldroot);\n\tif (newroot != -1)\n\t\tclose(newroot);\n\treturn -1;\n}"
  },
  {
    "function_name": "setup_tty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "976-1056",
    "snippet": "static int setup_tty(struct lxc_conf *conf)\n{\n\tconst struct lxc_tty_info *tty_info = &conf->tty_info;\n\tchar *ttydir = conf->ttydir;\n\tchar path[MAXPATHLEN], lxcpath[MAXPATHLEN];\n\tint i, ret;\n\n\tif (!conf->rootfs.path)\n\t\treturn 0;\n\n\tfor (i = 0; i < tty_info->nbtty; i++) {\n\n\t\tstruct lxc_pty_info *pty_info = &tty_info->pty_info[i];\n\n\t\tret = snprintf(path, sizeof(path), \"/dev/tty%d\", i + 1);\n\t\tif (ret >= sizeof(path)) {\n\t\t\tERROR(\"pathname too long for ttys\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (ttydir) {\n\t\t\t/* create dev/lxc/tty%d\" */\n\t\t\tret = snprintf(lxcpath, sizeof(lxcpath), \"/dev/%s/tty%d\", ttydir, i + 1);\n\t\t\tif (ret >= sizeof(lxcpath)) {\n\t\t\t\tERROR(\"pathname too long for ttys\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tret = creat(lxcpath, 0660);\n\t\t\tif (ret==-1 && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"error creating %s\", lxcpath);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (ret >= 0)\n\t\t\t\tclose(ret);\n\t\t\tret = unlink(path);\n\t\t\tif (ret && errno != ENOENT) {\n\t\t\t\tSYSERROR(\"error unlinking %s\", path);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (mount(pty_info->name, lxcpath, \"none\", MS_BIND, 0)) {\n\t\t\t\tWARN(\"failed to mount '%s'->'%s'\",\n\t\t\t\t     pty_info->name, path);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = snprintf(lxcpath, sizeof(lxcpath), \"%s/tty%d\", ttydir, i+1);\n\t\t\tif (ret >= sizeof(lxcpath)) {\n\t\t\t\tERROR(\"tty pathname too long\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tret = symlink(lxcpath, path);\n\t\t\tif (ret) {\n\t\t\t\tSYSERROR(\"failed to create symlink for tty %d\", i+1);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\t/* If we populated /dev, then we need to create /dev/ttyN */\n\t\t\tif (access(path, F_OK)) {\n\t\t\t\tret = creat(path, 0660);\n\t\t\t\tif (ret==-1) {\n\t\t\t\t\tSYSERROR(\"error creating %s\", path);\n\t\t\t\t\t/* this isn't fatal, continue */\n\t\t\t\t} else {\n\t\t\t\t\tclose(ret);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mount(pty_info->name, path, \"none\", MS_BIND, 0)) {\n\t\t\t\tSYSERROR(\"failed to mount '%s'->'%s'\", pty_info->name, path);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (!append_ptyname(&conf->pty_names, pty_info->name)) {\n\t\t\tERROR(\"Error setting up container_ttys string\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tINFO(\"%d tty(s) has been setup\", tty_info->nbtty);\n\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"%d tty(s) has been setup\"",
            "tty_info->nbtty"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error setting up container_ttys string\""
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "append_ptyname",
          "args": [
            "&conf->pty_names",
            "pty_info->name"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "append_ptyname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "956-974",
          "snippet": "static bool append_ptyname(char **pp, char *name)\n{\n\tchar *p;\n\n\tif (!*pp) {\n\t\t*pp = malloc(strlen(name) + strlen(\"container_ttys=\") + 1);\n\t\tif (!*pp)\n\t\t\treturn false;\n\t\tsprintf(*pp, \"container_ttys=%s\", name);\n\t\treturn true;\n\t}\n\tp = realloc(*pp, strlen(*pp) + strlen(name) + 2);\n\tif (!p)\n\t\treturn false;\n\t*pp = p;\n\tstrcat(p, \" \");\n\tstrcat(p, name);\n\treturn true;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic bool append_ptyname(char **pp, char *name)\n{\n\tchar *p;\n\n\tif (!*pp) {\n\t\t*pp = malloc(strlen(name) + strlen(\"container_ttys=\") + 1);\n\t\tif (!*pp)\n\t\t\treturn false;\n\t\tsprintf(*pp, \"container_ttys=%s\", name);\n\t\treturn true;\n\t}\n\tp = realloc(*pp, strlen(*pp) + strlen(name) + 2);\n\tif (!p)\n\t\treturn false;\n\t*pp = p;\n\tstrcat(p, \" \");\n\tstrcat(p, name);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to mount '%s'->'%s'\"",
            "pty_info->name",
            "path"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "pty_info->name",
            "path",
            "\"none\"",
            "MS_BIND",
            "0"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "mount_entry_on_generic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1838-1869",
          "snippet": "static inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "ret"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"error creating %s\"",
            "path"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "creat",
          "args": [
            "path",
            "0660"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_create_tty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3410-3456",
          "snippet": "int lxc_create_tty(const char *name, struct lxc_conf *conf)\n{\n\tstruct lxc_tty_info *tty_info = &conf->tty_info;\n\tint i, ret;\n\n\t/* no tty in the configuration */\n\tif (!conf->tty)\n\t\treturn 0;\n\n\ttty_info->pty_info =\n\t\tmalloc(sizeof(*tty_info->pty_info)*conf->tty);\n\tif (!tty_info->pty_info) {\n\t\tSYSERROR(\"failed to allocate pty_info\");\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < conf->tty; i++) {\n\n\t\tstruct lxc_pty_info *pty_info = &tty_info->pty_info[i];\n\n\t\tprocess_lock();\n\t\tret = openpty(&pty_info->master, &pty_info->slave,\n\t\t\t    pty_info->name, NULL, NULL);\n\t\tprocess_unlock();\n\t\tif (ret) {\n\t\t\tSYSERROR(\"failed to create pty #%d\", i);\n\t\t\ttty_info->nbtty = i;\n\t\t\tlxc_delete_tty(tty_info);\n\t\t\treturn -1;\n\t\t}\n\n\t\tDEBUG(\"allocated pty '%s' (%d/%d)\",\n\t\t      pty_info->name, pty_info->master, pty_info->slave);\n\n\t\t/* Prevent leaking the file descriptors to the container */\n\t\tfcntl(pty_info->master, F_SETFD, FD_CLOEXEC);\n\t\tfcntl(pty_info->slave, F_SETFD, FD_CLOEXEC);\n\n\t\tpty_info->busy = 0;\n\t}\n\n\ttty_info->nbtty = conf->tty;\n\n\tINFO(\"tty's configured\");\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_create_tty(const char *name, struct lxc_conf *conf)\n{\n\tstruct lxc_tty_info *tty_info = &conf->tty_info;\n\tint i, ret;\n\n\t/* no tty in the configuration */\n\tif (!conf->tty)\n\t\treturn 0;\n\n\ttty_info->pty_info =\n\t\tmalloc(sizeof(*tty_info->pty_info)*conf->tty);\n\tif (!tty_info->pty_info) {\n\t\tSYSERROR(\"failed to allocate pty_info\");\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < conf->tty; i++) {\n\n\t\tstruct lxc_pty_info *pty_info = &tty_info->pty_info[i];\n\n\t\tprocess_lock();\n\t\tret = openpty(&pty_info->master, &pty_info->slave,\n\t\t\t    pty_info->name, NULL, NULL);\n\t\tprocess_unlock();\n\t\tif (ret) {\n\t\t\tSYSERROR(\"failed to create pty #%d\", i);\n\t\t\ttty_info->nbtty = i;\n\t\t\tlxc_delete_tty(tty_info);\n\t\t\treturn -1;\n\t\t}\n\n\t\tDEBUG(\"allocated pty '%s' (%d/%d)\",\n\t\t      pty_info->name, pty_info->master, pty_info->slave);\n\n\t\t/* Prevent leaking the file descriptors to the container */\n\t\tfcntl(pty_info->master, F_SETFD, FD_CLOEXEC);\n\t\tfcntl(pty_info->slave, F_SETFD, FD_CLOEXEC);\n\n\t\tpty_info->busy = 0;\n\t}\n\n\ttty_info->nbtty = conf->tty;\n\n\tINFO(\"tty's configured\");\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "path",
            "F_OK"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to create symlink for tty %d\"",
            "i+1"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "symlink",
          "args": [
            "lxcpath",
            "path"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "open_without_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1616-1677",
          "snippet": "static int open_without_symlink(const char *target, const char *prefix_skip)\n{\n\tint curlen = 0, dirfd, fulllen, i;\n\tchar *dup = NULL;\n\n\tfulllen = strlen(target);\n\n\t/* make sure prefix-skip makes sense */\n\tif (prefix_skip && strlen(prefix_skip) > 0) {\n\t\tcurlen = strlen(prefix_skip);\n\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n\t\t\tERROR(\"WHOA there - target '%s' didn't start with prefix '%s'\",\n\t\t\t\ttarget, prefix_skip);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/*\n\t\t * get_nextpath() expects the curlen argument to be\n\t\t * on a  (turned into \\0) / or before it, so decrement\n\t\t * curlen to make sure that happens\n\t\t */\n\t\tif (curlen)\n\t\t\tcurlen--;\n\t} else {\n\t\tprefix_skip = \"/\";\n\t\tcurlen = 0;\n\t}\n\n\t/* Make a copy of target which we can hack up, and tokenize it */\n\tif ((dup = strdup(target)) == NULL) {\n\t\tSYSERROR(\"Out of memory checking for symbolic link\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < fulllen; i++) {\n\t\tif (dup[i] == '/')\n\t\t\tdup[i] = '\\0';\n\t}\n\n\tdirfd = open(prefix_skip, O_RDONLY);\n\tif (dirfd < 0)\n\t\tgoto out;\n\twhile (1) {\n\t\tint newfd, saved_errno;\n\t\tchar *nextpath;\n\n\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n\t\t\tgoto out;\n\t\tnewfd = open_if_safe(dirfd, nextpath);\n\t\tsaved_errno = errno;\n\t\tclose(dirfd);\n\t\tdirfd = newfd;\n\t\tif (newfd < 0) {\n\t\t\terrno = saved_errno;\n\t\t\tif (errno == ELOOP)\n\t\t\t\tSYSERROR(\"%s in %s was a symbolic link!\", nextpath, target);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfree(dup);\n\treturn dirfd;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int open_without_symlink(const char *target, const char *prefix_skip)\n{\n\tint curlen = 0, dirfd, fulllen, i;\n\tchar *dup = NULL;\n\n\tfulllen = strlen(target);\n\n\t/* make sure prefix-skip makes sense */\n\tif (prefix_skip && strlen(prefix_skip) > 0) {\n\t\tcurlen = strlen(prefix_skip);\n\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n\t\t\tERROR(\"WHOA there - target '%s' didn't start with prefix '%s'\",\n\t\t\t\ttarget, prefix_skip);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/*\n\t\t * get_nextpath() expects the curlen argument to be\n\t\t * on a  (turned into \\0) / or before it, so decrement\n\t\t * curlen to make sure that happens\n\t\t */\n\t\tif (curlen)\n\t\t\tcurlen--;\n\t} else {\n\t\tprefix_skip = \"/\";\n\t\tcurlen = 0;\n\t}\n\n\t/* Make a copy of target which we can hack up, and tokenize it */\n\tif ((dup = strdup(target)) == NULL) {\n\t\tSYSERROR(\"Out of memory checking for symbolic link\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < fulllen; i++) {\n\t\tif (dup[i] == '/')\n\t\t\tdup[i] = '\\0';\n\t}\n\n\tdirfd = open(prefix_skip, O_RDONLY);\n\tif (dirfd < 0)\n\t\tgoto out;\n\twhile (1) {\n\t\tint newfd, saved_errno;\n\t\tchar *nextpath;\n\n\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n\t\t\tgoto out;\n\t\tnewfd = open_if_safe(dirfd, nextpath);\n\t\tsaved_errno = errno;\n\t\tclose(dirfd);\n\t\tdirfd = newfd;\n\t\tif (newfd < 0) {\n\t\t\terrno = saved_errno;\n\t\t\tif (errno == ELOOP)\n\t\t\t\tSYSERROR(\"%s in %s was a symbolic link!\", nextpath, target);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfree(dup);\n\treturn dirfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"tty pathname too long\""
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "lxcpath",
            "sizeof(lxcpath)",
            "\"%s/tty%d\"",
            "ttydir",
            "i+1"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"failed to mount '%s'->'%s'\"",
            "pty_info->name",
            "path"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"error unlinking %s\"",
            "path"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "path"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"error creating %s\"",
            "lxcpath"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"pathname too long for ttys\""
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "lxcpath",
            "sizeof(lxcpath)",
            "\"/dev/%s/tty%d\"",
            "ttydir",
            "i + 1"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"pathname too long for ttys\""
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "sizeof(path)",
            "\"/dev/tty%d\"",
            "i + 1"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int setup_tty(struct lxc_conf *conf)\n{\n\tconst struct lxc_tty_info *tty_info = &conf->tty_info;\n\tchar *ttydir = conf->ttydir;\n\tchar path[MAXPATHLEN], lxcpath[MAXPATHLEN];\n\tint i, ret;\n\n\tif (!conf->rootfs.path)\n\t\treturn 0;\n\n\tfor (i = 0; i < tty_info->nbtty; i++) {\n\n\t\tstruct lxc_pty_info *pty_info = &tty_info->pty_info[i];\n\n\t\tret = snprintf(path, sizeof(path), \"/dev/tty%d\", i + 1);\n\t\tif (ret >= sizeof(path)) {\n\t\t\tERROR(\"pathname too long for ttys\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (ttydir) {\n\t\t\t/* create dev/lxc/tty%d\" */\n\t\t\tret = snprintf(lxcpath, sizeof(lxcpath), \"/dev/%s/tty%d\", ttydir, i + 1);\n\t\t\tif (ret >= sizeof(lxcpath)) {\n\t\t\t\tERROR(\"pathname too long for ttys\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tret = creat(lxcpath, 0660);\n\t\t\tif (ret==-1 && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"error creating %s\", lxcpath);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (ret >= 0)\n\t\t\t\tclose(ret);\n\t\t\tret = unlink(path);\n\t\t\tif (ret && errno != ENOENT) {\n\t\t\t\tSYSERROR(\"error unlinking %s\", path);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (mount(pty_info->name, lxcpath, \"none\", MS_BIND, 0)) {\n\t\t\t\tWARN(\"failed to mount '%s'->'%s'\",\n\t\t\t\t     pty_info->name, path);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = snprintf(lxcpath, sizeof(lxcpath), \"%s/tty%d\", ttydir, i+1);\n\t\t\tif (ret >= sizeof(lxcpath)) {\n\t\t\t\tERROR(\"tty pathname too long\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tret = symlink(lxcpath, path);\n\t\t\tif (ret) {\n\t\t\t\tSYSERROR(\"failed to create symlink for tty %d\", i+1);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\t/* If we populated /dev, then we need to create /dev/ttyN */\n\t\t\tif (access(path, F_OK)) {\n\t\t\t\tret = creat(path, 0660);\n\t\t\t\tif (ret==-1) {\n\t\t\t\t\tSYSERROR(\"error creating %s\", path);\n\t\t\t\t\t/* this isn't fatal, continue */\n\t\t\t\t} else {\n\t\t\t\t\tclose(ret);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mount(pty_info->name, path, \"none\", MS_BIND, 0)) {\n\t\t\t\tSYSERROR(\"failed to mount '%s'->'%s'\", pty_info->name, path);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (!append_ptyname(&conf->pty_names, pty_info->name)) {\n\t\t\tERROR(\"Error setting up container_ttys string\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tINFO(\"%d tty(s) has been setup\", tty_info->nbtty);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "append_ptyname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "956-974",
    "snippet": "static bool append_ptyname(char **pp, char *name)\n{\n\tchar *p;\n\n\tif (!*pp) {\n\t\t*pp = malloc(strlen(name) + strlen(\"container_ttys=\") + 1);\n\t\tif (!*pp)\n\t\t\treturn false;\n\t\tsprintf(*pp, \"container_ttys=%s\", name);\n\t\treturn true;\n\t}\n\tp = realloc(*pp, strlen(*pp) + strlen(name) + 2);\n\tif (!p)\n\t\treturn false;\n\t*pp = p;\n\tstrcat(p, \" \");\n\tstrcat(p, name);\n\treturn true;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "p",
            "name"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "p",
            "\" \""
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "*pp",
            "strlen(*pp) + strlen(name) + 2"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "must_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "116-124",
          "snippet": "static void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "*pp"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "*pp",
            "\"container_ttys=%s\"",
            "name"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(name) + strlen(\"container_ttys=\") + 1"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"container_ttys=\""
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic bool append_ptyname(char **pp, char *name)\n{\n\tchar *p;\n\n\tif (!*pp) {\n\t\t*pp = malloc(strlen(name) + strlen(\"container_ttys=\") + 1);\n\t\tif (!*pp)\n\t\t\treturn false;\n\t\tsprintf(*pp, \"container_ttys=%s\", name);\n\t\treturn true;\n\t}\n\tp = realloc(*pp, strlen(*pp) + strlen(name) + 2);\n\tif (!p)\n\t\treturn false;\n\t*pp = p;\n\tstrcat(p, \" \");\n\tstrcat(p, name);\n\treturn true;\n}"
  },
  {
    "function_name": "setup_dev_symlinks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "918-951",
    "snippet": "static int setup_dev_symlinks(const struct lxc_rootfs *rootfs)\n{\n\tchar path[MAXPATHLEN];\n\tint ret,i;\n\tstruct stat s;\n\n\n\tfor (i = 0; i < sizeof(dev_symlinks) / sizeof(dev_symlinks[0]); i++) {\n\t\tconst struct dev_symlinks *d = &dev_symlinks[i];\n\t\tret = snprintf(path, sizeof(path), \"%s/dev/%s\", rootfs->path ? rootfs->mount : \"\", d->name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn -1;\n\n\t\t/*\n\t\t * Stat the path first.  If we don't get an error\n\t\t * accept it as is and don't try to create it\n\t\t */\n\t\tif (!stat(path, &s)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = symlink(d->oldpath, path);\n\n\t\tif (ret && errno != EEXIST) {\n\t\t\tif ( errno == EROFS ) {\n\t\t\t\tWARN(\"Warning: Read Only file system while creating %s\", path);\n\t\t\t} else {\n\t\t\t\tSYSERROR(\"Error creating %s\", path);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct dev_symlinks dev_symlinks[] = {\n\t{\"/proc/self/fd\",\t\"fd\"},\n\t{\"/proc/self/fd/0\",\t\"stdin\"},\n\t{\"/proc/self/fd/1\",\t\"stdout\"},\n\t{\"/proc/self/fd/2\",\t\"stderr\"},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error creating %s\"",
            "path"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Warning: Read Only file system while creating %s\"",
            "path"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "symlink",
          "args": [
            "d->oldpath",
            "path"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "open_without_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1616-1677",
          "snippet": "static int open_without_symlink(const char *target, const char *prefix_skip)\n{\n\tint curlen = 0, dirfd, fulllen, i;\n\tchar *dup = NULL;\n\n\tfulllen = strlen(target);\n\n\t/* make sure prefix-skip makes sense */\n\tif (prefix_skip && strlen(prefix_skip) > 0) {\n\t\tcurlen = strlen(prefix_skip);\n\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n\t\t\tERROR(\"WHOA there - target '%s' didn't start with prefix '%s'\",\n\t\t\t\ttarget, prefix_skip);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/*\n\t\t * get_nextpath() expects the curlen argument to be\n\t\t * on a  (turned into \\0) / or before it, so decrement\n\t\t * curlen to make sure that happens\n\t\t */\n\t\tif (curlen)\n\t\t\tcurlen--;\n\t} else {\n\t\tprefix_skip = \"/\";\n\t\tcurlen = 0;\n\t}\n\n\t/* Make a copy of target which we can hack up, and tokenize it */\n\tif ((dup = strdup(target)) == NULL) {\n\t\tSYSERROR(\"Out of memory checking for symbolic link\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < fulllen; i++) {\n\t\tif (dup[i] == '/')\n\t\t\tdup[i] = '\\0';\n\t}\n\n\tdirfd = open(prefix_skip, O_RDONLY);\n\tif (dirfd < 0)\n\t\tgoto out;\n\twhile (1) {\n\t\tint newfd, saved_errno;\n\t\tchar *nextpath;\n\n\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n\t\t\tgoto out;\n\t\tnewfd = open_if_safe(dirfd, nextpath);\n\t\tsaved_errno = errno;\n\t\tclose(dirfd);\n\t\tdirfd = newfd;\n\t\tif (newfd < 0) {\n\t\t\terrno = saved_errno;\n\t\t\tif (errno == ELOOP)\n\t\t\t\tSYSERROR(\"%s in %s was a symbolic link!\", nextpath, target);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfree(dup);\n\treturn dirfd;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int open_without_symlink(const char *target, const char *prefix_skip)\n{\n\tint curlen = 0, dirfd, fulllen, i;\n\tchar *dup = NULL;\n\n\tfulllen = strlen(target);\n\n\t/* make sure prefix-skip makes sense */\n\tif (prefix_skip && strlen(prefix_skip) > 0) {\n\t\tcurlen = strlen(prefix_skip);\n\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n\t\t\tERROR(\"WHOA there - target '%s' didn't start with prefix '%s'\",\n\t\t\t\ttarget, prefix_skip);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/*\n\t\t * get_nextpath() expects the curlen argument to be\n\t\t * on a  (turned into \\0) / or before it, so decrement\n\t\t * curlen to make sure that happens\n\t\t */\n\t\tif (curlen)\n\t\t\tcurlen--;\n\t} else {\n\t\tprefix_skip = \"/\";\n\t\tcurlen = 0;\n\t}\n\n\t/* Make a copy of target which we can hack up, and tokenize it */\n\tif ((dup = strdup(target)) == NULL) {\n\t\tSYSERROR(\"Out of memory checking for symbolic link\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < fulllen; i++) {\n\t\tif (dup[i] == '/')\n\t\t\tdup[i] = '\\0';\n\t}\n\n\tdirfd = open(prefix_skip, O_RDONLY);\n\tif (dirfd < 0)\n\t\tgoto out;\n\twhile (1) {\n\t\tint newfd, saved_errno;\n\t\tchar *nextpath;\n\n\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n\t\t\tgoto out;\n\t\tnewfd = open_if_safe(dirfd, nextpath);\n\t\tsaved_errno = errno;\n\t\tclose(dirfd);\n\t\tdirfd = newfd;\n\t\tif (newfd < 0) {\n\t\t\terrno = saved_errno;\n\t\t\tif (errno == ELOOP)\n\t\t\t\tSYSERROR(\"%s in %s was a symbolic link!\", nextpath, target);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfree(dup);\n\treturn dirfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "path",
            "&s"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "freezer_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/freezer.c",
          "lines": "42-51",
          "snippet": "lxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}",
          "includes": [
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"monitor.h\"",
            "#include \"state.h\"",
            "#include \"error.h\"",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxc.h\"\n#include \"log.h\"\n#include \"monitor.h\"\n#include \"state.h\"\n#include \"error.h\"\n#include <sys/param.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nlxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "sizeof(path)",
            "\"%s/dev/%s\"",
            "rootfs->path ? rootfs->mount : \"\"",
            "d->name"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic const struct dev_symlinks dev_symlinks[] = {\n\t{\"/proc/self/fd\",\t\"fd\"},\n\t{\"/proc/self/fd/0\",\t\"stdin\"},\n\t{\"/proc/self/fd/1\",\t\"stdout\"},\n\t{\"/proc/self/fd/2\",\t\"stderr\"},\n};\n\nstatic int setup_dev_symlinks(const struct lxc_rootfs *rootfs)\n{\n\tchar path[MAXPATHLEN];\n\tint ret,i;\n\tstruct stat s;\n\n\n\tfor (i = 0; i < sizeof(dev_symlinks) / sizeof(dev_symlinks[0]); i++) {\n\t\tconst struct dev_symlinks *d = &dev_symlinks[i];\n\t\tret = snprintf(path, sizeof(path), \"%s/dev/%s\", rootfs->path ? rootfs->mount : \"\", d->name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn -1;\n\n\t\t/*\n\t\t * Stat the path first.  If we don't get an error\n\t\t * accept it as is and don't try to create it\n\t\t */\n\t\tif (!stat(path, &s)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = symlink(d->oldpath, path);\n\n\t\tif (ret && errno != EEXIST) {\n\t\t\tif ( errno == EROFS ) {\n\t\t\t\tWARN(\"Warning: Read Only file system while creating %s\", path);\n\t\t\t} else {\n\t\t\t\tSYSERROR(\"Error creating %s\", path);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "setup_utsname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "891-904",
    "snippet": "static int setup_utsname(struct utsname *utsname)\n{\n\tif (!utsname)\n\t\treturn 0;\n\n\tif (sethostname(utsname->nodename, strlen(utsname->nodename))) {\n\t\tSYSERROR(\"failed to set the hostname to '%s'\", utsname->nodename);\n\t\treturn -1;\n\t}\n\n\tINFO(\"'%s' hostname has been setup\", utsname->nodename);\n\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"'%s' hostname has been setup\"",
            "utsname->nodename"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to set the hostname to '%s'\"",
            "utsname->nodename"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sethostname",
          "args": [
            "utsname->nodename",
            "strlen(utsname->nodename)"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "sethostname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "155-163",
          "snippet": "static int sethostname(const char * name, size_t len)\n{\n#ifdef __NR_sethostname\n\treturn syscall(__NR_sethostname, name, len);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int sethostname(const char * name, size_t len)\n{\n#ifdef __NR_sethostname\n\treturn syscall(__NR_sethostname, name, len);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "utsname->nodename"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int setup_utsname(struct utsname *utsname)\n{\n\tif (!utsname)\n\t\treturn 0;\n\n\tif (sethostname(utsname->nodename, strlen(utsname->nodename))) {\n\t\tSYSERROR(\"failed to set the hostname to '%s'\", utsname->nodename);\n\t\treturn -1;\n\t}\n\n\tINFO(\"'%s' hostname has been setup\", utsname->nodename);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "mount_rootfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "847-889",
    "snippet": "static int mount_rootfs(const char *rootfs, const char *target, const char *options)\n{\n\tchar absrootfs[MAXPATHLEN];\n\tstruct stat s;\n\tint i;\n\n\ttypedef int (*rootfs_cb)(const char *, const char *, const char *);\n\n\tstruct rootfs_type {\n\t\tint type;\n\t\trootfs_cb cb;\n\t} rtfs_type[] = {\n\t\t{ S_IFDIR, mount_rootfs_dir },\n\t\t{ S_IFBLK, mount_rootfs_block },\n\t\t{ S_IFREG, mount_rootfs_file },\n\t};\n\n\tif (!realpath(rootfs, absrootfs)) {\n\t\tSYSERROR(\"failed to get real path for '%s'\", rootfs);\n\t\treturn -1;\n\t}\n\n\tif (access(absrootfs, F_OK)) {\n\t\tSYSERROR(\"'%s' is not accessible\", absrootfs);\n\t\treturn -1;\n\t}\n\n\tif (stat(absrootfs, &s)) {\n\t\tSYSERROR(\"failed to stat '%s'\", absrootfs);\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < sizeof(rtfs_type)/sizeof(rtfs_type[0]); i++) {\n\n\t\tif (!__S_ISTYPE(s.st_mode, rtfs_type[i].type))\n\t\t\tcontinue;\n\n\t\treturn rtfs_type[i].cb(absrootfs, target, options);\n\t}\n\n\tERROR(\"unsupported rootfs type for '%s'\", absrootfs);\n\treturn -1;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"unsupported rootfs type for '%s'\"",
            "absrootfs"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtfs_type[i].cb",
          "args": [
            "absrootfs",
            "target",
            "options"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__S_ISTYPE",
          "args": [
            "s.st_mode",
            "rtfs_type[i].type"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to stat '%s'\"",
            "absrootfs"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "absrootfs",
            "&s"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "freezer_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/freezer.c",
          "lines": "42-51",
          "snippet": "lxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}",
          "includes": [
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"monitor.h\"",
            "#include \"state.h\"",
            "#include \"error.h\"",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxc.h\"\n#include \"log.h\"\n#include \"monitor.h\"\n#include \"state.h\"\n#include \"error.h\"\n#include <sys/param.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nlxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"'%s' is not accessible\"",
            "absrootfs"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "absrootfs",
            "F_OK"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to get real path for '%s'\"",
            "rootfs"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realpath",
          "args": [
            "rootfs",
            "absrootfs"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int mount_rootfs(const char *rootfs, const char *target, const char *options)\n{\n\tchar absrootfs[MAXPATHLEN];\n\tstruct stat s;\n\tint i;\n\n\ttypedef int (*rootfs_cb)(const char *, const char *, const char *);\n\n\tstruct rootfs_type {\n\t\tint type;\n\t\trootfs_cb cb;\n\t} rtfs_type[] = {\n\t\t{ S_IFDIR, mount_rootfs_dir },\n\t\t{ S_IFBLK, mount_rootfs_block },\n\t\t{ S_IFREG, mount_rootfs_file },\n\t};\n\n\tif (!realpath(rootfs, absrootfs)) {\n\t\tSYSERROR(\"failed to get real path for '%s'\", rootfs);\n\t\treturn -1;\n\t}\n\n\tif (access(absrootfs, F_OK)) {\n\t\tSYSERROR(\"'%s' is not accessible\", absrootfs);\n\t\treturn -1;\n\t}\n\n\tif (stat(absrootfs, &s)) {\n\t\tSYSERROR(\"failed to stat '%s'\", absrootfs);\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < sizeof(rtfs_type)/sizeof(rtfs_type[0]); i++) {\n\n\t\tif (!__S_ISTYPE(s.st_mode, rtfs_type[i].type))\n\t\t\tcontinue;\n\n\t\treturn rtfs_type[i].cb(absrootfs, target, options);\n\t}\n\n\tERROR(\"unsupported rootfs type for '%s'\", absrootfs);\n\treturn -1;\n}"
  },
  {
    "function_name": "lxc_mount_auto_mounts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "719-845",
    "snippet": "static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_handler *handler)\n{\n\tint r;\n\tint i;\n\tstatic struct {\n\t\tint match_mask;\n\t\tint match_flag;\n\t\tconst char *source;\n\t\tconst char *destination;\n\t\tconst char *fstype;\n\t\tunsigned long flags;\n\t\tconst char *options;\n\t} default_mounts[] = {\n\t\t/* Read-only bind-mounting... In older kernels, doing that required\n\t\t * to do one MS_BIND mount and then MS_REMOUNT|MS_RDONLY the same\n\t\t * one. According to mount(2) manpage, MS_BIND honors MS_RDONLY from\n\t\t * kernel 2.6.26 onwards. However, this apparently does not work on\n\t\t * kernel 3.8. Unfortunately, on that very same kernel, doing the\n\t\t * same trick as above doesn't seem to work either, there one needs\n\t\t * to ALSO specify MS_BIND for the remount, otherwise the entire\n\t\t * fs is remounted read-only or the mount fails because it's busy...\n\t\t * MS_REMOUNT|MS_BIND|MS_RDONLY seems to work for kernels as low as\n\t\t * 2.6.32...\n\t\t */\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"proc\",                                              \"%r/proc\",                      \"proc\",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n\t\t/* proc/tty is used as a temporary placeholder for proc/sys/net which we'll move back in a few steps */\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys/net\",                                   \"%r/proc/tty\",                  NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys\",                                       \"%r/proc/sys\",                  NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \"%r/proc/sys\",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/tty\",                                       \"%r/proc/sys/net\",              NULL,       MS_MOVE,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sysrq-trigger\",                             \"%r/proc/sysrq-trigger\",        NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \"%r/proc/sysrq-trigger\",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    \"proc\",                                              \"%r/proc\",                      \"proc\",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_RW,     \"sysfs\",                                             \"%r/sys\",                       \"sysfs\",    0,                              NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_RO,     \"sysfs\",                                             \"%r/sys\",                       \"sysfs\",    MS_RDONLY,                      NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  \"sysfs\",                                             \"%r/sys\",                       \"sysfs\",    MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  \"%r/sys\",                                            \"%r/sys\",                       NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  NULL,                                                \"%r/sys\",                       NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  \"sysfs\",                                             \"%r/sys/devices/virtual/net\",   \"sysfs\",    0,                              NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  \"%r/sys/devices/virtual/net/devices/virtual/net\",    \"%r/sys/devices/virtual/net\",   NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  NULL,                                                \"%r/sys/devices/virtual/net\",   NULL,       MS_REMOUNT|MS_BIND|MS_NOSUID|MS_NODEV|MS_NOEXEC,   NULL },\n\t\t{ 0,                  0,                   NULL,                                                NULL,                           NULL,       0,                              NULL }\n\t};\n\n\tfor (i = 0; default_mounts[i].match_mask; i++) {\n\t\tif ((flags & default_mounts[i].match_mask) == default_mounts[i].match_flag) {\n\t\t\tchar *source = NULL;\n\t\t\tchar *destination = NULL;\n\t\t\tint saved_errno;\n\t\t\tunsigned long mflags;\n\n\t\t\tif (default_mounts[i].source) {\n\t\t\t\t/* will act like strdup if %r is not present */\n\t\t\t\tsource = lxc_string_replace(\"%r\", conf->rootfs.path ? conf->rootfs.mount : \"\", default_mounts[i].source);\n\t\t\t\tif (!source) {\n\t\t\t\t\tSYSERROR(\"memory allocation error\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!default_mounts[i].destination) {\n\t\t\t\tERROR(\"BUG: auto mounts destination %d was NULL\", i);\n\t\t\t\tfree(source);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t/* will act like strdup if %r is not present */\n\t\t\tdestination = lxc_string_replace(\"%r\", conf->rootfs.path ? conf->rootfs.mount : \"\", default_mounts[i].destination);\n\t\t\tif (!destination) {\n\t\t\t\tsaved_errno = errno;\n\t\t\t\tSYSERROR(\"memory allocation error\");\n\t\t\t\tfree(source);\n\t\t\t\terrno = saved_errno;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmflags = add_required_remount_flags(source, destination,\n\t\t\t\t\tdefault_mounts[i].flags);\n\t\t\tr = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);\n\t\t\tsaved_errno = errno;\n\t\t\tif (r < 0 && errno == ENOENT) {\n\t\t\t\tINFO(\"Mount source or target for %s on %s doesn't exist. Skipping.\", source, destination);\n\t\t\t\tr = 0;\n\t\t\t}\n\t\t\telse if (r < 0)\n\t\t\t\tSYSERROR(\"error mounting %s on %s flags %lu\", source, destination, mflags);\n\n\t\t\tfree(source);\n\t\t\tfree(destination);\n\t\t\tif (r < 0) {\n\t\t\t\terrno = saved_errno;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (flags & LXC_AUTO_CGROUP_MASK) {\n\t\tint cg_flags;\n\n\t\tcg_flags = flags & LXC_AUTO_CGROUP_MASK;\n\t\t/* If the type of cgroup mount was not specified, it depends on the\n\t\t * container's capabilities as to what makes sense: if we have\n\t\t * CAP_SYS_ADMIN, the read-only part can be remounted read-write\n\t\t * anyway, so we may as well default to read-write; then the admin\n\t\t * will not be given a false sense of security. (And if they really\n\t\t * want mixed r/o r/w, then they can explicitly specify :mixed.)\n\t\t * OTOH, if the container lacks CAP_SYS_ADMIN, do only default to\n\t\t * :mixed, because then the container can't remount it read-write. */\n\t\tif (cg_flags == LXC_AUTO_CGROUP_NOSPEC || cg_flags == LXC_AUTO_CGROUP_FULL_NOSPEC) {\n\t\t\tint has_sys_admin = 0;\n\t\t\tif (!lxc_list_empty(&conf->keepcaps)) {\n\t\t\t\thas_sys_admin = in_caplist(CAP_SYS_ADMIN, &conf->keepcaps);\n\t\t\t} else {\n\t\t\t\thas_sys_admin = !in_caplist(CAP_SYS_ADMIN, &conf->caps);\n\t\t\t}\n\t\t\tif (cg_flags == LXC_AUTO_CGROUP_NOSPEC) {\n\t\t\t\tcg_flags = has_sys_admin ? LXC_AUTO_CGROUP_RW : LXC_AUTO_CGROUP_MIXED;\n\t\t\t} else {\n\t\t\t\tcg_flags = has_sys_admin ? LXC_AUTO_CGROUP_FULL_RW : LXC_AUTO_CGROUP_FULL_MIXED;\n\t\t\t}\n\t\t}\n\n\t\tif (!cgroup_mount(conf->rootfs.path ? conf->rootfs.mount : \"\", handler, cg_flags)) {\n\t\t\tSYSERROR(\"error mounting /sys/fs/cgroup\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define CAP_SYS_ADMIN 21"
    ],
    "globals_used": [
      "static int in_caplist(int cap, struct lxc_list *caps);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"error mounting /sys/fs/cgroup\""
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_mount",
          "args": [
            "conf->rootfs.path ? conf->rootfs.mount : \"\"",
            "handler",
            "cg_flags"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgroup.c",
          "lines": "160-166",
          "snippet": "bool cgroup_mount(const char *root, struct lxc_handler *handler, int type)\n{\n\tif (ops) {\n\t\treturn ops->mount_cgroup(handler->cgroup_data, root, type);\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"log.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_ops *ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"log.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <unistd.h>\n\nstatic struct cgroup_ops *ops = NULL;\n\nbool cgroup_mount(const char *root, struct lxc_handler *handler, int type)\n{\n\tif (ops) {\n\t\treturn ops->mount_cgroup(handler->cgroup_data, root, type);\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_caplist",
          "args": [
            "CAP_SYS_ADMIN",
            "&conf->caps"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "in_caplist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "2104-2116",
          "snippet": "int in_caplist(int cap, struct lxc_list *caps)\n{\n\tstruct lxc_list *iterator;\n\tint capid;\n\n\tlxc_list_for_each(iterator, caps) {\n\t\tcapid = parse_cap(iterator->elem);\n\t\tif (capid == cap)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int in_caplist(int cap, struct lxc_list *caps);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int in_caplist(int cap, struct lxc_list *caps);\n\nint in_caplist(int cap, struct lxc_list *caps)\n{\n\tstruct lxc_list *iterator;\n\tint capid;\n\n\tlxc_list_for_each(iterator, caps) {\n\t\tcapid = parse_cap(iterator->elem);\n\t\tif (capid == cap)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_empty",
          "args": [
            "&conf->keepcaps"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "94-97",
          "snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "destination"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4619-4628",
          "snippet": "static void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"error mounting %s on %s flags %lu\"",
            "source",
            "destination",
            "mflags"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Mount source or target for %s on %s doesn't exist. Skipping.\"",
            "source",
            "destination"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_mount",
          "args": [
            "source",
            "destination",
            "default_mounts[i].fstype",
            "mflags",
            "default_mounts[i].options",
            "conf->rootfs.path ? conf->rootfs.mount : NULL"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "safe_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1687-1743",
          "snippet": "int safe_mount(const char *src, const char *dest, const char *fstype,\n\t\tunsigned long flags, const void *data, const char *rootfs)\n{\n\tint srcfd = -1, destfd, ret, saved_errno;\n\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n\tconst char *mntsrc = src;\n\n\tif (!rootfs)\n\t\trootfs = \"\";\n\n\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n\tif (flags & MS_BIND && src && src[0] != '/') {\n\t\tINFO(\"this is a relative bind mount\");\n\t\tsrcfd = open_without_symlink(src, NULL);\n\t\tif (srcfd < 0)\n\t\t\treturn srcfd;\n\t\tret = snprintf(srcbuf, 50, \"/proc/self/fd/%d\", srcfd);\n\t\tif (ret < 0 || ret > 50) {\n\t\t\tclose(srcfd);\n\t\t\tERROR(\"Out of memory\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmntsrc = srcbuf;\n\t}\n\n\tdestfd = open_without_symlink(dest, rootfs);\n\tif (destfd < 0) {\n\t\tif (srcfd != -1) {\n\t\t\tsaved_errno = errno;\n\t\t\tclose(srcfd);\n\t\t\terrno = saved_errno;\n\t\t}\n\t\treturn destfd;\n\t}\n\n\tret = snprintf(destbuf, 50, \"/proc/self/fd/%d\", destfd);\n\tif (ret < 0 || ret > 50) {\n\t\tif (srcfd != -1)\n\t\t\tclose(srcfd);\n\t\tclose(destfd);\n\t\tERROR(\"Out of memory\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = mount(mntsrc, destbuf, fstype, flags, data);\n\tsaved_errno = errno;\n\tif (srcfd != -1)\n\t\tclose(srcfd);\n\tclose(destfd);\n\tif (ret < 0) {\n\t\terrno = saved_errno;\n\t\tSYSERROR(\"Failed to mount %s onto %s\", src, dest);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint safe_mount(const char *src, const char *dest, const char *fstype,\n\t\tunsigned long flags, const void *data, const char *rootfs)\n{\n\tint srcfd = -1, destfd, ret, saved_errno;\n\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n\tconst char *mntsrc = src;\n\n\tif (!rootfs)\n\t\trootfs = \"\";\n\n\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n\tif (flags & MS_BIND && src && src[0] != '/') {\n\t\tINFO(\"this is a relative bind mount\");\n\t\tsrcfd = open_without_symlink(src, NULL);\n\t\tif (srcfd < 0)\n\t\t\treturn srcfd;\n\t\tret = snprintf(srcbuf, 50, \"/proc/self/fd/%d\", srcfd);\n\t\tif (ret < 0 || ret > 50) {\n\t\t\tclose(srcfd);\n\t\t\tERROR(\"Out of memory\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmntsrc = srcbuf;\n\t}\n\n\tdestfd = open_without_symlink(dest, rootfs);\n\tif (destfd < 0) {\n\t\tif (srcfd != -1) {\n\t\t\tsaved_errno = errno;\n\t\t\tclose(srcfd);\n\t\t\terrno = saved_errno;\n\t\t}\n\t\treturn destfd;\n\t}\n\n\tret = snprintf(destbuf, 50, \"/proc/self/fd/%d\", destfd);\n\tif (ret < 0 || ret > 50) {\n\t\tif (srcfd != -1)\n\t\t\tclose(srcfd);\n\t\tclose(destfd);\n\t\tERROR(\"Out of memory\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = mount(mntsrc, destbuf, fstype, flags, data);\n\tsaved_errno = errno;\n\tif (srcfd != -1)\n\t\tclose(srcfd);\n\tclose(destfd);\n\tif (ret < 0) {\n\t\terrno = saved_errno;\n\t\tSYSERROR(\"Failed to mount %s onto %s\", src, dest);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_required_remount_flags",
          "args": [
            "source",
            "destination",
            "default_mounts[i].flags"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "add_required_remount_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "686-717",
          "snippet": "static unsigned long add_required_remount_flags(const char *s, const char *d,\n\t\tunsigned long flags)\n{\n#ifdef HAVE_STATVFS\n\tstruct statvfs sb;\n\tunsigned long required_flags = 0;\n\n\tif (!(flags & MS_REMOUNT))\n\t\treturn flags;\n\n\tif (!s)\n\t\ts = d;\n\n\tif (!s)\n\t\treturn flags;\n\tif (statvfs(s, &sb) < 0)\n\t\treturn flags;\n\n\tif (sb.f_flag & MS_NOSUID)\n\t\trequired_flags |= MS_NOSUID;\n\tif (sb.f_flag & MS_NODEV)\n\t\trequired_flags |= MS_NODEV;\n\tif (sb.f_flag & MS_RDONLY)\n\t\trequired_flags |= MS_RDONLY;\n\tif (sb.f_flag & MS_NOEXEC)\n\t\trequired_flags |= MS_NOEXEC;\n\n\treturn flags | required_flags;\n#else\n\treturn flags;\n#endif\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic unsigned long add_required_remount_flags(const char *s, const char *d,\n\t\tunsigned long flags)\n{\n#ifdef HAVE_STATVFS\n\tstruct statvfs sb;\n\tunsigned long required_flags = 0;\n\n\tif (!(flags & MS_REMOUNT))\n\t\treturn flags;\n\n\tif (!s)\n\t\ts = d;\n\n\tif (!s)\n\t\treturn flags;\n\tif (statvfs(s, &sb) < 0)\n\t\treturn flags;\n\n\tif (sb.f_flag & MS_NOSUID)\n\t\trequired_flags |= MS_NOSUID;\n\tif (sb.f_flag & MS_NODEV)\n\t\trequired_flags |= MS_NODEV;\n\tif (sb.f_flag & MS_RDONLY)\n\t\trequired_flags |= MS_RDONLY;\n\tif (sb.f_flag & MS_NOEXEC)\n\t\trequired_flags |= MS_NOEXEC;\n\n\treturn flags | required_flags;\n#else\n\treturn flags;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"memory allocation error\""
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_string_replace",
          "args": [
            "\"%r\"",
            "conf->rootfs.path ? conf->rootfs.mount : \"\"",
            "default_mounts[i].destination"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "601-654",
          "snippet": "char *lxc_string_replace(const char *needle, const char *replacement, const char *haystack)\n{\n\tssize_t len = -1, saved_len = -1;\n\tchar *result = NULL;\n\tsize_t replacement_len = strlen(replacement);\n\tsize_t needle_len = strlen(needle);\n\n\t/* should be executed exactly twice */\n\twhile (len == -1 || result == NULL) {\n\t\tchar *p;\n\t\tchar *last_p;\n\t\tssize_t part_len;\n\n\t\tif (len != -1) {\n\t\t\tresult = calloc(1, len + 1);\n\t\t\tif (!result)\n\t\t\t\treturn NULL;\n\t\t\tsaved_len = len;\n\t\t}\n\n\t\tlen = 0;\n\n\t\tfor (last_p = (char *)haystack, p = strstr(last_p, needle); p; last_p = p, p = strstr(last_p, needle)) {\n\t\t\tpart_len = (ssize_t)(p - last_p);\n\t\t\tif (result && part_len > 0)\n\t\t\t\tmemcpy(&result[len], last_p, part_len);\n\t\t\tlen += part_len;\n\t\t\tif (result && replacement_len > 0)\n\t\t\t\tmemcpy(&result[len], replacement, replacement_len);\n\t\t\tlen += replacement_len;\n\t\t\tp += needle_len;\n\t\t}\n\t\tpart_len = strlen(last_p);\n\t\tif (result && part_len > 0)\n\t\t\tmemcpy(&result[len], last_p, part_len);\n\t\tlen += part_len;\n\t}\n\n\t/* make sure we did the same thing twice,\n\t * once for calculating length, the other\n\t * time for copying data */\n\tif (saved_len != len) {\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\t/* make sure we didn't overwrite any buffer,\n\t * due to calloc the string should be 0-terminated */\n\tif (result[len] != '\\0') {\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *lxc_string_replace(const char *needle, const char *replacement, const char *haystack)\n{\n\tssize_t len = -1, saved_len = -1;\n\tchar *result = NULL;\n\tsize_t replacement_len = strlen(replacement);\n\tsize_t needle_len = strlen(needle);\n\n\t/* should be executed exactly twice */\n\twhile (len == -1 || result == NULL) {\n\t\tchar *p;\n\t\tchar *last_p;\n\t\tssize_t part_len;\n\n\t\tif (len != -1) {\n\t\t\tresult = calloc(1, len + 1);\n\t\t\tif (!result)\n\t\t\t\treturn NULL;\n\t\t\tsaved_len = len;\n\t\t}\n\n\t\tlen = 0;\n\n\t\tfor (last_p = (char *)haystack, p = strstr(last_p, needle); p; last_p = p, p = strstr(last_p, needle)) {\n\t\t\tpart_len = (ssize_t)(p - last_p);\n\t\t\tif (result && part_len > 0)\n\t\t\t\tmemcpy(&result[len], last_p, part_len);\n\t\t\tlen += part_len;\n\t\t\tif (result && replacement_len > 0)\n\t\t\t\tmemcpy(&result[len], replacement, replacement_len);\n\t\t\tlen += replacement_len;\n\t\t\tp += needle_len;\n\t\t}\n\t\tpart_len = strlen(last_p);\n\t\tif (result && part_len > 0)\n\t\t\tmemcpy(&result[len], last_p, part_len);\n\t\tlen += part_len;\n\t}\n\n\t/* make sure we did the same thing twice,\n\t * once for calculating length, the other\n\t * time for copying data */\n\tif (saved_len != len) {\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\t/* make sure we didn't overwrite any buffer,\n\t * due to calloc the string should be 0-terminated */\n\tif (result[len] != '\\0') {\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"BUG: auto mounts destination %d was NULL\"",
            "i"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"memory allocation error\""
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\n#define CAP_SYS_ADMIN 21\n\nstatic int in_caplist(int cap, struct lxc_list *caps);\n\nstatic int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_handler *handler)\n{\n\tint r;\n\tint i;\n\tstatic struct {\n\t\tint match_mask;\n\t\tint match_flag;\n\t\tconst char *source;\n\t\tconst char *destination;\n\t\tconst char *fstype;\n\t\tunsigned long flags;\n\t\tconst char *options;\n\t} default_mounts[] = {\n\t\t/* Read-only bind-mounting... In older kernels, doing that required\n\t\t * to do one MS_BIND mount and then MS_REMOUNT|MS_RDONLY the same\n\t\t * one. According to mount(2) manpage, MS_BIND honors MS_RDONLY from\n\t\t * kernel 2.6.26 onwards. However, this apparently does not work on\n\t\t * kernel 3.8. Unfortunately, on that very same kernel, doing the\n\t\t * same trick as above doesn't seem to work either, there one needs\n\t\t * to ALSO specify MS_BIND for the remount, otherwise the entire\n\t\t * fs is remounted read-only or the mount fails because it's busy...\n\t\t * MS_REMOUNT|MS_BIND|MS_RDONLY seems to work for kernels as low as\n\t\t * 2.6.32...\n\t\t */\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"proc\",                                              \"%r/proc\",                      \"proc\",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n\t\t/* proc/tty is used as a temporary placeholder for proc/sys/net which we'll move back in a few steps */\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys/net\",                                   \"%r/proc/tty\",                  NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys\",                                       \"%r/proc/sys\",                  NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \"%r/proc/sys\",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/tty\",                                       \"%r/proc/sys/net\",              NULL,       MS_MOVE,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sysrq-trigger\",                             \"%r/proc/sysrq-trigger\",        NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \"%r/proc/sysrq-trigger\",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    \"proc\",                                              \"%r/proc\",                      \"proc\",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_RW,     \"sysfs\",                                             \"%r/sys\",                       \"sysfs\",    0,                              NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_RO,     \"sysfs\",                                             \"%r/sys\",                       \"sysfs\",    MS_RDONLY,                      NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  \"sysfs\",                                             \"%r/sys\",                       \"sysfs\",    MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  \"%r/sys\",                                            \"%r/sys\",                       NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  NULL,                                                \"%r/sys\",                       NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  \"sysfs\",                                             \"%r/sys/devices/virtual/net\",   \"sysfs\",    0,                              NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  \"%r/sys/devices/virtual/net/devices/virtual/net\",    \"%r/sys/devices/virtual/net\",   NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  NULL,                                                \"%r/sys/devices/virtual/net\",   NULL,       MS_REMOUNT|MS_BIND|MS_NOSUID|MS_NODEV|MS_NOEXEC,   NULL },\n\t\t{ 0,                  0,                   NULL,                                                NULL,                           NULL,       0,                              NULL }\n\t};\n\n\tfor (i = 0; default_mounts[i].match_mask; i++) {\n\t\tif ((flags & default_mounts[i].match_mask) == default_mounts[i].match_flag) {\n\t\t\tchar *source = NULL;\n\t\t\tchar *destination = NULL;\n\t\t\tint saved_errno;\n\t\t\tunsigned long mflags;\n\n\t\t\tif (default_mounts[i].source) {\n\t\t\t\t/* will act like strdup if %r is not present */\n\t\t\t\tsource = lxc_string_replace(\"%r\", conf->rootfs.path ? conf->rootfs.mount : \"\", default_mounts[i].source);\n\t\t\t\tif (!source) {\n\t\t\t\t\tSYSERROR(\"memory allocation error\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!default_mounts[i].destination) {\n\t\t\t\tERROR(\"BUG: auto mounts destination %d was NULL\", i);\n\t\t\t\tfree(source);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t/* will act like strdup if %r is not present */\n\t\t\tdestination = lxc_string_replace(\"%r\", conf->rootfs.path ? conf->rootfs.mount : \"\", default_mounts[i].destination);\n\t\t\tif (!destination) {\n\t\t\t\tsaved_errno = errno;\n\t\t\t\tSYSERROR(\"memory allocation error\");\n\t\t\t\tfree(source);\n\t\t\t\terrno = saved_errno;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmflags = add_required_remount_flags(source, destination,\n\t\t\t\t\tdefault_mounts[i].flags);\n\t\t\tr = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);\n\t\t\tsaved_errno = errno;\n\t\t\tif (r < 0 && errno == ENOENT) {\n\t\t\t\tINFO(\"Mount source or target for %s on %s doesn't exist. Skipping.\", source, destination);\n\t\t\t\tr = 0;\n\t\t\t}\n\t\t\telse if (r < 0)\n\t\t\t\tSYSERROR(\"error mounting %s on %s flags %lu\", source, destination, mflags);\n\n\t\t\tfree(source);\n\t\t\tfree(destination);\n\t\t\tif (r < 0) {\n\t\t\t\terrno = saved_errno;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (flags & LXC_AUTO_CGROUP_MASK) {\n\t\tint cg_flags;\n\n\t\tcg_flags = flags & LXC_AUTO_CGROUP_MASK;\n\t\t/* If the type of cgroup mount was not specified, it depends on the\n\t\t * container's capabilities as to what makes sense: if we have\n\t\t * CAP_SYS_ADMIN, the read-only part can be remounted read-write\n\t\t * anyway, so we may as well default to read-write; then the admin\n\t\t * will not be given a false sense of security. (And if they really\n\t\t * want mixed r/o r/w, then they can explicitly specify :mixed.)\n\t\t * OTOH, if the container lacks CAP_SYS_ADMIN, do only default to\n\t\t * :mixed, because then the container can't remount it read-write. */\n\t\tif (cg_flags == LXC_AUTO_CGROUP_NOSPEC || cg_flags == LXC_AUTO_CGROUP_FULL_NOSPEC) {\n\t\t\tint has_sys_admin = 0;\n\t\t\tif (!lxc_list_empty(&conf->keepcaps)) {\n\t\t\t\thas_sys_admin = in_caplist(CAP_SYS_ADMIN, &conf->keepcaps);\n\t\t\t} else {\n\t\t\t\thas_sys_admin = !in_caplist(CAP_SYS_ADMIN, &conf->caps);\n\t\t\t}\n\t\t\tif (cg_flags == LXC_AUTO_CGROUP_NOSPEC) {\n\t\t\t\tcg_flags = has_sys_admin ? LXC_AUTO_CGROUP_RW : LXC_AUTO_CGROUP_MIXED;\n\t\t\t} else {\n\t\t\t\tcg_flags = has_sys_admin ? LXC_AUTO_CGROUP_FULL_RW : LXC_AUTO_CGROUP_FULL_MIXED;\n\t\t\t}\n\t\t}\n\n\t\tif (!cgroup_mount(conf->rootfs.path ? conf->rootfs.mount : \"\", handler, cg_flags)) {\n\t\t\tSYSERROR(\"error mounting /sys/fs/cgroup\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "add_required_remount_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "686-717",
    "snippet": "static unsigned long add_required_remount_flags(const char *s, const char *d,\n\t\tunsigned long flags)\n{\n#ifdef HAVE_STATVFS\n\tstruct statvfs sb;\n\tunsigned long required_flags = 0;\n\n\tif (!(flags & MS_REMOUNT))\n\t\treturn flags;\n\n\tif (!s)\n\t\ts = d;\n\n\tif (!s)\n\t\treturn flags;\n\tif (statvfs(s, &sb) < 0)\n\t\treturn flags;\n\n\tif (sb.f_flag & MS_NOSUID)\n\t\trequired_flags |= MS_NOSUID;\n\tif (sb.f_flag & MS_NODEV)\n\t\trequired_flags |= MS_NODEV;\n\tif (sb.f_flag & MS_RDONLY)\n\t\trequired_flags |= MS_RDONLY;\n\tif (sb.f_flag & MS_NOEXEC)\n\t\trequired_flags |= MS_NOEXEC;\n\n\treturn flags | required_flags;\n#else\n\treturn flags;\n#endif\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "statvfs",
          "args": [
            "s",
            "&sb"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic unsigned long add_required_remount_flags(const char *s, const char *d,\n\t\tunsigned long flags)\n{\n#ifdef HAVE_STATVFS\n\tstruct statvfs sb;\n\tunsigned long required_flags = 0;\n\n\tif (!(flags & MS_REMOUNT))\n\t\treturn flags;\n\n\tif (!s)\n\t\ts = d;\n\n\tif (!s)\n\t\treturn flags;\n\tif (statvfs(s, &sb) < 0)\n\t\treturn flags;\n\n\tif (sb.f_flag & MS_NOSUID)\n\t\trequired_flags |= MS_NOSUID;\n\tif (sb.f_flag & MS_NODEV)\n\t\trequired_flags |= MS_NODEV;\n\tif (sb.f_flag & MS_RDONLY)\n\t\trequired_flags |= MS_RDONLY;\n\tif (sb.f_flag & MS_NOEXEC)\n\t\trequired_flags |= MS_NOEXEC;\n\n\treturn flags | required_flags;\n#else\n\treturn flags;\n#endif\n}"
  },
  {
    "function_name": "pin_rootfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "649-680",
    "snippet": "int pin_rootfs(const char *rootfs)\n{\n\tchar absrootfs[MAXPATHLEN];\n\tchar absrootfspin[MAXPATHLEN];\n\tstruct stat s;\n\tint ret, fd;\n\n\tif (rootfs == NULL || strlen(rootfs) == 0)\n\t\treturn -2;\n\n\tif (!realpath(rootfs, absrootfs))\n\t\treturn -2;\n\n\tif (access(absrootfs, F_OK))\n\t\treturn -1;\n\n\tif (stat(absrootfs, &s))\n\t\treturn -1;\n\n\tif (!S_ISDIR(s.st_mode))\n\t\treturn -2;\n\n\tret = snprintf(absrootfspin, MAXPATHLEN, \"%s/lxc.hold\", absrootfs);\n\tif (ret >= MAXPATHLEN)\n\t\treturn -1;\n\n\tfd = open(absrootfspin, O_CREAT | O_RDWR, S_IWUSR|S_IRUSR);\n\tif (fd < 0)\n\t\treturn fd;\n\t(void)unlink(absrootfspin);\n\treturn fd;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "absrootfspin"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "absrootfspin",
            "O_CREAT | O_RDWR",
            "S_IWUSR|S_IRUSR"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "37-82",
          "snippet": "int lxc_abstract_unix_open(const char *path, int type, int flags)\n{\n\tint fd;\n\tsize_t len;\n\tstruct sockaddr_un addr;\n\n\tif (flags & O_TRUNC)\n\t\tunlink(path);\n\n\tfd = socket(PF_UNIX, type, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\n\t/* Clear address structure */\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (!path)\n\t\treturn fd;\n\n\taddr.sun_family = AF_UNIX;\n\n\tlen = strlen(&path[1]) + 1;\n\tif (len >= sizeof(addr.sun_path) - 1) {\n\t\tclose(fd);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\t/* addr.sun_path[0] has already been set to 0 by memset() */\n\tstrncpy(&addr.sun_path[1], &path[1], strlen(&path[1]));\n\n\tif (bind(fd, (struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path) + len)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\tif (type == SOCK_STREAM && listen(fd, 100)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_open(const char *path, int type, int flags)\n{\n\tint fd;\n\tsize_t len;\n\tstruct sockaddr_un addr;\n\n\tif (flags & O_TRUNC)\n\t\tunlink(path);\n\n\tfd = socket(PF_UNIX, type, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\n\t/* Clear address structure */\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (!path)\n\t\treturn fd;\n\n\taddr.sun_family = AF_UNIX;\n\n\tlen = strlen(&path[1]) + 1;\n\tif (len >= sizeof(addr.sun_path) - 1) {\n\t\tclose(fd);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\t/* addr.sun_path[0] has already been set to 0 by memset() */\n\tstrncpy(&addr.sun_path[1], &path[1], strlen(&path[1]));\n\n\tif (bind(fd, (struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path) + len)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\tif (type == SOCK_STREAM && listen(fd, 100)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "absrootfspin",
            "MAXPATHLEN",
            "\"%s/lxc.hold\"",
            "absrootfs"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "s.st_mode"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "absrootfs",
            "&s"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "freezer_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/freezer.c",
          "lines": "42-51",
          "snippet": "lxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}",
          "includes": [
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"monitor.h\"",
            "#include \"state.h\"",
            "#include \"error.h\"",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxc.h\"\n#include \"log.h\"\n#include \"monitor.h\"\n#include \"state.h\"\n#include \"error.h\"\n#include <sys/param.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nlxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "absrootfs",
            "F_OK"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realpath",
          "args": [
            "rootfs",
            "absrootfs"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "rootfs"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint pin_rootfs(const char *rootfs)\n{\n\tchar absrootfs[MAXPATHLEN];\n\tchar absrootfspin[MAXPATHLEN];\n\tstruct stat s;\n\tint ret, fd;\n\n\tif (rootfs == NULL || strlen(rootfs) == 0)\n\t\treturn -2;\n\n\tif (!realpath(rootfs, absrootfs))\n\t\treturn -2;\n\n\tif (access(absrootfs, F_OK))\n\t\treturn -1;\n\n\tif (stat(absrootfs, &s))\n\t\treturn -1;\n\n\tif (!S_ISDIR(s.st_mode))\n\t\treturn -2;\n\n\tret = snprintf(absrootfspin, MAXPATHLEN, \"%s/lxc.hold\", absrootfs);\n\tif (ret >= MAXPATHLEN)\n\t\treturn -1;\n\n\tfd = open(absrootfspin, O_CREAT | O_RDWR, S_IWUSR|S_IRUSR);\n\tif (fd < 0)\n\t\treturn fd;\n\t(void)unlink(absrootfspin);\n\treturn fd;\n}"
  },
  {
    "function_name": "mount_rootfs_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "633-637",
    "snippet": "static int mount_rootfs_block(const char *rootfs, const char *target,\n\t\t\t                  const char *options)\n{\n\treturn mount_unknown_fs(rootfs, target, options);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_unknown_fs",
          "args": [
            "rootfs",
            "target",
            "options"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "mount_unknown_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "739-782",
          "snippet": "int mount_unknown_fs(const char *rootfs, const char *target,\n\t\tconst char *options)\n{\n\tstruct cbarg {\n\t\tconst char *rootfs;\n\t\tconst char *target;\n\t\tconst char *options;\n\t} cbarg = {\n\t\t.rootfs = rootfs,\n\t\t.target = target,\n\t\t.options = options,\n\t};\n\n\t/*\n\t * find the filesystem type with brute force:\n\t * first we check with /etc/filesystems, in case the modules\n\t * are auto-loaded and fall back to the supported kernel fs\n\t */\n\tchar *fsfile[] = {\n\t\t\"/etc/filesystems\",\n\t\t\"/proc/filesystems\",\n\t};\n\n\tsize_t i;\n\tfor (i = 0; i < sizeof(fsfile) / sizeof(fsfile[0]); i++) {\n\n\t\tint ret;\n\n\t\tif (access(fsfile[i], F_OK))\n\t\t\tcontinue;\n\n\t\tret = lxc_file_for_each_line(fsfile[i], find_fstype_cb, &cbarg);\n\t\tif (ret < 0) {\n\t\t\tERROR(\"failed to parse '%s'\", fsfile[i]);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (ret)\n\t\t\treturn 0;\n\t}\n\n\tERROR(\"failed to determine fs type for '%s'\", rootfs);\n\treturn -1;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bdev *bdev_get(const char *type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic struct bdev *bdev_get(const char *type);\n\nint mount_unknown_fs(const char *rootfs, const char *target,\n\t\tconst char *options)\n{\n\tstruct cbarg {\n\t\tconst char *rootfs;\n\t\tconst char *target;\n\t\tconst char *options;\n\t} cbarg = {\n\t\t.rootfs = rootfs,\n\t\t.target = target,\n\t\t.options = options,\n\t};\n\n\t/*\n\t * find the filesystem type with brute force:\n\t * first we check with /etc/filesystems, in case the modules\n\t * are auto-loaded and fall back to the supported kernel fs\n\t */\n\tchar *fsfile[] = {\n\t\t\"/etc/filesystems\",\n\t\t\"/proc/filesystems\",\n\t};\n\n\tsize_t i;\n\tfor (i = 0; i < sizeof(fsfile) / sizeof(fsfile[0]); i++) {\n\n\t\tint ret;\n\n\t\tif (access(fsfile[i], F_OK))\n\t\t\tcontinue;\n\n\t\tret = lxc_file_for_each_line(fsfile[i], find_fstype_cb, &cbarg);\n\t\tif (ret < 0) {\n\t\t\tERROR(\"failed to parse '%s'\", fsfile[i]);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (ret)\n\t\t\treturn 0;\n\t}\n\n\tERROR(\"failed to determine fs type for '%s'\", rootfs);\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int mount_rootfs_block(const char *rootfs, const char *target,\n\t\t\t                  const char *options)\n{\n\treturn mount_unknown_fs(rootfs, target, options);\n}"
  },
  {
    "function_name": "mount_rootfs_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "568-631",
    "snippet": "static int mount_rootfs_file(const char *rootfs, const char *target,\n\t\t\t\t             const char *options)\n{\n\tstruct dirent *direntp;\n\tstruct loop_info64 loinfo;\n\tint ret = -1, fd = -1, rc;\n\tDIR *dir;\n\tchar path[MAXPATHLEN];\n\n\tdir = opendir(\"/dev\");\n\tif (!dir) {\n\t\tSYSERROR(\"failed to open '/dev'\");\n\t\treturn -1;\n\t}\n\n\twhile ((direntp = readdir(dir))) {\n\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\"))\n\t\t\tcontinue;\n\n\t\tif (!strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\tif (strncmp(direntp->d_name, \"loop\", 4))\n\t\t\tcontinue;\n\n\t\trc = snprintf(path, MAXPATHLEN, \"/dev/%s\", direntp->d_name);\n\t\tif (rc < 0 || rc >= MAXPATHLEN)\n\t\t\tcontinue;\n\n\t\tfd = open(path, O_RDWR);\n\t\tif (fd < 0)\n\t\t\tcontinue;\n\n\t\tif (ioctl(fd, LOOP_GET_STATUS64, &loinfo) == 0) {\n\t\t\tclose(fd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (errno != ENXIO) {\n\t\t\tWARN(\"unexpected error for ioctl on '%s': %m\",\n\t\t\t     direntp->d_name);\n\t\t\tclose(fd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tDEBUG(\"found '%s' free lodev\", path);\n\n\t\tret = setup_lodev(rootfs, fd, &loinfo);\n\t\tif (!ret)\n\t\t\tret = mount_unknown_fs(path, target, options);\n\t\tclose(fd);\n\n\t\tbreak;\n\t}\n\n\tif (closedir(dir))\n\t\tWARN(\"failed to close directory\");\n\n\treturn ret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"failed to close directory\""
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dir"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mount_unknown_fs",
          "args": [
            "path",
            "target",
            "options"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "mount_unknown_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "739-782",
          "snippet": "int mount_unknown_fs(const char *rootfs, const char *target,\n\t\tconst char *options)\n{\n\tstruct cbarg {\n\t\tconst char *rootfs;\n\t\tconst char *target;\n\t\tconst char *options;\n\t} cbarg = {\n\t\t.rootfs = rootfs,\n\t\t.target = target,\n\t\t.options = options,\n\t};\n\n\t/*\n\t * find the filesystem type with brute force:\n\t * first we check with /etc/filesystems, in case the modules\n\t * are auto-loaded and fall back to the supported kernel fs\n\t */\n\tchar *fsfile[] = {\n\t\t\"/etc/filesystems\",\n\t\t\"/proc/filesystems\",\n\t};\n\n\tsize_t i;\n\tfor (i = 0; i < sizeof(fsfile) / sizeof(fsfile[0]); i++) {\n\n\t\tint ret;\n\n\t\tif (access(fsfile[i], F_OK))\n\t\t\tcontinue;\n\n\t\tret = lxc_file_for_each_line(fsfile[i], find_fstype_cb, &cbarg);\n\t\tif (ret < 0) {\n\t\t\tERROR(\"failed to parse '%s'\", fsfile[i]);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (ret)\n\t\t\treturn 0;\n\t}\n\n\tERROR(\"failed to determine fs type for '%s'\", rootfs);\n\treturn -1;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bdev *bdev_get(const char *type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic struct bdev *bdev_get(const char *type);\n\nint mount_unknown_fs(const char *rootfs, const char *target,\n\t\tconst char *options)\n{\n\tstruct cbarg {\n\t\tconst char *rootfs;\n\t\tconst char *target;\n\t\tconst char *options;\n\t} cbarg = {\n\t\t.rootfs = rootfs,\n\t\t.target = target,\n\t\t.options = options,\n\t};\n\n\t/*\n\t * find the filesystem type with brute force:\n\t * first we check with /etc/filesystems, in case the modules\n\t * are auto-loaded and fall back to the supported kernel fs\n\t */\n\tchar *fsfile[] = {\n\t\t\"/etc/filesystems\",\n\t\t\"/proc/filesystems\",\n\t};\n\n\tsize_t i;\n\tfor (i = 0; i < sizeof(fsfile) / sizeof(fsfile[0]); i++) {\n\n\t\tint ret;\n\n\t\tif (access(fsfile[i], F_OK))\n\t\t\tcontinue;\n\n\t\tret = lxc_file_for_each_line(fsfile[i], find_fstype_cb, &cbarg);\n\t\tif (ret < 0) {\n\t\t\tERROR(\"failed to parse '%s'\", fsfile[i]);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (ret)\n\t\t\treturn 0;\n\t}\n\n\tERROR(\"failed to determine fs type for '%s'\", rootfs);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_lodev",
          "args": [
            "rootfs",
            "fd",
            "&loinfo"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "setup_lodev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "536-566",
          "snippet": "static int setup_lodev(const char *rootfs, int fd, struct loop_info64 *loinfo)\n{\n\tint rfd;\n\tint ret = -1;\n\n\trfd = open(rootfs, O_RDWR);\n\tif (rfd < 0) {\n\t\tSYSERROR(\"failed to open '%s'\", rootfs);\n\t\treturn -1;\n\t}\n\n\tmemset(loinfo, 0, sizeof(*loinfo));\n\n\tloinfo->lo_flags = LO_FLAGS_AUTOCLEAR;\n\n\tif (ioctl(fd, LOOP_SET_FD, rfd)) {\n\t\tSYSERROR(\"failed to LOOP_SET_FD\");\n\t\tgoto out;\n\t}\n\n\tif (ioctl(fd, LOOP_SET_STATUS64, loinfo)) {\n\t\tSYSERROR(\"failed to LOOP_SET_STATUS64\");\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tclose(rfd);\n\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define LO_FLAGS_AUTOCLEAR 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\n#define LO_FLAGS_AUTOCLEAR 4\n\nstatic int setup_lodev(const char *rootfs, int fd, struct loop_info64 *loinfo)\n{\n\tint rfd;\n\tint ret = -1;\n\n\trfd = open(rootfs, O_RDWR);\n\tif (rfd < 0) {\n\t\tSYSERROR(\"failed to open '%s'\", rootfs);\n\t\treturn -1;\n\t}\n\n\tmemset(loinfo, 0, sizeof(*loinfo));\n\n\tloinfo->lo_flags = LO_FLAGS_AUTOCLEAR;\n\n\tif (ioctl(fd, LOOP_SET_FD, rfd)) {\n\t\tSYSERROR(\"failed to LOOP_SET_FD\");\n\t\tgoto out;\n\t}\n\n\tif (ioctl(fd, LOOP_SET_STATUS64, loinfo)) {\n\t\tSYSERROR(\"failed to LOOP_SET_STATUS64\");\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tclose(rfd);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"found '%s' free lodev\"",
            "path"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"unexpected error for ioctl on '%s': %m\"",
            "direntp->d_name"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "LOOP_GET_STATUS64",
            "&loinfo"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "path",
            "O_RDWR"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "genetlink_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/genl.c",
          "lines": "106-116",
          "snippet": "extern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"genl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/genetlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"genl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "MAXPATHLEN",
            "\"/dev/%s\"",
            "direntp->d_name"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "direntp->d_name",
            "\"loop\"",
            "4"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "direntp->d_name",
            "\"..\""
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "direntp->d_name",
            "\".\""
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "dir"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to open '/dev'\""
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "\"/dev\""
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int mount_rootfs_file(const char *rootfs, const char *target,\n\t\t\t\t             const char *options)\n{\n\tstruct dirent *direntp;\n\tstruct loop_info64 loinfo;\n\tint ret = -1, fd = -1, rc;\n\tDIR *dir;\n\tchar path[MAXPATHLEN];\n\n\tdir = opendir(\"/dev\");\n\tif (!dir) {\n\t\tSYSERROR(\"failed to open '/dev'\");\n\t\treturn -1;\n\t}\n\n\twhile ((direntp = readdir(dir))) {\n\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\"))\n\t\t\tcontinue;\n\n\t\tif (!strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\tif (strncmp(direntp->d_name, \"loop\", 4))\n\t\t\tcontinue;\n\n\t\trc = snprintf(path, MAXPATHLEN, \"/dev/%s\", direntp->d_name);\n\t\tif (rc < 0 || rc >= MAXPATHLEN)\n\t\t\tcontinue;\n\n\t\tfd = open(path, O_RDWR);\n\t\tif (fd < 0)\n\t\t\tcontinue;\n\n\t\tif (ioctl(fd, LOOP_GET_STATUS64, &loinfo) == 0) {\n\t\t\tclose(fd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (errno != ENXIO) {\n\t\t\tWARN(\"unexpected error for ioctl on '%s': %m\",\n\t\t\t     direntp->d_name);\n\t\t\tclose(fd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tDEBUG(\"found '%s' free lodev\", path);\n\n\t\tret = setup_lodev(rootfs, fd, &loinfo);\n\t\tif (!ret)\n\t\t\tret = mount_unknown_fs(path, target, options);\n\t\tclose(fd);\n\n\t\tbreak;\n\t}\n\n\tif (closedir(dir))\n\t\tWARN(\"failed to close directory\");\n\n\treturn ret;\n}"
  },
  {
    "function_name": "setup_lodev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "536-566",
    "snippet": "static int setup_lodev(const char *rootfs, int fd, struct loop_info64 *loinfo)\n{\n\tint rfd;\n\tint ret = -1;\n\n\trfd = open(rootfs, O_RDWR);\n\tif (rfd < 0) {\n\t\tSYSERROR(\"failed to open '%s'\", rootfs);\n\t\treturn -1;\n\t}\n\n\tmemset(loinfo, 0, sizeof(*loinfo));\n\n\tloinfo->lo_flags = LO_FLAGS_AUTOCLEAR;\n\n\tif (ioctl(fd, LOOP_SET_FD, rfd)) {\n\t\tSYSERROR(\"failed to LOOP_SET_FD\");\n\t\tgoto out;\n\t}\n\n\tif (ioctl(fd, LOOP_SET_STATUS64, loinfo)) {\n\t\tSYSERROR(\"failed to LOOP_SET_STATUS64\");\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tclose(rfd);\n\n\treturn ret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define LO_FLAGS_AUTOCLEAR 4"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "rfd"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to LOOP_SET_STATUS64\""
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "LOOP_SET_STATUS64",
            "loinfo"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to LOOP_SET_FD\""
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "LOOP_SET_FD",
            "rfd"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "loinfo",
            "0",
            "sizeof(*loinfo)"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to open '%s'\"",
            "rootfs"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "rootfs",
            "O_RDWR"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "genetlink_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/genl.c",
          "lines": "106-116",
          "snippet": "extern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"genl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/genetlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"genl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\n#define LO_FLAGS_AUTOCLEAR 4\n\nstatic int setup_lodev(const char *rootfs, int fd, struct loop_info64 *loinfo)\n{\n\tint rfd;\n\tint ret = -1;\n\n\trfd = open(rootfs, O_RDWR);\n\tif (rfd < 0) {\n\t\tSYSERROR(\"failed to open '%s'\", rootfs);\n\t\treturn -1;\n\t}\n\n\tmemset(loinfo, 0, sizeof(*loinfo));\n\n\tloinfo->lo_flags = LO_FLAGS_AUTOCLEAR;\n\n\tif (ioctl(fd, LOOP_SET_FD, rfd)) {\n\t\tSYSERROR(\"failed to LOOP_SET_FD\");\n\t\tgoto out;\n\t}\n\n\tif (ioctl(fd, LOOP_SET_STATUS64, loinfo)) {\n\t\tSYSERROR(\"failed to LOOP_SET_STATUS64\");\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tclose(rfd);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "mount_rootfs_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "518-534",
    "snippet": "static int mount_rootfs_dir(const char *rootfs, const char *target,\n\t\t\t                const char *options)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\n\tif (parse_mntopts(options, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount(rootfs, target, \"none\", MS_BIND | MS_REC | mntflags, mntdata);\n\tfree(mntdata);\n\n\treturn ret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "mntdata"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4619-4628",
          "snippet": "static void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "rootfs",
            "target",
            "\"none\"",
            "MS_BIND | MS_REC | mntflags",
            "mntdata"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "mount_entry_on_generic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1838-1869",
          "snippet": "static inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_mntopts",
          "args": [
            "options",
            "&mntflags",
            "&mntdata"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "parse_mntopts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1629-1666",
          "snippet": "int parse_mntopts(const char *mntopts, unsigned long *mntflags,\n\t\t\t char **mntdata)\n{\n\tchar *s, *data;\n\tchar *p, *saveptr = NULL;\n\n\t*mntdata = NULL;\n\t*mntflags = 0L;\n\n\tif (!mntopts)\n\t\treturn 0;\n\n\ts = strdup(mntopts);\n\tif (!s) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\treturn -1;\n\t}\n\n\tdata = malloc(strlen(s) + 1);\n\tif (!data) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\tfree(s);\n\t\treturn -1;\n\t}\n\t*data = 0;\n\n\tfor (p = strtok_r(s, \",\", &saveptr); p != NULL;\n\t     p = strtok_r(NULL, \",\", &saveptr))\n\t\tparse_mntopt(p, mntflags, &data);\n\n\tif (*data)\n\t\t*mntdata = data;\n\telse\n\t\tfree(data);\n\tfree(s);\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint parse_mntopts(const char *mntopts, unsigned long *mntflags,\n\t\t\t char **mntdata)\n{\n\tchar *s, *data;\n\tchar *p, *saveptr = NULL;\n\n\t*mntdata = NULL;\n\t*mntflags = 0L;\n\n\tif (!mntopts)\n\t\treturn 0;\n\n\ts = strdup(mntopts);\n\tif (!s) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\treturn -1;\n\t}\n\n\tdata = malloc(strlen(s) + 1);\n\tif (!data) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\tfree(s);\n\t\treturn -1;\n\t}\n\t*data = 0;\n\n\tfor (p = strtok_r(s, \",\", &saveptr); p != NULL;\n\t     p = strtok_r(NULL, \",\", &saveptr))\n\t\tparse_mntopt(p, mntflags, &data);\n\n\tif (*data)\n\t\t*mntdata = data;\n\telse\n\t\tfree(data);\n\tfree(s);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int mount_rootfs_dir(const char *rootfs, const char *target,\n\t\t\t                const char *options)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\n\tif (parse_mntopts(options, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount(rootfs, target, \"none\", MS_BIND | MS_REC | mntflags, mntdata);\n\tfree(mntdata);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "run_script",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "466-516",
    "snippet": "static int run_script(const char *name, const char *section, const char *script,\n\t\t      ...)\n{\n\tint ret;\n\tchar *buffer, *p;\n\tsize_t size = 0;\n\tva_list ap;\n\n\tINFO(\"Executing script \\\"%s\\\" for container \\\"%s\\\", config section \\\"%s\\\".\",\n\t     script, name, section);\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *)))\n\t\tsize += strlen(p) + 1;\n\tva_end(ap);\n\n\tsize += strlen(script);\n\tsize += strlen(name);\n\tsize += strlen(section);\n\tsize += 3;\n\n\tif (size > INT_MAX)\n\t\treturn -1;\n\n\tbuffer = alloca(size);\n\tif (!buffer) {\n\t\tERROR(\"Failed to allocate memory.\");\n\t\treturn -1;\n\t}\n\n\tret = snprintf(buffer, size, \"%s %s %s\", script, name, section);\n\tif (ret < 0 || ret >= size) {\n\t\tERROR(\"Script name too long.\");\n\t\treturn -1;\n\t}\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *))) {\n\t\tint len = size - ret;\n\t\tint rc;\n\t\trc = snprintf(buffer + ret, len, \" %s\", p);\n\t\tif (rc < 0 || rc >= len) {\n\t\t\tERROR(\"Script args too long.\");\n\t\t\treturn -1;\n\t\t}\n\t\tret += rc;\n\t}\n\tva_end(ap);\n\n\treturn run_buffer(buffer);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "run_buffer",
          "args": [
            "buffer"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "run_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "376-413",
          "snippet": "static int run_buffer(char *buffer)\n{\n\tstruct lxc_popen_FILE *f;\n\tchar *output;\n\tint ret;\n\n\tf = lxc_popen(buffer);\n\tif (!f) {\n\t\tSYSERROR(\"Failed to popen() %s.\", buffer);\n\t\treturn -1;\n\t}\n\n\toutput = malloc(LXC_LOG_BUFFER_SIZE);\n\tif (!output) {\n\t\tERROR(\"Failed to allocate memory for %s.\", buffer);\n\t\tlxc_pclose(f);\n\t\treturn -1;\n\t}\n\n\twhile (fgets(output, LXC_LOG_BUFFER_SIZE, f->f))\n\t\tDEBUG(\"Script %s with output: %s.\", buffer, output);\n\n\tfree(output);\n\n\tret = lxc_pclose(f);\n\tif (ret == -1) {\n\t\tSYSERROR(\"Script exited with error.\");\n\t\treturn -1;\n\t} else if (WIFEXITED(ret) && WEXITSTATUS(ret) != 0) {\n\t\tERROR(\"Script exited with status %d.\", WEXITSTATUS(ret));\n\t\treturn -1;\n\t} else if (WIFSIGNALED(ret)) {\n\t\tERROR(\"Script terminated by signal %d.\", WTERMSIG(ret));\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int run_buffer(char *buffer)\n{\n\tstruct lxc_popen_FILE *f;\n\tchar *output;\n\tint ret;\n\n\tf = lxc_popen(buffer);\n\tif (!f) {\n\t\tSYSERROR(\"Failed to popen() %s.\", buffer);\n\t\treturn -1;\n\t}\n\n\toutput = malloc(LXC_LOG_BUFFER_SIZE);\n\tif (!output) {\n\t\tERROR(\"Failed to allocate memory for %s.\", buffer);\n\t\tlxc_pclose(f);\n\t\treturn -1;\n\t}\n\n\twhile (fgets(output, LXC_LOG_BUFFER_SIZE, f->f))\n\t\tDEBUG(\"Script %s with output: %s.\", buffer, output);\n\n\tfree(output);\n\n\tret = lxc_pclose(f);\n\tif (ret == -1) {\n\t\tSYSERROR(\"Script exited with error.\");\n\t\treturn -1;\n\t} else if (WIFEXITED(ret) && WEXITSTATUS(ret) != 0) {\n\t\tERROR(\"Script exited with status %d.\", WEXITSTATUS(ret));\n\t\treturn -1;\n\t} else if (WIFSIGNALED(ret)) {\n\t\tERROR(\"Script terminated by signal %d.\", WTERMSIG(ret));\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ap"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Script args too long.\""
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer + ret",
            "len",
            "\" %s\"",
            "p"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "ap",
            "char*"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_va_arg_list_to_argv_const",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "464-467",
          "snippet": "const char** lxc_va_arg_list_to_argv_const(va_list ap, size_t skip)\n{\n\treturn (const char**)lxc_va_arg_list_to_argv(ap, skip, 0);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nconst char** lxc_va_arg_list_to_argv_const(va_list ap, size_t skip)\n{\n\treturn (const char**)lxc_va_arg_list_to_argv(ap, skip, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "ap",
            "script"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Script name too long.\""
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "size",
            "\"%s %s %s\"",
            "script",
            "name",
            "section"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to allocate memory.\""
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "size"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "section"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "script"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ap"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "ap",
            "script"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Executing script \\\"%s\\\" for container \\\"%s\\\", config section \\\"%s\\\".\"",
            "script",
            "name",
            "section"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int run_script(const char *name, const char *section, const char *script,\n\t\t      ...)\n{\n\tint ret;\n\tchar *buffer, *p;\n\tsize_t size = 0;\n\tva_list ap;\n\n\tINFO(\"Executing script \\\"%s\\\" for container \\\"%s\\\", config section \\\"%s\\\".\",\n\t     script, name, section);\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *)))\n\t\tsize += strlen(p) + 1;\n\tva_end(ap);\n\n\tsize += strlen(script);\n\tsize += strlen(name);\n\tsize += strlen(section);\n\tsize += 3;\n\n\tif (size > INT_MAX)\n\t\treturn -1;\n\n\tbuffer = alloca(size);\n\tif (!buffer) {\n\t\tERROR(\"Failed to allocate memory.\");\n\t\treturn -1;\n\t}\n\n\tret = snprintf(buffer, size, \"%s %s %s\", script, name, section);\n\tif (ret < 0 || ret >= size) {\n\t\tERROR(\"Script name too long.\");\n\t\treturn -1;\n\t}\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *))) {\n\t\tint len = size - ret;\n\t\tint rc;\n\t\trc = snprintf(buffer + ret, len, \" %s\", p);\n\t\tif (rc < 0 || rc >= len) {\n\t\t\tERROR(\"Script args too long.\");\n\t\t\treturn -1;\n\t\t}\n\t\tret += rc;\n\t}\n\tva_end(ap);\n\n\treturn run_buffer(buffer);\n}"
  },
  {
    "function_name": "run_script_argv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "415-464",
    "snippet": "static int run_script_argv(const char *name, const char *section,\n\t\t\t   const char *script, const char *hook,\n\t\t\t   const char *lxcpath, char **argsin)\n{\n\tint ret, i;\n\tchar *buffer;\n\tsize_t size = 0;\n\n\tINFO(\"Executing script \\\"%s\\\" for container \\\"%s\\\", config section \\\"%s\\\".\",\n\t     script, name, section);\n\n\tfor (i = 0; argsin && argsin[i]; i++)\n\t\tsize += strlen(argsin[i]) + 1;\n\n\tsize += strlen(hook) + 1;\n\n\tsize += strlen(script);\n\tsize += strlen(name);\n\tsize += strlen(section);\n\tsize += 3;\n\n\tif (size > INT_MAX)\n\t\treturn -1;\n\n\tbuffer = alloca(size);\n\tif (!buffer) {\n\t\tERROR(\"Failed to allocate memory.\");\n\t\treturn -1;\n\t}\n\n\tret =\n\t    snprintf(buffer, size, \"%s %s %s %s\", script, name, section, hook);\n\tif (ret < 0 || (size_t)ret >= size) {\n\t\tERROR(\"Script name too long.\");\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; argsin && argsin[i]; i++) {\n\t\tint len = size - ret;\n\t\tint rc;\n\t\trc = snprintf(buffer + ret, len, \" %s\", argsin[i]);\n\t\tif (rc < 0 || rc >= len) {\n\t\t\tERROR(\"Script args too long.\");\n\t\t\treturn -1;\n\t\t}\n\t\tret += rc;\n\t}\n\n\treturn run_buffer(buffer);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "run_buffer",
          "args": [
            "buffer"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "run_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "376-413",
          "snippet": "static int run_buffer(char *buffer)\n{\n\tstruct lxc_popen_FILE *f;\n\tchar *output;\n\tint ret;\n\n\tf = lxc_popen(buffer);\n\tif (!f) {\n\t\tSYSERROR(\"Failed to popen() %s.\", buffer);\n\t\treturn -1;\n\t}\n\n\toutput = malloc(LXC_LOG_BUFFER_SIZE);\n\tif (!output) {\n\t\tERROR(\"Failed to allocate memory for %s.\", buffer);\n\t\tlxc_pclose(f);\n\t\treturn -1;\n\t}\n\n\twhile (fgets(output, LXC_LOG_BUFFER_SIZE, f->f))\n\t\tDEBUG(\"Script %s with output: %s.\", buffer, output);\n\n\tfree(output);\n\n\tret = lxc_pclose(f);\n\tif (ret == -1) {\n\t\tSYSERROR(\"Script exited with error.\");\n\t\treturn -1;\n\t} else if (WIFEXITED(ret) && WEXITSTATUS(ret) != 0) {\n\t\tERROR(\"Script exited with status %d.\", WEXITSTATUS(ret));\n\t\treturn -1;\n\t} else if (WIFSIGNALED(ret)) {\n\t\tERROR(\"Script terminated by signal %d.\", WTERMSIG(ret));\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int run_buffer(char *buffer)\n{\n\tstruct lxc_popen_FILE *f;\n\tchar *output;\n\tint ret;\n\n\tf = lxc_popen(buffer);\n\tif (!f) {\n\t\tSYSERROR(\"Failed to popen() %s.\", buffer);\n\t\treturn -1;\n\t}\n\n\toutput = malloc(LXC_LOG_BUFFER_SIZE);\n\tif (!output) {\n\t\tERROR(\"Failed to allocate memory for %s.\", buffer);\n\t\tlxc_pclose(f);\n\t\treturn -1;\n\t}\n\n\twhile (fgets(output, LXC_LOG_BUFFER_SIZE, f->f))\n\t\tDEBUG(\"Script %s with output: %s.\", buffer, output);\n\n\tfree(output);\n\n\tret = lxc_pclose(f);\n\tif (ret == -1) {\n\t\tSYSERROR(\"Script exited with error.\");\n\t\treturn -1;\n\t} else if (WIFEXITED(ret) && WEXITSTATUS(ret) != 0) {\n\t\tERROR(\"Script exited with status %d.\", WEXITSTATUS(ret));\n\t\treturn -1;\n\t} else if (WIFSIGNALED(ret)) {\n\t\tERROR(\"Script terminated by signal %d.\", WTERMSIG(ret));\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Script args too long.\""
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer + ret",
            "len",
            "\" %s\"",
            "argsin[i]"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Script name too long.\""
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "size",
            "\"%s %s %s %s\"",
            "script",
            "name",
            "section",
            "hook"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to allocate memory.\""
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "size"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "section"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "script"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "hook"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argsin[i]"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Executing script \\\"%s\\\" for container \\\"%s\\\", config section \\\"%s\\\".\"",
            "script",
            "name",
            "section"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int run_script_argv(const char *name, const char *section,\n\t\t\t   const char *script, const char *hook,\n\t\t\t   const char *lxcpath, char **argsin)\n{\n\tint ret, i;\n\tchar *buffer;\n\tsize_t size = 0;\n\n\tINFO(\"Executing script \\\"%s\\\" for container \\\"%s\\\", config section \\\"%s\\\".\",\n\t     script, name, section);\n\n\tfor (i = 0; argsin && argsin[i]; i++)\n\t\tsize += strlen(argsin[i]) + 1;\n\n\tsize += strlen(hook) + 1;\n\n\tsize += strlen(script);\n\tsize += strlen(name);\n\tsize += strlen(section);\n\tsize += 3;\n\n\tif (size > INT_MAX)\n\t\treturn -1;\n\n\tbuffer = alloca(size);\n\tif (!buffer) {\n\t\tERROR(\"Failed to allocate memory.\");\n\t\treturn -1;\n\t}\n\n\tret =\n\t    snprintf(buffer, size, \"%s %s %s %s\", script, name, section, hook);\n\tif (ret < 0 || (size_t)ret >= size) {\n\t\tERROR(\"Script name too long.\");\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; argsin && argsin[i]; i++) {\n\t\tint len = size - ret;\n\t\tint rc;\n\t\trc = snprintf(buffer + ret, len, \" %s\", argsin[i]);\n\t\tif (rc < 0 || rc >= len) {\n\t\t\tERROR(\"Script args too long.\");\n\t\t\treturn -1;\n\t\t}\n\t\tret += rc;\n\t}\n\n\treturn run_buffer(buffer);\n}"
  },
  {
    "function_name": "run_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "376-413",
    "snippet": "static int run_buffer(char *buffer)\n{\n\tstruct lxc_popen_FILE *f;\n\tchar *output;\n\tint ret;\n\n\tf = lxc_popen(buffer);\n\tif (!f) {\n\t\tSYSERROR(\"Failed to popen() %s.\", buffer);\n\t\treturn -1;\n\t}\n\n\toutput = malloc(LXC_LOG_BUFFER_SIZE);\n\tif (!output) {\n\t\tERROR(\"Failed to allocate memory for %s.\", buffer);\n\t\tlxc_pclose(f);\n\t\treturn -1;\n\t}\n\n\twhile (fgets(output, LXC_LOG_BUFFER_SIZE, f->f))\n\t\tDEBUG(\"Script %s with output: %s.\", buffer, output);\n\n\tfree(output);\n\n\tret = lxc_pclose(f);\n\tif (ret == -1) {\n\t\tSYSERROR(\"Script exited with error.\");\n\t\treturn -1;\n\t} else if (WIFEXITED(ret) && WEXITSTATUS(ret) != 0) {\n\t\tERROR(\"Script exited with status %d.\", WEXITSTATUS(ret));\n\t\treturn -1;\n\t} else if (WIFSIGNALED(ret)) {\n\t\tERROR(\"Script terminated by signal %d.\", WTERMSIG(ret));\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Script terminated by signal %d.\"",
            "WTERMSIG(ret)"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WTERMSIG",
          "args": [
            "ret"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFSIGNALED",
          "args": [
            "ret"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Script exited with status %d.\"",
            "WEXITSTATUS(ret)"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "ret"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "ret"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "ret"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Script exited with error.\""
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_pclose",
          "args": [
            "f"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_pclose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "569-599",
          "snippet": "extern int lxc_pclose(struct lxc_popen_FILE *fp)\n{\n\tFILE *f = NULL;\n\tpid_t child_pid = 0;\n\tint wstatus = 0;\n\tpid_t wait_pid;\n\n\tif (fp) {\n\t\tf = fp->f;\n\t\tchild_pid = fp->child_pid;\n\t\t/* free memory (we still need to close file stream) */\n\t\tfree(fp);\n\t\tfp = NULL;\n\t}\n\n\tif (!f || fclose(f)) {\n\t\tERROR(\"fclose failure\");\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\twait_pid = waitpid(child_pid, &wstatus, 0);\n\t} while (wait_pid == -1 && errno == EINTR);\n\n\tif (wait_pid == -1) {\n\t\tERROR(\"waitpid failure\");\n\t\treturn -1;\n\t}\n\n\treturn wstatus;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int lxc_pclose(struct lxc_popen_FILE *fp)\n{\n\tFILE *f = NULL;\n\tpid_t child_pid = 0;\n\tint wstatus = 0;\n\tpid_t wait_pid;\n\n\tif (fp) {\n\t\tf = fp->f;\n\t\tchild_pid = fp->child_pid;\n\t\t/* free memory (we still need to close file stream) */\n\t\tfree(fp);\n\t\tfp = NULL;\n\t}\n\n\tif (!f || fclose(f)) {\n\t\tERROR(\"fclose failure\");\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\twait_pid = waitpid(child_pid, &wstatus, 0);\n\t} while (wait_pid == -1 && errno == EINTR);\n\n\tif (wait_pid == -1) {\n\t\tERROR(\"waitpid failure\");\n\t\treturn -1;\n\t}\n\n\treturn wstatus;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "output"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4619-4628",
          "snippet": "static void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void free_cgroup_settings(struct lxc_list *result)\n{\n\tstruct lxc_list *iterator, *next;\n\n\tlxc_list_for_each_safe(iterator, result, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Script %s with output: %s.\"",
            "buffer",
            "output"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "output",
            "LXC_LOG_BUFFER_SIZE",
            "f->f"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to allocate memory for %s.\"",
            "buffer"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "LXC_LOG_BUFFER_SIZE"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to popen() %s.\"",
            "buffer"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_popen",
          "args": [
            "buffer"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_popen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "469-567",
          "snippet": "extern struct lxc_popen_FILE *lxc_popen(const char *command)\n{\n\tstruct lxc_popen_FILE *fp = NULL;\n\tint parent_end = -1, child_end = -1;\n\tint pipe_fds[2];\n\tpid_t child_pid;\n\n\tint r = pipe2(pipe_fds, O_CLOEXEC);\n\n\tif (r < 0) {\n\t\tERROR(\"pipe2 failure\");\n\t\treturn NULL;\n\t}\n\n\tparent_end = pipe_fds[0];\n\tchild_end = pipe_fds[1];\n\n\tchild_pid = fork();\n\n\tif (child_pid == 0) {\n\t\t/* child */\n\t\tint child_std_end = STDOUT_FILENO;\n\n\t\tif (child_end != child_std_end) {\n\t\t\t/* dup2() doesn't dup close-on-exec flag */\n\t\t\tdup2(child_end, child_std_end);\n\n\t\t\t/* it's safe not to close child_end here\n\t\t\t * as it's marked close-on-exec anyway\n\t\t\t */\n\t\t} else {\n\t\t\t/*\n\t\t\t * The descriptor is already the one we will use.\n\t\t\t * But it must not be marked close-on-exec.\n\t\t\t * Undo the effects.\n\t\t\t */\n\t\t\tif (fcntl(child_end, F_SETFD, 0) != 0) {\n\t\t\t\tSYSERROR(\"Failed to remove FD_CLOEXEC from fd.\");\n\t\t\t\texit(127);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Unblock signals.\n\t\t * This is the main/only reason\n\t\t * why we do our lousy popen() emulation.\n\t\t */\n\t\t{\n\t\t\tsigset_t mask;\n\t\t\tsigfillset(&mask);\n\t\t\tsigprocmask(SIG_UNBLOCK, &mask, NULL);\n\t\t}\n\n\t\texecl(\"/bin/sh\", \"sh\", \"-c\", command, (char *) NULL);\n\t\texit(127);\n\t}\n\n\t/* parent */\n\n\tclose(child_end);\n\tchild_end = -1;\n\n\tif (child_pid < 0) {\n\t\tERROR(\"fork failure\");\n\t\tgoto error;\n\t}\n\n\tfp = calloc(1, sizeof(*fp));\n\tif (!fp) {\n\t\tERROR(\"failed to allocate memory\");\n\t\tgoto error;\n\t}\n\n\tfp->f = fdopen(parent_end, \"r\");\n\tif (!fp->f) {\n\t\tERROR(\"fdopen failure\");\n\t\tgoto error;\n\t}\n\n\tfp->child_pid = child_pid;\n\n\treturn fp;\n\nerror:\n\n\tif (fp) {\n\t\tif (fp->f) {\n\t\t\tfclose(fp->f);\n\t\t\tparent_end = -1; /* so we do not close it second time */\n\t\t}\n\n\t\tfree(fp);\n\t}\n\n\tif (parent_end != -1)\n\t\tclose(parent_end);\n\n\treturn NULL;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern struct lxc_popen_FILE *lxc_popen(const char *command)\n{\n\tstruct lxc_popen_FILE *fp = NULL;\n\tint parent_end = -1, child_end = -1;\n\tint pipe_fds[2];\n\tpid_t child_pid;\n\n\tint r = pipe2(pipe_fds, O_CLOEXEC);\n\n\tif (r < 0) {\n\t\tERROR(\"pipe2 failure\");\n\t\treturn NULL;\n\t}\n\n\tparent_end = pipe_fds[0];\n\tchild_end = pipe_fds[1];\n\n\tchild_pid = fork();\n\n\tif (child_pid == 0) {\n\t\t/* child */\n\t\tint child_std_end = STDOUT_FILENO;\n\n\t\tif (child_end != child_std_end) {\n\t\t\t/* dup2() doesn't dup close-on-exec flag */\n\t\t\tdup2(child_end, child_std_end);\n\n\t\t\t/* it's safe not to close child_end here\n\t\t\t * as it's marked close-on-exec anyway\n\t\t\t */\n\t\t} else {\n\t\t\t/*\n\t\t\t * The descriptor is already the one we will use.\n\t\t\t * But it must not be marked close-on-exec.\n\t\t\t * Undo the effects.\n\t\t\t */\n\t\t\tif (fcntl(child_end, F_SETFD, 0) != 0) {\n\t\t\t\tSYSERROR(\"Failed to remove FD_CLOEXEC from fd.\");\n\t\t\t\texit(127);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Unblock signals.\n\t\t * This is the main/only reason\n\t\t * why we do our lousy popen() emulation.\n\t\t */\n\t\t{\n\t\t\tsigset_t mask;\n\t\t\tsigfillset(&mask);\n\t\t\tsigprocmask(SIG_UNBLOCK, &mask, NULL);\n\t\t}\n\n\t\texecl(\"/bin/sh\", \"sh\", \"-c\", command, (char *) NULL);\n\t\texit(127);\n\t}\n\n\t/* parent */\n\n\tclose(child_end);\n\tchild_end = -1;\n\n\tif (child_pid < 0) {\n\t\tERROR(\"fork failure\");\n\t\tgoto error;\n\t}\n\n\tfp = calloc(1, sizeof(*fp));\n\tif (!fp) {\n\t\tERROR(\"failed to allocate memory\");\n\t\tgoto error;\n\t}\n\n\tfp->f = fdopen(parent_end, \"r\");\n\tif (!fp->f) {\n\t\tERROR(\"fdopen failure\");\n\t\tgoto error;\n\t}\n\n\tfp->child_pid = child_pid;\n\n\treturn fp;\n\nerror:\n\n\tif (fp) {\n\t\tif (fp->f) {\n\t\t\tfclose(fp->f);\n\t\t\tparent_end = -1; /* so we do not close it second time */\n\t\t}\n\n\t\tfree(fp);\n\t}\n\n\tif (parent_end != -1)\n\t\tclose(parent_end);\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int run_buffer(char *buffer)\n{\n\tstruct lxc_popen_FILE *f;\n\tchar *output;\n\tint ret;\n\n\tf = lxc_popen(buffer);\n\tif (!f) {\n\t\tSYSERROR(\"Failed to popen() %s.\", buffer);\n\t\treturn -1;\n\t}\n\n\toutput = malloc(LXC_LOG_BUFFER_SIZE);\n\tif (!output) {\n\t\tERROR(\"Failed to allocate memory for %s.\", buffer);\n\t\tlxc_pclose(f);\n\t\treturn -1;\n\t}\n\n\twhile (fgets(output, LXC_LOG_BUFFER_SIZE, f->f))\n\t\tDEBUG(\"Script %s with output: %s.\", buffer, output);\n\n\tfree(output);\n\n\tret = lxc_pclose(f);\n\tif (ret == -1) {\n\t\tSYSERROR(\"Script exited with error.\");\n\t\treturn -1;\n\t} else if (WIFEXITED(ret) && WEXITSTATUS(ret) != 0) {\n\t\tERROR(\"Script exited with status %d.\", WEXITSTATUS(ret));\n\t\treturn -1;\n\t} else if (WIFSIGNALED(ret)) {\n\t\tERROR(\"Script terminated by signal %d.\", WTERMSIG(ret));\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "memfd_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "185-223",
    "snippet": "static int memfd_create(const char *name, unsigned int flags) {\n\t#ifndef __NR_memfd_create\n\t\t#if defined __i386__\n\t\t\t#define __NR_memfd_create 356\n\t\t#elif defined __x86_64__\n\t\t\t#define __NR_memfd_create 319\n\t\t#elif defined __arm__\n\t\t\t#define __NR_memfd_create 385\n\t\t#elif defined __aarch64__\n\t\t\t#define __NR_memfd_create 279\n\t\t#elif defined __s390__\n\t\t\t#define __NR_memfd_create 350\n\t\t#elif defined __powerpc__\n\t\t\t#define __NR_memfd_create 360\n\t\t#elif defined __sparc__\n\t\t\t#define __NR_memfd_create 348\n\t\t#elif defined __blackfin__\n\t\t\t#define __NR_memfd_create 390\n\t\t#elif defined __ia64__\n\t\t\t#define __NR_memfd_create 1340\n\t\t#elif defined _MIPS_SIM\n\t\t\t#if _MIPS_SIM == _MIPS_SIM_ABI32\n\t\t\t\t#define __NR_memfd_create 4354\n\t\t\t#endif\n\t\t\t#if _MIPS_SIM == _MIPS_SIM_NABI32\n\t\t\t\t#define __NR_memfd_create 6318\n\t\t\t#endif\n\t\t\t#if _MIPS_SIM == _MIPS_SIM_ABI64\n\t\t\t\t#define __NR_memfd_create 5314\n\t\t\t#endif\n\t\t#endif\n\t#endif\n\t#ifdef __NR_memfd_create\n\treturn syscall(__NR_memfd_create, name, flags);\n\t#else\n\terrno = ENOSYS;\n\treturn -1;\n\t#endif\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define __NR_memfd_create 5314",
      "#define __NR_memfd_create 6318",
      "#define __NR_memfd_create 4354",
      "#define __NR_memfd_create 1340",
      "#define __NR_memfd_create 390",
      "#define __NR_memfd_create 348",
      "#define __NR_memfd_create 360",
      "#define __NR_memfd_create 350",
      "#define __NR_memfd_create 279",
      "#define __NR_memfd_create 385",
      "#define __NR_memfd_create 319",
      "#define __NR_memfd_create 356"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "__NR_memfd_create",
            "name",
            "flags"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\n#define __NR_memfd_create 5314\n#define __NR_memfd_create 6318\n#define __NR_memfd_create 4354\n#define __NR_memfd_create 1340\n#define __NR_memfd_create 390\n#define __NR_memfd_create 348\n#define __NR_memfd_create 360\n#define __NR_memfd_create 350\n#define __NR_memfd_create 279\n#define __NR_memfd_create 385\n#define __NR_memfd_create 319\n#define __NR_memfd_create 356\n\nstatic int memfd_create(const char *name, unsigned int flags) {\n\t#ifndef __NR_memfd_create\n\t\t#if defined __i386__\n\t\t\t#define __NR_memfd_create 356\n\t\t#elif defined __x86_64__\n\t\t\t#define __NR_memfd_create 319\n\t\t#elif defined __arm__\n\t\t\t#define __NR_memfd_create 385\n\t\t#elif defined __aarch64__\n\t\t\t#define __NR_memfd_create 279\n\t\t#elif defined __s390__\n\t\t\t#define __NR_memfd_create 350\n\t\t#elif defined __powerpc__\n\t\t\t#define __NR_memfd_create 360\n\t\t#elif defined __sparc__\n\t\t\t#define __NR_memfd_create 348\n\t\t#elif defined __blackfin__\n\t\t\t#define __NR_memfd_create 390\n\t\t#elif defined __ia64__\n\t\t\t#define __NR_memfd_create 1340\n\t\t#elif defined _MIPS_SIM\n\t\t\t#if _MIPS_SIM == _MIPS_SIM_ABI32\n\t\t\t\t#define __NR_memfd_create 4354\n\t\t\t#endif\n\t\t\t#if _MIPS_SIM == _MIPS_SIM_NABI32\n\t\t\t\t#define __NR_memfd_create 6318\n\t\t\t#endif\n\t\t\t#if _MIPS_SIM == _MIPS_SIM_ABI64\n\t\t\t\t#define __NR_memfd_create 5314\n\t\t\t#endif\n\t\t#endif\n\t#endif\n\t#ifdef __NR_memfd_create\n\treturn syscall(__NR_memfd_create, name, flags);\n\t#else\n\terrno = ENOSYS;\n\treturn -1;\n\t#endif\n}"
  },
  {
    "function_name": "sethostname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "155-163",
    "snippet": "static int sethostname(const char * name, size_t len)\n{\n#ifdef __NR_sethostname\n\treturn syscall(__NR_sethostname, name, len);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "__NR_sethostname",
            "name",
            "len"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int sethostname(const char * name, size_t len)\n{\n#ifdef __NR_sethostname\n\treturn syscall(__NR_sethostname, name, len);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}"
  },
  {
    "function_name": "pivot_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
    "lines": "140-148",
    "snippet": "static int pivot_root(const char * new_root, const char * put_old)\n{\n#ifdef __NR_pivot_root\n\treturn syscall(__NR_pivot_root, new_root, put_old);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include <sys/personality.h>",
      "#include <sys/capability.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <linux/memfd.h>",
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include <sys/statvfs.h>",
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include <sys/wait.h>",
      "#include <sys/utsname.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <linux/loop.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "__NR_pivot_root",
            "new_root",
            "put_old"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int pivot_root(const char * new_root, const char * put_old)\n{\n#ifdef __NR_pivot_root\n\treturn syscall(__NR_pivot_root, new_root, put_old);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}"
  }
]