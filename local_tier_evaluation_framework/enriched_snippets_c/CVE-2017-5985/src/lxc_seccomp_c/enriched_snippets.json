[
  {
    "function_name": "lxc_seccomp_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
    "lines": "776-786",
    "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
    "includes": [
      "#include \"lxcseccomp.h\"",
      "#include \"log.h\"",
      "#include \"config.h\"",
      "#include <sys/utsname.h>",
      "#include <sys/mount.h>",
      "#include <seccomp.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seccomp_release",
          "args": [
            "conf->seccomp_ctx"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "conf->seccomp"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
  },
  {
    "function_name": "lxc_read_seccomp_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
    "lines": "707-755",
    "snippet": "int lxc_read_seccomp_config(struct lxc_conf *conf)\n{\n\tFILE *f;\n\tint ret;\n\tint check_seccomp_attr_set;\n\n\tif (!conf->seccomp)\n\t\treturn 0;\n\n\tif (!use_seccomp())\n\t\treturn 0;\n#if HAVE_SCMP_FILTER_CTX\n\t/* XXX for debug, pass in SCMP_ACT_TRAP */\n\tconf->seccomp_ctx = seccomp_init(SCMP_ACT_KILL);\n\tret = !conf->seccomp_ctx;\n#else\n\tret = seccomp_init(SCMP_ACT_KILL) < 0;\n#endif\n\tif (ret) {\n\t\tERROR(\"Failed initializing seccomp.\");\n\t\treturn -1;\n\t}\n\n/* turn off no-new-privs.  We don't want it in lxc, and it breaks\n * with apparmor */\n#if HAVE_SCMP_FILTER_CTX\n\tcheck_seccomp_attr_set = seccomp_attr_set(conf->seccomp_ctx, SCMP_FLTATR_CTL_NNP, 0);\n#else\n\tcheck_seccomp_attr_set = seccomp_attr_set(SCMP_FLTATR_CTL_NNP, 0);\n#endif\n\tif (check_seccomp_attr_set) {\n\t\tERROR(\"Failed to turn off n-new-privs.\");\n\t\treturn -1;\n\t}\n#ifdef SCMP_FLTATR_ATL_TSKIP\n\tif (seccomp_attr_set(conf->seccomp_ctx, SCMP_FLTATR_ATL_TSKIP, 1)) {\n\t\tWARN(\"Failed to turn on seccomp nop-skip, continuing\");\n\t}\n#endif\n\n\tf = fopen(conf->seccomp, \"r\");\n\tif (!f) {\n\t\tSYSERROR(\"Failed to open seccomp policy file %s.\", conf->seccomp);\n\t\treturn -1;\n\t}\n\tret = parse_config(f, conf);\n\tfclose(f);\n\treturn ret;\n}",
    "includes": [
      "#include \"lxcseccomp.h\"",
      "#include \"log.h\"",
      "#include \"config.h\"",
      "#include <sys/utsname.h>",
      "#include <sys/mount.h>",
      "#include <seccomp.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ret;",
      "int ret;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_config",
          "args": [
            "f",
            "conf"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "parse_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "638-665",
          "snippet": "static int parse_config(FILE *f, struct lxc_conf *conf)\n{\n\tchar line[1024];\n\tint ret, version;\n\n\tret = fscanf(f, \"%d\\n\", &version);\n\tif (ret != 1 || (version != 1 && version != 2)) {\n\t\tERROR(\"Invalid version.\");\n\t\treturn -1;\n\t}\n\tif (!fgets(line, 1024, f)) {\n\t\tERROR(\"Invalid config file.\");\n\t\treturn -1;\n\t}\n\tif (version == 1 && !strstr(line, \"whitelist\")) {\n\t\tERROR(\"Only whitelist policy is supported.\");\n\t\treturn -1;\n\t}\n\n\tif (strstr(line, \"debug\")) {\n\t\tERROR(\"Debug not yet implemented.\");\n\t\treturn -1;\n\t}\n\n\tif (version == 1)\n\t\treturn parse_config_v1(f, conf);\n\treturn parse_config_v2(f, line, conf);\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ret;",
            "int ret;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nint ret;\nint ret;\n\nstatic int parse_config(FILE *f, struct lxc_conf *conf)\n{\n\tchar line[1024];\n\tint ret, version;\n\n\tret = fscanf(f, \"%d\\n\", &version);\n\tif (ret != 1 || (version != 1 && version != 2)) {\n\t\tERROR(\"Invalid version.\");\n\t\treturn -1;\n\t}\n\tif (!fgets(line, 1024, f)) {\n\t\tERROR(\"Invalid config file.\");\n\t\treturn -1;\n\t}\n\tif (version == 1 && !strstr(line, \"whitelist\")) {\n\t\tERROR(\"Only whitelist policy is supported.\");\n\t\treturn -1;\n\t}\n\n\tif (strstr(line, \"debug\")) {\n\t\tERROR(\"Debug not yet implemented.\");\n\t\treturn -1;\n\t}\n\n\tif (version == 1)\n\t\treturn parse_config_v1(f, conf);\n\treturn parse_config_v2(f, line, conf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to open seccomp policy file %s.\"",
            "conf->seccomp"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "conf->seccomp",
            "\"r\""
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to turn on seccomp nop-skip, continuing\""
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_attr_set",
          "args": [
            "conf->seccomp_ctx",
            "SCMP_FLTATR_ATL_TSKIP",
            "1"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to turn off n-new-privs.\""
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_attr_set",
          "args": [
            "SCMP_FLTATR_CTL_NNP",
            "0"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_attr_set",
          "args": [
            "conf->seccomp_ctx",
            "SCMP_FLTATR_CTL_NNP",
            "0"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed initializing seccomp.\""
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_init",
          "args": [
            "SCMP_ACT_KILL"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_init",
          "args": [
            "SCMP_ACT_KILL"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "use_seccomp",
          "args": [],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "use_seccomp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "674-705",
          "snippet": "static bool use_seccomp(void)\n{\n\tFILE *f = fopen(\"/proc/self/status\", \"r\");\n\tchar line[1024];\n\tbool already_enabled = false;\n\tbool found = false;\n\tint ret, v;\n\n\tif (!f)\n\t\treturn true;\n\n\twhile (fgets(line, 1024, f)) {\n\t\tif (strncmp(line, \"Seccomp:\", 8) == 0) {\n\t\t\tfound = true;\n\t\t\tret = sscanf(line + 8, \"%d\", &v);\n\t\t\tif (ret == 1 && v != 0)\n\t\t\t\talready_enabled = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfclose(f);\n\tif (!found) { /* no Seccomp line, no seccomp in kernel */\n\t\tINFO(\"Seccomp is not enabled in the kernel.\");\n\t\treturn false;\n\t}\n\tif (already_enabled) { /* already seccomp-confined */\n\t\tINFO(\"Already seccomp-confined, not loading new policy.\");\n\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ret;",
            "int ret;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nint ret;\nint ret;\n\nstatic bool use_seccomp(void)\n{\n\tFILE *f = fopen(\"/proc/self/status\", \"r\");\n\tchar line[1024];\n\tbool already_enabled = false;\n\tbool found = false;\n\tint ret, v;\n\n\tif (!f)\n\t\treturn true;\n\n\twhile (fgets(line, 1024, f)) {\n\t\tif (strncmp(line, \"Seccomp:\", 8) == 0) {\n\t\t\tfound = true;\n\t\t\tret = sscanf(line + 8, \"%d\", &v);\n\t\t\tif (ret == 1 && v != 0)\n\t\t\t\talready_enabled = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfclose(f);\n\tif (!found) { /* no Seccomp line, no seccomp in kernel */\n\t\tINFO(\"Seccomp is not enabled in the kernel.\");\n\t\treturn false;\n\t}\n\tif (already_enabled) { /* already seccomp-confined */\n\t\tINFO(\"Already seccomp-confined, not loading new policy.\");\n\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nint ret;\nint ret;\n\nint lxc_read_seccomp_config(struct lxc_conf *conf)\n{\n\tFILE *f;\n\tint ret;\n\tint check_seccomp_attr_set;\n\n\tif (!conf->seccomp)\n\t\treturn 0;\n\n\tif (!use_seccomp())\n\t\treturn 0;\n#if HAVE_SCMP_FILTER_CTX\n\t/* XXX for debug, pass in SCMP_ACT_TRAP */\n\tconf->seccomp_ctx = seccomp_init(SCMP_ACT_KILL);\n\tret = !conf->seccomp_ctx;\n#else\n\tret = seccomp_init(SCMP_ACT_KILL) < 0;\n#endif\n\tif (ret) {\n\t\tERROR(\"Failed initializing seccomp.\");\n\t\treturn -1;\n\t}\n\n/* turn off no-new-privs.  We don't want it in lxc, and it breaks\n * with apparmor */\n#if HAVE_SCMP_FILTER_CTX\n\tcheck_seccomp_attr_set = seccomp_attr_set(conf->seccomp_ctx, SCMP_FLTATR_CTL_NNP, 0);\n#else\n\tcheck_seccomp_attr_set = seccomp_attr_set(SCMP_FLTATR_CTL_NNP, 0);\n#endif\n\tif (check_seccomp_attr_set) {\n\t\tERROR(\"Failed to turn off n-new-privs.\");\n\t\treturn -1;\n\t}\n#ifdef SCMP_FLTATR_ATL_TSKIP\n\tif (seccomp_attr_set(conf->seccomp_ctx, SCMP_FLTATR_ATL_TSKIP, 1)) {\n\t\tWARN(\"Failed to turn on seccomp nop-skip, continuing\");\n\t}\n#endif\n\n\tf = fopen(conf->seccomp, \"r\");\n\tif (!f) {\n\t\tSYSERROR(\"Failed to open seccomp policy file %s.\", conf->seccomp);\n\t\treturn -1;\n\t}\n\tret = parse_config(f, conf);\n\tfclose(f);\n\treturn ret;\n}"
  },
  {
    "function_name": "use_seccomp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
    "lines": "674-705",
    "snippet": "static bool use_seccomp(void)\n{\n\tFILE *f = fopen(\"/proc/self/status\", \"r\");\n\tchar line[1024];\n\tbool already_enabled = false;\n\tbool found = false;\n\tint ret, v;\n\n\tif (!f)\n\t\treturn true;\n\n\twhile (fgets(line, 1024, f)) {\n\t\tif (strncmp(line, \"Seccomp:\", 8) == 0) {\n\t\t\tfound = true;\n\t\t\tret = sscanf(line + 8, \"%d\", &v);\n\t\t\tif (ret == 1 && v != 0)\n\t\t\t\talready_enabled = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfclose(f);\n\tif (!found) { /* no Seccomp line, no seccomp in kernel */\n\t\tINFO(\"Seccomp is not enabled in the kernel.\");\n\t\treturn false;\n\t}\n\tif (already_enabled) { /* already seccomp-confined */\n\t\tINFO(\"Already seccomp-confined, not loading new policy.\");\n\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"lxcseccomp.h\"",
      "#include \"log.h\"",
      "#include \"config.h\"",
      "#include <sys/utsname.h>",
      "#include <sys/mount.h>",
      "#include <seccomp.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ret;",
      "int ret;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Already seccomp-confined, not loading new policy.\""
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Seccomp is not enabled in the kernel.\""
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "line + 8",
            "\"%d\"",
            "&v"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "line",
            "\"Seccomp:\"",
            "8"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "1024",
            "f"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "\"/proc/self/status\"",
            "\"r\""
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nint ret;\nint ret;\n\nstatic bool use_seccomp(void)\n{\n\tFILE *f = fopen(\"/proc/self/status\", \"r\");\n\tchar line[1024];\n\tbool already_enabled = false;\n\tbool found = false;\n\tint ret, v;\n\n\tif (!f)\n\t\treturn true;\n\n\twhile (fgets(line, 1024, f)) {\n\t\tif (strncmp(line, \"Seccomp:\", 8) == 0) {\n\t\t\tfound = true;\n\t\t\tret = sscanf(line + 8, \"%d\", &v);\n\t\t\tif (ret == 1 && v != 0)\n\t\t\t\talready_enabled = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfclose(f);\n\tif (!found) { /* no Seccomp line, no seccomp in kernel */\n\t\tINFO(\"Seccomp is not enabled in the kernel.\");\n\t\treturn false;\n\t}\n\tif (already_enabled) { /* already seccomp-confined */\n\t\tINFO(\"Already seccomp-confined, not loading new policy.\");\n\t\treturn false;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "parse_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
    "lines": "638-665",
    "snippet": "static int parse_config(FILE *f, struct lxc_conf *conf)\n{\n\tchar line[1024];\n\tint ret, version;\n\n\tret = fscanf(f, \"%d\\n\", &version);\n\tif (ret != 1 || (version != 1 && version != 2)) {\n\t\tERROR(\"Invalid version.\");\n\t\treturn -1;\n\t}\n\tif (!fgets(line, 1024, f)) {\n\t\tERROR(\"Invalid config file.\");\n\t\treturn -1;\n\t}\n\tif (version == 1 && !strstr(line, \"whitelist\")) {\n\t\tERROR(\"Only whitelist policy is supported.\");\n\t\treturn -1;\n\t}\n\n\tif (strstr(line, \"debug\")) {\n\t\tERROR(\"Debug not yet implemented.\");\n\t\treturn -1;\n\t}\n\n\tif (version == 1)\n\t\treturn parse_config_v1(f, conf);\n\treturn parse_config_v2(f, line, conf);\n}",
    "includes": [
      "#include \"lxcseccomp.h\"",
      "#include \"log.h\"",
      "#include \"config.h\"",
      "#include <sys/utsname.h>",
      "#include <sys/mount.h>",
      "#include <seccomp.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ret;",
      "int ret;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "parse_config_v2",
          "args": [
            "f",
            "line",
            "conf"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "parse_config_v2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "624-627",
          "snippet": "static int parse_config_v2(FILE *f, char *line, struct lxc_conf *conf)\n{\n\treturn -1;\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nstatic int parse_config_v2(FILE *f, char *line, struct lxc_conf *conf)\n{\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_config_v1",
          "args": [
            "f",
            "conf"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "parse_config_v1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "38-59",
          "snippet": "static int parse_config_v1(FILE *f, struct lxc_conf *conf)\n{\n\tchar line[1024];\n\tint ret;\n\n\twhile (fgets(line, 1024, f)) {\n\t\tint nr;\n\t\tret = sscanf(line, \"%d\", &nr);\n\t\tif (ret != 1)\n\t\t\treturn -1;\n\t\tret = seccomp_rule_add(\n#if HAVE_SCMP_FILTER_CTX\n\t\t    conf->seccomp_ctx,\n#endif\n\t\t    SCMP_ACT_ALLOW, nr, 0);\n\t\tif (ret < 0) {\n\t\t\tERROR(\"Failed loading allow rule for %d.\", nr);\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ret;",
            "int ret;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nint ret;\nint ret;\n\nstatic int parse_config_v1(FILE *f, struct lxc_conf *conf)\n{\n\tchar line[1024];\n\tint ret;\n\n\twhile (fgets(line, 1024, f)) {\n\t\tint nr;\n\t\tret = sscanf(line, \"%d\", &nr);\n\t\tif (ret != 1)\n\t\t\treturn -1;\n\t\tret = seccomp_rule_add(\n#if HAVE_SCMP_FILTER_CTX\n\t\t    conf->seccomp_ctx,\n#endif\n\t\t    SCMP_ACT_ALLOW, nr, 0);\n\t\tif (ret < 0) {\n\t\t\tERROR(\"Failed loading allow rule for %d.\", nr);\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Debug not yet implemented.\""
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\"debug\""
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Only whitelist policy is supported.\""
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\"whitelist\""
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Invalid config file.\""
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "1024",
            "f"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Invalid version.\""
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "f",
            "\"%d\\n\"",
            "&version"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nint ret;\nint ret;\n\nstatic int parse_config(FILE *f, struct lxc_conf *conf)\n{\n\tchar line[1024];\n\tint ret, version;\n\n\tret = fscanf(f, \"%d\\n\", &version);\n\tif (ret != 1 || (version != 1 && version != 2)) {\n\t\tERROR(\"Invalid version.\");\n\t\treturn -1;\n\t}\n\tif (!fgets(line, 1024, f)) {\n\t\tERROR(\"Invalid config file.\");\n\t\treturn -1;\n\t}\n\tif (version == 1 && !strstr(line, \"whitelist\")) {\n\t\tERROR(\"Only whitelist policy is supported.\");\n\t\treturn -1;\n\t}\n\n\tif (strstr(line, \"debug\")) {\n\t\tERROR(\"Debug not yet implemented.\");\n\t\treturn -1;\n\t}\n\n\tif (version == 1)\n\t\treturn parse_config_v1(f, conf);\n\treturn parse_config_v2(f, line, conf);\n}"
  },
  {
    "function_name": "parse_config_v2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
    "lines": "624-627",
    "snippet": "static int parse_config_v2(FILE *f, char *line, struct lxc_conf *conf)\n{\n\treturn -1;\n}",
    "includes": [
      "#include \"lxcseccomp.h\"",
      "#include \"log.h\"",
      "#include \"config.h\"",
      "#include <sys/utsname.h>",
      "#include <sys/mount.h>",
      "#include <seccomp.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nstatic int parse_config_v2(FILE *f, char *line, struct lxc_conf *conf)\n{\n\treturn -1;\n}"
  },
  {
    "function_name": "do_resolve_add_rule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
    "lines": "245-289",
    "snippet": "bool do_resolve_add_rule(uint32_t arch, char *line, scmp_filter_ctx ctx,\n\t\t\tuint32_t action)\n{\n\tint nr, ret;\n\n\tret = seccomp_arch_exist(ctx, arch);\n\tif (arch && ret != 0) {\n\t\tERROR(\"BUG: Seccomp: rule and context arch do not match (arch \"\n\t\t      \"%d): %s.\",\n\t\t      arch, strerror(-ret));\n\t\treturn false;\n\t}\n\n\tif (strncmp(line, \"reject_force_umount\", 19) == 0) {\n\t\tINFO(\"Setting Seccomp rule to reject force umounts.\");\n\t\tret = seccomp_rule_add_exact(ctx, SCMP_ACT_ERRNO(EACCES), SCMP_SYS(umount2),\n\t\t\t\t1, SCMP_A1(SCMP_CMP_MASKED_EQ , MNT_FORCE , MNT_FORCE ));\n\t\tif (ret < 0) {\n\t\t\tERROR(\"Failed (%d) loading rule to reject force \"\n\t\t\t      \"umount: %s.\",\n\t\t\t      ret, strerror(-ret));\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tnr = seccomp_syscall_resolve_name(line);\n\tif (nr == __NR_SCMP_ERROR) {\n\t\tWARN(\"Seccomp: failed to resolve syscall: %s.\", line);\n\t\tWARN(\"This syscall will NOT be blacklisted.\");\n\t\treturn true;\n\t}\n\tif (nr < 0) {\n\t\tWARN(\"Seccomp: got negative for syscall: %d: %s.\", nr, line);\n\t\tWARN(\"This syscall will NOT be blacklisted.\");\n\t\treturn true;\n\t}\n\tret = seccomp_rule_add_exact(ctx, action, nr, 0);\n\tif (ret < 0) {\n\t\tERROR(\"Failed (%d) loading rule for %s (nr %d action %d): %s.\",\n\t\t      ret, line, nr, action, strerror(-ret));\n\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"lxcseccomp.h\"",
      "#include \"log.h\"",
      "#include \"config.h\"",
      "#include <sys/utsname.h>",
      "#include <sys/mount.h>",
      "#include <seccomp.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ret;",
      "int ret;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed (%d) loading rule for %s (nr %d action %d): %s.\"",
            "ret",
            "line",
            "nr",
            "action",
            "strerror(-ret)"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "-ret"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add_exact",
          "args": [
            "ctx",
            "action",
            "nr",
            "0"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"This syscall will NOT be blacklisted.\""
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Seccomp: got negative for syscall: %d: %s.\"",
            "nr",
            "line"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"This syscall will NOT be blacklisted.\""
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Seccomp: failed to resolve syscall: %s.\"",
            "line"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_syscall_resolve_name",
          "args": [
            "line"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed (%d) loading rule to reject force \"\n\t\t\t      \"umount: %s.\"",
            "ret",
            "strerror(-ret)"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "-ret"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add_exact",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(EACCES)",
            "SCMP_SYS(umount2)",
            "1",
            "SCMP_A1(SCMP_CMP_MASKED_EQ , MNT_FORCE , MNT_FORCE )"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_A1",
          "args": [
            "SCMP_CMP_MASKED_EQ",
            "MNT_FORCE",
            "MNT_FORCE"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "umount2"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "EACCES"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Setting Seccomp rule to reject force umounts.\""
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "line",
            "\"reject_force_umount\"",
            "19"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"BUG: Seccomp: rule and context arch do not match (arch \"\n\t\t      \"%d): %s.\"",
            "arch",
            "strerror(-ret)"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "-ret"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_arch_exist",
          "args": [
            "ctx",
            "arch"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nint ret;\nint ret;\n\nbool do_resolve_add_rule(uint32_t arch, char *line, scmp_filter_ctx ctx,\n\t\t\tuint32_t action)\n{\n\tint nr, ret;\n\n\tret = seccomp_arch_exist(ctx, arch);\n\tif (arch && ret != 0) {\n\t\tERROR(\"BUG: Seccomp: rule and context arch do not match (arch \"\n\t\t      \"%d): %s.\",\n\t\t      arch, strerror(-ret));\n\t\treturn false;\n\t}\n\n\tif (strncmp(line, \"reject_force_umount\", 19) == 0) {\n\t\tINFO(\"Setting Seccomp rule to reject force umounts.\");\n\t\tret = seccomp_rule_add_exact(ctx, SCMP_ACT_ERRNO(EACCES), SCMP_SYS(umount2),\n\t\t\t\t1, SCMP_A1(SCMP_CMP_MASKED_EQ , MNT_FORCE , MNT_FORCE ));\n\t\tif (ret < 0) {\n\t\t\tERROR(\"Failed (%d) loading rule to reject force \"\n\t\t\t      \"umount: %s.\",\n\t\t\t      ret, strerror(-ret));\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tnr = seccomp_syscall_resolve_name(line);\n\tif (nr == __NR_SCMP_ERROR) {\n\t\tWARN(\"Seccomp: failed to resolve syscall: %s.\", line);\n\t\tWARN(\"This syscall will NOT be blacklisted.\");\n\t\treturn true;\n\t}\n\tif (nr < 0) {\n\t\tWARN(\"Seccomp: got negative for syscall: %d: %s.\", nr, line);\n\t\tWARN(\"This syscall will NOT be blacklisted.\");\n\t\treturn true;\n\t}\n\tret = seccomp_rule_add_exact(ctx, action, nr, 0);\n\tif (ret < 0) {\n\t\tERROR(\"Failed (%d) loading rule for %s (nr %d action %d): %s.\",\n\t\t      ret, line, nr, action, strerror(-ret));\n\t\treturn false;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "get_new_ctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
    "lines": "178-243",
    "snippet": "scmp_filter_ctx get_new_ctx(enum lxc_hostarch_t n_arch, uint32_t default_policy_action)\n{\n\tscmp_filter_ctx ctx;\n\tint ret;\n\tuint32_t arch;\n\n\tswitch(n_arch) {\n\tcase lxc_seccomp_arch_i386: arch = SCMP_ARCH_X86; break;\n\tcase lxc_seccomp_arch_x32: arch = SCMP_ARCH_X32; break;\n\tcase lxc_seccomp_arch_amd64: arch = SCMP_ARCH_X86_64; break;\n\tcase lxc_seccomp_arch_arm: arch = SCMP_ARCH_ARM; break;\n#ifdef SCMP_ARCH_AARCH64\n\tcase lxc_seccomp_arch_arm64: arch = SCMP_ARCH_AARCH64; break;\n#endif\n#ifdef SCMP_ARCH_PPC64LE\n\tcase lxc_seccomp_arch_ppc64le: arch = SCMP_ARCH_PPC64LE; break;\n#endif\n#ifdef SCMP_ARCH_PPC64\n\tcase lxc_seccomp_arch_ppc64: arch = SCMP_ARCH_PPC64; break;\n#endif\n#ifdef SCMP_ARCH_PPC\n\tcase lxc_seccomp_arch_ppc: arch = SCMP_ARCH_PPC; break;\n#endif\n#ifdef SCMP_ARCH_MIPS\n\tcase lxc_seccomp_arch_mips: arch = SCMP_ARCH_MIPS; break;\n\tcase lxc_seccomp_arch_mips64: arch = SCMP_ARCH_MIPS64; break;\n\tcase lxc_seccomp_arch_mips64n32: arch = SCMP_ARCH_MIPS64N32; break;\n\tcase lxc_seccomp_arch_mipsel: arch = SCMP_ARCH_MIPSEL; break;\n\tcase lxc_seccomp_arch_mipsel64: arch = SCMP_ARCH_MIPSEL64; break;\n\tcase lxc_seccomp_arch_mipsel64n32: arch = SCMP_ARCH_MIPSEL64N32; break;\n#endif\n#ifdef SCMP_ARCH_S390X\n\tcase lxc_seccomp_arch_s390x: arch = SCMP_ARCH_S390X; break;\n#endif\n\tdefault: return NULL;\n\t}\n\n\tif ((ctx = seccomp_init(default_policy_action)) == NULL) {\n\t\tERROR(\"Error initializing seccomp context.\");\n\t\treturn NULL;\n\t}\n\tif (seccomp_attr_set(ctx, SCMP_FLTATR_CTL_NNP, 0)) {\n\t\tERROR(\"Failed to turn off n-new-privs.\");\n\t\tseccomp_release(ctx);\n\t\treturn NULL;\n\t}\n#ifdef SCMP_FLTATR_ATL_TSKIP\n\tif (seccomp_attr_set(ctx, SCMP_FLTATR_ATL_TSKIP, 1)) {\n\t\tWARN(\"Failed to turn on seccomp nop-skip, continuing\");\n\t}\n#endif\n\tret = seccomp_arch_add(ctx, arch);\n\tif (ret != 0) {\n\t\tERROR(\"Seccomp error %d (%s) adding arch: %d\", ret,\n\t\t      strerror(-ret), (int)n_arch);\n\t\tseccomp_release(ctx);\n\t\treturn NULL;\n\t}\n\tif (seccomp_arch_remove(ctx, SCMP_ARCH_NATIVE) != 0) {\n\t\tERROR(\"Seccomp error removing native arch\");\n\t\tseccomp_release(ctx);\n\t\treturn NULL;\n\t}\n\n\treturn ctx;\n}",
    "includes": [
      "#include \"lxcseccomp.h\"",
      "#include \"log.h\"",
      "#include \"config.h\"",
      "#include <sys/utsname.h>",
      "#include <sys/mount.h>",
      "#include <seccomp.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ret;",
      "uint32_t default_policy_action = -1, default_rule_action = -1, action;",
      "int ret;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seccomp_release",
          "args": [
            "ctx"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Seccomp error removing native arch\""
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_arch_remove",
          "args": [
            "ctx",
            "SCMP_ARCH_NATIVE"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_release",
          "args": [
            "ctx"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Seccomp error %d (%s) adding arch: %d\"",
            "ret",
            "strerror(-ret)",
            "(int)n_arch"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "-ret"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_arch_add",
          "args": [
            "ctx",
            "arch"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to turn on seccomp nop-skip, continuing\""
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_attr_set",
          "args": [
            "ctx",
            "SCMP_FLTATR_ATL_TSKIP",
            "1"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_release",
          "args": [
            "ctx"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to turn off n-new-privs.\""
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_attr_set",
          "args": [
            "ctx",
            "SCMP_FLTATR_CTL_NNP",
            "0"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error initializing seccomp context.\""
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_init",
          "args": [
            "default_policy_action"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nint ret;\nuint32_t default_policy_action = -1, default_rule_action = -1, action;\nint ret;\n\nscmp_filter_ctx get_new_ctx(enum lxc_hostarch_t n_arch, uint32_t default_policy_action)\n{\n\tscmp_filter_ctx ctx;\n\tint ret;\n\tuint32_t arch;\n\n\tswitch(n_arch) {\n\tcase lxc_seccomp_arch_i386: arch = SCMP_ARCH_X86; break;\n\tcase lxc_seccomp_arch_x32: arch = SCMP_ARCH_X32; break;\n\tcase lxc_seccomp_arch_amd64: arch = SCMP_ARCH_X86_64; break;\n\tcase lxc_seccomp_arch_arm: arch = SCMP_ARCH_ARM; break;\n#ifdef SCMP_ARCH_AARCH64\n\tcase lxc_seccomp_arch_arm64: arch = SCMP_ARCH_AARCH64; break;\n#endif\n#ifdef SCMP_ARCH_PPC64LE\n\tcase lxc_seccomp_arch_ppc64le: arch = SCMP_ARCH_PPC64LE; break;\n#endif\n#ifdef SCMP_ARCH_PPC64\n\tcase lxc_seccomp_arch_ppc64: arch = SCMP_ARCH_PPC64; break;\n#endif\n#ifdef SCMP_ARCH_PPC\n\tcase lxc_seccomp_arch_ppc: arch = SCMP_ARCH_PPC; break;\n#endif\n#ifdef SCMP_ARCH_MIPS\n\tcase lxc_seccomp_arch_mips: arch = SCMP_ARCH_MIPS; break;\n\tcase lxc_seccomp_arch_mips64: arch = SCMP_ARCH_MIPS64; break;\n\tcase lxc_seccomp_arch_mips64n32: arch = SCMP_ARCH_MIPS64N32; break;\n\tcase lxc_seccomp_arch_mipsel: arch = SCMP_ARCH_MIPSEL; break;\n\tcase lxc_seccomp_arch_mipsel64: arch = SCMP_ARCH_MIPSEL64; break;\n\tcase lxc_seccomp_arch_mipsel64n32: arch = SCMP_ARCH_MIPSEL64N32; break;\n#endif\n#ifdef SCMP_ARCH_S390X\n\tcase lxc_seccomp_arch_s390x: arch = SCMP_ARCH_S390X; break;\n#endif\n\tdefault: return NULL;\n\t}\n\n\tif ((ctx = seccomp_init(default_policy_action)) == NULL) {\n\t\tERROR(\"Error initializing seccomp context.\");\n\t\treturn NULL;\n\t}\n\tif (seccomp_attr_set(ctx, SCMP_FLTATR_CTL_NNP, 0)) {\n\t\tERROR(\"Failed to turn off n-new-privs.\");\n\t\tseccomp_release(ctx);\n\t\treturn NULL;\n\t}\n#ifdef SCMP_FLTATR_ATL_TSKIP\n\tif (seccomp_attr_set(ctx, SCMP_FLTATR_ATL_TSKIP, 1)) {\n\t\tWARN(\"Failed to turn on seccomp nop-skip, continuing\");\n\t}\n#endif\n\tret = seccomp_arch_add(ctx, arch);\n\tif (ret != 0) {\n\t\tERROR(\"Seccomp error %d (%s) adding arch: %d\", ret,\n\t\t      strerror(-ret), (int)n_arch);\n\t\tseccomp_release(ctx);\n\t\treturn NULL;\n\t}\n\tif (seccomp_arch_remove(ctx, SCMP_ARCH_NATIVE) != 0) {\n\t\tERROR(\"Seccomp error removing native arch\");\n\t\tseccomp_release(ctx);\n\t\treturn NULL;\n\t}\n\n\treturn ctx;\n}"
  },
  {
    "function_name": "get_hostarch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
    "lines": "147-176",
    "snippet": "int get_hostarch(void)\n{\n\tstruct utsname uts;\n\tif (uname(&uts) < 0) {\n\t\tSYSERROR(\"Failed to read host arch.\");\n\t\treturn -1;\n\t}\n\tif (strcmp(uts.machine, \"i686\") == 0)\n\t\treturn lxc_seccomp_arch_i386;\n\t// no x32 kernels\n\telse if (strcmp(uts.machine, \"x86_64\") == 0)\n\t\treturn lxc_seccomp_arch_amd64;\n\telse if (strncmp(uts.machine, \"armv7\", 5) == 0)\n\t\treturn lxc_seccomp_arch_arm;\n\telse if (strncmp(uts.machine, \"aarch64\", 7) == 0)\n\t\treturn lxc_seccomp_arch_arm64;\n\telse if (strncmp(uts.machine, \"ppc64le\", 7) == 0)\n\t\treturn lxc_seccomp_arch_ppc64le;\n\telse if (strncmp(uts.machine, \"ppc64\", 5) == 0)\n\t\treturn lxc_seccomp_arch_ppc64;\n\telse if (strncmp(uts.machine, \"ppc\", 3) == 0)\n\t\treturn lxc_seccomp_arch_ppc;\n\telse if (strncmp(uts.machine, \"mips64\", 6) == 0)\n\t\treturn MIPS_ARCH_N64;\n\telse if (strncmp(uts.machine, \"mips\", 4) == 0)\n\t\treturn MIPS_ARCH_O32;\n\telse if (strncmp(uts.machine, \"s390x\", 5) == 0)\n\t\treturn lxc_seccomp_arch_s390x;\n\treturn lxc_seccomp_arch_unknown;\n}",
    "includes": [
      "#include \"lxcseccomp.h\"",
      "#include \"log.h\"",
      "#include \"config.h\"",
      "#include <sys/utsname.h>",
      "#include <sys/mount.h>",
      "#include <seccomp.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "uts.machine",
            "\"s390x\"",
            "5"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "uts.machine",
            "\"mips\"",
            "4"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "uts.machine",
            "\"mips64\"",
            "6"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "uts.machine",
            "\"ppc\"",
            "3"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "uts.machine",
            "\"ppc64\"",
            "5"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "uts.machine",
            "\"ppc64le\"",
            "7"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "uts.machine",
            "\"aarch64\"",
            "7"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "uts.machine",
            "\"armv7\"",
            "5"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "uts.machine",
            "\"x86_64\""
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "uts.machine",
            "\"i686\""
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to read host arch.\""
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uname",
          "args": [
            "&uts"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nint get_hostarch(void)\n{\n\tstruct utsname uts;\n\tif (uname(&uts) < 0) {\n\t\tSYSERROR(\"Failed to read host arch.\");\n\t\treturn -1;\n\t}\n\tif (strcmp(uts.machine, \"i686\") == 0)\n\t\treturn lxc_seccomp_arch_i386;\n\t// no x32 kernels\n\telse if (strcmp(uts.machine, \"x86_64\") == 0)\n\t\treturn lxc_seccomp_arch_amd64;\n\telse if (strncmp(uts.machine, \"armv7\", 5) == 0)\n\t\treturn lxc_seccomp_arch_arm;\n\telse if (strncmp(uts.machine, \"aarch64\", 7) == 0)\n\t\treturn lxc_seccomp_arch_arm64;\n\telse if (strncmp(uts.machine, \"ppc64le\", 7) == 0)\n\t\treturn lxc_seccomp_arch_ppc64le;\n\telse if (strncmp(uts.machine, \"ppc64\", 5) == 0)\n\t\treturn lxc_seccomp_arch_ppc64;\n\telse if (strncmp(uts.machine, \"ppc\", 3) == 0)\n\t\treturn lxc_seccomp_arch_ppc;\n\telse if (strncmp(uts.machine, \"mips64\", 6) == 0)\n\t\treturn MIPS_ARCH_N64;\n\telse if (strncmp(uts.machine, \"mips\", 4) == 0)\n\t\treturn MIPS_ARCH_O32;\n\telse if (strncmp(uts.machine, \"s390x\", 5) == 0)\n\t\treturn lxc_seccomp_arch_s390x;\n\treturn lxc_seccomp_arch_unknown;\n}"
  },
  {
    "function_name": "get_and_clear_v2_action",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
    "lines": "95-114",
    "snippet": "static uint32_t get_and_clear_v2_action(char *line, uint32_t def_action)\n{\n\tchar *p = strchr(line, ' ');\n\tuint32_t ret;\n\n\tif (!p)\n\t\treturn def_action;\n\t*p = '\\0';\n\tp++;\n\twhile (*p == ' ')\n\t\tp++;\n\tif (!*p || *p == '#')\n\t\treturn def_action;\n\tret = get_v2_default_action(p);\n\tswitch(ret) {\n\tcase -2: return -1;\n\tcase -1: return def_action;\n\tdefault: return ret;\n\t}\n}",
    "includes": [
      "#include \"lxcseccomp.h\"",
      "#include \"log.h\"",
      "#include \"config.h\"",
      "#include <sys/utsname.h>",
      "#include <sys/mount.h>",
      "#include <seccomp.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "char *p;",
      "int ret;",
      "int ret;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_v2_default_action",
          "args": [
            "p"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "get_v2_default_action",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "72-93",
          "snippet": "static uint32_t get_v2_default_action(char *line)\n{\n\tuint32_t ret_action = -1;\n\n\twhile (*line == ' ')\n\t\tline++;\n\t// after 'whitelist' or 'blacklist' comes default behavior\n\tif (strncmp(line, \"kill\", 4) == 0)\n\t\tret_action = SCMP_ACT_KILL;\n\telse if (strncmp(line, \"errno\", 5) == 0) {\n\t\tint e;\n\t\tif (sscanf(line + 5, \"%d\", &e) != 1) {\n\t\t\tERROR(\"Bad errno value in %s.\", line);\n\t\t\treturn -2;\n\t\t}\n\t\tret_action = SCMP_ACT_ERRNO(e);\n\t} else if (strncmp(line, \"allow\", 5) == 0)\n\t\tret_action = SCMP_ACT_ALLOW;\n\telse if (strncmp(line, \"trap\", 4) == 0)\n\t\tret_action = SCMP_ACT_TRAP;\n\treturn ret_action;\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool blacklist = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nbool blacklist = false;\n\nstatic uint32_t get_v2_default_action(char *line)\n{\n\tuint32_t ret_action = -1;\n\n\twhile (*line == ' ')\n\t\tline++;\n\t// after 'whitelist' or 'blacklist' comes default behavior\n\tif (strncmp(line, \"kill\", 4) == 0)\n\t\tret_action = SCMP_ACT_KILL;\n\telse if (strncmp(line, \"errno\", 5) == 0) {\n\t\tint e;\n\t\tif (sscanf(line + 5, \"%d\", &e) != 1) {\n\t\t\tERROR(\"Bad errno value in %s.\", line);\n\t\t\treturn -2;\n\t\t}\n\t\tret_action = SCMP_ACT_ERRNO(e);\n\t} else if (strncmp(line, \"allow\", 5) == 0)\n\t\tret_action = SCMP_ACT_ALLOW;\n\telse if (strncmp(line, \"trap\", 4) == 0)\n\t\tret_action = SCMP_ACT_TRAP;\n\treturn ret_action;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "line",
            "' '"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nchar *p;\nint ret;\nint ret;\n\nstatic uint32_t get_and_clear_v2_action(char *line, uint32_t def_action)\n{\n\tchar *p = strchr(line, ' ');\n\tuint32_t ret;\n\n\tif (!p)\n\t\treturn def_action;\n\t*p = '\\0';\n\tp++;\n\twhile (*p == ' ')\n\t\tp++;\n\tif (!*p || *p == '#')\n\t\treturn def_action;\n\tret = get_v2_default_action(p);\n\tswitch(ret) {\n\tcase -2: return -1;\n\tcase -1: return def_action;\n\tdefault: return ret;\n\t}\n}"
  },
  {
    "function_name": "get_v2_default_action",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
    "lines": "72-93",
    "snippet": "static uint32_t get_v2_default_action(char *line)\n{\n\tuint32_t ret_action = -1;\n\n\twhile (*line == ' ')\n\t\tline++;\n\t// after 'whitelist' or 'blacklist' comes default behavior\n\tif (strncmp(line, \"kill\", 4) == 0)\n\t\tret_action = SCMP_ACT_KILL;\n\telse if (strncmp(line, \"errno\", 5) == 0) {\n\t\tint e;\n\t\tif (sscanf(line + 5, \"%d\", &e) != 1) {\n\t\t\tERROR(\"Bad errno value in %s.\", line);\n\t\t\treturn -2;\n\t\t}\n\t\tret_action = SCMP_ACT_ERRNO(e);\n\t} else if (strncmp(line, \"allow\", 5) == 0)\n\t\tret_action = SCMP_ACT_ALLOW;\n\telse if (strncmp(line, \"trap\", 4) == 0)\n\t\tret_action = SCMP_ACT_TRAP;\n\treturn ret_action;\n}",
    "includes": [
      "#include \"lxcseccomp.h\"",
      "#include \"log.h\"",
      "#include \"config.h\"",
      "#include <sys/utsname.h>",
      "#include <sys/mount.h>",
      "#include <seccomp.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "bool blacklist = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "line",
            "\"trap\"",
            "4"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "line",
            "\"allow\"",
            "5"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "e"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Bad errno value in %s.\"",
            "line"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "line + 5",
            "\"%d\"",
            "&e"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "line",
            "\"errno\"",
            "5"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "line",
            "\"kill\"",
            "4"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nbool blacklist = false;\n\nstatic uint32_t get_v2_default_action(char *line)\n{\n\tuint32_t ret_action = -1;\n\n\twhile (*line == ' ')\n\t\tline++;\n\t// after 'whitelist' or 'blacklist' comes default behavior\n\tif (strncmp(line, \"kill\", 4) == 0)\n\t\tret_action = SCMP_ACT_KILL;\n\telse if (strncmp(line, \"errno\", 5) == 0) {\n\t\tint e;\n\t\tif (sscanf(line + 5, \"%d\", &e) != 1) {\n\t\t\tERROR(\"Bad errno value in %s.\", line);\n\t\t\treturn -2;\n\t\t}\n\t\tret_action = SCMP_ACT_ERRNO(e);\n\t} else if (strncmp(line, \"allow\", 5) == 0)\n\t\tret_action = SCMP_ACT_ALLOW;\n\telse if (strncmp(line, \"trap\", 4) == 0)\n\t\tret_action = SCMP_ACT_TRAP;\n\treturn ret_action;\n}"
  },
  {
    "function_name": "remove_trailing_newlines",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
    "lines": "62-70",
    "snippet": "static void remove_trailing_newlines(char *l)\n{\n\tchar *p = l;\n\n\twhile (*p)\n\t\tp++;\n\twhile (--p >= l && *p == '\\n')\n\t\t*p = '\\0';\n}",
    "includes": [
      "#include \"lxcseccomp.h\"",
      "#include \"log.h\"",
      "#include \"config.h\"",
      "#include <sys/utsname.h>",
      "#include <sys/mount.h>",
      "#include <seccomp.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "char *p;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nchar *p;\n\nstatic void remove_trailing_newlines(char *l)\n{\n\tchar *p = l;\n\n\twhile (*p)\n\t\tp++;\n\twhile (--p >= l && *p == '\\n')\n\t\t*p = '\\0';\n}"
  },
  {
    "function_name": "parse_config_v1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
    "lines": "38-59",
    "snippet": "static int parse_config_v1(FILE *f, struct lxc_conf *conf)\n{\n\tchar line[1024];\n\tint ret;\n\n\twhile (fgets(line, 1024, f)) {\n\t\tint nr;\n\t\tret = sscanf(line, \"%d\", &nr);\n\t\tif (ret != 1)\n\t\t\treturn -1;\n\t\tret = seccomp_rule_add(\n#if HAVE_SCMP_FILTER_CTX\n\t\t    conf->seccomp_ctx,\n#endif\n\t\t    SCMP_ACT_ALLOW, nr, 0);\n\t\tif (ret < 0) {\n\t\t\tERROR(\"Failed loading allow rule for %d.\", nr);\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"lxcseccomp.h\"",
      "#include \"log.h\"",
      "#include \"config.h\"",
      "#include <sys/utsname.h>",
      "#include <sys/mount.h>",
      "#include <seccomp.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ret;",
      "int ret;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed loading allow rule for %d.\"",
            "nr"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "line",
            "\"%d\"",
            "&nr"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "1024",
            "f"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nint ret;\nint ret;\n\nstatic int parse_config_v1(FILE *f, struct lxc_conf *conf)\n{\n\tchar line[1024];\n\tint ret;\n\n\twhile (fgets(line, 1024, f)) {\n\t\tint nr;\n\t\tret = sscanf(line, \"%d\", &nr);\n\t\tif (ret != 1)\n\t\t\treturn -1;\n\t\tret = seccomp_rule_add(\n#if HAVE_SCMP_FILTER_CTX\n\t\t    conf->seccomp_ctx,\n#endif\n\t\t    SCMP_ACT_ALLOW, nr, 0);\n\t\tif (ret < 0) {\n\t\t\tERROR(\"Failed loading allow rule for %d.\", nr);\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}"
  }
]