[
  {
    "function_name": "do_destroy_container",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
    "lines": "1540-1547",
    "snippet": "static bool do_destroy_container(struct lxc_conf *conf) {\n\tif (am_unpriv()) {\n\t\tif (userns_exec_1(conf, bdev_destroy_wrapper, conf) < 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\treturn bdev_destroy(conf);\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <sys/reboot.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"sync.h\"",
      "#include \"start.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"lxcutmp.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"console.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/capability.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <alloca.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_destroy_container(struct lxc_conf *conf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdev_destroy",
          "args": [
            "conf"
          ],
          "line": 1546
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_destroy_wrapper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "513-531",
          "snippet": "int bdev_destroy_wrapper(void *data)\n{\n\tstruct lxc_conf *conf = data;\n\n\tif (setgid(0) < 0) {\n\t\tERROR(\"Failed to setgid to 0\");\n\t\treturn -1;\n\t}\n\tif (setgroups(0, NULL) < 0)\n\t\tWARN(\"Failed to clear groups\");\n\tif (setuid(0) < 0) {\n\t\tERROR(\"Failed to setuid to 0\");\n\t\treturn -1;\n\t}\n\tif (!bdev_destroy(conf))\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int find_fstype_cb(char *buffer, void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic int find_fstype_cb(char *buffer, void *data);\n\nint bdev_destroy_wrapper(void *data)\n{\n\tstruct lxc_conf *conf = data;\n\n\tif (setgid(0) < 0) {\n\t\tERROR(\"Failed to setgid to 0\");\n\t\treturn -1;\n\t}\n\tif (setgroups(0, NULL) < 0)\n\t\tWARN(\"Failed to clear groups\");\n\tif (setuid(0) < 0) {\n\t\tERROR(\"Failed to setuid to 0\");\n\t\treturn -1;\n\t}\n\tif (!bdev_destroy(conf))\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "userns_exec_1",
          "args": [
            "conf",
            "bdev_destroy_wrapper",
            "conf"
          ],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "userns_exec_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4435-4487",
          "snippet": "int userns_exec_1(struct lxc_conf *conf, int (*fn)(void *), void *data)\n{\n\tint ret, pid;\n\tstruct userns_fn_data d;\n\tchar c = '1';\n\tint p[2];\n\tstruct lxc_list *idmap;\n\n\tret = pipe(p);\n\tif (ret < 0) {\n\t\tSYSERROR(\"opening pipe\");\n\t\treturn -1;\n\t}\n\td.fn = fn;\n\td.arg = data;\n\td.p[0] = p[0];\n\td.p[1] = p[1];\n\tpid = lxc_clone(run_userns_fn, &d, CLONE_NEWUSER);\n\tif (pid < 0)\n\t\tgoto err;\n\tclose(p[0]);\n\tp[0] = -1;\n\n\tif ((idmap = idmap_add_id(conf, geteuid(), getegid())) == NULL) {\n\t\tERROR(\"Error adding self to container uid/gid map\");\n\t\tgoto err;\n\t}\n\n\tret = lxc_map_ids(idmap, pid);\n\tlxc_free_idmap(idmap);\n\tfree(idmap);\n\tif (ret) {\n\t\tERROR(\"Error setting up child mappings\");\n\t\tgoto err;\n\t}\n\n\t// kick the child\n\tif (write(p[1], &c, 1) != 1) {\n\t\tSYSERROR(\"writing to pipe to child\");\n\t\tgoto err;\n\t}\n\n\tret = wait_for_pid(pid);\n\n\tclose(p[1]);\n\treturn ret;\n\nerr:\n\tif (p[0] != -1)\n\t\tclose(p[0]);\n\tclose(p[1]);\n\treturn -1;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint userns_exec_1(struct lxc_conf *conf, int (*fn)(void *), void *data)\n{\n\tint ret, pid;\n\tstruct userns_fn_data d;\n\tchar c = '1';\n\tint p[2];\n\tstruct lxc_list *idmap;\n\n\tret = pipe(p);\n\tif (ret < 0) {\n\t\tSYSERROR(\"opening pipe\");\n\t\treturn -1;\n\t}\n\td.fn = fn;\n\td.arg = data;\n\td.p[0] = p[0];\n\td.p[1] = p[1];\n\tpid = lxc_clone(run_userns_fn, &d, CLONE_NEWUSER);\n\tif (pid < 0)\n\t\tgoto err;\n\tclose(p[0]);\n\tp[0] = -1;\n\n\tif ((idmap = idmap_add_id(conf, geteuid(), getegid())) == NULL) {\n\t\tERROR(\"Error adding self to container uid/gid map\");\n\t\tgoto err;\n\t}\n\n\tret = lxc_map_ids(idmap, pid);\n\tlxc_free_idmap(idmap);\n\tfree(idmap);\n\tif (ret) {\n\t\tERROR(\"Error setting up child mappings\");\n\t\tgoto err;\n\t}\n\n\t// kick the child\n\tif (write(p[1], &c, 1) != 1) {\n\t\tSYSERROR(\"writing to pipe to child\");\n\t\tgoto err;\n\t}\n\n\tret = wait_for_pid(pid);\n\n\tclose(p[1]);\n\treturn ret;\n\nerr:\n\tif (p[0] != -1)\n\t\tclose(p[0]);\n\tclose(p[1]);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "am_unpriv",
          "args": [],
          "line": 1541
        },
        "resolved": true,
        "details": {
          "function_name": "am_unpriv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.h",
          "lines": "288-290",
          "snippet": "inline static bool am_unpriv(void) {\n\treturn geteuid() != 0;\n}",
          "includes": [
            "#include <stdint.h>",
            "#  include <sys/signalfd.h>",
            "#include <../include/getline.h>",
            "#include \"initutils.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#  include <sys/signalfd.h>\n#include <../include/getline.h>\n#include \"initutils.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"config.h\"\n\ninline static bool am_unpriv(void) {\n\treturn geteuid() != 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic bool do_destroy_container(struct lxc_conf *conf);\n\nstatic bool do_destroy_container(struct lxc_conf *conf) {\n\tif (am_unpriv()) {\n\t\tif (userns_exec_1(conf, bdev_destroy_wrapper, conf) < 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\treturn bdev_destroy(conf);\n}"
  },
  {
    "function_name": "lxc_rmdir_onedev_wrapper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
    "lines": "1534-1538",
    "snippet": "static int lxc_rmdir_onedev_wrapper(void *data)\n{\n\tchar *arg = (char *) data;\n\treturn lxc_rmdir_onedev(arg, NULL);\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <sys/reboot.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"sync.h\"",
      "#include \"start.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"lxcutmp.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"console.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/capability.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <alloca.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int lxc_rmdir_onedev_wrapper(void *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_rmdir_onedev",
          "args": [
            "arg",
            "NULL"
          ],
          "line": 1537
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_rmdir_onedev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "203-220",
          "snippet": "extern int lxc_rmdir_onedev(char *path, const char *exclude)\n{\n\tstruct stat mystat;\n\tbool onedev = true;\n\n\tif (is_native_overlayfs(path)) {\n\t\tonedev = false;\n\t}\n\n\tif (lstat(path, &mystat) < 0) {\n\t\tif (errno == ENOENT)\n\t\t\treturn 0;\n\t\tERROR(\"%s: failed to stat %s\", __func__, path);\n\t\treturn -1;\n\t}\n\n\treturn _recursive_rmdir(path, mystat.st_dev, exclude, 0, onedev);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool btrfs_try_remove_subvol(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nextern int lxc_rmdir_onedev(char *path, const char *exclude)\n{\n\tstruct stat mystat;\n\tbool onedev = true;\n\n\tif (is_native_overlayfs(path)) {\n\t\tonedev = false;\n\t}\n\n\tif (lstat(path, &mystat) < 0) {\n\t\tif (errno == ENOENT)\n\t\t\treturn 0;\n\t\tERROR(\"%s: failed to stat %s\", __func__, path);\n\t\treturn -1;\n\t}\n\n\treturn _recursive_rmdir(path, mystat.st_dev, exclude, 0, onedev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic int lxc_rmdir_onedev_wrapper(void *data);\n\nstatic int lxc_rmdir_onedev_wrapper(void *data)\n{\n\tchar *arg = (char *) data;\n\treturn lxc_rmdir_onedev(arg, NULL);\n}"
  },
  {
    "function_name": "lxc_destroy_container_on_signal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
    "lines": "1488-1532",
    "snippet": "static void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name)\n{\n\tchar destroy[MAXPATHLEN];\n\tbool bret = true;\n\tint ret = 0;\n\tstruct lxc_container *c;\n\tif (handler->conf->rootfs.path && handler->conf->rootfs.mount) {\n\t\tbret = do_destroy_container(handler->conf);\n\t\tif (!bret) {\n\t\t\tERROR(\"Error destroying rootfs for container \\\"%s\\\".\", name);\n\t\t\treturn;\n\t\t}\n\t}\n\tINFO(\"Destroyed rootfs for container \\\"%s\\\".\", name);\n\n\tret = snprintf(destroy, MAXPATHLEN, \"%s/%s\", handler->lxcpath, name);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tERROR(\"Error destroying directory for container \\\"%s\\\".\", name);\n\t\treturn;\n\t}\n\n\tc = lxc_container_new(name, handler->lxcpath);\n\tif (c) {\n\t\tif (container_disk_lock(c)) {\n\t\t\tINFO(\"Could not update lxc_snapshots file.\");\n\t\t\tlxc_container_put(c);\n\t\t} else {\n\t\t\tmod_all_rdeps(c, false);\n\t\t\tcontainer_disk_unlock(c);\n\t\t\tlxc_container_put(c);\n\t\t}\n\t}\n\n\tif (am_unpriv())\n\t\tret = userns_exec_1(handler->conf, lxc_rmdir_onedev_wrapper, destroy);\n\telse\n\t\tret = lxc_rmdir_onedev(destroy, NULL);\n\n\tif (ret < 0) {\n\t\tERROR(\"Error destroying directory for container \\\"%s\\\".\", name);\n\t\treturn;\n\t}\n\tINFO(\"Destroyed directory for container \\\"%s\\\".\", name);\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <sys/reboot.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"sync.h\"",
      "#include \"start.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"lxcutmp.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"console.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/capability.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <alloca.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_destroy_container(struct lxc_conf *conf);",
      "static void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Destroyed directory for container \\\"%s\\\".\"",
            "name"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error destroying directory for container \\\"%s\\\".\"",
            "name"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_rmdir_onedev",
          "args": [
            "destroy",
            "NULL"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_rmdir_onedev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "203-220",
          "snippet": "extern int lxc_rmdir_onedev(char *path, const char *exclude)\n{\n\tstruct stat mystat;\n\tbool onedev = true;\n\n\tif (is_native_overlayfs(path)) {\n\t\tonedev = false;\n\t}\n\n\tif (lstat(path, &mystat) < 0) {\n\t\tif (errno == ENOENT)\n\t\t\treturn 0;\n\t\tERROR(\"%s: failed to stat %s\", __func__, path);\n\t\treturn -1;\n\t}\n\n\treturn _recursive_rmdir(path, mystat.st_dev, exclude, 0, onedev);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool btrfs_try_remove_subvol(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nextern int lxc_rmdir_onedev(char *path, const char *exclude)\n{\n\tstruct stat mystat;\n\tbool onedev = true;\n\n\tif (is_native_overlayfs(path)) {\n\t\tonedev = false;\n\t}\n\n\tif (lstat(path, &mystat) < 0) {\n\t\tif (errno == ENOENT)\n\t\t\treturn 0;\n\t\tERROR(\"%s: failed to stat %s\", __func__, path);\n\t\treturn -1;\n\t}\n\n\treturn _recursive_rmdir(path, mystat.st_dev, exclude, 0, onedev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "userns_exec_1",
          "args": [
            "handler->conf",
            "lxc_rmdir_onedev_wrapper",
            "destroy"
          ],
          "line": 1523
        },
        "resolved": true,
        "details": {
          "function_name": "userns_exec_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4435-4487",
          "snippet": "int userns_exec_1(struct lxc_conf *conf, int (*fn)(void *), void *data)\n{\n\tint ret, pid;\n\tstruct userns_fn_data d;\n\tchar c = '1';\n\tint p[2];\n\tstruct lxc_list *idmap;\n\n\tret = pipe(p);\n\tif (ret < 0) {\n\t\tSYSERROR(\"opening pipe\");\n\t\treturn -1;\n\t}\n\td.fn = fn;\n\td.arg = data;\n\td.p[0] = p[0];\n\td.p[1] = p[1];\n\tpid = lxc_clone(run_userns_fn, &d, CLONE_NEWUSER);\n\tif (pid < 0)\n\t\tgoto err;\n\tclose(p[0]);\n\tp[0] = -1;\n\n\tif ((idmap = idmap_add_id(conf, geteuid(), getegid())) == NULL) {\n\t\tERROR(\"Error adding self to container uid/gid map\");\n\t\tgoto err;\n\t}\n\n\tret = lxc_map_ids(idmap, pid);\n\tlxc_free_idmap(idmap);\n\tfree(idmap);\n\tif (ret) {\n\t\tERROR(\"Error setting up child mappings\");\n\t\tgoto err;\n\t}\n\n\t// kick the child\n\tif (write(p[1], &c, 1) != 1) {\n\t\tSYSERROR(\"writing to pipe to child\");\n\t\tgoto err;\n\t}\n\n\tret = wait_for_pid(pid);\n\n\tclose(p[1]);\n\treturn ret;\n\nerr:\n\tif (p[0] != -1)\n\t\tclose(p[0]);\n\tclose(p[1]);\n\treturn -1;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint userns_exec_1(struct lxc_conf *conf, int (*fn)(void *), void *data)\n{\n\tint ret, pid;\n\tstruct userns_fn_data d;\n\tchar c = '1';\n\tint p[2];\n\tstruct lxc_list *idmap;\n\n\tret = pipe(p);\n\tif (ret < 0) {\n\t\tSYSERROR(\"opening pipe\");\n\t\treturn -1;\n\t}\n\td.fn = fn;\n\td.arg = data;\n\td.p[0] = p[0];\n\td.p[1] = p[1];\n\tpid = lxc_clone(run_userns_fn, &d, CLONE_NEWUSER);\n\tif (pid < 0)\n\t\tgoto err;\n\tclose(p[0]);\n\tp[0] = -1;\n\n\tif ((idmap = idmap_add_id(conf, geteuid(), getegid())) == NULL) {\n\t\tERROR(\"Error adding self to container uid/gid map\");\n\t\tgoto err;\n\t}\n\n\tret = lxc_map_ids(idmap, pid);\n\tlxc_free_idmap(idmap);\n\tfree(idmap);\n\tif (ret) {\n\t\tERROR(\"Error setting up child mappings\");\n\t\tgoto err;\n\t}\n\n\t// kick the child\n\tif (write(p[1], &c, 1) != 1) {\n\t\tSYSERROR(\"writing to pipe to child\");\n\t\tgoto err;\n\t}\n\n\tret = wait_for_pid(pid);\n\n\tclose(p[1]);\n\treturn ret;\n\nerr:\n\tif (p[0] != -1)\n\t\tclose(p[0]);\n\tclose(p[1]);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "am_unpriv",
          "args": [],
          "line": 1522
        },
        "resolved": true,
        "details": {
          "function_name": "am_unpriv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.h",
          "lines": "288-290",
          "snippet": "inline static bool am_unpriv(void) {\n\treturn geteuid() != 0;\n}",
          "includes": [
            "#include <stdint.h>",
            "#  include <sys/signalfd.h>",
            "#include <../include/getline.h>",
            "#include \"initutils.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#  include <sys/signalfd.h>\n#include <../include/getline.h>\n#include \"initutils.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"config.h\"\n\ninline static bool am_unpriv(void) {\n\treturn geteuid() != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_container_put",
          "args": [
            "c"
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "312-325",
          "snippet": "int lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_disk_unlock",
          "args": [
            "c"
          ],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "container_disk_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "365-369",
          "snippet": "void container_disk_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->slock);\n\tlxcunlock(c->privlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nvoid container_disk_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->slock);\n\tlxcunlock(c->privlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mod_all_rdeps",
          "args": [
            "c",
            "false"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "mod_all_rdeps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2223-2261",
          "snippet": "void mod_all_rdeps(struct lxc_container *c, bool inc)\n{\n\tstruct lxc_container *p;\n\tchar *lxcpath = NULL, *lxcname = NULL, path[MAXPATHLEN];\n\tsize_t pathlen = 0, namelen = 0;\n\tFILE *f;\n\tint ret;\n\n\tret = snprintf(path, MAXPATHLEN, \"%s/%s/lxc_rdepends\",\n\t\tc->config_path, c->name);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tERROR(\"Path name too long\");\n\t\treturn;\n\t}\n\tf = fopen(path, \"r\");\n\tif (f == NULL)\n\t\treturn;\n\twhile (getline(&lxcpath, &pathlen, f) != -1) {\n\t\tif (getline(&lxcname, &namelen, f) == -1) {\n\t\t\tERROR(\"badly formatted file %s\", path);\n\t\t\tgoto out;\n\t\t}\n\t\tstrip_newline(lxcpath);\n\t\tstrip_newline(lxcname);\n\t\tif ((p = lxc_container_new(lxcname, lxcpath)) == NULL) {\n\t\t\tERROR(\"Unable to find dependent container %s:%s\",\n\t\t\t\tlxcpath, lxcname);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!mod_rdep(p, c, inc))\n\t\t\tERROR(\"Failed to update snapshots file for %s:%s\",\n\t\t\t\tlxcpath, lxcname);\n\t\tlxc_container_put(p);\n\t}\nout:\n\tfree(lxcpath);\n\tfree(lxcname);\n\tfclose(f);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nvoid mod_all_rdeps(struct lxc_container *c, bool inc)\n{\n\tstruct lxc_container *p;\n\tchar *lxcpath = NULL, *lxcname = NULL, path[MAXPATHLEN];\n\tsize_t pathlen = 0, namelen = 0;\n\tFILE *f;\n\tint ret;\n\n\tret = snprintf(path, MAXPATHLEN, \"%s/%s/lxc_rdepends\",\n\t\tc->config_path, c->name);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tERROR(\"Path name too long\");\n\t\treturn;\n\t}\n\tf = fopen(path, \"r\");\n\tif (f == NULL)\n\t\treturn;\n\twhile (getline(&lxcpath, &pathlen, f) != -1) {\n\t\tif (getline(&lxcname, &namelen, f) == -1) {\n\t\t\tERROR(\"badly formatted file %s\", path);\n\t\t\tgoto out;\n\t\t}\n\t\tstrip_newline(lxcpath);\n\t\tstrip_newline(lxcname);\n\t\tif ((p = lxc_container_new(lxcname, lxcpath)) == NULL) {\n\t\t\tERROR(\"Unable to find dependent container %s:%s\",\n\t\t\t\tlxcpath, lxcname);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!mod_rdep(p, c, inc))\n\t\t\tERROR(\"Failed to update snapshots file for %s:%s\",\n\t\t\t\tlxcpath, lxcname);\n\t\tlxc_container_put(p);\n\t}\nout:\n\tfree(lxcpath);\n\tfree(lxcname);\n\tfclose(f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Could not update lxc_snapshots file.\""
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_disk_lock",
          "args": [
            "c"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "container_disk_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "352-363",
          "snippet": "int container_disk_lock(struct lxc_container *c)\n{\n\tint ret;\n\n\tif ((ret = lxclock(c->privlock, 0)))\n\t\treturn ret;\n\tif ((ret = lxclock(c->slock, 0))) {\n\t\tlxcunlock(c->privlock);\n\t\treturn ret;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nint container_disk_lock(struct lxc_container *c)\n{\n\tint ret;\n\n\tif ((ret = lxclock(c->privlock, 0)))\n\t\treturn ret;\n\tif ((ret = lxclock(c->slock, 0))) {\n\t\tlxcunlock(c->privlock);\n\t\treturn ret;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_container_new",
          "args": [
            "name",
            "handler->lxcpath"
          ],
          "line": 1510
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "4099-4218",
          "snippet": "struct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstruct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error destroying directory for container \\\"%s\\\".\"",
            "name"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "destroy",
            "MAXPATHLEN",
            "\"%s/%s\"",
            "handler->lxcpath",
            "name"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Destroyed rootfs for container \\\"%s\\\".\"",
            "name"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error destroying rootfs for container \\\"%s\\\".\"",
            "name"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_destroy_container",
          "args": [
            "handler->conf"
          ],
          "line": 1496
        },
        "resolved": true,
        "details": {
          "function_name": "do_destroy_container",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "1540-1547",
          "snippet": "static bool do_destroy_container(struct lxc_conf *conf) {\n\tif (am_unpriv()) {\n\t\tif (userns_exec_1(conf, bdev_destroy_wrapper, conf) < 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\treturn bdev_destroy(conf);\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_destroy_container(struct lxc_conf *conf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic bool do_destroy_container(struct lxc_conf *conf);\n\nstatic bool do_destroy_container(struct lxc_conf *conf) {\n\tif (am_unpriv()) {\n\t\tif (userns_exec_1(conf, bdev_destroy_wrapper, conf) < 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\treturn bdev_destroy(conf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic bool do_destroy_container(struct lxc_conf *conf);\nstatic void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);\n\nstatic void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name)\n{\n\tchar destroy[MAXPATHLEN];\n\tbool bret = true;\n\tint ret = 0;\n\tstruct lxc_container *c;\n\tif (handler->conf->rootfs.path && handler->conf->rootfs.mount) {\n\t\tbret = do_destroy_container(handler->conf);\n\t\tif (!bret) {\n\t\t\tERROR(\"Error destroying rootfs for container \\\"%s\\\".\", name);\n\t\t\treturn;\n\t\t}\n\t}\n\tINFO(\"Destroyed rootfs for container \\\"%s\\\".\", name);\n\n\tret = snprintf(destroy, MAXPATHLEN, \"%s/%s\", handler->lxcpath, name);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tERROR(\"Error destroying directory for container \\\"%s\\\".\", name);\n\t\treturn;\n\t}\n\n\tc = lxc_container_new(name, handler->lxcpath);\n\tif (c) {\n\t\tif (container_disk_lock(c)) {\n\t\t\tINFO(\"Could not update lxc_snapshots file.\");\n\t\t\tlxc_container_put(c);\n\t\t} else {\n\t\t\tmod_all_rdeps(c, false);\n\t\t\tcontainer_disk_unlock(c);\n\t\t\tlxc_container_put(c);\n\t\t}\n\t}\n\n\tif (am_unpriv())\n\t\tret = userns_exec_1(handler->conf, lxc_rmdir_onedev_wrapper, destroy);\n\telse\n\t\tret = lxc_rmdir_onedev(destroy, NULL);\n\n\tif (ret < 0) {\n\t\tERROR(\"Error destroying directory for container \\\"%s\\\".\", name);\n\t\treturn;\n\t}\n\tINFO(\"Destroyed directory for container \\\"%s\\\".\", name);\n}"
  },
  {
    "function_name": "lxc_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
    "lines": "1477-1486",
    "snippet": "int lxc_start(const char *name, char *const argv[], struct lxc_conf *conf,\n\t      const char *lxcpath, bool backgrounded)\n{\n\tstruct start_args start_arg = {\n\t\t.argv = argv,\n\t};\n\n\tconf->need_utmp_watch = 1;\n\treturn __lxc_start(name, conf, &start_ops, &start_arg, lxcpath, backgrounded);\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <sys/reboot.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"sync.h\"",
      "#include \"start.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"lxcutmp.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"console.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/capability.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <alloca.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_destroy_container(struct lxc_conf *conf);",
      "static void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);",
      "static struct lxc_operations start_ops = {\n\t.start = start,\n\t.post_start = post_start\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__lxc_start",
          "args": [
            "name",
            "conf",
            "&start_ops",
            "&start_arg",
            "lxcpath",
            "backgrounded"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "__lxc_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "1320-1447",
          "snippet": "int __lxc_start(const char *name, struct lxc_conf *conf,\n\t\tstruct lxc_operations* ops, void *data, const char *lxcpath,\n\t\tbool backgrounded)\n{\n\tstruct lxc_handler *handler;\n\tint err = -1;\n\tint status;\n\tbool removed_all_netdevs = true;\n\n\thandler = lxc_init(name, conf, lxcpath);\n\tif (!handler) {\n\t\tERROR(\"Failed to initialize container \\\"%s\\\".\", name);\n\t\treturn -1;\n\t}\n\thandler->ops = ops;\n\thandler->data = data;\n\thandler->backgrounded = backgrounded;\n\thandler->netnsfd = -1;\n\n\tif (must_drop_cap_sys_boot(handler->conf)) {\n\t\t#if HAVE_LIBCAP\n\t\tDEBUG(\"Dropping CAP_SYS_BOOT capability.\");\n\t\t#else\n\t\tDEBUG(\"Not dropping CAP_SYS_BOOT capability as capabilities aren't supported.\");\n\t\t#endif\n\t} else {\n\t\tDEBUG(\"Not dropping CAP_SYS_BOOT or watching utmp.\");\n\t\thandler->conf->need_utmp_watch = 0;\n\t}\n\n\tif (!attach_block_device(handler->conf)) {\n\t\tERROR(\"Failed to attach block device.\");\n\t\tgoto out_fini_nonet;\n\t}\n\n\tif (geteuid() == 0 && !lxc_list_empty(&conf->id_map)) {\n\t\t/* If the backing store is a device, mount it here and now. */\n\t\tif (rootfs_is_blockdev(conf)) {\n\t\t\tif (unshare(CLONE_NEWNS) < 0) {\n\t\t\t\tERROR(\"Failed to unshare CLONE_NEWNS.\");\n\t\t\t\tgoto out_fini_nonet;\n\t\t\t}\n\t\t\tINFO(\"Unshared CLONE_NEWNS.\");\n\n\t\t\tremount_all_slave();\n\t\t\tif (do_rootfs_setup(conf, name, lxcpath) < 0) {\n\t\t\t\tERROR(\"Error setting up rootfs mount as root before spawn.\");\n\t\t\t\tgoto out_fini_nonet;\n\t\t\t}\n\t\t\tINFO(\"Set up container rootfs as host root.\");\n\t\t}\n\t}\n\n\terr = lxc_spawn(handler);\n\tif (err) {\n\t\tERROR(\"Failed to spawn container \\\"%s\\\".\", name);\n\t\tgoto out_detach_blockdev;\n\t}\n\n\thandler->conf->reboot = 0;\n\n\terr = lxc_poll(name, handler);\n\tif (err) {\n\t\tERROR(\"LXC mainloop exited with error: %d.\", err);\n\t\tif (handler->netnsfd >= 0) {\n\t\t\tclose(handler->netnsfd);\n\t\t\thandler->netnsfd = -1;\n\t\t}\n\t\tgoto out_abort;\n\t}\n\n\twhile (waitpid(handler->pid, &status, 0) < 0 && errno == EINTR)\n\t\tcontinue;\n\n\t/* If the child process exited but was not signaled, it didn't call\n\t * reboot. This should mean it was an lxc-execute which simply exited.\n\t * In any case, treat it as a 'halt'.\n\t */\n\tif (WIFSIGNALED(status)) {\n\t\tswitch(WTERMSIG(status)) {\n\t\tcase SIGINT: /* halt */\n\t\t\tDEBUG(\"Container \\\"%s\\\" is halting.\", name);\n\t\t\tbreak;\n\t\tcase SIGHUP: /* reboot */\n\t\t\tDEBUG(\"Container \\\"%s\\\" is rebooting.\", name);\n\t\t\thandler->conf->reboot = 1;\n\t\t\tbreak;\n\t\tcase SIGSYS: /* seccomp */\n\t\t\tDEBUG(\"Container \\\"%s\\\" violated its seccomp policy.\", name);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDEBUG(\"Unknown exit status for container \\\"%s\\\" init %d.\", name, WTERMSIG(status));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tDEBUG(\"Pushing physical nics back to host namespace\");\n\tlxc_restore_phys_nics_to_netns(handler->netnsfd, handler->conf);\n\n\tDEBUG(\"Tearing down virtual network devices used by container \\\"%s\\\".\", name);\n\tremoved_all_netdevs = lxc_delete_network(handler);\n\n\tif (handler->pinfd >= 0) {\n\t\tclose(handler->pinfd);\n\t\thandler->pinfd = -1;\n\t}\n\n\tlxc_monitor_send_exit_code(name, status, handler->lxcpath);\n\terr =  lxc_error_set_and_log(handler->pid, status);\nout_fini:\n\tif (!removed_all_netdevs) {\n\t\tDEBUG(\"Failed tearing down network devices used by container. Trying again!\");\n\t\tremoved_all_netdevs = lxc_delete_network(handler);\n\t\tif (!removed_all_netdevs)\n\t\t\tDEBUG(\"Failed tearing down network devices used by container. Not trying again!\");\n\t}\n\nout_detach_blockdev:\n\tdetach_block_device(handler->conf);\n\nout_fini_nonet:\n\tlxc_fini(name, handler);\n\treturn err;\n\nout_abort:\n\tlxc_abort(name, handler);\n\tgoto out_fini;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_destroy_container(struct lxc_conf *conf);",
            "static int lxc_rmdir_onedev_wrapper(void *data);",
            "static void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic bool do_destroy_container(struct lxc_conf *conf);\nstatic int lxc_rmdir_onedev_wrapper(void *data);\nstatic void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);\n\nint __lxc_start(const char *name, struct lxc_conf *conf,\n\t\tstruct lxc_operations* ops, void *data, const char *lxcpath,\n\t\tbool backgrounded)\n{\n\tstruct lxc_handler *handler;\n\tint err = -1;\n\tint status;\n\tbool removed_all_netdevs = true;\n\n\thandler = lxc_init(name, conf, lxcpath);\n\tif (!handler) {\n\t\tERROR(\"Failed to initialize container \\\"%s\\\".\", name);\n\t\treturn -1;\n\t}\n\thandler->ops = ops;\n\thandler->data = data;\n\thandler->backgrounded = backgrounded;\n\thandler->netnsfd = -1;\n\n\tif (must_drop_cap_sys_boot(handler->conf)) {\n\t\t#if HAVE_LIBCAP\n\t\tDEBUG(\"Dropping CAP_SYS_BOOT capability.\");\n\t\t#else\n\t\tDEBUG(\"Not dropping CAP_SYS_BOOT capability as capabilities aren't supported.\");\n\t\t#endif\n\t} else {\n\t\tDEBUG(\"Not dropping CAP_SYS_BOOT or watching utmp.\");\n\t\thandler->conf->need_utmp_watch = 0;\n\t}\n\n\tif (!attach_block_device(handler->conf)) {\n\t\tERROR(\"Failed to attach block device.\");\n\t\tgoto out_fini_nonet;\n\t}\n\n\tif (geteuid() == 0 && !lxc_list_empty(&conf->id_map)) {\n\t\t/* If the backing store is a device, mount it here and now. */\n\t\tif (rootfs_is_blockdev(conf)) {\n\t\t\tif (unshare(CLONE_NEWNS) < 0) {\n\t\t\t\tERROR(\"Failed to unshare CLONE_NEWNS.\");\n\t\t\t\tgoto out_fini_nonet;\n\t\t\t}\n\t\t\tINFO(\"Unshared CLONE_NEWNS.\");\n\n\t\t\tremount_all_slave();\n\t\t\tif (do_rootfs_setup(conf, name, lxcpath) < 0) {\n\t\t\t\tERROR(\"Error setting up rootfs mount as root before spawn.\");\n\t\t\t\tgoto out_fini_nonet;\n\t\t\t}\n\t\t\tINFO(\"Set up container rootfs as host root.\");\n\t\t}\n\t}\n\n\terr = lxc_spawn(handler);\n\tif (err) {\n\t\tERROR(\"Failed to spawn container \\\"%s\\\".\", name);\n\t\tgoto out_detach_blockdev;\n\t}\n\n\thandler->conf->reboot = 0;\n\n\terr = lxc_poll(name, handler);\n\tif (err) {\n\t\tERROR(\"LXC mainloop exited with error: %d.\", err);\n\t\tif (handler->netnsfd >= 0) {\n\t\t\tclose(handler->netnsfd);\n\t\t\thandler->netnsfd = -1;\n\t\t}\n\t\tgoto out_abort;\n\t}\n\n\twhile (waitpid(handler->pid, &status, 0) < 0 && errno == EINTR)\n\t\tcontinue;\n\n\t/* If the child process exited but was not signaled, it didn't call\n\t * reboot. This should mean it was an lxc-execute which simply exited.\n\t * In any case, treat it as a 'halt'.\n\t */\n\tif (WIFSIGNALED(status)) {\n\t\tswitch(WTERMSIG(status)) {\n\t\tcase SIGINT: /* halt */\n\t\t\tDEBUG(\"Container \\\"%s\\\" is halting.\", name);\n\t\t\tbreak;\n\t\tcase SIGHUP: /* reboot */\n\t\t\tDEBUG(\"Container \\\"%s\\\" is rebooting.\", name);\n\t\t\thandler->conf->reboot = 1;\n\t\t\tbreak;\n\t\tcase SIGSYS: /* seccomp */\n\t\t\tDEBUG(\"Container \\\"%s\\\" violated its seccomp policy.\", name);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDEBUG(\"Unknown exit status for container \\\"%s\\\" init %d.\", name, WTERMSIG(status));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tDEBUG(\"Pushing physical nics back to host namespace\");\n\tlxc_restore_phys_nics_to_netns(handler->netnsfd, handler->conf);\n\n\tDEBUG(\"Tearing down virtual network devices used by container \\\"%s\\\".\", name);\n\tremoved_all_netdevs = lxc_delete_network(handler);\n\n\tif (handler->pinfd >= 0) {\n\t\tclose(handler->pinfd);\n\t\thandler->pinfd = -1;\n\t}\n\n\tlxc_monitor_send_exit_code(name, status, handler->lxcpath);\n\terr =  lxc_error_set_and_log(handler->pid, status);\nout_fini:\n\tif (!removed_all_netdevs) {\n\t\tDEBUG(\"Failed tearing down network devices used by container. Trying again!\");\n\t\tremoved_all_netdevs = lxc_delete_network(handler);\n\t\tif (!removed_all_netdevs)\n\t\t\tDEBUG(\"Failed tearing down network devices used by container. Not trying again!\");\n\t}\n\nout_detach_blockdev:\n\tdetach_block_device(handler->conf);\n\nout_fini_nonet:\n\tlxc_fini(name, handler);\n\treturn err;\n\nout_abort:\n\tlxc_abort(name, handler);\n\tgoto out_fini;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic bool do_destroy_container(struct lxc_conf *conf);\nstatic void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);\nstatic struct lxc_operations start_ops = {\n\t.start = start,\n\t.post_start = post_start\n};\n\nint lxc_start(const char *name, char *const argv[], struct lxc_conf *conf,\n\t      const char *lxcpath, bool backgrounded)\n{\n\tstruct start_args start_arg = {\n\t\t.argv = argv,\n\t};\n\n\tconf->need_utmp_watch = 1;\n\treturn __lxc_start(name, conf, &start_ops, &start_arg, lxcpath, backgrounded);\n}"
  },
  {
    "function_name": "post_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
    "lines": "1464-1470",
    "snippet": "static int post_start(struct lxc_handler *handler, void* data)\n{\n\tstruct start_args *arg = data;\n\n\tNOTICE(\"Started \\\"%s\\\" with pid \\\"%d\\\".\", arg->argv[0], handler->pid);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <sys/reboot.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"sync.h\"",
      "#include \"start.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"lxcutmp.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"console.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/capability.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <alloca.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int lxc_rmdir_onedev_wrapper(void *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NOTICE",
          "args": [
            "\"Started \\\"%s\\\" with pid \\\"%d\\\".\"",
            "arg->argv[0]",
            "handler->pid"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic int lxc_rmdir_onedev_wrapper(void *data);\n\nstatic int post_start(struct lxc_handler *handler, void* data)\n{\n\tstruct start_args *arg = data;\n\n\tNOTICE(\"Started \\\"%s\\\" with pid \\\"%d\\\".\", arg->argv[0], handler->pid);\n\treturn 0;\n}"
  },
  {
    "function_name": "start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
    "lines": "1453-1462",
    "snippet": "static int start(struct lxc_handler *handler, void* data)\n{\n\tstruct start_args *arg = data;\n\n\tNOTICE(\"Exec'ing \\\"%s\\\".\", arg->argv[0]);\n\n\texecvp(arg->argv[0], arg->argv);\n\tSYSERROR(\"Failed to exec \\\"%s\\\".\", arg->argv[0]);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <sys/reboot.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"sync.h\"",
      "#include \"start.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"lxcutmp.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"console.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/capability.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <alloca.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int lxc_rmdir_onedev_wrapper(void *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to exec \\\"%s\\\".\"",
            "arg->argv[0]"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "arg->argv[0]",
            "arg->argv"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NOTICE",
          "args": [
            "\"Exec'ing \\\"%s\\\".\"",
            "arg->argv[0]"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic int lxc_rmdir_onedev_wrapper(void *data);\n\nstatic int start(struct lxc_handler *handler, void* data)\n{\n\tstruct start_args *arg = data;\n\n\tNOTICE(\"Exec'ing \\\"%s\\\".\", arg->argv[0]);\n\n\texecvp(arg->argv[0], arg->argv);\n\tSYSERROR(\"Failed to exec \\\"%s\\\".\", arg->argv[0]);\n\treturn 0;\n}"
  },
  {
    "function_name": "__lxc_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
    "lines": "1320-1447",
    "snippet": "int __lxc_start(const char *name, struct lxc_conf *conf,\n\t\tstruct lxc_operations* ops, void *data, const char *lxcpath,\n\t\tbool backgrounded)\n{\n\tstruct lxc_handler *handler;\n\tint err = -1;\n\tint status;\n\tbool removed_all_netdevs = true;\n\n\thandler = lxc_init(name, conf, lxcpath);\n\tif (!handler) {\n\t\tERROR(\"Failed to initialize container \\\"%s\\\".\", name);\n\t\treturn -1;\n\t}\n\thandler->ops = ops;\n\thandler->data = data;\n\thandler->backgrounded = backgrounded;\n\thandler->netnsfd = -1;\n\n\tif (must_drop_cap_sys_boot(handler->conf)) {\n\t\t#if HAVE_LIBCAP\n\t\tDEBUG(\"Dropping CAP_SYS_BOOT capability.\");\n\t\t#else\n\t\tDEBUG(\"Not dropping CAP_SYS_BOOT capability as capabilities aren't supported.\");\n\t\t#endif\n\t} else {\n\t\tDEBUG(\"Not dropping CAP_SYS_BOOT or watching utmp.\");\n\t\thandler->conf->need_utmp_watch = 0;\n\t}\n\n\tif (!attach_block_device(handler->conf)) {\n\t\tERROR(\"Failed to attach block device.\");\n\t\tgoto out_fini_nonet;\n\t}\n\n\tif (geteuid() == 0 && !lxc_list_empty(&conf->id_map)) {\n\t\t/* If the backing store is a device, mount it here and now. */\n\t\tif (rootfs_is_blockdev(conf)) {\n\t\t\tif (unshare(CLONE_NEWNS) < 0) {\n\t\t\t\tERROR(\"Failed to unshare CLONE_NEWNS.\");\n\t\t\t\tgoto out_fini_nonet;\n\t\t\t}\n\t\t\tINFO(\"Unshared CLONE_NEWNS.\");\n\n\t\t\tremount_all_slave();\n\t\t\tif (do_rootfs_setup(conf, name, lxcpath) < 0) {\n\t\t\t\tERROR(\"Error setting up rootfs mount as root before spawn.\");\n\t\t\t\tgoto out_fini_nonet;\n\t\t\t}\n\t\t\tINFO(\"Set up container rootfs as host root.\");\n\t\t}\n\t}\n\n\terr = lxc_spawn(handler);\n\tif (err) {\n\t\tERROR(\"Failed to spawn container \\\"%s\\\".\", name);\n\t\tgoto out_detach_blockdev;\n\t}\n\n\thandler->conf->reboot = 0;\n\n\terr = lxc_poll(name, handler);\n\tif (err) {\n\t\tERROR(\"LXC mainloop exited with error: %d.\", err);\n\t\tif (handler->netnsfd >= 0) {\n\t\t\tclose(handler->netnsfd);\n\t\t\thandler->netnsfd = -1;\n\t\t}\n\t\tgoto out_abort;\n\t}\n\n\twhile (waitpid(handler->pid, &status, 0) < 0 && errno == EINTR)\n\t\tcontinue;\n\n\t/* If the child process exited but was not signaled, it didn't call\n\t * reboot. This should mean it was an lxc-execute which simply exited.\n\t * In any case, treat it as a 'halt'.\n\t */\n\tif (WIFSIGNALED(status)) {\n\t\tswitch(WTERMSIG(status)) {\n\t\tcase SIGINT: /* halt */\n\t\t\tDEBUG(\"Container \\\"%s\\\" is halting.\", name);\n\t\t\tbreak;\n\t\tcase SIGHUP: /* reboot */\n\t\t\tDEBUG(\"Container \\\"%s\\\" is rebooting.\", name);\n\t\t\thandler->conf->reboot = 1;\n\t\t\tbreak;\n\t\tcase SIGSYS: /* seccomp */\n\t\t\tDEBUG(\"Container \\\"%s\\\" violated its seccomp policy.\", name);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDEBUG(\"Unknown exit status for container \\\"%s\\\" init %d.\", name, WTERMSIG(status));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tDEBUG(\"Pushing physical nics back to host namespace\");\n\tlxc_restore_phys_nics_to_netns(handler->netnsfd, handler->conf);\n\n\tDEBUG(\"Tearing down virtual network devices used by container \\\"%s\\\".\", name);\n\tremoved_all_netdevs = lxc_delete_network(handler);\n\n\tif (handler->pinfd >= 0) {\n\t\tclose(handler->pinfd);\n\t\thandler->pinfd = -1;\n\t}\n\n\tlxc_monitor_send_exit_code(name, status, handler->lxcpath);\n\terr =  lxc_error_set_and_log(handler->pid, status);\nout_fini:\n\tif (!removed_all_netdevs) {\n\t\tDEBUG(\"Failed tearing down network devices used by container. Trying again!\");\n\t\tremoved_all_netdevs = lxc_delete_network(handler);\n\t\tif (!removed_all_netdevs)\n\t\t\tDEBUG(\"Failed tearing down network devices used by container. Not trying again!\");\n\t}\n\nout_detach_blockdev:\n\tdetach_block_device(handler->conf);\n\nout_fini_nonet:\n\tlxc_fini(name, handler);\n\treturn err;\n\nout_abort:\n\tlxc_abort(name, handler);\n\tgoto out_fini;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <sys/reboot.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"sync.h\"",
      "#include \"start.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"lxcutmp.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"console.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/capability.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <alloca.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_destroy_container(struct lxc_conf *conf);",
      "static int lxc_rmdir_onedev_wrapper(void *data);",
      "static void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_abort",
          "args": [
            "name",
            "handler"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "590-600",
          "snippet": "void lxc_abort(const char *name, struct lxc_handler *handler)\n{\n\tint ret, status;\n\n\tlxc_set_state(name, handler, ABORTING);\n\tif (handler->pid > 0)\n\t\tkill(handler->pid, SIGKILL);\n\twhile ((ret = waitpid(-1, &status, 0)) > 0) {\n\t\t;\n\t}\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);\n\nvoid lxc_abort(const char *name, struct lxc_handler *handler)\n{\n\tint ret, status;\n\n\tlxc_set_state(name, handler, ABORTING);\n\tif (handler->pid > 0)\n\t\tkill(handler->pid, SIGKILL);\n\twhile ((ret = waitpid(-1, &status, 0)) > 0) {\n\t\t;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_fini",
          "args": [
            "name",
            "handler"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_fini",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "509-588",
          "snippet": "void lxc_fini(const char *name, struct lxc_handler *handler)\n{\n\tint i, rc;\n\tpid_t self = getpid();\n\tchar *namespaces[LXC_NS_MAX+1];\n\tsize_t namespace_count = 0;\n\n\t/* The STOPPING state is there for future cleanup code which can take\n\t * awhile.\n\t */\n\tlxc_set_state(name, handler, STOPPING);\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (handler->nsfd[i] != -1) {\n\t\t\trc = asprintf(&namespaces[namespace_count], \"%s:/proc/%d/fd/%d\",\n\t\t\t              ns_info[i].proc_name, self, handler->nsfd[i]);\n\t\t\tif (rc == -1) {\n\t\t\t\tSYSERROR(\"Failed to allocate memory.\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++namespace_count;\n\t\t}\n\t}\n\tnamespaces[namespace_count] = NULL;\n\n\tif (handler->conf->reboot && setenv(\"LXC_TARGET\", \"reboot\", 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_TARGET=reboot.\");\n\n\tif (!handler->conf->reboot && setenv(\"LXC_TARGET\", \"stop\", 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_TARGET=stop.\");\n\n\tif (run_lxc_hooks(name, \"stop\", handler->conf, handler->lxcpath, namespaces))\n\t\tERROR(\"Failed to run lxc.hook.stop for container \\\"%s\\\".\", name);\n\n\twhile (namespace_count--)\n\t\tfree(namespaces[namespace_count]);\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (handler->nsfd[i] != -1) {\n\t\t\tclose(handler->nsfd[i]);\n\t\t\thandler->nsfd[i] = -1;\n\t\t}\n\t}\n\n\tif (handler->netnsfd >= 0) {\n\t\tclose(handler->netnsfd);\n\t\thandler->netnsfd = -1;\n\t}\n\n\tlxc_set_state(name, handler, STOPPED);\n\n\tif (run_lxc_hooks(name, \"post-stop\", handler->conf, handler->lxcpath, NULL)) {\n\t\tERROR(\"Failed to run lxc.hook.post-stop for container \\\"%s\\\".\", name);\n\t\tif (handler->conf->reboot) {\n\t\t\tWARN(\"Container will be stopped instead of rebooted.\");\n\t\t\thandler->conf->reboot = 0;\n\t\t\tif (setenv(\"LXC_TARGET\", \"stop\", 1))\n\t\t\t\tWARN(\"Failed to set environment variable: LXC_TARGET=stop.\");\n\t\t}\n\t}\n\n\t/* Reset mask set by setup_signal_fd. */\n\tif (sigprocmask(SIG_SETMASK, &handler->oldmask, NULL))\n\t\tWARN(\"Failed to restore signal mask.\");\n\n\tlxc_console_delete(&handler->conf->console);\n\tlxc_delete_tty(&handler->conf->tty_info);\n\tclose(handler->conf->maincmd_fd);\n\thandler->conf->maincmd_fd = -1;\n\tfree(handler->name);\n\tif (handler->ttysock[0] != -1) {\n\t\tclose(handler->ttysock[0]);\n\t\tclose(handler->ttysock[1]);\n\t}\n\n\tif (handler->conf->ephemeral == 1 && handler->conf->reboot != 1)\n\t\tlxc_destroy_container_on_signal(handler, name);\n\n\tcgroup_destroy(handler);\n\tfree(handler);\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_destroy_container(struct lxc_conf *conf);",
            "static void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic bool do_destroy_container(struct lxc_conf *conf);\nstatic void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);\n\nvoid lxc_fini(const char *name, struct lxc_handler *handler)\n{\n\tint i, rc;\n\tpid_t self = getpid();\n\tchar *namespaces[LXC_NS_MAX+1];\n\tsize_t namespace_count = 0;\n\n\t/* The STOPPING state is there for future cleanup code which can take\n\t * awhile.\n\t */\n\tlxc_set_state(name, handler, STOPPING);\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (handler->nsfd[i] != -1) {\n\t\t\trc = asprintf(&namespaces[namespace_count], \"%s:/proc/%d/fd/%d\",\n\t\t\t              ns_info[i].proc_name, self, handler->nsfd[i]);\n\t\t\tif (rc == -1) {\n\t\t\t\tSYSERROR(\"Failed to allocate memory.\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++namespace_count;\n\t\t}\n\t}\n\tnamespaces[namespace_count] = NULL;\n\n\tif (handler->conf->reboot && setenv(\"LXC_TARGET\", \"reboot\", 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_TARGET=reboot.\");\n\n\tif (!handler->conf->reboot && setenv(\"LXC_TARGET\", \"stop\", 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_TARGET=stop.\");\n\n\tif (run_lxc_hooks(name, \"stop\", handler->conf, handler->lxcpath, namespaces))\n\t\tERROR(\"Failed to run lxc.hook.stop for container \\\"%s\\\".\", name);\n\n\twhile (namespace_count--)\n\t\tfree(namespaces[namespace_count]);\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (handler->nsfd[i] != -1) {\n\t\t\tclose(handler->nsfd[i]);\n\t\t\thandler->nsfd[i] = -1;\n\t\t}\n\t}\n\n\tif (handler->netnsfd >= 0) {\n\t\tclose(handler->netnsfd);\n\t\thandler->netnsfd = -1;\n\t}\n\n\tlxc_set_state(name, handler, STOPPED);\n\n\tif (run_lxc_hooks(name, \"post-stop\", handler->conf, handler->lxcpath, NULL)) {\n\t\tERROR(\"Failed to run lxc.hook.post-stop for container \\\"%s\\\".\", name);\n\t\tif (handler->conf->reboot) {\n\t\t\tWARN(\"Container will be stopped instead of rebooted.\");\n\t\t\thandler->conf->reboot = 0;\n\t\t\tif (setenv(\"LXC_TARGET\", \"stop\", 1))\n\t\t\t\tWARN(\"Failed to set environment variable: LXC_TARGET=stop.\");\n\t\t}\n\t}\n\n\t/* Reset mask set by setup_signal_fd. */\n\tif (sigprocmask(SIG_SETMASK, &handler->oldmask, NULL))\n\t\tWARN(\"Failed to restore signal mask.\");\n\n\tlxc_console_delete(&handler->conf->console);\n\tlxc_delete_tty(&handler->conf->tty_info);\n\tclose(handler->conf->maincmd_fd);\n\thandler->conf->maincmd_fd = -1;\n\tfree(handler->name);\n\tif (handler->ttysock[0] != -1) {\n\t\tclose(handler->ttysock[0]);\n\t\tclose(handler->ttysock[1]);\n\t}\n\n\tif (handler->conf->ephemeral == 1 && handler->conf->reboot != 1)\n\t\tlxc_destroy_container_on_signal(handler, name);\n\n\tcgroup_destroy(handler);\n\tfree(handler);\n}"
        }
      },
      {
        "call_info": {
          "callee": "detach_block_device",
          "args": [
            "handler->conf"
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "detach_block_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "607-611",
          "snippet": "void detach_block_device(struct lxc_conf *conf)\n{\n\tif (conf->nbd_idx != -1)\n\t\tdetach_nbd_idx(conf->nbd_idx);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nvoid detach_block_device(struct lxc_conf *conf)\n{\n\tif (conf->nbd_idx != -1)\n\t\tdetach_nbd_idx(conf->nbd_idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Failed tearing down network devices used by container. Not trying again!\""
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_delete_network",
          "args": [
            "handler"
          ],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_delete_network",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "2971-3048",
          "snippet": "bool lxc_delete_network(struct lxc_handler *handler)\n{\n\tint ret;\n\tstruct lxc_list *network = &handler->conf->network;\n\tstruct lxc_list *iterator;\n\tstruct lxc_netdev *netdev;\n\tbool deleted_all = true;\n\n\tlxc_list_for_each(iterator, network) {\n\t\tnetdev = iterator->elem;\n\n\t\tif (netdev->ifindex != 0 && netdev->type == LXC_NET_PHYS) {\n\t\t\tif (lxc_netdev_rename_by_index(netdev->ifindex, netdev->link))\n\t\t\t\tWARN(\"Failed to rename interface with index %d \"\n\t\t\t\t     \"to its initial name \\\"%s\\\".\",\n\t\t\t\t     netdev->ifindex, netdev->link);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (netdev_deconf[netdev->type](handler, netdev)) {\n\t\t\tWARN(\"Failed to destroy netdev\");\n\t\t}\n\n\t\t/* Recent kernel remove the virtual interfaces when the network\n\t\t * namespace is destroyed but in case we did not moved the\n\t\t * interface to the network namespace, we have to destroy it\n\t\t */\n\t\tif (netdev->ifindex != 0) {\n\t\t\tret = lxc_netdev_delete_by_index(netdev->ifindex);\n\t\t\tif (-ret == ENODEV) {\n\t\t\t\tINFO(\"Interface \\\"%s\\\" with index %d already \"\n\t\t\t\t     \"deleted or existing in different network \"\n\t\t\t\t     \"namespace.\",\n\t\t\t\t     netdev->name ? netdev->name : \"(null)\",\n\t\t\t\t     netdev->ifindex);\n\t\t\t} else if (ret < 0) {\n\t\t\t\tdeleted_all = false;\n\t\t\t\tWARN(\"Failed to remove interface \\\"%s\\\" with \"\n\t\t\t\t     \"index %d: %s.\",\n\t\t\t\t     netdev->name ? netdev->name : \"(null)\",\n\t\t\t\t     netdev->ifindex, strerror(-ret));\n\t\t\t} else {\n\t\t\t\tINFO(\"Removed interface \\\"%s\\\" with index %d.\",\n\t\t\t\t     netdev->name ? netdev->name : \"(null)\",\n\t\t\t\t     netdev->ifindex);\n\t\t\t}\n\t\t}\n\n\t\t/* Explicitly delete host veth device to prevent lingering\n\t\t * devices. We had issues in LXD around this.\n\t\t */\n\t\tif (netdev->type == LXC_NET_VETH) {\n\t\t\tchar *hostveth;\n\t\t\tif (netdev->priv.veth_attr.pair) {\n\t\t\t\thostveth = netdev->priv.veth_attr.pair;\n\t\t\t\tret = lxc_netdev_delete_by_name(hostveth);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tWARN(\"Failed to remove interface \\\"%s\\\" from host: %s.\", hostveth, strerror(-ret));\n\t\t\t\t} else {\n\t\t\t\t\tINFO(\"Removed interface \\\"%s\\\" from host.\", hostveth);\n\t\t\t\t\tfree(netdev->priv.veth_attr.pair);\n\t\t\t\t\tnetdev->priv.veth_attr.pair = NULL;\n\t\t\t\t}\n\t\t\t} else if (strlen(netdev->priv.veth_attr.veth1) > 0) {\n\t\t\t\thostveth = netdev->priv.veth_attr.veth1;\n\t\t\t\tret = lxc_netdev_delete_by_name(hostveth);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tWARN(\"Failed to remove \\\"%s\\\" from host: %s.\", hostveth, strerror(-ret));\n\t\t\t\t} else {\n\t\t\t\t\tINFO(\"Removed interface \\\"%s\\\" from host.\", hostveth);\n\t\t\t\t\tmemset((void *)&netdev->priv.veth_attr.veth1, 0, sizeof(netdev->priv.veth_attr.veth1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn deleted_all;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_none(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_none(struct lxc_handler *, struct lxc_netdev *);",
            "static  instantiate_cb netdev_deconf[LXC_NET_MAXCONFTYPE + 1] = {\n\t[LXC_NET_VETH]    = shutdown_veth,\n\t[LXC_NET_MACVLAN] = shutdown_macvlan,\n\t[LXC_NET_VLAN]    = shutdown_vlan,\n\t[LXC_NET_PHYS]    = shutdown_phys,\n\t[LXC_NET_EMPTY]   = shutdown_empty,\n\t[LXC_NET_NONE]    = shutdown_none,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_none(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_none(struct lxc_handler *, struct lxc_netdev *);\nstatic  instantiate_cb netdev_deconf[LXC_NET_MAXCONFTYPE + 1] = {\n\t[LXC_NET_VETH]    = shutdown_veth,\n\t[LXC_NET_MACVLAN] = shutdown_macvlan,\n\t[LXC_NET_VLAN]    = shutdown_vlan,\n\t[LXC_NET_PHYS]    = shutdown_phys,\n\t[LXC_NET_EMPTY]   = shutdown_empty,\n\t[LXC_NET_NONE]    = shutdown_none,\n};\n\nbool lxc_delete_network(struct lxc_handler *handler)\n{\n\tint ret;\n\tstruct lxc_list *network = &handler->conf->network;\n\tstruct lxc_list *iterator;\n\tstruct lxc_netdev *netdev;\n\tbool deleted_all = true;\n\n\tlxc_list_for_each(iterator, network) {\n\t\tnetdev = iterator->elem;\n\n\t\tif (netdev->ifindex != 0 && netdev->type == LXC_NET_PHYS) {\n\t\t\tif (lxc_netdev_rename_by_index(netdev->ifindex, netdev->link))\n\t\t\t\tWARN(\"Failed to rename interface with index %d \"\n\t\t\t\t     \"to its initial name \\\"%s\\\".\",\n\t\t\t\t     netdev->ifindex, netdev->link);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (netdev_deconf[netdev->type](handler, netdev)) {\n\t\t\tWARN(\"Failed to destroy netdev\");\n\t\t}\n\n\t\t/* Recent kernel remove the virtual interfaces when the network\n\t\t * namespace is destroyed but in case we did not moved the\n\t\t * interface to the network namespace, we have to destroy it\n\t\t */\n\t\tif (netdev->ifindex != 0) {\n\t\t\tret = lxc_netdev_delete_by_index(netdev->ifindex);\n\t\t\tif (-ret == ENODEV) {\n\t\t\t\tINFO(\"Interface \\\"%s\\\" with index %d already \"\n\t\t\t\t     \"deleted or existing in different network \"\n\t\t\t\t     \"namespace.\",\n\t\t\t\t     netdev->name ? netdev->name : \"(null)\",\n\t\t\t\t     netdev->ifindex);\n\t\t\t} else if (ret < 0) {\n\t\t\t\tdeleted_all = false;\n\t\t\t\tWARN(\"Failed to remove interface \\\"%s\\\" with \"\n\t\t\t\t     \"index %d: %s.\",\n\t\t\t\t     netdev->name ? netdev->name : \"(null)\",\n\t\t\t\t     netdev->ifindex, strerror(-ret));\n\t\t\t} else {\n\t\t\t\tINFO(\"Removed interface \\\"%s\\\" with index %d.\",\n\t\t\t\t     netdev->name ? netdev->name : \"(null)\",\n\t\t\t\t     netdev->ifindex);\n\t\t\t}\n\t\t}\n\n\t\t/* Explicitly delete host veth device to prevent lingering\n\t\t * devices. We had issues in LXD around this.\n\t\t */\n\t\tif (netdev->type == LXC_NET_VETH) {\n\t\t\tchar *hostveth;\n\t\t\tif (netdev->priv.veth_attr.pair) {\n\t\t\t\thostveth = netdev->priv.veth_attr.pair;\n\t\t\t\tret = lxc_netdev_delete_by_name(hostveth);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tWARN(\"Failed to remove interface \\\"%s\\\" from host: %s.\", hostveth, strerror(-ret));\n\t\t\t\t} else {\n\t\t\t\t\tINFO(\"Removed interface \\\"%s\\\" from host.\", hostveth);\n\t\t\t\t\tfree(netdev->priv.veth_attr.pair);\n\t\t\t\t\tnetdev->priv.veth_attr.pair = NULL;\n\t\t\t\t}\n\t\t\t} else if (strlen(netdev->priv.veth_attr.veth1) > 0) {\n\t\t\t\thostveth = netdev->priv.veth_attr.veth1;\n\t\t\t\tret = lxc_netdev_delete_by_name(hostveth);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tWARN(\"Failed to remove \\\"%s\\\" from host: %s.\", hostveth, strerror(-ret));\n\t\t\t\t} else {\n\t\t\t\t\tINFO(\"Removed interface \\\"%s\\\" from host.\", hostveth);\n\t\t\t\t\tmemset((void *)&netdev->priv.veth_attr.veth1, 0, sizeof(netdev->priv.veth_attr.veth1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn deleted_all;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Failed tearing down network devices used by container. Trying again!\""
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_error_set_and_log",
          "args": [
            "handler->pid",
            "status"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_error_set_and_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/error.c",
          "lines": "42-58",
          "snippet": "extern int  lxc_error_set_and_log(int pid, int status)\n{\n\tint ret = 0;\n\n\tif (WIFEXITED(status)) {\n\t\tret = WEXITSTATUS(status);\n\t\tif (ret)\n\t\t\tINFO(\"Child <%d> ended on error (%d).\", pid, ret);\n\t}\n\n\tif (WIFSIGNALED(status)) {\n\t\tint signal = WTERMSIG(status);\n\t\tINFO(\"Child <%d> ended on signal (%d).\", pid, signal);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"error.h\"\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nextern int  lxc_error_set_and_log(int pid, int status)\n{\n\tint ret = 0;\n\n\tif (WIFEXITED(status)) {\n\t\tret = WEXITSTATUS(status);\n\t\tif (ret)\n\t\t\tINFO(\"Child <%d> ended on error (%d).\", pid, ret);\n\t}\n\n\tif (WIFSIGNALED(status)) {\n\t\tint signal = WTERMSIG(status);\n\t\tINFO(\"Child <%d> ended on signal (%d).\", pid, signal);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_monitor_send_exit_code",
          "args": [
            "name",
            "status",
            "handler->lxcpath"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_monitor_send_exit_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/monitor.c",
          "lines": "140-148",
          "snippet": "void lxc_monitor_send_exit_code(const char *name, int exit_code,\n\t\t\t\tconst char *lxcpath)\n{\n\tstruct lxc_msg msg = {.type = lxc_msg_exit_code, .value = exit_code};\n\tstrncpy(msg.name, name, sizeof(msg.name));\n\tmsg.name[sizeof(msg.name) - 1] = 0;\n\n\tlxc_monitor_fifo_send(&msg, lxcpath);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"af_unix.h\"",
            "#include \"config.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include <poll.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"state.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"af_unix.h\"\n#include \"config.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <errno.h>\n\nvoid lxc_monitor_send_exit_code(const char *name, int exit_code,\n\t\t\t\tconst char *lxcpath)\n{\n\tstruct lxc_msg msg = {.type = lxc_msg_exit_code, .value = exit_code};\n\tstrncpy(msg.name, name, sizeof(msg.name));\n\tmsg.name[sizeof(msg.name) - 1] = 0;\n\n\tlxc_monitor_fifo_send(&msg, lxcpath);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "handler->pinfd"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "close_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "118-128",
          "snippet": "static void close_ns(int ns_fd[LXC_NS_MAX])\n{\n\tint i;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (ns_fd[i] > -1) {\n\t\t\tclose(ns_fd[i]);\n\t\t\tns_fd[i] = -1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic void close_ns(int ns_fd[LXC_NS_MAX])\n{\n\tint i;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (ns_fd[i] > -1) {\n\t\t\tclose(ns_fd[i]);\n\t\t\tns_fd[i] = -1;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Tearing down virtual network devices used by container \\\"%s\\\".\"",
            "name"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_restore_phys_nics_to_netns",
          "args": [
            "handler->netnsfd",
            "handler->conf"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_restore_phys_nics_to_netns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "2479-2516",
          "snippet": "void lxc_restore_phys_nics_to_netns(int netnsfd, struct lxc_conf *conf)\n{\n\tint i, oldfd;\n\tchar ifname[IFNAMSIZ];\n\n\tif (netnsfd < 0 || conf->num_savednics == 0)\n\t\treturn;\n\n\tINFO(\"Running to reset %d nic names.\", conf->num_savednics);\n\n\toldfd = lxc_preserve_ns(getpid(), \"net\");\n\tif (oldfd < 0) {\n\t\tSYSERROR(\"Failed to open monitor netns fd.\");\n\t\treturn;\n\t}\n\n\tif (setns(netnsfd, 0) != 0) {\n\t\tSYSERROR(\"Failed to enter container netns to reset nics\");\n\t\tclose(oldfd);\n\t\treturn;\n\t}\n\tfor (i=0; i<conf->num_savednics; i++) {\n\t\tstruct saved_nic *s = &conf->saved_nics[i];\n\t\t/* retrieve the name of the interface */\n\t\tif (!if_indextoname(s->ifindex, ifname)) {\n\t\t\tWARN(\"no interface corresponding to index '%d'\", s->ifindex);\n\t\t\tcontinue;\n\t\t}\n\t\tif (lxc_netdev_move_by_name(ifname, 1, s->orig_name))\n\t\t\tWARN(\"Error moving nic name:%s back to host netns\", ifname);\n\t\tfree(s->orig_name);\n\t}\n\tconf->num_savednics = 0;\n\n\tif (setns(oldfd, 0) != 0)\n\t\tSYSERROR(\"Failed to re-enter monitor's netns\");\n\tclose(oldfd);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid lxc_restore_phys_nics_to_netns(int netnsfd, struct lxc_conf *conf)\n{\n\tint i, oldfd;\n\tchar ifname[IFNAMSIZ];\n\n\tif (netnsfd < 0 || conf->num_savednics == 0)\n\t\treturn;\n\n\tINFO(\"Running to reset %d nic names.\", conf->num_savednics);\n\n\toldfd = lxc_preserve_ns(getpid(), \"net\");\n\tif (oldfd < 0) {\n\t\tSYSERROR(\"Failed to open monitor netns fd.\");\n\t\treturn;\n\t}\n\n\tif (setns(netnsfd, 0) != 0) {\n\t\tSYSERROR(\"Failed to enter container netns to reset nics\");\n\t\tclose(oldfd);\n\t\treturn;\n\t}\n\tfor (i=0; i<conf->num_savednics; i++) {\n\t\tstruct saved_nic *s = &conf->saved_nics[i];\n\t\t/* retrieve the name of the interface */\n\t\tif (!if_indextoname(s->ifindex, ifname)) {\n\t\t\tWARN(\"no interface corresponding to index '%d'\", s->ifindex);\n\t\t\tcontinue;\n\t\t}\n\t\tif (lxc_netdev_move_by_name(ifname, 1, s->orig_name))\n\t\t\tWARN(\"Error moving nic name:%s back to host netns\", ifname);\n\t\tfree(s->orig_name);\n\t}\n\tconf->num_savednics = 0;\n\n\tif (setns(oldfd, 0) != 0)\n\t\tSYSERROR(\"Failed to re-enter monitor's netns\");\n\tclose(oldfd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Pushing physical nics back to host namespace\""
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Unknown exit status for container \\\"%s\\\" init %d.\"",
            "name",
            "WTERMSIG(status)"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WTERMSIG",
          "args": [
            "status"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Container \\\"%s\\\" violated its seccomp policy.\"",
            "name"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Container \\\"%s\\\" is rebooting.\"",
            "name"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Container \\\"%s\\\" is halting.\"",
            "name"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WTERMSIG",
          "args": [
            "status"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFSIGNALED",
          "args": [
            "status"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "handler->pid",
            "&status",
            "0"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"LXC mainloop exited with error: %d.\"",
            "err"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_poll",
          "args": [
            "name",
            "handler"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "351-397",
          "snippet": "int lxc_poll(const char *name, struct lxc_handler *handler)\n{\n\tint sigfd = handler->sigfd;\n\tint pid = handler->pid;\n\tstruct lxc_epoll_descr descr;\n\n\tif (lxc_mainloop_open(&descr)) {\n\t\tERROR(\"Failed to create LXC mainloop.\");\n\t\tgoto out_sigfd;\n\t}\n\n\tif (lxc_mainloop_add_handler(&descr, sigfd, signal_handler, &pid)) {\n\t\tERROR(\"Failed to add signal handler with file descriptor %d to LXC mainloop.\", sigfd);\n\t\tgoto out_mainloop_open;\n\t}\n\n\tif (lxc_console_mainloop_add(&descr, handler->conf)) {\n\t\tERROR(\"Failed to add console handler to LXC mainloop.\");\n\t\tgoto out_mainloop_open;\n\t}\n\n\tif (lxc_cmd_mainloop_add(name, &descr, handler)) {\n\t\tERROR(\"Failed to add command handler to LXC mainloop.\");\n\t\tgoto out_mainloop_open;\n\t}\n\n\tif (handler->conf->need_utmp_watch) {\n\t\t#if HAVE_LIBCAP\n\t\tif (lxc_utmp_mainloop_add(&descr, handler)) {\n\t\t\tERROR(\"Failed to add utmp handler to LXC mainloop.\");\n\t\t\tgoto out_mainloop_open;\n\t\t}\n\t\t#else\n\t\t\tDEBUG(\"Not starting utmp handler as CAP_SYS_BOOT cannot be dropped without capabilities support.\");\n\t\t#endif\n\t}\n\n\treturn lxc_mainloop(&descr, -1);\n\nout_mainloop_open:\n\tlxc_mainloop_close(&descr);\n\nout_sigfd:\n\tclose(sigfd);\n\n\treturn -1;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_destroy_container(struct lxc_conf *conf);",
            "static void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic bool do_destroy_container(struct lxc_conf *conf);\nstatic void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);\n\nint lxc_poll(const char *name, struct lxc_handler *handler)\n{\n\tint sigfd = handler->sigfd;\n\tint pid = handler->pid;\n\tstruct lxc_epoll_descr descr;\n\n\tif (lxc_mainloop_open(&descr)) {\n\t\tERROR(\"Failed to create LXC mainloop.\");\n\t\tgoto out_sigfd;\n\t}\n\n\tif (lxc_mainloop_add_handler(&descr, sigfd, signal_handler, &pid)) {\n\t\tERROR(\"Failed to add signal handler with file descriptor %d to LXC mainloop.\", sigfd);\n\t\tgoto out_mainloop_open;\n\t}\n\n\tif (lxc_console_mainloop_add(&descr, handler->conf)) {\n\t\tERROR(\"Failed to add console handler to LXC mainloop.\");\n\t\tgoto out_mainloop_open;\n\t}\n\n\tif (lxc_cmd_mainloop_add(name, &descr, handler)) {\n\t\tERROR(\"Failed to add command handler to LXC mainloop.\");\n\t\tgoto out_mainloop_open;\n\t}\n\n\tif (handler->conf->need_utmp_watch) {\n\t\t#if HAVE_LIBCAP\n\t\tif (lxc_utmp_mainloop_add(&descr, handler)) {\n\t\t\tERROR(\"Failed to add utmp handler to LXC mainloop.\");\n\t\t\tgoto out_mainloop_open;\n\t\t}\n\t\t#else\n\t\t\tDEBUG(\"Not starting utmp handler as CAP_SYS_BOOT cannot be dropped without capabilities support.\");\n\t\t#endif\n\t}\n\n\treturn lxc_mainloop(&descr, -1);\n\nout_mainloop_open:\n\tlxc_mainloop_close(&descr);\n\nout_sigfd:\n\tclose(sigfd);\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to spawn container \\\"%s\\\".\"",
            "name"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_spawn",
          "args": [
            "handler"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_spawn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "1074-1318",
          "snippet": "static int lxc_spawn(struct lxc_handler *handler)\n{\n\tint failed_before_rename = 0;\n\tconst char *name = handler->name;\n\tbool cgroups_connected = false;\n\tint saved_ns_fd[LXC_NS_MAX];\n\tint preserve_mask = 0, i, flags;\n\tint netpipepair[2], nveths;\n\n\tnetpipe = -1;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++)\n\t\tif (handler->conf->inherit_ns_fd[i] != -1)\n\t\t\tpreserve_mask |= ns_info[i].clone_flag;\n\n\tif (lxc_sync_init(handler))\n\t\treturn -1;\n\n\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, handler->ttysock) < 0) {\n\t\tlxc_sync_fini(handler);\n\t\treturn -1;\n\t}\n\n\tresolve_clone_flags(handler);\n\n\tif (handler->clone_flags & CLONE_NEWNET) {\n\t\tif (!lxc_list_empty(&handler->conf->network)) {\n\n\t\t\t/* Find gateway addresses from the link device, which is\n\t\t\t * no longer accessible inside the container. Do this\n\t\t\t * before creating network interfaces, since goto\n\t\t\t * out_delete_net does not work before lxc_clone.\n\t\t\t */\n\t\t\tif (lxc_find_gateway_addresses(handler)) {\n\t\t\t\tERROR(\"Failed to find gateway addresses.\");\n\t\t\t\tlxc_sync_fini(handler);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/* That should be done before the clone because we will\n\t\t\t * fill the netdev index and use them in the child.\n\t\t\t */\n\t\t\tif (lxc_create_network(handler)) {\n\t\t\t\tERROR(\"Failed to create the network.\");\n\t\t\t\tlxc_sync_fini(handler);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (save_phys_nics(handler->conf)) {\n\t\t\tERROR(\"Failed to save physical nic info.\");\n\t\t\tgoto out_abort;\n\t\t}\n\t}\n\n\tif (!cgroup_init(handler)) {\n\t\tERROR(\"Failed initializing cgroup support.\");\n\t\tgoto out_delete_net;\n\t}\n\n\tcgroups_connected = true;\n\n\tif (!cgroup_create(handler)) {\n\t\tERROR(\"Failed creating cgroups.\");\n\t\tgoto out_delete_net;\n\t}\n\n\t/* If the rootfs is not a blockdev, prevent the container from marking\n\t * it readonly.\n\t * If the container is unprivileged then skip rootfs pinning.\n\t */\n\tif (lxc_list_empty(&handler->conf->id_map)) {\n\t\thandler->pinfd = pin_rootfs(handler->conf->rootfs.path);\n\t\tif (handler->pinfd == -1)\n\t\t\tINFO(\"Failed to pin the rootfs for container \\\"%s\\\".\", handler->name);\n\t}\n\n\tif (!preserve_ns(saved_ns_fd, preserve_mask, getpid()))\n\t\tgoto out_delete_net;\n\n\tif (attach_ns(handler->conf->inherit_ns_fd) < 0)\n\t\tgoto out_delete_net;\n\n\tif (am_unpriv() && (nveths = count_veths(&handler->conf->network))) {\n\t\tif (pipe(netpipepair) < 0) {\n\t\t\tSYSERROR(\"Failed to create pipe.\");\n\t\t\tgoto out_delete_net;\n\t\t}\n\t\t/* Store netpipe in the global var for do_start's use. */\n\t\tnetpipe = netpipepair[0];\n\t}\n\n\t/* Create a process in a new set of namespaces. */\n\tflags = handler->clone_flags;\n\tif (handler->clone_flags & CLONE_NEWUSER) {\n\t\t/* If CLONE_NEWUSER and CLONE_NEWNET was requested, we need to\n\t\t * clone a new user namespace first and only later unshare our\n\t\t * network namespace to ensure that network devices ownership is\n\t\t * set up correctly.\n\t\t */\n\t\tflags &= ~CLONE_NEWNET;\n\t}\n\thandler->pid = lxc_clone(do_start, handler, flags);\n\tif (handler->pid < 0) {\n\t\tSYSERROR(\"Failed to clone a new set of namespaces.\");\n\t\tgoto out_delete_net;\n\t}\n\tfor (i = 0; i < LXC_NS_MAX; i++)\n\t\tif (flags & ns_info[i].clone_flag)\n\t\t\tINFO(\"Cloned %s.\", ns_info[i].flag_name);\n\n\tif (!preserve_ns(handler->nsfd, handler->clone_flags | preserve_mask, handler->pid))\n\t\tINFO(\"Failed to preserve namespace for lxc.hook.stop.\");\n\n\tif (attach_ns(saved_ns_fd))\n\t\tWARN(\"Failed to restore saved namespaces.\");\n\n\tlxc_sync_fini_child(handler);\n\n\t/* Map the container uids. The container became an invalid userid the\n\t * moment it was cloned with CLONE_NEWUSER. This call doesn't change\n\t * anything immediately, but allows the container to setuid(0) (0 being\n\t * mapped to something else on the host.) later to become a valid uid\n\t * again.\n\t */\n\tif (lxc_map_ids(&handler->conf->id_map, handler->pid)) {\n\t\tERROR(\"Failed to set up id mapping.\");\n\t\tgoto out_delete_net;\n\t}\n\n\tif (lxc_sync_wake_child(handler, LXC_SYNC_STARTUP)) {\n\t\tfailed_before_rename = 1;\n\t\tgoto out_delete_net;\n\t}\n\n\tif (lxc_sync_wait_child(handler, LXC_SYNC_CONFIGURE)) {\n\t\tfailed_before_rename = 1;\n\t\tgoto out_delete_net;\n\t}\n\n\tif (!cgroup_create_legacy(handler)) {\n\t\tERROR(\"Failed to setup legacy cgroups for container \\\"%s\\\".\", name);\n\t\tgoto out_delete_net;\n\t}\n\tif (!cgroup_setup_limits(handler, false)) {\n\t\tERROR(\"Failed to setup cgroup limits for container \\\"%s\\\".\", name);\n\t\tgoto out_delete_net;\n\t}\n\n\tif (!cgroup_enter(handler))\n\t\tgoto out_delete_net;\n\n\tif (!cgroup_chown(handler))\n\t\tgoto out_delete_net;\n\n\tif (failed_before_rename)\n\t\tgoto out_delete_net;\n\n\t/* Create the network configuration. */\n\tif (handler->clone_flags & CLONE_NEWNET) {\n\t\tif (lxc_assign_network(handler->lxcpath, handler->name,\n\t\t\t\t       &handler->conf->network, handler->pid)) {\n\t\t\tERROR(\"Failed to create the configured network.\");\n\t\t\tgoto out_delete_net;\n\t\t}\n\t}\n\n\tif (netpipe != -1) {\n\t\tstruct lxc_list *iterator;\n\t\tstruct lxc_netdev *netdev;\n\n\t\tclose(netpipe);\n\t\tlxc_list_for_each(iterator, &handler->conf->network) {\n\t\t\tnetdev = iterator->elem;\n\t\t\tif (netdev->type != LXC_NET_VETH)\n\t\t\t\tcontinue;\n\t\t\tif (write(netpipepair[1], netdev->name, IFNAMSIZ) != IFNAMSIZ) {\n\t\t\t\tERROR(\"Error writing veth name to container.\");\n\t\t\t\tgoto out_delete_net;\n\t\t\t}\n\t\t}\n\t\tclose(netpipepair[1]);\n\t}\n\n\t/* Tell the child to continue its initialization. We'll get\n\t * LXC_SYNC_CGROUP when it is ready for us to setup cgroups.\n\t */\n\tif (lxc_sync_barrier_child(handler, LXC_SYNC_POST_CONFIGURE))\n\t\tgoto out_delete_net;\n\n\tif (!cgroup_setup_limits(handler, true)) {\n\t\tERROR(\"Failed to setup the devices cgroup for container \\\"%s\\\".\", name);\n\t\tgoto out_delete_net;\n\t}\n\n\tcgroup_disconnect();\n\tcgroups_connected = false;\n\n\t/* Read tty fds allocated by child. */\n\tif (recv_ttys_from_child(handler) < 0) {\n\t\tERROR(\"Failed to receive tty info from child process.\");\n\t\tgoto out_delete_net;\n\t}\n\n\t/* Tell the child to complete its initialization and wait for it to exec\n\t * or return an error. (The child will never return\n\t * LXC_SYNC_POST_CGROUP+1. It will either close the sync pipe, causing\n\t * lxc_sync_barrier_child to return success, or return a different\n\t * value, causing us to error out).\n\t */\n\tif (lxc_sync_barrier_child(handler, LXC_SYNC_POST_CGROUP))\n\t\treturn -1;\n\n\tif (detect_shared_rootfs())\n\t\tumount2(handler->conf->rootfs.mount, MNT_DETACH);\n\n\tif (handler->ops->post_start(handler, handler->data))\n\t\tgoto out_abort;\n\n\tif (lxc_set_state(name, handler, RUNNING)) {\n\t\tERROR(\"Failed to set state for container \\\"%s\\\" to \\\"%s\\\".\", name,\n\t\t      lxc_state2str(RUNNING));\n\t\tgoto out_abort;\n\t}\n\n\tlxc_sync_fini(handler);\n\thandler->netnsfd = lxc_preserve_ns(handler->pid, \"net\");\n\n\treturn 0;\n\nout_delete_net:\n\tif (cgroups_connected)\n\t\tcgroup_disconnect();\n\tif (handler->clone_flags & CLONE_NEWNET)\n\t\tlxc_delete_network(handler);\nout_abort:\n\tlxc_abort(name, handler);\n\tlxc_sync_fini(handler);\n\tif (handler->pinfd >= 0) {\n\t\tclose(handler->pinfd);\n\t\thandler->pinfd = -1;\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_destroy_container(struct lxc_conf *conf);",
            "static int lxc_rmdir_onedev_wrapper(void *data);",
            "static void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);",
            "static int netpipe = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic bool do_destroy_container(struct lxc_conf *conf);\nstatic int lxc_rmdir_onedev_wrapper(void *data);\nstatic void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);\nstatic int netpipe = -1;\n\nstatic int lxc_spawn(struct lxc_handler *handler)\n{\n\tint failed_before_rename = 0;\n\tconst char *name = handler->name;\n\tbool cgroups_connected = false;\n\tint saved_ns_fd[LXC_NS_MAX];\n\tint preserve_mask = 0, i, flags;\n\tint netpipepair[2], nveths;\n\n\tnetpipe = -1;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++)\n\t\tif (handler->conf->inherit_ns_fd[i] != -1)\n\t\t\tpreserve_mask |= ns_info[i].clone_flag;\n\n\tif (lxc_sync_init(handler))\n\t\treturn -1;\n\n\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, handler->ttysock) < 0) {\n\t\tlxc_sync_fini(handler);\n\t\treturn -1;\n\t}\n\n\tresolve_clone_flags(handler);\n\n\tif (handler->clone_flags & CLONE_NEWNET) {\n\t\tif (!lxc_list_empty(&handler->conf->network)) {\n\n\t\t\t/* Find gateway addresses from the link device, which is\n\t\t\t * no longer accessible inside the container. Do this\n\t\t\t * before creating network interfaces, since goto\n\t\t\t * out_delete_net does not work before lxc_clone.\n\t\t\t */\n\t\t\tif (lxc_find_gateway_addresses(handler)) {\n\t\t\t\tERROR(\"Failed to find gateway addresses.\");\n\t\t\t\tlxc_sync_fini(handler);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/* That should be done before the clone because we will\n\t\t\t * fill the netdev index and use them in the child.\n\t\t\t */\n\t\t\tif (lxc_create_network(handler)) {\n\t\t\t\tERROR(\"Failed to create the network.\");\n\t\t\t\tlxc_sync_fini(handler);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (save_phys_nics(handler->conf)) {\n\t\t\tERROR(\"Failed to save physical nic info.\");\n\t\t\tgoto out_abort;\n\t\t}\n\t}\n\n\tif (!cgroup_init(handler)) {\n\t\tERROR(\"Failed initializing cgroup support.\");\n\t\tgoto out_delete_net;\n\t}\n\n\tcgroups_connected = true;\n\n\tif (!cgroup_create(handler)) {\n\t\tERROR(\"Failed creating cgroups.\");\n\t\tgoto out_delete_net;\n\t}\n\n\t/* If the rootfs is not a blockdev, prevent the container from marking\n\t * it readonly.\n\t * If the container is unprivileged then skip rootfs pinning.\n\t */\n\tif (lxc_list_empty(&handler->conf->id_map)) {\n\t\thandler->pinfd = pin_rootfs(handler->conf->rootfs.path);\n\t\tif (handler->pinfd == -1)\n\t\t\tINFO(\"Failed to pin the rootfs for container \\\"%s\\\".\", handler->name);\n\t}\n\n\tif (!preserve_ns(saved_ns_fd, preserve_mask, getpid()))\n\t\tgoto out_delete_net;\n\n\tif (attach_ns(handler->conf->inherit_ns_fd) < 0)\n\t\tgoto out_delete_net;\n\n\tif (am_unpriv() && (nveths = count_veths(&handler->conf->network))) {\n\t\tif (pipe(netpipepair) < 0) {\n\t\t\tSYSERROR(\"Failed to create pipe.\");\n\t\t\tgoto out_delete_net;\n\t\t}\n\t\t/* Store netpipe in the global var for do_start's use. */\n\t\tnetpipe = netpipepair[0];\n\t}\n\n\t/* Create a process in a new set of namespaces. */\n\tflags = handler->clone_flags;\n\tif (handler->clone_flags & CLONE_NEWUSER) {\n\t\t/* If CLONE_NEWUSER and CLONE_NEWNET was requested, we need to\n\t\t * clone a new user namespace first and only later unshare our\n\t\t * network namespace to ensure that network devices ownership is\n\t\t * set up correctly.\n\t\t */\n\t\tflags &= ~CLONE_NEWNET;\n\t}\n\thandler->pid = lxc_clone(do_start, handler, flags);\n\tif (handler->pid < 0) {\n\t\tSYSERROR(\"Failed to clone a new set of namespaces.\");\n\t\tgoto out_delete_net;\n\t}\n\tfor (i = 0; i < LXC_NS_MAX; i++)\n\t\tif (flags & ns_info[i].clone_flag)\n\t\t\tINFO(\"Cloned %s.\", ns_info[i].flag_name);\n\n\tif (!preserve_ns(handler->nsfd, handler->clone_flags | preserve_mask, handler->pid))\n\t\tINFO(\"Failed to preserve namespace for lxc.hook.stop.\");\n\n\tif (attach_ns(saved_ns_fd))\n\t\tWARN(\"Failed to restore saved namespaces.\");\n\n\tlxc_sync_fini_child(handler);\n\n\t/* Map the container uids. The container became an invalid userid the\n\t * moment it was cloned with CLONE_NEWUSER. This call doesn't change\n\t * anything immediately, but allows the container to setuid(0) (0 being\n\t * mapped to something else on the host.) later to become a valid uid\n\t * again.\n\t */\n\tif (lxc_map_ids(&handler->conf->id_map, handler->pid)) {\n\t\tERROR(\"Failed to set up id mapping.\");\n\t\tgoto out_delete_net;\n\t}\n\n\tif (lxc_sync_wake_child(handler, LXC_SYNC_STARTUP)) {\n\t\tfailed_before_rename = 1;\n\t\tgoto out_delete_net;\n\t}\n\n\tif (lxc_sync_wait_child(handler, LXC_SYNC_CONFIGURE)) {\n\t\tfailed_before_rename = 1;\n\t\tgoto out_delete_net;\n\t}\n\n\tif (!cgroup_create_legacy(handler)) {\n\t\tERROR(\"Failed to setup legacy cgroups for container \\\"%s\\\".\", name);\n\t\tgoto out_delete_net;\n\t}\n\tif (!cgroup_setup_limits(handler, false)) {\n\t\tERROR(\"Failed to setup cgroup limits for container \\\"%s\\\".\", name);\n\t\tgoto out_delete_net;\n\t}\n\n\tif (!cgroup_enter(handler))\n\t\tgoto out_delete_net;\n\n\tif (!cgroup_chown(handler))\n\t\tgoto out_delete_net;\n\n\tif (failed_before_rename)\n\t\tgoto out_delete_net;\n\n\t/* Create the network configuration. */\n\tif (handler->clone_flags & CLONE_NEWNET) {\n\t\tif (lxc_assign_network(handler->lxcpath, handler->name,\n\t\t\t\t       &handler->conf->network, handler->pid)) {\n\t\t\tERROR(\"Failed to create the configured network.\");\n\t\t\tgoto out_delete_net;\n\t\t}\n\t}\n\n\tif (netpipe != -1) {\n\t\tstruct lxc_list *iterator;\n\t\tstruct lxc_netdev *netdev;\n\n\t\tclose(netpipe);\n\t\tlxc_list_for_each(iterator, &handler->conf->network) {\n\t\t\tnetdev = iterator->elem;\n\t\t\tif (netdev->type != LXC_NET_VETH)\n\t\t\t\tcontinue;\n\t\t\tif (write(netpipepair[1], netdev->name, IFNAMSIZ) != IFNAMSIZ) {\n\t\t\t\tERROR(\"Error writing veth name to container.\");\n\t\t\t\tgoto out_delete_net;\n\t\t\t}\n\t\t}\n\t\tclose(netpipepair[1]);\n\t}\n\n\t/* Tell the child to continue its initialization. We'll get\n\t * LXC_SYNC_CGROUP when it is ready for us to setup cgroups.\n\t */\n\tif (lxc_sync_barrier_child(handler, LXC_SYNC_POST_CONFIGURE))\n\t\tgoto out_delete_net;\n\n\tif (!cgroup_setup_limits(handler, true)) {\n\t\tERROR(\"Failed to setup the devices cgroup for container \\\"%s\\\".\", name);\n\t\tgoto out_delete_net;\n\t}\n\n\tcgroup_disconnect();\n\tcgroups_connected = false;\n\n\t/* Read tty fds allocated by child. */\n\tif (recv_ttys_from_child(handler) < 0) {\n\t\tERROR(\"Failed to receive tty info from child process.\");\n\t\tgoto out_delete_net;\n\t}\n\n\t/* Tell the child to complete its initialization and wait for it to exec\n\t * or return an error. (The child will never return\n\t * LXC_SYNC_POST_CGROUP+1. It will either close the sync pipe, causing\n\t * lxc_sync_barrier_child to return success, or return a different\n\t * value, causing us to error out).\n\t */\n\tif (lxc_sync_barrier_child(handler, LXC_SYNC_POST_CGROUP))\n\t\treturn -1;\n\n\tif (detect_shared_rootfs())\n\t\tumount2(handler->conf->rootfs.mount, MNT_DETACH);\n\n\tif (handler->ops->post_start(handler, handler->data))\n\t\tgoto out_abort;\n\n\tif (lxc_set_state(name, handler, RUNNING)) {\n\t\tERROR(\"Failed to set state for container \\\"%s\\\" to \\\"%s\\\".\", name,\n\t\t      lxc_state2str(RUNNING));\n\t\tgoto out_abort;\n\t}\n\n\tlxc_sync_fini(handler);\n\thandler->netnsfd = lxc_preserve_ns(handler->pid, \"net\");\n\n\treturn 0;\n\nout_delete_net:\n\tif (cgroups_connected)\n\t\tcgroup_disconnect();\n\tif (handler->clone_flags & CLONE_NEWNET)\n\t\tlxc_delete_network(handler);\nout_abort:\n\tlxc_abort(name, handler);\n\tlxc_sync_fini(handler);\n\tif (handler->pinfd >= 0) {\n\t\tclose(handler->pinfd);\n\t\thandler->pinfd = -1;\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Set up container rootfs as host root.\""
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error setting up rootfs mount as root before spawn.\""
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_rootfs_setup",
          "args": [
            "conf",
            "name",
            "lxcpath"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "do_rootfs_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3740-3769",
          "snippet": "int do_rootfs_setup(struct lxc_conf *conf, const char *name, const char *lxcpath)\n{\n\tif (conf->rootfs_setup) {\n\t\t/*\n\t\t * rootfs was set up in another namespace.  bind-mount it\n\t\t * to give us a mount in our own ns so we can pivot_root to it\n\t\t */\n\t\tconst char *path = conf->rootfs.mount;\n\t\tif (mount(path, path, \"rootfs\", MS_BIND, NULL) < 0) {\n\t\t\tERROR(\"Failed to bind-mount container / onto itself\");\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tremount_all_slave();\n\n\tif (run_lxc_hooks(name, \"pre-mount\", conf, lxcpath, NULL)) {\n\t\tERROR(\"failed to run pre-mount hooks for container '%s'.\", name);\n\t\treturn -1;\n\t}\n\n\tif (setup_rootfs(conf)) {\n\t\tERROR(\"failed to setup rootfs for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tconf->rootfs_setup = true;\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint do_rootfs_setup(struct lxc_conf *conf, const char *name, const char *lxcpath)\n{\n\tif (conf->rootfs_setup) {\n\t\t/*\n\t\t * rootfs was set up in another namespace.  bind-mount it\n\t\t * to give us a mount in our own ns so we can pivot_root to it\n\t\t */\n\t\tconst char *path = conf->rootfs.mount;\n\t\tif (mount(path, path, \"rootfs\", MS_BIND, NULL) < 0) {\n\t\t\tERROR(\"Failed to bind-mount container / onto itself\");\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tremount_all_slave();\n\n\tif (run_lxc_hooks(name, \"pre-mount\", conf, lxcpath, NULL)) {\n\t\tERROR(\"failed to run pre-mount hooks for container '%s'.\", name);\n\t\treturn -1;\n\t}\n\n\tif (setup_rootfs(conf)) {\n\t\tERROR(\"failed to setup rootfs for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tconf->rootfs_setup = true;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remount_all_slave",
          "args": [],
          "line": 1364
        },
        "resolved": true,
        "details": {
          "function_name": "remount_all_slave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3658-3690",
          "snippet": "void remount_all_slave(void)\n{\n\t/* walk /proc/mounts and change any shared entries to slave */\n\tFILE *f = fopen(\"/proc/self/mountinfo\", \"r\");\n\tchar *line = NULL;\n\tsize_t len = 0;\n\n\tif (!f) {\n\t\tSYSERROR(\"Failed to open /proc/self/mountinfo to mark all shared\");\n\t\tERROR(\"Continuing container startup...\");\n\t\treturn;\n\t}\n\n\twhile (getline(&line, &len, f) != -1) {\n\t\tchar *target, *opts;\n\t\ttarget = get_field(line, 4);\n\t\tif (!target)\n\t\t\tcontinue;\n\t\topts = get_field(target, 2);\n\t\tif (!opts)\n\t\t\tcontinue;\n\t\tnull_endofword(opts);\n\t\tif (!strstr(opts, \"shared\"))\n\t\t\tcontinue;\n\t\tnull_endofword(target);\n\t\tif (mount(NULL, target, NULL, MS_SLAVE, NULL)) {\n\t\t\tSYSERROR(\"Failed to make %s rslave\", target);\n\t\t\tERROR(\"Continuing...\");\n\t\t}\n\t}\n\tfclose(f);\n\tfree(line);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid remount_all_slave(void)\n{\n\t/* walk /proc/mounts and change any shared entries to slave */\n\tFILE *f = fopen(\"/proc/self/mountinfo\", \"r\");\n\tchar *line = NULL;\n\tsize_t len = 0;\n\n\tif (!f) {\n\t\tSYSERROR(\"Failed to open /proc/self/mountinfo to mark all shared\");\n\t\tERROR(\"Continuing container startup...\");\n\t\treturn;\n\t}\n\n\twhile (getline(&line, &len, f) != -1) {\n\t\tchar *target, *opts;\n\t\ttarget = get_field(line, 4);\n\t\tif (!target)\n\t\t\tcontinue;\n\t\topts = get_field(target, 2);\n\t\tif (!opts)\n\t\t\tcontinue;\n\t\tnull_endofword(opts);\n\t\tif (!strstr(opts, \"shared\"))\n\t\t\tcontinue;\n\t\tnull_endofword(target);\n\t\tif (mount(NULL, target, NULL, MS_SLAVE, NULL)) {\n\t\t\tSYSERROR(\"Failed to make %s rslave\", target);\n\t\t\tERROR(\"Continuing...\");\n\t\t}\n\t}\n\tfclose(f);\n\tfree(line);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Unshared CLONE_NEWNS.\""
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to unshare CLONE_NEWNS.\""
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unshare",
          "args": [
            "CLONE_NEWNS"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "unshare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.h",
          "lines": "73-81",
          "snippet": "static inline int unshare(int flags)\n{\n#ifdef __NR_unshare\n\treturn syscall(__NR_unshare, flags);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}",
          "includes": [
            "#include <stdint.h>",
            "#  include <sys/signalfd.h>",
            "#include <../include/getline.h>",
            "#include \"initutils.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#  include <sys/signalfd.h>\n#include <../include/getline.h>\n#include \"initutils.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic inline int unshare(int flags)\n{\n#ifdef __NR_unshare\n\treturn syscall(__NR_unshare, flags);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rootfs_is_blockdev",
          "args": [
            "conf"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "rootfs_is_blockdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "784-805",
          "snippet": "bool rootfs_is_blockdev(struct lxc_conf *conf)\n{\n\tconst struct bdev_type *q;\n\tstruct stat st;\n\tint ret;\n\n\tif (!conf->rootfs.path || strcmp(conf->rootfs.path, \"/\") == 0 ||\n\t\tstrlen(conf->rootfs.path) == 0)\n\t\treturn false;\n\n\tret = stat(conf->rootfs.path, &st);\n\tif (ret == 0 && S_ISBLK(st.st_mode))\n\t\treturn true;\n\tq = bdev_query(conf, conf->rootfs.path);\n\tif (!q)\n\t\treturn false;\n\tif (strcmp(q->name, \"lvm\") == 0 ||\n\t\tstrcmp(q->name, \"loop\") == 0 ||\n\t\tstrcmp(q->name, \"nbd\") == 0)\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nbool rootfs_is_blockdev(struct lxc_conf *conf)\n{\n\tconst struct bdev_type *q;\n\tstruct stat st;\n\tint ret;\n\n\tif (!conf->rootfs.path || strcmp(conf->rootfs.path, \"/\") == 0 ||\n\t\tstrlen(conf->rootfs.path) == 0)\n\t\treturn false;\n\n\tret = stat(conf->rootfs.path, &st);\n\tif (ret == 0 && S_ISBLK(st.st_mode))\n\t\treturn true;\n\tq = bdev_query(conf, conf->rootfs.path);\n\tif (!q)\n\t\treturn false;\n\tif (strcmp(q->name, \"lvm\") == 0 ||\n\t\tstrcmp(q->name, \"loop\") == 0 ||\n\t\tstrcmp(q->name, \"nbd\") == 0)\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_empty",
          "args": [
            "&conf->id_map"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "94-97",
          "snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to attach block device.\""
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "attach_block_device",
          "args": [
            "handler->conf"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "attach_block_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "261-277",
          "snippet": "bool attach_block_device(struct lxc_conf *conf)\n{\n\tchar *path;\n\n\tif (!conf->rootfs.path)\n\t\treturn true;\n\tpath = conf->rootfs.path;\n\tif (!requires_nbd(path))\n\t\treturn true;\n\tpath = strchr(path, ':');\n\tif (!path)\n\t\treturn false;\n\tpath++;\n\tif (!attach_nbd(path, conf))\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nbool attach_block_device(struct lxc_conf *conf)\n{\n\tchar *path;\n\n\tif (!conf->rootfs.path)\n\t\treturn true;\n\tpath = conf->rootfs.path;\n\tif (!requires_nbd(path))\n\t\treturn true;\n\tpath = strchr(path, ':');\n\tif (!path)\n\t\treturn false;\n\tpath++;\n\tif (!attach_nbd(path, conf))\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Not dropping CAP_SYS_BOOT or watching utmp.\""
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Not dropping CAP_SYS_BOOT capability as capabilities aren't supported.\""
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Dropping CAP_SYS_BOOT capability.\""
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "must_drop_cap_sys_boot",
          "args": [
            "handler->conf"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "must_drop_cap_sys_boot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "620-669",
          "snippet": "static int must_drop_cap_sys_boot(struct lxc_conf *conf)\n{\n\tFILE *f;\n\tint ret, cmd, v, flags;\n\tlong stack_size = 4096;\n\tvoid *stack = alloca(stack_size);\n\tint status;\n\tpid_t pid;\n\n\tf = fopen(\"/proc/sys/kernel/ctrl-alt-del\", \"r\");\n\tif (!f) {\n\t\tDEBUG(\"failed to open /proc/sys/kernel/ctrl-alt-del\");\n\t\treturn 1;\n\t}\n\n\tret = fscanf(f, \"%d\", &v);\n\tfclose(f);\n\tif (ret != 1) {\n\t\tDEBUG(\"Failed to read /proc/sys/kernel/ctrl-alt-del.\");\n\t\treturn 1;\n\t}\n\tcmd = v ? LINUX_REBOOT_CMD_CAD_ON : LINUX_REBOOT_CMD_CAD_OFF;\n\n\tflags = CLONE_NEWPID | SIGCHLD;\n\tif (!lxc_list_empty(&conf->id_map))\n\t\tflags |= CLONE_NEWUSER;\n\n#ifdef __ia64__\n\tpid = __clone2(container_reboot_supported, stack, stack_size, flags,  &cmd);\n#else\n\tstack += stack_size;\n\tpid = clone(container_reboot_supported, stack, flags, &cmd);\n#endif\n\tif (pid < 0) {\n\t\tif (flags & CLONE_NEWUSER)\n\t\t\tERROR(\"Failed to clone (%#x): %s (includes CLONE_NEWUSER).\", flags, strerror(errno));\n\t\telse\n\t\t\tERROR(\"Failed to clone (%#x): %s.\", flags, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (wait(&status) < 0) {\n\t\tSYSERROR(\"Unexpected wait error: %m.\");\n\t\treturn -1;\n\t}\n\n\tif (WEXITSTATUS(status) != 1)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_destroy_container(struct lxc_conf *conf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic bool do_destroy_container(struct lxc_conf *conf);\n\nstatic int must_drop_cap_sys_boot(struct lxc_conf *conf)\n{\n\tFILE *f;\n\tint ret, cmd, v, flags;\n\tlong stack_size = 4096;\n\tvoid *stack = alloca(stack_size);\n\tint status;\n\tpid_t pid;\n\n\tf = fopen(\"/proc/sys/kernel/ctrl-alt-del\", \"r\");\n\tif (!f) {\n\t\tDEBUG(\"failed to open /proc/sys/kernel/ctrl-alt-del\");\n\t\treturn 1;\n\t}\n\n\tret = fscanf(f, \"%d\", &v);\n\tfclose(f);\n\tif (ret != 1) {\n\t\tDEBUG(\"Failed to read /proc/sys/kernel/ctrl-alt-del.\");\n\t\treturn 1;\n\t}\n\tcmd = v ? LINUX_REBOOT_CMD_CAD_ON : LINUX_REBOOT_CMD_CAD_OFF;\n\n\tflags = CLONE_NEWPID | SIGCHLD;\n\tif (!lxc_list_empty(&conf->id_map))\n\t\tflags |= CLONE_NEWUSER;\n\n#ifdef __ia64__\n\tpid = __clone2(container_reboot_supported, stack, stack_size, flags,  &cmd);\n#else\n\tstack += stack_size;\n\tpid = clone(container_reboot_supported, stack, flags, &cmd);\n#endif\n\tif (pid < 0) {\n\t\tif (flags & CLONE_NEWUSER)\n\t\t\tERROR(\"Failed to clone (%#x): %s (includes CLONE_NEWUSER).\", flags, strerror(errno));\n\t\telse\n\t\t\tERROR(\"Failed to clone (%#x): %s.\", flags, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (wait(&status) < 0) {\n\t\tSYSERROR(\"Unexpected wait error: %m.\");\n\t\treturn -1;\n\t}\n\n\tif (WEXITSTATUS(status) != 1)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to initialize container \\\"%s\\\".\"",
            "name"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_init",
          "args": [
            "name",
            "conf",
            "lxcpath"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "399-507",
          "snippet": "struct lxc_handler *lxc_init(const char *name, struct lxc_conf *conf, const char *lxcpath)\n{\n\tint i;\n\tstruct lxc_handler *handler;\n\n\thandler = malloc(sizeof(*handler));\n\tif (!handler)\n\t\treturn NULL;\n\n\tmemset(handler, 0, sizeof(*handler));\n\n\thandler->ttysock[0] = handler->ttysock[1] = -1;\n\thandler->conf = conf;\n\thandler->lxcpath = lxcpath;\n\thandler->pinfd = -1;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++)\n\t\thandler->nsfd[i] = -1;\n\n\tlsm_init();\n\n\thandler->name = strdup(name);\n\tif (!handler->name) {\n\t\tERROR(\"Failed to allocate memory.\");\n\t\tgoto out_free;\n\t}\n\n\tif (lxc_cmd_init(name, handler, lxcpath))\n\t\tgoto out_free_name;\n\n\tif (lxc_read_seccomp_config(conf) != 0) {\n\t\tERROR(\"Failed loading seccomp policy.\");\n\t\tgoto out_close_maincmd_fd;\n\t}\n\n\t/* Begin by setting the state to STARTING. */\n\tif (lxc_set_state(name, handler, STARTING)) {\n\t\tERROR(\"Failed to set state for container \\\"%s\\\" to \\\"%s\\\".\", name, lxc_state2str(STARTING));\n\t\tgoto out_close_maincmd_fd;\n\t}\n\n\t/* Start of environment variable setup for hooks. */\n\tif (name && setenv(\"LXC_NAME\", name, 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_NAME=%s.\", name);\n\n\tif (conf->rcfile && setenv(\"LXC_CONFIG_FILE\", conf->rcfile, 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_CONFIG_FILE=%s.\", conf->rcfile);\n\n\tif (conf->rootfs.mount && setenv(\"LXC_ROOTFS_MOUNT\", conf->rootfs.mount, 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_ROOTFS_MOUNT=%s.\", conf->rootfs.mount);\n\n\tif (conf->rootfs.path && setenv(\"LXC_ROOTFS_PATH\", conf->rootfs.path, 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_ROOTFS_PATH=%s.\", conf->rootfs.path);\n\n\tif (conf->console.path && setenv(\"LXC_CONSOLE\", conf->console.path, 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_CONSOLE=%s.\", conf->console.path);\n\n\tif (conf->console.log_path && setenv(\"LXC_CONSOLE_LOGPATH\", conf->console.log_path, 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_CONSOLE_LOGPATH=%s.\", conf->console.log_path);\n\n\tif (setenv(\"LXC_CGNS_AWARE\", \"1\", 1))\n\t\tSYSERROR(\"Failed to set environment variable LXC_CGNS_AWARE=1.\");\n\t/* End of environment variable setup for hooks. */\n\n\tif (run_lxc_hooks(name, \"pre-start\", conf, handler->lxcpath, NULL)) {\n\t\tERROR(\"Failed to run lxc.hook.pre-start for container \\\"%s\\\".\", name);\n\t\tgoto out_aborting;\n\t}\n\n\t/* The signal fd has to be created before forking otherwise if the child\n\t * process exits before we setup the signal fd, the event will be lost\n\t * and the command will be stuck.\n\t */\n\thandler->sigfd = setup_signal_fd(&handler->oldmask);\n\tif (handler->sigfd < 0) {\n\t\tERROR(\"Failed to setup SIGCHLD fd handler.\");\n\t\tgoto out_delete_tty;\n\t}\n\n\t/* Do this after setting up signals since it might unblock SIGWINCH. */\n\tif (lxc_console_create(conf)) {\n\t\tERROR(\"Failed to create console for container \\\"%s\\\".\", name);\n\t\tgoto out_restore_sigmask;\n\t}\n\n\tif (ttys_shift_ids(conf) < 0) {\n\t\tERROR(\"Failed to shift tty into container.\");\n\t\tgoto out_restore_sigmask;\n\t}\n\n\tINFO(\"Container \\\"%s\\\" is initialized.\", name);\n\treturn handler;\n\nout_restore_sigmask:\n\tsigprocmask(SIG_SETMASK, &handler->oldmask, NULL);\nout_delete_tty:\n\tlxc_delete_tty(&conf->tty_info);\nout_aborting:\n\tlxc_set_state(name, handler, ABORTING);\nout_close_maincmd_fd:\n\tclose(conf->maincmd_fd);\n\tconf->maincmd_fd = -1;\nout_free_name:\n\tfree(handler->name);\n\thandler->name = NULL;\nout_free:\n\tfree(handler);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_destroy_container(struct lxc_conf *conf);",
            "static void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic bool do_destroy_container(struct lxc_conf *conf);\nstatic void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);\n\nstruct lxc_handler *lxc_init(const char *name, struct lxc_conf *conf, const char *lxcpath)\n{\n\tint i;\n\tstruct lxc_handler *handler;\n\n\thandler = malloc(sizeof(*handler));\n\tif (!handler)\n\t\treturn NULL;\n\n\tmemset(handler, 0, sizeof(*handler));\n\n\thandler->ttysock[0] = handler->ttysock[1] = -1;\n\thandler->conf = conf;\n\thandler->lxcpath = lxcpath;\n\thandler->pinfd = -1;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++)\n\t\thandler->nsfd[i] = -1;\n\n\tlsm_init();\n\n\thandler->name = strdup(name);\n\tif (!handler->name) {\n\t\tERROR(\"Failed to allocate memory.\");\n\t\tgoto out_free;\n\t}\n\n\tif (lxc_cmd_init(name, handler, lxcpath))\n\t\tgoto out_free_name;\n\n\tif (lxc_read_seccomp_config(conf) != 0) {\n\t\tERROR(\"Failed loading seccomp policy.\");\n\t\tgoto out_close_maincmd_fd;\n\t}\n\n\t/* Begin by setting the state to STARTING. */\n\tif (lxc_set_state(name, handler, STARTING)) {\n\t\tERROR(\"Failed to set state for container \\\"%s\\\" to \\\"%s\\\".\", name, lxc_state2str(STARTING));\n\t\tgoto out_close_maincmd_fd;\n\t}\n\n\t/* Start of environment variable setup for hooks. */\n\tif (name && setenv(\"LXC_NAME\", name, 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_NAME=%s.\", name);\n\n\tif (conf->rcfile && setenv(\"LXC_CONFIG_FILE\", conf->rcfile, 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_CONFIG_FILE=%s.\", conf->rcfile);\n\n\tif (conf->rootfs.mount && setenv(\"LXC_ROOTFS_MOUNT\", conf->rootfs.mount, 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_ROOTFS_MOUNT=%s.\", conf->rootfs.mount);\n\n\tif (conf->rootfs.path && setenv(\"LXC_ROOTFS_PATH\", conf->rootfs.path, 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_ROOTFS_PATH=%s.\", conf->rootfs.path);\n\n\tif (conf->console.path && setenv(\"LXC_CONSOLE\", conf->console.path, 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_CONSOLE=%s.\", conf->console.path);\n\n\tif (conf->console.log_path && setenv(\"LXC_CONSOLE_LOGPATH\", conf->console.log_path, 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_CONSOLE_LOGPATH=%s.\", conf->console.log_path);\n\n\tif (setenv(\"LXC_CGNS_AWARE\", \"1\", 1))\n\t\tSYSERROR(\"Failed to set environment variable LXC_CGNS_AWARE=1.\");\n\t/* End of environment variable setup for hooks. */\n\n\tif (run_lxc_hooks(name, \"pre-start\", conf, handler->lxcpath, NULL)) {\n\t\tERROR(\"Failed to run lxc.hook.pre-start for container \\\"%s\\\".\", name);\n\t\tgoto out_aborting;\n\t}\n\n\t/* The signal fd has to be created before forking otherwise if the child\n\t * process exits before we setup the signal fd, the event will be lost\n\t * and the command will be stuck.\n\t */\n\thandler->sigfd = setup_signal_fd(&handler->oldmask);\n\tif (handler->sigfd < 0) {\n\t\tERROR(\"Failed to setup SIGCHLD fd handler.\");\n\t\tgoto out_delete_tty;\n\t}\n\n\t/* Do this after setting up signals since it might unblock SIGWINCH. */\n\tif (lxc_console_create(conf)) {\n\t\tERROR(\"Failed to create console for container \\\"%s\\\".\", name);\n\t\tgoto out_restore_sigmask;\n\t}\n\n\tif (ttys_shift_ids(conf) < 0) {\n\t\tERROR(\"Failed to shift tty into container.\");\n\t\tgoto out_restore_sigmask;\n\t}\n\n\tINFO(\"Container \\\"%s\\\" is initialized.\", name);\n\treturn handler;\n\nout_restore_sigmask:\n\tsigprocmask(SIG_SETMASK, &handler->oldmask, NULL);\nout_delete_tty:\n\tlxc_delete_tty(&conf->tty_info);\nout_aborting:\n\tlxc_set_state(name, handler, ABORTING);\nout_close_maincmd_fd:\n\tclose(conf->maincmd_fd);\n\tconf->maincmd_fd = -1;\nout_free_name:\n\tfree(handler->name);\n\thandler->name = NULL;\nout_free:\n\tfree(handler);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic bool do_destroy_container(struct lxc_conf *conf);\nstatic int lxc_rmdir_onedev_wrapper(void *data);\nstatic void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);\n\nint __lxc_start(const char *name, struct lxc_conf *conf,\n\t\tstruct lxc_operations* ops, void *data, const char *lxcpath,\n\t\tbool backgrounded)\n{\n\tstruct lxc_handler *handler;\n\tint err = -1;\n\tint status;\n\tbool removed_all_netdevs = true;\n\n\thandler = lxc_init(name, conf, lxcpath);\n\tif (!handler) {\n\t\tERROR(\"Failed to initialize container \\\"%s\\\".\", name);\n\t\treturn -1;\n\t}\n\thandler->ops = ops;\n\thandler->data = data;\n\thandler->backgrounded = backgrounded;\n\thandler->netnsfd = -1;\n\n\tif (must_drop_cap_sys_boot(handler->conf)) {\n\t\t#if HAVE_LIBCAP\n\t\tDEBUG(\"Dropping CAP_SYS_BOOT capability.\");\n\t\t#else\n\t\tDEBUG(\"Not dropping CAP_SYS_BOOT capability as capabilities aren't supported.\");\n\t\t#endif\n\t} else {\n\t\tDEBUG(\"Not dropping CAP_SYS_BOOT or watching utmp.\");\n\t\thandler->conf->need_utmp_watch = 0;\n\t}\n\n\tif (!attach_block_device(handler->conf)) {\n\t\tERROR(\"Failed to attach block device.\");\n\t\tgoto out_fini_nonet;\n\t}\n\n\tif (geteuid() == 0 && !lxc_list_empty(&conf->id_map)) {\n\t\t/* If the backing store is a device, mount it here and now. */\n\t\tif (rootfs_is_blockdev(conf)) {\n\t\t\tif (unshare(CLONE_NEWNS) < 0) {\n\t\t\t\tERROR(\"Failed to unshare CLONE_NEWNS.\");\n\t\t\t\tgoto out_fini_nonet;\n\t\t\t}\n\t\t\tINFO(\"Unshared CLONE_NEWNS.\");\n\n\t\t\tremount_all_slave();\n\t\t\tif (do_rootfs_setup(conf, name, lxcpath) < 0) {\n\t\t\t\tERROR(\"Error setting up rootfs mount as root before spawn.\");\n\t\t\t\tgoto out_fini_nonet;\n\t\t\t}\n\t\t\tINFO(\"Set up container rootfs as host root.\");\n\t\t}\n\t}\n\n\terr = lxc_spawn(handler);\n\tif (err) {\n\t\tERROR(\"Failed to spawn container \\\"%s\\\".\", name);\n\t\tgoto out_detach_blockdev;\n\t}\n\n\thandler->conf->reboot = 0;\n\n\terr = lxc_poll(name, handler);\n\tif (err) {\n\t\tERROR(\"LXC mainloop exited with error: %d.\", err);\n\t\tif (handler->netnsfd >= 0) {\n\t\t\tclose(handler->netnsfd);\n\t\t\thandler->netnsfd = -1;\n\t\t}\n\t\tgoto out_abort;\n\t}\n\n\twhile (waitpid(handler->pid, &status, 0) < 0 && errno == EINTR)\n\t\tcontinue;\n\n\t/* If the child process exited but was not signaled, it didn't call\n\t * reboot. This should mean it was an lxc-execute which simply exited.\n\t * In any case, treat it as a 'halt'.\n\t */\n\tif (WIFSIGNALED(status)) {\n\t\tswitch(WTERMSIG(status)) {\n\t\tcase SIGINT: /* halt */\n\t\t\tDEBUG(\"Container \\\"%s\\\" is halting.\", name);\n\t\t\tbreak;\n\t\tcase SIGHUP: /* reboot */\n\t\t\tDEBUG(\"Container \\\"%s\\\" is rebooting.\", name);\n\t\t\thandler->conf->reboot = 1;\n\t\t\tbreak;\n\t\tcase SIGSYS: /* seccomp */\n\t\t\tDEBUG(\"Container \\\"%s\\\" violated its seccomp policy.\", name);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDEBUG(\"Unknown exit status for container \\\"%s\\\" init %d.\", name, WTERMSIG(status));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tDEBUG(\"Pushing physical nics back to host namespace\");\n\tlxc_restore_phys_nics_to_netns(handler->netnsfd, handler->conf);\n\n\tDEBUG(\"Tearing down virtual network devices used by container \\\"%s\\\".\", name);\n\tremoved_all_netdevs = lxc_delete_network(handler);\n\n\tif (handler->pinfd >= 0) {\n\t\tclose(handler->pinfd);\n\t\thandler->pinfd = -1;\n\t}\n\n\tlxc_monitor_send_exit_code(name, status, handler->lxcpath);\n\terr =  lxc_error_set_and_log(handler->pid, status);\nout_fini:\n\tif (!removed_all_netdevs) {\n\t\tDEBUG(\"Failed tearing down network devices used by container. Trying again!\");\n\t\tremoved_all_netdevs = lxc_delete_network(handler);\n\t\tif (!removed_all_netdevs)\n\t\t\tDEBUG(\"Failed tearing down network devices used by container. Not trying again!\");\n\t}\n\nout_detach_blockdev:\n\tdetach_block_device(handler->conf);\n\nout_fini_nonet:\n\tlxc_fini(name, handler);\n\treturn err;\n\nout_abort:\n\tlxc_abort(name, handler);\n\tgoto out_fini;\n}"
  },
  {
    "function_name": "lxc_spawn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
    "lines": "1074-1318",
    "snippet": "static int lxc_spawn(struct lxc_handler *handler)\n{\n\tint failed_before_rename = 0;\n\tconst char *name = handler->name;\n\tbool cgroups_connected = false;\n\tint saved_ns_fd[LXC_NS_MAX];\n\tint preserve_mask = 0, i, flags;\n\tint netpipepair[2], nveths;\n\n\tnetpipe = -1;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++)\n\t\tif (handler->conf->inherit_ns_fd[i] != -1)\n\t\t\tpreserve_mask |= ns_info[i].clone_flag;\n\n\tif (lxc_sync_init(handler))\n\t\treturn -1;\n\n\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, handler->ttysock) < 0) {\n\t\tlxc_sync_fini(handler);\n\t\treturn -1;\n\t}\n\n\tresolve_clone_flags(handler);\n\n\tif (handler->clone_flags & CLONE_NEWNET) {\n\t\tif (!lxc_list_empty(&handler->conf->network)) {\n\n\t\t\t/* Find gateway addresses from the link device, which is\n\t\t\t * no longer accessible inside the container. Do this\n\t\t\t * before creating network interfaces, since goto\n\t\t\t * out_delete_net does not work before lxc_clone.\n\t\t\t */\n\t\t\tif (lxc_find_gateway_addresses(handler)) {\n\t\t\t\tERROR(\"Failed to find gateway addresses.\");\n\t\t\t\tlxc_sync_fini(handler);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/* That should be done before the clone because we will\n\t\t\t * fill the netdev index and use them in the child.\n\t\t\t */\n\t\t\tif (lxc_create_network(handler)) {\n\t\t\t\tERROR(\"Failed to create the network.\");\n\t\t\t\tlxc_sync_fini(handler);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (save_phys_nics(handler->conf)) {\n\t\t\tERROR(\"Failed to save physical nic info.\");\n\t\t\tgoto out_abort;\n\t\t}\n\t}\n\n\tif (!cgroup_init(handler)) {\n\t\tERROR(\"Failed initializing cgroup support.\");\n\t\tgoto out_delete_net;\n\t}\n\n\tcgroups_connected = true;\n\n\tif (!cgroup_create(handler)) {\n\t\tERROR(\"Failed creating cgroups.\");\n\t\tgoto out_delete_net;\n\t}\n\n\t/* If the rootfs is not a blockdev, prevent the container from marking\n\t * it readonly.\n\t * If the container is unprivileged then skip rootfs pinning.\n\t */\n\tif (lxc_list_empty(&handler->conf->id_map)) {\n\t\thandler->pinfd = pin_rootfs(handler->conf->rootfs.path);\n\t\tif (handler->pinfd == -1)\n\t\t\tINFO(\"Failed to pin the rootfs for container \\\"%s\\\".\", handler->name);\n\t}\n\n\tif (!preserve_ns(saved_ns_fd, preserve_mask, getpid()))\n\t\tgoto out_delete_net;\n\n\tif (attach_ns(handler->conf->inherit_ns_fd) < 0)\n\t\tgoto out_delete_net;\n\n\tif (am_unpriv() && (nveths = count_veths(&handler->conf->network))) {\n\t\tif (pipe(netpipepair) < 0) {\n\t\t\tSYSERROR(\"Failed to create pipe.\");\n\t\t\tgoto out_delete_net;\n\t\t}\n\t\t/* Store netpipe in the global var for do_start's use. */\n\t\tnetpipe = netpipepair[0];\n\t}\n\n\t/* Create a process in a new set of namespaces. */\n\tflags = handler->clone_flags;\n\tif (handler->clone_flags & CLONE_NEWUSER) {\n\t\t/* If CLONE_NEWUSER and CLONE_NEWNET was requested, we need to\n\t\t * clone a new user namespace first and only later unshare our\n\t\t * network namespace to ensure that network devices ownership is\n\t\t * set up correctly.\n\t\t */\n\t\tflags &= ~CLONE_NEWNET;\n\t}\n\thandler->pid = lxc_clone(do_start, handler, flags);\n\tif (handler->pid < 0) {\n\t\tSYSERROR(\"Failed to clone a new set of namespaces.\");\n\t\tgoto out_delete_net;\n\t}\n\tfor (i = 0; i < LXC_NS_MAX; i++)\n\t\tif (flags & ns_info[i].clone_flag)\n\t\t\tINFO(\"Cloned %s.\", ns_info[i].flag_name);\n\n\tif (!preserve_ns(handler->nsfd, handler->clone_flags | preserve_mask, handler->pid))\n\t\tINFO(\"Failed to preserve namespace for lxc.hook.stop.\");\n\n\tif (attach_ns(saved_ns_fd))\n\t\tWARN(\"Failed to restore saved namespaces.\");\n\n\tlxc_sync_fini_child(handler);\n\n\t/* Map the container uids. The container became an invalid userid the\n\t * moment it was cloned with CLONE_NEWUSER. This call doesn't change\n\t * anything immediately, but allows the container to setuid(0) (0 being\n\t * mapped to something else on the host.) later to become a valid uid\n\t * again.\n\t */\n\tif (lxc_map_ids(&handler->conf->id_map, handler->pid)) {\n\t\tERROR(\"Failed to set up id mapping.\");\n\t\tgoto out_delete_net;\n\t}\n\n\tif (lxc_sync_wake_child(handler, LXC_SYNC_STARTUP)) {\n\t\tfailed_before_rename = 1;\n\t\tgoto out_delete_net;\n\t}\n\n\tif (lxc_sync_wait_child(handler, LXC_SYNC_CONFIGURE)) {\n\t\tfailed_before_rename = 1;\n\t\tgoto out_delete_net;\n\t}\n\n\tif (!cgroup_create_legacy(handler)) {\n\t\tERROR(\"Failed to setup legacy cgroups for container \\\"%s\\\".\", name);\n\t\tgoto out_delete_net;\n\t}\n\tif (!cgroup_setup_limits(handler, false)) {\n\t\tERROR(\"Failed to setup cgroup limits for container \\\"%s\\\".\", name);\n\t\tgoto out_delete_net;\n\t}\n\n\tif (!cgroup_enter(handler))\n\t\tgoto out_delete_net;\n\n\tif (!cgroup_chown(handler))\n\t\tgoto out_delete_net;\n\n\tif (failed_before_rename)\n\t\tgoto out_delete_net;\n\n\t/* Create the network configuration. */\n\tif (handler->clone_flags & CLONE_NEWNET) {\n\t\tif (lxc_assign_network(handler->lxcpath, handler->name,\n\t\t\t\t       &handler->conf->network, handler->pid)) {\n\t\t\tERROR(\"Failed to create the configured network.\");\n\t\t\tgoto out_delete_net;\n\t\t}\n\t}\n\n\tif (netpipe != -1) {\n\t\tstruct lxc_list *iterator;\n\t\tstruct lxc_netdev *netdev;\n\n\t\tclose(netpipe);\n\t\tlxc_list_for_each(iterator, &handler->conf->network) {\n\t\t\tnetdev = iterator->elem;\n\t\t\tif (netdev->type != LXC_NET_VETH)\n\t\t\t\tcontinue;\n\t\t\tif (write(netpipepair[1], netdev->name, IFNAMSIZ) != IFNAMSIZ) {\n\t\t\t\tERROR(\"Error writing veth name to container.\");\n\t\t\t\tgoto out_delete_net;\n\t\t\t}\n\t\t}\n\t\tclose(netpipepair[1]);\n\t}\n\n\t/* Tell the child to continue its initialization. We'll get\n\t * LXC_SYNC_CGROUP when it is ready for us to setup cgroups.\n\t */\n\tif (lxc_sync_barrier_child(handler, LXC_SYNC_POST_CONFIGURE))\n\t\tgoto out_delete_net;\n\n\tif (!cgroup_setup_limits(handler, true)) {\n\t\tERROR(\"Failed to setup the devices cgroup for container \\\"%s\\\".\", name);\n\t\tgoto out_delete_net;\n\t}\n\n\tcgroup_disconnect();\n\tcgroups_connected = false;\n\n\t/* Read tty fds allocated by child. */\n\tif (recv_ttys_from_child(handler) < 0) {\n\t\tERROR(\"Failed to receive tty info from child process.\");\n\t\tgoto out_delete_net;\n\t}\n\n\t/* Tell the child to complete its initialization and wait for it to exec\n\t * or return an error. (The child will never return\n\t * LXC_SYNC_POST_CGROUP+1. It will either close the sync pipe, causing\n\t * lxc_sync_barrier_child to return success, or return a different\n\t * value, causing us to error out).\n\t */\n\tif (lxc_sync_barrier_child(handler, LXC_SYNC_POST_CGROUP))\n\t\treturn -1;\n\n\tif (detect_shared_rootfs())\n\t\tumount2(handler->conf->rootfs.mount, MNT_DETACH);\n\n\tif (handler->ops->post_start(handler, handler->data))\n\t\tgoto out_abort;\n\n\tif (lxc_set_state(name, handler, RUNNING)) {\n\t\tERROR(\"Failed to set state for container \\\"%s\\\" to \\\"%s\\\".\", name,\n\t\t      lxc_state2str(RUNNING));\n\t\tgoto out_abort;\n\t}\n\n\tlxc_sync_fini(handler);\n\thandler->netnsfd = lxc_preserve_ns(handler->pid, \"net\");\n\n\treturn 0;\n\nout_delete_net:\n\tif (cgroups_connected)\n\t\tcgroup_disconnect();\n\tif (handler->clone_flags & CLONE_NEWNET)\n\t\tlxc_delete_network(handler);\nout_abort:\n\tlxc_abort(name, handler);\n\tlxc_sync_fini(handler);\n\tif (handler->pinfd >= 0) {\n\t\tclose(handler->pinfd);\n\t\thandler->pinfd = -1;\n\t}\n\n\treturn -1;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <sys/reboot.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"sync.h\"",
      "#include \"start.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"lxcutmp.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"console.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/capability.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <alloca.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_destroy_container(struct lxc_conf *conf);",
      "static int lxc_rmdir_onedev_wrapper(void *data);",
      "static void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);",
      "static int netpipe = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "handler->pinfd"
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "close_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "118-128",
          "snippet": "static void close_ns(int ns_fd[LXC_NS_MAX])\n{\n\tint i;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (ns_fd[i] > -1) {\n\t\t\tclose(ns_fd[i]);\n\t\t\tns_fd[i] = -1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic void close_ns(int ns_fd[LXC_NS_MAX])\n{\n\tint i;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (ns_fd[i] > -1) {\n\t\t\tclose(ns_fd[i]);\n\t\t\tns_fd[i] = -1;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_sync_fini",
          "args": [
            "handler"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_sync_fini",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/sync.c",
          "lines": "149-153",
          "snippet": "void lxc_sync_fini(struct lxc_handler *handler)\n{\n\tlxc_sync_fini_child(handler);\n\tlxc_sync_fini_parent(handler);\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"log.h\"",
            "#include \"sync.h\"",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"log.h\"\n#include \"sync.h\"\n#include <fcntl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n\nvoid lxc_sync_fini(struct lxc_handler *handler)\n{\n\tlxc_sync_fini_child(handler);\n\tlxc_sync_fini_parent(handler);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_abort",
          "args": [
            "name",
            "handler"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "590-600",
          "snippet": "void lxc_abort(const char *name, struct lxc_handler *handler)\n{\n\tint ret, status;\n\n\tlxc_set_state(name, handler, ABORTING);\n\tif (handler->pid > 0)\n\t\tkill(handler->pid, SIGKILL);\n\twhile ((ret = waitpid(-1, &status, 0)) > 0) {\n\t\t;\n\t}\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);\n\nvoid lxc_abort(const char *name, struct lxc_handler *handler)\n{\n\tint ret, status;\n\n\tlxc_set_state(name, handler, ABORTING);\n\tif (handler->pid > 0)\n\t\tkill(handler->pid, SIGKILL);\n\twhile ((ret = waitpid(-1, &status, 0)) > 0) {\n\t\t;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_delete_network",
          "args": [
            "handler"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_delete_network",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "2971-3048",
          "snippet": "bool lxc_delete_network(struct lxc_handler *handler)\n{\n\tint ret;\n\tstruct lxc_list *network = &handler->conf->network;\n\tstruct lxc_list *iterator;\n\tstruct lxc_netdev *netdev;\n\tbool deleted_all = true;\n\n\tlxc_list_for_each(iterator, network) {\n\t\tnetdev = iterator->elem;\n\n\t\tif (netdev->ifindex != 0 && netdev->type == LXC_NET_PHYS) {\n\t\t\tif (lxc_netdev_rename_by_index(netdev->ifindex, netdev->link))\n\t\t\t\tWARN(\"Failed to rename interface with index %d \"\n\t\t\t\t     \"to its initial name \\\"%s\\\".\",\n\t\t\t\t     netdev->ifindex, netdev->link);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (netdev_deconf[netdev->type](handler, netdev)) {\n\t\t\tWARN(\"Failed to destroy netdev\");\n\t\t}\n\n\t\t/* Recent kernel remove the virtual interfaces when the network\n\t\t * namespace is destroyed but in case we did not moved the\n\t\t * interface to the network namespace, we have to destroy it\n\t\t */\n\t\tif (netdev->ifindex != 0) {\n\t\t\tret = lxc_netdev_delete_by_index(netdev->ifindex);\n\t\t\tif (-ret == ENODEV) {\n\t\t\t\tINFO(\"Interface \\\"%s\\\" with index %d already \"\n\t\t\t\t     \"deleted or existing in different network \"\n\t\t\t\t     \"namespace.\",\n\t\t\t\t     netdev->name ? netdev->name : \"(null)\",\n\t\t\t\t     netdev->ifindex);\n\t\t\t} else if (ret < 0) {\n\t\t\t\tdeleted_all = false;\n\t\t\t\tWARN(\"Failed to remove interface \\\"%s\\\" with \"\n\t\t\t\t     \"index %d: %s.\",\n\t\t\t\t     netdev->name ? netdev->name : \"(null)\",\n\t\t\t\t     netdev->ifindex, strerror(-ret));\n\t\t\t} else {\n\t\t\t\tINFO(\"Removed interface \\\"%s\\\" with index %d.\",\n\t\t\t\t     netdev->name ? netdev->name : \"(null)\",\n\t\t\t\t     netdev->ifindex);\n\t\t\t}\n\t\t}\n\n\t\t/* Explicitly delete host veth device to prevent lingering\n\t\t * devices. We had issues in LXD around this.\n\t\t */\n\t\tif (netdev->type == LXC_NET_VETH) {\n\t\t\tchar *hostveth;\n\t\t\tif (netdev->priv.veth_attr.pair) {\n\t\t\t\thostveth = netdev->priv.veth_attr.pair;\n\t\t\t\tret = lxc_netdev_delete_by_name(hostveth);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tWARN(\"Failed to remove interface \\\"%s\\\" from host: %s.\", hostveth, strerror(-ret));\n\t\t\t\t} else {\n\t\t\t\t\tINFO(\"Removed interface \\\"%s\\\" from host.\", hostveth);\n\t\t\t\t\tfree(netdev->priv.veth_attr.pair);\n\t\t\t\t\tnetdev->priv.veth_attr.pair = NULL;\n\t\t\t\t}\n\t\t\t} else if (strlen(netdev->priv.veth_attr.veth1) > 0) {\n\t\t\t\thostveth = netdev->priv.veth_attr.veth1;\n\t\t\t\tret = lxc_netdev_delete_by_name(hostveth);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tWARN(\"Failed to remove \\\"%s\\\" from host: %s.\", hostveth, strerror(-ret));\n\t\t\t\t} else {\n\t\t\t\t\tINFO(\"Removed interface \\\"%s\\\" from host.\", hostveth);\n\t\t\t\t\tmemset((void *)&netdev->priv.veth_attr.veth1, 0, sizeof(netdev->priv.veth_attr.veth1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn deleted_all;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_none(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_none(struct lxc_handler *, struct lxc_netdev *);",
            "static  instantiate_cb netdev_deconf[LXC_NET_MAXCONFTYPE + 1] = {\n\t[LXC_NET_VETH]    = shutdown_veth,\n\t[LXC_NET_MACVLAN] = shutdown_macvlan,\n\t[LXC_NET_VLAN]    = shutdown_vlan,\n\t[LXC_NET_PHYS]    = shutdown_phys,\n\t[LXC_NET_EMPTY]   = shutdown_empty,\n\t[LXC_NET_NONE]    = shutdown_none,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_none(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_none(struct lxc_handler *, struct lxc_netdev *);\nstatic  instantiate_cb netdev_deconf[LXC_NET_MAXCONFTYPE + 1] = {\n\t[LXC_NET_VETH]    = shutdown_veth,\n\t[LXC_NET_MACVLAN] = shutdown_macvlan,\n\t[LXC_NET_VLAN]    = shutdown_vlan,\n\t[LXC_NET_PHYS]    = shutdown_phys,\n\t[LXC_NET_EMPTY]   = shutdown_empty,\n\t[LXC_NET_NONE]    = shutdown_none,\n};\n\nbool lxc_delete_network(struct lxc_handler *handler)\n{\n\tint ret;\n\tstruct lxc_list *network = &handler->conf->network;\n\tstruct lxc_list *iterator;\n\tstruct lxc_netdev *netdev;\n\tbool deleted_all = true;\n\n\tlxc_list_for_each(iterator, network) {\n\t\tnetdev = iterator->elem;\n\n\t\tif (netdev->ifindex != 0 && netdev->type == LXC_NET_PHYS) {\n\t\t\tif (lxc_netdev_rename_by_index(netdev->ifindex, netdev->link))\n\t\t\t\tWARN(\"Failed to rename interface with index %d \"\n\t\t\t\t     \"to its initial name \\\"%s\\\".\",\n\t\t\t\t     netdev->ifindex, netdev->link);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (netdev_deconf[netdev->type](handler, netdev)) {\n\t\t\tWARN(\"Failed to destroy netdev\");\n\t\t}\n\n\t\t/* Recent kernel remove the virtual interfaces when the network\n\t\t * namespace is destroyed but in case we did not moved the\n\t\t * interface to the network namespace, we have to destroy it\n\t\t */\n\t\tif (netdev->ifindex != 0) {\n\t\t\tret = lxc_netdev_delete_by_index(netdev->ifindex);\n\t\t\tif (-ret == ENODEV) {\n\t\t\t\tINFO(\"Interface \\\"%s\\\" with index %d already \"\n\t\t\t\t     \"deleted or existing in different network \"\n\t\t\t\t     \"namespace.\",\n\t\t\t\t     netdev->name ? netdev->name : \"(null)\",\n\t\t\t\t     netdev->ifindex);\n\t\t\t} else if (ret < 0) {\n\t\t\t\tdeleted_all = false;\n\t\t\t\tWARN(\"Failed to remove interface \\\"%s\\\" with \"\n\t\t\t\t     \"index %d: %s.\",\n\t\t\t\t     netdev->name ? netdev->name : \"(null)\",\n\t\t\t\t     netdev->ifindex, strerror(-ret));\n\t\t\t} else {\n\t\t\t\tINFO(\"Removed interface \\\"%s\\\" with index %d.\",\n\t\t\t\t     netdev->name ? netdev->name : \"(null)\",\n\t\t\t\t     netdev->ifindex);\n\t\t\t}\n\t\t}\n\n\t\t/* Explicitly delete host veth device to prevent lingering\n\t\t * devices. We had issues in LXD around this.\n\t\t */\n\t\tif (netdev->type == LXC_NET_VETH) {\n\t\t\tchar *hostveth;\n\t\t\tif (netdev->priv.veth_attr.pair) {\n\t\t\t\thostveth = netdev->priv.veth_attr.pair;\n\t\t\t\tret = lxc_netdev_delete_by_name(hostveth);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tWARN(\"Failed to remove interface \\\"%s\\\" from host: %s.\", hostveth, strerror(-ret));\n\t\t\t\t} else {\n\t\t\t\t\tINFO(\"Removed interface \\\"%s\\\" from host.\", hostveth);\n\t\t\t\t\tfree(netdev->priv.veth_attr.pair);\n\t\t\t\t\tnetdev->priv.veth_attr.pair = NULL;\n\t\t\t\t}\n\t\t\t} else if (strlen(netdev->priv.veth_attr.veth1) > 0) {\n\t\t\t\thostveth = netdev->priv.veth_attr.veth1;\n\t\t\t\tret = lxc_netdev_delete_by_name(hostveth);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tWARN(\"Failed to remove \\\"%s\\\" from host: %s.\", hostveth, strerror(-ret));\n\t\t\t\t} else {\n\t\t\t\t\tINFO(\"Removed interface \\\"%s\\\" from host.\", hostveth);\n\t\t\t\t\tmemset((void *)&netdev->priv.veth_attr.veth1, 0, sizeof(netdev->priv.veth_attr.veth1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn deleted_all;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_disconnect",
          "args": [],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgroup.c",
          "lines": "200-204",
          "snippet": "void cgroup_disconnect(void)\n{\n\tif (ops && ops->disconnect)\n\t\tops->disconnect();\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"log.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_ops *ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"log.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <unistd.h>\n\nstatic struct cgroup_ops *ops = NULL;\n\nvoid cgroup_disconnect(void)\n{\n\tif (ops && ops->disconnect)\n\t\tops->disconnect();\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_preserve_ns",
          "args": [
            "handler->pid",
            "\"net\""
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_preserve_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1965-1983",
          "snippet": "int lxc_preserve_ns(const int pid, const char *ns)\n{\n\tint ret;\n/* 5 /proc + 21 /int_as_str + 3 /ns + 20 /NS_NAME + 1 \\0 */\n#define __NS_PATH_LEN 50\n\tchar path[__NS_PATH_LEN];\n\n\t/* This way we can use this function to also check whether namespaces\n\t * are supported by the kernel by passing in the NULL or the empty\n\t * string.\n\t */\n\tret = snprintf(path, __NS_PATH_LEN, \"/proc/%d/ns%s%s\", pid,\n\t\t       !ns || strcmp(ns, \"\") == 0 ? \"\" : \"/\",\n\t\t       !ns || strcmp(ns, \"\") == 0 ? \"\" : ns);\n\tif (ret < 0 || (size_t)ret >= __NS_PATH_LEN)\n\t\treturn -1;\n\n\treturn open(path, O_RDONLY | O_CLOEXEC);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define __NS_PATH_LEN 50"
          ],
          "globals_used": [
            "extern bool btrfs_try_remove_subvol(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\n#define __NS_PATH_LEN 50\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nint lxc_preserve_ns(const int pid, const char *ns)\n{\n\tint ret;\n/* 5 /proc + 21 /int_as_str + 3 /ns + 20 /NS_NAME + 1 \\0 */\n#define __NS_PATH_LEN 50\n\tchar path[__NS_PATH_LEN];\n\n\t/* This way we can use this function to also check whether namespaces\n\t * are supported by the kernel by passing in the NULL or the empty\n\t * string.\n\t */\n\tret = snprintf(path, __NS_PATH_LEN, \"/proc/%d/ns%s%s\", pid,\n\t\t       !ns || strcmp(ns, \"\") == 0 ? \"\" : \"/\",\n\t\t       !ns || strcmp(ns, \"\") == 0 ? \"\" : ns);\n\tif (ret < 0 || (size_t)ret >= __NS_PATH_LEN)\n\t\treturn -1;\n\n\treturn open(path, O_RDONLY | O_CLOEXEC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to set state for container \\\"%s\\\" to \\\"%s\\\".\"",
            "name",
            "lxc_state2str(RUNNING)"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_state2str",
          "args": [
            "RUNNING"
          ],
          "line": 1295
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_state2str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/state.c",
          "lines": "52-57",
          "snippet": "const char *lxc_state2str(lxc_state_t state)\n{\n\tif (state < STOPPED || state > MAX_STATE - 1)\n\t\treturn NULL;\n\treturn strstate[state];\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"monitor.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const strstate[] = {\n\t\"STOPPED\", \"STARTING\", \"RUNNING\", \"STOPPING\",\n\t\"ABORTING\", \"FREEZING\", \"FROZEN\", \"THAWED\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"monitor.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic const char * const strstate[] = {\n\t\"STOPPED\", \"STARTING\", \"RUNNING\", \"STOPPING\",\n\t\"ABORTING\", \"FREEZING\", \"FROZEN\", \"THAWED\",\n};\n\nconst char *lxc_state2str(lxc_state_t state)\n{\n\tif (state < STOPPED || state > MAX_STATE - 1)\n\t\treturn NULL;\n\treturn strstate[state];\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_set_state",
          "args": [
            "name",
            "handler",
            "RUNNING"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_set_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "344-349",
          "snippet": "int lxc_set_state(const char *name, struct lxc_handler *handler, lxc_state_t state)\n{\n\thandler->state = state;\n\tlxc_monitor_send_state(name, state, handler->lxcpath);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);\n\nint lxc_set_state(const char *name, struct lxc_handler *handler, lxc_state_t state)\n{\n\thandler->state = state;\n\tlxc_monitor_send_state(name, state, handler->lxcpath);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handler->ops->post_start",
          "args": [
            "handler",
            "handler->data"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "post_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "1464-1470",
          "snippet": "static int post_start(struct lxc_handler *handler, void* data)\n{\n\tstruct start_args *arg = data;\n\n\tNOTICE(\"Started \\\"%s\\\" with pid \\\"%d\\\".\", arg->argv[0], handler->pid);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int lxc_rmdir_onedev_wrapper(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic int lxc_rmdir_onedev_wrapper(void *data);\n\nstatic int post_start(struct lxc_handler *handler, void* data)\n{\n\tstruct start_args *arg = data;\n\n\tNOTICE(\"Started \\\"%s\\\" with pid \\\"%d\\\".\", arg->argv[0], handler->pid);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "umount2",
          "args": [
            "handler->conf->rootfs.mount",
            "MNT_DETACH"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "detect_shared_rootfs",
          "args": [],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "detect_shared_rootfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1102-1132",
          "snippet": "int detect_shared_rootfs(void)\n{\n\tchar buf[LXC_LINELEN], *p;\n\tFILE *f;\n\tint i;\n\tchar *p2;\n\n\tf = fopen(\"/proc/self/mountinfo\", \"r\");\n\tif (!f)\n\t\treturn 0;\n\twhile (fgets(buf, LXC_LINELEN, f)) {\n\t\tfor (p = buf, i = 0; p && i < 4; i++)\n\t\t\tp = strchr(p + 1, ' ');\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tp2 = strchr(p + 1, ' ');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\t\tif (strcmp(p + 1, \"/\") == 0) {\n\t\t\t// this is '/'.  is it shared?\n\t\t\tp = strchr(p2 + 1, ' ');\n\t\t\tif (p && strstr(p, \"shared:\")) {\n\t\t\t\tfclose(f);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tfclose(f);\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint detect_shared_rootfs(void)\n{\n\tchar buf[LXC_LINELEN], *p;\n\tFILE *f;\n\tint i;\n\tchar *p2;\n\n\tf = fopen(\"/proc/self/mountinfo\", \"r\");\n\tif (!f)\n\t\treturn 0;\n\twhile (fgets(buf, LXC_LINELEN, f)) {\n\t\tfor (p = buf, i = 0; p && i < 4; i++)\n\t\t\tp = strchr(p + 1, ' ');\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tp2 = strchr(p + 1, ' ');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\t\tif (strcmp(p + 1, \"/\") == 0) {\n\t\t\t// this is '/'.  is it shared?\n\t\t\tp = strchr(p2 + 1, ' ');\n\t\t\tif (p && strstr(p, \"shared:\")) {\n\t\t\t\tfclose(f);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tfclose(f);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_sync_barrier_child",
          "args": [
            "handler",
            "LXC_SYNC_POST_CGROUP"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_sync_barrier_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/sync.c",
          "lines": "92-95",
          "snippet": "int lxc_sync_barrier_child(struct lxc_handler *handler, int sequence)\n{\n\treturn __sync_barrier(handler->sv[1], sequence);\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"log.h\"",
            "#include \"sync.h\"",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"log.h\"\n#include \"sync.h\"\n#include <fcntl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n\nint lxc_sync_barrier_child(struct lxc_handler *handler, int sequence)\n{\n\treturn __sync_barrier(handler->sv[1], sequence);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to receive tty info from child process.\""
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv_ttys_from_child",
          "args": [
            "handler"
          ],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "recv_ttys_from_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "1022-1047",
          "snippet": "static int recv_ttys_from_child(struct lxc_handler *handler)\n{\n\tstruct lxc_conf *conf = handler->conf;\n\tint i, sock = handler->ttysock[1];\n\tstruct lxc_tty_info *tty_info = &conf->tty_info;\n\n\tif (!conf->tty)\n\t\treturn 0;\n\n\ttty_info->pty_info = malloc(sizeof(*tty_info->pty_info) * conf->tty);\n\tif (!tty_info->pty_info)\n\t\treturn -1;\n\n\tfor (i = 0; i < conf->tty; i++) {\n\t\tstruct lxc_pty_info *pty_info = &tty_info->pty_info[i];\n\t\tpty_info->busy = 0;\n\t\tif (recv_fd(sock, &pty_info->slave) < 0 ||\n\t\t    recv_fd(sock, &pty_info->master) < 0) {\n\t\t\tERROR(\"Error receiving tty info from child process.\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\ttty_info->nbtty = conf->tty;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_destroy_container(struct lxc_conf *conf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic bool do_destroy_container(struct lxc_conf *conf);\n\nstatic int recv_ttys_from_child(struct lxc_handler *handler)\n{\n\tstruct lxc_conf *conf = handler->conf;\n\tint i, sock = handler->ttysock[1];\n\tstruct lxc_tty_info *tty_info = &conf->tty_info;\n\n\tif (!conf->tty)\n\t\treturn 0;\n\n\ttty_info->pty_info = malloc(sizeof(*tty_info->pty_info) * conf->tty);\n\tif (!tty_info->pty_info)\n\t\treturn -1;\n\n\tfor (i = 0; i < conf->tty; i++) {\n\t\tstruct lxc_pty_info *pty_info = &tty_info->pty_info[i];\n\t\tpty_info->busy = 0;\n\t\tif (recv_fd(sock, &pty_info->slave) < 0 ||\n\t\t    recv_fd(sock, &pty_info->master) < 0) {\n\t\t\tERROR(\"Error receiving tty info from child process.\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\ttty_info->nbtty = conf->tty;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to setup the devices cgroup for container \\\"%s\\\".\"",
            "name"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_setup_limits",
          "args": [
            "handler",
            "true"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_setup_limits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgroup.c",
          "lines": "145-151",
          "snippet": "bool cgroup_setup_limits(struct lxc_handler *handler, bool with_devices)\n{\n\tif (ops)\n\t\treturn ops->setup_limits(handler->cgroup_data,\n\t\t\t\t\t &handler->conf->cgroup, with_devices);\n\treturn false;\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"log.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_ops *ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"log.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <unistd.h>\n\nstatic struct cgroup_ops *ops = NULL;\n\nbool cgroup_setup_limits(struct lxc_handler *handler, bool with_devices)\n{\n\tif (ops)\n\t\treturn ops->setup_limits(handler->cgroup_data,\n\t\t\t\t\t &handler->conf->cgroup, with_devices);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error writing veth name to container.\""
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "netpipepair[1]",
            "netdev->name",
            "IFNAMSIZ"
          ],
          "line": 1250
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_nointr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "327-335",
          "snippet": "ssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "iterator",
            "&handler->conf->network"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to create the configured network.\""
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_assign_network",
          "args": [
            "handler->lxcpath",
            "handler->name",
            "&handler->conf->network",
            "handler->pid"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_assign_network",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3159-3202",
          "snippet": "int lxc_assign_network(const char *lxcpath, char *lxcname,\n\t\t       struct lxc_list *network, pid_t pid)\n{\n\tstruct lxc_list *iterator;\n\tstruct lxc_netdev *netdev;\n\tchar ifname[IFNAMSIZ];\n\tint am_root = (getuid() == 0);\n\tint err;\n\n\tlxc_list_for_each(iterator, network) {\n\n\t\tnetdev = iterator->elem;\n\n\t\tif (netdev->type == LXC_NET_VETH && !am_root) {\n\t\t\tif (unpriv_assign_nic(lxcpath, lxcname, netdev, pid))\n\t\t\t\treturn -1;\n\t\t\t// lxc-user-nic has moved the nic to the new ns.\n\t\t\t// unpriv_assign_nic() fills in netdev->name.\n\t\t\t// netdev->ifindex will be filed in at setup_netdev.\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* empty network namespace, nothing to move */\n\t\tif (!netdev->ifindex)\n\t\t\tcontinue;\n\n\t\t/* retrieve the name of the interface */\n\t\tif (!if_indextoname(netdev->ifindex, ifname)) {\n\t\t\tERROR(\"no interface corresponding to index '%d'\", netdev->ifindex);\n\t\t\treturn -1;\n\t\t}\n\n\t\terr = lxc_netdev_move_by_name(ifname, pid, NULL);\n\t\tif (err) {\n\t\t\tERROR(\"failed to move '%s' to the container : %s\",\n\t\t\t      netdev->link, strerror(-err));\n\t\t\treturn -1;\n\t\t}\n\n\t\tDEBUG(\"move '%s'/'%s' to '%d': .\", ifname, netdev->name, pid);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_none(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_none(struct lxc_handler *, struct lxc_netdev *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_none(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_none(struct lxc_handler *, struct lxc_netdev *);\n\nint lxc_assign_network(const char *lxcpath, char *lxcname,\n\t\t       struct lxc_list *network, pid_t pid)\n{\n\tstruct lxc_list *iterator;\n\tstruct lxc_netdev *netdev;\n\tchar ifname[IFNAMSIZ];\n\tint am_root = (getuid() == 0);\n\tint err;\n\n\tlxc_list_for_each(iterator, network) {\n\n\t\tnetdev = iterator->elem;\n\n\t\tif (netdev->type == LXC_NET_VETH && !am_root) {\n\t\t\tif (unpriv_assign_nic(lxcpath, lxcname, netdev, pid))\n\t\t\t\treturn -1;\n\t\t\t// lxc-user-nic has moved the nic to the new ns.\n\t\t\t// unpriv_assign_nic() fills in netdev->name.\n\t\t\t// netdev->ifindex will be filed in at setup_netdev.\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* empty network namespace, nothing to move */\n\t\tif (!netdev->ifindex)\n\t\t\tcontinue;\n\n\t\t/* retrieve the name of the interface */\n\t\tif (!if_indextoname(netdev->ifindex, ifname)) {\n\t\t\tERROR(\"no interface corresponding to index '%d'\", netdev->ifindex);\n\t\t\treturn -1;\n\t\t}\n\n\t\terr = lxc_netdev_move_by_name(ifname, pid, NULL);\n\t\tif (err) {\n\t\t\tERROR(\"failed to move '%s' to the container : %s\",\n\t\t\t      netdev->link, strerror(-err));\n\t\t\treturn -1;\n\t\t}\n\n\t\tDEBUG(\"move '%s'/'%s' to '%d': .\", ifname, netdev->name, pid);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_chown",
          "args": [
            "handler"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_chown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgroup.c",
          "lines": "153-158",
          "snippet": "bool cgroup_chown(struct lxc_handler *handler)\n{\n\tif (ops && ops->chown)\n\t\treturn ops->chown(handler->cgroup_data, handler->conf);\n\treturn true;\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"log.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_ops *ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"log.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <unistd.h>\n\nstatic struct cgroup_ops *ops = NULL;\n\nbool cgroup_chown(struct lxc_handler *handler)\n{\n\tif (ops && ops->chown)\n\t\treturn ops->chown(handler->cgroup_data, handler->conf);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_enter",
          "args": [
            "handler"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgroup.c",
          "lines": "94-99",
          "snippet": "bool cgroup_enter(struct lxc_handler *handler)\n{\n\tif (ops)\n\t\treturn ops->enter(handler->cgroup_data, handler->pid);\n\treturn false;\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"log.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_ops *ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"log.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <unistd.h>\n\nstatic struct cgroup_ops *ops = NULL;\n\nbool cgroup_enter(struct lxc_handler *handler)\n{\n\tif (ops)\n\t\treturn ops->enter(handler->cgroup_data, handler->pid);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to setup cgroup limits for container \\\"%s\\\".\"",
            "name"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to setup legacy cgroups for container \\\"%s\\\".\"",
            "name"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_create_legacy",
          "args": [
            "handler"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_create_legacy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgroup.c",
          "lines": "101-106",
          "snippet": "bool cgroup_create_legacy(struct lxc_handler *handler)\n{\n\tif (ops && ops->create_legacy)\n\t\treturn ops->create_legacy(handler->cgroup_data, handler->pid);\n\treturn true;\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"log.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_ops *ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"log.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <unistd.h>\n\nstatic struct cgroup_ops *ops = NULL;\n\nbool cgroup_create_legacy(struct lxc_handler *handler)\n{\n\tif (ops && ops->create_legacy)\n\t\treturn ops->create_legacy(handler->cgroup_data, handler->pid);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_sync_wait_child",
          "args": [
            "handler",
            "LXC_SYNC_CONFIGURE"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_sync_wait_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/sync.c",
          "lines": "107-110",
          "snippet": "int lxc_sync_wait_child(struct lxc_handler *handler, int sequence)\n{\n\treturn __sync_wait(handler->sv[1], sequence);\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"log.h\"",
            "#include \"sync.h\"",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"log.h\"\n#include \"sync.h\"\n#include <fcntl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n\nint lxc_sync_wait_child(struct lxc_handler *handler, int sequence)\n{\n\treturn __sync_wait(handler->sv[1], sequence);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_sync_wake_child",
          "args": [
            "handler",
            "LXC_SYNC_STARTUP"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_sync_wake_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/sync.c",
          "lines": "112-115",
          "snippet": "int lxc_sync_wake_child(struct lxc_handler *handler, int sequence)\n{\n\treturn __sync_wake(handler->sv[1], sequence);\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"log.h\"",
            "#include \"sync.h\"",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"log.h\"\n#include \"sync.h\"\n#include <fcntl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n\nint lxc_sync_wake_child(struct lxc_handler *handler, int sequence)\n{\n\treturn __sync_wake(handler->sv[1], sequence);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to set up id mapping.\""
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_map_ids",
          "args": [
            "&handler->conf->id_map",
            "handler->pid"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_map_ids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3230-3305",
          "snippet": "int lxc_map_ids(struct lxc_list *idmap, pid_t pid)\n{\n\tstruct lxc_list *iterator;\n\tstruct id_map *map;\n\tint ret = 0, use_shadow = 0;\n\tenum idtype type;\n\tchar *buf = NULL, *pos, *cmdpath = NULL;\n\n\t/*\n\t * If newuidmap exists, that is, if shadow is handing out subuid\n\t * ranges, then insist that root also reserve ranges in subuid.  This\n\t * will protected it by preventing another user from being handed the\n\t * range by shadow.\n\t */\n\tcmdpath = on_path(\"newuidmap\", NULL);\n\tif (cmdpath) {\n\t\tuse_shadow = 1;\n\t\tfree(cmdpath);\n\t}\n\n\tif (!use_shadow && geteuid()) {\n\t\tERROR(\"Missing newuidmap/newgidmap\");\n\t\treturn -1;\n\t}\n\n\tfor(type = ID_TYPE_UID; type <= ID_TYPE_GID; type++) {\n\t\tint left, fill;\n\t\tint had_entry = 0;\n\t\tif (!buf) {\n\t\t\tbuf = pos = malloc(4096);\n\t\t\tif (!buf)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tpos = buf;\n\t\tif (use_shadow)\n\t\t\tpos += sprintf(buf, \"new%cidmap %d\",\n\t\t\t\ttype == ID_TYPE_UID ? 'u' : 'g',\n\t\t\t\tpid);\n\n\t\tlxc_list_for_each(iterator, idmap) {\n\t\t\t/* The kernel only takes <= 4k for writes to /proc/<nr>/[ug]id_map */\n\t\t\tmap = iterator->elem;\n\t\t\tif (map->idtype != type)\n\t\t\t\tcontinue;\n\n\t\t\thad_entry = 1;\n\t\t\tleft = 4096 - (pos - buf);\n\t\t\tfill = snprintf(pos, left, \"%s%lu %lu %lu%s\",\n\t\t\t\t\tuse_shadow ? \" \" : \"\",\n\t\t\t\t\tmap->nsid, map->hostid, map->range,\n\t\t\t\t\tuse_shadow ? \"\" : \"\\n\");\n\t\t\tif (fill <= 0 || fill >= left)\n\t\t\t\tSYSERROR(\"snprintf failed, too many mappings\");\n\t\t\tpos += fill;\n\t\t}\n\t\tif (!had_entry)\n\t\t\tcontinue;\n\n\t\tif (!use_shadow) {\n\t\t\tret = write_id_mapping(type, pid, buf, pos-buf);\n\t\t} else {\n\t\t\tleft = 4096 - (pos - buf);\n\t\t\tfill = snprintf(pos, left, \"\\n\");\n\t\t\tif (fill <= 0 || fill >= left)\n\t\t\t\tSYSERROR(\"snprintf failed, too many mappings\");\n\t\t\tpos += fill;\n\t\t\tret = system(buf);\n\t\t}\n\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tfree(buf);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_map_ids(struct lxc_list *idmap, pid_t pid)\n{\n\tstruct lxc_list *iterator;\n\tstruct id_map *map;\n\tint ret = 0, use_shadow = 0;\n\tenum idtype type;\n\tchar *buf = NULL, *pos, *cmdpath = NULL;\n\n\t/*\n\t * If newuidmap exists, that is, if shadow is handing out subuid\n\t * ranges, then insist that root also reserve ranges in subuid.  This\n\t * will protected it by preventing another user from being handed the\n\t * range by shadow.\n\t */\n\tcmdpath = on_path(\"newuidmap\", NULL);\n\tif (cmdpath) {\n\t\tuse_shadow = 1;\n\t\tfree(cmdpath);\n\t}\n\n\tif (!use_shadow && geteuid()) {\n\t\tERROR(\"Missing newuidmap/newgidmap\");\n\t\treturn -1;\n\t}\n\n\tfor(type = ID_TYPE_UID; type <= ID_TYPE_GID; type++) {\n\t\tint left, fill;\n\t\tint had_entry = 0;\n\t\tif (!buf) {\n\t\t\tbuf = pos = malloc(4096);\n\t\t\tif (!buf)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tpos = buf;\n\t\tif (use_shadow)\n\t\t\tpos += sprintf(buf, \"new%cidmap %d\",\n\t\t\t\ttype == ID_TYPE_UID ? 'u' : 'g',\n\t\t\t\tpid);\n\n\t\tlxc_list_for_each(iterator, idmap) {\n\t\t\t/* The kernel only takes <= 4k for writes to /proc/<nr>/[ug]id_map */\n\t\t\tmap = iterator->elem;\n\t\t\tif (map->idtype != type)\n\t\t\t\tcontinue;\n\n\t\t\thad_entry = 1;\n\t\t\tleft = 4096 - (pos - buf);\n\t\t\tfill = snprintf(pos, left, \"%s%lu %lu %lu%s\",\n\t\t\t\t\tuse_shadow ? \" \" : \"\",\n\t\t\t\t\tmap->nsid, map->hostid, map->range,\n\t\t\t\t\tuse_shadow ? \"\" : \"\\n\");\n\t\t\tif (fill <= 0 || fill >= left)\n\t\t\t\tSYSERROR(\"snprintf failed, too many mappings\");\n\t\t\tpos += fill;\n\t\t}\n\t\tif (!had_entry)\n\t\t\tcontinue;\n\n\t\tif (!use_shadow) {\n\t\t\tret = write_id_mapping(type, pid, buf, pos-buf);\n\t\t} else {\n\t\t\tleft = 4096 - (pos - buf);\n\t\t\tfill = snprintf(pos, left, \"\\n\");\n\t\t\tif (fill <= 0 || fill >= left)\n\t\t\t\tSYSERROR(\"snprintf failed, too many mappings\");\n\t\t\tpos += fill;\n\t\t\tret = system(buf);\n\t\t}\n\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tfree(buf);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_sync_fini_child",
          "args": [
            "handler"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_sync_fini_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/sync.c",
          "lines": "133-139",
          "snippet": "void lxc_sync_fini_child(struct lxc_handler *handler)\n{\n\tif (handler->sv[0] != -1) {\n\t\tclose(handler->sv[0]);\n\t\thandler->sv[0] = -1;\n\t}\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"log.h\"",
            "#include \"sync.h\"",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"log.h\"\n#include \"sync.h\"\n#include <fcntl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n\nvoid lxc_sync_fini_child(struct lxc_handler *handler)\n{\n\tif (handler->sv[0] != -1) {\n\t\tclose(handler->sv[0]);\n\t\thandler->sv[0] = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to restore saved namespaces.\""
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "attach_ns",
          "args": [
            "saved_ns_fd"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "attach_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "168-183",
          "snippet": "static int attach_ns(const int ns_fd[LXC_NS_MAX]) {\n\tint i;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (ns_fd[i] < 0)\n\t\t\tcontinue;\n\n\t\tif (setns(ns_fd[i], 0) != 0)\n\t\t\tgoto error;\n\t}\n\treturn 0;\n\nerror:\n\tSYSERROR(\"Failed to attach %s namespace.\", ns_info[i].proc_name);\n\treturn -1;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic int attach_ns(const int ns_fd[LXC_NS_MAX]) {\n\tint i;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (ns_fd[i] < 0)\n\t\t\tcontinue;\n\n\t\tif (setns(ns_fd[i], 0) != 0)\n\t\t\tgoto error;\n\t}\n\treturn 0;\n\nerror:\n\tSYSERROR(\"Failed to attach %s namespace.\", ns_info[i].proc_name);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Failed to preserve namespace for lxc.hook.stop.\""
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preserve_ns",
          "args": [
            "handler->nsfd",
            "handler->clone_flags | preserve_mask",
            "handler->pid"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "preserve_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "134-166",
          "snippet": "static bool preserve_ns(int ns_fd[LXC_NS_MAX], int clone_flags, pid_t pid)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++)\n\t\tns_fd[i] = -1;\n\n\tret = lxc_preserve_ns(pid, \"\");\n\tif (ret < 0) {\n\t\tSYSERROR(\"Kernel does not support attaching to namespaces.\");\n\t\treturn false;\n\t} else {\n\t\tclose(ret);\n\t}\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif ((clone_flags & ns_info[i].clone_flag) == 0)\n\t\t\tcontinue;\n\t\tns_fd[i] = lxc_preserve_ns(pid, ns_info[i].proc_name);\n\t\tif (ns_fd[i] < 0)\n\t\t\tgoto error;\n\t}\n\n\treturn true;\n\nerror:\n\tif (errno == ENOENT)\n\t\tSYSERROR(\"Kernel does not support attaching to %s namespaces.\", ns_info[i].proc_name);\n\telse\n\t\tSYSERROR(\"Failed to open file descriptor for %s namespace: %s.\", ns_info[i].proc_name, strerror(errno));\n\tclose_ns(ns_fd);\n\treturn false;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic bool preserve_ns(int ns_fd[LXC_NS_MAX], int clone_flags, pid_t pid)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++)\n\t\tns_fd[i] = -1;\n\n\tret = lxc_preserve_ns(pid, \"\");\n\tif (ret < 0) {\n\t\tSYSERROR(\"Kernel does not support attaching to namespaces.\");\n\t\treturn false;\n\t} else {\n\t\tclose(ret);\n\t}\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif ((clone_flags & ns_info[i].clone_flag) == 0)\n\t\t\tcontinue;\n\t\tns_fd[i] = lxc_preserve_ns(pid, ns_info[i].proc_name);\n\t\tif (ns_fd[i] < 0)\n\t\t\tgoto error;\n\t}\n\n\treturn true;\n\nerror:\n\tif (errno == ENOENT)\n\t\tSYSERROR(\"Kernel does not support attaching to %s namespaces.\", ns_info[i].proc_name);\n\telse\n\t\tSYSERROR(\"Failed to open file descriptor for %s namespace: %s.\", ns_info[i].proc_name, strerror(errno));\n\tclose_ns(ns_fd);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Cloned %s.\"",
            "ns_info[i].flag_name"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to clone a new set of namespaces.\""
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_clone",
          "args": [
            "do_start",
            "handler",
            "flags"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_clone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/namespace.c",
          "lines": "49-70",
          "snippet": "pid_t lxc_clone(int (*fn)(void *), void *arg, int flags)\n{\n\tstruct clone_arg clone_arg = {\n\t\t.fn = fn,\n\t\t.arg = arg,\n\t};\n\n\tsize_t stack_size = sysconf(_SC_PAGESIZE);\n\tvoid *stack = alloca(stack_size);\n\tpid_t ret;\n\n#ifdef __ia64__\n\tret = __clone2(do_clone, stack,\n\t\t       stack_size, flags | SIGCHLD, &clone_arg);\n#else\n\tret = clone(do_clone, stack  + stack_size, flags | SIGCHLD, &clone_arg);\n#endif\n\tif (ret < 0)\n\t\tERROR(\"Failed to clone (%#x): %s.\", flags, strerror(errno));\n\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"namespace.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <alloca.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"namespace.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <signal.h>\n#include <errno.h>\n#include <alloca.h>\n#include <unistd.h>\n\npid_t lxc_clone(int (*fn)(void *), void *arg, int flags)\n{\n\tstruct clone_arg clone_arg = {\n\t\t.fn = fn,\n\t\t.arg = arg,\n\t};\n\n\tsize_t stack_size = sysconf(_SC_PAGESIZE);\n\tvoid *stack = alloca(stack_size);\n\tpid_t ret;\n\n#ifdef __ia64__\n\tret = __clone2(do_clone, stack,\n\t\t       stack_size, flags | SIGCHLD, &clone_arg);\n#else\n\tret = clone(do_clone, stack  + stack_size, flags | SIGCHLD, &clone_arg);\n#endif\n\tif (ret < 0)\n\t\tERROR(\"Failed to clone (%#x): %s.\", flags, strerror(errno));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to create pipe.\""
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "netpipepair"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_veths",
          "args": [
            "&handler->conf->network"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "count_veths",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "676-689",
          "snippet": "static inline int count_veths(struct lxc_list *network)\n{\n\tstruct lxc_list *iterator;\n\tstruct lxc_netdev *netdev;\n\tint count = 0;\n\n\tlxc_list_for_each(iterator, network) {\n\t\tnetdev = iterator->elem;\n\t\tif (netdev->type != LXC_NET_VETH)\n\t\t\tcontinue;\n\t\tcount++;\n\t}\n\treturn count;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic inline int count_veths(struct lxc_list *network)\n{\n\tstruct lxc_list *iterator;\n\tstruct lxc_netdev *netdev;\n\tint count = 0;\n\n\tlxc_list_for_each(iterator, network) {\n\t\tnetdev = iterator->elem;\n\t\tif (netdev->type != LXC_NET_VETH)\n\t\t\tcontinue;\n\t\tcount++;\n\t}\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "am_unpriv",
          "args": [],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "am_unpriv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.h",
          "lines": "288-290",
          "snippet": "inline static bool am_unpriv(void) {\n\treturn geteuid() != 0;\n}",
          "includes": [
            "#include <stdint.h>",
            "#  include <sys/signalfd.h>",
            "#include <../include/getline.h>",
            "#include \"initutils.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#  include <sys/signalfd.h>\n#include <../include/getline.h>\n#include \"initutils.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"config.h\"\n\ninline static bool am_unpriv(void) {\n\treturn geteuid() != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Failed to pin the rootfs for container \\\"%s\\\".\"",
            "handler->name"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_rootfs",
          "args": [
            "handler->conf->rootfs.path"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "pin_rootfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "649-680",
          "snippet": "int pin_rootfs(const char *rootfs)\n{\n\tchar absrootfs[MAXPATHLEN];\n\tchar absrootfspin[MAXPATHLEN];\n\tstruct stat s;\n\tint ret, fd;\n\n\tif (rootfs == NULL || strlen(rootfs) == 0)\n\t\treturn -2;\n\n\tif (!realpath(rootfs, absrootfs))\n\t\treturn -2;\n\n\tif (access(absrootfs, F_OK))\n\t\treturn -1;\n\n\tif (stat(absrootfs, &s))\n\t\treturn -1;\n\n\tif (!S_ISDIR(s.st_mode))\n\t\treturn -2;\n\n\tret = snprintf(absrootfspin, MAXPATHLEN, \"%s/lxc.hold\", absrootfs);\n\tif (ret >= MAXPATHLEN)\n\t\treturn -1;\n\n\tfd = open(absrootfspin, O_CREAT | O_RDWR, S_IWUSR|S_IRUSR);\n\tif (fd < 0)\n\t\treturn fd;\n\t(void)unlink(absrootfspin);\n\treturn fd;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint pin_rootfs(const char *rootfs)\n{\n\tchar absrootfs[MAXPATHLEN];\n\tchar absrootfspin[MAXPATHLEN];\n\tstruct stat s;\n\tint ret, fd;\n\n\tif (rootfs == NULL || strlen(rootfs) == 0)\n\t\treturn -2;\n\n\tif (!realpath(rootfs, absrootfs))\n\t\treturn -2;\n\n\tif (access(absrootfs, F_OK))\n\t\treturn -1;\n\n\tif (stat(absrootfs, &s))\n\t\treturn -1;\n\n\tif (!S_ISDIR(s.st_mode))\n\t\treturn -2;\n\n\tret = snprintf(absrootfspin, MAXPATHLEN, \"%s/lxc.hold\", absrootfs);\n\tif (ret >= MAXPATHLEN)\n\t\treturn -1;\n\n\tfd = open(absrootfspin, O_CREAT | O_RDWR, S_IWUSR|S_IRUSR);\n\tif (fd < 0)\n\t\treturn fd;\n\t(void)unlink(absrootfspin);\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_empty",
          "args": [
            "&handler->conf->id_map"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "94-97",
          "snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed creating cgroups.\""
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed initializing cgroup support.\""
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_init",
          "args": [
            "handler"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgroup.c",
          "lines": "60-72",
          "snippet": "bool cgroup_init(struct lxc_handler *handler)\n{\n\tif (handler->cgroup_data) {\n\t\tERROR(\"cgroup_init called on already inited handler\");\n\t\treturn true;\n\t}\n\n\tif (ops) {\n\t\tINFO(\"cgroup driver %s initing for %s\", ops->name, handler->name);\n\t\thandler->cgroup_data = ops->init(handler->name);\n\t}\n\treturn handler->cgroup_data != NULL;\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"log.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_ops *ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"log.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <unistd.h>\n\nstatic struct cgroup_ops *ops = NULL;\n\nbool cgroup_init(struct lxc_handler *handler)\n{\n\tif (handler->cgroup_data) {\n\t\tERROR(\"cgroup_init called on already inited handler\");\n\t\treturn true;\n\t}\n\n\tif (ops) {\n\t\tINFO(\"cgroup driver %s initing for %s\", ops->name, handler->name);\n\t\thandler->cgroup_data = ops->init(handler->name);\n\t}\n\treturn handler->cgroup_data != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to save physical nic info.\""
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_phys_nics",
          "args": [
            "handler->conf"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "save_phys_nics",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "981-1009",
          "snippet": "static int save_phys_nics(struct lxc_conf *conf)\n{\n\tstruct lxc_list *iterator;\n\tint am_root = (getuid() == 0);\n\n\tif (!am_root)\n\t\treturn 0;\n\n\tlxc_list_for_each(iterator, &conf->network) {\n\t\tstruct lxc_netdev *netdev = iterator->elem;\n\n\t\tif (netdev->type != LXC_NET_PHYS)\n\t\t\tcontinue;\n\t\tconf->saved_nics = realloc(conf->saved_nics,\n\t\t\t\t(conf->num_savednics+1)*sizeof(struct saved_nic));\n\t\tif (!conf->saved_nics)\n\t\t\treturn -1;\n\t\tconf->saved_nics[conf->num_savednics].ifindex = netdev->ifindex;\n\t\tconf->saved_nics[conf->num_savednics].orig_name = strdup(netdev->link);\n\t\tif (!conf->saved_nics[conf->num_savednics].orig_name)\n\t\t\treturn -1;\n\t\tINFO(\"Stored saved_nic #%d idx %d name %s.\", conf->num_savednics,\n\t\t\tconf->saved_nics[conf->num_savednics].ifindex,\n\t\t\tconf->saved_nics[conf->num_savednics].orig_name);\n\t\tconf->num_savednics++;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_destroy_container(struct lxc_conf *conf);",
            "static void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic bool do_destroy_container(struct lxc_conf *conf);\nstatic void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);\n\nstatic int save_phys_nics(struct lxc_conf *conf)\n{\n\tstruct lxc_list *iterator;\n\tint am_root = (getuid() == 0);\n\n\tif (!am_root)\n\t\treturn 0;\n\n\tlxc_list_for_each(iterator, &conf->network) {\n\t\tstruct lxc_netdev *netdev = iterator->elem;\n\n\t\tif (netdev->type != LXC_NET_PHYS)\n\t\t\tcontinue;\n\t\tconf->saved_nics = realloc(conf->saved_nics,\n\t\t\t\t(conf->num_savednics+1)*sizeof(struct saved_nic));\n\t\tif (!conf->saved_nics)\n\t\t\treturn -1;\n\t\tconf->saved_nics[conf->num_savednics].ifindex = netdev->ifindex;\n\t\tconf->saved_nics[conf->num_savednics].orig_name = strdup(netdev->link);\n\t\tif (!conf->saved_nics[conf->num_savednics].orig_name)\n\t\t\treturn -1;\n\t\tINFO(\"Stored saved_nic #%d idx %d name %s.\", conf->num_savednics,\n\t\t\tconf->saved_nics[conf->num_savednics].ifindex,\n\t\t\tconf->saved_nics[conf->num_savednics].orig_name);\n\t\tconf->num_savednics++;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to create the network.\""
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_create_network",
          "args": [
            "handler"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_create_network",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "2941-2969",
          "snippet": "int lxc_create_network(struct lxc_handler *handler)\n{\n\tstruct lxc_list *network = &handler->conf->network;\n\tstruct lxc_list *iterator;\n\tstruct lxc_netdev *netdev;\n\tint am_root = (getuid() == 0);\n\n\tif (!am_root)\n\t\treturn 0;\n\n\tlxc_list_for_each(iterator, network) {\n\n\t\tnetdev = iterator->elem;\n\n\t\tif (netdev->type < 0 || netdev->type > LXC_NET_MAXCONFTYPE) {\n\t\t\tERROR(\"invalid network configuration type '%d'\",\n\t\t\t      netdev->type);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (netdev_conf[netdev->type](handler, netdev)) {\n\t\t\tERROR(\"failed to create netdev\");\n\t\t\treturn -1;\n\t\t}\n\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_none(struct lxc_handler *, struct lxc_netdev *);",
            "static  instantiate_cb netdev_conf[LXC_NET_MAXCONFTYPE + 1] = {\n\t[LXC_NET_VETH]    = instantiate_veth,\n\t[LXC_NET_MACVLAN] = instantiate_macvlan,\n\t[LXC_NET_VLAN]    = instantiate_vlan,\n\t[LXC_NET_PHYS]    = instantiate_phys,\n\t[LXC_NET_EMPTY]   = instantiate_empty,\n\t[LXC_NET_NONE]    = instantiate_none,\n};",
            "static int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_none(struct lxc_handler *, struct lxc_netdev *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_none(struct lxc_handler *, struct lxc_netdev *);\nstatic  instantiate_cb netdev_conf[LXC_NET_MAXCONFTYPE + 1] = {\n\t[LXC_NET_VETH]    = instantiate_veth,\n\t[LXC_NET_MACVLAN] = instantiate_macvlan,\n\t[LXC_NET_VLAN]    = instantiate_vlan,\n\t[LXC_NET_PHYS]    = instantiate_phys,\n\t[LXC_NET_EMPTY]   = instantiate_empty,\n\t[LXC_NET_NONE]    = instantiate_none,\n};\nstatic int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_none(struct lxc_handler *, struct lxc_netdev *);\n\nint lxc_create_network(struct lxc_handler *handler)\n{\n\tstruct lxc_list *network = &handler->conf->network;\n\tstruct lxc_list *iterator;\n\tstruct lxc_netdev *netdev;\n\tint am_root = (getuid() == 0);\n\n\tif (!am_root)\n\t\treturn 0;\n\n\tlxc_list_for_each(iterator, network) {\n\n\t\tnetdev = iterator->elem;\n\n\t\tif (netdev->type < 0 || netdev->type > LXC_NET_MAXCONFTYPE) {\n\t\t\tERROR(\"invalid network configuration type '%d'\",\n\t\t\t      netdev->type);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (netdev_conf[netdev->type](handler, netdev)) {\n\t\t\tERROR(\"failed to create netdev\");\n\t\t\treturn -1;\n\t\t}\n\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to find gateway addresses.\""
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_find_gateway_addresses",
          "args": [
            "handler"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_find_gateway_addresses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3362-3408",
          "snippet": "int lxc_find_gateway_addresses(struct lxc_handler *handler)\n{\n\tstruct lxc_list *network = &handler->conf->network;\n\tstruct lxc_list *iterator;\n\tstruct lxc_netdev *netdev;\n\tint link_index;\n\n\tlxc_list_for_each(iterator, network) {\n\t\tnetdev = iterator->elem;\n\n\t\tif (!netdev->ipv4_gateway_auto && !netdev->ipv6_gateway_auto)\n\t\t\tcontinue;\n\n\t\tif (netdev->type != LXC_NET_VETH && netdev->type != LXC_NET_MACVLAN) {\n\t\t\tERROR(\"gateway = auto only supported for \"\n\t\t\t      \"veth and macvlan\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (!netdev->link) {\n\t\t\tERROR(\"gateway = auto needs a link interface\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tlink_index = if_nametoindex(netdev->link);\n\t\tif (!link_index)\n\t\t\treturn -EINVAL;\n\n\t\tif (netdev->ipv4_gateway_auto) {\n\t\t\tif (lxc_ipv4_addr_get(link_index, &netdev->ipv4_gateway)) {\n\t\t\t\tERROR(\"failed to automatically find ipv4 gateway \"\n\t\t\t\t      \"address from link interface '%s'\", netdev->link);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (netdev->ipv6_gateway_auto) {\n\t\t\tif (lxc_ipv6_addr_get(link_index, &netdev->ipv6_gateway)) {\n\t\t\t\tERROR(\"failed to automatically find ipv6 gateway \"\n\t\t\t\t      \"address from link interface '%s'\", netdev->link);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_none(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_none(struct lxc_handler *, struct lxc_netdev *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_none(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_none(struct lxc_handler *, struct lxc_netdev *);\n\nint lxc_find_gateway_addresses(struct lxc_handler *handler)\n{\n\tstruct lxc_list *network = &handler->conf->network;\n\tstruct lxc_list *iterator;\n\tstruct lxc_netdev *netdev;\n\tint link_index;\n\n\tlxc_list_for_each(iterator, network) {\n\t\tnetdev = iterator->elem;\n\n\t\tif (!netdev->ipv4_gateway_auto && !netdev->ipv6_gateway_auto)\n\t\t\tcontinue;\n\n\t\tif (netdev->type != LXC_NET_VETH && netdev->type != LXC_NET_MACVLAN) {\n\t\t\tERROR(\"gateway = auto only supported for \"\n\t\t\t      \"veth and macvlan\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (!netdev->link) {\n\t\t\tERROR(\"gateway = auto needs a link interface\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tlink_index = if_nametoindex(netdev->link);\n\t\tif (!link_index)\n\t\t\treturn -EINVAL;\n\n\t\tif (netdev->ipv4_gateway_auto) {\n\t\t\tif (lxc_ipv4_addr_get(link_index, &netdev->ipv4_gateway)) {\n\t\t\t\tERROR(\"failed to automatically find ipv4 gateway \"\n\t\t\t\t      \"address from link interface '%s'\", netdev->link);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (netdev->ipv6_gateway_auto) {\n\t\t\tif (lxc_ipv6_addr_get(link_index, &netdev->ipv6_gateway)) {\n\t\t\t\tERROR(\"failed to automatically find ipv6 gateway \"\n\t\t\t\t      \"address from link interface '%s'\", netdev->link);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "resolve_clone_flags",
          "args": [
            "handler"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "resolve_clone_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "1049-1072",
          "snippet": "void resolve_clone_flags(struct lxc_handler *handler)\n{\n\thandler->clone_flags = CLONE_NEWPID | CLONE_NEWNS;\n\n\tif (!lxc_list_empty(&handler->conf->id_map))\n\t\thandler->clone_flags |= CLONE_NEWUSER;\n\n\tif (handler->conf->inherit_ns_fd[LXC_NS_NET] == -1) {\n\t\tif (!lxc_requests_empty_network(handler))\n\t\t\thandler->clone_flags |= CLONE_NEWNET;\n\t} else {\n\t\tINFO(\"Inheriting a NET namespace.\");\n\t}\n\n\tif (handler->conf->inherit_ns_fd[LXC_NS_IPC] == -1)\n\t\thandler->clone_flags |= CLONE_NEWIPC;\n\telse\n\t\tINFO(\"Inheriting an IPC namespace.\");\n\n\tif (handler->conf->inherit_ns_fd[LXC_NS_UTS] == -1)\n\t\thandler->clone_flags |= CLONE_NEWUTS;\n\telse\n\t\tINFO(\"Inheriting a UTS namespace.\");\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_destroy_container(struct lxc_conf *conf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic bool do_destroy_container(struct lxc_conf *conf);\n\nvoid resolve_clone_flags(struct lxc_handler *handler)\n{\n\thandler->clone_flags = CLONE_NEWPID | CLONE_NEWNS;\n\n\tif (!lxc_list_empty(&handler->conf->id_map))\n\t\thandler->clone_flags |= CLONE_NEWUSER;\n\n\tif (handler->conf->inherit_ns_fd[LXC_NS_NET] == -1) {\n\t\tif (!lxc_requests_empty_network(handler))\n\t\t\thandler->clone_flags |= CLONE_NEWNET;\n\t} else {\n\t\tINFO(\"Inheriting a NET namespace.\");\n\t}\n\n\tif (handler->conf->inherit_ns_fd[LXC_NS_IPC] == -1)\n\t\thandler->clone_flags |= CLONE_NEWIPC;\n\telse\n\t\tINFO(\"Inheriting an IPC namespace.\");\n\n\tif (handler->conf->inherit_ns_fd[LXC_NS_UTS] == -1)\n\t\thandler->clone_flags |= CLONE_NEWUTS;\n\telse\n\t\tINFO(\"Inheriting a UTS namespace.\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "socketpair",
          "args": [
            "AF_UNIX",
            "SOCK_DGRAM",
            "0",
            "handler->ttysock"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_sync_init",
          "args": [
            "handler"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_sync_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/sync.c",
          "lines": "117-131",
          "snippet": "int lxc_sync_init(struct lxc_handler *handler)\n{\n\tint ret;\n\n\tret = socketpair(AF_LOCAL, SOCK_STREAM, 0, handler->sv);\n\tif (ret) {\n\t\tSYSERROR(\"failed to create synchronization socketpair\");\n\t\treturn -1;\n\t}\n\n\t/* Be sure we don't inherit this after the exec */\n\tfcntl(handler->sv[0], F_SETFD, FD_CLOEXEC);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"log.h\"",
            "#include \"sync.h\"",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"log.h\"\n#include \"sync.h\"\n#include <fcntl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n\nint lxc_sync_init(struct lxc_handler *handler)\n{\n\tint ret;\n\n\tret = socketpair(AF_LOCAL, SOCK_STREAM, 0, handler->sv);\n\tif (ret) {\n\t\tSYSERROR(\"failed to create synchronization socketpair\");\n\t\treturn -1;\n\t}\n\n\t/* Be sure we don't inherit this after the exec */\n\tfcntl(handler->sv[0], F_SETFD, FD_CLOEXEC);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic bool do_destroy_container(struct lxc_conf *conf);\nstatic int lxc_rmdir_onedev_wrapper(void *data);\nstatic void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);\nstatic int netpipe = -1;\n\nstatic int lxc_spawn(struct lxc_handler *handler)\n{\n\tint failed_before_rename = 0;\n\tconst char *name = handler->name;\n\tbool cgroups_connected = false;\n\tint saved_ns_fd[LXC_NS_MAX];\n\tint preserve_mask = 0, i, flags;\n\tint netpipepair[2], nveths;\n\n\tnetpipe = -1;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++)\n\t\tif (handler->conf->inherit_ns_fd[i] != -1)\n\t\t\tpreserve_mask |= ns_info[i].clone_flag;\n\n\tif (lxc_sync_init(handler))\n\t\treturn -1;\n\n\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, handler->ttysock) < 0) {\n\t\tlxc_sync_fini(handler);\n\t\treturn -1;\n\t}\n\n\tresolve_clone_flags(handler);\n\n\tif (handler->clone_flags & CLONE_NEWNET) {\n\t\tif (!lxc_list_empty(&handler->conf->network)) {\n\n\t\t\t/* Find gateway addresses from the link device, which is\n\t\t\t * no longer accessible inside the container. Do this\n\t\t\t * before creating network interfaces, since goto\n\t\t\t * out_delete_net does not work before lxc_clone.\n\t\t\t */\n\t\t\tif (lxc_find_gateway_addresses(handler)) {\n\t\t\t\tERROR(\"Failed to find gateway addresses.\");\n\t\t\t\tlxc_sync_fini(handler);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/* That should be done before the clone because we will\n\t\t\t * fill the netdev index and use them in the child.\n\t\t\t */\n\t\t\tif (lxc_create_network(handler)) {\n\t\t\t\tERROR(\"Failed to create the network.\");\n\t\t\t\tlxc_sync_fini(handler);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (save_phys_nics(handler->conf)) {\n\t\t\tERROR(\"Failed to save physical nic info.\");\n\t\t\tgoto out_abort;\n\t\t}\n\t}\n\n\tif (!cgroup_init(handler)) {\n\t\tERROR(\"Failed initializing cgroup support.\");\n\t\tgoto out_delete_net;\n\t}\n\n\tcgroups_connected = true;\n\n\tif (!cgroup_create(handler)) {\n\t\tERROR(\"Failed creating cgroups.\");\n\t\tgoto out_delete_net;\n\t}\n\n\t/* If the rootfs is not a blockdev, prevent the container from marking\n\t * it readonly.\n\t * If the container is unprivileged then skip rootfs pinning.\n\t */\n\tif (lxc_list_empty(&handler->conf->id_map)) {\n\t\thandler->pinfd = pin_rootfs(handler->conf->rootfs.path);\n\t\tif (handler->pinfd == -1)\n\t\t\tINFO(\"Failed to pin the rootfs for container \\\"%s\\\".\", handler->name);\n\t}\n\n\tif (!preserve_ns(saved_ns_fd, preserve_mask, getpid()))\n\t\tgoto out_delete_net;\n\n\tif (attach_ns(handler->conf->inherit_ns_fd) < 0)\n\t\tgoto out_delete_net;\n\n\tif (am_unpriv() && (nveths = count_veths(&handler->conf->network))) {\n\t\tif (pipe(netpipepair) < 0) {\n\t\t\tSYSERROR(\"Failed to create pipe.\");\n\t\t\tgoto out_delete_net;\n\t\t}\n\t\t/* Store netpipe in the global var for do_start's use. */\n\t\tnetpipe = netpipepair[0];\n\t}\n\n\t/* Create a process in a new set of namespaces. */\n\tflags = handler->clone_flags;\n\tif (handler->clone_flags & CLONE_NEWUSER) {\n\t\t/* If CLONE_NEWUSER and CLONE_NEWNET was requested, we need to\n\t\t * clone a new user namespace first and only later unshare our\n\t\t * network namespace to ensure that network devices ownership is\n\t\t * set up correctly.\n\t\t */\n\t\tflags &= ~CLONE_NEWNET;\n\t}\n\thandler->pid = lxc_clone(do_start, handler, flags);\n\tif (handler->pid < 0) {\n\t\tSYSERROR(\"Failed to clone a new set of namespaces.\");\n\t\tgoto out_delete_net;\n\t}\n\tfor (i = 0; i < LXC_NS_MAX; i++)\n\t\tif (flags & ns_info[i].clone_flag)\n\t\t\tINFO(\"Cloned %s.\", ns_info[i].flag_name);\n\n\tif (!preserve_ns(handler->nsfd, handler->clone_flags | preserve_mask, handler->pid))\n\t\tINFO(\"Failed to preserve namespace for lxc.hook.stop.\");\n\n\tif (attach_ns(saved_ns_fd))\n\t\tWARN(\"Failed to restore saved namespaces.\");\n\n\tlxc_sync_fini_child(handler);\n\n\t/* Map the container uids. The container became an invalid userid the\n\t * moment it was cloned with CLONE_NEWUSER. This call doesn't change\n\t * anything immediately, but allows the container to setuid(0) (0 being\n\t * mapped to something else on the host.) later to become a valid uid\n\t * again.\n\t */\n\tif (lxc_map_ids(&handler->conf->id_map, handler->pid)) {\n\t\tERROR(\"Failed to set up id mapping.\");\n\t\tgoto out_delete_net;\n\t}\n\n\tif (lxc_sync_wake_child(handler, LXC_SYNC_STARTUP)) {\n\t\tfailed_before_rename = 1;\n\t\tgoto out_delete_net;\n\t}\n\n\tif (lxc_sync_wait_child(handler, LXC_SYNC_CONFIGURE)) {\n\t\tfailed_before_rename = 1;\n\t\tgoto out_delete_net;\n\t}\n\n\tif (!cgroup_create_legacy(handler)) {\n\t\tERROR(\"Failed to setup legacy cgroups for container \\\"%s\\\".\", name);\n\t\tgoto out_delete_net;\n\t}\n\tif (!cgroup_setup_limits(handler, false)) {\n\t\tERROR(\"Failed to setup cgroup limits for container \\\"%s\\\".\", name);\n\t\tgoto out_delete_net;\n\t}\n\n\tif (!cgroup_enter(handler))\n\t\tgoto out_delete_net;\n\n\tif (!cgroup_chown(handler))\n\t\tgoto out_delete_net;\n\n\tif (failed_before_rename)\n\t\tgoto out_delete_net;\n\n\t/* Create the network configuration. */\n\tif (handler->clone_flags & CLONE_NEWNET) {\n\t\tif (lxc_assign_network(handler->lxcpath, handler->name,\n\t\t\t\t       &handler->conf->network, handler->pid)) {\n\t\t\tERROR(\"Failed to create the configured network.\");\n\t\t\tgoto out_delete_net;\n\t\t}\n\t}\n\n\tif (netpipe != -1) {\n\t\tstruct lxc_list *iterator;\n\t\tstruct lxc_netdev *netdev;\n\n\t\tclose(netpipe);\n\t\tlxc_list_for_each(iterator, &handler->conf->network) {\n\t\t\tnetdev = iterator->elem;\n\t\t\tif (netdev->type != LXC_NET_VETH)\n\t\t\t\tcontinue;\n\t\t\tif (write(netpipepair[1], netdev->name, IFNAMSIZ) != IFNAMSIZ) {\n\t\t\t\tERROR(\"Error writing veth name to container.\");\n\t\t\t\tgoto out_delete_net;\n\t\t\t}\n\t\t}\n\t\tclose(netpipepair[1]);\n\t}\n\n\t/* Tell the child to continue its initialization. We'll get\n\t * LXC_SYNC_CGROUP when it is ready for us to setup cgroups.\n\t */\n\tif (lxc_sync_barrier_child(handler, LXC_SYNC_POST_CONFIGURE))\n\t\tgoto out_delete_net;\n\n\tif (!cgroup_setup_limits(handler, true)) {\n\t\tERROR(\"Failed to setup the devices cgroup for container \\\"%s\\\".\", name);\n\t\tgoto out_delete_net;\n\t}\n\n\tcgroup_disconnect();\n\tcgroups_connected = false;\n\n\t/* Read tty fds allocated by child. */\n\tif (recv_ttys_from_child(handler) < 0) {\n\t\tERROR(\"Failed to receive tty info from child process.\");\n\t\tgoto out_delete_net;\n\t}\n\n\t/* Tell the child to complete its initialization and wait for it to exec\n\t * or return an error. (The child will never return\n\t * LXC_SYNC_POST_CGROUP+1. It will either close the sync pipe, causing\n\t * lxc_sync_barrier_child to return success, or return a different\n\t * value, causing us to error out).\n\t */\n\tif (lxc_sync_barrier_child(handler, LXC_SYNC_POST_CGROUP))\n\t\treturn -1;\n\n\tif (detect_shared_rootfs())\n\t\tumount2(handler->conf->rootfs.mount, MNT_DETACH);\n\n\tif (handler->ops->post_start(handler, handler->data))\n\t\tgoto out_abort;\n\n\tif (lxc_set_state(name, handler, RUNNING)) {\n\t\tERROR(\"Failed to set state for container \\\"%s\\\" to \\\"%s\\\".\", name,\n\t\t      lxc_state2str(RUNNING));\n\t\tgoto out_abort;\n\t}\n\n\tlxc_sync_fini(handler);\n\thandler->netnsfd = lxc_preserve_ns(handler->pid, \"net\");\n\n\treturn 0;\n\nout_delete_net:\n\tif (cgroups_connected)\n\t\tcgroup_disconnect();\n\tif (handler->clone_flags & CLONE_NEWNET)\n\t\tlxc_delete_network(handler);\nout_abort:\n\tlxc_abort(name, handler);\n\tlxc_sync_fini(handler);\n\tif (handler->pinfd >= 0) {\n\t\tclose(handler->pinfd);\n\t\thandler->pinfd = -1;\n\t}\n\n\treturn -1;\n}"
  },
  {
    "function_name": "resolve_clone_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
    "lines": "1049-1072",
    "snippet": "void resolve_clone_flags(struct lxc_handler *handler)\n{\n\thandler->clone_flags = CLONE_NEWPID | CLONE_NEWNS;\n\n\tif (!lxc_list_empty(&handler->conf->id_map))\n\t\thandler->clone_flags |= CLONE_NEWUSER;\n\n\tif (handler->conf->inherit_ns_fd[LXC_NS_NET] == -1) {\n\t\tif (!lxc_requests_empty_network(handler))\n\t\t\thandler->clone_flags |= CLONE_NEWNET;\n\t} else {\n\t\tINFO(\"Inheriting a NET namespace.\");\n\t}\n\n\tif (handler->conf->inherit_ns_fd[LXC_NS_IPC] == -1)\n\t\thandler->clone_flags |= CLONE_NEWIPC;\n\telse\n\t\tINFO(\"Inheriting an IPC namespace.\");\n\n\tif (handler->conf->inherit_ns_fd[LXC_NS_UTS] == -1)\n\t\thandler->clone_flags |= CLONE_NEWUTS;\n\telse\n\t\tINFO(\"Inheriting a UTS namespace.\");\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <sys/reboot.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"sync.h\"",
      "#include \"start.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"lxcutmp.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"console.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/capability.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <alloca.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_destroy_container(struct lxc_conf *conf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Inheriting a UTS namespace.\""
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Inheriting an IPC namespace.\""
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Inheriting a NET namespace.\""
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_requests_empty_network",
          "args": [
            "handler"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_requests_empty_network",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "2917-2939",
          "snippet": "int lxc_requests_empty_network(struct lxc_handler *handler)\n{\n\tstruct lxc_list *network = &handler->conf->network;\n\tstruct lxc_list *iterator;\n\tstruct lxc_netdev *netdev;\n\tbool found_none = false, found_nic = false;\n\n\tif (lxc_list_empty(network))\n\t\treturn 0;\n\n\tlxc_list_for_each(iterator, network) {\n\n\t\tnetdev = iterator->elem;\n\n\t\tif (netdev->type == LXC_NET_NONE)\n\t\t\tfound_none = true;\n\t\telse\n\t\t\tfound_nic = true;\n\t}\n\tif (found_none && !found_nic)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);",
            "static int instantiate_none(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);",
            "static int shutdown_none(struct lxc_handler *, struct lxc_netdev *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int instantiate_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int instantiate_none(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_veth(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_macvlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_vlan(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_phys(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_empty(struct lxc_handler *, struct lxc_netdev *);\nstatic int shutdown_none(struct lxc_handler *, struct lxc_netdev *);\n\nint lxc_requests_empty_network(struct lxc_handler *handler)\n{\n\tstruct lxc_list *network = &handler->conf->network;\n\tstruct lxc_list *iterator;\n\tstruct lxc_netdev *netdev;\n\tbool found_none = false, found_nic = false;\n\n\tif (lxc_list_empty(network))\n\t\treturn 0;\n\n\tlxc_list_for_each(iterator, network) {\n\n\t\tnetdev = iterator->elem;\n\n\t\tif (netdev->type == LXC_NET_NONE)\n\t\t\tfound_none = true;\n\t\telse\n\t\t\tfound_nic = true;\n\t}\n\tif (found_none && !found_nic)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_empty",
          "args": [
            "&handler->conf->id_map"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "94-97",
          "snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic bool do_destroy_container(struct lxc_conf *conf);\n\nvoid resolve_clone_flags(struct lxc_handler *handler)\n{\n\thandler->clone_flags = CLONE_NEWPID | CLONE_NEWNS;\n\n\tif (!lxc_list_empty(&handler->conf->id_map))\n\t\thandler->clone_flags |= CLONE_NEWUSER;\n\n\tif (handler->conf->inherit_ns_fd[LXC_NS_NET] == -1) {\n\t\tif (!lxc_requests_empty_network(handler))\n\t\t\thandler->clone_flags |= CLONE_NEWNET;\n\t} else {\n\t\tINFO(\"Inheriting a NET namespace.\");\n\t}\n\n\tif (handler->conf->inherit_ns_fd[LXC_NS_IPC] == -1)\n\t\thandler->clone_flags |= CLONE_NEWIPC;\n\telse\n\t\tINFO(\"Inheriting an IPC namespace.\");\n\n\tif (handler->conf->inherit_ns_fd[LXC_NS_UTS] == -1)\n\t\thandler->clone_flags |= CLONE_NEWUTS;\n\telse\n\t\tINFO(\"Inheriting a UTS namespace.\");\n}"
  },
  {
    "function_name": "recv_ttys_from_child",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
    "lines": "1022-1047",
    "snippet": "static int recv_ttys_from_child(struct lxc_handler *handler)\n{\n\tstruct lxc_conf *conf = handler->conf;\n\tint i, sock = handler->ttysock[1];\n\tstruct lxc_tty_info *tty_info = &conf->tty_info;\n\n\tif (!conf->tty)\n\t\treturn 0;\n\n\ttty_info->pty_info = malloc(sizeof(*tty_info->pty_info) * conf->tty);\n\tif (!tty_info->pty_info)\n\t\treturn -1;\n\n\tfor (i = 0; i < conf->tty; i++) {\n\t\tstruct lxc_pty_info *pty_info = &tty_info->pty_info[i];\n\t\tpty_info->busy = 0;\n\t\tif (recv_fd(sock, &pty_info->slave) < 0 ||\n\t\t    recv_fd(sock, &pty_info->master) < 0) {\n\t\t\tERROR(\"Error receiving tty info from child process.\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\ttty_info->nbtty = conf->tty;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <sys/reboot.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"sync.h\"",
      "#include \"start.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"lxcutmp.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"console.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/capability.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <alloca.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_destroy_container(struct lxc_conf *conf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error receiving tty info from child process.\""
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv_fd",
          "args": [
            "sock",
            "&pty_info->master"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "recv_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "1011-1020",
          "snippet": "static int recv_fd(int sock, int *fd)\n{\n\tif (lxc_abstract_unix_recv_fd(sock, fd, NULL, 0) < 0) {\n\t\tSYSERROR(\"Error receiving tty file descriptor from child process.\");\n\t\treturn -1;\n\t}\n\tif (*fd == -1)\n\t\treturn -1;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic int recv_fd(int sock, int *fd)\n{\n\tif (lxc_abstract_unix_recv_fd(sock, fd, NULL, 0) < 0) {\n\t\tSYSERROR(\"Error receiving tty file descriptor from child process.\");\n\t\treturn -1;\n\t}\n\tif (*fd == -1)\n\t\treturn -1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*tty_info->pty_info) * conf->tty"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic bool do_destroy_container(struct lxc_conf *conf);\n\nstatic int recv_ttys_from_child(struct lxc_handler *handler)\n{\n\tstruct lxc_conf *conf = handler->conf;\n\tint i, sock = handler->ttysock[1];\n\tstruct lxc_tty_info *tty_info = &conf->tty_info;\n\n\tif (!conf->tty)\n\t\treturn 0;\n\n\ttty_info->pty_info = malloc(sizeof(*tty_info->pty_info) * conf->tty);\n\tif (!tty_info->pty_info)\n\t\treturn -1;\n\n\tfor (i = 0; i < conf->tty; i++) {\n\t\tstruct lxc_pty_info *pty_info = &tty_info->pty_info[i];\n\t\tpty_info->busy = 0;\n\t\tif (recv_fd(sock, &pty_info->slave) < 0 ||\n\t\t    recv_fd(sock, &pty_info->master) < 0) {\n\t\t\tERROR(\"Error receiving tty info from child process.\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\ttty_info->nbtty = conf->tty;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "recv_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
    "lines": "1011-1020",
    "snippet": "static int recv_fd(int sock, int *fd)\n{\n\tif (lxc_abstract_unix_recv_fd(sock, fd, NULL, 0) < 0) {\n\t\tSYSERROR(\"Error receiving tty file descriptor from child process.\");\n\t\treturn -1;\n\t}\n\tif (*fd == -1)\n\t\treturn -1;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <sys/reboot.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"sync.h\"",
      "#include \"start.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"lxcutmp.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"console.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/capability.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <alloca.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error receiving tty file descriptor from child process.\""
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_abstract_unix_recv_fd",
          "args": [
            "sock",
            "fd",
            "NULL",
            "0"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_recv_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "164-201",
          "snippet": "int lxc_abstract_unix_recv_fd(int fd, int *recvfd, void *data, size_t size)\n{\n\tstruct msghdr msg = { 0 };\n\tstruct iovec iov;\n\tstruct cmsghdr *cmsg;\n\tchar cmsgbuf[CMSG_SPACE(sizeof(int))];\n\tchar buf[1];\n\tint ret, *val;\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_namelen = 0;\n\tmsg.msg_control = cmsgbuf;\n\tmsg.msg_controllen = sizeof(cmsgbuf);\n\n\tiov.iov_base = data ? data : buf;\n\tiov.iov_len = data ? size : sizeof(buf);\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\tret = recvmsg(fd, &msg, 0);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\n\t/* if the message is wrong the variable will not be\n\t * filled and the peer will notified about a problem */\n\t*recvfd = -1;\n\n\tif (cmsg && cmsg->cmsg_len == CMSG_LEN(sizeof(int)) &&\n\t\t\tcmsg->cmsg_level == SOL_SOCKET &&\n\t\t\tcmsg->cmsg_type == SCM_RIGHTS) {\n\t\tval = (int *) CMSG_DATA(cmsg);\n\t\t*recvfd = *val;\n\t}\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_recv_fd(int fd, int *recvfd, void *data, size_t size)\n{\n\tstruct msghdr msg = { 0 };\n\tstruct iovec iov;\n\tstruct cmsghdr *cmsg;\n\tchar cmsgbuf[CMSG_SPACE(sizeof(int))];\n\tchar buf[1];\n\tint ret, *val;\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_namelen = 0;\n\tmsg.msg_control = cmsgbuf;\n\tmsg.msg_controllen = sizeof(cmsgbuf);\n\n\tiov.iov_base = data ? data : buf;\n\tiov.iov_len = data ? size : sizeof(buf);\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\tret = recvmsg(fd, &msg, 0);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\n\t/* if the message is wrong the variable will not be\n\t * filled and the peer will notified about a problem */\n\t*recvfd = -1;\n\n\tif (cmsg && cmsg->cmsg_len == CMSG_LEN(sizeof(int)) &&\n\t\t\tcmsg->cmsg_level == SOL_SOCKET &&\n\t\t\tcmsg->cmsg_type == SCM_RIGHTS) {\n\t\tval = (int *) CMSG_DATA(cmsg);\n\t\t*recvfd = *val;\n\t}\nout:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic int recv_fd(int sock, int *fd)\n{\n\tif (lxc_abstract_unix_recv_fd(sock, fd, NULL, 0) < 0) {\n\t\tSYSERROR(\"Error receiving tty file descriptor from child process.\");\n\t\treturn -1;\n\t}\n\tif (*fd == -1)\n\t\treturn -1;\n\treturn 0;\n}"
  },
  {
    "function_name": "save_phys_nics",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
    "lines": "981-1009",
    "snippet": "static int save_phys_nics(struct lxc_conf *conf)\n{\n\tstruct lxc_list *iterator;\n\tint am_root = (getuid() == 0);\n\n\tif (!am_root)\n\t\treturn 0;\n\n\tlxc_list_for_each(iterator, &conf->network) {\n\t\tstruct lxc_netdev *netdev = iterator->elem;\n\n\t\tif (netdev->type != LXC_NET_PHYS)\n\t\t\tcontinue;\n\t\tconf->saved_nics = realloc(conf->saved_nics,\n\t\t\t\t(conf->num_savednics+1)*sizeof(struct saved_nic));\n\t\tif (!conf->saved_nics)\n\t\t\treturn -1;\n\t\tconf->saved_nics[conf->num_savednics].ifindex = netdev->ifindex;\n\t\tconf->saved_nics[conf->num_savednics].orig_name = strdup(netdev->link);\n\t\tif (!conf->saved_nics[conf->num_savednics].orig_name)\n\t\t\treturn -1;\n\t\tINFO(\"Stored saved_nic #%d idx %d name %s.\", conf->num_savednics,\n\t\t\tconf->saved_nics[conf->num_savednics].ifindex,\n\t\t\tconf->saved_nics[conf->num_savednics].orig_name);\n\t\tconf->num_savednics++;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <sys/reboot.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"sync.h\"",
      "#include \"start.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"lxcutmp.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"console.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/capability.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <alloca.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_destroy_container(struct lxc_conf *conf);",
      "static void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Stored saved_nic #%d idx %d name %s.\"",
            "conf->num_savednics",
            "conf->saved_nics[conf->num_savednics].ifindex",
            "conf->saved_nics[conf->num_savednics].orig_name"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "netdev->link"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "conf->saved_nics",
            "(conf->num_savednics+1)*sizeof(struct saved_nic)"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "must_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "116-124",
          "snippet": "static void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "iterator",
            "&conf->network"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic bool do_destroy_container(struct lxc_conf *conf);\nstatic void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);\n\nstatic int save_phys_nics(struct lxc_conf *conf)\n{\n\tstruct lxc_list *iterator;\n\tint am_root = (getuid() == 0);\n\n\tif (!am_root)\n\t\treturn 0;\n\n\tlxc_list_for_each(iterator, &conf->network) {\n\t\tstruct lxc_netdev *netdev = iterator->elem;\n\n\t\tif (netdev->type != LXC_NET_PHYS)\n\t\t\tcontinue;\n\t\tconf->saved_nics = realloc(conf->saved_nics,\n\t\t\t\t(conf->num_savednics+1)*sizeof(struct saved_nic));\n\t\tif (!conf->saved_nics)\n\t\t\treturn -1;\n\t\tconf->saved_nics[conf->num_savednics].ifindex = netdev->ifindex;\n\t\tconf->saved_nics[conf->num_savednics].orig_name = strdup(netdev->link);\n\t\tif (!conf->saved_nics[conf->num_savednics].orig_name)\n\t\t\treturn -1;\n\t\tINFO(\"Stored saved_nic #%d idx %d name %s.\", conf->num_savednics,\n\t\t\tconf->saved_nics[conf->num_savednics].ifindex,\n\t\t\tconf->saved_nics[conf->num_savednics].orig_name);\n\t\tconf->num_savednics++;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "do_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
    "lines": "716-979",
    "snippet": "static int do_start(void *data)\n{\n\tstruct lxc_list *iterator;\n\tstruct lxc_handler *handler = data;\n\tint devnull_fd = -1, ret;\n\tchar path[PATH_MAX];\n\n\tif (sigprocmask(SIG_SETMASK, &handler->oldmask, NULL)) {\n\t\tSYSERROR(\"Failed to set signal mask.\");\n\t\treturn -1;\n\t}\n\n\t/* This prctl must be before the synchro, so if the parent dies before\n\t * we set the parent death signal, we will detect its death with the\n\t * synchro right after, otherwise we have a window where the parent can\n\t * exit before we set the pdeath signal leading to a unsupervized\n\t * container.\n\t */\n\tif (prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0)) {\n\t\tSYSERROR(\"Failed to set PR_SET_PDEATHSIG to SIGKILL.\");\n\t\treturn -1;\n\t}\n\n\tlxc_sync_fini_parent(handler);\n\n\t/* Don't leak the pinfd to the container. */\n\tif (handler->pinfd >= 0) {\n\t\tclose(handler->pinfd);\n\t}\n\n\tif (lxc_sync_wait_parent(handler, LXC_SYNC_STARTUP))\n\t\treturn -1;\n\n\t/* Unshare CLONE_NEWNET after CLONE_NEWUSER. See\n\t * https://github.com/lxc/lxd/issues/1978.\n\t */\n\tif ((handler->clone_flags & (CLONE_NEWNET | CLONE_NEWUSER)) ==\n\t    (CLONE_NEWNET | CLONE_NEWUSER)) {\n\t\tret = unshare(CLONE_NEWNET);\n\t\tif (ret < 0) {\n\t\t\tSYSERROR(\"Failed to unshare CLONE_NEWNET.\");\n\t\t\tgoto out_warn_father;\n\t\t}\n\t\tINFO(\"Unshared CLONE_NEWNET.\");\n\t}\n\n\t/* Tell the parent task it can begin to configure the container and wait\n\t * for it to finish.\n\t */\n\tif (lxc_sync_barrier_parent(handler, LXC_SYNC_CONFIGURE))\n\t\treturn -1;\n\n\tif (read_unpriv_netifindex(&handler->conf->network) < 0)\n\t\tgoto out_warn_father;\n\n\t/* If we are in a new user namespace, become root there to have\n\t * privilege over our namespace.\n\t */\n\tif (!lxc_list_empty(&handler->conf->id_map)) {\n\t\tif (lxc_switch_uid_gid(0, 0) < 0)\n\t\t\tgoto out_warn_father;\n\n\t\t/* Drop groups only after we switched to a valid gid in the new\n\t\t * user namespace.\n\t\t */\n\t\tif (lxc_setgroups(0, NULL) < 0)\n\t\t\tgoto out_warn_father;\n\t}\n\n\tif (access(handler->lxcpath, X_OK)) {\n\t\tprint_top_failing_dir(handler->lxcpath);\n\t\tgoto out_warn_father;\n\t}\n\n\t#if HAVE_LIBCAP\n\tif (handler->conf->need_utmp_watch) {\n\t\tif (prctl(PR_CAPBSET_DROP, CAP_SYS_BOOT, 0, 0, 0)) {\n\t\t\tSYSERROR(\"Failed to remove the CAP_SYS_BOOT capability.\");\n\t\t\tgoto out_warn_father;\n\t\t}\n\t\tDEBUG(\"Dropped the CAP_SYS_BOOT capability.\");\n\t}\n\t#endif\n\n\tret = snprintf(path, sizeof(path), \"%s/dev/null\", handler->conf->rootfs.mount);\n\tif (ret < 0 || ret >= sizeof(path))\n\t\tgoto out_warn_father;\n\n\t/* In order to checkpoint restore, we need to have everything in the\n\t * same mount namespace. However, some containers may not have a\n\t * reasonable /dev (in particular, they may not have /dev/null), so we\n\t * can't set init's std fds to /dev/null by opening it from inside the\n\t * container.\n\t *\n\t * If that's the case, fall back to using the host's /dev/null. This\n\t * means that migration won't work, but at least we won't spew output\n\t * where it isn't wanted.\n\t */\n\tif (handler->backgrounded && !handler->conf->autodev && access(path, F_OK) < 0) {\n\t\tdevnull_fd = open_devnull();\n\n\t\tif (devnull_fd < 0)\n\t\t\tgoto out_warn_father;\n\t\tWARN(\"Using /dev/null from the host for container init's \"\n\t\t     \"standard file descriptors. Migration will not work.\");\n\t}\n\n\t/* Setup the container, ip, names, utsname, ... */\n\tif (lxc_setup(handler)) {\n\t\tERROR(\"Failed to setup container \\\"%s\\\".\", handler->name);\n\t\tgoto out_warn_father;\n\t}\n\n\t/* Ask father to setup cgroups and wait for him to finish. */\n\tif (lxc_sync_barrier_parent(handler, LXC_SYNC_CGROUP))\n\t\tgoto out_error;\n\n\t/* Unshare cgroup namespace after we have setup our cgroups. If we do it\n\t * earlier we end up with a wrong view of /proc/self/cgroup. For\n\t * example, assume we unshare(CLONE_NEWCGROUP) first, and then create\n\t * the cgroup for the container, say /sys/fs/cgroup/cpuset/lxc/c, then\n\t * /proc/self/cgroup would show us:\n\t *\n\t *\t8:cpuset:/lxc/c\n\t *\n\t * whereas it should actually show\n\t *\n\t *\t8:cpuset:/\n\t */\n\tif (cgns_supported()) {\n\t\tif (unshare(CLONE_NEWCGROUP) < 0) {\n\t\t\tINFO(\"Failed to unshare CLONE_NEWCGROUP.\");\n\t\t\tgoto out_warn_father;\n\t\t}\n\t\tINFO(\"Unshared CLONE_NEWCGROUP.\");\n\t}\n\n\t/* Set the label to change to when we exec(2) the container's init. */\n\tif (lsm_process_label_set(NULL, handler->conf, 1, 1) < 0)\n\t\tgoto out_warn_father;\n\n\t/* Set PR_SET_NO_NEW_PRIVS after we changed the lsm label. If we do it\n\t * before we aren't allowed anymore.\n\t */\n\tif (handler->conf->no_new_privs) {\n\t\tif (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0) {\n\t\t\tSYSERROR(\"Could not set PR_SET_NO_NEW_PRIVS to block execve() gainable privileges.\");\n\t\t\tgoto out_warn_father;\n\t\t}\n\t\tDEBUG(\"Set PR_SET_NO_NEW_PRIVS to block execve() gainable privileges.\");\n\t}\n\n\t/* Some init's such as busybox will set sane tty settings on stdin,\n\t * stdout, stderr which it thinks is the console. We already set them\n\t * the way we wanted on the real terminal, and we want init to do its\n\t * setup on its console ie. the pty allocated in lxc_console_create() so\n\t * make sure that that pty is stdin,stdout,stderr.\n\t */\n\tif (lxc_console_set_stdfds(handler->conf->console.slave) < 0)\n\t\tgoto out_warn_father;\n\n\t/* If we mounted a temporary proc, then unmount it now. */\n\ttmp_proc_unmount(handler->conf);\n\n\tif (lxc_seccomp_load(handler->conf) != 0)\n\t\tgoto out_warn_father;\n\n\tif (run_lxc_hooks(handler->name, \"start\", handler->conf, handler->lxcpath, NULL)) {\n\t\tERROR(\"Failed to run lxc.hook.start for container \\\"%s\\\".\", handler->name);\n\t\tgoto out_warn_father;\n\t}\n\n\t/* The container has been setup. We can now switch to an unprivileged\n\t * uid/gid.\n\t */\n\tif (handler->conf->is_execute) {\n\t\tbool have_cap_setgid;\n\t\tuid_t new_uid = handler->conf->init_uid;\n\t\tgid_t new_gid = handler->conf->init_gid;\n\n\t\t/* If we are in a new user namespace we already dropped all\n\t\t * groups when we switched to root in the new user namespace\n\t\t * further above. Only drop groups if we can, so ensure that we\n\t\t * have necessary privilege.\n\t\t */\n\t\t#if HAVE_LIBCAP\n\t\thave_cap_setgid = lxc_cap_is_set(CAP_SETGID, CAP_EFFECTIVE);\n\t\t#else\n\t\thave_cap_setgid = false;\n\t\t#endif\n\t\tif (lxc_list_empty(&handler->conf->id_map) && have_cap_setgid) {\n\t\t\tif (lxc_setgroups(0, NULL) < 0)\n\t\t\t\tgoto out_warn_father;\n\t\t}\n\n\t\tif (lxc_switch_uid_gid(new_uid, new_gid) < 0)\n\t\t\tgoto out_warn_father;\n\t}\n\n\t/* The clearenv() and putenv() calls have been moved here to allow us to\n\t * use environment variables passed to the various hooks, such as the\n\t * start hook above. Not all of the variables like CONFIG_PATH or ROOTFS\n\t * are valid in this context but others are.\n\t */\n\tif (clearenv()) {\n\t\tSYSERROR(\"Failed to clear environment.\");\n\t\t/* Don't error out though. */\n\t}\n\n\tlxc_list_for_each(iterator, &handler->conf->environment) {\n\t\tif (putenv((char *)iterator->elem)) {\n\t\t\tSYSERROR(\"Failed to set environment variable: %s.\", (char *)iterator->elem);\n\t\t\tgoto out_warn_father;\n\t\t}\n\t}\n\n\tif (putenv(\"container=lxc\")) {\n\t\tSYSERROR(\"Failed to set environment variable: container=lxc.\");\n\t\tgoto out_warn_father;\n\t}\n\n\tif (handler->conf->pty_names) {\n\t\tif (putenv(handler->conf->pty_names)) {\n\t\t\tSYSERROR(\"Failed to set environment variable for container ptys.\");\n\t\t\tgoto out_warn_father;\n\t\t}\n\t}\n\n\tclose(handler->sigfd);\n\n\tif (devnull_fd < 0) {\n\t\tdevnull_fd = open_devnull();\n\n\t\tif (devnull_fd < 0)\n\t\t\tgoto out_warn_father;\n\t}\n\n\tif (handler->backgrounded && set_stdfds(devnull_fd))\n\t\tgoto out_warn_father;\n\n\tif (devnull_fd >= 0) {\n\t\tclose(devnull_fd);\n\t\tdevnull_fd = -1;\n\t}\n\n\tsetsid();\n\n\t/* After this call, we are in error because this ops should not return\n\t * as it execs.\n\t */\n\thandler->ops->start(handler, handler->data);\n\nout_warn_father:\n\t/* We want the parent to know something went wrong, so we return a\n\t * special error code.\n\t */\n\tlxc_sync_wake_parent(handler, LXC_SYNC_ERROR);\n\nout_error:\n\tif (devnull_fd >= 0)\n\t\tclose(devnull_fd);\n\n\treturn -1;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <sys/reboot.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"sync.h\"",
      "#include \"start.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"lxcutmp.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"console.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/capability.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <alloca.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define PR_SET_NO_NEW_PRIVS 38",
      "#define PR_CAPBSET_DROP 24"
    ],
    "globals_used": [
      "static bool do_destroy_container(struct lxc_conf *conf);",
      "static int lxc_rmdir_onedev_wrapper(void *data);",
      "static void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "devnull_fd"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "close_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "118-128",
          "snippet": "static void close_ns(int ns_fd[LXC_NS_MAX])\n{\n\tint i;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (ns_fd[i] > -1) {\n\t\t\tclose(ns_fd[i]);\n\t\t\tns_fd[i] = -1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic void close_ns(int ns_fd[LXC_NS_MAX])\n{\n\tint i;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (ns_fd[i] > -1) {\n\t\t\tclose(ns_fd[i]);\n\t\t\tns_fd[i] = -1;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_sync_wake_parent",
          "args": [
            "handler",
            "LXC_SYNC_ERROR"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_sync_wake_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/sync.c",
          "lines": "97-100",
          "snippet": "int lxc_sync_wake_parent(struct lxc_handler *handler, int sequence)\n{\n\treturn __sync_wake(handler->sv[0], sequence);\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"log.h\"",
            "#include \"sync.h\"",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"log.h\"\n#include \"sync.h\"\n#include <fcntl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n\nint lxc_sync_wake_parent(struct lxc_handler *handler, int sequence)\n{\n\treturn __sync_wake(handler->sv[0], sequence);\n}"
        }
      },
      {
        "call_info": {
          "callee": "handler->ops->start",
          "args": [
            "handler",
            "handler->data"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "1453-1462",
          "snippet": "static int start(struct lxc_handler *handler, void* data)\n{\n\tstruct start_args *arg = data;\n\n\tNOTICE(\"Exec'ing \\\"%s\\\".\", arg->argv[0]);\n\n\texecvp(arg->argv[0], arg->argv);\n\tSYSERROR(\"Failed to exec \\\"%s\\\".\", arg->argv[0]);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int lxc_rmdir_onedev_wrapper(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic int lxc_rmdir_onedev_wrapper(void *data);\n\nstatic int start(struct lxc_handler *handler, void* data)\n{\n\tstruct start_args *arg = data;\n\n\tNOTICE(\"Exec'ing \\\"%s\\\".\", arg->argv[0]);\n\n\texecvp(arg->argv[0], arg->argv);\n\tSYSERROR(\"Failed to exec \\\"%s\\\".\", arg->argv[0]);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setsid",
          "args": [],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_stdfds",
          "args": [
            "devnull_fd"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_console_set_stdfds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
          "lines": "555-579",
          "snippet": "int lxc_console_set_stdfds(int fd)\n{\n\tif (fd < 0)\n\t\treturn 0;\n\n\tif (isatty(STDIN_FILENO))\n\t\tif (dup2(fd, STDIN_FILENO) < 0) {\n\t\t\tSYSERROR(\"failed to duplicate stdin.\");\n\t\t\treturn -1;\n\t\t}\n\n\tif (isatty(STDOUT_FILENO))\n\t\tif (dup2(fd, STDOUT_FILENO) < 0) {\n\t\t\tSYSERROR(\"failed to duplicate stdout.\");\n\t\t\treturn -1;\n\t\t}\n\n\tif (isatty(STDERR_FILENO))\n\t\tif (dup2(fd, STDERR_FILENO) < 0) {\n\t\t\tSYSERROR(\"failed to duplicate stderr.\");\n\t\t\treturn -1;\n\t\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"start.h\" \t/* for struct lxc_handler */",
            "#include \"mainloop.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"caps.h\"",
            "#include \"af_unix.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_console_set_stdfds(int fd)\n{\n\tif (fd < 0)\n\t\treturn 0;\n\n\tif (isatty(STDIN_FILENO))\n\t\tif (dup2(fd, STDIN_FILENO) < 0) {\n\t\t\tSYSERROR(\"failed to duplicate stdin.\");\n\t\t\treturn -1;\n\t\t}\n\n\tif (isatty(STDOUT_FILENO))\n\t\tif (dup2(fd, STDOUT_FILENO) < 0) {\n\t\t\tSYSERROR(\"failed to duplicate stdout.\");\n\t\t\treturn -1;\n\t\t}\n\n\tif (isatty(STDERR_FILENO))\n\t\tif (dup2(fd, STDERR_FILENO) < 0) {\n\t\t\tSYSERROR(\"failed to duplicate stderr.\");\n\t\t\treturn -1;\n\t\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open_devnull",
          "args": [],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "open_devnull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1803-1811",
          "snippet": "int open_devnull(void)\n{\n\tint fd = open(\"/dev/null\", O_RDWR);\n\n\tif (fd < 0)\n\t\tSYSERROR(\"Can't open /dev/null\");\n\n\treturn fd;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint open_devnull(void)\n{\n\tint fd = open(\"/dev/null\", O_RDWR);\n\n\tif (fd < 0)\n\t\tSYSERROR(\"Can't open /dev/null\");\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to set environment variable for container ptys.\""
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "putenv",
          "args": [
            "handler->conf->pty_names"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to set environment variable: container=lxc.\""
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "putenv",
          "args": [
            "\"container=lxc\""
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to set environment variable: %s.\"",
            "(char *)iterator->elem"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "putenv",
          "args": [
            "(char *)iterator->elem"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "iterator",
            "&handler->conf->environment"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to clear environment.\""
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clearenv",
          "args": [],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_switch_uid_gid",
          "args": [
            "new_uid",
            "new_gid"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_switch_uid_gid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "2045-2060",
          "snippet": "int lxc_switch_uid_gid(uid_t uid, gid_t gid)\n{\n\tif (setgid(gid) < 0) {\n\t\tSYSERROR(\"Failed to switch to gid %d.\", gid);\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Switched to gid %d.\", gid);\n\n\tif (setuid(uid) < 0) {\n\t\tSYSERROR(\"Failed to switch to uid %d.\", uid);\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Switched to uid %d.\", uid);\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_switch_uid_gid(uid_t uid, gid_t gid)\n{\n\tif (setgid(gid) < 0) {\n\t\tSYSERROR(\"Failed to switch to gid %d.\", gid);\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Switched to gid %d.\", gid);\n\n\tif (setuid(uid) < 0) {\n\t\tSYSERROR(\"Failed to switch to uid %d.\", uid);\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Switched to uid %d.\", uid);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_setgroups",
          "args": [
            "0",
            "NULL"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_setgroups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "2063-2072",
          "snippet": "int lxc_setgroups(int size, gid_t list[])\n{\n\tif (setgroups(size, list) < 0) {\n\t\tSYSERROR(\"Failed to setgroups().\");\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Dropped additional groups.\");\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_setgroups(int size, gid_t list[])\n{\n\tif (setgroups(size, list) < 0) {\n\t\tSYSERROR(\"Failed to setgroups().\");\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Dropped additional groups.\");\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_empty",
          "args": [
            "&handler->conf->id_map"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "94-97",
          "snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cap_is_set",
          "args": [
            "CAP_SETGID",
            "CAP_EFFECTIVE"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cap_is_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/caps.h",
          "lines": "57-59",
          "snippet": "static inline bool lxc_cap_is_set(cap_value_t cap, cap_flag_t flag) {\n\treturn true;\n}",
          "includes": [
            "#include <sys/capability.h>",
            "#include <stdbool.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/capability.h>\n#include <stdbool.h>\n#include \"config.h\"\n\nstatic inline bool lxc_cap_is_set(cap_value_t cap, cap_flag_t flag) {\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to run lxc.hook.start for container \\\"%s\\\".\"",
            "handler->name"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run_lxc_hooks",
          "args": [
            "handler->name",
            "\"start\"",
            "handler->conf",
            "handler->lxcpath",
            "NULL"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "run_lxc_hooks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3995-4029",
          "snippet": "int run_lxc_hooks(const char *name, char *hook, struct lxc_conf *conf,\n\t\t  const char *lxcpath, char *argv[])\n{\n\tint which = -1;\n\tstruct lxc_list *it;\n\n\tif (strcmp(hook, \"pre-start\") == 0)\n\t\twhich = LXCHOOK_PRESTART;\n\telse if (strcmp(hook, \"pre-mount\") == 0)\n\t\twhich = LXCHOOK_PREMOUNT;\n\telse if (strcmp(hook, \"mount\") == 0)\n\t\twhich = LXCHOOK_MOUNT;\n\telse if (strcmp(hook, \"autodev\") == 0)\n\t\twhich = LXCHOOK_AUTODEV;\n\telse if (strcmp(hook, \"start\") == 0)\n\t\twhich = LXCHOOK_START;\n\telse if (strcmp(hook, \"stop\") == 0)\n\t\twhich = LXCHOOK_STOP;\n\telse if (strcmp(hook, \"post-stop\") == 0)\n\t\twhich = LXCHOOK_POSTSTOP;\n\telse if (strcmp(hook, \"clone\") == 0)\n\t\twhich = LXCHOOK_CLONE;\n\telse if (strcmp(hook, \"destroy\") == 0)\n\t\twhich = LXCHOOK_DESTROY;\n\telse\n\t\treturn -1;\n\tlxc_list_for_each(it, &conf->hooks[which]) {\n\t\tint ret;\n\t\tchar *hookname = it->elem;\n\t\tret = run_script_argv(name, \"lxc\", hookname, hook, lxcpath, argv);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint run_lxc_hooks(const char *name, char *hook, struct lxc_conf *conf,\n\t\t  const char *lxcpath, char *argv[])\n{\n\tint which = -1;\n\tstruct lxc_list *it;\n\n\tif (strcmp(hook, \"pre-start\") == 0)\n\t\twhich = LXCHOOK_PRESTART;\n\telse if (strcmp(hook, \"pre-mount\") == 0)\n\t\twhich = LXCHOOK_PREMOUNT;\n\telse if (strcmp(hook, \"mount\") == 0)\n\t\twhich = LXCHOOK_MOUNT;\n\telse if (strcmp(hook, \"autodev\") == 0)\n\t\twhich = LXCHOOK_AUTODEV;\n\telse if (strcmp(hook, \"start\") == 0)\n\t\twhich = LXCHOOK_START;\n\telse if (strcmp(hook, \"stop\") == 0)\n\t\twhich = LXCHOOK_STOP;\n\telse if (strcmp(hook, \"post-stop\") == 0)\n\t\twhich = LXCHOOK_POSTSTOP;\n\telse if (strcmp(hook, \"clone\") == 0)\n\t\twhich = LXCHOOK_CLONE;\n\telse if (strcmp(hook, \"destroy\") == 0)\n\t\twhich = LXCHOOK_DESTROY;\n\telse\n\t\treturn -1;\n\tlxc_list_for_each(it, &conf->hooks[which]) {\n\t\tint ret;\n\t\tchar *hookname = it->elem;\n\t\tret = run_script_argv(name, \"lxc\", hookname, hook, lxcpath, argv);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_seccomp_load",
          "args": [
            "handler->conf"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_load",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxcseccomp.h",
          "lines": "34-36",
          "snippet": "static inline int lxc_seccomp_load(struct lxc_conf *conf) {\n\treturn 0;\n}",
          "includes": [
            "#include \"conf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"conf.h\"\n\nstatic inline int lxc_seccomp_load(struct lxc_conf *conf) {\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tmp_proc_unmount",
          "args": [
            "handler->conf"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "tmp_proc_unmount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3650-3656",
          "snippet": "void tmp_proc_unmount(struct lxc_conf *lxc_conf)\n{\n\tif (lxc_conf->tmp_umount_proc == 1) {\n\t\tumount(\"/proc\");\n\t\tlxc_conf->tmp_umount_proc = 0;\n\t}\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid tmp_proc_unmount(struct lxc_conf *lxc_conf)\n{\n\tif (lxc_conf->tmp_umount_proc == 1) {\n\t\tumount(\"/proc\");\n\t\tlxc_conf->tmp_umount_proc = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Set PR_SET_NO_NEW_PRIVS to block execve() gainable privileges.\""
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Could not set PR_SET_NO_NEW_PRIVS to block execve() gainable privileges.\""
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prctl",
          "args": [
            "PR_SET_NO_NEW_PRIVS",
            "1",
            "0",
            "0",
            "0"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lsm_process_label_set",
          "args": [
            "NULL",
            "handler->conf",
            "1",
            "1"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "lsm_process_label_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lsm/lsm.h",
          "lines": "52-53",
          "snippet": "static inline int         lsm_process_label_set(const char *label,\n\t\tstruct lxc_conf *conf, int use_default, int on_exec) { return 0; }",
          "includes": [
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n\nstatic inline int         lsm_process_label_set(const char *label,\n\t\tstruct lxc_conf *conf, int use_default, int on_exec) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Unshared CLONE_NEWCGROUP.\""
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Failed to unshare CLONE_NEWCGROUP.\""
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unshare",
          "args": [
            "CLONE_NEWCGROUP"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "unshare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.h",
          "lines": "73-81",
          "snippet": "static inline int unshare(int flags)\n{\n#ifdef __NR_unshare\n\treturn syscall(__NR_unshare, flags);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}",
          "includes": [
            "#include <stdint.h>",
            "#  include <sys/signalfd.h>",
            "#include <../include/getline.h>",
            "#include \"initutils.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#  include <sys/signalfd.h>\n#include <../include/getline.h>\n#include \"initutils.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic inline int unshare(int flags)\n{\n#ifdef __NR_unshare\n\treturn syscall(__NR_unshare, flags);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgns_supported",
          "args": [],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "cgns_supported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1247-1250",
          "snippet": "bool cgns_supported(void)\n{\n\treturn file_exists(\"/proc/self/ns/cgroup\");\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool cgns_supported(void)\n{\n\treturn file_exists(\"/proc/self/ns/cgroup\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_sync_barrier_parent",
          "args": [
            "handler",
            "LXC_SYNC_CGROUP"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_sync_barrier_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/sync.c",
          "lines": "87-90",
          "snippet": "int lxc_sync_barrier_parent(struct lxc_handler *handler, int sequence)\n{\n\treturn __sync_barrier(handler->sv[0], sequence);\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"log.h\"",
            "#include \"sync.h\"",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"log.h\"\n#include \"sync.h\"\n#include <fcntl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n\nint lxc_sync_barrier_parent(struct lxc_handler *handler, int sequence)\n{\n\treturn __sync_barrier(handler->sv[0], sequence);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to setup container \\\"%s\\\".\"",
            "handler->name"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_setup",
          "args": [
            "handler"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3838-3993",
          "snippet": "int lxc_setup(struct lxc_handler *handler)\n{\n\tconst char *name = handler->name;\n\tstruct lxc_conf *lxc_conf = handler->conf;\n\tconst char *lxcpath = handler->lxcpath;\n\n\tif (do_rootfs_setup(lxc_conf, name, lxcpath) < 0) {\n\t\tERROR(\"Error setting up rootfs mount after spawn\");\n\t\treturn -1;\n\t}\n\n\tif (lxc_conf->inherit_ns_fd[LXC_NS_UTS] == -1) {\n\t\tif (setup_utsname(lxc_conf->utsname)) {\n\t\t\tERROR(\"failed to setup the utsname for '%s'\", name);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (setup_network(&lxc_conf->network)) {\n\t\tERROR(\"failed to setup the network for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tif (lxc_conf->autodev > 0) {\n\t\tif (mount_autodev(name, &lxc_conf->rootfs, lxcpath)) {\n\t\t\tERROR(\"failed to mount /dev in the container\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* do automatic mounts (mainly /proc and /sys), but exclude\n\t * those that need to wait until other stuff has finished\n\t */\n\tif (lxc_mount_auto_mounts(lxc_conf, lxc_conf->auto_mounts & ~LXC_AUTO_CGROUP_MASK, handler) < 0) {\n\t\tERROR(\"failed to setup the automatic mounts for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tif (setup_mount(&lxc_conf->rootfs, lxc_conf->fstab, name, lxcpath)) {\n\t\tERROR(\"failed to setup the mounts for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tif (!lxc_list_empty(&lxc_conf->mount_list) && setup_mount_entries(&lxc_conf->rootfs, &lxc_conf->mount_list, name, lxcpath)) {\n\t\tERROR(\"failed to setup the mount entries for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\t/* Make sure any start hooks are in the container */\n\tif (!verify_start_hooks(lxc_conf))\n\t\treturn -1;\n\n\tif (lxc_conf->is_execute)\n\t\tlxc_execute_bind_init(lxc_conf);\n\n\t/* now mount only cgroup, if wanted;\n\t * before, /sys could not have been mounted\n\t * (is either mounted automatically or via fstab entries)\n\t */\n\tif (lxc_mount_auto_mounts(lxc_conf, lxc_conf->auto_mounts & LXC_AUTO_CGROUP_MASK, handler) < 0) {\n\t\tERROR(\"failed to setup the automatic mounts for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tif (run_lxc_hooks(name, \"mount\", lxc_conf, lxcpath, NULL)) {\n\t\tERROR(\"failed to run mount hooks for container '%s'.\", name);\n\t\treturn -1;\n\t}\n\n\tif (lxc_conf->autodev > 0) {\n\t\tbool mount_console = lxc_conf->console.path && !strcmp(lxc_conf->console.path, \"none\");\n\n\t\tif (run_lxc_hooks(name, \"autodev\", lxc_conf, lxcpath, NULL)) {\n\t\t\tERROR(\"failed to run autodev hooks for container '%s'.\", name);\n\t\t\treturn -1;\n\t\t}\n\t\tif (fill_autodev(&lxc_conf->rootfs, mount_console)) {\n\t\t\tERROR(\"failed to populate /dev in the container\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!lxc_conf->is_execute && setup_console(&lxc_conf->rootfs, &lxc_conf->console, lxc_conf->ttydir)) {\n\t\tERROR(\"failed to setup the console for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tif (lxc_conf->kmsg) {\n\t\tif (setup_kmsg(&lxc_conf->rootfs, &lxc_conf->console))  // don't fail\n\t\t\tERROR(\"failed to setup kmsg for '%s'\", name);\n\t}\n\n\tif (!lxc_conf->is_execute && setup_dev_symlinks(&lxc_conf->rootfs)) {\n\t\tERROR(\"failed to setup /dev symlinks for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\t/* mount /proc if it's not already there */\n\tif (tmp_proc_mount(lxc_conf) < 0) {\n\t\tERROR(\"failed to LSM mount proc for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tif (setup_pivot_root(&lxc_conf->rootfs)) {\n\t\tERROR(\"failed to set rootfs for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tif (setup_pts(lxc_conf->pts)) {\n\t\tERROR(\"failed to setup the new pts instance\");\n\t\treturn -1;\n\t}\n\n\tif (lxc_create_tty(name, lxc_conf)) {\n\t\tERROR(\"failed to create the ttys\");\n\t\treturn -1;\n\t}\n\n\tif (send_ttys_to_parent(handler) < 0) {\n\t\tERROR(\"failure sending console info to parent\");\n\t\treturn -1;\n\t}\n\n\n\tif (!lxc_conf->is_execute && setup_tty(lxc_conf)) {\n\t\tERROR(\"failed to setup the ttys for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tif (lxc_conf->pty_names && setenv(\"container_ttys\", lxc_conf->pty_names, 1))\n\t\tSYSERROR(\"failed to set environment variable for container ptys\");\n\n\n\tif (setup_personality(lxc_conf->personality)) {\n\t\tERROR(\"failed to setup personality\");\n\t\treturn -1;\n\t}\n\n\tif (!lxc_list_empty(&lxc_conf->keepcaps)) {\n\t\tif (!lxc_list_empty(&lxc_conf->caps)) {\n\t\t\tERROR(\"Container requests lxc.cap.drop and lxc.cap.keep: either use lxc.cap.drop or lxc.cap.keep, not both.\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (dropcaps_except(&lxc_conf->keepcaps)) {\n\t\t\tERROR(\"failed to keep requested caps\");\n\t\t\treturn -1;\n\t\t}\n\t} else if (setup_caps(&lxc_conf->caps)) {\n\t\tERROR(\"failed to drop capabilities\");\n\t\treturn -1;\n\t}\n\n\tNOTICE(\"'%s' is setup.\", name);\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int in_caplist(int cap, struct lxc_list *caps);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int in_caplist(int cap, struct lxc_list *caps);\n\nint lxc_setup(struct lxc_handler *handler)\n{\n\tconst char *name = handler->name;\n\tstruct lxc_conf *lxc_conf = handler->conf;\n\tconst char *lxcpath = handler->lxcpath;\n\n\tif (do_rootfs_setup(lxc_conf, name, lxcpath) < 0) {\n\t\tERROR(\"Error setting up rootfs mount after spawn\");\n\t\treturn -1;\n\t}\n\n\tif (lxc_conf->inherit_ns_fd[LXC_NS_UTS] == -1) {\n\t\tif (setup_utsname(lxc_conf->utsname)) {\n\t\t\tERROR(\"failed to setup the utsname for '%s'\", name);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (setup_network(&lxc_conf->network)) {\n\t\tERROR(\"failed to setup the network for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tif (lxc_conf->autodev > 0) {\n\t\tif (mount_autodev(name, &lxc_conf->rootfs, lxcpath)) {\n\t\t\tERROR(\"failed to mount /dev in the container\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* do automatic mounts (mainly /proc and /sys), but exclude\n\t * those that need to wait until other stuff has finished\n\t */\n\tif (lxc_mount_auto_mounts(lxc_conf, lxc_conf->auto_mounts & ~LXC_AUTO_CGROUP_MASK, handler) < 0) {\n\t\tERROR(\"failed to setup the automatic mounts for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tif (setup_mount(&lxc_conf->rootfs, lxc_conf->fstab, name, lxcpath)) {\n\t\tERROR(\"failed to setup the mounts for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tif (!lxc_list_empty(&lxc_conf->mount_list) && setup_mount_entries(&lxc_conf->rootfs, &lxc_conf->mount_list, name, lxcpath)) {\n\t\tERROR(\"failed to setup the mount entries for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\t/* Make sure any start hooks are in the container */\n\tif (!verify_start_hooks(lxc_conf))\n\t\treturn -1;\n\n\tif (lxc_conf->is_execute)\n\t\tlxc_execute_bind_init(lxc_conf);\n\n\t/* now mount only cgroup, if wanted;\n\t * before, /sys could not have been mounted\n\t * (is either mounted automatically or via fstab entries)\n\t */\n\tif (lxc_mount_auto_mounts(lxc_conf, lxc_conf->auto_mounts & LXC_AUTO_CGROUP_MASK, handler) < 0) {\n\t\tERROR(\"failed to setup the automatic mounts for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tif (run_lxc_hooks(name, \"mount\", lxc_conf, lxcpath, NULL)) {\n\t\tERROR(\"failed to run mount hooks for container '%s'.\", name);\n\t\treturn -1;\n\t}\n\n\tif (lxc_conf->autodev > 0) {\n\t\tbool mount_console = lxc_conf->console.path && !strcmp(lxc_conf->console.path, \"none\");\n\n\t\tif (run_lxc_hooks(name, \"autodev\", lxc_conf, lxcpath, NULL)) {\n\t\t\tERROR(\"failed to run autodev hooks for container '%s'.\", name);\n\t\t\treturn -1;\n\t\t}\n\t\tif (fill_autodev(&lxc_conf->rootfs, mount_console)) {\n\t\t\tERROR(\"failed to populate /dev in the container\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!lxc_conf->is_execute && setup_console(&lxc_conf->rootfs, &lxc_conf->console, lxc_conf->ttydir)) {\n\t\tERROR(\"failed to setup the console for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tif (lxc_conf->kmsg) {\n\t\tif (setup_kmsg(&lxc_conf->rootfs, &lxc_conf->console))  // don't fail\n\t\t\tERROR(\"failed to setup kmsg for '%s'\", name);\n\t}\n\n\tif (!lxc_conf->is_execute && setup_dev_symlinks(&lxc_conf->rootfs)) {\n\t\tERROR(\"failed to setup /dev symlinks for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\t/* mount /proc if it's not already there */\n\tif (tmp_proc_mount(lxc_conf) < 0) {\n\t\tERROR(\"failed to LSM mount proc for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tif (setup_pivot_root(&lxc_conf->rootfs)) {\n\t\tERROR(\"failed to set rootfs for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tif (setup_pts(lxc_conf->pts)) {\n\t\tERROR(\"failed to setup the new pts instance\");\n\t\treturn -1;\n\t}\n\n\tif (lxc_create_tty(name, lxc_conf)) {\n\t\tERROR(\"failed to create the ttys\");\n\t\treturn -1;\n\t}\n\n\tif (send_ttys_to_parent(handler) < 0) {\n\t\tERROR(\"failure sending console info to parent\");\n\t\treturn -1;\n\t}\n\n\n\tif (!lxc_conf->is_execute && setup_tty(lxc_conf)) {\n\t\tERROR(\"failed to setup the ttys for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tif (lxc_conf->pty_names && setenv(\"container_ttys\", lxc_conf->pty_names, 1))\n\t\tSYSERROR(\"failed to set environment variable for container ptys\");\n\n\n\tif (setup_personality(lxc_conf->personality)) {\n\t\tERROR(\"failed to setup personality\");\n\t\treturn -1;\n\t}\n\n\tif (!lxc_list_empty(&lxc_conf->keepcaps)) {\n\t\tif (!lxc_list_empty(&lxc_conf->caps)) {\n\t\t\tERROR(\"Container requests lxc.cap.drop and lxc.cap.keep: either use lxc.cap.drop or lxc.cap.keep, not both.\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (dropcaps_except(&lxc_conf->keepcaps)) {\n\t\t\tERROR(\"failed to keep requested caps\");\n\t\t\treturn -1;\n\t\t}\n\t} else if (setup_caps(&lxc_conf->caps)) {\n\t\tERROR(\"failed to drop capabilities\");\n\t\treturn -1;\n\t}\n\n\tNOTICE(\"'%s' is setup.\", name);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Using /dev/null from the host for container init's \"\n\t\t     \"standard file descriptors. Migration will not work.\""
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "path",
            "F_OK"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "sizeof(path)",
            "\"%s/dev/null\"",
            "handler->conf->rootfs.mount"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Dropped the CAP_SYS_BOOT capability.\""
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to remove the CAP_SYS_BOOT capability.\""
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prctl",
          "args": [
            "PR_CAPBSET_DROP",
            "CAP_SYS_BOOT",
            "0",
            "0",
            "0"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_top_failing_dir",
          "args": [
            "handler->lxcpath"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "print_top_failing_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "93-116",
          "snippet": "static void print_top_failing_dir(const char *path)\n{\n\tsize_t len = strlen(path);\n\tchar *copy = alloca(len + 1), *p, *e, saved;\n\tstrcpy(copy, path);\n\n\tp = copy;\n\te = copy + len;\n\twhile (p < e) {\n\t\twhile (p < e && *p == '/')\n\t\t\tp++;\n\t\twhile (p < e && *p != '/')\n\t\t\tp++;\n\t\tsaved = *p;\n\t\t*p = '\\0';\n\t\tif (access(copy, X_OK)) {\n\t\t\tSYSERROR(\"Could not access %s. Please grant it x \"\n\t\t\t\t \"access, or add an ACL for the container \"\n\t\t\t\t \"root.\", copy);\n\t\t\treturn;\n\t\t}\n\t\t*p = saved;\n\t}\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic void print_top_failing_dir(const char *path)\n{\n\tsize_t len = strlen(path);\n\tchar *copy = alloca(len + 1), *p, *e, saved;\n\tstrcpy(copy, path);\n\n\tp = copy;\n\te = copy + len;\n\twhile (p < e) {\n\t\twhile (p < e && *p == '/')\n\t\t\tp++;\n\t\twhile (p < e && *p != '/')\n\t\t\tp++;\n\t\tsaved = *p;\n\t\t*p = '\\0';\n\t\tif (access(copy, X_OK)) {\n\t\t\tSYSERROR(\"Could not access %s. Please grant it x \"\n\t\t\t\t \"access, or add an ACL for the container \"\n\t\t\t\t \"root.\", copy);\n\t\t\treturn;\n\t\t}\n\t\t*p = saved;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "handler->lxcpath",
            "X_OK"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unpriv_netifindex",
          "args": [
            "&handler->conf->network"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "read_unpriv_netifindex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "691-714",
          "snippet": "static int read_unpriv_netifindex(struct lxc_list *network)\n{\n\tstruct lxc_list *iterator;\n\tstruct lxc_netdev *netdev;\n\n\tif (netpipe == -1)\n\t\treturn 0;\n\tlxc_list_for_each(iterator, network) {\n\t\tnetdev = iterator->elem;\n\t\tif (netdev->type != LXC_NET_VETH)\n\t\t\tcontinue;\n\t\tif (!(netdev->name = malloc(IFNAMSIZ))) {\n\t\t\tERROR(\"Out of memory.\");\n\t\t\tclose(netpipe);\n\t\t\treturn -1;\n\t\t}\n\t\tif (read(netpipe, netdev->name, IFNAMSIZ) != IFNAMSIZ) {\n\t\t\tclose(netpipe);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tclose(netpipe);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);",
            "static int netpipe = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);\nstatic int netpipe = -1;\n\nstatic int read_unpriv_netifindex(struct lxc_list *network)\n{\n\tstruct lxc_list *iterator;\n\tstruct lxc_netdev *netdev;\n\n\tif (netpipe == -1)\n\t\treturn 0;\n\tlxc_list_for_each(iterator, network) {\n\t\tnetdev = iterator->elem;\n\t\tif (netdev->type != LXC_NET_VETH)\n\t\t\tcontinue;\n\t\tif (!(netdev->name = malloc(IFNAMSIZ))) {\n\t\t\tERROR(\"Out of memory.\");\n\t\t\tclose(netpipe);\n\t\t\treturn -1;\n\t\t}\n\t\tif (read(netpipe, netdev->name, IFNAMSIZ) != IFNAMSIZ) {\n\t\t\tclose(netpipe);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tclose(netpipe);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Unshared CLONE_NEWNET.\""
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to unshare CLONE_NEWNET.\""
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_sync_wait_parent",
          "args": [
            "handler",
            "LXC_SYNC_STARTUP"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_sync_wait_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/sync.c",
          "lines": "102-105",
          "snippet": "int lxc_sync_wait_parent(struct lxc_handler *handler, int sequence)\n{\n\treturn __sync_wait(handler->sv[0], sequence);\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"log.h\"",
            "#include \"sync.h\"",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"log.h\"\n#include \"sync.h\"\n#include <fcntl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n\nint lxc_sync_wait_parent(struct lxc_handler *handler, int sequence)\n{\n\treturn __sync_wait(handler->sv[0], sequence);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_sync_fini_parent",
          "args": [
            "handler"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_sync_fini_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/sync.c",
          "lines": "141-147",
          "snippet": "void lxc_sync_fini_parent(struct lxc_handler *handler)\n{\n\tif (handler->sv[1] != -1) {\n\t\tclose(handler->sv[1]);\n\t\thandler->sv[1] = -1;\n\t}\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"log.h\"",
            "#include \"sync.h\"",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"log.h\"\n#include \"sync.h\"\n#include <fcntl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n\nvoid lxc_sync_fini_parent(struct lxc_handler *handler)\n{\n\tif (handler->sv[1] != -1) {\n\t\tclose(handler->sv[1]);\n\t\thandler->sv[1] = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to set PR_SET_PDEATHSIG to SIGKILL.\""
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prctl",
          "args": [
            "PR_SET_PDEATHSIG",
            "SIGKILL",
            "0",
            "0",
            "0"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to set signal mask.\""
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_SETMASK",
            "&handler->oldmask",
            "NULL"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\n#define PR_SET_NO_NEW_PRIVS 38\n#define PR_CAPBSET_DROP 24\n\nstatic bool do_destroy_container(struct lxc_conf *conf);\nstatic int lxc_rmdir_onedev_wrapper(void *data);\nstatic void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);\n\nstatic int do_start(void *data)\n{\n\tstruct lxc_list *iterator;\n\tstruct lxc_handler *handler = data;\n\tint devnull_fd = -1, ret;\n\tchar path[PATH_MAX];\n\n\tif (sigprocmask(SIG_SETMASK, &handler->oldmask, NULL)) {\n\t\tSYSERROR(\"Failed to set signal mask.\");\n\t\treturn -1;\n\t}\n\n\t/* This prctl must be before the synchro, so if the parent dies before\n\t * we set the parent death signal, we will detect its death with the\n\t * synchro right after, otherwise we have a window where the parent can\n\t * exit before we set the pdeath signal leading to a unsupervized\n\t * container.\n\t */\n\tif (prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0)) {\n\t\tSYSERROR(\"Failed to set PR_SET_PDEATHSIG to SIGKILL.\");\n\t\treturn -1;\n\t}\n\n\tlxc_sync_fini_parent(handler);\n\n\t/* Don't leak the pinfd to the container. */\n\tif (handler->pinfd >= 0) {\n\t\tclose(handler->pinfd);\n\t}\n\n\tif (lxc_sync_wait_parent(handler, LXC_SYNC_STARTUP))\n\t\treturn -1;\n\n\t/* Unshare CLONE_NEWNET after CLONE_NEWUSER. See\n\t * https://github.com/lxc/lxd/issues/1978.\n\t */\n\tif ((handler->clone_flags & (CLONE_NEWNET | CLONE_NEWUSER)) ==\n\t    (CLONE_NEWNET | CLONE_NEWUSER)) {\n\t\tret = unshare(CLONE_NEWNET);\n\t\tif (ret < 0) {\n\t\t\tSYSERROR(\"Failed to unshare CLONE_NEWNET.\");\n\t\t\tgoto out_warn_father;\n\t\t}\n\t\tINFO(\"Unshared CLONE_NEWNET.\");\n\t}\n\n\t/* Tell the parent task it can begin to configure the container and wait\n\t * for it to finish.\n\t */\n\tif (lxc_sync_barrier_parent(handler, LXC_SYNC_CONFIGURE))\n\t\treturn -1;\n\n\tif (read_unpriv_netifindex(&handler->conf->network) < 0)\n\t\tgoto out_warn_father;\n\n\t/* If we are in a new user namespace, become root there to have\n\t * privilege over our namespace.\n\t */\n\tif (!lxc_list_empty(&handler->conf->id_map)) {\n\t\tif (lxc_switch_uid_gid(0, 0) < 0)\n\t\t\tgoto out_warn_father;\n\n\t\t/* Drop groups only after we switched to a valid gid in the new\n\t\t * user namespace.\n\t\t */\n\t\tif (lxc_setgroups(0, NULL) < 0)\n\t\t\tgoto out_warn_father;\n\t}\n\n\tif (access(handler->lxcpath, X_OK)) {\n\t\tprint_top_failing_dir(handler->lxcpath);\n\t\tgoto out_warn_father;\n\t}\n\n\t#if HAVE_LIBCAP\n\tif (handler->conf->need_utmp_watch) {\n\t\tif (prctl(PR_CAPBSET_DROP, CAP_SYS_BOOT, 0, 0, 0)) {\n\t\t\tSYSERROR(\"Failed to remove the CAP_SYS_BOOT capability.\");\n\t\t\tgoto out_warn_father;\n\t\t}\n\t\tDEBUG(\"Dropped the CAP_SYS_BOOT capability.\");\n\t}\n\t#endif\n\n\tret = snprintf(path, sizeof(path), \"%s/dev/null\", handler->conf->rootfs.mount);\n\tif (ret < 0 || ret >= sizeof(path))\n\t\tgoto out_warn_father;\n\n\t/* In order to checkpoint restore, we need to have everything in the\n\t * same mount namespace. However, some containers may not have a\n\t * reasonable /dev (in particular, they may not have /dev/null), so we\n\t * can't set init's std fds to /dev/null by opening it from inside the\n\t * container.\n\t *\n\t * If that's the case, fall back to using the host's /dev/null. This\n\t * means that migration won't work, but at least we won't spew output\n\t * where it isn't wanted.\n\t */\n\tif (handler->backgrounded && !handler->conf->autodev && access(path, F_OK) < 0) {\n\t\tdevnull_fd = open_devnull();\n\n\t\tif (devnull_fd < 0)\n\t\t\tgoto out_warn_father;\n\t\tWARN(\"Using /dev/null from the host for container init's \"\n\t\t     \"standard file descriptors. Migration will not work.\");\n\t}\n\n\t/* Setup the container, ip, names, utsname, ... */\n\tif (lxc_setup(handler)) {\n\t\tERROR(\"Failed to setup container \\\"%s\\\".\", handler->name);\n\t\tgoto out_warn_father;\n\t}\n\n\t/* Ask father to setup cgroups and wait for him to finish. */\n\tif (lxc_sync_barrier_parent(handler, LXC_SYNC_CGROUP))\n\t\tgoto out_error;\n\n\t/* Unshare cgroup namespace after we have setup our cgroups. If we do it\n\t * earlier we end up with a wrong view of /proc/self/cgroup. For\n\t * example, assume we unshare(CLONE_NEWCGROUP) first, and then create\n\t * the cgroup for the container, say /sys/fs/cgroup/cpuset/lxc/c, then\n\t * /proc/self/cgroup would show us:\n\t *\n\t *\t8:cpuset:/lxc/c\n\t *\n\t * whereas it should actually show\n\t *\n\t *\t8:cpuset:/\n\t */\n\tif (cgns_supported()) {\n\t\tif (unshare(CLONE_NEWCGROUP) < 0) {\n\t\t\tINFO(\"Failed to unshare CLONE_NEWCGROUP.\");\n\t\t\tgoto out_warn_father;\n\t\t}\n\t\tINFO(\"Unshared CLONE_NEWCGROUP.\");\n\t}\n\n\t/* Set the label to change to when we exec(2) the container's init. */\n\tif (lsm_process_label_set(NULL, handler->conf, 1, 1) < 0)\n\t\tgoto out_warn_father;\n\n\t/* Set PR_SET_NO_NEW_PRIVS after we changed the lsm label. If we do it\n\t * before we aren't allowed anymore.\n\t */\n\tif (handler->conf->no_new_privs) {\n\t\tif (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0) {\n\t\t\tSYSERROR(\"Could not set PR_SET_NO_NEW_PRIVS to block execve() gainable privileges.\");\n\t\t\tgoto out_warn_father;\n\t\t}\n\t\tDEBUG(\"Set PR_SET_NO_NEW_PRIVS to block execve() gainable privileges.\");\n\t}\n\n\t/* Some init's such as busybox will set sane tty settings on stdin,\n\t * stdout, stderr which it thinks is the console. We already set them\n\t * the way we wanted on the real terminal, and we want init to do its\n\t * setup on its console ie. the pty allocated in lxc_console_create() so\n\t * make sure that that pty is stdin,stdout,stderr.\n\t */\n\tif (lxc_console_set_stdfds(handler->conf->console.slave) < 0)\n\t\tgoto out_warn_father;\n\n\t/* If we mounted a temporary proc, then unmount it now. */\n\ttmp_proc_unmount(handler->conf);\n\n\tif (lxc_seccomp_load(handler->conf) != 0)\n\t\tgoto out_warn_father;\n\n\tif (run_lxc_hooks(handler->name, \"start\", handler->conf, handler->lxcpath, NULL)) {\n\t\tERROR(\"Failed to run lxc.hook.start for container \\\"%s\\\".\", handler->name);\n\t\tgoto out_warn_father;\n\t}\n\n\t/* The container has been setup. We can now switch to an unprivileged\n\t * uid/gid.\n\t */\n\tif (handler->conf->is_execute) {\n\t\tbool have_cap_setgid;\n\t\tuid_t new_uid = handler->conf->init_uid;\n\t\tgid_t new_gid = handler->conf->init_gid;\n\n\t\t/* If we are in a new user namespace we already dropped all\n\t\t * groups when we switched to root in the new user namespace\n\t\t * further above. Only drop groups if we can, so ensure that we\n\t\t * have necessary privilege.\n\t\t */\n\t\t#if HAVE_LIBCAP\n\t\thave_cap_setgid = lxc_cap_is_set(CAP_SETGID, CAP_EFFECTIVE);\n\t\t#else\n\t\thave_cap_setgid = false;\n\t\t#endif\n\t\tif (lxc_list_empty(&handler->conf->id_map) && have_cap_setgid) {\n\t\t\tif (lxc_setgroups(0, NULL) < 0)\n\t\t\t\tgoto out_warn_father;\n\t\t}\n\n\t\tif (lxc_switch_uid_gid(new_uid, new_gid) < 0)\n\t\t\tgoto out_warn_father;\n\t}\n\n\t/* The clearenv() and putenv() calls have been moved here to allow us to\n\t * use environment variables passed to the various hooks, such as the\n\t * start hook above. Not all of the variables like CONFIG_PATH or ROOTFS\n\t * are valid in this context but others are.\n\t */\n\tif (clearenv()) {\n\t\tSYSERROR(\"Failed to clear environment.\");\n\t\t/* Don't error out though. */\n\t}\n\n\tlxc_list_for_each(iterator, &handler->conf->environment) {\n\t\tif (putenv((char *)iterator->elem)) {\n\t\t\tSYSERROR(\"Failed to set environment variable: %s.\", (char *)iterator->elem);\n\t\t\tgoto out_warn_father;\n\t\t}\n\t}\n\n\tif (putenv(\"container=lxc\")) {\n\t\tSYSERROR(\"Failed to set environment variable: container=lxc.\");\n\t\tgoto out_warn_father;\n\t}\n\n\tif (handler->conf->pty_names) {\n\t\tif (putenv(handler->conf->pty_names)) {\n\t\t\tSYSERROR(\"Failed to set environment variable for container ptys.\");\n\t\t\tgoto out_warn_father;\n\t\t}\n\t}\n\n\tclose(handler->sigfd);\n\n\tif (devnull_fd < 0) {\n\t\tdevnull_fd = open_devnull();\n\n\t\tif (devnull_fd < 0)\n\t\t\tgoto out_warn_father;\n\t}\n\n\tif (handler->backgrounded && set_stdfds(devnull_fd))\n\t\tgoto out_warn_father;\n\n\tif (devnull_fd >= 0) {\n\t\tclose(devnull_fd);\n\t\tdevnull_fd = -1;\n\t}\n\n\tsetsid();\n\n\t/* After this call, we are in error because this ops should not return\n\t * as it execs.\n\t */\n\thandler->ops->start(handler, handler->data);\n\nout_warn_father:\n\t/* We want the parent to know something went wrong, so we return a\n\t * special error code.\n\t */\n\tlxc_sync_wake_parent(handler, LXC_SYNC_ERROR);\n\nout_error:\n\tif (devnull_fd >= 0)\n\t\tclose(devnull_fd);\n\n\treturn -1;\n}"
  },
  {
    "function_name": "read_unpriv_netifindex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
    "lines": "691-714",
    "snippet": "static int read_unpriv_netifindex(struct lxc_list *network)\n{\n\tstruct lxc_list *iterator;\n\tstruct lxc_netdev *netdev;\n\n\tif (netpipe == -1)\n\t\treturn 0;\n\tlxc_list_for_each(iterator, network) {\n\t\tnetdev = iterator->elem;\n\t\tif (netdev->type != LXC_NET_VETH)\n\t\t\tcontinue;\n\t\tif (!(netdev->name = malloc(IFNAMSIZ))) {\n\t\t\tERROR(\"Out of memory.\");\n\t\t\tclose(netpipe);\n\t\t\treturn -1;\n\t\t}\n\t\tif (read(netpipe, netdev->name, IFNAMSIZ) != IFNAMSIZ) {\n\t\t\tclose(netpipe);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tclose(netpipe);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <sys/reboot.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"sync.h\"",
      "#include \"start.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"lxcutmp.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"console.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/capability.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <alloca.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);",
      "static int netpipe = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "netpipe"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "close_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "118-128",
          "snippet": "static void close_ns(int ns_fd[LXC_NS_MAX])\n{\n\tint i;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (ns_fd[i] > -1) {\n\t\t\tclose(ns_fd[i]);\n\t\t\tns_fd[i] = -1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic void close_ns(int ns_fd[LXC_NS_MAX])\n{\n\tint i;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (ns_fd[i] > -1) {\n\t\t\tclose(ns_fd[i]);\n\t\t\tns_fd[i] = -1;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "netpipe",
            "netdev->name",
            "IFNAMSIZ"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "962-990",
          "snippet": "int lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Out of memory.\""
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "IFNAMSIZ"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "iterator",
            "network"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);\nstatic int netpipe = -1;\n\nstatic int read_unpriv_netifindex(struct lxc_list *network)\n{\n\tstruct lxc_list *iterator;\n\tstruct lxc_netdev *netdev;\n\n\tif (netpipe == -1)\n\t\treturn 0;\n\tlxc_list_for_each(iterator, network) {\n\t\tnetdev = iterator->elem;\n\t\tif (netdev->type != LXC_NET_VETH)\n\t\t\tcontinue;\n\t\tif (!(netdev->name = malloc(IFNAMSIZ))) {\n\t\t\tERROR(\"Out of memory.\");\n\t\t\tclose(netpipe);\n\t\t\treturn -1;\n\t\t}\n\t\tif (read(netpipe, netdev->name, IFNAMSIZ) != IFNAMSIZ) {\n\t\t\tclose(netpipe);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tclose(netpipe);\n\treturn 0;\n}"
  },
  {
    "function_name": "count_veths",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
    "lines": "676-689",
    "snippet": "static inline int count_veths(struct lxc_list *network)\n{\n\tstruct lxc_list *iterator;\n\tstruct lxc_netdev *netdev;\n\tint count = 0;\n\n\tlxc_list_for_each(iterator, network) {\n\t\tnetdev = iterator->elem;\n\t\tif (netdev->type != LXC_NET_VETH)\n\t\t\tcontinue;\n\t\tcount++;\n\t}\n\treturn count;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <sys/reboot.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"sync.h\"",
      "#include \"start.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"lxcutmp.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"console.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/capability.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <alloca.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "iterator",
            "network"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic inline int count_veths(struct lxc_list *network)\n{\n\tstruct lxc_list *iterator;\n\tstruct lxc_netdev *netdev;\n\tint count = 0;\n\n\tlxc_list_for_each(iterator, network) {\n\t\tnetdev = iterator->elem;\n\t\tif (netdev->type != LXC_NET_VETH)\n\t\t\tcontinue;\n\t\tcount++;\n\t}\n\treturn count;\n}"
  },
  {
    "function_name": "must_drop_cap_sys_boot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
    "lines": "620-669",
    "snippet": "static int must_drop_cap_sys_boot(struct lxc_conf *conf)\n{\n\tFILE *f;\n\tint ret, cmd, v, flags;\n\tlong stack_size = 4096;\n\tvoid *stack = alloca(stack_size);\n\tint status;\n\tpid_t pid;\n\n\tf = fopen(\"/proc/sys/kernel/ctrl-alt-del\", \"r\");\n\tif (!f) {\n\t\tDEBUG(\"failed to open /proc/sys/kernel/ctrl-alt-del\");\n\t\treturn 1;\n\t}\n\n\tret = fscanf(f, \"%d\", &v);\n\tfclose(f);\n\tif (ret != 1) {\n\t\tDEBUG(\"Failed to read /proc/sys/kernel/ctrl-alt-del.\");\n\t\treturn 1;\n\t}\n\tcmd = v ? LINUX_REBOOT_CMD_CAD_ON : LINUX_REBOOT_CMD_CAD_OFF;\n\n\tflags = CLONE_NEWPID | SIGCHLD;\n\tif (!lxc_list_empty(&conf->id_map))\n\t\tflags |= CLONE_NEWUSER;\n\n#ifdef __ia64__\n\tpid = __clone2(container_reboot_supported, stack, stack_size, flags,  &cmd);\n#else\n\tstack += stack_size;\n\tpid = clone(container_reboot_supported, stack, flags, &cmd);\n#endif\n\tif (pid < 0) {\n\t\tif (flags & CLONE_NEWUSER)\n\t\t\tERROR(\"Failed to clone (%#x): %s (includes CLONE_NEWUSER).\", flags, strerror(errno));\n\t\telse\n\t\t\tERROR(\"Failed to clone (%#x): %s.\", flags, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (wait(&status) < 0) {\n\t\tSYSERROR(\"Unexpected wait error: %m.\");\n\t\treturn -1;\n\t}\n\n\tif (WEXITSTATUS(status) != 1)\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <sys/reboot.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"sync.h\"",
      "#include \"start.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"lxcutmp.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"console.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/capability.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <alloca.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_destroy_container(struct lxc_conf *conf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Unexpected wait error: %m.\""
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait",
          "args": [
            "&status"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_get_wait_states",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "4220-4228",
          "snippet": "int lxc_get_wait_states(const char **states)\n{\n\tint i;\n\n\tif (states)\n\t\tfor (i=0; i<MAX_STATE; i++)\n\t\t\tstates[i] = lxc_state2str(i);\n\treturn MAX_STATE;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nint lxc_get_wait_states(const char **states)\n{\n\tint i;\n\n\tif (states)\n\t\tfor (i=0; i<MAX_STATE; i++)\n\t\t\tstates[i] = lxc_state2str(i);\n\treturn MAX_STATE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to clone (%#x): %s.\"",
            "flags",
            "strerror(errno)"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to clone (%#x): %s (includes CLONE_NEWUSER).\"",
            "flags",
            "strerror(errno)"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clone",
          "args": [
            "container_reboot_supported",
            "stack",
            "flags",
            "&cmd"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "do_clone_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "517-537",
          "snippet": "static int do_clone_task(struct lxc_container *c, enum task task, int flags,\n\t\t\t char **args)\n{\n\tint ret = 0;\n\n\tswitch (task) {\n\tcase DESTROY:\n\t\tret = do_clone_ephemeral(c, &my_args, args, flags);\n\t\tbreak;\n\tcase RENAME:\n\t\tret = do_clone_rename(c, my_args.newname);\n\t\tbreak;\n\tdefault:\n\t\tret = do_clone(c, my_args.newname, my_args.newpath, flags,\n\t\t\t       my_args.bdevtype, my_args.fssize, my_args.task,\n\t\t\t       args);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lxc_arguments my_args = {\n\t.progname = \"lxc-copy\",\n\t.help = \"\\n\\\n--name=NAME [-P lxcpath] -N newname [-p newpath] [-B backingstorage] [-s] [-K] [-M] [-L size [unit]] -- hook options\\n\\\n--name=NAME [-P lxcpath] [-N newname] [-p newpath] [-B backingstorage] -e [-d] [-D] [-K] [-M] [-m {bind,aufs,overlay}=/src:/dest] -- hook options\\n\\\n--name=NAME [-P lxcpath] -N newname -R\\n\\\n\\n\\\nlxc-copy clone a container\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME           NAME of the container\\n\\\n  -N, --newname=NEWNAME     NEWNAME for the restored container\\n\\\n  -p, --newpath=NEWPATH     NEWPATH for the container to be stored\\n\\\n  -R, --rename              rename container\\n\\\n  -s, --snapshot            create snapshot instead of clone\\n\\\n  -F, --foreground          start with current tty attached to /dev/console\\n\\\n  -d, --daemon              daemonize the container (default)\\n\\\n  -e, --ephemeral           start ephemeral container\\n\\\n  -m, --mount               directory to mount into container, either \\n\\\n                            {bind,aufs,overlay}=/src-path or {bind,aufs,overlay}=/src-path:/dst-path\\n\\\n  -B, --backingstorage=TYPE backingstorage type for the container\\n\\\n  -t, --tmpfs               place ephemeral container on a tmpfs\\n\\\n                            (WARNING: On reboot all changes made to the container will be lost.)\\n\\\n  -L, --fssize              size of the new block device for block device containers\\n\\\n  -D, --keedata             pass together with -e start a persistent snapshot \\n\\\n  -K, --keepname            keep the hostname of the original container\\n\\\n  --  hook options          arguments passed to the hook program\\n\\\n  -M, --keepmac             keep the MAC address of the original container\\n\\\n  --rcfile=FILE             Load configuration file FILE\\n\",\n\t.options = my_longopts,\n\t.parser = my_parser,\n\t.task = CLONE,\n\t.daemonize = 1,\n\t.quiet = false,\n\t.tmpfs = false,\n};",
            "static int do_clone(struct lxc_container *c, char *newname, char *newpath,\n\t\t    int flags, char *bdevtype, uint64_t fssize, enum task task,\n\t\t    char **args);",
            "static int do_clone_ephemeral(struct lxc_container *c,\n\t\t\t      struct lxc_arguments *arg, char **args,\n\t\t\t      int flags);",
            "static int do_clone_rename(struct lxc_container *c, char *newname);",
            "static int do_clone_task(struct lxc_container *c, enum task task, int flags,\n\t\t\t char **args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic struct lxc_arguments my_args = {\n\t.progname = \"lxc-copy\",\n\t.help = \"\\n\\\n--name=NAME [-P lxcpath] -N newname [-p newpath] [-B backingstorage] [-s] [-K] [-M] [-L size [unit]] -- hook options\\n\\\n--name=NAME [-P lxcpath] [-N newname] [-p newpath] [-B backingstorage] -e [-d] [-D] [-K] [-M] [-m {bind,aufs,overlay}=/src:/dest] -- hook options\\n\\\n--name=NAME [-P lxcpath] -N newname -R\\n\\\n\\n\\\nlxc-copy clone a container\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME           NAME of the container\\n\\\n  -N, --newname=NEWNAME     NEWNAME for the restored container\\n\\\n  -p, --newpath=NEWPATH     NEWPATH for the container to be stored\\n\\\n  -R, --rename              rename container\\n\\\n  -s, --snapshot            create snapshot instead of clone\\n\\\n  -F, --foreground          start with current tty attached to /dev/console\\n\\\n  -d, --daemon              daemonize the container (default)\\n\\\n  -e, --ephemeral           start ephemeral container\\n\\\n  -m, --mount               directory to mount into container, either \\n\\\n                            {bind,aufs,overlay}=/src-path or {bind,aufs,overlay}=/src-path:/dst-path\\n\\\n  -B, --backingstorage=TYPE backingstorage type for the container\\n\\\n  -t, --tmpfs               place ephemeral container on a tmpfs\\n\\\n                            (WARNING: On reboot all changes made to the container will be lost.)\\n\\\n  -L, --fssize              size of the new block device for block device containers\\n\\\n  -D, --keedata             pass together with -e start a persistent snapshot \\n\\\n  -K, --keepname            keep the hostname of the original container\\n\\\n  --  hook options          arguments passed to the hook program\\n\\\n  -M, --keepmac             keep the MAC address of the original container\\n\\\n  --rcfile=FILE             Load configuration file FILE\\n\",\n\t.options = my_longopts,\n\t.parser = my_parser,\n\t.task = CLONE,\n\t.daemonize = 1,\n\t.quiet = false,\n\t.tmpfs = false,\n};\nstatic int do_clone(struct lxc_container *c, char *newname, char *newpath,\n\t\t    int flags, char *bdevtype, uint64_t fssize, enum task task,\n\t\t    char **args);\nstatic int do_clone_ephemeral(struct lxc_container *c,\n\t\t\t      struct lxc_arguments *arg, char **args,\n\t\t\t      int flags);\nstatic int do_clone_rename(struct lxc_container *c, char *newname);\nstatic int do_clone_task(struct lxc_container *c, enum task task, int flags,\n\t\t\t char **args);\n\nstatic int do_clone_task(struct lxc_container *c, enum task task, int flags,\n\t\t\t char **args)\n{\n\tint ret = 0;\n\n\tswitch (task) {\n\tcase DESTROY:\n\t\tret = do_clone_ephemeral(c, &my_args, args, flags);\n\t\tbreak;\n\tcase RENAME:\n\t\tret = do_clone_rename(c, my_args.newname);\n\t\tbreak;\n\tdefault:\n\t\tret = do_clone(c, my_args.newname, my_args.newpath, flags,\n\t\t\t       my_args.bdevtype, my_args.fssize, my_args.task,\n\t\t\t       args);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__clone2",
          "args": [
            "container_reboot_supported",
            "stack",
            "stack_size",
            "flags",
            "&cmd"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_empty",
          "args": [
            "&conf->id_map"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "94-97",
          "snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Failed to read /proc/sys/kernel/ctrl-alt-del.\""
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "f",
            "\"%d\"",
            "&v"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"failed to open /proc/sys/kernel/ctrl-alt-del\""
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "\"/proc/sys/kernel/ctrl-alt-del\"",
            "\"r\""
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "stack_size"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic bool do_destroy_container(struct lxc_conf *conf);\n\nstatic int must_drop_cap_sys_boot(struct lxc_conf *conf)\n{\n\tFILE *f;\n\tint ret, cmd, v, flags;\n\tlong stack_size = 4096;\n\tvoid *stack = alloca(stack_size);\n\tint status;\n\tpid_t pid;\n\n\tf = fopen(\"/proc/sys/kernel/ctrl-alt-del\", \"r\");\n\tif (!f) {\n\t\tDEBUG(\"failed to open /proc/sys/kernel/ctrl-alt-del\");\n\t\treturn 1;\n\t}\n\n\tret = fscanf(f, \"%d\", &v);\n\tfclose(f);\n\tif (ret != 1) {\n\t\tDEBUG(\"Failed to read /proc/sys/kernel/ctrl-alt-del.\");\n\t\treturn 1;\n\t}\n\tcmd = v ? LINUX_REBOOT_CMD_CAD_ON : LINUX_REBOOT_CMD_CAD_OFF;\n\n\tflags = CLONE_NEWPID | SIGCHLD;\n\tif (!lxc_list_empty(&conf->id_map))\n\t\tflags |= CLONE_NEWUSER;\n\n#ifdef __ia64__\n\tpid = __clone2(container_reboot_supported, stack, stack_size, flags,  &cmd);\n#else\n\tstack += stack_size;\n\tpid = clone(container_reboot_supported, stack, flags, &cmd);\n#endif\n\tif (pid < 0) {\n\t\tif (flags & CLONE_NEWUSER)\n\t\t\tERROR(\"Failed to clone (%#x): %s (includes CLONE_NEWUSER).\", flags, strerror(errno));\n\t\telse\n\t\t\tERROR(\"Failed to clone (%#x): %s.\", flags, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (wait(&status) < 0) {\n\t\tSYSERROR(\"Unexpected wait error: %m.\");\n\t\treturn -1;\n\t}\n\n\tif (WEXITSTATUS(status) != 1)\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "container_reboot_supported",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
    "lines": "609-618",
    "snippet": "static int container_reboot_supported(void *arg)\n{\n\tint *cmd = arg;\n\tint ret;\n\n\tret = reboot(*cmd);\n\tif (ret == -1 && errno == EINVAL)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <sys/reboot.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"sync.h\"",
      "#include \"start.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"lxcutmp.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"console.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/capability.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <alloca.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reboot",
          "args": [
            "*cmd"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "container_reboot_supported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "609-618",
          "snippet": "static int container_reboot_supported(void *arg)\n{\n\tint *cmd = arg;\n\tint ret;\n\n\tret = reboot(*cmd);\n\tif (ret == -1 && errno == EINVAL)\n\t\treturn 1;\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic int container_reboot_supported(void *arg)\n{\n\tint *cmd = arg;\n\tint ret;\n\n\tret = reboot(*cmd);\n\tif (ret == -1 && errno == EINVAL)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_abort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
    "lines": "590-600",
    "snippet": "void lxc_abort(const char *name, struct lxc_handler *handler)\n{\n\tint ret, status;\n\n\tlxc_set_state(name, handler, ABORTING);\n\tif (handler->pid > 0)\n\t\tkill(handler->pid, SIGKILL);\n\twhile ((ret = waitpid(-1, &status, 0)) > 0) {\n\t\t;\n\t}\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <sys/reboot.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"sync.h\"",
      "#include \"start.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"lxcutmp.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"console.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/capability.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <alloca.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "-1",
            "&status",
            "0"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "handler->pid",
            "SIGKILL"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_set_state",
          "args": [
            "name",
            "handler",
            "ABORTING"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_set_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "344-349",
          "snippet": "int lxc_set_state(const char *name, struct lxc_handler *handler, lxc_state_t state)\n{\n\thandler->state = state;\n\tlxc_monitor_send_state(name, state, handler->lxcpath);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);\n\nint lxc_set_state(const char *name, struct lxc_handler *handler, lxc_state_t state)\n{\n\thandler->state = state;\n\tlxc_monitor_send_state(name, state, handler->lxcpath);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);\n\nvoid lxc_abort(const char *name, struct lxc_handler *handler)\n{\n\tint ret, status;\n\n\tlxc_set_state(name, handler, ABORTING);\n\tif (handler->pid > 0)\n\t\tkill(handler->pid, SIGKILL);\n\twhile ((ret = waitpid(-1, &status, 0)) > 0) {\n\t\t;\n\t}\n}"
  },
  {
    "function_name": "lxc_fini",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
    "lines": "509-588",
    "snippet": "void lxc_fini(const char *name, struct lxc_handler *handler)\n{\n\tint i, rc;\n\tpid_t self = getpid();\n\tchar *namespaces[LXC_NS_MAX+1];\n\tsize_t namespace_count = 0;\n\n\t/* The STOPPING state is there for future cleanup code which can take\n\t * awhile.\n\t */\n\tlxc_set_state(name, handler, STOPPING);\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (handler->nsfd[i] != -1) {\n\t\t\trc = asprintf(&namespaces[namespace_count], \"%s:/proc/%d/fd/%d\",\n\t\t\t              ns_info[i].proc_name, self, handler->nsfd[i]);\n\t\t\tif (rc == -1) {\n\t\t\t\tSYSERROR(\"Failed to allocate memory.\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++namespace_count;\n\t\t}\n\t}\n\tnamespaces[namespace_count] = NULL;\n\n\tif (handler->conf->reboot && setenv(\"LXC_TARGET\", \"reboot\", 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_TARGET=reboot.\");\n\n\tif (!handler->conf->reboot && setenv(\"LXC_TARGET\", \"stop\", 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_TARGET=stop.\");\n\n\tif (run_lxc_hooks(name, \"stop\", handler->conf, handler->lxcpath, namespaces))\n\t\tERROR(\"Failed to run lxc.hook.stop for container \\\"%s\\\".\", name);\n\n\twhile (namespace_count--)\n\t\tfree(namespaces[namespace_count]);\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (handler->nsfd[i] != -1) {\n\t\t\tclose(handler->nsfd[i]);\n\t\t\thandler->nsfd[i] = -1;\n\t\t}\n\t}\n\n\tif (handler->netnsfd >= 0) {\n\t\tclose(handler->netnsfd);\n\t\thandler->netnsfd = -1;\n\t}\n\n\tlxc_set_state(name, handler, STOPPED);\n\n\tif (run_lxc_hooks(name, \"post-stop\", handler->conf, handler->lxcpath, NULL)) {\n\t\tERROR(\"Failed to run lxc.hook.post-stop for container \\\"%s\\\".\", name);\n\t\tif (handler->conf->reboot) {\n\t\t\tWARN(\"Container will be stopped instead of rebooted.\");\n\t\t\thandler->conf->reboot = 0;\n\t\t\tif (setenv(\"LXC_TARGET\", \"stop\", 1))\n\t\t\t\tWARN(\"Failed to set environment variable: LXC_TARGET=stop.\");\n\t\t}\n\t}\n\n\t/* Reset mask set by setup_signal_fd. */\n\tif (sigprocmask(SIG_SETMASK, &handler->oldmask, NULL))\n\t\tWARN(\"Failed to restore signal mask.\");\n\n\tlxc_console_delete(&handler->conf->console);\n\tlxc_delete_tty(&handler->conf->tty_info);\n\tclose(handler->conf->maincmd_fd);\n\thandler->conf->maincmd_fd = -1;\n\tfree(handler->name);\n\tif (handler->ttysock[0] != -1) {\n\t\tclose(handler->ttysock[0]);\n\t\tclose(handler->ttysock[1]);\n\t}\n\n\tif (handler->conf->ephemeral == 1 && handler->conf->reboot != 1)\n\t\tlxc_destroy_container_on_signal(handler, name);\n\n\tcgroup_destroy(handler);\n\tfree(handler);\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <sys/reboot.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"sync.h\"",
      "#include \"start.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"lxcutmp.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"console.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/capability.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <alloca.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_destroy_container(struct lxc_conf *conf);",
      "static void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "handler"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_destroy",
          "args": [
            "handler"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgroup.c",
          "lines": "74-80",
          "snippet": "void cgroup_destroy(struct lxc_handler *handler)\n{\n\tif (ops) {\n\t\tops->destroy(handler->cgroup_data, handler->conf);\n\t\thandler->cgroup_data = NULL;\n\t}\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"log.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_ops *ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"log.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <unistd.h>\n\nstatic struct cgroup_ops *ops = NULL;\n\nvoid cgroup_destroy(struct lxc_handler *handler)\n{\n\tif (ops) {\n\t\tops->destroy(handler->cgroup_data, handler->conf);\n\t\thandler->cgroup_data = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_destroy_container_on_signal",
          "args": [
            "handler",
            "name"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_destroy_container_on_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "1488-1532",
          "snippet": "static void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name)\n{\n\tchar destroy[MAXPATHLEN];\n\tbool bret = true;\n\tint ret = 0;\n\tstruct lxc_container *c;\n\tif (handler->conf->rootfs.path && handler->conf->rootfs.mount) {\n\t\tbret = do_destroy_container(handler->conf);\n\t\tif (!bret) {\n\t\t\tERROR(\"Error destroying rootfs for container \\\"%s\\\".\", name);\n\t\t\treturn;\n\t\t}\n\t}\n\tINFO(\"Destroyed rootfs for container \\\"%s\\\".\", name);\n\n\tret = snprintf(destroy, MAXPATHLEN, \"%s/%s\", handler->lxcpath, name);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tERROR(\"Error destroying directory for container \\\"%s\\\".\", name);\n\t\treturn;\n\t}\n\n\tc = lxc_container_new(name, handler->lxcpath);\n\tif (c) {\n\t\tif (container_disk_lock(c)) {\n\t\t\tINFO(\"Could not update lxc_snapshots file.\");\n\t\t\tlxc_container_put(c);\n\t\t} else {\n\t\t\tmod_all_rdeps(c, false);\n\t\t\tcontainer_disk_unlock(c);\n\t\t\tlxc_container_put(c);\n\t\t}\n\t}\n\n\tif (am_unpriv())\n\t\tret = userns_exec_1(handler->conf, lxc_rmdir_onedev_wrapper, destroy);\n\telse\n\t\tret = lxc_rmdir_onedev(destroy, NULL);\n\n\tif (ret < 0) {\n\t\tERROR(\"Error destroying directory for container \\\"%s\\\".\", name);\n\t\treturn;\n\t}\n\tINFO(\"Destroyed directory for container \\\"%s\\\".\", name);\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_destroy_container(struct lxc_conf *conf);",
            "static void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic bool do_destroy_container(struct lxc_conf *conf);\nstatic void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);\n\nstatic void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name)\n{\n\tchar destroy[MAXPATHLEN];\n\tbool bret = true;\n\tint ret = 0;\n\tstruct lxc_container *c;\n\tif (handler->conf->rootfs.path && handler->conf->rootfs.mount) {\n\t\tbret = do_destroy_container(handler->conf);\n\t\tif (!bret) {\n\t\t\tERROR(\"Error destroying rootfs for container \\\"%s\\\".\", name);\n\t\t\treturn;\n\t\t}\n\t}\n\tINFO(\"Destroyed rootfs for container \\\"%s\\\".\", name);\n\n\tret = snprintf(destroy, MAXPATHLEN, \"%s/%s\", handler->lxcpath, name);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tERROR(\"Error destroying directory for container \\\"%s\\\".\", name);\n\t\treturn;\n\t}\n\n\tc = lxc_container_new(name, handler->lxcpath);\n\tif (c) {\n\t\tif (container_disk_lock(c)) {\n\t\t\tINFO(\"Could not update lxc_snapshots file.\");\n\t\t\tlxc_container_put(c);\n\t\t} else {\n\t\t\tmod_all_rdeps(c, false);\n\t\t\tcontainer_disk_unlock(c);\n\t\t\tlxc_container_put(c);\n\t\t}\n\t}\n\n\tif (am_unpriv())\n\t\tret = userns_exec_1(handler->conf, lxc_rmdir_onedev_wrapper, destroy);\n\telse\n\t\tret = lxc_rmdir_onedev(destroy, NULL);\n\n\tif (ret < 0) {\n\t\tERROR(\"Error destroying directory for container \\\"%s\\\".\", name);\n\t\treturn;\n\t}\n\tINFO(\"Destroyed directory for container \\\"%s\\\".\", name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "handler->ttysock[1]"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "close_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "118-128",
          "snippet": "static void close_ns(int ns_fd[LXC_NS_MAX])\n{\n\tint i;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (ns_fd[i] > -1) {\n\t\t\tclose(ns_fd[i]);\n\t\t\tns_fd[i] = -1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic void close_ns(int ns_fd[LXC_NS_MAX])\n{\n\tint i;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (ns_fd[i] > -1) {\n\t\t\tclose(ns_fd[i]);\n\t\t\tns_fd[i] = -1;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_delete_tty",
          "args": [
            "&handler->conf->tty_info"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_delete_tty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3458-3472",
          "snippet": "void lxc_delete_tty(struct lxc_tty_info *tty_info)\n{\n\tint i;\n\n\tfor (i = 0; i < tty_info->nbtty; i++) {\n\t\tstruct lxc_pty_info *pty_info = &tty_info->pty_info[i];\n\n\t\tclose(pty_info->master);\n\t\tclose(pty_info->slave);\n\t}\n\n\tfree(tty_info->pty_info);\n\ttty_info->pty_info = NULL;\n\ttty_info->nbtty = 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid lxc_delete_tty(struct lxc_tty_info *tty_info)\n{\n\tint i;\n\n\tfor (i = 0; i < tty_info->nbtty; i++) {\n\t\tstruct lxc_pty_info *pty_info = &tty_info->pty_info[i];\n\n\t\tclose(pty_info->master);\n\t\tclose(pty_info->slave);\n\t}\n\n\tfree(tty_info->pty_info);\n\ttty_info->pty_info = NULL;\n\ttty_info->nbtty = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_console_delete",
          "args": [
            "&handler->conf->console"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_console_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
          "lines": "480-498",
          "snippet": "void lxc_console_delete(struct lxc_console *console)\n{\n\tif (console->tios && console->peer >= 0 &&\n\t    tcsetattr(console->peer, TCSAFLUSH, console->tios))\n\t\tWARN(\"failed to set old terminal settings\");\n\tfree(console->tios);\n\tconsole->tios = NULL;\n\n\tclose(console->peer);\n\tclose(console->master);\n\tclose(console->slave);\n\tif (console->log_fd >= 0)\n\t\tclose(console->log_fd);\n\n\tconsole->peer = -1;\n\tconsole->master = -1;\n\tconsole->slave = -1;\n\tconsole->log_fd = -1;\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"start.h\" \t/* for struct lxc_handler */",
            "#include \"mainloop.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"caps.h\"",
            "#include \"af_unix.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nvoid lxc_console_delete(struct lxc_console *console)\n{\n\tif (console->tios && console->peer >= 0 &&\n\t    tcsetattr(console->peer, TCSAFLUSH, console->tios))\n\t\tWARN(\"failed to set old terminal settings\");\n\tfree(console->tios);\n\tconsole->tios = NULL;\n\n\tclose(console->peer);\n\tclose(console->master);\n\tclose(console->slave);\n\tif (console->log_fd >= 0)\n\t\tclose(console->log_fd);\n\n\tconsole->peer = -1;\n\tconsole->master = -1;\n\tconsole->slave = -1;\n\tconsole->log_fd = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to restore signal mask.\""
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_SETMASK",
            "&handler->oldmask",
            "NULL"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to set environment variable: LXC_TARGET=stop.\""
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"LXC_TARGET\"",
            "\"stop\"",
            "1"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Container will be stopped instead of rebooted.\""
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to run lxc.hook.post-stop for container \\\"%s\\\".\"",
            "name"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run_lxc_hooks",
          "args": [
            "name",
            "\"post-stop\"",
            "handler->conf",
            "handler->lxcpath",
            "NULL"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "run_lxc_hooks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3995-4029",
          "snippet": "int run_lxc_hooks(const char *name, char *hook, struct lxc_conf *conf,\n\t\t  const char *lxcpath, char *argv[])\n{\n\tint which = -1;\n\tstruct lxc_list *it;\n\n\tif (strcmp(hook, \"pre-start\") == 0)\n\t\twhich = LXCHOOK_PRESTART;\n\telse if (strcmp(hook, \"pre-mount\") == 0)\n\t\twhich = LXCHOOK_PREMOUNT;\n\telse if (strcmp(hook, \"mount\") == 0)\n\t\twhich = LXCHOOK_MOUNT;\n\telse if (strcmp(hook, \"autodev\") == 0)\n\t\twhich = LXCHOOK_AUTODEV;\n\telse if (strcmp(hook, \"start\") == 0)\n\t\twhich = LXCHOOK_START;\n\telse if (strcmp(hook, \"stop\") == 0)\n\t\twhich = LXCHOOK_STOP;\n\telse if (strcmp(hook, \"post-stop\") == 0)\n\t\twhich = LXCHOOK_POSTSTOP;\n\telse if (strcmp(hook, \"clone\") == 0)\n\t\twhich = LXCHOOK_CLONE;\n\telse if (strcmp(hook, \"destroy\") == 0)\n\t\twhich = LXCHOOK_DESTROY;\n\telse\n\t\treturn -1;\n\tlxc_list_for_each(it, &conf->hooks[which]) {\n\t\tint ret;\n\t\tchar *hookname = it->elem;\n\t\tret = run_script_argv(name, \"lxc\", hookname, hook, lxcpath, argv);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint run_lxc_hooks(const char *name, char *hook, struct lxc_conf *conf,\n\t\t  const char *lxcpath, char *argv[])\n{\n\tint which = -1;\n\tstruct lxc_list *it;\n\n\tif (strcmp(hook, \"pre-start\") == 0)\n\t\twhich = LXCHOOK_PRESTART;\n\telse if (strcmp(hook, \"pre-mount\") == 0)\n\t\twhich = LXCHOOK_PREMOUNT;\n\telse if (strcmp(hook, \"mount\") == 0)\n\t\twhich = LXCHOOK_MOUNT;\n\telse if (strcmp(hook, \"autodev\") == 0)\n\t\twhich = LXCHOOK_AUTODEV;\n\telse if (strcmp(hook, \"start\") == 0)\n\t\twhich = LXCHOOK_START;\n\telse if (strcmp(hook, \"stop\") == 0)\n\t\twhich = LXCHOOK_STOP;\n\telse if (strcmp(hook, \"post-stop\") == 0)\n\t\twhich = LXCHOOK_POSTSTOP;\n\telse if (strcmp(hook, \"clone\") == 0)\n\t\twhich = LXCHOOK_CLONE;\n\telse if (strcmp(hook, \"destroy\") == 0)\n\t\twhich = LXCHOOK_DESTROY;\n\telse\n\t\treturn -1;\n\tlxc_list_for_each(it, &conf->hooks[which]) {\n\t\tint ret;\n\t\tchar *hookname = it->elem;\n\t\tret = run_script_argv(name, \"lxc\", hookname, hook, lxcpath, argv);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_set_state",
          "args": [
            "name",
            "handler",
            "STOPPED"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_set_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "344-349",
          "snippet": "int lxc_set_state(const char *name, struct lxc_handler *handler, lxc_state_t state)\n{\n\thandler->state = state;\n\tlxc_monitor_send_state(name, state, handler->lxcpath);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);\n\nint lxc_set_state(const char *name, struct lxc_handler *handler, lxc_state_t state)\n{\n\thandler->state = state;\n\tlxc_monitor_send_state(name, state, handler->lxcpath);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to run lxc.hook.stop for container \\\"%s\\\".\"",
            "name"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to set environment variable: LXC_TARGET=stop.\""
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"LXC_TARGET\"",
            "\"stop\"",
            "1"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to set environment variable: LXC_TARGET=reboot.\""
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"LXC_TARGET\"",
            "\"reboot\"",
            "1"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to allocate memory.\""
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&namespaces[namespace_count]",
            "\"%s:/proc/%d/fd/%d\"",
            "ns_info[i].proc_name",
            "self",
            "handler->nsfd[i]"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic bool do_destroy_container(struct lxc_conf *conf);\nstatic void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);\n\nvoid lxc_fini(const char *name, struct lxc_handler *handler)\n{\n\tint i, rc;\n\tpid_t self = getpid();\n\tchar *namespaces[LXC_NS_MAX+1];\n\tsize_t namespace_count = 0;\n\n\t/* The STOPPING state is there for future cleanup code which can take\n\t * awhile.\n\t */\n\tlxc_set_state(name, handler, STOPPING);\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (handler->nsfd[i] != -1) {\n\t\t\trc = asprintf(&namespaces[namespace_count], \"%s:/proc/%d/fd/%d\",\n\t\t\t              ns_info[i].proc_name, self, handler->nsfd[i]);\n\t\t\tif (rc == -1) {\n\t\t\t\tSYSERROR(\"Failed to allocate memory.\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++namespace_count;\n\t\t}\n\t}\n\tnamespaces[namespace_count] = NULL;\n\n\tif (handler->conf->reboot && setenv(\"LXC_TARGET\", \"reboot\", 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_TARGET=reboot.\");\n\n\tif (!handler->conf->reboot && setenv(\"LXC_TARGET\", \"stop\", 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_TARGET=stop.\");\n\n\tif (run_lxc_hooks(name, \"stop\", handler->conf, handler->lxcpath, namespaces))\n\t\tERROR(\"Failed to run lxc.hook.stop for container \\\"%s\\\".\", name);\n\n\twhile (namespace_count--)\n\t\tfree(namespaces[namespace_count]);\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (handler->nsfd[i] != -1) {\n\t\t\tclose(handler->nsfd[i]);\n\t\t\thandler->nsfd[i] = -1;\n\t\t}\n\t}\n\n\tif (handler->netnsfd >= 0) {\n\t\tclose(handler->netnsfd);\n\t\thandler->netnsfd = -1;\n\t}\n\n\tlxc_set_state(name, handler, STOPPED);\n\n\tif (run_lxc_hooks(name, \"post-stop\", handler->conf, handler->lxcpath, NULL)) {\n\t\tERROR(\"Failed to run lxc.hook.post-stop for container \\\"%s\\\".\", name);\n\t\tif (handler->conf->reboot) {\n\t\t\tWARN(\"Container will be stopped instead of rebooted.\");\n\t\t\thandler->conf->reboot = 0;\n\t\t\tif (setenv(\"LXC_TARGET\", \"stop\", 1))\n\t\t\t\tWARN(\"Failed to set environment variable: LXC_TARGET=stop.\");\n\t\t}\n\t}\n\n\t/* Reset mask set by setup_signal_fd. */\n\tif (sigprocmask(SIG_SETMASK, &handler->oldmask, NULL))\n\t\tWARN(\"Failed to restore signal mask.\");\n\n\tlxc_console_delete(&handler->conf->console);\n\tlxc_delete_tty(&handler->conf->tty_info);\n\tclose(handler->conf->maincmd_fd);\n\thandler->conf->maincmd_fd = -1;\n\tfree(handler->name);\n\tif (handler->ttysock[0] != -1) {\n\t\tclose(handler->ttysock[0]);\n\t\tclose(handler->ttysock[1]);\n\t}\n\n\tif (handler->conf->ephemeral == 1 && handler->conf->reboot != 1)\n\t\tlxc_destroy_container_on_signal(handler, name);\n\n\tcgroup_destroy(handler);\n\tfree(handler);\n}"
  },
  {
    "function_name": "lxc_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
    "lines": "399-507",
    "snippet": "struct lxc_handler *lxc_init(const char *name, struct lxc_conf *conf, const char *lxcpath)\n{\n\tint i;\n\tstruct lxc_handler *handler;\n\n\thandler = malloc(sizeof(*handler));\n\tif (!handler)\n\t\treturn NULL;\n\n\tmemset(handler, 0, sizeof(*handler));\n\n\thandler->ttysock[0] = handler->ttysock[1] = -1;\n\thandler->conf = conf;\n\thandler->lxcpath = lxcpath;\n\thandler->pinfd = -1;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++)\n\t\thandler->nsfd[i] = -1;\n\n\tlsm_init();\n\n\thandler->name = strdup(name);\n\tif (!handler->name) {\n\t\tERROR(\"Failed to allocate memory.\");\n\t\tgoto out_free;\n\t}\n\n\tif (lxc_cmd_init(name, handler, lxcpath))\n\t\tgoto out_free_name;\n\n\tif (lxc_read_seccomp_config(conf) != 0) {\n\t\tERROR(\"Failed loading seccomp policy.\");\n\t\tgoto out_close_maincmd_fd;\n\t}\n\n\t/* Begin by setting the state to STARTING. */\n\tif (lxc_set_state(name, handler, STARTING)) {\n\t\tERROR(\"Failed to set state for container \\\"%s\\\" to \\\"%s\\\".\", name, lxc_state2str(STARTING));\n\t\tgoto out_close_maincmd_fd;\n\t}\n\n\t/* Start of environment variable setup for hooks. */\n\tif (name && setenv(\"LXC_NAME\", name, 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_NAME=%s.\", name);\n\n\tif (conf->rcfile && setenv(\"LXC_CONFIG_FILE\", conf->rcfile, 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_CONFIG_FILE=%s.\", conf->rcfile);\n\n\tif (conf->rootfs.mount && setenv(\"LXC_ROOTFS_MOUNT\", conf->rootfs.mount, 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_ROOTFS_MOUNT=%s.\", conf->rootfs.mount);\n\n\tif (conf->rootfs.path && setenv(\"LXC_ROOTFS_PATH\", conf->rootfs.path, 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_ROOTFS_PATH=%s.\", conf->rootfs.path);\n\n\tif (conf->console.path && setenv(\"LXC_CONSOLE\", conf->console.path, 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_CONSOLE=%s.\", conf->console.path);\n\n\tif (conf->console.log_path && setenv(\"LXC_CONSOLE_LOGPATH\", conf->console.log_path, 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_CONSOLE_LOGPATH=%s.\", conf->console.log_path);\n\n\tif (setenv(\"LXC_CGNS_AWARE\", \"1\", 1))\n\t\tSYSERROR(\"Failed to set environment variable LXC_CGNS_AWARE=1.\");\n\t/* End of environment variable setup for hooks. */\n\n\tif (run_lxc_hooks(name, \"pre-start\", conf, handler->lxcpath, NULL)) {\n\t\tERROR(\"Failed to run lxc.hook.pre-start for container \\\"%s\\\".\", name);\n\t\tgoto out_aborting;\n\t}\n\n\t/* The signal fd has to be created before forking otherwise if the child\n\t * process exits before we setup the signal fd, the event will be lost\n\t * and the command will be stuck.\n\t */\n\thandler->sigfd = setup_signal_fd(&handler->oldmask);\n\tif (handler->sigfd < 0) {\n\t\tERROR(\"Failed to setup SIGCHLD fd handler.\");\n\t\tgoto out_delete_tty;\n\t}\n\n\t/* Do this after setting up signals since it might unblock SIGWINCH. */\n\tif (lxc_console_create(conf)) {\n\t\tERROR(\"Failed to create console for container \\\"%s\\\".\", name);\n\t\tgoto out_restore_sigmask;\n\t}\n\n\tif (ttys_shift_ids(conf) < 0) {\n\t\tERROR(\"Failed to shift tty into container.\");\n\t\tgoto out_restore_sigmask;\n\t}\n\n\tINFO(\"Container \\\"%s\\\" is initialized.\", name);\n\treturn handler;\n\nout_restore_sigmask:\n\tsigprocmask(SIG_SETMASK, &handler->oldmask, NULL);\nout_delete_tty:\n\tlxc_delete_tty(&conf->tty_info);\nout_aborting:\n\tlxc_set_state(name, handler, ABORTING);\nout_close_maincmd_fd:\n\tclose(conf->maincmd_fd);\n\tconf->maincmd_fd = -1;\nout_free_name:\n\tfree(handler->name);\n\thandler->name = NULL;\nout_free:\n\tfree(handler);\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <sys/reboot.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"sync.h\"",
      "#include \"start.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"lxcutmp.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"console.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/capability.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <alloca.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_destroy_container(struct lxc_conf *conf);",
      "static void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "handler"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "conf->maincmd_fd"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "close_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "118-128",
          "snippet": "static void close_ns(int ns_fd[LXC_NS_MAX])\n{\n\tint i;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (ns_fd[i] > -1) {\n\t\t\tclose(ns_fd[i]);\n\t\t\tns_fd[i] = -1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic void close_ns(int ns_fd[LXC_NS_MAX])\n{\n\tint i;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (ns_fd[i] > -1) {\n\t\t\tclose(ns_fd[i]);\n\t\t\tns_fd[i] = -1;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_set_state",
          "args": [
            "name",
            "handler",
            "ABORTING"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_set_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "344-349",
          "snippet": "int lxc_set_state(const char *name, struct lxc_handler *handler, lxc_state_t state)\n{\n\thandler->state = state;\n\tlxc_monitor_send_state(name, state, handler->lxcpath);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);\n\nint lxc_set_state(const char *name, struct lxc_handler *handler, lxc_state_t state)\n{\n\thandler->state = state;\n\tlxc_monitor_send_state(name, state, handler->lxcpath);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_delete_tty",
          "args": [
            "&conf->tty_info"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_delete_tty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3458-3472",
          "snippet": "void lxc_delete_tty(struct lxc_tty_info *tty_info)\n{\n\tint i;\n\n\tfor (i = 0; i < tty_info->nbtty; i++) {\n\t\tstruct lxc_pty_info *pty_info = &tty_info->pty_info[i];\n\n\t\tclose(pty_info->master);\n\t\tclose(pty_info->slave);\n\t}\n\n\tfree(tty_info->pty_info);\n\ttty_info->pty_info = NULL;\n\ttty_info->nbtty = 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid lxc_delete_tty(struct lxc_tty_info *tty_info)\n{\n\tint i;\n\n\tfor (i = 0; i < tty_info->nbtty; i++) {\n\t\tstruct lxc_pty_info *pty_info = &tty_info->pty_info[i];\n\n\t\tclose(pty_info->master);\n\t\tclose(pty_info->slave);\n\t}\n\n\tfree(tty_info->pty_info);\n\ttty_info->pty_info = NULL;\n\ttty_info->nbtty = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_SETMASK",
            "&handler->oldmask",
            "NULL"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Container \\\"%s\\\" is initialized.\"",
            "name"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to shift tty into container.\""
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttys_shift_ids",
          "args": [
            "conf"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "ttys_shift_ids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3620-3631",
          "snippet": "int ttys_shift_ids(struct lxc_conf *c)\n{\n\tif (lxc_list_empty(&c->id_map))\n\t\treturn 0;\n\n\tif (strcmp(c->console.name, \"\") !=0 && chown_mapped_root(c->console.name, c) < 0) {\n\t\tERROR(\"Failed to chown %s\", c->console.name);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint ttys_shift_ids(struct lxc_conf *c)\n{\n\tif (lxc_list_empty(&c->id_map))\n\t\treturn 0;\n\n\tif (strcmp(c->console.name, \"\") !=0 && chown_mapped_root(c->console.name, c) < 0) {\n\t\tERROR(\"Failed to chown %s\", c->console.name);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to create console for container \\\"%s\\\".\"",
            "name"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_console_create",
          "args": [
            "conf"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_console_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
          "lines": "500-553",
          "snippet": "int lxc_console_create(struct lxc_conf *conf)\n{\n\tstruct lxc_console *console = &conf->console;\n\tint ret;\n\n\tif (conf->is_execute) {\n\t\tINFO(\"no console for lxc-execute.\");\n\t\treturn 0;\n\t}\n\n\tif (!conf->rootfs.path)\n\t\treturn 0;\n\n\tif (console->path && !strcmp(console->path, \"none\"))\n\t\treturn 0;\n\n\tprocess_lock();\n\tret = openpty(&console->master, &console->slave,\n\t\t    console->name, NULL, NULL);\n\tprocess_unlock();\n\tif (ret) {\n\t\tSYSERROR(\"failed to allocate a pty\");\n\t\treturn -1;\n\t}\n\n\tif (fcntl(console->master, F_SETFD, FD_CLOEXEC)) {\n\t\tSYSERROR(\"failed to set console master to close-on-exec\");\n\t\tgoto err;\n\t}\n\n\tif (fcntl(console->slave, F_SETFD, FD_CLOEXEC)) {\n\t\tSYSERROR(\"failed to set console slave to close-on-exec\");\n\t\tgoto err;\n\t}\n\n\tlxc_console_peer_default(console);\n\n\tif (console->log_path) {\n\t\tconsole->log_fd = lxc_unpriv(open(console->log_path,\n\t\t\t\t\t\t  O_CLOEXEC | O_RDWR |\n\t\t\t\t\t\t  O_CREAT | O_APPEND, 0600));\n\t\tif (console->log_fd < 0) {\n\t\t\tSYSERROR(\"failed to open '%s'\", console->log_path);\n\t\t\tgoto err;\n\t\t}\n\t\tDEBUG(\"using '%s' as console log\", console->log_path);\n\t}\n\n\treturn 0;\n\nerr:\n\tlxc_console_delete(console);\n\treturn -1;\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"start.h\" \t/* for struct lxc_handler */",
            "#include \"mainloop.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"caps.h\"",
            "#include \"af_unix.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_console_create(struct lxc_conf *conf)\n{\n\tstruct lxc_console *console = &conf->console;\n\tint ret;\n\n\tif (conf->is_execute) {\n\t\tINFO(\"no console for lxc-execute.\");\n\t\treturn 0;\n\t}\n\n\tif (!conf->rootfs.path)\n\t\treturn 0;\n\n\tif (console->path && !strcmp(console->path, \"none\"))\n\t\treturn 0;\n\n\tprocess_lock();\n\tret = openpty(&console->master, &console->slave,\n\t\t    console->name, NULL, NULL);\n\tprocess_unlock();\n\tif (ret) {\n\t\tSYSERROR(\"failed to allocate a pty\");\n\t\treturn -1;\n\t}\n\n\tif (fcntl(console->master, F_SETFD, FD_CLOEXEC)) {\n\t\tSYSERROR(\"failed to set console master to close-on-exec\");\n\t\tgoto err;\n\t}\n\n\tif (fcntl(console->slave, F_SETFD, FD_CLOEXEC)) {\n\t\tSYSERROR(\"failed to set console slave to close-on-exec\");\n\t\tgoto err;\n\t}\n\n\tlxc_console_peer_default(console);\n\n\tif (console->log_path) {\n\t\tconsole->log_fd = lxc_unpriv(open(console->log_path,\n\t\t\t\t\t\t  O_CLOEXEC | O_RDWR |\n\t\t\t\t\t\t  O_CREAT | O_APPEND, 0600));\n\t\tif (console->log_fd < 0) {\n\t\t\tSYSERROR(\"failed to open '%s'\", console->log_path);\n\t\t\tgoto err;\n\t\t}\n\t\tDEBUG(\"using '%s' as console log\", console->log_path);\n\t}\n\n\treturn 0;\n\nerr:\n\tlxc_console_delete(console);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to setup SIGCHLD fd handler.\""
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_signal_fd",
          "args": [
            "&handler->oldmask"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "setup_signal_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "259-290",
          "snippet": "static int setup_signal_fd(sigset_t *oldmask)\n{\n\tsigset_t mask;\n\tint fd;\n\n\t/* Block everything except serious error signals. */\n\tif (sigfillset(&mask) ||\n\t    sigdelset(&mask, SIGILL) ||\n\t    sigdelset(&mask, SIGSEGV) ||\n\t    sigdelset(&mask, SIGBUS) ||\n\t    sigdelset(&mask, SIGWINCH) ||\n\t    sigprocmask(SIG_BLOCK, &mask, oldmask)) {\n\t\tSYSERROR(\"Failed to set signal mask.\");\n\t\treturn -1;\n\t}\n\n\tfd = signalfd(-1, &mask, 0);\n\tif (fd < 0) {\n\t\tSYSERROR(\"Failed to create signal file descriptor.\");\n\t\treturn -1;\n\t}\n\n\tif (fcntl(fd, F_SETFD, FD_CLOEXEC)) {\n\t\tSYSERROR(\"Failed to set FD_CLOEXEC on the signal file descriptor: %d.\", fd);\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\tDEBUG(\"Set SIGCHLD handler with file descriptor: %d.\", fd);\n\n\treturn fd;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic int setup_signal_fd(sigset_t *oldmask)\n{\n\tsigset_t mask;\n\tint fd;\n\n\t/* Block everything except serious error signals. */\n\tif (sigfillset(&mask) ||\n\t    sigdelset(&mask, SIGILL) ||\n\t    sigdelset(&mask, SIGSEGV) ||\n\t    sigdelset(&mask, SIGBUS) ||\n\t    sigdelset(&mask, SIGWINCH) ||\n\t    sigprocmask(SIG_BLOCK, &mask, oldmask)) {\n\t\tSYSERROR(\"Failed to set signal mask.\");\n\t\treturn -1;\n\t}\n\n\tfd = signalfd(-1, &mask, 0);\n\tif (fd < 0) {\n\t\tSYSERROR(\"Failed to create signal file descriptor.\");\n\t\treturn -1;\n\t}\n\n\tif (fcntl(fd, F_SETFD, FD_CLOEXEC)) {\n\t\tSYSERROR(\"Failed to set FD_CLOEXEC on the signal file descriptor: %d.\", fd);\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\tDEBUG(\"Set SIGCHLD handler with file descriptor: %d.\", fd);\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to run lxc.hook.pre-start for container \\\"%s\\\".\"",
            "name"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run_lxc_hooks",
          "args": [
            "name",
            "\"pre-start\"",
            "conf",
            "handler->lxcpath",
            "NULL"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "run_lxc_hooks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3995-4029",
          "snippet": "int run_lxc_hooks(const char *name, char *hook, struct lxc_conf *conf,\n\t\t  const char *lxcpath, char *argv[])\n{\n\tint which = -1;\n\tstruct lxc_list *it;\n\n\tif (strcmp(hook, \"pre-start\") == 0)\n\t\twhich = LXCHOOK_PRESTART;\n\telse if (strcmp(hook, \"pre-mount\") == 0)\n\t\twhich = LXCHOOK_PREMOUNT;\n\telse if (strcmp(hook, \"mount\") == 0)\n\t\twhich = LXCHOOK_MOUNT;\n\telse if (strcmp(hook, \"autodev\") == 0)\n\t\twhich = LXCHOOK_AUTODEV;\n\telse if (strcmp(hook, \"start\") == 0)\n\t\twhich = LXCHOOK_START;\n\telse if (strcmp(hook, \"stop\") == 0)\n\t\twhich = LXCHOOK_STOP;\n\telse if (strcmp(hook, \"post-stop\") == 0)\n\t\twhich = LXCHOOK_POSTSTOP;\n\telse if (strcmp(hook, \"clone\") == 0)\n\t\twhich = LXCHOOK_CLONE;\n\telse if (strcmp(hook, \"destroy\") == 0)\n\t\twhich = LXCHOOK_DESTROY;\n\telse\n\t\treturn -1;\n\tlxc_list_for_each(it, &conf->hooks[which]) {\n\t\tint ret;\n\t\tchar *hookname = it->elem;\n\t\tret = run_script_argv(name, \"lxc\", hookname, hook, lxcpath, argv);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint run_lxc_hooks(const char *name, char *hook, struct lxc_conf *conf,\n\t\t  const char *lxcpath, char *argv[])\n{\n\tint which = -1;\n\tstruct lxc_list *it;\n\n\tif (strcmp(hook, \"pre-start\") == 0)\n\t\twhich = LXCHOOK_PRESTART;\n\telse if (strcmp(hook, \"pre-mount\") == 0)\n\t\twhich = LXCHOOK_PREMOUNT;\n\telse if (strcmp(hook, \"mount\") == 0)\n\t\twhich = LXCHOOK_MOUNT;\n\telse if (strcmp(hook, \"autodev\") == 0)\n\t\twhich = LXCHOOK_AUTODEV;\n\telse if (strcmp(hook, \"start\") == 0)\n\t\twhich = LXCHOOK_START;\n\telse if (strcmp(hook, \"stop\") == 0)\n\t\twhich = LXCHOOK_STOP;\n\telse if (strcmp(hook, \"post-stop\") == 0)\n\t\twhich = LXCHOOK_POSTSTOP;\n\telse if (strcmp(hook, \"clone\") == 0)\n\t\twhich = LXCHOOK_CLONE;\n\telse if (strcmp(hook, \"destroy\") == 0)\n\t\twhich = LXCHOOK_DESTROY;\n\telse\n\t\treturn -1;\n\tlxc_list_for_each(it, &conf->hooks[which]) {\n\t\tint ret;\n\t\tchar *hookname = it->elem;\n\t\tret = run_script_argv(name, \"lxc\", hookname, hook, lxcpath, argv);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to set environment variable LXC_CGNS_AWARE=1.\""
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"LXC_CGNS_AWARE\"",
            "\"1\"",
            "1"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to set environment variable: LXC_CONSOLE_LOGPATH=%s.\"",
            "conf->console.log_path"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"LXC_CONSOLE_LOGPATH\"",
            "conf->console.log_path",
            "1"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to set environment variable: LXC_CONSOLE=%s.\"",
            "conf->console.path"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"LXC_CONSOLE\"",
            "conf->console.path",
            "1"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to set environment variable: LXC_ROOTFS_PATH=%s.\"",
            "conf->rootfs.path"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"LXC_ROOTFS_PATH\"",
            "conf->rootfs.path",
            "1"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to set environment variable: LXC_ROOTFS_MOUNT=%s.\"",
            "conf->rootfs.mount"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"LXC_ROOTFS_MOUNT\"",
            "conf->rootfs.mount",
            "1"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to set environment variable: LXC_CONFIG_FILE=%s.\"",
            "conf->rcfile"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"LXC_CONFIG_FILE\"",
            "conf->rcfile",
            "1"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to set environment variable: LXC_NAME=%s.\"",
            "name"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"LXC_NAME\"",
            "name",
            "1"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to set state for container \\\"%s\\\" to \\\"%s\\\".\"",
            "name",
            "lxc_state2str(STARTING)"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_state2str",
          "args": [
            "STARTING"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_state2str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/state.c",
          "lines": "52-57",
          "snippet": "const char *lxc_state2str(lxc_state_t state)\n{\n\tif (state < STOPPED || state > MAX_STATE - 1)\n\t\treturn NULL;\n\treturn strstate[state];\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"monitor.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const strstate[] = {\n\t\"STOPPED\", \"STARTING\", \"RUNNING\", \"STOPPING\",\n\t\"ABORTING\", \"FREEZING\", \"FROZEN\", \"THAWED\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"monitor.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic const char * const strstate[] = {\n\t\"STOPPED\", \"STARTING\", \"RUNNING\", \"STOPPING\",\n\t\"ABORTING\", \"FREEZING\", \"FROZEN\", \"THAWED\",\n};\n\nconst char *lxc_state2str(lxc_state_t state)\n{\n\tif (state < STOPPED || state > MAX_STATE - 1)\n\t\treturn NULL;\n\treturn strstate[state];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed loading seccomp policy.\""
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_read_seccomp_config",
          "args": [
            "conf"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_seccomp_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "707-755",
          "snippet": "int lxc_read_seccomp_config(struct lxc_conf *conf)\n{\n\tFILE *f;\n\tint ret;\n\tint check_seccomp_attr_set;\n\n\tif (!conf->seccomp)\n\t\treturn 0;\n\n\tif (!use_seccomp())\n\t\treturn 0;\n#if HAVE_SCMP_FILTER_CTX\n\t/* XXX for debug, pass in SCMP_ACT_TRAP */\n\tconf->seccomp_ctx = seccomp_init(SCMP_ACT_KILL);\n\tret = !conf->seccomp_ctx;\n#else\n\tret = seccomp_init(SCMP_ACT_KILL) < 0;\n#endif\n\tif (ret) {\n\t\tERROR(\"Failed initializing seccomp.\");\n\t\treturn -1;\n\t}\n\n/* turn off no-new-privs.  We don't want it in lxc, and it breaks\n * with apparmor */\n#if HAVE_SCMP_FILTER_CTX\n\tcheck_seccomp_attr_set = seccomp_attr_set(conf->seccomp_ctx, SCMP_FLTATR_CTL_NNP, 0);\n#else\n\tcheck_seccomp_attr_set = seccomp_attr_set(SCMP_FLTATR_CTL_NNP, 0);\n#endif\n\tif (check_seccomp_attr_set) {\n\t\tERROR(\"Failed to turn off n-new-privs.\");\n\t\treturn -1;\n\t}\n#ifdef SCMP_FLTATR_ATL_TSKIP\n\tif (seccomp_attr_set(conf->seccomp_ctx, SCMP_FLTATR_ATL_TSKIP, 1)) {\n\t\tWARN(\"Failed to turn on seccomp nop-skip, continuing\");\n\t}\n#endif\n\n\tf = fopen(conf->seccomp, \"r\");\n\tif (!f) {\n\t\tSYSERROR(\"Failed to open seccomp policy file %s.\", conf->seccomp);\n\t\treturn -1;\n\t}\n\tret = parse_config(f, conf);\n\tfclose(f);\n\treturn ret;\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ret;",
            "int ret;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nint ret;\nint ret;\n\nint lxc_read_seccomp_config(struct lxc_conf *conf)\n{\n\tFILE *f;\n\tint ret;\n\tint check_seccomp_attr_set;\n\n\tif (!conf->seccomp)\n\t\treturn 0;\n\n\tif (!use_seccomp())\n\t\treturn 0;\n#if HAVE_SCMP_FILTER_CTX\n\t/* XXX for debug, pass in SCMP_ACT_TRAP */\n\tconf->seccomp_ctx = seccomp_init(SCMP_ACT_KILL);\n\tret = !conf->seccomp_ctx;\n#else\n\tret = seccomp_init(SCMP_ACT_KILL) < 0;\n#endif\n\tif (ret) {\n\t\tERROR(\"Failed initializing seccomp.\");\n\t\treturn -1;\n\t}\n\n/* turn off no-new-privs.  We don't want it in lxc, and it breaks\n * with apparmor */\n#if HAVE_SCMP_FILTER_CTX\n\tcheck_seccomp_attr_set = seccomp_attr_set(conf->seccomp_ctx, SCMP_FLTATR_CTL_NNP, 0);\n#else\n\tcheck_seccomp_attr_set = seccomp_attr_set(SCMP_FLTATR_CTL_NNP, 0);\n#endif\n\tif (check_seccomp_attr_set) {\n\t\tERROR(\"Failed to turn off n-new-privs.\");\n\t\treturn -1;\n\t}\n#ifdef SCMP_FLTATR_ATL_TSKIP\n\tif (seccomp_attr_set(conf->seccomp_ctx, SCMP_FLTATR_ATL_TSKIP, 1)) {\n\t\tWARN(\"Failed to turn on seccomp nop-skip, continuing\");\n\t}\n#endif\n\n\tf = fopen(conf->seccomp, \"r\");\n\tif (!f) {\n\t\tSYSERROR(\"Failed to open seccomp policy file %s.\", conf->seccomp);\n\t\treturn -1;\n\t}\n\tret = parse_config(f, conf);\n\tfclose(f);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cmd_init",
          "args": [
            "name",
            "handler",
            "lxcpath"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "972-1006",
          "snippet": "int lxc_cmd_init(const char *name, struct lxc_handler *handler,\n\t\t const char *lxcpath)\n{\n\tint fd;\n\tchar path[sizeof(((struct sockaddr_un *)0)->sun_path)] = { 0 };\n\tchar *offset = &path[1];\n\tint len;\n\n\t/* -2 here because this is an abstract unix socket so it needs a\n\t * leading \\0, and we null terminate, so it needs a trailing \\0.\n\t * Although null termination isn't required by the API, we do it anyway\n\t * because we print the sockname out sometimes.\n\t */\n\tlen = sizeof(path)-2;\n\tif (fill_sock_name(offset, len, name, lxcpath, NULL))\n\t\treturn -1;\n\n\tfd = lxc_abstract_unix_open(path, SOCK_STREAM, 0);\n\tif (fd < 0) {\n\t\tERROR(\"Failed to create the command service point %s: %s.\",\n\t\t      offset, strerror(errno));\n\t\tif (errno == EADDRINUSE)\n\t\t\tERROR(\"Container \\\"%s\\\" appears to be already running!\", name);\n\t\treturn -1;\n\t}\n\n\tif (fcntl(fd, F_SETFD, FD_CLOEXEC)) {\n\t\tSYSERROR(\"Failed to set FD_CLOEXEC on signal file descriptor.\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\thandler->conf->maincmd_fd = fd;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nint lxc_cmd_init(const char *name, struct lxc_handler *handler,\n\t\t const char *lxcpath)\n{\n\tint fd;\n\tchar path[sizeof(((struct sockaddr_un *)0)->sun_path)] = { 0 };\n\tchar *offset = &path[1];\n\tint len;\n\n\t/* -2 here because this is an abstract unix socket so it needs a\n\t * leading \\0, and we null terminate, so it needs a trailing \\0.\n\t * Although null termination isn't required by the API, we do it anyway\n\t * because we print the sockname out sometimes.\n\t */\n\tlen = sizeof(path)-2;\n\tif (fill_sock_name(offset, len, name, lxcpath, NULL))\n\t\treturn -1;\n\n\tfd = lxc_abstract_unix_open(path, SOCK_STREAM, 0);\n\tif (fd < 0) {\n\t\tERROR(\"Failed to create the command service point %s: %s.\",\n\t\t      offset, strerror(errno));\n\t\tif (errno == EADDRINUSE)\n\t\t\tERROR(\"Container \\\"%s\\\" appears to be already running!\", name);\n\t\treturn -1;\n\t}\n\n\tif (fcntl(fd, F_SETFD, FD_CLOEXEC)) {\n\t\tSYSERROR(\"Failed to set FD_CLOEXEC on signal file descriptor.\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\thandler->conf->maincmd_fd = fd;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to allocate memory.\""
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "name"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lsm_init",
          "args": [],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "lsm_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lsm/lsm.h",
          "lines": "48-48",
          "snippet": "static inline void        lsm_init(void) { }",
          "includes": [
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n\nstatic inline void        lsm_init(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "handler",
            "0",
            "sizeof(*handler)"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*handler)"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic bool do_destroy_container(struct lxc_conf *conf);\nstatic void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);\n\nstruct lxc_handler *lxc_init(const char *name, struct lxc_conf *conf, const char *lxcpath)\n{\n\tint i;\n\tstruct lxc_handler *handler;\n\n\thandler = malloc(sizeof(*handler));\n\tif (!handler)\n\t\treturn NULL;\n\n\tmemset(handler, 0, sizeof(*handler));\n\n\thandler->ttysock[0] = handler->ttysock[1] = -1;\n\thandler->conf = conf;\n\thandler->lxcpath = lxcpath;\n\thandler->pinfd = -1;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++)\n\t\thandler->nsfd[i] = -1;\n\n\tlsm_init();\n\n\thandler->name = strdup(name);\n\tif (!handler->name) {\n\t\tERROR(\"Failed to allocate memory.\");\n\t\tgoto out_free;\n\t}\n\n\tif (lxc_cmd_init(name, handler, lxcpath))\n\t\tgoto out_free_name;\n\n\tif (lxc_read_seccomp_config(conf) != 0) {\n\t\tERROR(\"Failed loading seccomp policy.\");\n\t\tgoto out_close_maincmd_fd;\n\t}\n\n\t/* Begin by setting the state to STARTING. */\n\tif (lxc_set_state(name, handler, STARTING)) {\n\t\tERROR(\"Failed to set state for container \\\"%s\\\" to \\\"%s\\\".\", name, lxc_state2str(STARTING));\n\t\tgoto out_close_maincmd_fd;\n\t}\n\n\t/* Start of environment variable setup for hooks. */\n\tif (name && setenv(\"LXC_NAME\", name, 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_NAME=%s.\", name);\n\n\tif (conf->rcfile && setenv(\"LXC_CONFIG_FILE\", conf->rcfile, 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_CONFIG_FILE=%s.\", conf->rcfile);\n\n\tif (conf->rootfs.mount && setenv(\"LXC_ROOTFS_MOUNT\", conf->rootfs.mount, 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_ROOTFS_MOUNT=%s.\", conf->rootfs.mount);\n\n\tif (conf->rootfs.path && setenv(\"LXC_ROOTFS_PATH\", conf->rootfs.path, 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_ROOTFS_PATH=%s.\", conf->rootfs.path);\n\n\tif (conf->console.path && setenv(\"LXC_CONSOLE\", conf->console.path, 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_CONSOLE=%s.\", conf->console.path);\n\n\tif (conf->console.log_path && setenv(\"LXC_CONSOLE_LOGPATH\", conf->console.log_path, 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_CONSOLE_LOGPATH=%s.\", conf->console.log_path);\n\n\tif (setenv(\"LXC_CGNS_AWARE\", \"1\", 1))\n\t\tSYSERROR(\"Failed to set environment variable LXC_CGNS_AWARE=1.\");\n\t/* End of environment variable setup for hooks. */\n\n\tif (run_lxc_hooks(name, \"pre-start\", conf, handler->lxcpath, NULL)) {\n\t\tERROR(\"Failed to run lxc.hook.pre-start for container \\\"%s\\\".\", name);\n\t\tgoto out_aborting;\n\t}\n\n\t/* The signal fd has to be created before forking otherwise if the child\n\t * process exits before we setup the signal fd, the event will be lost\n\t * and the command will be stuck.\n\t */\n\thandler->sigfd = setup_signal_fd(&handler->oldmask);\n\tif (handler->sigfd < 0) {\n\t\tERROR(\"Failed to setup SIGCHLD fd handler.\");\n\t\tgoto out_delete_tty;\n\t}\n\n\t/* Do this after setting up signals since it might unblock SIGWINCH. */\n\tif (lxc_console_create(conf)) {\n\t\tERROR(\"Failed to create console for container \\\"%s\\\".\", name);\n\t\tgoto out_restore_sigmask;\n\t}\n\n\tif (ttys_shift_ids(conf) < 0) {\n\t\tERROR(\"Failed to shift tty into container.\");\n\t\tgoto out_restore_sigmask;\n\t}\n\n\tINFO(\"Container \\\"%s\\\" is initialized.\", name);\n\treturn handler;\n\nout_restore_sigmask:\n\tsigprocmask(SIG_SETMASK, &handler->oldmask, NULL);\nout_delete_tty:\n\tlxc_delete_tty(&conf->tty_info);\nout_aborting:\n\tlxc_set_state(name, handler, ABORTING);\nout_close_maincmd_fd:\n\tclose(conf->maincmd_fd);\n\tconf->maincmd_fd = -1;\nout_free_name:\n\tfree(handler->name);\n\thandler->name = NULL;\nout_free:\n\tfree(handler);\n\treturn NULL;\n}"
  },
  {
    "function_name": "lxc_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
    "lines": "351-397",
    "snippet": "int lxc_poll(const char *name, struct lxc_handler *handler)\n{\n\tint sigfd = handler->sigfd;\n\tint pid = handler->pid;\n\tstruct lxc_epoll_descr descr;\n\n\tif (lxc_mainloop_open(&descr)) {\n\t\tERROR(\"Failed to create LXC mainloop.\");\n\t\tgoto out_sigfd;\n\t}\n\n\tif (lxc_mainloop_add_handler(&descr, sigfd, signal_handler, &pid)) {\n\t\tERROR(\"Failed to add signal handler with file descriptor %d to LXC mainloop.\", sigfd);\n\t\tgoto out_mainloop_open;\n\t}\n\n\tif (lxc_console_mainloop_add(&descr, handler->conf)) {\n\t\tERROR(\"Failed to add console handler to LXC mainloop.\");\n\t\tgoto out_mainloop_open;\n\t}\n\n\tif (lxc_cmd_mainloop_add(name, &descr, handler)) {\n\t\tERROR(\"Failed to add command handler to LXC mainloop.\");\n\t\tgoto out_mainloop_open;\n\t}\n\n\tif (handler->conf->need_utmp_watch) {\n\t\t#if HAVE_LIBCAP\n\t\tif (lxc_utmp_mainloop_add(&descr, handler)) {\n\t\t\tERROR(\"Failed to add utmp handler to LXC mainloop.\");\n\t\t\tgoto out_mainloop_open;\n\t\t}\n\t\t#else\n\t\t\tDEBUG(\"Not starting utmp handler as CAP_SYS_BOOT cannot be dropped without capabilities support.\");\n\t\t#endif\n\t}\n\n\treturn lxc_mainloop(&descr, -1);\n\nout_mainloop_open:\n\tlxc_mainloop_close(&descr);\n\nout_sigfd:\n\tclose(sigfd);\n\n\treturn -1;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <sys/reboot.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"sync.h\"",
      "#include \"start.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"lxcutmp.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"console.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/capability.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <alloca.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_destroy_container(struct lxc_conf *conf);",
      "static void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sigfd"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "close_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "118-128",
          "snippet": "static void close_ns(int ns_fd[LXC_NS_MAX])\n{\n\tint i;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (ns_fd[i] > -1) {\n\t\t\tclose(ns_fd[i]);\n\t\t\tns_fd[i] = -1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic void close_ns(int ns_fd[LXC_NS_MAX])\n{\n\tint i;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (ns_fd[i] > -1) {\n\t\t\tclose(ns_fd[i]);\n\t\t\tns_fd[i] = -1;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_mainloop_close",
          "args": [
            "&descr"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_mainloop_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/mainloop.c",
          "lines": "148-163",
          "snippet": "int lxc_mainloop_close(struct lxc_epoll_descr *descr)\n{\n\tstruct lxc_list *iterator, *next;\n\n\titerator = descr->handlers.next;\n\twhile (iterator != &descr->handlers) {\n\t\tnext = iterator->next;\n\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator->elem);\n\t\tfree(iterator);\n\t\titerator = next;\n\t}\n\n\treturn close(descr->epfd);\n}",
          "includes": [
            "#include \"mainloop.h\"",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mainloop.h\"\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint lxc_mainloop_close(struct lxc_epoll_descr *descr)\n{\n\tstruct lxc_list *iterator, *next;\n\n\titerator = descr->handlers.next;\n\twhile (iterator != &descr->handlers) {\n\t\tnext = iterator->next;\n\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator->elem);\n\t\tfree(iterator);\n\t\titerator = next;\n\t}\n\n\treturn close(descr->epfd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_mainloop",
          "args": [
            "&descr",
            "-1"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_mainloop_del_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/mainloop.c",
          "lines": "109-130",
          "snippet": "int lxc_mainloop_del_handler(struct lxc_epoll_descr *descr, int fd)\n{\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *iterator;\n\n\tlxc_list_for_each(iterator, &descr->handlers) {\n\t\thandler = iterator->elem;\n\n\t\tif (handler->fd == fd) {\n\t\t\t/* found */\n\t\t\tif (epoll_ctl(descr->epfd, EPOLL_CTL_DEL, fd, NULL))\n\t\t\t\treturn -1;\n\n\t\t\tlxc_list_del(iterator);\n\t\t\tfree(iterator->elem);\n\t\t\tfree(iterator);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include \"mainloop.h\"",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mainloop.h\"\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint lxc_mainloop_del_handler(struct lxc_epoll_descr *descr, int fd)\n{\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *iterator;\n\n\tlxc_list_for_each(iterator, &descr->handlers) {\n\t\thandler = iterator->elem;\n\n\t\tif (handler->fd == fd) {\n\t\t\t/* found */\n\t\t\tif (epoll_ctl(descr->epfd, EPOLL_CTL_DEL, fd, NULL))\n\t\t\t\treturn -1;\n\n\t\t\tlxc_list_del(iterator);\n\t\t\tfree(iterator->elem);\n\t\t\tfree(iterator);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Not starting utmp handler as CAP_SYS_BOOT cannot be dropped without capabilities support.\""
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to add utmp handler to LXC mainloop.\""
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_utmp_mainloop_add",
          "args": [
            "&descr",
            "handler"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_utmp_mainloop_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxcutmp.c",
          "lines": "306-391",
          "snippet": "int lxc_utmp_mainloop_add(struct lxc_epoll_descr *descr,\n\t\t\t  struct lxc_handler *handler)\n{\n\tchar path[MAXPATHLEN];\n\tchar path2[MAXPATHLEN];\n\tint fd, wd;\n\tstruct lxc_utmp *utmp_data;\n\n\t/* We set up a watch for the /var/run directory. We're only interested\n\t * in utmp at the moment, but want to watch for delete and create\n\t * events as well.\n\t */\n\tif (snprintf(path, MAXPATHLEN, \"/proc/%d/root/run\",\n\t\t     handler->pid) > MAXPATHLEN) {\n\t\tERROR(\"path is too long\");\n\t\treturn -1;\n\t}\n\tif (snprintf(path2, MAXPATHLEN, \"/proc/%d/root/run/utmp\",\n\t\t     handler->pid) > MAXPATHLEN) {\n\t\tERROR(\"path is too long\");\n\t\treturn -1;\n\t}\n\tif (!access(path2, F_OK))\n\t\tgoto run_ok;\n\n\tif (snprintf(path, MAXPATHLEN, \"/proc/%d/root/var/run\",\n\t\t     handler->pid) > MAXPATHLEN) {\n\t\tERROR(\"path is too long\");\n\t\treturn -1;\n\t}\n\n\tif (access(path, F_OK)) {\n\t\tWARN(\"'%s' not found\", path);\n\t\treturn 0;\n\t}\n\nrun_ok:\n\n\tutmp_data = (struct lxc_utmp *)malloc(sizeof(struct lxc_utmp));\n\n\tif (NULL == utmp_data) {\n\t\tSYSERROR(\"failed to malloc handler utmp_data\");\n\t\treturn -1;\n\t}\n\n\tmemset(utmp_data, 0, sizeof(struct lxc_utmp));\n\n\tfd = inotify_init();\n\tif (fd < 0) {\n\t\tSYSERROR(\"failed to inotify_init\");\n\t\tgoto out;\n\t}\n\n\tif (fcntl(fd, F_SETFD, FD_CLOEXEC)) {\n\t\tSYSERROR(\"failed to set inotify fd to close-on-exec\");\n\t\tgoto out_close;\n\n\t}\n\n\twd = inotify_add_watch(fd, path, IN_MODIFY | IN_CREATE);\n\tif (wd < 0) {\n\t\tSYSERROR(\"failed to add watch for '%s'\", path);\n\t\tgoto out_close;\n\t}\n\n\tutmp_data->handler = handler;\n\tutmp_data->container_state = CONTAINER_STARTING;\n\tutmp_data->timer_fd = -1;\n\tutmp_data->prev_runlevel = 'N';\n\tutmp_data->curr_runlevel = 'N';\n\n\tif (lxc_mainloop_add_handler\n\t    (descr, fd, utmp_handler, (void *)utmp_data)) {\n\t\tSYSERROR(\"failed to add mainloop\");\n\t\tgoto out_close;\n\t}\n\n\tDEBUG(\"Added '%s' to inotifywatch\", path);\n\n\treturn 0;\nout_close:\n\tclose(fd);\nout:\n\tfree(utmp_data);\n\treturn -1;\n}",
          "includes": [
            "#include <utmp.h>",
            "#include <utmp.h>",
            "#include <utmpx.h>",
            "#include \"log.h\"",
            "#include \"lxc.h\"",
            "#include \"mainloop.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"conf.h\"",
            "#include <sys/syscall.h>",
            "#include <sys/timerfd.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/inotify.h>",
            "#include <fcntl.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CONTAINER_STARTING  0"
          ],
          "globals_used": [
            "static int utmp_get_runlevel(struct lxc_utmp *utmp_data);",
            "static int utmp_get_ntasks(struct lxc_handler *handler);",
            "static int utmp_shutdown_handler(int fd, uint32_t events, void *data,\n\t\t\t\t struct lxc_epoll_descr *descr);",
            "static int lxc_utmp_del_timer(struct lxc_epoll_descr *descr,\n\t\t\t      struct lxc_utmp *utmp_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <utmp.h>\n#include <utmp.h>\n#include <utmpx.h>\n#include \"log.h\"\n#include \"lxc.h\"\n#include \"mainloop.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"conf.h\"\n#include <sys/syscall.h>\n#include <sys/timerfd.h>\n#include <sys/ioctl.h>\n#include <sys/inotify.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define CONTAINER_STARTING  0\n\nstatic int utmp_get_runlevel(struct lxc_utmp *utmp_data);\nstatic int utmp_get_ntasks(struct lxc_handler *handler);\nstatic int utmp_shutdown_handler(int fd, uint32_t events, void *data,\n\t\t\t\t struct lxc_epoll_descr *descr);\nstatic int lxc_utmp_del_timer(struct lxc_epoll_descr *descr,\n\t\t\t      struct lxc_utmp *utmp_data);\n\nint lxc_utmp_mainloop_add(struct lxc_epoll_descr *descr,\n\t\t\t  struct lxc_handler *handler)\n{\n\tchar path[MAXPATHLEN];\n\tchar path2[MAXPATHLEN];\n\tint fd, wd;\n\tstruct lxc_utmp *utmp_data;\n\n\t/* We set up a watch for the /var/run directory. We're only interested\n\t * in utmp at the moment, but want to watch for delete and create\n\t * events as well.\n\t */\n\tif (snprintf(path, MAXPATHLEN, \"/proc/%d/root/run\",\n\t\t     handler->pid) > MAXPATHLEN) {\n\t\tERROR(\"path is too long\");\n\t\treturn -1;\n\t}\n\tif (snprintf(path2, MAXPATHLEN, \"/proc/%d/root/run/utmp\",\n\t\t     handler->pid) > MAXPATHLEN) {\n\t\tERROR(\"path is too long\");\n\t\treturn -1;\n\t}\n\tif (!access(path2, F_OK))\n\t\tgoto run_ok;\n\n\tif (snprintf(path, MAXPATHLEN, \"/proc/%d/root/var/run\",\n\t\t     handler->pid) > MAXPATHLEN) {\n\t\tERROR(\"path is too long\");\n\t\treturn -1;\n\t}\n\n\tif (access(path, F_OK)) {\n\t\tWARN(\"'%s' not found\", path);\n\t\treturn 0;\n\t}\n\nrun_ok:\n\n\tutmp_data = (struct lxc_utmp *)malloc(sizeof(struct lxc_utmp));\n\n\tif (NULL == utmp_data) {\n\t\tSYSERROR(\"failed to malloc handler utmp_data\");\n\t\treturn -1;\n\t}\n\n\tmemset(utmp_data, 0, sizeof(struct lxc_utmp));\n\n\tfd = inotify_init();\n\tif (fd < 0) {\n\t\tSYSERROR(\"failed to inotify_init\");\n\t\tgoto out;\n\t}\n\n\tif (fcntl(fd, F_SETFD, FD_CLOEXEC)) {\n\t\tSYSERROR(\"failed to set inotify fd to close-on-exec\");\n\t\tgoto out_close;\n\n\t}\n\n\twd = inotify_add_watch(fd, path, IN_MODIFY | IN_CREATE);\n\tif (wd < 0) {\n\t\tSYSERROR(\"failed to add watch for '%s'\", path);\n\t\tgoto out_close;\n\t}\n\n\tutmp_data->handler = handler;\n\tutmp_data->container_state = CONTAINER_STARTING;\n\tutmp_data->timer_fd = -1;\n\tutmp_data->prev_runlevel = 'N';\n\tutmp_data->curr_runlevel = 'N';\n\n\tif (lxc_mainloop_add_handler\n\t    (descr, fd, utmp_handler, (void *)utmp_data)) {\n\t\tSYSERROR(\"failed to add mainloop\");\n\t\tgoto out_close;\n\t}\n\n\tDEBUG(\"Added '%s' to inotifywatch\", path);\n\n\treturn 0;\nout_close:\n\tclose(fd);\nout:\n\tfree(utmp_data);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to add command handler to LXC mainloop.\""
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cmd_mainloop_add",
          "args": [
            "name",
            "&descr",
            "handler"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_mainloop_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "1008-1021",
          "snippet": "int lxc_cmd_mainloop_add(const char *name,\n\t\t\t struct lxc_epoll_descr *descr,\n\t\t\t struct lxc_handler *handler)\n{\n\tint ret, fd = handler->conf->maincmd_fd;\n\n\tret = lxc_mainloop_add_handler(descr, fd, lxc_cmd_accept, handler);\n\tif (ret) {\n\t\tERROR(\"Failed to add handler for command socket.\");\n\t\tclose(fd);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nint lxc_cmd_mainloop_add(const char *name,\n\t\t\t struct lxc_epoll_descr *descr,\n\t\t\t struct lxc_handler *handler)\n{\n\tint ret, fd = handler->conf->maincmd_fd;\n\n\tret = lxc_mainloop_add_handler(descr, fd, lxc_cmd_accept, handler);\n\tif (ret) {\n\t\tERROR(\"Failed to add handler for command socket.\");\n\t\tclose(fd);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to add console handler to LXC mainloop.\""
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_console_mainloop_add",
          "args": [
            "&descr",
            "handler->conf"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_console_mainloop_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
          "lines": "209-243",
          "snippet": "extern int lxc_console_mainloop_add(struct lxc_epoll_descr *descr,\n\t\t\t\t    struct lxc_conf *conf)\n{\n\tstruct lxc_console *console = &conf->console;\n\n\tif (conf->is_execute) {\n\t\tINFO(\"no console for lxc-execute.\");\n\t\treturn 0;\n\t}\n\n\tif (!conf->rootfs.path) {\n\t\tINFO(\"no rootfs, no console.\");\n\t\treturn 0;\n\t}\n\n\tif (console->master < 0) {\n\t\tINFO(\"no console\");\n\t\treturn 0;\n\t}\n\n\tif (lxc_mainloop_add_handler(descr, console->master,\n\t\t\t\t     lxc_console_cb_con, console)) {\n\t\tERROR(\"failed to add to mainloop console handler for '%d'\",\n\t\t      console->master);\n\t\treturn -1;\n\t}\n\n\t/* we cache the descr so that we can add an fd to it when someone\n\t * does attach to it in lxc_console_allocate()\n\t */\n\tconsole->descr = descr;\n\tlxc_console_mainloop_add_peer(console);\n\n\treturn 0;\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"start.h\" \t/* for struct lxc_handler */",
            "#include \"mainloop.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"caps.h\"",
            "#include \"af_unix.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nextern int lxc_console_mainloop_add(struct lxc_epoll_descr *descr,\n\t\t\t\t    struct lxc_conf *conf)\n{\n\tstruct lxc_console *console = &conf->console;\n\n\tif (conf->is_execute) {\n\t\tINFO(\"no console for lxc-execute.\");\n\t\treturn 0;\n\t}\n\n\tif (!conf->rootfs.path) {\n\t\tINFO(\"no rootfs, no console.\");\n\t\treturn 0;\n\t}\n\n\tif (console->master < 0) {\n\t\tINFO(\"no console\");\n\t\treturn 0;\n\t}\n\n\tif (lxc_mainloop_add_handler(descr, console->master,\n\t\t\t\t     lxc_console_cb_con, console)) {\n\t\tERROR(\"failed to add to mainloop console handler for '%d'\",\n\t\t      console->master);\n\t\treturn -1;\n\t}\n\n\t/* we cache the descr so that we can add an fd to it when someone\n\t * does attach to it in lxc_console_allocate()\n\t */\n\tconsole->descr = descr;\n\tlxc_console_mainloop_add_peer(console);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to add signal handler with file descriptor %d to LXC mainloop.\"",
            "sigfd"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_mainloop_add_handler",
          "args": [
            "&descr",
            "sigfd",
            "signal_handler",
            "&pid"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_mainloop_add_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/mainloop.c",
          "lines": "75-107",
          "snippet": "int lxc_mainloop_add_handler(struct lxc_epoll_descr *descr, int fd,\n\t\t\t     lxc_mainloop_callback_t callback, void *data)\n{\n\tstruct epoll_event ev;\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *item;\n\n\thandler = malloc(sizeof(*handler));\n\tif (!handler)\n\t\treturn -1;\n\n\thandler->callback = callback;\n\thandler->fd = fd;\n\thandler->data = data;\n\n\tev.events = EPOLLIN;\n\tev.data.ptr = handler;\n\n\tif (epoll_ctl(descr->epfd, EPOLL_CTL_ADD, fd, &ev) < 0)\n\t\tgoto out_free_handler;\n\n\titem = malloc(sizeof(*item));\n\tif (!item)\n\t\tgoto out_free_handler;\n\n\titem->elem = handler;\n\tlxc_list_add(&descr->handlers, item);\n\treturn 0;\n\nout_free_handler:\n\tfree(handler);\n\treturn -1;\n}",
          "includes": [
            "#include \"mainloop.h\"",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mainloop.h\"\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint lxc_mainloop_add_handler(struct lxc_epoll_descr *descr, int fd,\n\t\t\t     lxc_mainloop_callback_t callback, void *data)\n{\n\tstruct epoll_event ev;\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *item;\n\n\thandler = malloc(sizeof(*handler));\n\tif (!handler)\n\t\treturn -1;\n\n\thandler->callback = callback;\n\thandler->fd = fd;\n\thandler->data = data;\n\n\tev.events = EPOLLIN;\n\tev.data.ptr = handler;\n\n\tif (epoll_ctl(descr->epfd, EPOLL_CTL_ADD, fd, &ev) < 0)\n\t\tgoto out_free_handler;\n\n\titem = malloc(sizeof(*item));\n\tif (!item)\n\t\tgoto out_free_handler;\n\n\titem->elem = handler;\n\tlxc_list_add(&descr->handlers, item);\n\treturn 0;\n\nout_free_handler:\n\tfree(handler);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to create LXC mainloop.\""
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_mainloop_open",
          "args": [
            "&descr"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_mainloop_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/mainloop.c",
          "lines": "132-146",
          "snippet": "int lxc_mainloop_open(struct lxc_epoll_descr *descr)\n{\n\t/* hint value passed to epoll create */\n\tdescr->epfd = epoll_create(2);\n\tif (descr->epfd < 0)\n\t\treturn -1;\n\n\tif (fcntl(descr->epfd, F_SETFD, FD_CLOEXEC)) {\n\t\tclose(descr->epfd);\n\t\treturn -1;\n\t}\n\n\tlxc_list_init(&descr->handlers);\n\treturn 0;\n}",
          "includes": [
            "#include \"mainloop.h\"",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mainloop.h\"\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint lxc_mainloop_open(struct lxc_epoll_descr *descr)\n{\n\t/* hint value passed to epoll create */\n\tdescr->epfd = epoll_create(2);\n\tif (descr->epfd < 0)\n\t\treturn -1;\n\n\tif (fcntl(descr->epfd, F_SETFD, FD_CLOEXEC)) {\n\t\tclose(descr->epfd);\n\t\treturn -1;\n\t}\n\n\tlxc_list_init(&descr->handlers);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic bool do_destroy_container(struct lxc_conf *conf);\nstatic void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);\n\nint lxc_poll(const char *name, struct lxc_handler *handler)\n{\n\tint sigfd = handler->sigfd;\n\tint pid = handler->pid;\n\tstruct lxc_epoll_descr descr;\n\n\tif (lxc_mainloop_open(&descr)) {\n\t\tERROR(\"Failed to create LXC mainloop.\");\n\t\tgoto out_sigfd;\n\t}\n\n\tif (lxc_mainloop_add_handler(&descr, sigfd, signal_handler, &pid)) {\n\t\tERROR(\"Failed to add signal handler with file descriptor %d to LXC mainloop.\", sigfd);\n\t\tgoto out_mainloop_open;\n\t}\n\n\tif (lxc_console_mainloop_add(&descr, handler->conf)) {\n\t\tERROR(\"Failed to add console handler to LXC mainloop.\");\n\t\tgoto out_mainloop_open;\n\t}\n\n\tif (lxc_cmd_mainloop_add(name, &descr, handler)) {\n\t\tERROR(\"Failed to add command handler to LXC mainloop.\");\n\t\tgoto out_mainloop_open;\n\t}\n\n\tif (handler->conf->need_utmp_watch) {\n\t\t#if HAVE_LIBCAP\n\t\tif (lxc_utmp_mainloop_add(&descr, handler)) {\n\t\t\tERROR(\"Failed to add utmp handler to LXC mainloop.\");\n\t\t\tgoto out_mainloop_open;\n\t\t}\n\t\t#else\n\t\t\tDEBUG(\"Not starting utmp handler as CAP_SYS_BOOT cannot be dropped without capabilities support.\");\n\t\t#endif\n\t}\n\n\treturn lxc_mainloop(&descr, -1);\n\nout_mainloop_open:\n\tlxc_mainloop_close(&descr);\n\nout_sigfd:\n\tclose(sigfd);\n\n\treturn -1;\n}"
  },
  {
    "function_name": "lxc_set_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
    "lines": "344-349",
    "snippet": "int lxc_set_state(const char *name, struct lxc_handler *handler, lxc_state_t state)\n{\n\thandler->state = state;\n\tlxc_monitor_send_state(name, state, handler->lxcpath);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <sys/reboot.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"sync.h\"",
      "#include \"start.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"lxcutmp.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"console.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/capability.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <alloca.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_monitor_send_state",
          "args": [
            "name",
            "state",
            "handler->lxcpath"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_monitor_send_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/monitor.c",
          "lines": "130-138",
          "snippet": "void lxc_monitor_send_state(const char *name, lxc_state_t state,\n\t\t\t    const char *lxcpath)\n{\n\tstruct lxc_msg msg = {.type = lxc_msg_state, .value = state};\n\tstrncpy(msg.name, name, sizeof(msg.name));\n\tmsg.name[sizeof(msg.name) - 1] = 0;\n\n\tlxc_monitor_fifo_send(&msg, lxcpath);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"af_unix.h\"",
            "#include \"config.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include <poll.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"state.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"af_unix.h\"\n#include \"config.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <errno.h>\n\nvoid lxc_monitor_send_state(const char *name, lxc_state_t state,\n\t\t\t    const char *lxcpath)\n{\n\tstruct lxc_msg msg = {.type = lxc_msg_state, .value = state};\n\tstrncpy(msg.name, name, sizeof(msg.name));\n\tmsg.name[sizeof(msg.name) - 1] = 0;\n\n\tlxc_monitor_fifo_send(&msg, lxcpath);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);\n\nint lxc_set_state(const char *name, struct lxc_handler *handler, lxc_state_t state)\n{\n\thandler->state = state;\n\tlxc_monitor_send_state(name, state, handler->lxcpath);\n\treturn 0;\n}"
  },
  {
    "function_name": "signal_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
    "lines": "292-342",
    "snippet": "static int signal_handler(int fd, uint32_t events, void *data,\n\t\t\t  struct lxc_epoll_descr *descr)\n{\n\tstruct signalfd_siginfo siginfo;\n\tsiginfo_t info;\n\tint ret;\n\tpid_t *pid = data;\n\tbool init_died = false;\n\n\tret = read(fd, &siginfo, sizeof(siginfo));\n\tif (ret < 0) {\n\t\tERROR(\"Failed to read signal info from signal file descriptor: %d.\", fd);\n\t\treturn -1;\n\t}\n\n\tif (ret != sizeof(siginfo)) {\n\t\tERROR(\"Unexpected size for siginfo struct.\");\n\t\treturn -1;\n\t}\n\n\t/* Check whether init is running. */\n\tinfo.si_pid = 0;\n\tret = waitid(P_PID, *pid, &info, WEXITED | WNOWAIT | WNOHANG);\n\tif (ret == 0 && info.si_pid == *pid)\n\t\tinit_died = true;\n\n\tif (siginfo.ssi_signo != SIGCHLD) {\n\t\tkill(*pid, siginfo.ssi_signo);\n\t\tINFO(\"Forwarded signal %d to pid %d.\", siginfo.ssi_signo, *pid);\n\t\treturn init_died ? 1 : 0;\n\t}\n\n\tif (siginfo.ssi_code == CLD_STOPPED) {\n\t\tINFO(\"Container init process was stopped.\");\n\t\treturn init_died ? 1 : 0;\n\t} else if (siginfo.ssi_code == CLD_CONTINUED) {\n\t\tINFO(\"Container init process was continued.\");\n\t\treturn init_died ? 1 : 0;\n\t}\n\n\t/* More robustness, protect ourself from a SIGCHLD sent\n\t * by a process different from the container init.\n\t */\n\tif (siginfo.ssi_pid != *pid) {\n\t\tNOTICE(\"Received SIGCHLD from pid %d instead of container init %d.\", siginfo.ssi_pid, *pid);\n\t\treturn init_died ? 1 : 0;\n\t}\n\n\tDEBUG(\"Container init process %d exited.\", *pid);\n\treturn 1;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <sys/reboot.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"sync.h\"",
      "#include \"start.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"lxcutmp.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"console.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/capability.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <alloca.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int lxc_rmdir_onedev_wrapper(void *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Container init process %d exited.\"",
            "*pid"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NOTICE",
          "args": [
            "\"Received SIGCHLD from pid %d instead of container init %d.\"",
            "siginfo.ssi_pid",
            "*pid"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Container init process was continued.\""
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Container init process was stopped.\""
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Forwarded signal %d to pid %d.\"",
            "siginfo.ssi_signo",
            "*pid"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "*pid",
            "siginfo.ssi_signo"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitid",
          "args": [
            "P_PID",
            "*pid",
            "&info",
            "WEXITED | WNOWAIT | WNOHANG"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Unexpected size for siginfo struct.\""
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to read signal info from signal file descriptor: %d.\"",
            "fd"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "&siginfo",
            "sizeof(siginfo)"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "962-990",
          "snippet": "int lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic int lxc_rmdir_onedev_wrapper(void *data);\n\nstatic int signal_handler(int fd, uint32_t events, void *data,\n\t\t\t  struct lxc_epoll_descr *descr)\n{\n\tstruct signalfd_siginfo siginfo;\n\tsiginfo_t info;\n\tint ret;\n\tpid_t *pid = data;\n\tbool init_died = false;\n\n\tret = read(fd, &siginfo, sizeof(siginfo));\n\tif (ret < 0) {\n\t\tERROR(\"Failed to read signal info from signal file descriptor: %d.\", fd);\n\t\treturn -1;\n\t}\n\n\tif (ret != sizeof(siginfo)) {\n\t\tERROR(\"Unexpected size for siginfo struct.\");\n\t\treturn -1;\n\t}\n\n\t/* Check whether init is running. */\n\tinfo.si_pid = 0;\n\tret = waitid(P_PID, *pid, &info, WEXITED | WNOWAIT | WNOHANG);\n\tif (ret == 0 && info.si_pid == *pid)\n\t\tinit_died = true;\n\n\tif (siginfo.ssi_signo != SIGCHLD) {\n\t\tkill(*pid, siginfo.ssi_signo);\n\t\tINFO(\"Forwarded signal %d to pid %d.\", siginfo.ssi_signo, *pid);\n\t\treturn init_died ? 1 : 0;\n\t}\n\n\tif (siginfo.ssi_code == CLD_STOPPED) {\n\t\tINFO(\"Container init process was stopped.\");\n\t\treturn init_died ? 1 : 0;\n\t} else if (siginfo.ssi_code == CLD_CONTINUED) {\n\t\tINFO(\"Container init process was continued.\");\n\t\treturn init_died ? 1 : 0;\n\t}\n\n\t/* More robustness, protect ourself from a SIGCHLD sent\n\t * by a process different from the container init.\n\t */\n\tif (siginfo.ssi_pid != *pid) {\n\t\tNOTICE(\"Received SIGCHLD from pid %d instead of container init %d.\", siginfo.ssi_pid, *pid);\n\t\treturn init_died ? 1 : 0;\n\t}\n\n\tDEBUG(\"Container init process %d exited.\", *pid);\n\treturn 1;\n}"
  },
  {
    "function_name": "setup_signal_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
    "lines": "259-290",
    "snippet": "static int setup_signal_fd(sigset_t *oldmask)\n{\n\tsigset_t mask;\n\tint fd;\n\n\t/* Block everything except serious error signals. */\n\tif (sigfillset(&mask) ||\n\t    sigdelset(&mask, SIGILL) ||\n\t    sigdelset(&mask, SIGSEGV) ||\n\t    sigdelset(&mask, SIGBUS) ||\n\t    sigdelset(&mask, SIGWINCH) ||\n\t    sigprocmask(SIG_BLOCK, &mask, oldmask)) {\n\t\tSYSERROR(\"Failed to set signal mask.\");\n\t\treturn -1;\n\t}\n\n\tfd = signalfd(-1, &mask, 0);\n\tif (fd < 0) {\n\t\tSYSERROR(\"Failed to create signal file descriptor.\");\n\t\treturn -1;\n\t}\n\n\tif (fcntl(fd, F_SETFD, FD_CLOEXEC)) {\n\t\tSYSERROR(\"Failed to set FD_CLOEXEC on the signal file descriptor: %d.\", fd);\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\tDEBUG(\"Set SIGCHLD handler with file descriptor: %d.\", fd);\n\n\treturn fd;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <sys/reboot.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"sync.h\"",
      "#include \"start.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"lxcutmp.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"console.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/capability.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <alloca.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Set SIGCHLD handler with file descriptor: %d.\"",
            "fd"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "close_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "118-128",
          "snippet": "static void close_ns(int ns_fd[LXC_NS_MAX])\n{\n\tint i;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (ns_fd[i] > -1) {\n\t\t\tclose(ns_fd[i]);\n\t\t\tns_fd[i] = -1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic void close_ns(int ns_fd[LXC_NS_MAX])\n{\n\tint i;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (ns_fd[i] > -1) {\n\t\t\tclose(ns_fd[i]);\n\t\t\tns_fd[i] = -1;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to set FD_CLOEXEC on the signal file descriptor: %d.\"",
            "fd"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "fd",
            "F_SETFD",
            "FD_CLOEXEC"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to create signal file descriptor.\""
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signalfd",
          "args": [
            "-1",
            "&mask",
            "0"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "signalfd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.h",
          "lines": "155-163",
          "snippet": "static inline int signalfd(int fd, const sigset_t *mask, int flags)\n{\n\tint retval;\n\n\tretval = syscall (__NR_signalfd4, fd, mask, _NSIG / 8, flags);\n\tif (errno == ENOSYS && flags == 0)\n\t\tretval = syscall (__NR_signalfd, fd, mask, _NSIG / 8);\n\treturn retval;\n}",
          "includes": [
            "#include <stdint.h>",
            "#  include <sys/signalfd.h>",
            "#include <../include/getline.h>",
            "#include \"initutils.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#  include <sys/signalfd.h>\n#include <../include/getline.h>\n#include \"initutils.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic inline int signalfd(int fd, const sigset_t *mask, int flags)\n{\n\tint retval;\n\n\tretval = syscall (__NR_signalfd4, fd, mask, _NSIG / 8, flags);\n\tif (errno == ENOSYS && flags == 0)\n\t\tretval = syscall (__NR_signalfd, fd, mask, _NSIG / 8);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to set signal mask.\""
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_BLOCK",
            "&mask",
            "oldmask"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelset",
          "args": [
            "&mask",
            "SIGWINCH"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelset",
          "args": [
            "&mask",
            "SIGBUS"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelset",
          "args": [
            "&mask",
            "SIGSEGV"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelset",
          "args": [
            "&mask",
            "SIGILL"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigfillset",
          "args": [
            "&mask"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic int setup_signal_fd(sigset_t *oldmask)\n{\n\tsigset_t mask;\n\tint fd;\n\n\t/* Block everything except serious error signals. */\n\tif (sigfillset(&mask) ||\n\t    sigdelset(&mask, SIGILL) ||\n\t    sigdelset(&mask, SIGSEGV) ||\n\t    sigdelset(&mask, SIGBUS) ||\n\t    sigdelset(&mask, SIGWINCH) ||\n\t    sigprocmask(SIG_BLOCK, &mask, oldmask)) {\n\t\tSYSERROR(\"Failed to set signal mask.\");\n\t\treturn -1;\n\t}\n\n\tfd = signalfd(-1, &mask, 0);\n\tif (fd < 0) {\n\t\tSYSERROR(\"Failed to create signal file descriptor.\");\n\t\treturn -1;\n\t}\n\n\tif (fcntl(fd, F_SETFD, FD_CLOEXEC)) {\n\t\tSYSERROR(\"Failed to set FD_CLOEXEC on the signal file descriptor: %d.\", fd);\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\tDEBUG(\"Set SIGCHLD handler with file descriptor: %d.\", fd);\n\n\treturn fd;\n}"
  },
  {
    "function_name": "lxc_check_inherited",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
    "lines": "198-257",
    "snippet": "int lxc_check_inherited(struct lxc_conf *conf, bool closeall, int fd_to_ignore)\n{\n\tstruct dirent *direntp;\n\tint fd, fddir;\n\tDIR *dir;\n\n\tif (conf && conf->close_all_fds)\n\t\tcloseall = true;\n\nrestart:\n\tdir = opendir(\"/proc/self/fd\");\n\tif (!dir) {\n\t\tWARN(\"Failed to open directory: %m.\");\n\t\treturn -1;\n\t}\n\n\tfddir = dirfd(dir);\n\n\twhile ((direntp = readdir(dir))) {\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\"))\n\t\t\tcontinue;\n\n\t\tif (!strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\tif (lxc_safe_int(direntp->d_name, &fd) < 0) {\n\t\t\tINFO(\"Could not parse file descriptor for: %s\", direntp->d_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fd == fddir || fd == lxc_log_fd || fd == fd_to_ignore)\n\t\t\tcontinue;\n\n\t\tif (current_config && fd == current_config->logfd)\n\t\t\tcontinue;\n\n\t\tif (match_fd(fd))\n\t\t\tcontinue;\n\n\t\tif (closeall) {\n\t\t\tclose(fd);\n\t\t\tclosedir(dir);\n\t\t\tINFO(\"Closed inherited fd: %d.\", fd);\n\t\t\tgoto restart;\n\t\t}\n\t\tWARN(\"Inherited fd: %d.\", fd);\n\t}\n\n\t/* Only enable syslog at this point to avoid the above logging function\n\t * to open a new fd and make the check_inherited function enter an\n\t * infinite loop.\n\t */\n\tlxc_log_enable_syslog();\n\n\tclosedir(dir); /* cannot fail */\n\treturn 0;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <sys/reboot.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"sync.h\"",
      "#include \"start.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"lxcutmp.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"console.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/capability.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <alloca.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_destroy_container(struct lxc_conf *conf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dir"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_log_enable_syslog",
          "args": [],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_log_enable_syslog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
          "lines": "536-539",
          "snippet": "extern void lxc_log_enable_syslog(void)\n{\n\tsyslog_enable = 1;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"caps.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <pthread.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int syslog_enable = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nstatic int syslog_enable = 0;\n\nextern void lxc_log_enable_syslog(void)\n{\n\tsyslog_enable = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Inherited fd: %d.\"",
            "fd"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Closed inherited fd: %d.\"",
            "fd"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dir"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "close_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "118-128",
          "snippet": "static void close_ns(int ns_fd[LXC_NS_MAX])\n{\n\tint i;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (ns_fd[i] > -1) {\n\t\t\tclose(ns_fd[i]);\n\t\t\tns_fd[i] = -1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic void close_ns(int ns_fd[LXC_NS_MAX])\n{\n\tint i;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (ns_fd[i] > -1) {\n\t\t\tclose(ns_fd[i]);\n\t\t\tns_fd[i] = -1;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_fd",
          "args": [
            "fd"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "match_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "185-188",
          "snippet": "static int match_fd(int fd)\n{\n\treturn (fd == 0 || fd == 1 || fd == 2);\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic int match_fd(int fd)\n{\n\treturn (fd == 0 || fd == 1 || fd == 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Could not parse file descriptor for: %s\"",
            "direntp->d_name"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_safe_int",
          "args": [
            "direntp->d_name",
            "&fd"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_safe_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "2005-2023",
          "snippet": "int lxc_safe_int(const char *numstr, int *converted)\n{\n\tchar *err = NULL;\n\tsigned long int sli;\n\n\terrno = 0;\n\tsli = strtol(numstr, &err, 0);\n\tif (errno > 0)\n\t\treturn -errno;\n\n\tif (!err || err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\n\tif (sli > INT_MAX)\n\t\treturn -ERANGE;\n\n\t*converted = (int)sli;\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_safe_int(const char *numstr, int *converted)\n{\n\tchar *err = NULL;\n\tsigned long int sli;\n\n\terrno = 0;\n\tsli = strtol(numstr, &err, 0);\n\tif (errno > 0)\n\t\treturn -errno;\n\n\tif (!err || err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\n\tif (sli > INT_MAX)\n\t\treturn -ERANGE;\n\n\t*converted = (int)sli;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "direntp->d_name",
            "\"..\""
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "direntp->d_name",
            "\".\""
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "dir"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dirfd",
          "args": [
            "dir"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to open directory: %m.\""
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "\"/proc/self/fd\""
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic bool do_destroy_container(struct lxc_conf *conf);\n\nint lxc_check_inherited(struct lxc_conf *conf, bool closeall, int fd_to_ignore)\n{\n\tstruct dirent *direntp;\n\tint fd, fddir;\n\tDIR *dir;\n\n\tif (conf && conf->close_all_fds)\n\t\tcloseall = true;\n\nrestart:\n\tdir = opendir(\"/proc/self/fd\");\n\tif (!dir) {\n\t\tWARN(\"Failed to open directory: %m.\");\n\t\treturn -1;\n\t}\n\n\tfddir = dirfd(dir);\n\n\twhile ((direntp = readdir(dir))) {\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\"))\n\t\t\tcontinue;\n\n\t\tif (!strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\tif (lxc_safe_int(direntp->d_name, &fd) < 0) {\n\t\t\tINFO(\"Could not parse file descriptor for: %s\", direntp->d_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fd == fddir || fd == lxc_log_fd || fd == fd_to_ignore)\n\t\t\tcontinue;\n\n\t\tif (current_config && fd == current_config->logfd)\n\t\t\tcontinue;\n\n\t\tif (match_fd(fd))\n\t\t\tcontinue;\n\n\t\tif (closeall) {\n\t\t\tclose(fd);\n\t\t\tclosedir(dir);\n\t\t\tINFO(\"Closed inherited fd: %d.\", fd);\n\t\t\tgoto restart;\n\t\t}\n\t\tWARN(\"Inherited fd: %d.\", fd);\n\t}\n\n\t/* Only enable syslog at this point to avoid the above logging function\n\t * to open a new fd and make the check_inherited function enter an\n\t * infinite loop.\n\t */\n\tlxc_log_enable_syslog();\n\n\tclosedir(dir); /* cannot fail */\n\treturn 0;\n}"
  },
  {
    "function_name": "match_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
    "lines": "185-188",
    "snippet": "static int match_fd(int fd)\n{\n\treturn (fd == 0 || fd == 1 || fd == 2);\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <sys/reboot.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"sync.h\"",
      "#include \"start.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"lxcutmp.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"console.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/capability.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <alloca.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic int match_fd(int fd)\n{\n\treturn (fd == 0 || fd == 1 || fd == 2);\n}"
  },
  {
    "function_name": "attach_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
    "lines": "168-183",
    "snippet": "static int attach_ns(const int ns_fd[LXC_NS_MAX]) {\n\tint i;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (ns_fd[i] < 0)\n\t\t\tcontinue;\n\n\t\tif (setns(ns_fd[i], 0) != 0)\n\t\t\tgoto error;\n\t}\n\treturn 0;\n\nerror:\n\tSYSERROR(\"Failed to attach %s namespace.\", ns_info[i].proc_name);\n\treturn -1;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <sys/reboot.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"sync.h\"",
      "#include \"start.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"lxcutmp.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"console.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/capability.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <alloca.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to attach %s namespace.\"",
            "ns_info[i].proc_name"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setns",
          "args": [
            "ns_fd[i]",
            "0"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "setns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.h",
          "lines": "58-68",
          "snippet": "static inline int setns(int fd, int nstype)\n{\n#ifdef __NR_setns\n\treturn syscall(__NR_setns, fd, nstype);\n#elif defined(__NR_set_ns)\n\treturn syscall(__NR_set_ns, fd, nstype);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}",
          "includes": [
            "#include <stdint.h>",
            "#  include <sys/signalfd.h>",
            "#include <../include/getline.h>",
            "#include \"initutils.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#  include <sys/signalfd.h>\n#include <../include/getline.h>\n#include \"initutils.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic inline int setns(int fd, int nstype)\n{\n#ifdef __NR_setns\n\treturn syscall(__NR_setns, fd, nstype);\n#elif defined(__NR_set_ns)\n\treturn syscall(__NR_set_ns, fd, nstype);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic int attach_ns(const int ns_fd[LXC_NS_MAX]) {\n\tint i;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (ns_fd[i] < 0)\n\t\t\tcontinue;\n\n\t\tif (setns(ns_fd[i], 0) != 0)\n\t\t\tgoto error;\n\t}\n\treturn 0;\n\nerror:\n\tSYSERROR(\"Failed to attach %s namespace.\", ns_info[i].proc_name);\n\treturn -1;\n}"
  },
  {
    "function_name": "preserve_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
    "lines": "134-166",
    "snippet": "static bool preserve_ns(int ns_fd[LXC_NS_MAX], int clone_flags, pid_t pid)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++)\n\t\tns_fd[i] = -1;\n\n\tret = lxc_preserve_ns(pid, \"\");\n\tif (ret < 0) {\n\t\tSYSERROR(\"Kernel does not support attaching to namespaces.\");\n\t\treturn false;\n\t} else {\n\t\tclose(ret);\n\t}\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif ((clone_flags & ns_info[i].clone_flag) == 0)\n\t\t\tcontinue;\n\t\tns_fd[i] = lxc_preserve_ns(pid, ns_info[i].proc_name);\n\t\tif (ns_fd[i] < 0)\n\t\t\tgoto error;\n\t}\n\n\treturn true;\n\nerror:\n\tif (errno == ENOENT)\n\t\tSYSERROR(\"Kernel does not support attaching to %s namespaces.\", ns_info[i].proc_name);\n\telse\n\t\tSYSERROR(\"Failed to open file descriptor for %s namespace: %s.\", ns_info[i].proc_name, strerror(errno));\n\tclose_ns(ns_fd);\n\treturn false;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <sys/reboot.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"sync.h\"",
      "#include \"start.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"lxcutmp.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"console.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/capability.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <alloca.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close_ns",
          "args": [
            "ns_fd"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "close_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "118-128",
          "snippet": "static void close_ns(int ns_fd[LXC_NS_MAX])\n{\n\tint i;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (ns_fd[i] > -1) {\n\t\t\tclose(ns_fd[i]);\n\t\t\tns_fd[i] = -1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic void close_ns(int ns_fd[LXC_NS_MAX])\n{\n\tint i;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (ns_fd[i] > -1) {\n\t\t\tclose(ns_fd[i]);\n\t\t\tns_fd[i] = -1;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to open file descriptor for %s namespace: %s.\"",
            "ns_info[i].proc_name",
            "strerror(errno)"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Kernel does not support attaching to %s namespaces.\"",
            "ns_info[i].proc_name"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_preserve_ns",
          "args": [
            "pid",
            "ns_info[i].proc_name"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_preserve_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1965-1983",
          "snippet": "int lxc_preserve_ns(const int pid, const char *ns)\n{\n\tint ret;\n/* 5 /proc + 21 /int_as_str + 3 /ns + 20 /NS_NAME + 1 \\0 */\n#define __NS_PATH_LEN 50\n\tchar path[__NS_PATH_LEN];\n\n\t/* This way we can use this function to also check whether namespaces\n\t * are supported by the kernel by passing in the NULL or the empty\n\t * string.\n\t */\n\tret = snprintf(path, __NS_PATH_LEN, \"/proc/%d/ns%s%s\", pid,\n\t\t       !ns || strcmp(ns, \"\") == 0 ? \"\" : \"/\",\n\t\t       !ns || strcmp(ns, \"\") == 0 ? \"\" : ns);\n\tif (ret < 0 || (size_t)ret >= __NS_PATH_LEN)\n\t\treturn -1;\n\n\treturn open(path, O_RDONLY | O_CLOEXEC);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define __NS_PATH_LEN 50"
          ],
          "globals_used": [
            "extern bool btrfs_try_remove_subvol(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\n#define __NS_PATH_LEN 50\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nint lxc_preserve_ns(const int pid, const char *ns)\n{\n\tint ret;\n/* 5 /proc + 21 /int_as_str + 3 /ns + 20 /NS_NAME + 1 \\0 */\n#define __NS_PATH_LEN 50\n\tchar path[__NS_PATH_LEN];\n\n\t/* This way we can use this function to also check whether namespaces\n\t * are supported by the kernel by passing in the NULL or the empty\n\t * string.\n\t */\n\tret = snprintf(path, __NS_PATH_LEN, \"/proc/%d/ns%s%s\", pid,\n\t\t       !ns || strcmp(ns, \"\") == 0 ? \"\" : \"/\",\n\t\t       !ns || strcmp(ns, \"\") == 0 ? \"\" : ns);\n\tif (ret < 0 || (size_t)ret >= __NS_PATH_LEN)\n\t\treturn -1;\n\n\treturn open(path, O_RDONLY | O_CLOEXEC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Kernel does not support attaching to namespaces.\""
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic bool preserve_ns(int ns_fd[LXC_NS_MAX], int clone_flags, pid_t pid)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++)\n\t\tns_fd[i] = -1;\n\n\tret = lxc_preserve_ns(pid, \"\");\n\tif (ret < 0) {\n\t\tSYSERROR(\"Kernel does not support attaching to namespaces.\");\n\t\treturn false;\n\t} else {\n\t\tclose(ret);\n\t}\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif ((clone_flags & ns_info[i].clone_flag) == 0)\n\t\t\tcontinue;\n\t\tns_fd[i] = lxc_preserve_ns(pid, ns_info[i].proc_name);\n\t\tif (ns_fd[i] < 0)\n\t\t\tgoto error;\n\t}\n\n\treturn true;\n\nerror:\n\tif (errno == ENOENT)\n\t\tSYSERROR(\"Kernel does not support attaching to %s namespaces.\", ns_info[i].proc_name);\n\telse\n\t\tSYSERROR(\"Failed to open file descriptor for %s namespace: %s.\", ns_info[i].proc_name, strerror(errno));\n\tclose_ns(ns_fd);\n\treturn false;\n}"
  },
  {
    "function_name": "close_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
    "lines": "118-128",
    "snippet": "static void close_ns(int ns_fd[LXC_NS_MAX])\n{\n\tint i;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (ns_fd[i] > -1) {\n\t\t\tclose(ns_fd[i]);\n\t\t\tns_fd[i] = -1;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <sys/reboot.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"sync.h\"",
      "#include \"start.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"lxcutmp.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"console.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/capability.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <alloca.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "ns_fd[i]"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "close_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "118-128",
          "snippet": "static void close_ns(int ns_fd[LXC_NS_MAX])\n{\n\tint i;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (ns_fd[i] > -1) {\n\t\t\tclose(ns_fd[i]);\n\t\t\tns_fd[i] = -1;\n\t\t}\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic void close_ns(int ns_fd[LXC_NS_MAX])\n{\n\tint i;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (ns_fd[i] > -1) {\n\t\t\tclose(ns_fd[i]);\n\t\t\tns_fd[i] = -1;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "print_top_failing_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
    "lines": "93-116",
    "snippet": "static void print_top_failing_dir(const char *path)\n{\n\tsize_t len = strlen(path);\n\tchar *copy = alloca(len + 1), *p, *e, saved;\n\tstrcpy(copy, path);\n\n\tp = copy;\n\te = copy + len;\n\twhile (p < e) {\n\t\twhile (p < e && *p == '/')\n\t\t\tp++;\n\t\twhile (p < e && *p != '/')\n\t\t\tp++;\n\t\tsaved = *p;\n\t\t*p = '\\0';\n\t\tif (access(copy, X_OK)) {\n\t\t\tSYSERROR(\"Could not access %s. Please grant it x \"\n\t\t\t\t \"access, or add an ACL for the container \"\n\t\t\t\t \"root.\", copy);\n\t\t\treturn;\n\t\t}\n\t\t*p = saved;\n\t}\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <sys/reboot.h>",
      "#include \"lsm/lsm.h\"",
      "#include \"utils.h\"",
      "#include \"sync.h\"",
      "#include \"start.h\"",
      "#include \"namespace.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"lxcutmp.h\"",
      "#include \"lxcseccomp.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"console.h\"",
      "#include \"conf.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"",
      "#include \"bdev.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/capability.h>",
      "#include <sys/wait.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <poll.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <alloca.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Could not access %s. Please grant it x \"\n\t\t\t\t \"access, or add an ACL for the container \"\n\t\t\t\t \"root.\"",
            "copy"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "copy",
            "X_OK"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "copy",
            "path"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "len + 1"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic void print_top_failing_dir(const char *path)\n{\n\tsize_t len = strlen(path);\n\tchar *copy = alloca(len + 1), *p, *e, saved;\n\tstrcpy(copy, path);\n\n\tp = copy;\n\te = copy + len;\n\twhile (p < e) {\n\t\twhile (p < e && *p == '/')\n\t\t\tp++;\n\t\twhile (p < e && *p != '/')\n\t\t\tp++;\n\t\tsaved = *p;\n\t\t*p = '\\0';\n\t\tif (access(copy, X_OK)) {\n\t\t\tSYSERROR(\"Could not access %s. Please grant it x \"\n\t\t\t\t \"access, or add an ACL for the container \"\n\t\t\t\t \"root.\", copy);\n\t\t\treturn;\n\t\t}\n\t\t*p = saved;\n\t}\n}"
  }
]