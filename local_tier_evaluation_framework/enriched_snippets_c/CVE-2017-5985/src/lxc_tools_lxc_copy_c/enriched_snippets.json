[
  {
    "function_name": "mount_tmpfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
    "lines": "818-893",
    "snippet": "static char *mount_tmpfs(const char *oldname, const char *newname,\n\t\t\t const char *path, struct lxc_arguments *arg)\n{\n\tint ret, fd;\n\tsize_t len;\n\tchar *premount = NULL;\n\tFILE *fp;\n\n\tif (arg->tmpfs && arg->keepdata) {\n\t\tfprintf(stderr, \"%s\\n\", \"A container can only be placed on a \"\n\t\t\t\t\t\"tmpfs when storage backend is overlay \"\n\t\t\t\t\t\"or aufs.\");\n\t\tgoto err_free;\n\t}\n\n\tif (arg->tmpfs && !arg->bdevtype) {\n\t\targ->bdevtype = \"overlayfs\";\n\t} else if (arg->tmpfs && arg->bdevtype && strcmp(arg->bdevtype, \"overlayfs\") && strcmp(arg->bdevtype, \"aufs\")) {\n\t\tfprintf(stderr, \"%s\\n\", \"A container can only be placed on a \"\n\t\t\t\t\t\"tmpfs when storage backend is overlay \"\n\t\t\t\t\t\"or aufs.\");\n\t\tgoto err_free;\n\t}\n\n\tlen = strlen(path) + strlen(newname) + strlen(\"pre-start-XXXXXX\") + /* //\\0 */ 3;\n\tpremount = malloc(len);\n\tif (!premount)\n\t\tgoto err_free;\n\n\tret = snprintf(premount, len, \"%s/%s/pre-start-XXXXXX\", path, newname);\n\tif (ret < 0 || (size_t)ret >= len)\n\t\tgoto err_free;\n\n\tfd = mkstemp(premount);\n\tif (fd < 0)\n\t\tgoto err_free;\n\n\tif (fcntl(fd, F_SETFD, FD_CLOEXEC)) {\n\t\tSYSERROR(\"Failed to set close-on-exec on file descriptor.\");\n\t\tgoto err_close;\n\t}\n\n\tif (chmod(premount, 0755) < 0)\n\t\tgoto err_close;\n\n\tfp = fdopen(fd, \"r+\");\n\tif (!fp)\n\t\tgoto err_close;\n\tfd = -1;\n\n\tret = fprintf(fp, \"#! /bin/sh\\n\"\n\t\t\t  \"mount -n -t tmpfs -o mode=0755 none %s/%s\\n\",\n\t\t      path, newname);\n\tif (ret < 0)\n\t\tgoto err_close;\n\n\tif (!arg->keepname) {\n\t\tret = fprintf(fp, \"mkdir -p %s/%s/delta0/etc\\n\"\n\t\t\t\t  \"echo %s > %s/%s/delta0/etc/hostname\\n\",\n\t\t\t      path, newname, newname, path, newname);\n\t\tif (ret < 0)\n\t\t\tgoto err_close;\n\t}\n\n\tfclose(fp);\n\treturn premount;\n\nerr_close:\n\tif (fd > 0)\n\t\tclose(fd);\n\telse\n\t\tfclose(fp);\nerr_free:\n\tfree(premount);\n\treturn NULL;\n}",
    "includes": [
      "#include <../include/getsubopt.h>",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"arguments.h\"",
      "#include \"confile.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <stdbool.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <stdint.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <getopt.h>",
      "#include <unistd.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int my_parser(struct lxc_arguments *args, int c, char *arg);",
      "static int mk_rand_ovl_dirs(struct mnts *mnts, unsigned int num,\n\t\t\t    struct lxc_arguments *arg);",
      "static int do_clone_rename(struct lxc_container *c, char *newname);",
      "static uint64_t get_fssize(char *s);",
      "static char *mount_tmpfs(const char *oldname, const char *newname,\n\t\t\t const char *path, struct lxc_arguments *arg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "premount"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "free_mnts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "539-554",
          "snippet": "static void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int mnt_table_size = 0;",
            "static struct mnts *mnt_table = NULL;",
            "static void free_mnts(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic unsigned int mnt_table_size = 0;\nstatic struct mnts *mnt_table = NULL;\nstatic void free_mnts(void);\n\nstatic void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"mkdir -p %s/%s/delta0/etc\\n\"\n\t\t\t\t  \"echo %s > %s/%s/delta0/etc/hostname\\n\"",
            "path",
            "newname",
            "newname",
            "path",
            "newname"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"#! /bin/sh\\n\"\n\t\t\t  \"mount -n -t tmpfs -o mode=0755 none %s/%s\\n\"",
            "path",
            "newname"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdopen",
          "args": [
            "fd",
            "\"r+\""
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "premount",
            "0755"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to set close-on-exec on file descriptor.\""
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "fd",
            "F_SETFD",
            "FD_CLOEXEC"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkstemp",
          "args": [
            "premount"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "premount",
            "len",
            "\"%s/%s/pre-start-XXXXXX\"",
            "path",
            "newname"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"pre-start-XXXXXX\""
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "newname"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s\\n\"",
            "\"A container can only be placed on a \"\n\t\t\t\t\t\"tmpfs when storage backend is overlay \"\n\t\t\t\t\t\"or aufs.\""
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg->bdevtype",
            "\"aufs\""
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg->bdevtype",
            "\"overlayfs\""
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s\\n\"",
            "\"A container can only be placed on a \"\n\t\t\t\t\t\"tmpfs when storage backend is overlay \"\n\t\t\t\t\t\"or aufs.\""
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic int my_parser(struct lxc_arguments *args, int c, char *arg);\nstatic int mk_rand_ovl_dirs(struct mnts *mnts, unsigned int num,\n\t\t\t    struct lxc_arguments *arg);\nstatic int do_clone_rename(struct lxc_container *c, char *newname);\nstatic uint64_t get_fssize(char *s);\nstatic char *mount_tmpfs(const char *oldname, const char *newname,\n\t\t\t const char *path, struct lxc_arguments *arg);\n\nstatic char *mount_tmpfs(const char *oldname, const char *newname,\n\t\t\t const char *path, struct lxc_arguments *arg)\n{\n\tint ret, fd;\n\tsize_t len;\n\tchar *premount = NULL;\n\tFILE *fp;\n\n\tif (arg->tmpfs && arg->keepdata) {\n\t\tfprintf(stderr, \"%s\\n\", \"A container can only be placed on a \"\n\t\t\t\t\t\"tmpfs when storage backend is overlay \"\n\t\t\t\t\t\"or aufs.\");\n\t\tgoto err_free;\n\t}\n\n\tif (arg->tmpfs && !arg->bdevtype) {\n\t\targ->bdevtype = \"overlayfs\";\n\t} else if (arg->tmpfs && arg->bdevtype && strcmp(arg->bdevtype, \"overlayfs\") && strcmp(arg->bdevtype, \"aufs\")) {\n\t\tfprintf(stderr, \"%s\\n\", \"A container can only be placed on a \"\n\t\t\t\t\t\"tmpfs when storage backend is overlay \"\n\t\t\t\t\t\"or aufs.\");\n\t\tgoto err_free;\n\t}\n\n\tlen = strlen(path) + strlen(newname) + strlen(\"pre-start-XXXXXX\") + /* //\\0 */ 3;\n\tpremount = malloc(len);\n\tif (!premount)\n\t\tgoto err_free;\n\n\tret = snprintf(premount, len, \"%s/%s/pre-start-XXXXXX\", path, newname);\n\tif (ret < 0 || (size_t)ret >= len)\n\t\tgoto err_free;\n\n\tfd = mkstemp(premount);\n\tif (fd < 0)\n\t\tgoto err_free;\n\n\tif (fcntl(fd, F_SETFD, FD_CLOEXEC)) {\n\t\tSYSERROR(\"Failed to set close-on-exec on file descriptor.\");\n\t\tgoto err_close;\n\t}\n\n\tif (chmod(premount, 0755) < 0)\n\t\tgoto err_close;\n\n\tfp = fdopen(fd, \"r+\");\n\tif (!fp)\n\t\tgoto err_close;\n\tfd = -1;\n\n\tret = fprintf(fp, \"#! /bin/sh\\n\"\n\t\t\t  \"mount -n -t tmpfs -o mode=0755 none %s/%s\\n\",\n\t\t      path, newname);\n\tif (ret < 0)\n\t\tgoto err_close;\n\n\tif (!arg->keepname) {\n\t\tret = fprintf(fp, \"mkdir -p %s/%s/delta0/etc\\n\"\n\t\t\t\t  \"echo %s > %s/%s/delta0/etc/hostname\\n\",\n\t\t\t      path, newname, newname, path, newname);\n\t\tif (ret < 0)\n\t\t\tgoto err_close;\n\t}\n\n\tfclose(fp);\n\treturn premount;\n\nerr_close:\n\tif (fd > 0)\n\t\tclose(fd);\n\telse\n\t\tfclose(fp);\nerr_free:\n\tfree(premount);\n\treturn NULL;\n}"
  },
  {
    "function_name": "parse_ovl_mnt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
    "lines": "771-807",
    "snippet": "static int parse_ovl_mnt(char *mntstring, enum mnttype type)\n{\n\tint len = 0;\n\tchar **mntarray = NULL;\n\tstruct mnts *m;\n\n\tm = add_mnt(&mnt_table, &mnt_table_size, type);\n\tif (!m)\n\t\tgoto err;\n\n\tmntarray = lxc_string_split(mntstring, ':');\n\tif (!mntarray)\n\t\tgoto err;\n\n\tm->src = construct_path(mntarray[0], true);\n\tif (!m->src)\n\t\tgoto err;\n\n\tlen = lxc_array_len((void **)mntarray);\n\tif (len == 1) /* overlay=src */\n\t\tm->dest = construct_path(mntarray[0], false);\n\telse if (len == 2) /* overlay=src:dest */\n\t\tm->dest = construct_path(mntarray[1], false);\n\telse\n\t\tINFO(\"Excess elements in mount specification\");\n\n\tif (!m->dest)\n\t\tgoto err;\n\n\tlxc_free_array((void **)mntarray, free);\n\treturn 0;\n\nerr:\n\tfree_mnts();\n\tlxc_free_array((void **)mntarray, free);\n\treturn -1;\n}",
    "includes": [
      "#include <../include/getsubopt.h>",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"arguments.h\"",
      "#include \"confile.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <stdbool.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <stdint.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <getopt.h>",
      "#include <unistd.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int mnt_table_size = 0;",
      "static struct mnts *mnt_table = NULL;",
      "static struct mnts *add_mnt(struct mnts **mnts, unsigned int *num,\n\t\t\t    enum mnttype type);",
      "static char *set_mnt_entry(struct mnts *m);",
      "static void free_mnts(void);",
      "static int parse_aufs_mnt(char *mntstring, enum mnttype type);",
      "static int parse_bind_mnt(char *mntstring, enum mnttype type);",
      "static int parse_ovl_mnt(char *mntstring, enum mnttype type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_free_array",
          "args": [
            "(void **)mntarray",
            "free"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_free_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "886-892",
          "snippet": "void lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_mnts",
          "args": [],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "free_mnts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "539-554",
          "snippet": "static void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int mnt_table_size = 0;",
            "static struct mnts *mnt_table = NULL;",
            "static void free_mnts(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic unsigned int mnt_table_size = 0;\nstatic struct mnts *mnt_table = NULL;\nstatic void free_mnts(void);\n\nstatic void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Excess elements in mount specification\""
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "construct_path",
          "args": [
            "mntarray[1]",
            "false"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "construct_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "303-316",
          "snippet": "static char *construct_path(char *path, bool as_prefix)\n{\n\tchar **components = NULL;\n\tchar *cleanpath = NULL;\n\n\tcomponents = lxc_normalize_path(path);\n\tif (!components)\n\t\treturn NULL;\n\n\tcleanpath = lxc_string_join(\"/\", (const char **)components, as_prefix);\n\tlxc_free_array((void **)components, free);\n\n\treturn cleanpath;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *construct_path(char *path, bool as_prefix);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic char *construct_path(char *path, bool as_prefix);\n\nstatic char *construct_path(char *path, bool as_prefix)\n{\n\tchar **components = NULL;\n\tchar *cleanpath = NULL;\n\n\tcomponents = lxc_normalize_path(path);\n\tif (!components)\n\t\treturn NULL;\n\n\tcleanpath = lxc_string_join(\"/\", (const char **)components, as_prefix);\n\tlxc_free_array((void **)components, free);\n\n\treturn cleanpath;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_array_len",
          "args": [
            "(void **)mntarray"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_array_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "923-932",
          "snippet": "size_t lxc_array_len(void **array)\n{\n\tvoid **p;\n\tsize_t result = 0;\n\n\tfor (p = array; p && *p; p++)\n\t\tresult++;\n\n\treturn result;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nsize_t lxc_array_len(void **array)\n{\n\tvoid **p;\n\tsize_t result = 0;\n\n\tfor (p = array; p && *p; p++)\n\t\tresult++;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_string_split",
          "args": [
            "mntstring",
            "':'"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_split_and_trim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "845-884",
          "snippet": "char **lxc_string_split_and_trim(const char *string, char _sep)\n{\n\tchar *token, *str, *saveptr = NULL;\n\tchar sep[2] = { _sep, '\\0' };\n\tchar **result = NULL;\n\tsize_t result_capacity = 0;\n\tsize_t result_count = 0;\n\tint r, saved_errno;\n\tsize_t i = 0;\n\n\tif (!string)\n\t\treturn calloc(1, sizeof(char *));\n\n\tstr = alloca(strlen(string)+1);\n\tstrcpy(str, string);\n\tfor (; (token = strtok_r(str, sep, &saveptr)); str = NULL) {\n\t\twhile (token[0] == ' ' || token[0] == '\\t')\n\t\t\ttoken++;\n\t\ti = strlen(token);\n\t\twhile (i > 0 && (token[i - 1] == ' ' || token[i - 1] == '\\t')) {\n\t\t\ttoken[i - 1] = '\\0';\n\t\t\ti--;\n\t\t}\n\t\tr = lxc_grow_array((void ***)&result, &result_capacity, result_count + 1, 16);\n\t\tif (r < 0)\n\t\t\tgoto error_out;\n\t\tresult[result_count] = strdup(token);\n\t\tif (!result[result_count])\n\t\t\tgoto error_out;\n\t\tresult_count++;\n\t}\n\n\t/* if we allocated too much, reduce it */\n\treturn realloc(result, (result_count + 1) * sizeof(char *));\nerror_out:\n\tsaved_errno = errno;\n\tlxc_free_array((void **)result, free);\n\terrno = saved_errno;\n\treturn NULL;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar **lxc_string_split_and_trim(const char *string, char _sep)\n{\n\tchar *token, *str, *saveptr = NULL;\n\tchar sep[2] = { _sep, '\\0' };\n\tchar **result = NULL;\n\tsize_t result_capacity = 0;\n\tsize_t result_count = 0;\n\tint r, saved_errno;\n\tsize_t i = 0;\n\n\tif (!string)\n\t\treturn calloc(1, sizeof(char *));\n\n\tstr = alloca(strlen(string)+1);\n\tstrcpy(str, string);\n\tfor (; (token = strtok_r(str, sep, &saveptr)); str = NULL) {\n\t\twhile (token[0] == ' ' || token[0] == '\\t')\n\t\t\ttoken++;\n\t\ti = strlen(token);\n\t\twhile (i > 0 && (token[i - 1] == ' ' || token[i - 1] == '\\t')) {\n\t\t\ttoken[i - 1] = '\\0';\n\t\t\ti--;\n\t\t}\n\t\tr = lxc_grow_array((void ***)&result, &result_capacity, result_count + 1, 16);\n\t\tif (r < 0)\n\t\t\tgoto error_out;\n\t\tresult[result_count] = strdup(token);\n\t\tif (!result[result_count])\n\t\t\tgoto error_out;\n\t\tresult_count++;\n\t}\n\n\t/* if we allocated too much, reduce it */\n\treturn realloc(result, (result_count + 1) * sizeof(char *));\nerror_out:\n\tsaved_errno = errno;\n\tlxc_free_array((void **)result, free);\n\terrno = saved_errno;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_mnt",
          "args": [
            "&mnt_table",
            "&mnt_table_size",
            "type"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "add_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "249-264",
          "snippet": "static struct mnts *add_mnt(struct mnts **mnts, unsigned int *num, enum mnttype type)\n{\n\tstruct mnts *m, *n;\n\n\tn = realloc(*mnts, (*num + 1) * sizeof(struct mnts));\n\tif (!n)\n\t\treturn NULL;\n\n\t*mnts = n;\n\tm = *mnts + *num;\n\t(*num)++;\n\n\t*m = (struct mnts) {.mnt_type = type};\n\n\treturn m;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct mnts *add_mnt(struct mnts **mnts, unsigned int *num,\n\t\t\t    enum mnttype type);",
            "static char *set_mnt_entry(struct mnts *m);",
            "static int parse_aufs_mnt(char *mntstring, enum mnttype type);",
            "static int parse_bind_mnt(char *mntstring, enum mnttype type);",
            "static int parse_ovl_mnt(char *mntstring, enum mnttype type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic struct mnts *add_mnt(struct mnts **mnts, unsigned int *num,\n\t\t\t    enum mnttype type);\nstatic char *set_mnt_entry(struct mnts *m);\nstatic int parse_aufs_mnt(char *mntstring, enum mnttype type);\nstatic int parse_bind_mnt(char *mntstring, enum mnttype type);\nstatic int parse_ovl_mnt(char *mntstring, enum mnttype type);\n\nstatic struct mnts *add_mnt(struct mnts **mnts, unsigned int *num, enum mnttype type)\n{\n\tstruct mnts *m, *n;\n\n\tn = realloc(*mnts, (*num + 1) * sizeof(struct mnts));\n\tif (!n)\n\t\treturn NULL;\n\n\t*mnts = n;\n\tm = *mnts + *num;\n\t(*num)++;\n\n\t*m = (struct mnts) {.mnt_type = type};\n\n\treturn m;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic unsigned int mnt_table_size = 0;\nstatic struct mnts *mnt_table = NULL;\nstatic struct mnts *add_mnt(struct mnts **mnts, unsigned int *num,\n\t\t\t    enum mnttype type);\nstatic char *set_mnt_entry(struct mnts *m);\nstatic void free_mnts(void);\nstatic int parse_aufs_mnt(char *mntstring, enum mnttype type);\nstatic int parse_bind_mnt(char *mntstring, enum mnttype type);\nstatic int parse_ovl_mnt(char *mntstring, enum mnttype type);\n\nstatic int parse_ovl_mnt(char *mntstring, enum mnttype type)\n{\n\tint len = 0;\n\tchar **mntarray = NULL;\n\tstruct mnts *m;\n\n\tm = add_mnt(&mnt_table, &mnt_table_size, type);\n\tif (!m)\n\t\tgoto err;\n\n\tmntarray = lxc_string_split(mntstring, ':');\n\tif (!mntarray)\n\t\tgoto err;\n\n\tm->src = construct_path(mntarray[0], true);\n\tif (!m->src)\n\t\tgoto err;\n\n\tlen = lxc_array_len((void **)mntarray);\n\tif (len == 1) /* overlay=src */\n\t\tm->dest = construct_path(mntarray[0], false);\n\telse if (len == 2) /* overlay=src:dest */\n\t\tm->dest = construct_path(mntarray[1], false);\n\telse\n\t\tINFO(\"Excess elements in mount specification\");\n\n\tif (!m->dest)\n\t\tgoto err;\n\n\tlxc_free_array((void **)mntarray, free);\n\treturn 0;\n\nerr:\n\tfree_mnts();\n\tlxc_free_array((void **)mntarray, free);\n\treturn -1;\n}"
  },
  {
    "function_name": "parse_mntsubopts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
    "lines": "748-769",
    "snippet": "static int parse_mntsubopts(char *subopts, char *const *keys, char *mntparameters)\n{\n\twhile (*subopts != '\\0') {\n\t\tswitch (getsubopt(&subopts, keys, &mntparameters)) {\n\t\tcase LXC_MNT_BIND:\n\t\t\tif (parse_bind_mnt(mntparameters, LXC_MNT_BIND) < 0)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tcase LXC_MNT_OVL:\n\t\t\tif (parse_ovl_mnt(mntparameters, LXC_MNT_OVL) < 0)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tcase LXC_MNT_AUFS:\n\t\t\tif (parse_aufs_mnt(mntparameters, LXC_MNT_AUFS) < 0)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <../include/getsubopt.h>",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"arguments.h\"",
      "#include \"confile.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <stdbool.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <stdint.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <getopt.h>",
      "#include <unistd.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *const keys[] = {\n\t[LXC_MNT_BIND] = \"bind\",\n\t[LXC_MNT_AUFS] = \"aufs\",\n\t[LXC_MNT_OVL] = \"overlay\",\n\tNULL\n};",
      "static int parse_mntsubopts(char *subopts, char *const *keys,\n\t\t\t    char *mntparameters);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "parse_aufs_mnt",
          "args": [
            "mntparameters",
            "LXC_MNT_AUFS"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "parse_aufs_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "647-688",
          "snippet": "static int parse_aufs_mnt(char *mntstring, enum mnttype type)\n{\n\tint len = 0;\n\tconst char *xinopath = \"/dev/shm/aufs.xino\";\n\tchar **mntarray = NULL;\n\tstruct mnts *m = NULL;\n\n\tm = add_mnt(&mnt_table, &mnt_table_size, type);\n\tif (!m)\n\t\tgoto err;\n\n\tmntarray = lxc_string_split(mntstring, ':');\n\tif (!mntarray)\n\t\tgoto err;\n\n\tm->src = construct_path(mntarray[0], true);\n\tif (!m->src)\n\t\tgoto err;\n\n\tlen = lxc_array_len((void **)mntarray);\n\tif (len == 1) /* aufs=src */\n\t\tm->dest = construct_path(mntarray[0], false);\n\telse if (len == 2) /* aufs=src:dest */\n\t\tm->dest = construct_path(mntarray[1], false);\n\telse\n\t\tINFO(\"Excess elements in mount specification\");\n\n\tif (!m->dest)\n\t\tgoto err;\n\n\tm->workdir = strdup(xinopath);\n\tif (!m->workdir)\n\t\tgoto err;\n\n\tlxc_free_array((void **)mntarray, free);\n\treturn 0;\n\nerr:\n\tfree_mnts();\n\tlxc_free_array((void **)mntarray, free);\n\treturn -1;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int mnt_table_size = 0;",
            "static struct mnts *mnt_table = NULL;",
            "static struct mnts *add_mnt(struct mnts **mnts, unsigned int *num,\n\t\t\t    enum mnttype type);",
            "static char *set_mnt_entry(struct mnts *m);",
            "static void free_mnts(void);",
            "static int parse_aufs_mnt(char *mntstring, enum mnttype type);",
            "static int parse_bind_mnt(char *mntstring, enum mnttype type);",
            "static int parse_ovl_mnt(char *mntstring, enum mnttype type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic unsigned int mnt_table_size = 0;\nstatic struct mnts *mnt_table = NULL;\nstatic struct mnts *add_mnt(struct mnts **mnts, unsigned int *num,\n\t\t\t    enum mnttype type);\nstatic char *set_mnt_entry(struct mnts *m);\nstatic void free_mnts(void);\nstatic int parse_aufs_mnt(char *mntstring, enum mnttype type);\nstatic int parse_bind_mnt(char *mntstring, enum mnttype type);\nstatic int parse_ovl_mnt(char *mntstring, enum mnttype type);\n\nstatic int parse_aufs_mnt(char *mntstring, enum mnttype type)\n{\n\tint len = 0;\n\tconst char *xinopath = \"/dev/shm/aufs.xino\";\n\tchar **mntarray = NULL;\n\tstruct mnts *m = NULL;\n\n\tm = add_mnt(&mnt_table, &mnt_table_size, type);\n\tif (!m)\n\t\tgoto err;\n\n\tmntarray = lxc_string_split(mntstring, ':');\n\tif (!mntarray)\n\t\tgoto err;\n\n\tm->src = construct_path(mntarray[0], true);\n\tif (!m->src)\n\t\tgoto err;\n\n\tlen = lxc_array_len((void **)mntarray);\n\tif (len == 1) /* aufs=src */\n\t\tm->dest = construct_path(mntarray[0], false);\n\telse if (len == 2) /* aufs=src:dest */\n\t\tm->dest = construct_path(mntarray[1], false);\n\telse\n\t\tINFO(\"Excess elements in mount specification\");\n\n\tif (!m->dest)\n\t\tgoto err;\n\n\tm->workdir = strdup(xinopath);\n\tif (!m->workdir)\n\t\tgoto err;\n\n\tlxc_free_array((void **)mntarray, free);\n\treturn 0;\n\nerr:\n\tfree_mnts();\n\tlxc_free_array((void **)mntarray, free);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_ovl_mnt",
          "args": [
            "mntparameters",
            "LXC_MNT_OVL"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "parse_ovl_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "771-807",
          "snippet": "static int parse_ovl_mnt(char *mntstring, enum mnttype type)\n{\n\tint len = 0;\n\tchar **mntarray = NULL;\n\tstruct mnts *m;\n\n\tm = add_mnt(&mnt_table, &mnt_table_size, type);\n\tif (!m)\n\t\tgoto err;\n\n\tmntarray = lxc_string_split(mntstring, ':');\n\tif (!mntarray)\n\t\tgoto err;\n\n\tm->src = construct_path(mntarray[0], true);\n\tif (!m->src)\n\t\tgoto err;\n\n\tlen = lxc_array_len((void **)mntarray);\n\tif (len == 1) /* overlay=src */\n\t\tm->dest = construct_path(mntarray[0], false);\n\telse if (len == 2) /* overlay=src:dest */\n\t\tm->dest = construct_path(mntarray[1], false);\n\telse\n\t\tINFO(\"Excess elements in mount specification\");\n\n\tif (!m->dest)\n\t\tgoto err;\n\n\tlxc_free_array((void **)mntarray, free);\n\treturn 0;\n\nerr:\n\tfree_mnts();\n\tlxc_free_array((void **)mntarray, free);\n\treturn -1;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int mnt_table_size = 0;",
            "static struct mnts *mnt_table = NULL;",
            "static struct mnts *add_mnt(struct mnts **mnts, unsigned int *num,\n\t\t\t    enum mnttype type);",
            "static char *set_mnt_entry(struct mnts *m);",
            "static void free_mnts(void);",
            "static int parse_aufs_mnt(char *mntstring, enum mnttype type);",
            "static int parse_bind_mnt(char *mntstring, enum mnttype type);",
            "static int parse_ovl_mnt(char *mntstring, enum mnttype type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic unsigned int mnt_table_size = 0;\nstatic struct mnts *mnt_table = NULL;\nstatic struct mnts *add_mnt(struct mnts **mnts, unsigned int *num,\n\t\t\t    enum mnttype type);\nstatic char *set_mnt_entry(struct mnts *m);\nstatic void free_mnts(void);\nstatic int parse_aufs_mnt(char *mntstring, enum mnttype type);\nstatic int parse_bind_mnt(char *mntstring, enum mnttype type);\nstatic int parse_ovl_mnt(char *mntstring, enum mnttype type);\n\nstatic int parse_ovl_mnt(char *mntstring, enum mnttype type)\n{\n\tint len = 0;\n\tchar **mntarray = NULL;\n\tstruct mnts *m;\n\n\tm = add_mnt(&mnt_table, &mnt_table_size, type);\n\tif (!m)\n\t\tgoto err;\n\n\tmntarray = lxc_string_split(mntstring, ':');\n\tif (!mntarray)\n\t\tgoto err;\n\n\tm->src = construct_path(mntarray[0], true);\n\tif (!m->src)\n\t\tgoto err;\n\n\tlen = lxc_array_len((void **)mntarray);\n\tif (len == 1) /* overlay=src */\n\t\tm->dest = construct_path(mntarray[0], false);\n\telse if (len == 2) /* overlay=src:dest */\n\t\tm->dest = construct_path(mntarray[1], false);\n\telse\n\t\tINFO(\"Excess elements in mount specification\");\n\n\tif (!m->dest)\n\t\tgoto err;\n\n\tlxc_free_array((void **)mntarray, free);\n\treturn 0;\n\nerr:\n\tfree_mnts();\n\tlxc_free_array((void **)mntarray, free);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_bind_mnt",
          "args": [
            "mntparameters",
            "LXC_MNT_BIND"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "parse_bind_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "690-746",
          "snippet": "static int parse_bind_mnt(char *mntstring, enum mnttype type)\n{\n\tint len = 0;\n\tchar **mntarray = NULL;\n\tstruct mnts *m = NULL;\n\n\tm = add_mnt(&mnt_table, &mnt_table_size, type);\n\tif (!m)\n\t\tgoto err;\n\n\tmntarray = lxc_string_split(mntstring, ':');\n\tif (!mntarray)\n\t\tgoto err;\n\n\tm->src = construct_path(mntarray[0], true);\n\tif (!m->src)\n\t\tgoto err;\n\n\tlen = lxc_array_len((void **)mntarray);\n\tif (len == 1) { /* bind=src */\n\t\tm->dest = construct_path(mntarray[0], false);\n\t} else if (len == 2) { /* bind=src:option or bind=src:dest */\n\t\tif (strncmp(mntarray[1], \"rw\", strlen(mntarray[1])) == 0)\n\t\t\tm->options = strdup(\"rw\");\n\n\t\tif (strncmp(mntarray[1], \"ro\", strlen(mntarray[1])) == 0)\n\t\t\tm->options = strdup(\"ro\");\n\n\t\tif (m->options)\n\t\t\tm->dest = construct_path(mntarray[0], false);\n\t\telse\n\t\t\tm->dest = construct_path(mntarray[1], false);\n\t} else if (len == 3) { /* bind=src:dest:option */\n\t\t\tm->dest = construct_path(mntarray[1], false);\n\t\t\tm->options = strdup(mntarray[2]);\n\t} else {\n\t\tINFO(\"Excess elements in mount specification\");\n\t}\n\n\tif (!m->dest)\n\t\tgoto err;\n\n\tif (!m->options)\n\t\tm->options = strdup(\"rw\");\n\n\tif (!m->options || (strncmp(m->options, \"rw\", strlen(m->options)) &&\n\t\t\t    strncmp(m->options, \"ro\", strlen(m->options))))\n\t\tgoto err;\n\n\tlxc_free_array((void **)mntarray, free);\n\treturn 0;\n\nerr:\n\tfree_mnts();\n\tlxc_free_array((void **)mntarray, free);\n\treturn -1;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int mnt_table_size = 0;",
            "static struct mnts *mnt_table = NULL;",
            "static struct mnts *add_mnt(struct mnts **mnts, unsigned int *num,\n\t\t\t    enum mnttype type);",
            "static char *set_mnt_entry(struct mnts *m);",
            "static void free_mnts(void);",
            "static int parse_aufs_mnt(char *mntstring, enum mnttype type);",
            "static int parse_bind_mnt(char *mntstring, enum mnttype type);",
            "static int parse_ovl_mnt(char *mntstring, enum mnttype type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic unsigned int mnt_table_size = 0;\nstatic struct mnts *mnt_table = NULL;\nstatic struct mnts *add_mnt(struct mnts **mnts, unsigned int *num,\n\t\t\t    enum mnttype type);\nstatic char *set_mnt_entry(struct mnts *m);\nstatic void free_mnts(void);\nstatic int parse_aufs_mnt(char *mntstring, enum mnttype type);\nstatic int parse_bind_mnt(char *mntstring, enum mnttype type);\nstatic int parse_ovl_mnt(char *mntstring, enum mnttype type);\n\nstatic int parse_bind_mnt(char *mntstring, enum mnttype type)\n{\n\tint len = 0;\n\tchar **mntarray = NULL;\n\tstruct mnts *m = NULL;\n\n\tm = add_mnt(&mnt_table, &mnt_table_size, type);\n\tif (!m)\n\t\tgoto err;\n\n\tmntarray = lxc_string_split(mntstring, ':');\n\tif (!mntarray)\n\t\tgoto err;\n\n\tm->src = construct_path(mntarray[0], true);\n\tif (!m->src)\n\t\tgoto err;\n\n\tlen = lxc_array_len((void **)mntarray);\n\tif (len == 1) { /* bind=src */\n\t\tm->dest = construct_path(mntarray[0], false);\n\t} else if (len == 2) { /* bind=src:option or bind=src:dest */\n\t\tif (strncmp(mntarray[1], \"rw\", strlen(mntarray[1])) == 0)\n\t\t\tm->options = strdup(\"rw\");\n\n\t\tif (strncmp(mntarray[1], \"ro\", strlen(mntarray[1])) == 0)\n\t\t\tm->options = strdup(\"ro\");\n\n\t\tif (m->options)\n\t\t\tm->dest = construct_path(mntarray[0], false);\n\t\telse\n\t\t\tm->dest = construct_path(mntarray[1], false);\n\t} else if (len == 3) { /* bind=src:dest:option */\n\t\t\tm->dest = construct_path(mntarray[1], false);\n\t\t\tm->options = strdup(mntarray[2]);\n\t} else {\n\t\tINFO(\"Excess elements in mount specification\");\n\t}\n\n\tif (!m->dest)\n\t\tgoto err;\n\n\tif (!m->options)\n\t\tm->options = strdup(\"rw\");\n\n\tif (!m->options || (strncmp(m->options, \"rw\", strlen(m->options)) &&\n\t\t\t    strncmp(m->options, \"ro\", strlen(m->options))))\n\t\tgoto err;\n\n\tlxc_free_array((void **)mntarray, free);\n\treturn 0;\n\nerr:\n\tfree_mnts();\n\tlxc_free_array((void **)mntarray, free);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getsubopt",
          "args": [
            "&subopts",
            "keys",
            "&mntparameters"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "getsubopt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "48-89",
          "snippet": "int\ngetsubopt (char **optionp, char *const *tokens, char **valuep)\n{\n  char *endp, *vstart;\n  int cnt;\n\n  if (**optionp == '\\0')\n    return -1;\n\n  /* Find end of next token.  */\n  endp = strchrnul (*optionp, ',');\n\n  /* Find start of value.  */\n  vstart = memchr (*optionp, '=', endp - *optionp);\n  if (vstart == NULL)\n    vstart = endp;\n\n  /* Try to match the characters between *OPTIONP and VSTART against\n     one of the TOKENS.  */\n  for (cnt = 0; tokens[cnt] != NULL; ++cnt)\n    if (strncmp (*optionp, tokens[cnt], vstart - *optionp) == 0\n    && tokens[cnt][vstart - *optionp] == '\\0')\n      {\n    /* We found the current option in TOKENS.  */\n    *valuep = vstart != endp ? vstart + 1 : NULL;\n\n    if (*endp != '\\0')\n      *endp++ = '\\0';\n    *optionp = endp;\n\n    return cnt;\n      }\n\n  /* The current suboption does not match any option.  */\n  *valuep = *optionp;\n\n  if (*endp != '\\0')\n    *endp++ = '\\0';\n  *optionp = endp;\n\n  return -1;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nint\ngetsubopt (char **optionp, char *const *tokens, char **valuep)\n{\n  char *endp, *vstart;\n  int cnt;\n\n  if (**optionp == '\\0')\n    return -1;\n\n  /* Find end of next token.  */\n  endp = strchrnul (*optionp, ',');\n\n  /* Find start of value.  */\n  vstart = memchr (*optionp, '=', endp - *optionp);\n  if (vstart == NULL)\n    vstart = endp;\n\n  /* Try to match the characters between *OPTIONP and VSTART against\n     one of the TOKENS.  */\n  for (cnt = 0; tokens[cnt] != NULL; ++cnt)\n    if (strncmp (*optionp, tokens[cnt], vstart - *optionp) == 0\n    && tokens[cnt][vstart - *optionp] == '\\0')\n      {\n    /* We found the current option in TOKENS.  */\n    *valuep = vstart != endp ? vstart + 1 : NULL;\n\n    if (*endp != '\\0')\n      *endp++ = '\\0';\n    *optionp = endp;\n\n    return cnt;\n      }\n\n  /* The current suboption does not match any option.  */\n  *valuep = *optionp;\n\n  if (*endp != '\\0')\n    *endp++ = '\\0';\n  *optionp = endp;\n\n  return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic char *const keys[] = {\n\t[LXC_MNT_BIND] = \"bind\",\n\t[LXC_MNT_AUFS] = \"aufs\",\n\t[LXC_MNT_OVL] = \"overlay\",\n\tNULL\n};\nstatic int parse_mntsubopts(char *subopts, char *const *keys,\n\t\t\t    char *mntparameters);\n\nstatic int parse_mntsubopts(char *subopts, char *const *keys, char *mntparameters)\n{\n\twhile (*subopts != '\\0') {\n\t\tswitch (getsubopt(&subopts, keys, &mntparameters)) {\n\t\tcase LXC_MNT_BIND:\n\t\t\tif (parse_bind_mnt(mntparameters, LXC_MNT_BIND) < 0)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tcase LXC_MNT_OVL:\n\t\t\tif (parse_ovl_mnt(mntparameters, LXC_MNT_OVL) < 0)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tcase LXC_MNT_AUFS:\n\t\t\tif (parse_aufs_mnt(mntparameters, LXC_MNT_AUFS) < 0)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "parse_bind_mnt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
    "lines": "690-746",
    "snippet": "static int parse_bind_mnt(char *mntstring, enum mnttype type)\n{\n\tint len = 0;\n\tchar **mntarray = NULL;\n\tstruct mnts *m = NULL;\n\n\tm = add_mnt(&mnt_table, &mnt_table_size, type);\n\tif (!m)\n\t\tgoto err;\n\n\tmntarray = lxc_string_split(mntstring, ':');\n\tif (!mntarray)\n\t\tgoto err;\n\n\tm->src = construct_path(mntarray[0], true);\n\tif (!m->src)\n\t\tgoto err;\n\n\tlen = lxc_array_len((void **)mntarray);\n\tif (len == 1) { /* bind=src */\n\t\tm->dest = construct_path(mntarray[0], false);\n\t} else if (len == 2) { /* bind=src:option or bind=src:dest */\n\t\tif (strncmp(mntarray[1], \"rw\", strlen(mntarray[1])) == 0)\n\t\t\tm->options = strdup(\"rw\");\n\n\t\tif (strncmp(mntarray[1], \"ro\", strlen(mntarray[1])) == 0)\n\t\t\tm->options = strdup(\"ro\");\n\n\t\tif (m->options)\n\t\t\tm->dest = construct_path(mntarray[0], false);\n\t\telse\n\t\t\tm->dest = construct_path(mntarray[1], false);\n\t} else if (len == 3) { /* bind=src:dest:option */\n\t\t\tm->dest = construct_path(mntarray[1], false);\n\t\t\tm->options = strdup(mntarray[2]);\n\t} else {\n\t\tINFO(\"Excess elements in mount specification\");\n\t}\n\n\tif (!m->dest)\n\t\tgoto err;\n\n\tif (!m->options)\n\t\tm->options = strdup(\"rw\");\n\n\tif (!m->options || (strncmp(m->options, \"rw\", strlen(m->options)) &&\n\t\t\t    strncmp(m->options, \"ro\", strlen(m->options))))\n\t\tgoto err;\n\n\tlxc_free_array((void **)mntarray, free);\n\treturn 0;\n\nerr:\n\tfree_mnts();\n\tlxc_free_array((void **)mntarray, free);\n\treturn -1;\n}",
    "includes": [
      "#include <../include/getsubopt.h>",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"arguments.h\"",
      "#include \"confile.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <stdbool.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <stdint.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <getopt.h>",
      "#include <unistd.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int mnt_table_size = 0;",
      "static struct mnts *mnt_table = NULL;",
      "static struct mnts *add_mnt(struct mnts **mnts, unsigned int *num,\n\t\t\t    enum mnttype type);",
      "static char *set_mnt_entry(struct mnts *m);",
      "static void free_mnts(void);",
      "static int parse_aufs_mnt(char *mntstring, enum mnttype type);",
      "static int parse_bind_mnt(char *mntstring, enum mnttype type);",
      "static int parse_ovl_mnt(char *mntstring, enum mnttype type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_free_array",
          "args": [
            "(void **)mntarray",
            "free"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_free_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "886-892",
          "snippet": "void lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_mnts",
          "args": [],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "free_mnts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "539-554",
          "snippet": "static void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int mnt_table_size = 0;",
            "static struct mnts *mnt_table = NULL;",
            "static void free_mnts(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic unsigned int mnt_table_size = 0;\nstatic struct mnts *mnt_table = NULL;\nstatic void free_mnts(void);\n\nstatic void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "m->options",
            "\"ro\"",
            "strlen(m->options)"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "m->options"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "m->options",
            "\"rw\"",
            "strlen(m->options)"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "m->options"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"rw\""
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Excess elements in mount specification\""
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "mntarray[2]"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "construct_path",
          "args": [
            "mntarray[1]",
            "false"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "construct_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "303-316",
          "snippet": "static char *construct_path(char *path, bool as_prefix)\n{\n\tchar **components = NULL;\n\tchar *cleanpath = NULL;\n\n\tcomponents = lxc_normalize_path(path);\n\tif (!components)\n\t\treturn NULL;\n\n\tcleanpath = lxc_string_join(\"/\", (const char **)components, as_prefix);\n\tlxc_free_array((void **)components, free);\n\n\treturn cleanpath;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *construct_path(char *path, bool as_prefix);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic char *construct_path(char *path, bool as_prefix);\n\nstatic char *construct_path(char *path, bool as_prefix)\n{\n\tchar **components = NULL;\n\tchar *cleanpath = NULL;\n\n\tcomponents = lxc_normalize_path(path);\n\tif (!components)\n\t\treturn NULL;\n\n\tcleanpath = lxc_string_join(\"/\", (const char **)components, as_prefix);\n\tlxc_free_array((void **)components, free);\n\n\treturn cleanpath;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"ro\""
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "mntarray[1]",
            "\"ro\"",
            "strlen(mntarray[1])"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "mntarray[1]"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"rw\""
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "mntarray[1]",
            "\"rw\"",
            "strlen(mntarray[1])"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "mntarray[1]"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_array_len",
          "args": [
            "(void **)mntarray"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_array_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "923-932",
          "snippet": "size_t lxc_array_len(void **array)\n{\n\tvoid **p;\n\tsize_t result = 0;\n\n\tfor (p = array; p && *p; p++)\n\t\tresult++;\n\n\treturn result;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nsize_t lxc_array_len(void **array)\n{\n\tvoid **p;\n\tsize_t result = 0;\n\n\tfor (p = array; p && *p; p++)\n\t\tresult++;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_string_split",
          "args": [
            "mntstring",
            "':'"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_split_and_trim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "845-884",
          "snippet": "char **lxc_string_split_and_trim(const char *string, char _sep)\n{\n\tchar *token, *str, *saveptr = NULL;\n\tchar sep[2] = { _sep, '\\0' };\n\tchar **result = NULL;\n\tsize_t result_capacity = 0;\n\tsize_t result_count = 0;\n\tint r, saved_errno;\n\tsize_t i = 0;\n\n\tif (!string)\n\t\treturn calloc(1, sizeof(char *));\n\n\tstr = alloca(strlen(string)+1);\n\tstrcpy(str, string);\n\tfor (; (token = strtok_r(str, sep, &saveptr)); str = NULL) {\n\t\twhile (token[0] == ' ' || token[0] == '\\t')\n\t\t\ttoken++;\n\t\ti = strlen(token);\n\t\twhile (i > 0 && (token[i - 1] == ' ' || token[i - 1] == '\\t')) {\n\t\t\ttoken[i - 1] = '\\0';\n\t\t\ti--;\n\t\t}\n\t\tr = lxc_grow_array((void ***)&result, &result_capacity, result_count + 1, 16);\n\t\tif (r < 0)\n\t\t\tgoto error_out;\n\t\tresult[result_count] = strdup(token);\n\t\tif (!result[result_count])\n\t\t\tgoto error_out;\n\t\tresult_count++;\n\t}\n\n\t/* if we allocated too much, reduce it */\n\treturn realloc(result, (result_count + 1) * sizeof(char *));\nerror_out:\n\tsaved_errno = errno;\n\tlxc_free_array((void **)result, free);\n\terrno = saved_errno;\n\treturn NULL;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar **lxc_string_split_and_trim(const char *string, char _sep)\n{\n\tchar *token, *str, *saveptr = NULL;\n\tchar sep[2] = { _sep, '\\0' };\n\tchar **result = NULL;\n\tsize_t result_capacity = 0;\n\tsize_t result_count = 0;\n\tint r, saved_errno;\n\tsize_t i = 0;\n\n\tif (!string)\n\t\treturn calloc(1, sizeof(char *));\n\n\tstr = alloca(strlen(string)+1);\n\tstrcpy(str, string);\n\tfor (; (token = strtok_r(str, sep, &saveptr)); str = NULL) {\n\t\twhile (token[0] == ' ' || token[0] == '\\t')\n\t\t\ttoken++;\n\t\ti = strlen(token);\n\t\twhile (i > 0 && (token[i - 1] == ' ' || token[i - 1] == '\\t')) {\n\t\t\ttoken[i - 1] = '\\0';\n\t\t\ti--;\n\t\t}\n\t\tr = lxc_grow_array((void ***)&result, &result_capacity, result_count + 1, 16);\n\t\tif (r < 0)\n\t\t\tgoto error_out;\n\t\tresult[result_count] = strdup(token);\n\t\tif (!result[result_count])\n\t\t\tgoto error_out;\n\t\tresult_count++;\n\t}\n\n\t/* if we allocated too much, reduce it */\n\treturn realloc(result, (result_count + 1) * sizeof(char *));\nerror_out:\n\tsaved_errno = errno;\n\tlxc_free_array((void **)result, free);\n\terrno = saved_errno;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_mnt",
          "args": [
            "&mnt_table",
            "&mnt_table_size",
            "type"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "add_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "249-264",
          "snippet": "static struct mnts *add_mnt(struct mnts **mnts, unsigned int *num, enum mnttype type)\n{\n\tstruct mnts *m, *n;\n\n\tn = realloc(*mnts, (*num + 1) * sizeof(struct mnts));\n\tif (!n)\n\t\treturn NULL;\n\n\t*mnts = n;\n\tm = *mnts + *num;\n\t(*num)++;\n\n\t*m = (struct mnts) {.mnt_type = type};\n\n\treturn m;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct mnts *add_mnt(struct mnts **mnts, unsigned int *num,\n\t\t\t    enum mnttype type);",
            "static char *set_mnt_entry(struct mnts *m);",
            "static int parse_aufs_mnt(char *mntstring, enum mnttype type);",
            "static int parse_bind_mnt(char *mntstring, enum mnttype type);",
            "static int parse_ovl_mnt(char *mntstring, enum mnttype type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic struct mnts *add_mnt(struct mnts **mnts, unsigned int *num,\n\t\t\t    enum mnttype type);\nstatic char *set_mnt_entry(struct mnts *m);\nstatic int parse_aufs_mnt(char *mntstring, enum mnttype type);\nstatic int parse_bind_mnt(char *mntstring, enum mnttype type);\nstatic int parse_ovl_mnt(char *mntstring, enum mnttype type);\n\nstatic struct mnts *add_mnt(struct mnts **mnts, unsigned int *num, enum mnttype type)\n{\n\tstruct mnts *m, *n;\n\n\tn = realloc(*mnts, (*num + 1) * sizeof(struct mnts));\n\tif (!n)\n\t\treturn NULL;\n\n\t*mnts = n;\n\tm = *mnts + *num;\n\t(*num)++;\n\n\t*m = (struct mnts) {.mnt_type = type};\n\n\treturn m;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic unsigned int mnt_table_size = 0;\nstatic struct mnts *mnt_table = NULL;\nstatic struct mnts *add_mnt(struct mnts **mnts, unsigned int *num,\n\t\t\t    enum mnttype type);\nstatic char *set_mnt_entry(struct mnts *m);\nstatic void free_mnts(void);\nstatic int parse_aufs_mnt(char *mntstring, enum mnttype type);\nstatic int parse_bind_mnt(char *mntstring, enum mnttype type);\nstatic int parse_ovl_mnt(char *mntstring, enum mnttype type);\n\nstatic int parse_bind_mnt(char *mntstring, enum mnttype type)\n{\n\tint len = 0;\n\tchar **mntarray = NULL;\n\tstruct mnts *m = NULL;\n\n\tm = add_mnt(&mnt_table, &mnt_table_size, type);\n\tif (!m)\n\t\tgoto err;\n\n\tmntarray = lxc_string_split(mntstring, ':');\n\tif (!mntarray)\n\t\tgoto err;\n\n\tm->src = construct_path(mntarray[0], true);\n\tif (!m->src)\n\t\tgoto err;\n\n\tlen = lxc_array_len((void **)mntarray);\n\tif (len == 1) { /* bind=src */\n\t\tm->dest = construct_path(mntarray[0], false);\n\t} else if (len == 2) { /* bind=src:option or bind=src:dest */\n\t\tif (strncmp(mntarray[1], \"rw\", strlen(mntarray[1])) == 0)\n\t\t\tm->options = strdup(\"rw\");\n\n\t\tif (strncmp(mntarray[1], \"ro\", strlen(mntarray[1])) == 0)\n\t\t\tm->options = strdup(\"ro\");\n\n\t\tif (m->options)\n\t\t\tm->dest = construct_path(mntarray[0], false);\n\t\telse\n\t\t\tm->dest = construct_path(mntarray[1], false);\n\t} else if (len == 3) { /* bind=src:dest:option */\n\t\t\tm->dest = construct_path(mntarray[1], false);\n\t\t\tm->options = strdup(mntarray[2]);\n\t} else {\n\t\tINFO(\"Excess elements in mount specification\");\n\t}\n\n\tif (!m->dest)\n\t\tgoto err;\n\n\tif (!m->options)\n\t\tm->options = strdup(\"rw\");\n\n\tif (!m->options || (strncmp(m->options, \"rw\", strlen(m->options)) &&\n\t\t\t    strncmp(m->options, \"ro\", strlen(m->options))))\n\t\tgoto err;\n\n\tlxc_free_array((void **)mntarray, free);\n\treturn 0;\n\nerr:\n\tfree_mnts();\n\tlxc_free_array((void **)mntarray, free);\n\treturn -1;\n}"
  },
  {
    "function_name": "parse_aufs_mnt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
    "lines": "647-688",
    "snippet": "static int parse_aufs_mnt(char *mntstring, enum mnttype type)\n{\n\tint len = 0;\n\tconst char *xinopath = \"/dev/shm/aufs.xino\";\n\tchar **mntarray = NULL;\n\tstruct mnts *m = NULL;\n\n\tm = add_mnt(&mnt_table, &mnt_table_size, type);\n\tif (!m)\n\t\tgoto err;\n\n\tmntarray = lxc_string_split(mntstring, ':');\n\tif (!mntarray)\n\t\tgoto err;\n\n\tm->src = construct_path(mntarray[0], true);\n\tif (!m->src)\n\t\tgoto err;\n\n\tlen = lxc_array_len((void **)mntarray);\n\tif (len == 1) /* aufs=src */\n\t\tm->dest = construct_path(mntarray[0], false);\n\telse if (len == 2) /* aufs=src:dest */\n\t\tm->dest = construct_path(mntarray[1], false);\n\telse\n\t\tINFO(\"Excess elements in mount specification\");\n\n\tif (!m->dest)\n\t\tgoto err;\n\n\tm->workdir = strdup(xinopath);\n\tif (!m->workdir)\n\t\tgoto err;\n\n\tlxc_free_array((void **)mntarray, free);\n\treturn 0;\n\nerr:\n\tfree_mnts();\n\tlxc_free_array((void **)mntarray, free);\n\treturn -1;\n}",
    "includes": [
      "#include <../include/getsubopt.h>",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"arguments.h\"",
      "#include \"confile.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <stdbool.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <stdint.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <getopt.h>",
      "#include <unistd.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int mnt_table_size = 0;",
      "static struct mnts *mnt_table = NULL;",
      "static struct mnts *add_mnt(struct mnts **mnts, unsigned int *num,\n\t\t\t    enum mnttype type);",
      "static char *set_mnt_entry(struct mnts *m);",
      "static void free_mnts(void);",
      "static int parse_aufs_mnt(char *mntstring, enum mnttype type);",
      "static int parse_bind_mnt(char *mntstring, enum mnttype type);",
      "static int parse_ovl_mnt(char *mntstring, enum mnttype type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_free_array",
          "args": [
            "(void **)mntarray",
            "free"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_free_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "886-892",
          "snippet": "void lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_mnts",
          "args": [],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "free_mnts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "539-554",
          "snippet": "static void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int mnt_table_size = 0;",
            "static struct mnts *mnt_table = NULL;",
            "static void free_mnts(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic unsigned int mnt_table_size = 0;\nstatic struct mnts *mnt_table = NULL;\nstatic void free_mnts(void);\n\nstatic void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "xinopath"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Excess elements in mount specification\""
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "construct_path",
          "args": [
            "mntarray[1]",
            "false"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "construct_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "303-316",
          "snippet": "static char *construct_path(char *path, bool as_prefix)\n{\n\tchar **components = NULL;\n\tchar *cleanpath = NULL;\n\n\tcomponents = lxc_normalize_path(path);\n\tif (!components)\n\t\treturn NULL;\n\n\tcleanpath = lxc_string_join(\"/\", (const char **)components, as_prefix);\n\tlxc_free_array((void **)components, free);\n\n\treturn cleanpath;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *construct_path(char *path, bool as_prefix);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic char *construct_path(char *path, bool as_prefix);\n\nstatic char *construct_path(char *path, bool as_prefix)\n{\n\tchar **components = NULL;\n\tchar *cleanpath = NULL;\n\n\tcomponents = lxc_normalize_path(path);\n\tif (!components)\n\t\treturn NULL;\n\n\tcleanpath = lxc_string_join(\"/\", (const char **)components, as_prefix);\n\tlxc_free_array((void **)components, free);\n\n\treturn cleanpath;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_array_len",
          "args": [
            "(void **)mntarray"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_array_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "923-932",
          "snippet": "size_t lxc_array_len(void **array)\n{\n\tvoid **p;\n\tsize_t result = 0;\n\n\tfor (p = array; p && *p; p++)\n\t\tresult++;\n\n\treturn result;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nsize_t lxc_array_len(void **array)\n{\n\tvoid **p;\n\tsize_t result = 0;\n\n\tfor (p = array; p && *p; p++)\n\t\tresult++;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_string_split",
          "args": [
            "mntstring",
            "':'"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_split_and_trim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "845-884",
          "snippet": "char **lxc_string_split_and_trim(const char *string, char _sep)\n{\n\tchar *token, *str, *saveptr = NULL;\n\tchar sep[2] = { _sep, '\\0' };\n\tchar **result = NULL;\n\tsize_t result_capacity = 0;\n\tsize_t result_count = 0;\n\tint r, saved_errno;\n\tsize_t i = 0;\n\n\tif (!string)\n\t\treturn calloc(1, sizeof(char *));\n\n\tstr = alloca(strlen(string)+1);\n\tstrcpy(str, string);\n\tfor (; (token = strtok_r(str, sep, &saveptr)); str = NULL) {\n\t\twhile (token[0] == ' ' || token[0] == '\\t')\n\t\t\ttoken++;\n\t\ti = strlen(token);\n\t\twhile (i > 0 && (token[i - 1] == ' ' || token[i - 1] == '\\t')) {\n\t\t\ttoken[i - 1] = '\\0';\n\t\t\ti--;\n\t\t}\n\t\tr = lxc_grow_array((void ***)&result, &result_capacity, result_count + 1, 16);\n\t\tif (r < 0)\n\t\t\tgoto error_out;\n\t\tresult[result_count] = strdup(token);\n\t\tif (!result[result_count])\n\t\t\tgoto error_out;\n\t\tresult_count++;\n\t}\n\n\t/* if we allocated too much, reduce it */\n\treturn realloc(result, (result_count + 1) * sizeof(char *));\nerror_out:\n\tsaved_errno = errno;\n\tlxc_free_array((void **)result, free);\n\terrno = saved_errno;\n\treturn NULL;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar **lxc_string_split_and_trim(const char *string, char _sep)\n{\n\tchar *token, *str, *saveptr = NULL;\n\tchar sep[2] = { _sep, '\\0' };\n\tchar **result = NULL;\n\tsize_t result_capacity = 0;\n\tsize_t result_count = 0;\n\tint r, saved_errno;\n\tsize_t i = 0;\n\n\tif (!string)\n\t\treturn calloc(1, sizeof(char *));\n\n\tstr = alloca(strlen(string)+1);\n\tstrcpy(str, string);\n\tfor (; (token = strtok_r(str, sep, &saveptr)); str = NULL) {\n\t\twhile (token[0] == ' ' || token[0] == '\\t')\n\t\t\ttoken++;\n\t\ti = strlen(token);\n\t\twhile (i > 0 && (token[i - 1] == ' ' || token[i - 1] == '\\t')) {\n\t\t\ttoken[i - 1] = '\\0';\n\t\t\ti--;\n\t\t}\n\t\tr = lxc_grow_array((void ***)&result, &result_capacity, result_count + 1, 16);\n\t\tif (r < 0)\n\t\t\tgoto error_out;\n\t\tresult[result_count] = strdup(token);\n\t\tif (!result[result_count])\n\t\t\tgoto error_out;\n\t\tresult_count++;\n\t}\n\n\t/* if we allocated too much, reduce it */\n\treturn realloc(result, (result_count + 1) * sizeof(char *));\nerror_out:\n\tsaved_errno = errno;\n\tlxc_free_array((void **)result, free);\n\terrno = saved_errno;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_mnt",
          "args": [
            "&mnt_table",
            "&mnt_table_size",
            "type"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "add_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "249-264",
          "snippet": "static struct mnts *add_mnt(struct mnts **mnts, unsigned int *num, enum mnttype type)\n{\n\tstruct mnts *m, *n;\n\n\tn = realloc(*mnts, (*num + 1) * sizeof(struct mnts));\n\tif (!n)\n\t\treturn NULL;\n\n\t*mnts = n;\n\tm = *mnts + *num;\n\t(*num)++;\n\n\t*m = (struct mnts) {.mnt_type = type};\n\n\treturn m;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct mnts *add_mnt(struct mnts **mnts, unsigned int *num,\n\t\t\t    enum mnttype type);",
            "static char *set_mnt_entry(struct mnts *m);",
            "static int parse_aufs_mnt(char *mntstring, enum mnttype type);",
            "static int parse_bind_mnt(char *mntstring, enum mnttype type);",
            "static int parse_ovl_mnt(char *mntstring, enum mnttype type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic struct mnts *add_mnt(struct mnts **mnts, unsigned int *num,\n\t\t\t    enum mnttype type);\nstatic char *set_mnt_entry(struct mnts *m);\nstatic int parse_aufs_mnt(char *mntstring, enum mnttype type);\nstatic int parse_bind_mnt(char *mntstring, enum mnttype type);\nstatic int parse_ovl_mnt(char *mntstring, enum mnttype type);\n\nstatic struct mnts *add_mnt(struct mnts **mnts, unsigned int *num, enum mnttype type)\n{\n\tstruct mnts *m, *n;\n\n\tn = realloc(*mnts, (*num + 1) * sizeof(struct mnts));\n\tif (!n)\n\t\treturn NULL;\n\n\t*mnts = n;\n\tm = *mnts + *num;\n\t(*num)++;\n\n\t*m = (struct mnts) {.mnt_type = type};\n\n\treturn m;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic unsigned int mnt_table_size = 0;\nstatic struct mnts *mnt_table = NULL;\nstatic struct mnts *add_mnt(struct mnts **mnts, unsigned int *num,\n\t\t\t    enum mnttype type);\nstatic char *set_mnt_entry(struct mnts *m);\nstatic void free_mnts(void);\nstatic int parse_aufs_mnt(char *mntstring, enum mnttype type);\nstatic int parse_bind_mnt(char *mntstring, enum mnttype type);\nstatic int parse_ovl_mnt(char *mntstring, enum mnttype type);\n\nstatic int parse_aufs_mnt(char *mntstring, enum mnttype type)\n{\n\tint len = 0;\n\tconst char *xinopath = \"/dev/shm/aufs.xino\";\n\tchar **mntarray = NULL;\n\tstruct mnts *m = NULL;\n\n\tm = add_mnt(&mnt_table, &mnt_table_size, type);\n\tif (!m)\n\t\tgoto err;\n\n\tmntarray = lxc_string_split(mntstring, ':');\n\tif (!mntarray)\n\t\tgoto err;\n\n\tm->src = construct_path(mntarray[0], true);\n\tif (!m->src)\n\t\tgoto err;\n\n\tlen = lxc_array_len((void **)mntarray);\n\tif (len == 1) /* aufs=src */\n\t\tm->dest = construct_path(mntarray[0], false);\n\telse if (len == 2) /* aufs=src:dest */\n\t\tm->dest = construct_path(mntarray[1], false);\n\telse\n\t\tINFO(\"Excess elements in mount specification\");\n\n\tif (!m->dest)\n\t\tgoto err;\n\n\tm->workdir = strdup(xinopath);\n\tif (!m->workdir)\n\t\tgoto err;\n\n\tlxc_free_array((void **)mntarray, free);\n\treturn 0;\n\nerr:\n\tfree_mnts();\n\tlxc_free_array((void **)mntarray, free);\n\treturn -1;\n}"
  },
  {
    "function_name": "my_parser",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
    "lines": "591-645",
    "snippet": "static int my_parser(struct lxc_arguments *args, int c, char *arg)\n{\n\tchar *subopts = NULL;\n\tchar *mntparameters = NULL;\n\tswitch (c) {\n\tcase 'N':\n\t\targs->newname = arg;\n\t\tbreak;\n\tcase 'p':\n\t\targs->newpath = arg;\n\t\tbreak;\n\tcase 'R':\n\t\targs->task = RENAME;\n\t\tbreak;\n\tcase 's':\n\t\targs->task = SNAP;\n\t\tbreak;\n\tcase 'F':\n\t\targs->daemonize = 0;\n\t\tbreak;\n\tcase 'd':\n\t\targs->daemonize = 1;\n\t\tbreak;\n\tcase 'e':\n\t\targs->task = DESTROY;\n\t\tbreak;\n\tcase 'm':\n\t\tsubopts = optarg;\n\t\tif (parse_mntsubopts(subopts, keys, mntparameters) < 0)\n\t\t\treturn -1;\n\t\tbreak;\n\tcase 'B':\n\t\tif (strcmp(arg, \"overlay\") == 0)\n\t\t\targ = \"overlayfs\";\n\t\targs->bdevtype = arg;\n\t\tbreak;\n\tcase 't':\n\t\targs->tmpfs = true;\n\t\tbreak;\n\tcase 'L':\n\t\targs->fssize = get_fssize(optarg);\n\t\tbreak;\n\tcase 'D':\n\t\targs->keepdata = 1;\n\t\tbreak;\n\tcase 'K':\n\t\targs->keepname = 1;\n\t\tbreak;\n\tcase 'M':\n\t\targs->keepmac = 1;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <../include/getsubopt.h>",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"arguments.h\"",
      "#include \"confile.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <stdbool.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <stdint.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <getopt.h>",
      "#include <unistd.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int my_parser(struct lxc_arguments *args, int c, char *arg);",
      "static char *const keys[] = {\n\t[LXC_MNT_BIND] = \"bind\",\n\t[LXC_MNT_AUFS] = \"aufs\",\n\t[LXC_MNT_OVL] = \"overlay\",\n\tNULL\n};",
      "static int mk_rand_ovl_dirs(struct mnts *mnts, unsigned int num,\n\t\t\t    struct lxc_arguments *arg);",
      "static char *set_mnt_entry(struct mnts *m);",
      "static int do_clone(struct lxc_container *c, char *newname, char *newpath,\n\t\t    int flags, char *bdevtype, uint64_t fssize, enum task task,\n\t\t    char **args);",
      "static int do_clone_rename(struct lxc_container *c, char *newname);",
      "static int do_clone_task(struct lxc_container *c, enum task task, int flags,\n\t\t\t char **args);",
      "static uint64_t get_fssize(char *s);",
      "static char *mount_tmpfs(const char *oldname, const char *newname,\n\t\t\t const char *path, struct lxc_arguments *arg);",
      "static int parse_mntsubopts(char *subopts, char *const *keys,\n\t\t\t    char *mntparameters);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_fssize",
          "args": [
            "optarg"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "get_fssize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "557-589",
          "snippet": "static uint64_t get_fssize(char *s)\n{\n\tuint64_t ret;\n\tchar *end;\n\n\tret = strtoull(s, &end, 0);\n\tif (end == s) {\n\t\tif (!my_args.quiet)\n\t\t\tfprintf(stderr, \"Invalid blockdev size '%s', using default size\\n\", s);\n\t\treturn 0;\n\t}\n\twhile (isblank(*end))\n\t\tend++;\n\tif (*end == '\\0') {\n\t\tret *= 1024ULL * 1024ULL; // MB by default\n\t} else if (*end == 'b' || *end == 'B') {\n\t\tret *= 1ULL;\n\t} else if (*end == 'k' || *end == 'K') {\n\t\tret *= 1024ULL;\n\t} else if (*end == 'm' || *end == 'M') {\n\t\tret *= 1024ULL * 1024ULL;\n\t} else if (*end == 'g' || *end == 'G') {\n\t\tret *= 1024ULL * 1024ULL * 1024ULL;\n\t} else if (*end == 't' || *end == 'T') {\n\t\tret *= 1024ULL * 1024ULL * 1024ULL * 1024ULL;\n\t} else {\n\t\tif (!my_args.quiet)\n\t\t\tfprintf(stderr, \"Invalid blockdev unit size '%c' in '%s', \" \"using default size\\n\", *end, s);\n\t\treturn 0;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lxc_arguments my_args = {\n\t.progname = \"lxc-copy\",\n\t.help = \"\\n\\\n--name=NAME [-P lxcpath] -N newname [-p newpath] [-B backingstorage] [-s] [-K] [-M] [-L size [unit]] -- hook options\\n\\\n--name=NAME [-P lxcpath] [-N newname] [-p newpath] [-B backingstorage] -e [-d] [-D] [-K] [-M] [-m {bind,aufs,overlay}=/src:/dest] -- hook options\\n\\\n--name=NAME [-P lxcpath] -N newname -R\\n\\\n\\n\\\nlxc-copy clone a container\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME           NAME of the container\\n\\\n  -N, --newname=NEWNAME     NEWNAME for the restored container\\n\\\n  -p, --newpath=NEWPATH     NEWPATH for the container to be stored\\n\\\n  -R, --rename              rename container\\n\\\n  -s, --snapshot            create snapshot instead of clone\\n\\\n  -F, --foreground          start with current tty attached to /dev/console\\n\\\n  -d, --daemon              daemonize the container (default)\\n\\\n  -e, --ephemeral           start ephemeral container\\n\\\n  -m, --mount               directory to mount into container, either \\n\\\n                            {bind,aufs,overlay}=/src-path or {bind,aufs,overlay}=/src-path:/dst-path\\n\\\n  -B, --backingstorage=TYPE backingstorage type for the container\\n\\\n  -t, --tmpfs               place ephemeral container on a tmpfs\\n\\\n                            (WARNING: On reboot all changes made to the container will be lost.)\\n\\\n  -L, --fssize              size of the new block device for block device containers\\n\\\n  -D, --keedata             pass together with -e start a persistent snapshot \\n\\\n  -K, --keepname            keep the hostname of the original container\\n\\\n  --  hook options          arguments passed to the hook program\\n\\\n  -M, --keepmac             keep the MAC address of the original container\\n\\\n  --rcfile=FILE             Load configuration file FILE\\n\",\n\t.options = my_longopts,\n\t.parser = my_parser,\n\t.task = CLONE,\n\t.daemonize = 1,\n\t.quiet = false,\n\t.tmpfs = false,\n};",
            "static char *set_mnt_entry(struct mnts *m);",
            "static uint64_t get_fssize(char *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic struct lxc_arguments my_args = {\n\t.progname = \"lxc-copy\",\n\t.help = \"\\n\\\n--name=NAME [-P lxcpath] -N newname [-p newpath] [-B backingstorage] [-s] [-K] [-M] [-L size [unit]] -- hook options\\n\\\n--name=NAME [-P lxcpath] [-N newname] [-p newpath] [-B backingstorage] -e [-d] [-D] [-K] [-M] [-m {bind,aufs,overlay}=/src:/dest] -- hook options\\n\\\n--name=NAME [-P lxcpath] -N newname -R\\n\\\n\\n\\\nlxc-copy clone a container\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME           NAME of the container\\n\\\n  -N, --newname=NEWNAME     NEWNAME for the restored container\\n\\\n  -p, --newpath=NEWPATH     NEWPATH for the container to be stored\\n\\\n  -R, --rename              rename container\\n\\\n  -s, --snapshot            create snapshot instead of clone\\n\\\n  -F, --foreground          start with current tty attached to /dev/console\\n\\\n  -d, --daemon              daemonize the container (default)\\n\\\n  -e, --ephemeral           start ephemeral container\\n\\\n  -m, --mount               directory to mount into container, either \\n\\\n                            {bind,aufs,overlay}=/src-path or {bind,aufs,overlay}=/src-path:/dst-path\\n\\\n  -B, --backingstorage=TYPE backingstorage type for the container\\n\\\n  -t, --tmpfs               place ephemeral container on a tmpfs\\n\\\n                            (WARNING: On reboot all changes made to the container will be lost.)\\n\\\n  -L, --fssize              size of the new block device for block device containers\\n\\\n  -D, --keedata             pass together with -e start a persistent snapshot \\n\\\n  -K, --keepname            keep the hostname of the original container\\n\\\n  --  hook options          arguments passed to the hook program\\n\\\n  -M, --keepmac             keep the MAC address of the original container\\n\\\n  --rcfile=FILE             Load configuration file FILE\\n\",\n\t.options = my_longopts,\n\t.parser = my_parser,\n\t.task = CLONE,\n\t.daemonize = 1,\n\t.quiet = false,\n\t.tmpfs = false,\n};\nstatic char *set_mnt_entry(struct mnts *m);\nstatic uint64_t get_fssize(char *s);\n\nstatic uint64_t get_fssize(char *s)\n{\n\tuint64_t ret;\n\tchar *end;\n\n\tret = strtoull(s, &end, 0);\n\tif (end == s) {\n\t\tif (!my_args.quiet)\n\t\t\tfprintf(stderr, \"Invalid blockdev size '%s', using default size\\n\", s);\n\t\treturn 0;\n\t}\n\twhile (isblank(*end))\n\t\tend++;\n\tif (*end == '\\0') {\n\t\tret *= 1024ULL * 1024ULL; // MB by default\n\t} else if (*end == 'b' || *end == 'B') {\n\t\tret *= 1ULL;\n\t} else if (*end == 'k' || *end == 'K') {\n\t\tret *= 1024ULL;\n\t} else if (*end == 'm' || *end == 'M') {\n\t\tret *= 1024ULL * 1024ULL;\n\t} else if (*end == 'g' || *end == 'G') {\n\t\tret *= 1024ULL * 1024ULL * 1024ULL;\n\t} else if (*end == 't' || *end == 'T') {\n\t\tret *= 1024ULL * 1024ULL * 1024ULL * 1024ULL;\n\t} else {\n\t\tif (!my_args.quiet)\n\t\t\tfprintf(stderr, \"Invalid blockdev unit size '%c' in '%s', \" \"using default size\\n\", *end, s);\n\t\treturn 0;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"overlay\""
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_mntsubopts",
          "args": [
            "subopts",
            "keys",
            "mntparameters"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "parse_mntsubopts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "748-769",
          "snippet": "static int parse_mntsubopts(char *subopts, char *const *keys, char *mntparameters)\n{\n\twhile (*subopts != '\\0') {\n\t\tswitch (getsubopt(&subopts, keys, &mntparameters)) {\n\t\tcase LXC_MNT_BIND:\n\t\t\tif (parse_bind_mnt(mntparameters, LXC_MNT_BIND) < 0)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tcase LXC_MNT_OVL:\n\t\t\tif (parse_ovl_mnt(mntparameters, LXC_MNT_OVL) < 0)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tcase LXC_MNT_AUFS:\n\t\t\tif (parse_aufs_mnt(mntparameters, LXC_MNT_AUFS) < 0)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *const keys[] = {\n\t[LXC_MNT_BIND] = \"bind\",\n\t[LXC_MNT_AUFS] = \"aufs\",\n\t[LXC_MNT_OVL] = \"overlay\",\n\tNULL\n};",
            "static int parse_mntsubopts(char *subopts, char *const *keys,\n\t\t\t    char *mntparameters);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic char *const keys[] = {\n\t[LXC_MNT_BIND] = \"bind\",\n\t[LXC_MNT_AUFS] = \"aufs\",\n\t[LXC_MNT_OVL] = \"overlay\",\n\tNULL\n};\nstatic int parse_mntsubopts(char *subopts, char *const *keys,\n\t\t\t    char *mntparameters);\n\nstatic int parse_mntsubopts(char *subopts, char *const *keys, char *mntparameters)\n{\n\twhile (*subopts != '\\0') {\n\t\tswitch (getsubopt(&subopts, keys, &mntparameters)) {\n\t\tcase LXC_MNT_BIND:\n\t\t\tif (parse_bind_mnt(mntparameters, LXC_MNT_BIND) < 0)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tcase LXC_MNT_OVL:\n\t\t\tif (parse_ovl_mnt(mntparameters, LXC_MNT_OVL) < 0)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tcase LXC_MNT_AUFS:\n\t\t\tif (parse_aufs_mnt(mntparameters, LXC_MNT_AUFS) < 0)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic int my_parser(struct lxc_arguments *args, int c, char *arg);\nstatic char *const keys[] = {\n\t[LXC_MNT_BIND] = \"bind\",\n\t[LXC_MNT_AUFS] = \"aufs\",\n\t[LXC_MNT_OVL] = \"overlay\",\n\tNULL\n};\nstatic int mk_rand_ovl_dirs(struct mnts *mnts, unsigned int num,\n\t\t\t    struct lxc_arguments *arg);\nstatic char *set_mnt_entry(struct mnts *m);\nstatic int do_clone(struct lxc_container *c, char *newname, char *newpath,\n\t\t    int flags, char *bdevtype, uint64_t fssize, enum task task,\n\t\t    char **args);\nstatic int do_clone_rename(struct lxc_container *c, char *newname);\nstatic int do_clone_task(struct lxc_container *c, enum task task, int flags,\n\t\t\t char **args);\nstatic uint64_t get_fssize(char *s);\nstatic char *mount_tmpfs(const char *oldname, const char *newname,\n\t\t\t const char *path, struct lxc_arguments *arg);\nstatic int parse_mntsubopts(char *subopts, char *const *keys,\n\t\t\t    char *mntparameters);\n\nstatic int my_parser(struct lxc_arguments *args, int c, char *arg)\n{\n\tchar *subopts = NULL;\n\tchar *mntparameters = NULL;\n\tswitch (c) {\n\tcase 'N':\n\t\targs->newname = arg;\n\t\tbreak;\n\tcase 'p':\n\t\targs->newpath = arg;\n\t\tbreak;\n\tcase 'R':\n\t\targs->task = RENAME;\n\t\tbreak;\n\tcase 's':\n\t\targs->task = SNAP;\n\t\tbreak;\n\tcase 'F':\n\t\targs->daemonize = 0;\n\t\tbreak;\n\tcase 'd':\n\t\targs->daemonize = 1;\n\t\tbreak;\n\tcase 'e':\n\t\targs->task = DESTROY;\n\t\tbreak;\n\tcase 'm':\n\t\tsubopts = optarg;\n\t\tif (parse_mntsubopts(subopts, keys, mntparameters) < 0)\n\t\t\treturn -1;\n\t\tbreak;\n\tcase 'B':\n\t\tif (strcmp(arg, \"overlay\") == 0)\n\t\t\targ = \"overlayfs\";\n\t\targs->bdevtype = arg;\n\t\tbreak;\n\tcase 't':\n\t\targs->tmpfs = true;\n\t\tbreak;\n\tcase 'L':\n\t\targs->fssize = get_fssize(optarg);\n\t\tbreak;\n\tcase 'D':\n\t\targs->keepdata = 1;\n\t\tbreak;\n\tcase 'K':\n\t\targs->keepname = 1;\n\t\tbreak;\n\tcase 'M':\n\t\targs->keepmac = 1;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "get_fssize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
    "lines": "557-589",
    "snippet": "static uint64_t get_fssize(char *s)\n{\n\tuint64_t ret;\n\tchar *end;\n\n\tret = strtoull(s, &end, 0);\n\tif (end == s) {\n\t\tif (!my_args.quiet)\n\t\t\tfprintf(stderr, \"Invalid blockdev size '%s', using default size\\n\", s);\n\t\treturn 0;\n\t}\n\twhile (isblank(*end))\n\t\tend++;\n\tif (*end == '\\0') {\n\t\tret *= 1024ULL * 1024ULL; // MB by default\n\t} else if (*end == 'b' || *end == 'B') {\n\t\tret *= 1ULL;\n\t} else if (*end == 'k' || *end == 'K') {\n\t\tret *= 1024ULL;\n\t} else if (*end == 'm' || *end == 'M') {\n\t\tret *= 1024ULL * 1024ULL;\n\t} else if (*end == 'g' || *end == 'G') {\n\t\tret *= 1024ULL * 1024ULL * 1024ULL;\n\t} else if (*end == 't' || *end == 'T') {\n\t\tret *= 1024ULL * 1024ULL * 1024ULL * 1024ULL;\n\t} else {\n\t\tif (!my_args.quiet)\n\t\t\tfprintf(stderr, \"Invalid blockdev unit size '%c' in '%s', \" \"using default size\\n\", *end, s);\n\t\treturn 0;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <../include/getsubopt.h>",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"arguments.h\"",
      "#include \"confile.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <stdbool.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <stdint.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <getopt.h>",
      "#include <unistd.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lxc_arguments my_args = {\n\t.progname = \"lxc-copy\",\n\t.help = \"\\n\\\n--name=NAME [-P lxcpath] -N newname [-p newpath] [-B backingstorage] [-s] [-K] [-M] [-L size [unit]] -- hook options\\n\\\n--name=NAME [-P lxcpath] [-N newname] [-p newpath] [-B backingstorage] -e [-d] [-D] [-K] [-M] [-m {bind,aufs,overlay}=/src:/dest] -- hook options\\n\\\n--name=NAME [-P lxcpath] -N newname -R\\n\\\n\\n\\\nlxc-copy clone a container\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME           NAME of the container\\n\\\n  -N, --newname=NEWNAME     NEWNAME for the restored container\\n\\\n  -p, --newpath=NEWPATH     NEWPATH for the container to be stored\\n\\\n  -R, --rename              rename container\\n\\\n  -s, --snapshot            create snapshot instead of clone\\n\\\n  -F, --foreground          start with current tty attached to /dev/console\\n\\\n  -d, --daemon              daemonize the container (default)\\n\\\n  -e, --ephemeral           start ephemeral container\\n\\\n  -m, --mount               directory to mount into container, either \\n\\\n                            {bind,aufs,overlay}=/src-path or {bind,aufs,overlay}=/src-path:/dst-path\\n\\\n  -B, --backingstorage=TYPE backingstorage type for the container\\n\\\n  -t, --tmpfs               place ephemeral container on a tmpfs\\n\\\n                            (WARNING: On reboot all changes made to the container will be lost.)\\n\\\n  -L, --fssize              size of the new block device for block device containers\\n\\\n  -D, --keedata             pass together with -e start a persistent snapshot \\n\\\n  -K, --keepname            keep the hostname of the original container\\n\\\n  --  hook options          arguments passed to the hook program\\n\\\n  -M, --keepmac             keep the MAC address of the original container\\n\\\n  --rcfile=FILE             Load configuration file FILE\\n\",\n\t.options = my_longopts,\n\t.parser = my_parser,\n\t.task = CLONE,\n\t.daemonize = 1,\n\t.quiet = false,\n\t.tmpfs = false,\n};",
      "static char *set_mnt_entry(struct mnts *m);",
      "static uint64_t get_fssize(char *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Invalid blockdev unit size '%c' in '%s', \" \"using default size\\n\"",
            "*end",
            "s"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isblank",
          "args": [
            "*end"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Invalid blockdev size '%s', using default size\\n\"",
            "s"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoull",
          "args": [
            "s",
            "&end",
            "0"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic struct lxc_arguments my_args = {\n\t.progname = \"lxc-copy\",\n\t.help = \"\\n\\\n--name=NAME [-P lxcpath] -N newname [-p newpath] [-B backingstorage] [-s] [-K] [-M] [-L size [unit]] -- hook options\\n\\\n--name=NAME [-P lxcpath] [-N newname] [-p newpath] [-B backingstorage] -e [-d] [-D] [-K] [-M] [-m {bind,aufs,overlay}=/src:/dest] -- hook options\\n\\\n--name=NAME [-P lxcpath] -N newname -R\\n\\\n\\n\\\nlxc-copy clone a container\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME           NAME of the container\\n\\\n  -N, --newname=NEWNAME     NEWNAME for the restored container\\n\\\n  -p, --newpath=NEWPATH     NEWPATH for the container to be stored\\n\\\n  -R, --rename              rename container\\n\\\n  -s, --snapshot            create snapshot instead of clone\\n\\\n  -F, --foreground          start with current tty attached to /dev/console\\n\\\n  -d, --daemon              daemonize the container (default)\\n\\\n  -e, --ephemeral           start ephemeral container\\n\\\n  -m, --mount               directory to mount into container, either \\n\\\n                            {bind,aufs,overlay}=/src-path or {bind,aufs,overlay}=/src-path:/dst-path\\n\\\n  -B, --backingstorage=TYPE backingstorage type for the container\\n\\\n  -t, --tmpfs               place ephemeral container on a tmpfs\\n\\\n                            (WARNING: On reboot all changes made to the container will be lost.)\\n\\\n  -L, --fssize              size of the new block device for block device containers\\n\\\n  -D, --keedata             pass together with -e start a persistent snapshot \\n\\\n  -K, --keepname            keep the hostname of the original container\\n\\\n  --  hook options          arguments passed to the hook program\\n\\\n  -M, --keepmac             keep the MAC address of the original container\\n\\\n  --rcfile=FILE             Load configuration file FILE\\n\",\n\t.options = my_longopts,\n\t.parser = my_parser,\n\t.task = CLONE,\n\t.daemonize = 1,\n\t.quiet = false,\n\t.tmpfs = false,\n};\nstatic char *set_mnt_entry(struct mnts *m);\nstatic uint64_t get_fssize(char *s);\n\nstatic uint64_t get_fssize(char *s)\n{\n\tuint64_t ret;\n\tchar *end;\n\n\tret = strtoull(s, &end, 0);\n\tif (end == s) {\n\t\tif (!my_args.quiet)\n\t\t\tfprintf(stderr, \"Invalid blockdev size '%s', using default size\\n\", s);\n\t\treturn 0;\n\t}\n\twhile (isblank(*end))\n\t\tend++;\n\tif (*end == '\\0') {\n\t\tret *= 1024ULL * 1024ULL; // MB by default\n\t} else if (*end == 'b' || *end == 'B') {\n\t\tret *= 1ULL;\n\t} else if (*end == 'k' || *end == 'K') {\n\t\tret *= 1024ULL;\n\t} else if (*end == 'm' || *end == 'M') {\n\t\tret *= 1024ULL * 1024ULL;\n\t} else if (*end == 'g' || *end == 'G') {\n\t\tret *= 1024ULL * 1024ULL * 1024ULL;\n\t} else if (*end == 't' || *end == 'T') {\n\t\tret *= 1024ULL * 1024ULL * 1024ULL * 1024ULL;\n\t} else {\n\t\tif (!my_args.quiet)\n\t\t\tfprintf(stderr, \"Invalid blockdev unit size '%c' in '%s', \" \"using default size\\n\", *end, s);\n\t\treturn 0;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "free_mnts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
    "lines": "539-554",
    "snippet": "static void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}",
    "includes": [
      "#include <../include/getsubopt.h>",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"arguments.h\"",
      "#include \"confile.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <stdbool.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <stdint.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <getopt.h>",
      "#include <unistd.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int mnt_table_size = 0;",
      "static struct mnts *mnt_table = NULL;",
      "static void free_mnts(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "mnt_table"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "free_mnts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "539-554",
          "snippet": "static void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic unsigned int mnt_table_size = 0;\nstatic struct mnts *mnt_table = NULL;\nstatic void free_mnts(void);\n\nstatic void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}"
  },
  {
    "function_name": "do_clone_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
    "lines": "517-537",
    "snippet": "static int do_clone_task(struct lxc_container *c, enum task task, int flags,\n\t\t\t char **args)\n{\n\tint ret = 0;\n\n\tswitch (task) {\n\tcase DESTROY:\n\t\tret = do_clone_ephemeral(c, &my_args, args, flags);\n\t\tbreak;\n\tcase RENAME:\n\t\tret = do_clone_rename(c, my_args.newname);\n\t\tbreak;\n\tdefault:\n\t\tret = do_clone(c, my_args.newname, my_args.newpath, flags,\n\t\t\t       my_args.bdevtype, my_args.fssize, my_args.task,\n\t\t\t       args);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <../include/getsubopt.h>",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"arguments.h\"",
      "#include \"confile.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <stdbool.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <stdint.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <getopt.h>",
      "#include <unistd.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lxc_arguments my_args = {\n\t.progname = \"lxc-copy\",\n\t.help = \"\\n\\\n--name=NAME [-P lxcpath] -N newname [-p newpath] [-B backingstorage] [-s] [-K] [-M] [-L size [unit]] -- hook options\\n\\\n--name=NAME [-P lxcpath] [-N newname] [-p newpath] [-B backingstorage] -e [-d] [-D] [-K] [-M] [-m {bind,aufs,overlay}=/src:/dest] -- hook options\\n\\\n--name=NAME [-P lxcpath] -N newname -R\\n\\\n\\n\\\nlxc-copy clone a container\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME           NAME of the container\\n\\\n  -N, --newname=NEWNAME     NEWNAME for the restored container\\n\\\n  -p, --newpath=NEWPATH     NEWPATH for the container to be stored\\n\\\n  -R, --rename              rename container\\n\\\n  -s, --snapshot            create snapshot instead of clone\\n\\\n  -F, --foreground          start with current tty attached to /dev/console\\n\\\n  -d, --daemon              daemonize the container (default)\\n\\\n  -e, --ephemeral           start ephemeral container\\n\\\n  -m, --mount               directory to mount into container, either \\n\\\n                            {bind,aufs,overlay}=/src-path or {bind,aufs,overlay}=/src-path:/dst-path\\n\\\n  -B, --backingstorage=TYPE backingstorage type for the container\\n\\\n  -t, --tmpfs               place ephemeral container on a tmpfs\\n\\\n                            (WARNING: On reboot all changes made to the container will be lost.)\\n\\\n  -L, --fssize              size of the new block device for block device containers\\n\\\n  -D, --keedata             pass together with -e start a persistent snapshot \\n\\\n  -K, --keepname            keep the hostname of the original container\\n\\\n  --  hook options          arguments passed to the hook program\\n\\\n  -M, --keepmac             keep the MAC address of the original container\\n\\\n  --rcfile=FILE             Load configuration file FILE\\n\",\n\t.options = my_longopts,\n\t.parser = my_parser,\n\t.task = CLONE,\n\t.daemonize = 1,\n\t.quiet = false,\n\t.tmpfs = false,\n};",
      "static int do_clone(struct lxc_container *c, char *newname, char *newpath,\n\t\t    int flags, char *bdevtype, uint64_t fssize, enum task task,\n\t\t    char **args);",
      "static int do_clone_ephemeral(struct lxc_container *c,\n\t\t\t      struct lxc_arguments *arg, char **args,\n\t\t\t      int flags);",
      "static int do_clone_rename(struct lxc_container *c, char *newname);",
      "static int do_clone_task(struct lxc_container *c, enum task task, int flags,\n\t\t\t char **args);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_clone",
          "args": [
            "c",
            "my_args.newname",
            "my_args.newpath",
            "flags",
            "my_args.bdevtype",
            "my_args.fssize",
            "my_args.task",
            "args"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "do_clone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "373-392",
          "snippet": "static int do_clone(struct lxc_container *c, char *newname, char *newpath,\n\t\t    int flags, char *bdevtype, uint64_t fssize, enum task task,\n\t\t    char **args)\n{\n\tstruct lxc_container *clone;\n\n\tclone = c->clone(c, newname, newpath, flags, bdevtype, NULL, fssize,\n\t\t\t args);\n\tif (!clone) {\n\t\tif (!my_args.quiet)\n\t\t\tfprintf(stderr, \"clone failed\\n\");\n\t\treturn -1;\n\t}\n\n\tINFO(\"Created %s as %s of %s\\n\", newname, task ? \"snapshot\" : \"copy\", c->name);\n\n\tlxc_container_put(clone);\n\n\treturn 0;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lxc_arguments my_args = {\n\t.progname = \"lxc-copy\",\n\t.help = \"\\n\\\n--name=NAME [-P lxcpath] -N newname [-p newpath] [-B backingstorage] [-s] [-K] [-M] [-L size [unit]] -- hook options\\n\\\n--name=NAME [-P lxcpath] [-N newname] [-p newpath] [-B backingstorage] -e [-d] [-D] [-K] [-M] [-m {bind,aufs,overlay}=/src:/dest] -- hook options\\n\\\n--name=NAME [-P lxcpath] -N newname -R\\n\\\n\\n\\\nlxc-copy clone a container\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME           NAME of the container\\n\\\n  -N, --newname=NEWNAME     NEWNAME for the restored container\\n\\\n  -p, --newpath=NEWPATH     NEWPATH for the container to be stored\\n\\\n  -R, --rename              rename container\\n\\\n  -s, --snapshot            create snapshot instead of clone\\n\\\n  -F, --foreground          start with current tty attached to /dev/console\\n\\\n  -d, --daemon              daemonize the container (default)\\n\\\n  -e, --ephemeral           start ephemeral container\\n\\\n  -m, --mount               directory to mount into container, either \\n\\\n                            {bind,aufs,overlay}=/src-path or {bind,aufs,overlay}=/src-path:/dst-path\\n\\\n  -B, --backingstorage=TYPE backingstorage type for the container\\n\\\n  -t, --tmpfs               place ephemeral container on a tmpfs\\n\\\n                            (WARNING: On reboot all changes made to the container will be lost.)\\n\\\n  -L, --fssize              size of the new block device for block device containers\\n\\\n  -D, --keedata             pass together with -e start a persistent snapshot \\n\\\n  -K, --keepname            keep the hostname of the original container\\n\\\n  --  hook options          arguments passed to the hook program\\n\\\n  -M, --keepmac             keep the MAC address of the original container\\n\\\n  --rcfile=FILE             Load configuration file FILE\\n\",\n\t.options = my_longopts,\n\t.parser = my_parser,\n\t.task = CLONE,\n\t.daemonize = 1,\n\t.quiet = false,\n\t.tmpfs = false,\n};",
            "static int do_clone(struct lxc_container *c, char *newname, char *newpath,\n\t\t    int flags, char *bdevtype, uint64_t fssize, enum task task,\n\t\t    char **args);",
            "static int do_clone_ephemeral(struct lxc_container *c,\n\t\t\t      struct lxc_arguments *arg, char **args,\n\t\t\t      int flags);",
            "static int do_clone_rename(struct lxc_container *c, char *newname);",
            "static int do_clone_task(struct lxc_container *c, enum task task, int flags,\n\t\t\t char **args);",
            "static uint64_t get_fssize(char *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic struct lxc_arguments my_args = {\n\t.progname = \"lxc-copy\",\n\t.help = \"\\n\\\n--name=NAME [-P lxcpath] -N newname [-p newpath] [-B backingstorage] [-s] [-K] [-M] [-L size [unit]] -- hook options\\n\\\n--name=NAME [-P lxcpath] [-N newname] [-p newpath] [-B backingstorage] -e [-d] [-D] [-K] [-M] [-m {bind,aufs,overlay}=/src:/dest] -- hook options\\n\\\n--name=NAME [-P lxcpath] -N newname -R\\n\\\n\\n\\\nlxc-copy clone a container\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME           NAME of the container\\n\\\n  -N, --newname=NEWNAME     NEWNAME for the restored container\\n\\\n  -p, --newpath=NEWPATH     NEWPATH for the container to be stored\\n\\\n  -R, --rename              rename container\\n\\\n  -s, --snapshot            create snapshot instead of clone\\n\\\n  -F, --foreground          start with current tty attached to /dev/console\\n\\\n  -d, --daemon              daemonize the container (default)\\n\\\n  -e, --ephemeral           start ephemeral container\\n\\\n  -m, --mount               directory to mount into container, either \\n\\\n                            {bind,aufs,overlay}=/src-path or {bind,aufs,overlay}=/src-path:/dst-path\\n\\\n  -B, --backingstorage=TYPE backingstorage type for the container\\n\\\n  -t, --tmpfs               place ephemeral container on a tmpfs\\n\\\n                            (WARNING: On reboot all changes made to the container will be lost.)\\n\\\n  -L, --fssize              size of the new block device for block device containers\\n\\\n  -D, --keedata             pass together with -e start a persistent snapshot \\n\\\n  -K, --keepname            keep the hostname of the original container\\n\\\n  --  hook options          arguments passed to the hook program\\n\\\n  -M, --keepmac             keep the MAC address of the original container\\n\\\n  --rcfile=FILE             Load configuration file FILE\\n\",\n\t.options = my_longopts,\n\t.parser = my_parser,\n\t.task = CLONE,\n\t.daemonize = 1,\n\t.quiet = false,\n\t.tmpfs = false,\n};\nstatic int do_clone(struct lxc_container *c, char *newname, char *newpath,\n\t\t    int flags, char *bdevtype, uint64_t fssize, enum task task,\n\t\t    char **args);\nstatic int do_clone_ephemeral(struct lxc_container *c,\n\t\t\t      struct lxc_arguments *arg, char **args,\n\t\t\t      int flags);\nstatic int do_clone_rename(struct lxc_container *c, char *newname);\nstatic int do_clone_task(struct lxc_container *c, enum task task, int flags,\n\t\t\t char **args);\nstatic uint64_t get_fssize(char *s);\n\nstatic int do_clone(struct lxc_container *c, char *newname, char *newpath,\n\t\t    int flags, char *bdevtype, uint64_t fssize, enum task task,\n\t\t    char **args)\n{\n\tstruct lxc_container *clone;\n\n\tclone = c->clone(c, newname, newpath, flags, bdevtype, NULL, fssize,\n\t\t\t args);\n\tif (!clone) {\n\t\tif (!my_args.quiet)\n\t\t\tfprintf(stderr, \"clone failed\\n\");\n\t\treturn -1;\n\t}\n\n\tINFO(\"Created %s as %s of %s\\n\", newname, task ? \"snapshot\" : \"copy\", c->name);\n\n\tlxc_container_put(clone);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_clone_rename",
          "args": [
            "c",
            "my_args.newname"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "do_clone_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "505-515",
          "snippet": "static int do_clone_rename(struct lxc_container *c, char *newname)\n{\n\tif (!c->rename(c, newname)) {\n\t\tERROR(\"Error: Renaming container %s to %s failed\\n\", c->name, newname);\n\t\treturn -1;\n\t}\n\n\tINFO(\"Renamed container %s to %s\\n\", c->name, newname);\n\n\treturn 0;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int do_clone_rename(struct lxc_container *c, char *newname);",
            "static uint64_t get_fssize(char *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic int do_clone_rename(struct lxc_container *c, char *newname);\nstatic uint64_t get_fssize(char *s);\n\nstatic int do_clone_rename(struct lxc_container *c, char *newname)\n{\n\tif (!c->rename(c, newname)) {\n\t\tERROR(\"Error: Renaming container %s to %s failed\\n\", c->name, newname);\n\t\treturn -1;\n\t}\n\n\tINFO(\"Renamed container %s to %s\\n\", c->name, newname);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_clone_ephemeral",
          "args": [
            "c",
            "&my_args",
            "args",
            "flags"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "do_clone_ephemeral",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "394-503",
          "snippet": "static int do_clone_ephemeral(struct lxc_container *c,\n\t\tstruct lxc_arguments *arg, char **args, int flags)\n{\n\tchar *bdev;\n\tchar *premount;\n\tchar randname[MAXPATHLEN];\n\tunsigned int i;\n\tint ret = 0;\n\tbool bret = true, started = false;\n\tstruct lxc_container *clone;\n\tlxc_attach_options_t attach_options = LXC_ATTACH_OPTIONS_DEFAULT;\n\tattach_options.env_policy = LXC_ATTACH_CLEAR_ENV;\n\n\tif (!arg->newname) {\n\t\tret = snprintf(randname, MAXPATHLEN, \"%s/%s_XXXXXX\", arg->newpath, arg->name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn -1;\n\t\tif (!mkdtemp(randname))\n\t\t\treturn -1;\n\t\tif (chmod(randname, 0770) < 0) {\n\t\t\tremove(randname);\n\t\t\treturn -1;\n\t\t}\n\t\targ->newname = randname + strlen(arg->newpath) + 1;\n\t}\n\n\tclone = c->clone(c, arg->newname, arg->newpath, flags,\n\t\t\t arg->bdevtype, NULL, arg->fssize, args);\n\tif (!clone)\n\t\treturn -1;\n\n\tif (arg->tmpfs) {\n\t\tbdev = c->lxc_conf->rootfs.bdev_type;\n\t\tif (bdev && strcmp(bdev, \"dir\")) {\n\t\t\tfprintf(stderr, \"Cannot currently use tmpfs with %s storage backend.\\n\", bdev);\n\t\t\tgoto destroy_and_put;\n\t\t}\n\n\t\tpremount = mount_tmpfs(arg->name, arg->newname, arg->newpath, arg);\n\t\tif (!premount)\n\t\t\tgoto destroy_and_put;\n\n\t\tbret = clone->set_config_item(clone, \"lxc.hook.pre-mount\", premount);\n\t\tfree(premount);\n\t\tif (!bret)\n\t\t\tgoto destroy_and_put;\n\t}\n\n\tif (!arg->keepdata)\n\t\tif (!clone->set_config_item(clone, \"lxc.ephemeral\", \"1\"))\n\t\t\tgoto destroy_and_put;\n\n\t/* allocate and create random upper- and workdirs for overlay mounts */\n\tif (mk_rand_ovl_dirs(mnt_table, mnt_table_size, arg) < 0)\n\t\tgoto destroy_and_put;\n\n\t/* allocate and set mount entries */\n\tstruct mnts *n = NULL;\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tchar *mntentry = NULL;\n\t\tmntentry = set_mnt_entry(n);\n\t\tif (!mntentry)\n\t\t\tgoto destroy_and_put;\n\t\tbret = clone->set_config_item(clone, \"lxc.mount.entry\", mntentry);\n\t\tfree(mntentry);\n\t\tif (!bret)\n\t\t\tgoto destroy_and_put;\n\t}\n\n\tif (!clone->save_config(clone, NULL))\n\t\tgoto destroy_and_put;\n\n\tif (!my_args.quiet)\n\t\tprintf(\"Created %s as clone of %s\\n\", arg->newname, arg->name);\n\n\tif (arg->tmpfs && !my_args.quiet)\n\t\tprintf(\"Container is placed on tmpfs.\\nRebooting will cause \"\n\t\t       \"all changes made to it to be lost!\\n\");\n\n\tif (!arg->daemonize && arg->argc) {\n\t\tclone->want_daemonize(clone, true);\n\t\targ->daemonize = 1;\n\t} else if (!arg->daemonize) {\n\t\tclone->want_daemonize(clone, false);\n\t}\n\n\tstarted = clone->start(clone, 0, NULL);\n\tif (!started)\n\t\tgoto destroy_and_put;\n\n\tif (arg->daemonize && arg->argc) {\n\t\tret = clone->attach_run_wait(clone, &attach_options, arg->argv[0], (const char *const *)arg->argv);\n\t\tif (ret < 0)\n\t\t\tgoto destroy_and_put;\n\t\tclone->shutdown(clone, -1);\n\t}\n\n\tfree_mnts();\n\tlxc_container_put(clone);\n\treturn 0;\n\ndestroy_and_put:\n\tif (started)\n\t\tclone->shutdown(clone, -1);\n\tif (!started || clone->lxc_conf->ephemeral != 1)\n\t\tclone->destroy(clone);\n\tfree_mnts();\n\tlxc_container_put(clone);\n\treturn -1;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int mnt_table_size = 0;",
            "static struct mnts *mnt_table = NULL;",
            "static int my_parser(struct lxc_arguments *args, int c, char *arg);",
            "static struct lxc_arguments my_args = {\n\t.progname = \"lxc-copy\",\n\t.help = \"\\n\\\n--name=NAME [-P lxcpath] -N newname [-p newpath] [-B backingstorage] [-s] [-K] [-M] [-L size [unit]] -- hook options\\n\\\n--name=NAME [-P lxcpath] [-N newname] [-p newpath] [-B backingstorage] -e [-d] [-D] [-K] [-M] [-m {bind,aufs,overlay}=/src:/dest] -- hook options\\n\\\n--name=NAME [-P lxcpath] -N newname -R\\n\\\n\\n\\\nlxc-copy clone a container\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME           NAME of the container\\n\\\n  -N, --newname=NEWNAME     NEWNAME for the restored container\\n\\\n  -p, --newpath=NEWPATH     NEWPATH for the container to be stored\\n\\\n  -R, --rename              rename container\\n\\\n  -s, --snapshot            create snapshot instead of clone\\n\\\n  -F, --foreground          start with current tty attached to /dev/console\\n\\\n  -d, --daemon              daemonize the container (default)\\n\\\n  -e, --ephemeral           start ephemeral container\\n\\\n  -m, --mount               directory to mount into container, either \\n\\\n                            {bind,aufs,overlay}=/src-path or {bind,aufs,overlay}=/src-path:/dst-path\\n\\\n  -B, --backingstorage=TYPE backingstorage type for the container\\n\\\n  -t, --tmpfs               place ephemeral container on a tmpfs\\n\\\n                            (WARNING: On reboot all changes made to the container will be lost.)\\n\\\n  -L, --fssize              size of the new block device for block device containers\\n\\\n  -D, --keedata             pass together with -e start a persistent snapshot \\n\\\n  -K, --keepname            keep the hostname of the original container\\n\\\n  --  hook options          arguments passed to the hook program\\n\\\n  -M, --keepmac             keep the MAC address of the original container\\n\\\n  --rcfile=FILE             Load configuration file FILE\\n\",\n\t.options = my_longopts,\n\t.parser = my_parser,\n\t.task = CLONE,\n\t.daemonize = 1,\n\t.quiet = false,\n\t.tmpfs = false,\n};",
            "static int mk_rand_ovl_dirs(struct mnts *mnts, unsigned int num,\n\t\t\t    struct lxc_arguments *arg);",
            "static int do_clone(struct lxc_container *c, char *newname, char *newpath,\n\t\t    int flags, char *bdevtype, uint64_t fssize, enum task task,\n\t\t    char **args);",
            "static int do_clone_ephemeral(struct lxc_container *c,\n\t\t\t      struct lxc_arguments *arg, char **args,\n\t\t\t      int flags);",
            "static int do_clone_rename(struct lxc_container *c, char *newname);",
            "static int do_clone_task(struct lxc_container *c, enum task task, int flags,\n\t\t\t char **args);",
            "static void free_mnts(void);",
            "static uint64_t get_fssize(char *s);",
            "static char *mount_tmpfs(const char *oldname, const char *newname,\n\t\t\t const char *path, struct lxc_arguments *arg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic unsigned int mnt_table_size = 0;\nstatic struct mnts *mnt_table = NULL;\nstatic int my_parser(struct lxc_arguments *args, int c, char *arg);\nstatic struct lxc_arguments my_args = {\n\t.progname = \"lxc-copy\",\n\t.help = \"\\n\\\n--name=NAME [-P lxcpath] -N newname [-p newpath] [-B backingstorage] [-s] [-K] [-M] [-L size [unit]] -- hook options\\n\\\n--name=NAME [-P lxcpath] [-N newname] [-p newpath] [-B backingstorage] -e [-d] [-D] [-K] [-M] [-m {bind,aufs,overlay}=/src:/dest] -- hook options\\n\\\n--name=NAME [-P lxcpath] -N newname -R\\n\\\n\\n\\\nlxc-copy clone a container\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME           NAME of the container\\n\\\n  -N, --newname=NEWNAME     NEWNAME for the restored container\\n\\\n  -p, --newpath=NEWPATH     NEWPATH for the container to be stored\\n\\\n  -R, --rename              rename container\\n\\\n  -s, --snapshot            create snapshot instead of clone\\n\\\n  -F, --foreground          start with current tty attached to /dev/console\\n\\\n  -d, --daemon              daemonize the container (default)\\n\\\n  -e, --ephemeral           start ephemeral container\\n\\\n  -m, --mount               directory to mount into container, either \\n\\\n                            {bind,aufs,overlay}=/src-path or {bind,aufs,overlay}=/src-path:/dst-path\\n\\\n  -B, --backingstorage=TYPE backingstorage type for the container\\n\\\n  -t, --tmpfs               place ephemeral container on a tmpfs\\n\\\n                            (WARNING: On reboot all changes made to the container will be lost.)\\n\\\n  -L, --fssize              size of the new block device for block device containers\\n\\\n  -D, --keedata             pass together with -e start a persistent snapshot \\n\\\n  -K, --keepname            keep the hostname of the original container\\n\\\n  --  hook options          arguments passed to the hook program\\n\\\n  -M, --keepmac             keep the MAC address of the original container\\n\\\n  --rcfile=FILE             Load configuration file FILE\\n\",\n\t.options = my_longopts,\n\t.parser = my_parser,\n\t.task = CLONE,\n\t.daemonize = 1,\n\t.quiet = false,\n\t.tmpfs = false,\n};\nstatic int mk_rand_ovl_dirs(struct mnts *mnts, unsigned int num,\n\t\t\t    struct lxc_arguments *arg);\nstatic int do_clone(struct lxc_container *c, char *newname, char *newpath,\n\t\t    int flags, char *bdevtype, uint64_t fssize, enum task task,\n\t\t    char **args);\nstatic int do_clone_ephemeral(struct lxc_container *c,\n\t\t\t      struct lxc_arguments *arg, char **args,\n\t\t\t      int flags);\nstatic int do_clone_rename(struct lxc_container *c, char *newname);\nstatic int do_clone_task(struct lxc_container *c, enum task task, int flags,\n\t\t\t char **args);\nstatic void free_mnts(void);\nstatic uint64_t get_fssize(char *s);\nstatic char *mount_tmpfs(const char *oldname, const char *newname,\n\t\t\t const char *path, struct lxc_arguments *arg);\n\nstatic int do_clone_ephemeral(struct lxc_container *c,\n\t\tstruct lxc_arguments *arg, char **args, int flags)\n{\n\tchar *bdev;\n\tchar *premount;\n\tchar randname[MAXPATHLEN];\n\tunsigned int i;\n\tint ret = 0;\n\tbool bret = true, started = false;\n\tstruct lxc_container *clone;\n\tlxc_attach_options_t attach_options = LXC_ATTACH_OPTIONS_DEFAULT;\n\tattach_options.env_policy = LXC_ATTACH_CLEAR_ENV;\n\n\tif (!arg->newname) {\n\t\tret = snprintf(randname, MAXPATHLEN, \"%s/%s_XXXXXX\", arg->newpath, arg->name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn -1;\n\t\tif (!mkdtemp(randname))\n\t\t\treturn -1;\n\t\tif (chmod(randname, 0770) < 0) {\n\t\t\tremove(randname);\n\t\t\treturn -1;\n\t\t}\n\t\targ->newname = randname + strlen(arg->newpath) + 1;\n\t}\n\n\tclone = c->clone(c, arg->newname, arg->newpath, flags,\n\t\t\t arg->bdevtype, NULL, arg->fssize, args);\n\tif (!clone)\n\t\treturn -1;\n\n\tif (arg->tmpfs) {\n\t\tbdev = c->lxc_conf->rootfs.bdev_type;\n\t\tif (bdev && strcmp(bdev, \"dir\")) {\n\t\t\tfprintf(stderr, \"Cannot currently use tmpfs with %s storage backend.\\n\", bdev);\n\t\t\tgoto destroy_and_put;\n\t\t}\n\n\t\tpremount = mount_tmpfs(arg->name, arg->newname, arg->newpath, arg);\n\t\tif (!premount)\n\t\t\tgoto destroy_and_put;\n\n\t\tbret = clone->set_config_item(clone, \"lxc.hook.pre-mount\", premount);\n\t\tfree(premount);\n\t\tif (!bret)\n\t\t\tgoto destroy_and_put;\n\t}\n\n\tif (!arg->keepdata)\n\t\tif (!clone->set_config_item(clone, \"lxc.ephemeral\", \"1\"))\n\t\t\tgoto destroy_and_put;\n\n\t/* allocate and create random upper- and workdirs for overlay mounts */\n\tif (mk_rand_ovl_dirs(mnt_table, mnt_table_size, arg) < 0)\n\t\tgoto destroy_and_put;\n\n\t/* allocate and set mount entries */\n\tstruct mnts *n = NULL;\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tchar *mntentry = NULL;\n\t\tmntentry = set_mnt_entry(n);\n\t\tif (!mntentry)\n\t\t\tgoto destroy_and_put;\n\t\tbret = clone->set_config_item(clone, \"lxc.mount.entry\", mntentry);\n\t\tfree(mntentry);\n\t\tif (!bret)\n\t\t\tgoto destroy_and_put;\n\t}\n\n\tif (!clone->save_config(clone, NULL))\n\t\tgoto destroy_and_put;\n\n\tif (!my_args.quiet)\n\t\tprintf(\"Created %s as clone of %s\\n\", arg->newname, arg->name);\n\n\tif (arg->tmpfs && !my_args.quiet)\n\t\tprintf(\"Container is placed on tmpfs.\\nRebooting will cause \"\n\t\t       \"all changes made to it to be lost!\\n\");\n\n\tif (!arg->daemonize && arg->argc) {\n\t\tclone->want_daemonize(clone, true);\n\t\targ->daemonize = 1;\n\t} else if (!arg->daemonize) {\n\t\tclone->want_daemonize(clone, false);\n\t}\n\n\tstarted = clone->start(clone, 0, NULL);\n\tif (!started)\n\t\tgoto destroy_and_put;\n\n\tif (arg->daemonize && arg->argc) {\n\t\tret = clone->attach_run_wait(clone, &attach_options, arg->argv[0], (const char *const *)arg->argv);\n\t\tif (ret < 0)\n\t\t\tgoto destroy_and_put;\n\t\tclone->shutdown(clone, -1);\n\t}\n\n\tfree_mnts();\n\tlxc_container_put(clone);\n\treturn 0;\n\ndestroy_and_put:\n\tif (started)\n\t\tclone->shutdown(clone, -1);\n\tif (!started || clone->lxc_conf->ephemeral != 1)\n\t\tclone->destroy(clone);\n\tfree_mnts();\n\tlxc_container_put(clone);\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic struct lxc_arguments my_args = {\n\t.progname = \"lxc-copy\",\n\t.help = \"\\n\\\n--name=NAME [-P lxcpath] -N newname [-p newpath] [-B backingstorage] [-s] [-K] [-M] [-L size [unit]] -- hook options\\n\\\n--name=NAME [-P lxcpath] [-N newname] [-p newpath] [-B backingstorage] -e [-d] [-D] [-K] [-M] [-m {bind,aufs,overlay}=/src:/dest] -- hook options\\n\\\n--name=NAME [-P lxcpath] -N newname -R\\n\\\n\\n\\\nlxc-copy clone a container\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME           NAME of the container\\n\\\n  -N, --newname=NEWNAME     NEWNAME for the restored container\\n\\\n  -p, --newpath=NEWPATH     NEWPATH for the container to be stored\\n\\\n  -R, --rename              rename container\\n\\\n  -s, --snapshot            create snapshot instead of clone\\n\\\n  -F, --foreground          start with current tty attached to /dev/console\\n\\\n  -d, --daemon              daemonize the container (default)\\n\\\n  -e, --ephemeral           start ephemeral container\\n\\\n  -m, --mount               directory to mount into container, either \\n\\\n                            {bind,aufs,overlay}=/src-path or {bind,aufs,overlay}=/src-path:/dst-path\\n\\\n  -B, --backingstorage=TYPE backingstorage type for the container\\n\\\n  -t, --tmpfs               place ephemeral container on a tmpfs\\n\\\n                            (WARNING: On reboot all changes made to the container will be lost.)\\n\\\n  -L, --fssize              size of the new block device for block device containers\\n\\\n  -D, --keedata             pass together with -e start a persistent snapshot \\n\\\n  -K, --keepname            keep the hostname of the original container\\n\\\n  --  hook options          arguments passed to the hook program\\n\\\n  -M, --keepmac             keep the MAC address of the original container\\n\\\n  --rcfile=FILE             Load configuration file FILE\\n\",\n\t.options = my_longopts,\n\t.parser = my_parser,\n\t.task = CLONE,\n\t.daemonize = 1,\n\t.quiet = false,\n\t.tmpfs = false,\n};\nstatic int do_clone(struct lxc_container *c, char *newname, char *newpath,\n\t\t    int flags, char *bdevtype, uint64_t fssize, enum task task,\n\t\t    char **args);\nstatic int do_clone_ephemeral(struct lxc_container *c,\n\t\t\t      struct lxc_arguments *arg, char **args,\n\t\t\t      int flags);\nstatic int do_clone_rename(struct lxc_container *c, char *newname);\nstatic int do_clone_task(struct lxc_container *c, enum task task, int flags,\n\t\t\t char **args);\n\nstatic int do_clone_task(struct lxc_container *c, enum task task, int flags,\n\t\t\t char **args)\n{\n\tint ret = 0;\n\n\tswitch (task) {\n\tcase DESTROY:\n\t\tret = do_clone_ephemeral(c, &my_args, args, flags);\n\t\tbreak;\n\tcase RENAME:\n\t\tret = do_clone_rename(c, my_args.newname);\n\t\tbreak;\n\tdefault:\n\t\tret = do_clone(c, my_args.newname, my_args.newpath, flags,\n\t\t\t       my_args.bdevtype, my_args.fssize, my_args.task,\n\t\t\t       args);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "do_clone_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
    "lines": "505-515",
    "snippet": "static int do_clone_rename(struct lxc_container *c, char *newname)\n{\n\tif (!c->rename(c, newname)) {\n\t\tERROR(\"Error: Renaming container %s to %s failed\\n\", c->name, newname);\n\t\treturn -1;\n\t}\n\n\tINFO(\"Renamed container %s to %s\\n\", c->name, newname);\n\n\treturn 0;\n}",
    "includes": [
      "#include <../include/getsubopt.h>",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"arguments.h\"",
      "#include \"confile.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <stdbool.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <stdint.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <getopt.h>",
      "#include <unistd.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int do_clone_rename(struct lxc_container *c, char *newname);",
      "static uint64_t get_fssize(char *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Renamed container %s to %s\\n\"",
            "c->name",
            "newname"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error: Renaming container %s to %s failed\\n\"",
            "c->name",
            "newname"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->rename",
          "args": [
            "c",
            "newname"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic int do_clone_rename(struct lxc_container *c, char *newname);\nstatic uint64_t get_fssize(char *s);\n\nstatic int do_clone_rename(struct lxc_container *c, char *newname)\n{\n\tif (!c->rename(c, newname)) {\n\t\tERROR(\"Error: Renaming container %s to %s failed\\n\", c->name, newname);\n\t\treturn -1;\n\t}\n\n\tINFO(\"Renamed container %s to %s\\n\", c->name, newname);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "do_clone_ephemeral",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
    "lines": "394-503",
    "snippet": "static int do_clone_ephemeral(struct lxc_container *c,\n\t\tstruct lxc_arguments *arg, char **args, int flags)\n{\n\tchar *bdev;\n\tchar *premount;\n\tchar randname[MAXPATHLEN];\n\tunsigned int i;\n\tint ret = 0;\n\tbool bret = true, started = false;\n\tstruct lxc_container *clone;\n\tlxc_attach_options_t attach_options = LXC_ATTACH_OPTIONS_DEFAULT;\n\tattach_options.env_policy = LXC_ATTACH_CLEAR_ENV;\n\n\tif (!arg->newname) {\n\t\tret = snprintf(randname, MAXPATHLEN, \"%s/%s_XXXXXX\", arg->newpath, arg->name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn -1;\n\t\tif (!mkdtemp(randname))\n\t\t\treturn -1;\n\t\tif (chmod(randname, 0770) < 0) {\n\t\t\tremove(randname);\n\t\t\treturn -1;\n\t\t}\n\t\targ->newname = randname + strlen(arg->newpath) + 1;\n\t}\n\n\tclone = c->clone(c, arg->newname, arg->newpath, flags,\n\t\t\t arg->bdevtype, NULL, arg->fssize, args);\n\tif (!clone)\n\t\treturn -1;\n\n\tif (arg->tmpfs) {\n\t\tbdev = c->lxc_conf->rootfs.bdev_type;\n\t\tif (bdev && strcmp(bdev, \"dir\")) {\n\t\t\tfprintf(stderr, \"Cannot currently use tmpfs with %s storage backend.\\n\", bdev);\n\t\t\tgoto destroy_and_put;\n\t\t}\n\n\t\tpremount = mount_tmpfs(arg->name, arg->newname, arg->newpath, arg);\n\t\tif (!premount)\n\t\t\tgoto destroy_and_put;\n\n\t\tbret = clone->set_config_item(clone, \"lxc.hook.pre-mount\", premount);\n\t\tfree(premount);\n\t\tif (!bret)\n\t\t\tgoto destroy_and_put;\n\t}\n\n\tif (!arg->keepdata)\n\t\tif (!clone->set_config_item(clone, \"lxc.ephemeral\", \"1\"))\n\t\t\tgoto destroy_and_put;\n\n\t/* allocate and create random upper- and workdirs for overlay mounts */\n\tif (mk_rand_ovl_dirs(mnt_table, mnt_table_size, arg) < 0)\n\t\tgoto destroy_and_put;\n\n\t/* allocate and set mount entries */\n\tstruct mnts *n = NULL;\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tchar *mntentry = NULL;\n\t\tmntentry = set_mnt_entry(n);\n\t\tif (!mntentry)\n\t\t\tgoto destroy_and_put;\n\t\tbret = clone->set_config_item(clone, \"lxc.mount.entry\", mntentry);\n\t\tfree(mntentry);\n\t\tif (!bret)\n\t\t\tgoto destroy_and_put;\n\t}\n\n\tif (!clone->save_config(clone, NULL))\n\t\tgoto destroy_and_put;\n\n\tif (!my_args.quiet)\n\t\tprintf(\"Created %s as clone of %s\\n\", arg->newname, arg->name);\n\n\tif (arg->tmpfs && !my_args.quiet)\n\t\tprintf(\"Container is placed on tmpfs.\\nRebooting will cause \"\n\t\t       \"all changes made to it to be lost!\\n\");\n\n\tif (!arg->daemonize && arg->argc) {\n\t\tclone->want_daemonize(clone, true);\n\t\targ->daemonize = 1;\n\t} else if (!arg->daemonize) {\n\t\tclone->want_daemonize(clone, false);\n\t}\n\n\tstarted = clone->start(clone, 0, NULL);\n\tif (!started)\n\t\tgoto destroy_and_put;\n\n\tif (arg->daemonize && arg->argc) {\n\t\tret = clone->attach_run_wait(clone, &attach_options, arg->argv[0], (const char *const *)arg->argv);\n\t\tif (ret < 0)\n\t\t\tgoto destroy_and_put;\n\t\tclone->shutdown(clone, -1);\n\t}\n\n\tfree_mnts();\n\tlxc_container_put(clone);\n\treturn 0;\n\ndestroy_and_put:\n\tif (started)\n\t\tclone->shutdown(clone, -1);\n\tif (!started || clone->lxc_conf->ephemeral != 1)\n\t\tclone->destroy(clone);\n\tfree_mnts();\n\tlxc_container_put(clone);\n\treturn -1;\n}",
    "includes": [
      "#include <../include/getsubopt.h>",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"arguments.h\"",
      "#include \"confile.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <stdbool.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <stdint.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <getopt.h>",
      "#include <unistd.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int mnt_table_size = 0;",
      "static struct mnts *mnt_table = NULL;",
      "static int my_parser(struct lxc_arguments *args, int c, char *arg);",
      "static struct lxc_arguments my_args = {\n\t.progname = \"lxc-copy\",\n\t.help = \"\\n\\\n--name=NAME [-P lxcpath] -N newname [-p newpath] [-B backingstorage] [-s] [-K] [-M] [-L size [unit]] -- hook options\\n\\\n--name=NAME [-P lxcpath] [-N newname] [-p newpath] [-B backingstorage] -e [-d] [-D] [-K] [-M] [-m {bind,aufs,overlay}=/src:/dest] -- hook options\\n\\\n--name=NAME [-P lxcpath] -N newname -R\\n\\\n\\n\\\nlxc-copy clone a container\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME           NAME of the container\\n\\\n  -N, --newname=NEWNAME     NEWNAME for the restored container\\n\\\n  -p, --newpath=NEWPATH     NEWPATH for the container to be stored\\n\\\n  -R, --rename              rename container\\n\\\n  -s, --snapshot            create snapshot instead of clone\\n\\\n  -F, --foreground          start with current tty attached to /dev/console\\n\\\n  -d, --daemon              daemonize the container (default)\\n\\\n  -e, --ephemeral           start ephemeral container\\n\\\n  -m, --mount               directory to mount into container, either \\n\\\n                            {bind,aufs,overlay}=/src-path or {bind,aufs,overlay}=/src-path:/dst-path\\n\\\n  -B, --backingstorage=TYPE backingstorage type for the container\\n\\\n  -t, --tmpfs               place ephemeral container on a tmpfs\\n\\\n                            (WARNING: On reboot all changes made to the container will be lost.)\\n\\\n  -L, --fssize              size of the new block device for block device containers\\n\\\n  -D, --keedata             pass together with -e start a persistent snapshot \\n\\\n  -K, --keepname            keep the hostname of the original container\\n\\\n  --  hook options          arguments passed to the hook program\\n\\\n  -M, --keepmac             keep the MAC address of the original container\\n\\\n  --rcfile=FILE             Load configuration file FILE\\n\",\n\t.options = my_longopts,\n\t.parser = my_parser,\n\t.task = CLONE,\n\t.daemonize = 1,\n\t.quiet = false,\n\t.tmpfs = false,\n};",
      "static int mk_rand_ovl_dirs(struct mnts *mnts, unsigned int num,\n\t\t\t    struct lxc_arguments *arg);",
      "static int do_clone(struct lxc_container *c, char *newname, char *newpath,\n\t\t    int flags, char *bdevtype, uint64_t fssize, enum task task,\n\t\t    char **args);",
      "static int do_clone_ephemeral(struct lxc_container *c,\n\t\t\t      struct lxc_arguments *arg, char **args,\n\t\t\t      int flags);",
      "static int do_clone_rename(struct lxc_container *c, char *newname);",
      "static int do_clone_task(struct lxc_container *c, enum task task, int flags,\n\t\t\t char **args);",
      "static void free_mnts(void);",
      "static uint64_t get_fssize(char *s);",
      "static char *mount_tmpfs(const char *oldname, const char *newname,\n\t\t\t const char *path, struct lxc_arguments *arg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_container_put",
          "args": [
            "clone"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "312-325",
          "snippet": "int lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_mnts",
          "args": [],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "free_mnts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "539-554",
          "snippet": "static void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int mnt_table_size = 0;",
            "static struct mnts *mnt_table = NULL;",
            "static void free_mnts(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic unsigned int mnt_table_size = 0;\nstatic struct mnts *mnt_table = NULL;\nstatic void free_mnts(void);\n\nstatic void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clone->destroy",
          "args": [
            "clone"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clone->shutdown",
          "args": [
            "clone",
            "-1"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clone->shutdown",
          "args": [
            "clone",
            "-1"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clone->attach_run_wait",
          "args": [
            "clone",
            "&attach_options",
            "arg->argv[0]",
            "(const char *const *)arg->argv"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clone->start",
          "args": [
            "clone",
            "0",
            "NULL"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clone->want_daemonize",
          "args": [
            "clone",
            "false"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clone->want_daemonize",
          "args": [
            "clone",
            "true"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Container is placed on tmpfs.\\nRebooting will cause \"\n\t\t       \"all changes made to it to be lost!\\n\""
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Created %s as clone of %s\\n\"",
            "arg->newname",
            "arg->name"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clone->save_config",
          "args": [
            "clone",
            "NULL"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clone->set_config_item",
          "args": [
            "clone",
            "\"lxc.mount.entry\"",
            "mntentry"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_mnt_entry",
          "args": [
            "n"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "set_mnt_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "318-371",
          "snippet": "static char *set_mnt_entry(struct mnts *m)\n{\n\tchar *mntentry = NULL;\n\tint ret = 0;\n\tsize_t len = 0;\n\n\tif (m->mnt_type == LXC_MNT_AUFS) {\n\t\tlen = strlen(\"  aufs br==rw:=ro,xino=,create=dir\") +\n\t\t      2 * strlen(m->src) + strlen(m->dest) + strlen(m->upper) +\n\t\t      strlen(m->workdir) + 1;\n\n\t\tmntentry = malloc(len);\n\t\tif (!mntentry)\n\t\t\tgoto err;\n\n\t\tret = snprintf(mntentry, len, \"%s %s aufs br=%s=rw:%s=ro,xino=%s,create=dir\",\n\t\t\t       m->src, m->dest, m->upper, m->src, m->workdir);\n\t\tif (ret < 0 || (size_t)ret >= len)\n\t\t\tgoto err;\n\t} else if (m->mnt_type == LXC_MNT_OVL) {\n\t\tlen = strlen(\"  overlay lowerdir=,upperdir=,workdir=,create=dir\") +\n\t\t      2 * strlen(m->src) + strlen(m->dest) + strlen(m->upper) +\n\t\t      strlen(m->workdir) + 1;\n\n\t\tmntentry = malloc(len);\n\t\tif (!mntentry)\n\t\t\tgoto err;\n\n\t\tret = snprintf(mntentry, len, \"%s %s overlay lowerdir=%s,upperdir=%s,workdir=%s,create=dir\",\n\t\t\t\tm->src, m->dest, m->src, m->upper, m->workdir);\n\t\tif (ret < 0 || (size_t)ret >= len)\n\t\t\tgoto err;\n\t} else if (m->mnt_type == LXC_MNT_BIND) {\n\t\tlen = strlen(\"  none bind,optional,, 0 0\") +\n\t\t      strlen(is_dir(m->src) ? \"create=dir\" : \"create=file\") +\n\t\t      strlen(m->src) + strlen(m->dest) + strlen(m->options) + 1;\n\n\t\tmntentry = malloc(len);\n\t\tif (!mntentry)\n\t\t\tgoto err;\n\n\t\tret = snprintf(mntentry, len, \"%s %s none bind,optional,%s,%s 0 0\",\n\t\t\t\tm->src,\tm->dest, m->options,\n\t\t\t\tis_dir(m->src) ? \"create=dir\" : \"create=file\");\n\t\tif (ret < 0 || (size_t)ret >= len)\n\t\t\tgoto err;\n\t}\n\n\treturn mntentry;\n\nerr:\n\tfree(mntentry);\n\treturn NULL;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *set_mnt_entry(struct mnts *m);",
            "static uint64_t get_fssize(char *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic char *set_mnt_entry(struct mnts *m);\nstatic uint64_t get_fssize(char *s);\n\nstatic char *set_mnt_entry(struct mnts *m)\n{\n\tchar *mntentry = NULL;\n\tint ret = 0;\n\tsize_t len = 0;\n\n\tif (m->mnt_type == LXC_MNT_AUFS) {\n\t\tlen = strlen(\"  aufs br==rw:=ro,xino=,create=dir\") +\n\t\t      2 * strlen(m->src) + strlen(m->dest) + strlen(m->upper) +\n\t\t      strlen(m->workdir) + 1;\n\n\t\tmntentry = malloc(len);\n\t\tif (!mntentry)\n\t\t\tgoto err;\n\n\t\tret = snprintf(mntentry, len, \"%s %s aufs br=%s=rw:%s=ro,xino=%s,create=dir\",\n\t\t\t       m->src, m->dest, m->upper, m->src, m->workdir);\n\t\tif (ret < 0 || (size_t)ret >= len)\n\t\t\tgoto err;\n\t} else if (m->mnt_type == LXC_MNT_OVL) {\n\t\tlen = strlen(\"  overlay lowerdir=,upperdir=,workdir=,create=dir\") +\n\t\t      2 * strlen(m->src) + strlen(m->dest) + strlen(m->upper) +\n\t\t      strlen(m->workdir) + 1;\n\n\t\tmntentry = malloc(len);\n\t\tif (!mntentry)\n\t\t\tgoto err;\n\n\t\tret = snprintf(mntentry, len, \"%s %s overlay lowerdir=%s,upperdir=%s,workdir=%s,create=dir\",\n\t\t\t\tm->src, m->dest, m->src, m->upper, m->workdir);\n\t\tif (ret < 0 || (size_t)ret >= len)\n\t\t\tgoto err;\n\t} else if (m->mnt_type == LXC_MNT_BIND) {\n\t\tlen = strlen(\"  none bind,optional,, 0 0\") +\n\t\t      strlen(is_dir(m->src) ? \"create=dir\" : \"create=file\") +\n\t\t      strlen(m->src) + strlen(m->dest) + strlen(m->options) + 1;\n\n\t\tmntentry = malloc(len);\n\t\tif (!mntentry)\n\t\t\tgoto err;\n\n\t\tret = snprintf(mntentry, len, \"%s %s none bind,optional,%s,%s 0 0\",\n\t\t\t\tm->src,\tm->dest, m->options,\n\t\t\t\tis_dir(m->src) ? \"create=dir\" : \"create=file\");\n\t\tif (ret < 0 || (size_t)ret >= len)\n\t\t\tgoto err;\n\t}\n\n\treturn mntentry;\n\nerr:\n\tfree(mntentry);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mk_rand_ovl_dirs",
          "args": [
            "mnt_table",
            "mnt_table_size",
            "arg"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "mk_rand_ovl_dirs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "266-301",
          "snippet": "static int mk_rand_ovl_dirs(struct mnts *mnts, unsigned int num, struct lxc_arguments *arg)\n{\n\tchar upperdir[MAXPATHLEN];\n\tchar workdir[MAXPATHLEN];\n\tunsigned int i;\n\tint ret;\n\tstruct mnts *m = NULL;\n\n\tfor (i = 0, m = mnts; i < num; i++, m++) {\n\t\tif ((m->mnt_type == LXC_MNT_OVL) || (m->mnt_type == LXC_MNT_AUFS)) {\n\t\t\tret = snprintf(upperdir, MAXPATHLEN, \"%s/%s/delta#XXXXXX\",\n\t\t\t\t\targ->newpath, arg->newname);\n\t\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\t\treturn -1;\n\t\t\tif (!mkdtemp(upperdir))\n\t\t\t\treturn -1;\n\t\t\tm->upper = strdup(upperdir);\n\t\t\tif (!m->upper)\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tif (m->mnt_type == LXC_MNT_OVL) {\n\t\t\tret = snprintf(workdir, MAXPATHLEN, \"%s/%s/work#XXXXXX\",\n\t\t\t\t\targ->newpath, arg->newname);\n\t\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\t\treturn -1;\n\t\t\tif (!mkdtemp(workdir))\n\t\t\t\treturn -1;\n\t\t\tm->workdir = strdup(workdir);\n\t\t\tif (!m->workdir)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int my_parser(struct lxc_arguments *args, int c, char *arg);",
            "static int mk_rand_ovl_dirs(struct mnts *mnts, unsigned int num,\n\t\t\t    struct lxc_arguments *arg);",
            "static char *set_mnt_entry(struct mnts *m);",
            "static int do_clone_rename(struct lxc_container *c, char *newname);",
            "static uint64_t get_fssize(char *s);",
            "static char *mount_tmpfs(const char *oldname, const char *newname,\n\t\t\t const char *path, struct lxc_arguments *arg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic int my_parser(struct lxc_arguments *args, int c, char *arg);\nstatic int mk_rand_ovl_dirs(struct mnts *mnts, unsigned int num,\n\t\t\t    struct lxc_arguments *arg);\nstatic char *set_mnt_entry(struct mnts *m);\nstatic int do_clone_rename(struct lxc_container *c, char *newname);\nstatic uint64_t get_fssize(char *s);\nstatic char *mount_tmpfs(const char *oldname, const char *newname,\n\t\t\t const char *path, struct lxc_arguments *arg);\n\nstatic int mk_rand_ovl_dirs(struct mnts *mnts, unsigned int num, struct lxc_arguments *arg)\n{\n\tchar upperdir[MAXPATHLEN];\n\tchar workdir[MAXPATHLEN];\n\tunsigned int i;\n\tint ret;\n\tstruct mnts *m = NULL;\n\n\tfor (i = 0, m = mnts; i < num; i++, m++) {\n\t\tif ((m->mnt_type == LXC_MNT_OVL) || (m->mnt_type == LXC_MNT_AUFS)) {\n\t\t\tret = snprintf(upperdir, MAXPATHLEN, \"%s/%s/delta#XXXXXX\",\n\t\t\t\t\targ->newpath, arg->newname);\n\t\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\t\treturn -1;\n\t\t\tif (!mkdtemp(upperdir))\n\t\t\t\treturn -1;\n\t\t\tm->upper = strdup(upperdir);\n\t\t\tif (!m->upper)\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tif (m->mnt_type == LXC_MNT_OVL) {\n\t\t\tret = snprintf(workdir, MAXPATHLEN, \"%s/%s/work#XXXXXX\",\n\t\t\t\t\targ->newpath, arg->newname);\n\t\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\t\treturn -1;\n\t\t\tif (!mkdtemp(workdir))\n\t\t\t\treturn -1;\n\t\t\tm->workdir = strdup(workdir);\n\t\t\tif (!m->workdir)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clone->set_config_item",
          "args": [
            "clone",
            "\"lxc.ephemeral\"",
            "\"1\""
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clone->set_config_item",
          "args": [
            "clone",
            "\"lxc.hook.pre-mount\"",
            "premount"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount_tmpfs",
          "args": [
            "arg->name",
            "arg->newname",
            "arg->newpath",
            "arg"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "mount_tmpfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "818-893",
          "snippet": "static char *mount_tmpfs(const char *oldname, const char *newname,\n\t\t\t const char *path, struct lxc_arguments *arg)\n{\n\tint ret, fd;\n\tsize_t len;\n\tchar *premount = NULL;\n\tFILE *fp;\n\n\tif (arg->tmpfs && arg->keepdata) {\n\t\tfprintf(stderr, \"%s\\n\", \"A container can only be placed on a \"\n\t\t\t\t\t\"tmpfs when storage backend is overlay \"\n\t\t\t\t\t\"or aufs.\");\n\t\tgoto err_free;\n\t}\n\n\tif (arg->tmpfs && !arg->bdevtype) {\n\t\targ->bdevtype = \"overlayfs\";\n\t} else if (arg->tmpfs && arg->bdevtype && strcmp(arg->bdevtype, \"overlayfs\") && strcmp(arg->bdevtype, \"aufs\")) {\n\t\tfprintf(stderr, \"%s\\n\", \"A container can only be placed on a \"\n\t\t\t\t\t\"tmpfs when storage backend is overlay \"\n\t\t\t\t\t\"or aufs.\");\n\t\tgoto err_free;\n\t}\n\n\tlen = strlen(path) + strlen(newname) + strlen(\"pre-start-XXXXXX\") + /* //\\0 */ 3;\n\tpremount = malloc(len);\n\tif (!premount)\n\t\tgoto err_free;\n\n\tret = snprintf(premount, len, \"%s/%s/pre-start-XXXXXX\", path, newname);\n\tif (ret < 0 || (size_t)ret >= len)\n\t\tgoto err_free;\n\n\tfd = mkstemp(premount);\n\tif (fd < 0)\n\t\tgoto err_free;\n\n\tif (fcntl(fd, F_SETFD, FD_CLOEXEC)) {\n\t\tSYSERROR(\"Failed to set close-on-exec on file descriptor.\");\n\t\tgoto err_close;\n\t}\n\n\tif (chmod(premount, 0755) < 0)\n\t\tgoto err_close;\n\n\tfp = fdopen(fd, \"r+\");\n\tif (!fp)\n\t\tgoto err_close;\n\tfd = -1;\n\n\tret = fprintf(fp, \"#! /bin/sh\\n\"\n\t\t\t  \"mount -n -t tmpfs -o mode=0755 none %s/%s\\n\",\n\t\t      path, newname);\n\tif (ret < 0)\n\t\tgoto err_close;\n\n\tif (!arg->keepname) {\n\t\tret = fprintf(fp, \"mkdir -p %s/%s/delta0/etc\\n\"\n\t\t\t\t  \"echo %s > %s/%s/delta0/etc/hostname\\n\",\n\t\t\t      path, newname, newname, path, newname);\n\t\tif (ret < 0)\n\t\t\tgoto err_close;\n\t}\n\n\tfclose(fp);\n\treturn premount;\n\nerr_close:\n\tif (fd > 0)\n\t\tclose(fd);\n\telse\n\t\tfclose(fp);\nerr_free:\n\tfree(premount);\n\treturn NULL;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int my_parser(struct lxc_arguments *args, int c, char *arg);",
            "static int mk_rand_ovl_dirs(struct mnts *mnts, unsigned int num,\n\t\t\t    struct lxc_arguments *arg);",
            "static int do_clone_rename(struct lxc_container *c, char *newname);",
            "static uint64_t get_fssize(char *s);",
            "static char *mount_tmpfs(const char *oldname, const char *newname,\n\t\t\t const char *path, struct lxc_arguments *arg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic int my_parser(struct lxc_arguments *args, int c, char *arg);\nstatic int mk_rand_ovl_dirs(struct mnts *mnts, unsigned int num,\n\t\t\t    struct lxc_arguments *arg);\nstatic int do_clone_rename(struct lxc_container *c, char *newname);\nstatic uint64_t get_fssize(char *s);\nstatic char *mount_tmpfs(const char *oldname, const char *newname,\n\t\t\t const char *path, struct lxc_arguments *arg);\n\nstatic char *mount_tmpfs(const char *oldname, const char *newname,\n\t\t\t const char *path, struct lxc_arguments *arg)\n{\n\tint ret, fd;\n\tsize_t len;\n\tchar *premount = NULL;\n\tFILE *fp;\n\n\tif (arg->tmpfs && arg->keepdata) {\n\t\tfprintf(stderr, \"%s\\n\", \"A container can only be placed on a \"\n\t\t\t\t\t\"tmpfs when storage backend is overlay \"\n\t\t\t\t\t\"or aufs.\");\n\t\tgoto err_free;\n\t}\n\n\tif (arg->tmpfs && !arg->bdevtype) {\n\t\targ->bdevtype = \"overlayfs\";\n\t} else if (arg->tmpfs && arg->bdevtype && strcmp(arg->bdevtype, \"overlayfs\") && strcmp(arg->bdevtype, \"aufs\")) {\n\t\tfprintf(stderr, \"%s\\n\", \"A container can only be placed on a \"\n\t\t\t\t\t\"tmpfs when storage backend is overlay \"\n\t\t\t\t\t\"or aufs.\");\n\t\tgoto err_free;\n\t}\n\n\tlen = strlen(path) + strlen(newname) + strlen(\"pre-start-XXXXXX\") + /* //\\0 */ 3;\n\tpremount = malloc(len);\n\tif (!premount)\n\t\tgoto err_free;\n\n\tret = snprintf(premount, len, \"%s/%s/pre-start-XXXXXX\", path, newname);\n\tif (ret < 0 || (size_t)ret >= len)\n\t\tgoto err_free;\n\n\tfd = mkstemp(premount);\n\tif (fd < 0)\n\t\tgoto err_free;\n\n\tif (fcntl(fd, F_SETFD, FD_CLOEXEC)) {\n\t\tSYSERROR(\"Failed to set close-on-exec on file descriptor.\");\n\t\tgoto err_close;\n\t}\n\n\tif (chmod(premount, 0755) < 0)\n\t\tgoto err_close;\n\n\tfp = fdopen(fd, \"r+\");\n\tif (!fp)\n\t\tgoto err_close;\n\tfd = -1;\n\n\tret = fprintf(fp, \"#! /bin/sh\\n\"\n\t\t\t  \"mount -n -t tmpfs -o mode=0755 none %s/%s\\n\",\n\t\t      path, newname);\n\tif (ret < 0)\n\t\tgoto err_close;\n\n\tif (!arg->keepname) {\n\t\tret = fprintf(fp, \"mkdir -p %s/%s/delta0/etc\\n\"\n\t\t\t\t  \"echo %s > %s/%s/delta0/etc/hostname\\n\",\n\t\t\t      path, newname, newname, path, newname);\n\t\tif (ret < 0)\n\t\t\tgoto err_close;\n\t}\n\n\tfclose(fp);\n\treturn premount;\n\nerr_close:\n\tif (fd > 0)\n\t\tclose(fd);\n\telse\n\t\tfclose(fp);\nerr_free:\n\tfree(premount);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Cannot currently use tmpfs with %s storage backend.\\n\"",
            "bdev"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "bdev",
            "\"dir\""
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->clone",
          "args": [
            "c",
            "arg->newname",
            "arg->newpath",
            "flags",
            "arg->bdevtype",
            "NULL",
            "arg->fssize",
            "args"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "arg->newpath"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove",
          "args": [
            "randname"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "remove_trailing_newlines",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "62-70",
          "snippet": "static void remove_trailing_newlines(char *l)\n{\n\tchar *p = l;\n\n\twhile (*p)\n\t\tp++;\n\twhile (--p >= l && *p == '\\n')\n\t\t*p = '\\0';\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char *p;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nchar *p;\n\nstatic void remove_trailing_newlines(char *l)\n{\n\tchar *p = l;\n\n\twhile (*p)\n\t\tp++;\n\twhile (--p >= l && *p == '\\n')\n\t\t*p = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "randname",
            "0770"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdtemp",
          "args": [
            "randname"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "randname",
            "MAXPATHLEN",
            "\"%s/%s_XXXXXX\"",
            "arg->newpath",
            "arg->name"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic unsigned int mnt_table_size = 0;\nstatic struct mnts *mnt_table = NULL;\nstatic int my_parser(struct lxc_arguments *args, int c, char *arg);\nstatic struct lxc_arguments my_args = {\n\t.progname = \"lxc-copy\",\n\t.help = \"\\n\\\n--name=NAME [-P lxcpath] -N newname [-p newpath] [-B backingstorage] [-s] [-K] [-M] [-L size [unit]] -- hook options\\n\\\n--name=NAME [-P lxcpath] [-N newname] [-p newpath] [-B backingstorage] -e [-d] [-D] [-K] [-M] [-m {bind,aufs,overlay}=/src:/dest] -- hook options\\n\\\n--name=NAME [-P lxcpath] -N newname -R\\n\\\n\\n\\\nlxc-copy clone a container\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME           NAME of the container\\n\\\n  -N, --newname=NEWNAME     NEWNAME for the restored container\\n\\\n  -p, --newpath=NEWPATH     NEWPATH for the container to be stored\\n\\\n  -R, --rename              rename container\\n\\\n  -s, --snapshot            create snapshot instead of clone\\n\\\n  -F, --foreground          start with current tty attached to /dev/console\\n\\\n  -d, --daemon              daemonize the container (default)\\n\\\n  -e, --ephemeral           start ephemeral container\\n\\\n  -m, --mount               directory to mount into container, either \\n\\\n                            {bind,aufs,overlay}=/src-path or {bind,aufs,overlay}=/src-path:/dst-path\\n\\\n  -B, --backingstorage=TYPE backingstorage type for the container\\n\\\n  -t, --tmpfs               place ephemeral container on a tmpfs\\n\\\n                            (WARNING: On reboot all changes made to the container will be lost.)\\n\\\n  -L, --fssize              size of the new block device for block device containers\\n\\\n  -D, --keedata             pass together with -e start a persistent snapshot \\n\\\n  -K, --keepname            keep the hostname of the original container\\n\\\n  --  hook options          arguments passed to the hook program\\n\\\n  -M, --keepmac             keep the MAC address of the original container\\n\\\n  --rcfile=FILE             Load configuration file FILE\\n\",\n\t.options = my_longopts,\n\t.parser = my_parser,\n\t.task = CLONE,\n\t.daemonize = 1,\n\t.quiet = false,\n\t.tmpfs = false,\n};\nstatic int mk_rand_ovl_dirs(struct mnts *mnts, unsigned int num,\n\t\t\t    struct lxc_arguments *arg);\nstatic int do_clone(struct lxc_container *c, char *newname, char *newpath,\n\t\t    int flags, char *bdevtype, uint64_t fssize, enum task task,\n\t\t    char **args);\nstatic int do_clone_ephemeral(struct lxc_container *c,\n\t\t\t      struct lxc_arguments *arg, char **args,\n\t\t\t      int flags);\nstatic int do_clone_rename(struct lxc_container *c, char *newname);\nstatic int do_clone_task(struct lxc_container *c, enum task task, int flags,\n\t\t\t char **args);\nstatic void free_mnts(void);\nstatic uint64_t get_fssize(char *s);\nstatic char *mount_tmpfs(const char *oldname, const char *newname,\n\t\t\t const char *path, struct lxc_arguments *arg);\n\nstatic int do_clone_ephemeral(struct lxc_container *c,\n\t\tstruct lxc_arguments *arg, char **args, int flags)\n{\n\tchar *bdev;\n\tchar *premount;\n\tchar randname[MAXPATHLEN];\n\tunsigned int i;\n\tint ret = 0;\n\tbool bret = true, started = false;\n\tstruct lxc_container *clone;\n\tlxc_attach_options_t attach_options = LXC_ATTACH_OPTIONS_DEFAULT;\n\tattach_options.env_policy = LXC_ATTACH_CLEAR_ENV;\n\n\tif (!arg->newname) {\n\t\tret = snprintf(randname, MAXPATHLEN, \"%s/%s_XXXXXX\", arg->newpath, arg->name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn -1;\n\t\tif (!mkdtemp(randname))\n\t\t\treturn -1;\n\t\tif (chmod(randname, 0770) < 0) {\n\t\t\tremove(randname);\n\t\t\treturn -1;\n\t\t}\n\t\targ->newname = randname + strlen(arg->newpath) + 1;\n\t}\n\n\tclone = c->clone(c, arg->newname, arg->newpath, flags,\n\t\t\t arg->bdevtype, NULL, arg->fssize, args);\n\tif (!clone)\n\t\treturn -1;\n\n\tif (arg->tmpfs) {\n\t\tbdev = c->lxc_conf->rootfs.bdev_type;\n\t\tif (bdev && strcmp(bdev, \"dir\")) {\n\t\t\tfprintf(stderr, \"Cannot currently use tmpfs with %s storage backend.\\n\", bdev);\n\t\t\tgoto destroy_and_put;\n\t\t}\n\n\t\tpremount = mount_tmpfs(arg->name, arg->newname, arg->newpath, arg);\n\t\tif (!premount)\n\t\t\tgoto destroy_and_put;\n\n\t\tbret = clone->set_config_item(clone, \"lxc.hook.pre-mount\", premount);\n\t\tfree(premount);\n\t\tif (!bret)\n\t\t\tgoto destroy_and_put;\n\t}\n\n\tif (!arg->keepdata)\n\t\tif (!clone->set_config_item(clone, \"lxc.ephemeral\", \"1\"))\n\t\t\tgoto destroy_and_put;\n\n\t/* allocate and create random upper- and workdirs for overlay mounts */\n\tif (mk_rand_ovl_dirs(mnt_table, mnt_table_size, arg) < 0)\n\t\tgoto destroy_and_put;\n\n\t/* allocate and set mount entries */\n\tstruct mnts *n = NULL;\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tchar *mntentry = NULL;\n\t\tmntentry = set_mnt_entry(n);\n\t\tif (!mntentry)\n\t\t\tgoto destroy_and_put;\n\t\tbret = clone->set_config_item(clone, \"lxc.mount.entry\", mntentry);\n\t\tfree(mntentry);\n\t\tif (!bret)\n\t\t\tgoto destroy_and_put;\n\t}\n\n\tif (!clone->save_config(clone, NULL))\n\t\tgoto destroy_and_put;\n\n\tif (!my_args.quiet)\n\t\tprintf(\"Created %s as clone of %s\\n\", arg->newname, arg->name);\n\n\tif (arg->tmpfs && !my_args.quiet)\n\t\tprintf(\"Container is placed on tmpfs.\\nRebooting will cause \"\n\t\t       \"all changes made to it to be lost!\\n\");\n\n\tif (!arg->daemonize && arg->argc) {\n\t\tclone->want_daemonize(clone, true);\n\t\targ->daemonize = 1;\n\t} else if (!arg->daemonize) {\n\t\tclone->want_daemonize(clone, false);\n\t}\n\n\tstarted = clone->start(clone, 0, NULL);\n\tif (!started)\n\t\tgoto destroy_and_put;\n\n\tif (arg->daemonize && arg->argc) {\n\t\tret = clone->attach_run_wait(clone, &attach_options, arg->argv[0], (const char *const *)arg->argv);\n\t\tif (ret < 0)\n\t\t\tgoto destroy_and_put;\n\t\tclone->shutdown(clone, -1);\n\t}\n\n\tfree_mnts();\n\tlxc_container_put(clone);\n\treturn 0;\n\ndestroy_and_put:\n\tif (started)\n\t\tclone->shutdown(clone, -1);\n\tif (!started || clone->lxc_conf->ephemeral != 1)\n\t\tclone->destroy(clone);\n\tfree_mnts();\n\tlxc_container_put(clone);\n\treturn -1;\n}"
  },
  {
    "function_name": "do_clone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
    "lines": "373-392",
    "snippet": "static int do_clone(struct lxc_container *c, char *newname, char *newpath,\n\t\t    int flags, char *bdevtype, uint64_t fssize, enum task task,\n\t\t    char **args)\n{\n\tstruct lxc_container *clone;\n\n\tclone = c->clone(c, newname, newpath, flags, bdevtype, NULL, fssize,\n\t\t\t args);\n\tif (!clone) {\n\t\tif (!my_args.quiet)\n\t\t\tfprintf(stderr, \"clone failed\\n\");\n\t\treturn -1;\n\t}\n\n\tINFO(\"Created %s as %s of %s\\n\", newname, task ? \"snapshot\" : \"copy\", c->name);\n\n\tlxc_container_put(clone);\n\n\treturn 0;\n}",
    "includes": [
      "#include <../include/getsubopt.h>",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"arguments.h\"",
      "#include \"confile.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <stdbool.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <stdint.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <getopt.h>",
      "#include <unistd.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lxc_arguments my_args = {\n\t.progname = \"lxc-copy\",\n\t.help = \"\\n\\\n--name=NAME [-P lxcpath] -N newname [-p newpath] [-B backingstorage] [-s] [-K] [-M] [-L size [unit]] -- hook options\\n\\\n--name=NAME [-P lxcpath] [-N newname] [-p newpath] [-B backingstorage] -e [-d] [-D] [-K] [-M] [-m {bind,aufs,overlay}=/src:/dest] -- hook options\\n\\\n--name=NAME [-P lxcpath] -N newname -R\\n\\\n\\n\\\nlxc-copy clone a container\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME           NAME of the container\\n\\\n  -N, --newname=NEWNAME     NEWNAME for the restored container\\n\\\n  -p, --newpath=NEWPATH     NEWPATH for the container to be stored\\n\\\n  -R, --rename              rename container\\n\\\n  -s, --snapshot            create snapshot instead of clone\\n\\\n  -F, --foreground          start with current tty attached to /dev/console\\n\\\n  -d, --daemon              daemonize the container (default)\\n\\\n  -e, --ephemeral           start ephemeral container\\n\\\n  -m, --mount               directory to mount into container, either \\n\\\n                            {bind,aufs,overlay}=/src-path or {bind,aufs,overlay}=/src-path:/dst-path\\n\\\n  -B, --backingstorage=TYPE backingstorage type for the container\\n\\\n  -t, --tmpfs               place ephemeral container on a tmpfs\\n\\\n                            (WARNING: On reboot all changes made to the container will be lost.)\\n\\\n  -L, --fssize              size of the new block device for block device containers\\n\\\n  -D, --keedata             pass together with -e start a persistent snapshot \\n\\\n  -K, --keepname            keep the hostname of the original container\\n\\\n  --  hook options          arguments passed to the hook program\\n\\\n  -M, --keepmac             keep the MAC address of the original container\\n\\\n  --rcfile=FILE             Load configuration file FILE\\n\",\n\t.options = my_longopts,\n\t.parser = my_parser,\n\t.task = CLONE,\n\t.daemonize = 1,\n\t.quiet = false,\n\t.tmpfs = false,\n};",
      "static int do_clone(struct lxc_container *c, char *newname, char *newpath,\n\t\t    int flags, char *bdevtype, uint64_t fssize, enum task task,\n\t\t    char **args);",
      "static int do_clone_ephemeral(struct lxc_container *c,\n\t\t\t      struct lxc_arguments *arg, char **args,\n\t\t\t      int flags);",
      "static int do_clone_rename(struct lxc_container *c, char *newname);",
      "static int do_clone_task(struct lxc_container *c, enum task task, int flags,\n\t\t\t char **args);",
      "static uint64_t get_fssize(char *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_container_put",
          "args": [
            "clone"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "312-325",
          "snippet": "int lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Created %s as %s of %s\\n\"",
            "newname",
            "task ? \"snapshot\" : \"copy\"",
            "c->name"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"clone failed\\n\""
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->clone",
          "args": [
            "c",
            "newname",
            "newpath",
            "flags",
            "bdevtype",
            "NULL",
            "fssize",
            "args"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic struct lxc_arguments my_args = {\n\t.progname = \"lxc-copy\",\n\t.help = \"\\n\\\n--name=NAME [-P lxcpath] -N newname [-p newpath] [-B backingstorage] [-s] [-K] [-M] [-L size [unit]] -- hook options\\n\\\n--name=NAME [-P lxcpath] [-N newname] [-p newpath] [-B backingstorage] -e [-d] [-D] [-K] [-M] [-m {bind,aufs,overlay}=/src:/dest] -- hook options\\n\\\n--name=NAME [-P lxcpath] -N newname -R\\n\\\n\\n\\\nlxc-copy clone a container\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME           NAME of the container\\n\\\n  -N, --newname=NEWNAME     NEWNAME for the restored container\\n\\\n  -p, --newpath=NEWPATH     NEWPATH for the container to be stored\\n\\\n  -R, --rename              rename container\\n\\\n  -s, --snapshot            create snapshot instead of clone\\n\\\n  -F, --foreground          start with current tty attached to /dev/console\\n\\\n  -d, --daemon              daemonize the container (default)\\n\\\n  -e, --ephemeral           start ephemeral container\\n\\\n  -m, --mount               directory to mount into container, either \\n\\\n                            {bind,aufs,overlay}=/src-path or {bind,aufs,overlay}=/src-path:/dst-path\\n\\\n  -B, --backingstorage=TYPE backingstorage type for the container\\n\\\n  -t, --tmpfs               place ephemeral container on a tmpfs\\n\\\n                            (WARNING: On reboot all changes made to the container will be lost.)\\n\\\n  -L, --fssize              size of the new block device for block device containers\\n\\\n  -D, --keedata             pass together with -e start a persistent snapshot \\n\\\n  -K, --keepname            keep the hostname of the original container\\n\\\n  --  hook options          arguments passed to the hook program\\n\\\n  -M, --keepmac             keep the MAC address of the original container\\n\\\n  --rcfile=FILE             Load configuration file FILE\\n\",\n\t.options = my_longopts,\n\t.parser = my_parser,\n\t.task = CLONE,\n\t.daemonize = 1,\n\t.quiet = false,\n\t.tmpfs = false,\n};\nstatic int do_clone(struct lxc_container *c, char *newname, char *newpath,\n\t\t    int flags, char *bdevtype, uint64_t fssize, enum task task,\n\t\t    char **args);\nstatic int do_clone_ephemeral(struct lxc_container *c,\n\t\t\t      struct lxc_arguments *arg, char **args,\n\t\t\t      int flags);\nstatic int do_clone_rename(struct lxc_container *c, char *newname);\nstatic int do_clone_task(struct lxc_container *c, enum task task, int flags,\n\t\t\t char **args);\nstatic uint64_t get_fssize(char *s);\n\nstatic int do_clone(struct lxc_container *c, char *newname, char *newpath,\n\t\t    int flags, char *bdevtype, uint64_t fssize, enum task task,\n\t\t    char **args)\n{\n\tstruct lxc_container *clone;\n\n\tclone = c->clone(c, newname, newpath, flags, bdevtype, NULL, fssize,\n\t\t\t args);\n\tif (!clone) {\n\t\tif (!my_args.quiet)\n\t\t\tfprintf(stderr, \"clone failed\\n\");\n\t\treturn -1;\n\t}\n\n\tINFO(\"Created %s as %s of %s\\n\", newname, task ? \"snapshot\" : \"copy\", c->name);\n\n\tlxc_container_put(clone);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "set_mnt_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
    "lines": "318-371",
    "snippet": "static char *set_mnt_entry(struct mnts *m)\n{\n\tchar *mntentry = NULL;\n\tint ret = 0;\n\tsize_t len = 0;\n\n\tif (m->mnt_type == LXC_MNT_AUFS) {\n\t\tlen = strlen(\"  aufs br==rw:=ro,xino=,create=dir\") +\n\t\t      2 * strlen(m->src) + strlen(m->dest) + strlen(m->upper) +\n\t\t      strlen(m->workdir) + 1;\n\n\t\tmntentry = malloc(len);\n\t\tif (!mntentry)\n\t\t\tgoto err;\n\n\t\tret = snprintf(mntentry, len, \"%s %s aufs br=%s=rw:%s=ro,xino=%s,create=dir\",\n\t\t\t       m->src, m->dest, m->upper, m->src, m->workdir);\n\t\tif (ret < 0 || (size_t)ret >= len)\n\t\t\tgoto err;\n\t} else if (m->mnt_type == LXC_MNT_OVL) {\n\t\tlen = strlen(\"  overlay lowerdir=,upperdir=,workdir=,create=dir\") +\n\t\t      2 * strlen(m->src) + strlen(m->dest) + strlen(m->upper) +\n\t\t      strlen(m->workdir) + 1;\n\n\t\tmntentry = malloc(len);\n\t\tif (!mntentry)\n\t\t\tgoto err;\n\n\t\tret = snprintf(mntentry, len, \"%s %s overlay lowerdir=%s,upperdir=%s,workdir=%s,create=dir\",\n\t\t\t\tm->src, m->dest, m->src, m->upper, m->workdir);\n\t\tif (ret < 0 || (size_t)ret >= len)\n\t\t\tgoto err;\n\t} else if (m->mnt_type == LXC_MNT_BIND) {\n\t\tlen = strlen(\"  none bind,optional,, 0 0\") +\n\t\t      strlen(is_dir(m->src) ? \"create=dir\" : \"create=file\") +\n\t\t      strlen(m->src) + strlen(m->dest) + strlen(m->options) + 1;\n\n\t\tmntentry = malloc(len);\n\t\tif (!mntentry)\n\t\t\tgoto err;\n\n\t\tret = snprintf(mntentry, len, \"%s %s none bind,optional,%s,%s 0 0\",\n\t\t\t\tm->src,\tm->dest, m->options,\n\t\t\t\tis_dir(m->src) ? \"create=dir\" : \"create=file\");\n\t\tif (ret < 0 || (size_t)ret >= len)\n\t\t\tgoto err;\n\t}\n\n\treturn mntentry;\n\nerr:\n\tfree(mntentry);\n\treturn NULL;\n}",
    "includes": [
      "#include <../include/getsubopt.h>",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"arguments.h\"",
      "#include \"confile.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <stdbool.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <stdint.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <getopt.h>",
      "#include <unistd.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *set_mnt_entry(struct mnts *m);",
      "static uint64_t get_fssize(char *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "mntentry"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "free_mnts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "539-554",
          "snippet": "static void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int mnt_table_size = 0;",
            "static struct mnts *mnt_table = NULL;",
            "static void free_mnts(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic unsigned int mnt_table_size = 0;\nstatic struct mnts *mnt_table = NULL;\nstatic void free_mnts(void);\n\nstatic void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "mntentry",
            "len",
            "\"%s %s none bind,optional,%s,%s 0 0\"",
            "m->src",
            "m->dest",
            "m->options",
            "is_dir(m->src) ? \"create=dir\" : \"create=file\""
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_dir",
          "args": [
            "m->src"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "is_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1364-1371",
          "snippet": "int is_dir(const char *path)\n{\n\tstruct stat statbuf;\n\tint ret = stat(path, &statbuf);\n\tif (ret == 0 && S_ISDIR(statbuf.st_mode))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool btrfs_try_remove_subvol(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nint is_dir(const char *path)\n{\n\tstruct stat statbuf;\n\tint ret = stat(path, &statbuf);\n\tif (ret == 0 && S_ISDIR(statbuf.st_mode))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "m->options"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "m->dest"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "m->src"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "is_dir(m->src) ? \"create=dir\" : \"create=file\""
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"  none bind,optional,, 0 0\""
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "mntentry",
            "len",
            "\"%s %s overlay lowerdir=%s,upperdir=%s,workdir=%s,create=dir\"",
            "m->src",
            "m->dest",
            "m->src",
            "m->upper",
            "m->workdir"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "m->workdir"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "m->upper"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "m->dest"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "m->src"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"  overlay lowerdir=,upperdir=,workdir=,create=dir\""
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "mntentry",
            "len",
            "\"%s %s aufs br=%s=rw:%s=ro,xino=%s,create=dir\"",
            "m->src",
            "m->dest",
            "m->upper",
            "m->src",
            "m->workdir"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "m->workdir"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "m->upper"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "m->dest"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "m->src"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"  aufs br==rw:=ro,xino=,create=dir\""
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic char *set_mnt_entry(struct mnts *m);\nstatic uint64_t get_fssize(char *s);\n\nstatic char *set_mnt_entry(struct mnts *m)\n{\n\tchar *mntentry = NULL;\n\tint ret = 0;\n\tsize_t len = 0;\n\n\tif (m->mnt_type == LXC_MNT_AUFS) {\n\t\tlen = strlen(\"  aufs br==rw:=ro,xino=,create=dir\") +\n\t\t      2 * strlen(m->src) + strlen(m->dest) + strlen(m->upper) +\n\t\t      strlen(m->workdir) + 1;\n\n\t\tmntentry = malloc(len);\n\t\tif (!mntentry)\n\t\t\tgoto err;\n\n\t\tret = snprintf(mntentry, len, \"%s %s aufs br=%s=rw:%s=ro,xino=%s,create=dir\",\n\t\t\t       m->src, m->dest, m->upper, m->src, m->workdir);\n\t\tif (ret < 0 || (size_t)ret >= len)\n\t\t\tgoto err;\n\t} else if (m->mnt_type == LXC_MNT_OVL) {\n\t\tlen = strlen(\"  overlay lowerdir=,upperdir=,workdir=,create=dir\") +\n\t\t      2 * strlen(m->src) + strlen(m->dest) + strlen(m->upper) +\n\t\t      strlen(m->workdir) + 1;\n\n\t\tmntentry = malloc(len);\n\t\tif (!mntentry)\n\t\t\tgoto err;\n\n\t\tret = snprintf(mntentry, len, \"%s %s overlay lowerdir=%s,upperdir=%s,workdir=%s,create=dir\",\n\t\t\t\tm->src, m->dest, m->src, m->upper, m->workdir);\n\t\tif (ret < 0 || (size_t)ret >= len)\n\t\t\tgoto err;\n\t} else if (m->mnt_type == LXC_MNT_BIND) {\n\t\tlen = strlen(\"  none bind,optional,, 0 0\") +\n\t\t      strlen(is_dir(m->src) ? \"create=dir\" : \"create=file\") +\n\t\t      strlen(m->src) + strlen(m->dest) + strlen(m->options) + 1;\n\n\t\tmntentry = malloc(len);\n\t\tif (!mntentry)\n\t\t\tgoto err;\n\n\t\tret = snprintf(mntentry, len, \"%s %s none bind,optional,%s,%s 0 0\",\n\t\t\t\tm->src,\tm->dest, m->options,\n\t\t\t\tis_dir(m->src) ? \"create=dir\" : \"create=file\");\n\t\tif (ret < 0 || (size_t)ret >= len)\n\t\t\tgoto err;\n\t}\n\n\treturn mntentry;\n\nerr:\n\tfree(mntentry);\n\treturn NULL;\n}"
  },
  {
    "function_name": "construct_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
    "lines": "303-316",
    "snippet": "static char *construct_path(char *path, bool as_prefix)\n{\n\tchar **components = NULL;\n\tchar *cleanpath = NULL;\n\n\tcomponents = lxc_normalize_path(path);\n\tif (!components)\n\t\treturn NULL;\n\n\tcleanpath = lxc_string_join(\"/\", (const char **)components, as_prefix);\n\tlxc_free_array((void **)components, free);\n\n\treturn cleanpath;\n}",
    "includes": [
      "#include <../include/getsubopt.h>",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"arguments.h\"",
      "#include \"confile.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <stdbool.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <stdint.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <getopt.h>",
      "#include <unistd.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *construct_path(char *path, bool as_prefix);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_free_array",
          "args": [
            "(void **)components",
            "free"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_free_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "886-892",
          "snippet": "void lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_string_join",
          "args": [
            "\"/\"",
            "(const char **)components",
            "as_prefix"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_join",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "664-688",
          "snippet": "char *lxc_string_join(const char *sep, const char **parts, bool use_as_prefix)\n{\n\tchar *result;\n\tchar **p;\n\tsize_t sep_len = strlen(sep);\n\tsize_t result_len = use_as_prefix * sep_len;\n\n\t/* calculate new string length */\n\tfor (p = (char **)parts; *p; p++)\n\t\tresult_len += (p > (char **)parts) * sep_len + strlen(*p);\n\n\tresult = calloc(result_len + 1, 1);\n\tif (!result)\n\t\treturn NULL;\n\n\tif (use_as_prefix)\n\t\tstrcpy(result, sep);\n\tfor (p = (char **)parts; *p; p++) {\n\t\tif (p > (char **)parts)\n\t\t\tstrcat(result, sep);\n\t\tstrcat(result, *p);\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *lxc_string_join(const char *sep, const char **parts, bool use_as_prefix)\n{\n\tchar *result;\n\tchar **p;\n\tsize_t sep_len = strlen(sep);\n\tsize_t result_len = use_as_prefix * sep_len;\n\n\t/* calculate new string length */\n\tfor (p = (char **)parts; *p; p++)\n\t\tresult_len += (p > (char **)parts) * sep_len + strlen(*p);\n\n\tresult = calloc(result_len + 1, 1);\n\tif (!result)\n\t\treturn NULL;\n\n\tif (use_as_prefix)\n\t\tstrcpy(result, sep);\n\tfor (p = (char **)parts; *p; p++) {\n\t\tif (p > (char **)parts)\n\t\t\tstrcat(result, sep);\n\t\tstrcat(result, *p);\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_normalize_path",
          "args": [
            "path"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_normalize_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "690-723",
          "snippet": "char **lxc_normalize_path(const char *path)\n{\n\tchar **components;\n\tchar **p;\n\tsize_t components_len = 0;\n\tsize_t pos = 0;\n\n\tcomponents = lxc_string_split(path, '/');\n\tif (!components)\n\t\treturn NULL;\n\tfor (p = components; *p; p++)\n\t\tcomponents_len++;\n\n\t/* resolve '.' and '..' */\n\tfor (pos = 0; pos < components_len; ) {\n\t\tif (!strcmp(components[pos], \".\") || (!strcmp(components[pos], \"..\") && pos == 0)) {\n\t\t\t/* eat this element */\n\t\t\tfree(components[pos]);\n\t\t\tmemmove(&components[pos], &components[pos+1], sizeof(char *) * (components_len - pos));\n\t\t\tcomponents_len--;\n\t\t} else if (!strcmp(components[pos], \"..\")) {\n\t\t\t/* eat this and the previous element */\n\t\t\tfree(components[pos - 1]);\n\t\t\tfree(components[pos]);\n\t\t\tmemmove(&components[pos-1], &components[pos+1], sizeof(char *) * (components_len - pos));\n\t\t\tcomponents_len -= 2;\n\t\t\tpos--;\n\t\t} else {\n\t\t\tpos++;\n\t\t}\n\t}\n\n\treturn components;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool btrfs_try_remove_subvol(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nchar **lxc_normalize_path(const char *path)\n{\n\tchar **components;\n\tchar **p;\n\tsize_t components_len = 0;\n\tsize_t pos = 0;\n\n\tcomponents = lxc_string_split(path, '/');\n\tif (!components)\n\t\treturn NULL;\n\tfor (p = components; *p; p++)\n\t\tcomponents_len++;\n\n\t/* resolve '.' and '..' */\n\tfor (pos = 0; pos < components_len; ) {\n\t\tif (!strcmp(components[pos], \".\") || (!strcmp(components[pos], \"..\") && pos == 0)) {\n\t\t\t/* eat this element */\n\t\t\tfree(components[pos]);\n\t\t\tmemmove(&components[pos], &components[pos+1], sizeof(char *) * (components_len - pos));\n\t\t\tcomponents_len--;\n\t\t} else if (!strcmp(components[pos], \"..\")) {\n\t\t\t/* eat this and the previous element */\n\t\t\tfree(components[pos - 1]);\n\t\t\tfree(components[pos]);\n\t\t\tmemmove(&components[pos-1], &components[pos+1], sizeof(char *) * (components_len - pos));\n\t\t\tcomponents_len -= 2;\n\t\t\tpos--;\n\t\t} else {\n\t\t\tpos++;\n\t\t}\n\t}\n\n\treturn components;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic char *construct_path(char *path, bool as_prefix);\n\nstatic char *construct_path(char *path, bool as_prefix)\n{\n\tchar **components = NULL;\n\tchar *cleanpath = NULL;\n\n\tcomponents = lxc_normalize_path(path);\n\tif (!components)\n\t\treturn NULL;\n\n\tcleanpath = lxc_string_join(\"/\", (const char **)components, as_prefix);\n\tlxc_free_array((void **)components, free);\n\n\treturn cleanpath;\n}"
  },
  {
    "function_name": "mk_rand_ovl_dirs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
    "lines": "266-301",
    "snippet": "static int mk_rand_ovl_dirs(struct mnts *mnts, unsigned int num, struct lxc_arguments *arg)\n{\n\tchar upperdir[MAXPATHLEN];\n\tchar workdir[MAXPATHLEN];\n\tunsigned int i;\n\tint ret;\n\tstruct mnts *m = NULL;\n\n\tfor (i = 0, m = mnts; i < num; i++, m++) {\n\t\tif ((m->mnt_type == LXC_MNT_OVL) || (m->mnt_type == LXC_MNT_AUFS)) {\n\t\t\tret = snprintf(upperdir, MAXPATHLEN, \"%s/%s/delta#XXXXXX\",\n\t\t\t\t\targ->newpath, arg->newname);\n\t\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\t\treturn -1;\n\t\t\tif (!mkdtemp(upperdir))\n\t\t\t\treturn -1;\n\t\t\tm->upper = strdup(upperdir);\n\t\t\tif (!m->upper)\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tif (m->mnt_type == LXC_MNT_OVL) {\n\t\t\tret = snprintf(workdir, MAXPATHLEN, \"%s/%s/work#XXXXXX\",\n\t\t\t\t\targ->newpath, arg->newname);\n\t\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\t\treturn -1;\n\t\t\tif (!mkdtemp(workdir))\n\t\t\t\treturn -1;\n\t\t\tm->workdir = strdup(workdir);\n\t\t\tif (!m->workdir)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <../include/getsubopt.h>",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"arguments.h\"",
      "#include \"confile.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <stdbool.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <stdint.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <getopt.h>",
      "#include <unistd.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int my_parser(struct lxc_arguments *args, int c, char *arg);",
      "static int mk_rand_ovl_dirs(struct mnts *mnts, unsigned int num,\n\t\t\t    struct lxc_arguments *arg);",
      "static char *set_mnt_entry(struct mnts *m);",
      "static int do_clone_rename(struct lxc_container *c, char *newname);",
      "static uint64_t get_fssize(char *s);",
      "static char *mount_tmpfs(const char *oldname, const char *newname,\n\t\t\t const char *path, struct lxc_arguments *arg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "workdir"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdtemp",
          "args": [
            "workdir"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "workdir",
            "MAXPATHLEN",
            "\"%s/%s/work#XXXXXX\"",
            "arg->newpath",
            "arg->newname"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "upperdir"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdtemp",
          "args": [
            "upperdir"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "upperdir",
            "MAXPATHLEN",
            "\"%s/%s/delta#XXXXXX\"",
            "arg->newpath",
            "arg->newname"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic int my_parser(struct lxc_arguments *args, int c, char *arg);\nstatic int mk_rand_ovl_dirs(struct mnts *mnts, unsigned int num,\n\t\t\t    struct lxc_arguments *arg);\nstatic char *set_mnt_entry(struct mnts *m);\nstatic int do_clone_rename(struct lxc_container *c, char *newname);\nstatic uint64_t get_fssize(char *s);\nstatic char *mount_tmpfs(const char *oldname, const char *newname,\n\t\t\t const char *path, struct lxc_arguments *arg);\n\nstatic int mk_rand_ovl_dirs(struct mnts *mnts, unsigned int num, struct lxc_arguments *arg)\n{\n\tchar upperdir[MAXPATHLEN];\n\tchar workdir[MAXPATHLEN];\n\tunsigned int i;\n\tint ret;\n\tstruct mnts *m = NULL;\n\n\tfor (i = 0, m = mnts; i < num; i++, m++) {\n\t\tif ((m->mnt_type == LXC_MNT_OVL) || (m->mnt_type == LXC_MNT_AUFS)) {\n\t\t\tret = snprintf(upperdir, MAXPATHLEN, \"%s/%s/delta#XXXXXX\",\n\t\t\t\t\targ->newpath, arg->newname);\n\t\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\t\treturn -1;\n\t\t\tif (!mkdtemp(upperdir))\n\t\t\t\treturn -1;\n\t\t\tm->upper = strdup(upperdir);\n\t\t\tif (!m->upper)\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tif (m->mnt_type == LXC_MNT_OVL) {\n\t\t\tret = snprintf(workdir, MAXPATHLEN, \"%s/%s/work#XXXXXX\",\n\t\t\t\t\targ->newpath, arg->newname);\n\t\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\t\treturn -1;\n\t\t\tif (!mkdtemp(workdir))\n\t\t\t\treturn -1;\n\t\t\tm->workdir = strdup(workdir);\n\t\t\tif (!m->workdir)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "add_mnt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
    "lines": "249-264",
    "snippet": "static struct mnts *add_mnt(struct mnts **mnts, unsigned int *num, enum mnttype type)\n{\n\tstruct mnts *m, *n;\n\n\tn = realloc(*mnts, (*num + 1) * sizeof(struct mnts));\n\tif (!n)\n\t\treturn NULL;\n\n\t*mnts = n;\n\tm = *mnts + *num;\n\t(*num)++;\n\n\t*m = (struct mnts) {.mnt_type = type};\n\n\treturn m;\n}",
    "includes": [
      "#include <../include/getsubopt.h>",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"arguments.h\"",
      "#include \"confile.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <stdbool.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <stdint.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <getopt.h>",
      "#include <unistd.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct mnts *add_mnt(struct mnts **mnts, unsigned int *num,\n\t\t\t    enum mnttype type);",
      "static char *set_mnt_entry(struct mnts *m);",
      "static int parse_aufs_mnt(char *mntstring, enum mnttype type);",
      "static int parse_bind_mnt(char *mntstring, enum mnttype type);",
      "static int parse_ovl_mnt(char *mntstring, enum mnttype type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "*mnts",
            "(*num + 1) * sizeof(struct mnts)"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "must_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "116-124",
          "snippet": "static void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic struct mnts *add_mnt(struct mnts **mnts, unsigned int *num,\n\t\t\t    enum mnttype type);\nstatic char *set_mnt_entry(struct mnts *m);\nstatic int parse_aufs_mnt(char *mntstring, enum mnttype type);\nstatic int parse_bind_mnt(char *mntstring, enum mnttype type);\nstatic int parse_ovl_mnt(char *mntstring, enum mnttype type);\n\nstatic struct mnts *add_mnt(struct mnts **mnts, unsigned int *num, enum mnttype type)\n{\n\tstruct mnts *m, *n;\n\n\tn = realloc(*mnts, (*num + 1) * sizeof(struct mnts));\n\tif (!n)\n\t\treturn NULL;\n\n\t*mnts = n;\n\tm = *mnts + *num;\n\t(*num)++;\n\n\t*m = (struct mnts) {.mnt_type = type};\n\n\treturn m;\n}"
  },
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
    "lines": "169-247",
    "snippet": "int main(int argc, char *argv[])\n{\n\tstruct lxc_container *c;\n\tint flags = 0;\n\tint ret = EXIT_FAILURE;\n\n\tif (lxc_arguments_parse(&my_args, argc, argv))\n\t\texit(ret);\n\n\tif (!my_args.log_file)\n\t\tmy_args.log_file = \"none\";\n\n\tif (lxc_log_init(my_args.name, my_args.log_file, my_args.log_priority,\n\t\t\t my_args.progname, my_args.quiet, my_args.lxcpath[0]))\n\t\texit(ret);\n\tlxc_log_options_no_override();\n\n\tif (geteuid()) {\n\t\tif (access(my_args.lxcpath[0], O_RDONLY) < 0) {\n\t\t\tif (!my_args.quiet)\n\t\t\t\tfprintf(stderr, \"You lack access to %s\\n\", my_args.lxcpath[0]);\n\t\t\texit(ret);\n\t\t}\n\t}\n\n\tif (!my_args.newname && !(my_args.task == DESTROY)) {\n\t\tif (!my_args.quiet)\n\t\t\tprintf(\"Error: You must provide a NEWNAME for the clone.\\n\");\n\t\texit(ret);\n\t}\n\n\tif (my_args.task == SNAP || my_args.task == DESTROY)\n\t\tflags |= LXC_CLONE_SNAPSHOT;\n\tif (my_args.keepname)\n\t\tflags |= LXC_CLONE_KEEPNAME;\n\tif (my_args.keepmac)\n\t\tflags |= LXC_CLONE_KEEPMACADDR;\n\n\tif (!my_args.newpath)\n\t\tmy_args.newpath = (char *)my_args.lxcpath[0];\n\n\tc = lxc_container_new(my_args.name, my_args.lxcpath[0]);\n\tif (!c)\n\t\texit(ret);\n\n\tif (my_args.rcfile) {\n\t\tc->clear_config(c);\n\t\tif (!c->load_config(c, my_args.rcfile)) {\n\t\t\tfprintf(stderr, \"Failed to load rcfile\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tc->configfile = strdup(my_args.rcfile);\n\t\tif (!c->configfile) {\n\t\t\tfprintf(stderr, \"Out of memory setting new config filename\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!c->may_control(c)) {\n\t\tif (!my_args.quiet)\n\t\t\tfprintf(stderr, \"Insufficent privileges to control %s\\n\", c->name);\n\t\tgoto out;\n\t}\n\n\tif (!c->is_defined(c)) {\n\t\tif (!my_args.quiet)\n\t\t\tfprintf(stderr, \"Error: container %s is not defined\\n\", c->name);\n\t\tgoto out;\n\t}\n\n\tret = do_clone_task(c, my_args.task, flags, &argv[optind]);\n\nout:\n\tlxc_container_put(c);\n\n\tif (ret == 0)\n\t\texit(EXIT_SUCCESS);\n\texit(EXIT_FAILURE);\n}",
    "includes": [
      "#include <../include/getsubopt.h>",
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"arguments.h\"",
      "#include \"confile.h\"",
      "#include \"log.h\"",
      "#include \"bdev.h\"",
      "#include \"attach.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <stdbool.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <stdint.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <getopt.h>",
      "#include <unistd.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lxc_arguments my_args = {\n\t.progname = \"lxc-copy\",\n\t.help = \"\\n\\\n--name=NAME [-P lxcpath] -N newname [-p newpath] [-B backingstorage] [-s] [-K] [-M] [-L size [unit]] -- hook options\\n\\\n--name=NAME [-P lxcpath] [-N newname] [-p newpath] [-B backingstorage] -e [-d] [-D] [-K] [-M] [-m {bind,aufs,overlay}=/src:/dest] -- hook options\\n\\\n--name=NAME [-P lxcpath] -N newname -R\\n\\\n\\n\\\nlxc-copy clone a container\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME           NAME of the container\\n\\\n  -N, --newname=NEWNAME     NEWNAME for the restored container\\n\\\n  -p, --newpath=NEWPATH     NEWPATH for the container to be stored\\n\\\n  -R, --rename              rename container\\n\\\n  -s, --snapshot            create snapshot instead of clone\\n\\\n  -F, --foreground          start with current tty attached to /dev/console\\n\\\n  -d, --daemon              daemonize the container (default)\\n\\\n  -e, --ephemeral           start ephemeral container\\n\\\n  -m, --mount               directory to mount into container, either \\n\\\n                            {bind,aufs,overlay}=/src-path or {bind,aufs,overlay}=/src-path:/dst-path\\n\\\n  -B, --backingstorage=TYPE backingstorage type for the container\\n\\\n  -t, --tmpfs               place ephemeral container on a tmpfs\\n\\\n                            (WARNING: On reboot all changes made to the container will be lost.)\\n\\\n  -L, --fssize              size of the new block device for block device containers\\n\\\n  -D, --keedata             pass together with -e start a persistent snapshot \\n\\\n  -K, --keepname            keep the hostname of the original container\\n\\\n  --  hook options          arguments passed to the hook program\\n\\\n  -M, --keepmac             keep the MAC address of the original container\\n\\\n  --rcfile=FILE             Load configuration file FILE\\n\",\n\t.options = my_longopts,\n\t.parser = my_parser,\n\t.task = CLONE,\n\t.daemonize = 1,\n\t.quiet = false,\n\t.tmpfs = false,\n};",
      "static int do_clone_ephemeral(struct lxc_container *c,\n\t\t\t      struct lxc_arguments *arg, char **args,\n\t\t\t      int flags);",
      "static int do_clone_rename(struct lxc_container *c, char *newname);",
      "static uint64_t get_fssize(char *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_SUCCESS"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_container_put",
          "args": [
            "c"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "312-325",
          "snippet": "int lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_clone_task",
          "args": [
            "c",
            "my_args.task",
            "flags",
            "&argv[optind]"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "do_clone_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "517-537",
          "snippet": "static int do_clone_task(struct lxc_container *c, enum task task, int flags,\n\t\t\t char **args)\n{\n\tint ret = 0;\n\n\tswitch (task) {\n\tcase DESTROY:\n\t\tret = do_clone_ephemeral(c, &my_args, args, flags);\n\t\tbreak;\n\tcase RENAME:\n\t\tret = do_clone_rename(c, my_args.newname);\n\t\tbreak;\n\tdefault:\n\t\tret = do_clone(c, my_args.newname, my_args.newpath, flags,\n\t\t\t       my_args.bdevtype, my_args.fssize, my_args.task,\n\t\t\t       args);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lxc_arguments my_args = {\n\t.progname = \"lxc-copy\",\n\t.help = \"\\n\\\n--name=NAME [-P lxcpath] -N newname [-p newpath] [-B backingstorage] [-s] [-K] [-M] [-L size [unit]] -- hook options\\n\\\n--name=NAME [-P lxcpath] [-N newname] [-p newpath] [-B backingstorage] -e [-d] [-D] [-K] [-M] [-m {bind,aufs,overlay}=/src:/dest] -- hook options\\n\\\n--name=NAME [-P lxcpath] -N newname -R\\n\\\n\\n\\\nlxc-copy clone a container\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME           NAME of the container\\n\\\n  -N, --newname=NEWNAME     NEWNAME for the restored container\\n\\\n  -p, --newpath=NEWPATH     NEWPATH for the container to be stored\\n\\\n  -R, --rename              rename container\\n\\\n  -s, --snapshot            create snapshot instead of clone\\n\\\n  -F, --foreground          start with current tty attached to /dev/console\\n\\\n  -d, --daemon              daemonize the container (default)\\n\\\n  -e, --ephemeral           start ephemeral container\\n\\\n  -m, --mount               directory to mount into container, either \\n\\\n                            {bind,aufs,overlay}=/src-path or {bind,aufs,overlay}=/src-path:/dst-path\\n\\\n  -B, --backingstorage=TYPE backingstorage type for the container\\n\\\n  -t, --tmpfs               place ephemeral container on a tmpfs\\n\\\n                            (WARNING: On reboot all changes made to the container will be lost.)\\n\\\n  -L, --fssize              size of the new block device for block device containers\\n\\\n  -D, --keedata             pass together with -e start a persistent snapshot \\n\\\n  -K, --keepname            keep the hostname of the original container\\n\\\n  --  hook options          arguments passed to the hook program\\n\\\n  -M, --keepmac             keep the MAC address of the original container\\n\\\n  --rcfile=FILE             Load configuration file FILE\\n\",\n\t.options = my_longopts,\n\t.parser = my_parser,\n\t.task = CLONE,\n\t.daemonize = 1,\n\t.quiet = false,\n\t.tmpfs = false,\n};",
            "static int do_clone(struct lxc_container *c, char *newname, char *newpath,\n\t\t    int flags, char *bdevtype, uint64_t fssize, enum task task,\n\t\t    char **args);",
            "static int do_clone_ephemeral(struct lxc_container *c,\n\t\t\t      struct lxc_arguments *arg, char **args,\n\t\t\t      int flags);",
            "static int do_clone_rename(struct lxc_container *c, char *newname);",
            "static int do_clone_task(struct lxc_container *c, enum task task, int flags,\n\t\t\t char **args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic struct lxc_arguments my_args = {\n\t.progname = \"lxc-copy\",\n\t.help = \"\\n\\\n--name=NAME [-P lxcpath] -N newname [-p newpath] [-B backingstorage] [-s] [-K] [-M] [-L size [unit]] -- hook options\\n\\\n--name=NAME [-P lxcpath] [-N newname] [-p newpath] [-B backingstorage] -e [-d] [-D] [-K] [-M] [-m {bind,aufs,overlay}=/src:/dest] -- hook options\\n\\\n--name=NAME [-P lxcpath] -N newname -R\\n\\\n\\n\\\nlxc-copy clone a container\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME           NAME of the container\\n\\\n  -N, --newname=NEWNAME     NEWNAME for the restored container\\n\\\n  -p, --newpath=NEWPATH     NEWPATH for the container to be stored\\n\\\n  -R, --rename              rename container\\n\\\n  -s, --snapshot            create snapshot instead of clone\\n\\\n  -F, --foreground          start with current tty attached to /dev/console\\n\\\n  -d, --daemon              daemonize the container (default)\\n\\\n  -e, --ephemeral           start ephemeral container\\n\\\n  -m, --mount               directory to mount into container, either \\n\\\n                            {bind,aufs,overlay}=/src-path or {bind,aufs,overlay}=/src-path:/dst-path\\n\\\n  -B, --backingstorage=TYPE backingstorage type for the container\\n\\\n  -t, --tmpfs               place ephemeral container on a tmpfs\\n\\\n                            (WARNING: On reboot all changes made to the container will be lost.)\\n\\\n  -L, --fssize              size of the new block device for block device containers\\n\\\n  -D, --keedata             pass together with -e start a persistent snapshot \\n\\\n  -K, --keepname            keep the hostname of the original container\\n\\\n  --  hook options          arguments passed to the hook program\\n\\\n  -M, --keepmac             keep the MAC address of the original container\\n\\\n  --rcfile=FILE             Load configuration file FILE\\n\",\n\t.options = my_longopts,\n\t.parser = my_parser,\n\t.task = CLONE,\n\t.daemonize = 1,\n\t.quiet = false,\n\t.tmpfs = false,\n};\nstatic int do_clone(struct lxc_container *c, char *newname, char *newpath,\n\t\t    int flags, char *bdevtype, uint64_t fssize, enum task task,\n\t\t    char **args);\nstatic int do_clone_ephemeral(struct lxc_container *c,\n\t\t\t      struct lxc_arguments *arg, char **args,\n\t\t\t      int flags);\nstatic int do_clone_rename(struct lxc_container *c, char *newname);\nstatic int do_clone_task(struct lxc_container *c, enum task task, int flags,\n\t\t\t char **args);\n\nstatic int do_clone_task(struct lxc_container *c, enum task task, int flags,\n\t\t\t char **args)\n{\n\tint ret = 0;\n\n\tswitch (task) {\n\tcase DESTROY:\n\t\tret = do_clone_ephemeral(c, &my_args, args, flags);\n\t\tbreak;\n\tcase RENAME:\n\t\tret = do_clone_rename(c, my_args.newname);\n\t\tbreak;\n\tdefault:\n\t\tret = do_clone(c, my_args.newname, my_args.newpath, flags,\n\t\t\t       my_args.bdevtype, my_args.fssize, my_args.task,\n\t\t\t       args);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: container %s is not defined\\n\"",
            "c->name"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->is_defined",
          "args": [
            "c"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Insufficent privileges to control %s\\n\"",
            "c->name"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->may_control",
          "args": [
            "c"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Out of memory setting new config filename\\n\""
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "my_args.rcfile"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to load rcfile\\n\""
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->load_config",
          "args": [
            "c",
            "my_args.rcfile"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->clear_config",
          "args": [
            "c"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "ret"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_container_new",
          "args": [
            "my_args.name",
            "my_args.lxcpath[0]"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "4099-4218",
          "snippet": "struct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstruct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "ret"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Error: You must provide a NEWNAME for the clone.\\n\""
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "ret"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"You lack access to %s\\n\"",
            "my_args.lxcpath[0]"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "my_args.lxcpath[0]",
            "O_RDONLY"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_log_options_no_override",
          "args": [],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_log_options_no_override",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
          "lines": "685-689",
          "snippet": "extern void lxc_log_options_no_override()\n{\n\tlxc_quiet_specified = 1;\n\tlxc_loglevel_specified = 1;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"caps.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <pthread.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int lxc_quiet_specified;",
            "static int lxc_loglevel_specified;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nint lxc_quiet_specified;\nstatic int lxc_loglevel_specified;\n\nextern void lxc_log_options_no_override()\n{\n\tlxc_quiet_specified = 1;\n\tlxc_loglevel_specified = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "ret"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_log_init",
          "args": [
            "my_args.name",
            "my_args.log_file",
            "my_args.log_priority",
            "my_args.progname",
            "my_args.quiet",
            "my_args.lxcpath[0]"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_log_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
          "lines": "546-615",
          "snippet": "extern int lxc_log_init(const char *name, const char *file,\n\t\t\tconst char *priority, const char *prefix, int quiet,\n\t\t\tconst char *lxcpath)\n{\n\tint lxc_priority = LXC_LOG_PRIORITY_ERROR;\n\tint ret;\n\n\tif (lxc_log_fd != -1) {\n\t\tWARN(\"lxc_log_init called with log already initialized\");\n\t\treturn 0;\n\t}\n\n\tif (priority)\n\t\tlxc_priority = lxc_log_priority_to_int(priority);\n\n\tif (!lxc_loglevel_specified) {\n\t\tlxc_log_category_lxc.priority = lxc_priority;\n\t\tlxc_loglevel_specified = 1;\n\t}\n\n\tif (!lxc_quiet_specified) {\n\t\tif (!quiet)\n\t\t\tlxc_log_category_lxc.appender->next = &log_appender_stderr;\n\t}\n\n\tif (prefix)\n\t\tlxc_log_set_prefix(prefix);\n\n\tif (name)\n\t\tlog_vmname = strdup(name);\n\n\tif (file) {\n\t\tif (strcmp(file, \"none\") == 0)\n\t\t\treturn 0;\n\t\tret = __lxc_log_set_file(file, 1);\n\t\tlxc_log_use_global_fd = 1;\n\t} else {\n\t\t/* if no name was specified, there nothing to do */\n\t\tif (!name)\n\t\t\treturn 0;\n\n\t\tret = -1;\n\n\t\tif (!lxcpath)\n\t\t\tlxcpath = LOGPATH;\n\n\t\t/* try LOGPATH if lxcpath is the default for the privileged containers */\n\t\tif (!geteuid() && strcmp(LXCPATH, lxcpath) == 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\n\t\t/* try in lxcpath */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, lxcpath, 1);\n\n\t\t/* try LOGPATH in case its writable by the caller */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\t}\n\n\t/*\n\t * If !file, that is, if the user did not request this logpath, then\n\t * ignore failures and continue logging to console\n\t */\n\tif (!file && ret != 0) {\n\t\tINFO(\"Ignoring failure to open default logfile.\");\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"caps.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <pthread.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int lxc_log_fd = -1;",
            "int lxc_quiet_specified;",
            "int lxc_log_use_global_fd;",
            "static int lxc_loglevel_specified;",
            "static char *log_vmname = NULL;",
            "static struct lxc_log_appender log_appender_stderr = {\n\t.name\t\t= \"stderr\",\n\t.append\t\t= log_append_stderr,\n\t.next\t\t= NULL,\n};",
            "struct lxc_log_category lxc_log_category_lxc = {\n\t.name\t\t= \"lxc\",\n\t.priority\t= LXC_LOG_PRIORITY_ERROR,\n\t.appender\t= &log_appender_logfile,\n\t.parent\t\t= &log_root\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nint lxc_log_fd = -1;\nint lxc_quiet_specified;\nint lxc_log_use_global_fd;\nstatic int lxc_loglevel_specified;\nstatic char *log_vmname = NULL;\nstatic struct lxc_log_appender log_appender_stderr = {\n\t.name\t\t= \"stderr\",\n\t.append\t\t= log_append_stderr,\n\t.next\t\t= NULL,\n};\nstruct lxc_log_category lxc_log_category_lxc = {\n\t.name\t\t= \"lxc\",\n\t.priority\t= LXC_LOG_PRIORITY_ERROR,\n\t.appender\t= &log_appender_logfile,\n\t.parent\t\t= &log_root\n};\n\nextern int lxc_log_init(const char *name, const char *file,\n\t\t\tconst char *priority, const char *prefix, int quiet,\n\t\t\tconst char *lxcpath)\n{\n\tint lxc_priority = LXC_LOG_PRIORITY_ERROR;\n\tint ret;\n\n\tif (lxc_log_fd != -1) {\n\t\tWARN(\"lxc_log_init called with log already initialized\");\n\t\treturn 0;\n\t}\n\n\tif (priority)\n\t\tlxc_priority = lxc_log_priority_to_int(priority);\n\n\tif (!lxc_loglevel_specified) {\n\t\tlxc_log_category_lxc.priority = lxc_priority;\n\t\tlxc_loglevel_specified = 1;\n\t}\n\n\tif (!lxc_quiet_specified) {\n\t\tif (!quiet)\n\t\t\tlxc_log_category_lxc.appender->next = &log_appender_stderr;\n\t}\n\n\tif (prefix)\n\t\tlxc_log_set_prefix(prefix);\n\n\tif (name)\n\t\tlog_vmname = strdup(name);\n\n\tif (file) {\n\t\tif (strcmp(file, \"none\") == 0)\n\t\t\treturn 0;\n\t\tret = __lxc_log_set_file(file, 1);\n\t\tlxc_log_use_global_fd = 1;\n\t} else {\n\t\t/* if no name was specified, there nothing to do */\n\t\tif (!name)\n\t\t\treturn 0;\n\n\t\tret = -1;\n\n\t\tif (!lxcpath)\n\t\t\tlxcpath = LOGPATH;\n\n\t\t/* try LOGPATH if lxcpath is the default for the privileged containers */\n\t\tif (!geteuid() && strcmp(LXCPATH, lxcpath) == 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\n\t\t/* try in lxcpath */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, lxcpath, 1);\n\n\t\t/* try LOGPATH in case its writable by the caller */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\t}\n\n\t/*\n\t * If !file, that is, if the user did not request this logpath, then\n\t * ignore failures and continue logging to console\n\t */\n\tif (!file && ret != 0) {\n\t\tINFO(\"Ignoring failure to open default logfile.\");\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "ret"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_arguments_parse",
          "args": [
            "&my_args",
            "argc",
            "argv"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_arguments_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/arguments.c",
          "lines": "182-252",
          "snippet": "extern int lxc_arguments_parse(struct lxc_arguments *args,\n\t\t\t       int argc, char * const argv[])\n{\n\tchar shortopts[256];\n\tint  ret = 0;\n\n\tret = build_shortopts(args->options, shortopts, sizeof(shortopts));\n\tif (ret < 0) {\n\t\tlxc_error(args, \"build_shortopts() failed : %s\",\n\t\t\t  strerror(errno));\n\t\treturn ret;\n\t}\n\n\twhile (1)  {\n\t\tint c, index = 0;\n\n\t\tc = getopt_long(argc, argv, shortopts, args->options, &index);\n\t\tif (c == -1)\n\t\t\tbreak;\n\t\tswitch (c) {\n\t\tcase 'n': \targs->name = optarg; break;\n\t\tcase 'o':\targs->log_file = optarg; break;\n\t\tcase 'l':\targs->log_priority = optarg; break;\n\t\tcase 'q':\targs->quiet = 1; break;\n\t\tcase OPT_RCFILE: args->rcfile = optarg; break;\n\t\tcase 'P':\n\t\t\tremove_trailing_slashes(optarg);\n\t\t\tret = lxc_arguments_lxcpath_add(args, optarg);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase OPT_USAGE: print_usage(args->options, args);\n\t\tcase OPT_VERSION: print_version();\n\t\tcase '?':\tprint_help(args, 1);\n\t\tcase 'h': \tprint_help(args, 0);\n\t\tdefault:\n\t\t\tif (args->parser) {\n\t\t\t\tret = args->parser(args, c, optarg);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Reclaim the remaining command arguments\n\t */\n\targs->argv = &argv[optind];\n\targs->argc = argc - optind;\n\n\t/* If no lxcpaths were given, use default */\n\tif (!args->lxcpath_cnt) {\n\t\tret = lxc_arguments_lxcpath_add(args, lxc_global_config_value(\"lxc.lxcpath\"));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t/* Check the command options */\n\n\tif (!args->name && strcmp(args->progname, \"lxc-autostart\") != 0) {\n\t\tlxc_error(args, \"missing container name, use --name option\");\n\t\treturn -1;\n\t}\n\n\tif (args->checker)\n\t\tret = args->checker(args);\nerror:\n\tif (ret)\n\t\tlxc_error(args, \"could not parse command line\");\n\treturn ret;\n}",
          "includes": [
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"arguments.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <ctype.h>\t\t/* for isprint() */",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"utils.h\"\n#include \"arguments.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <ctype.h>\t\t/* for isprint() */\n#include <string.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nextern int lxc_arguments_parse(struct lxc_arguments *args,\n\t\t\t       int argc, char * const argv[])\n{\n\tchar shortopts[256];\n\tint  ret = 0;\n\n\tret = build_shortopts(args->options, shortopts, sizeof(shortopts));\n\tif (ret < 0) {\n\t\tlxc_error(args, \"build_shortopts() failed : %s\",\n\t\t\t  strerror(errno));\n\t\treturn ret;\n\t}\n\n\twhile (1)  {\n\t\tint c, index = 0;\n\n\t\tc = getopt_long(argc, argv, shortopts, args->options, &index);\n\t\tif (c == -1)\n\t\t\tbreak;\n\t\tswitch (c) {\n\t\tcase 'n': \targs->name = optarg; break;\n\t\tcase 'o':\targs->log_file = optarg; break;\n\t\tcase 'l':\targs->log_priority = optarg; break;\n\t\tcase 'q':\targs->quiet = 1; break;\n\t\tcase OPT_RCFILE: args->rcfile = optarg; break;\n\t\tcase 'P':\n\t\t\tremove_trailing_slashes(optarg);\n\t\t\tret = lxc_arguments_lxcpath_add(args, optarg);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase OPT_USAGE: print_usage(args->options, args);\n\t\tcase OPT_VERSION: print_version();\n\t\tcase '?':\tprint_help(args, 1);\n\t\tcase 'h': \tprint_help(args, 0);\n\t\tdefault:\n\t\t\tif (args->parser) {\n\t\t\t\tret = args->parser(args, c, optarg);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Reclaim the remaining command arguments\n\t */\n\targs->argv = &argv[optind];\n\targs->argc = argc - optind;\n\n\t/* If no lxcpaths were given, use default */\n\tif (!args->lxcpath_cnt) {\n\t\tret = lxc_arguments_lxcpath_add(args, lxc_global_config_value(\"lxc.lxcpath\"));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t/* Check the command options */\n\n\tif (!args->name && strcmp(args->progname, \"lxc-autostart\") != 0) {\n\t\tlxc_error(args, \"missing container name, use --name option\");\n\t\treturn -1;\n\t}\n\n\tif (args->checker)\n\t\tret = args->checker(args);\nerror:\n\tif (ret)\n\t\tlxc_error(args, \"could not parse command line\");\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic struct lxc_arguments my_args = {\n\t.progname = \"lxc-copy\",\n\t.help = \"\\n\\\n--name=NAME [-P lxcpath] -N newname [-p newpath] [-B backingstorage] [-s] [-K] [-M] [-L size [unit]] -- hook options\\n\\\n--name=NAME [-P lxcpath] [-N newname] [-p newpath] [-B backingstorage] -e [-d] [-D] [-K] [-M] [-m {bind,aufs,overlay}=/src:/dest] -- hook options\\n\\\n--name=NAME [-P lxcpath] -N newname -R\\n\\\n\\n\\\nlxc-copy clone a container\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME           NAME of the container\\n\\\n  -N, --newname=NEWNAME     NEWNAME for the restored container\\n\\\n  -p, --newpath=NEWPATH     NEWPATH for the container to be stored\\n\\\n  -R, --rename              rename container\\n\\\n  -s, --snapshot            create snapshot instead of clone\\n\\\n  -F, --foreground          start with current tty attached to /dev/console\\n\\\n  -d, --daemon              daemonize the container (default)\\n\\\n  -e, --ephemeral           start ephemeral container\\n\\\n  -m, --mount               directory to mount into container, either \\n\\\n                            {bind,aufs,overlay}=/src-path or {bind,aufs,overlay}=/src-path:/dst-path\\n\\\n  -B, --backingstorage=TYPE backingstorage type for the container\\n\\\n  -t, --tmpfs               place ephemeral container on a tmpfs\\n\\\n                            (WARNING: On reboot all changes made to the container will be lost.)\\n\\\n  -L, --fssize              size of the new block device for block device containers\\n\\\n  -D, --keedata             pass together with -e start a persistent snapshot \\n\\\n  -K, --keepname            keep the hostname of the original container\\n\\\n  --  hook options          arguments passed to the hook program\\n\\\n  -M, --keepmac             keep the MAC address of the original container\\n\\\n  --rcfile=FILE             Load configuration file FILE\\n\",\n\t.options = my_longopts,\n\t.parser = my_parser,\n\t.task = CLONE,\n\t.daemonize = 1,\n\t.quiet = false,\n\t.tmpfs = false,\n};\nstatic int do_clone_ephemeral(struct lxc_container *c,\n\t\t\t      struct lxc_arguments *arg, char **args,\n\t\t\t      int flags);\nstatic int do_clone_rename(struct lxc_container *c, char *newname);\nstatic uint64_t get_fssize(char *s);\n\nint main(int argc, char *argv[])\n{\n\tstruct lxc_container *c;\n\tint flags = 0;\n\tint ret = EXIT_FAILURE;\n\n\tif (lxc_arguments_parse(&my_args, argc, argv))\n\t\texit(ret);\n\n\tif (!my_args.log_file)\n\t\tmy_args.log_file = \"none\";\n\n\tif (lxc_log_init(my_args.name, my_args.log_file, my_args.log_priority,\n\t\t\t my_args.progname, my_args.quiet, my_args.lxcpath[0]))\n\t\texit(ret);\n\tlxc_log_options_no_override();\n\n\tif (geteuid()) {\n\t\tif (access(my_args.lxcpath[0], O_RDONLY) < 0) {\n\t\t\tif (!my_args.quiet)\n\t\t\t\tfprintf(stderr, \"You lack access to %s\\n\", my_args.lxcpath[0]);\n\t\t\texit(ret);\n\t\t}\n\t}\n\n\tif (!my_args.newname && !(my_args.task == DESTROY)) {\n\t\tif (!my_args.quiet)\n\t\t\tprintf(\"Error: You must provide a NEWNAME for the clone.\\n\");\n\t\texit(ret);\n\t}\n\n\tif (my_args.task == SNAP || my_args.task == DESTROY)\n\t\tflags |= LXC_CLONE_SNAPSHOT;\n\tif (my_args.keepname)\n\t\tflags |= LXC_CLONE_KEEPNAME;\n\tif (my_args.keepmac)\n\t\tflags |= LXC_CLONE_KEEPMACADDR;\n\n\tif (!my_args.newpath)\n\t\tmy_args.newpath = (char *)my_args.lxcpath[0];\n\n\tc = lxc_container_new(my_args.name, my_args.lxcpath[0]);\n\tif (!c)\n\t\texit(ret);\n\n\tif (my_args.rcfile) {\n\t\tc->clear_config(c);\n\t\tif (!c->load_config(c, my_args.rcfile)) {\n\t\t\tfprintf(stderr, \"Failed to load rcfile\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tc->configfile = strdup(my_args.rcfile);\n\t\tif (!c->configfile) {\n\t\t\tfprintf(stderr, \"Out of memory setting new config filename\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!c->may_control(c)) {\n\t\tif (!my_args.quiet)\n\t\t\tfprintf(stderr, \"Insufficent privileges to control %s\\n\", c->name);\n\t\tgoto out;\n\t}\n\n\tif (!c->is_defined(c)) {\n\t\tif (!my_args.quiet)\n\t\t\tfprintf(stderr, \"Error: container %s is not defined\\n\", c->name);\n\t\tgoto out;\n\t}\n\n\tret = do_clone_task(c, my_args.task, flags, &argv[optind]);\n\nout:\n\tlxc_container_put(c);\n\n\tif (ret == 0)\n\t\texit(EXIT_SUCCESS);\n\texit(EXIT_FAILURE);\n}"
  }
]