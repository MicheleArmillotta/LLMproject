[
  {
    "function_name": "container_disk_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
    "lines": "365-369",
    "snippet": "void container_disk_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->slock);\n\tlxcunlock(c->privlock);\n}",
    "includes": [
      "#include <execinfo.h>",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <pthread.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <malloc.h>",
      "#include \"lxclock.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxcunlock",
          "args": [
            "c->privlock"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "lxcunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "250-282",
          "snippet": "int lxcunlock(struct lxc_lock *l)\n{\n\tint ret = 0, saved_errno = errno;\n\tstruct flock lk;\n\n\tswitch(l->type) {\n\tcase LXC_LOCK_ANON_SEM:\n\t\tif (!l->u.sem)\n\t\t\tret = -2;\n\t\telse {\n\t\t\tret = sem_post(l->u.sem);\n\t\t\tsaved_errno = errno;\n\t\t}\n\t\tbreak;\n\tcase LXC_LOCK_FLOCK:\n\t\tif (l->u.f.fd != -1) {\n\t\t\tlk.l_type = F_UNLCK;\n\t\t\tlk.l_whence = SEEK_SET;\n\t\t\tlk.l_start = 0;\n\t\t\tlk.l_len = 0;\n\t\t\tret = fcntl(l->u.f.fd, F_SETLK, &lk);\n\t\t\tif (ret < 0)\n\t\t\t\tsaved_errno = errno;\n\t\t\tclose(l->u.f.fd);\n\t\t\tl->u.f.fd = -1;\n\t\t} else\n\t\t\tret = -2;\n\t\tbreak;\n\t}\n\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nint lxcunlock(struct lxc_lock *l)\n{\n\tint ret = 0, saved_errno = errno;\n\tstruct flock lk;\n\n\tswitch(l->type) {\n\tcase LXC_LOCK_ANON_SEM:\n\t\tif (!l->u.sem)\n\t\t\tret = -2;\n\t\telse {\n\t\t\tret = sem_post(l->u.sem);\n\t\t\tsaved_errno = errno;\n\t\t}\n\t\tbreak;\n\tcase LXC_LOCK_FLOCK:\n\t\tif (l->u.f.fd != -1) {\n\t\t\tlk.l_type = F_UNLCK;\n\t\t\tlk.l_whence = SEEK_SET;\n\t\t\tlk.l_start = 0;\n\t\t\tlk.l_len = 0;\n\t\t\tret = fcntl(l->u.f.fd, F_SETLK, &lk);\n\t\t\tif (ret < 0)\n\t\t\t\tsaved_errno = errno;\n\t\t\tclose(l->u.f.fd);\n\t\t\tl->u.f.fd = -1;\n\t\t} else\n\t\t\tret = -2;\n\t\tbreak;\n\t}\n\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nvoid container_disk_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->slock);\n\tlxcunlock(c->privlock);\n}"
  },
  {
    "function_name": "container_disk_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
    "lines": "352-363",
    "snippet": "int container_disk_lock(struct lxc_container *c)\n{\n\tint ret;\n\n\tif ((ret = lxclock(c->privlock, 0)))\n\t\treturn ret;\n\tif ((ret = lxclock(c->slock, 0))) {\n\t\tlxcunlock(c->privlock);\n\t\treturn ret;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <execinfo.h>",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <pthread.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <malloc.h>",
      "#include \"lxclock.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxcunlock",
          "args": [
            "c->privlock"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "lxcunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "250-282",
          "snippet": "int lxcunlock(struct lxc_lock *l)\n{\n\tint ret = 0, saved_errno = errno;\n\tstruct flock lk;\n\n\tswitch(l->type) {\n\tcase LXC_LOCK_ANON_SEM:\n\t\tif (!l->u.sem)\n\t\t\tret = -2;\n\t\telse {\n\t\t\tret = sem_post(l->u.sem);\n\t\t\tsaved_errno = errno;\n\t\t}\n\t\tbreak;\n\tcase LXC_LOCK_FLOCK:\n\t\tif (l->u.f.fd != -1) {\n\t\t\tlk.l_type = F_UNLCK;\n\t\t\tlk.l_whence = SEEK_SET;\n\t\t\tlk.l_start = 0;\n\t\t\tlk.l_len = 0;\n\t\t\tret = fcntl(l->u.f.fd, F_SETLK, &lk);\n\t\t\tif (ret < 0)\n\t\t\t\tsaved_errno = errno;\n\t\t\tclose(l->u.f.fd);\n\t\t\tl->u.f.fd = -1;\n\t\t} else\n\t\t\tret = -2;\n\t\tbreak;\n\t}\n\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nint lxcunlock(struct lxc_lock *l)\n{\n\tint ret = 0, saved_errno = errno;\n\tstruct flock lk;\n\n\tswitch(l->type) {\n\tcase LXC_LOCK_ANON_SEM:\n\t\tif (!l->u.sem)\n\t\t\tret = -2;\n\t\telse {\n\t\t\tret = sem_post(l->u.sem);\n\t\t\tsaved_errno = errno;\n\t\t}\n\t\tbreak;\n\tcase LXC_LOCK_FLOCK:\n\t\tif (l->u.f.fd != -1) {\n\t\t\tlk.l_type = F_UNLCK;\n\t\t\tlk.l_whence = SEEK_SET;\n\t\t\tlk.l_start = 0;\n\t\t\tlk.l_len = 0;\n\t\t\tret = fcntl(l->u.f.fd, F_SETLK, &lk);\n\t\t\tif (ret < 0)\n\t\t\t\tsaved_errno = errno;\n\t\t\tclose(l->u.f.fd);\n\t\t\tl->u.f.fd = -1;\n\t\t} else\n\t\t\tret = -2;\n\t\tbreak;\n\t}\n\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxclock",
          "args": [
            "c->slock",
            "0"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "lxclock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "192-248",
          "snippet": "int lxclock(struct lxc_lock *l, int timeout)\n{\n\tint ret = -1, saved_errno = errno;\n\tstruct flock lk;\n\n\tswitch(l->type) {\n\tcase LXC_LOCK_ANON_SEM:\n\t\tif (!timeout) {\n\t\t\tret = sem_wait(l->u.sem);\n\t\t\tif (ret == -1)\n\t\t\t\tsaved_errno = errno;\n\t\t} else {\n\t\t\tstruct timespec ts;\n\t\t\tif (clock_gettime(CLOCK_REALTIME, &ts) == -1) {\n\t\t\t\tret = -2;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tts.tv_sec += timeout;\n\t\t\tret = sem_timedwait(l->u.sem, &ts);\n\t\t\tif (ret == -1)\n\t\t\t\tsaved_errno = errno;\n\t\t}\n\t\tbreak;\n\tcase LXC_LOCK_FLOCK:\n\t\tret = -2;\n\t\tif (timeout) {\n\t\t\tERROR(\"Error: timeout not supported with flock\");\n\t\t\tret = -2;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!l->u.f.fname) {\n\t\t\tERROR(\"Error: filename not set for flock\");\n\t\t\tret = -2;\n\t\t\tgoto out;\n\t\t}\n\t\tif (l->u.f.fd == -1) {\n\t\t\tl->u.f.fd = open(l->u.f.fname, O_RDWR|O_CREAT,\n\t\t\t\t\tS_IWUSR | S_IRUSR);\n\t\t\tif (l->u.f.fd == -1) {\n\t\t\t\tERROR(\"Error opening %s\", l->u.f.fname);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tlk.l_type = F_WRLCK;\n\t\tlk.l_whence = SEEK_SET;\n\t\tlk.l_start = 0;\n\t\tlk.l_len = 0;\n\t\tret = fcntl(l->u.f.fd, F_SETLKW, &lk);\n\t\tif (ret == -1)\n\t\t\tsaved_errno = errno;\n\t\tbreak;\n\t}\n\nout:\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nint lxclock(struct lxc_lock *l, int timeout)\n{\n\tint ret = -1, saved_errno = errno;\n\tstruct flock lk;\n\n\tswitch(l->type) {\n\tcase LXC_LOCK_ANON_SEM:\n\t\tif (!timeout) {\n\t\t\tret = sem_wait(l->u.sem);\n\t\t\tif (ret == -1)\n\t\t\t\tsaved_errno = errno;\n\t\t} else {\n\t\t\tstruct timespec ts;\n\t\t\tif (clock_gettime(CLOCK_REALTIME, &ts) == -1) {\n\t\t\t\tret = -2;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tts.tv_sec += timeout;\n\t\t\tret = sem_timedwait(l->u.sem, &ts);\n\t\t\tif (ret == -1)\n\t\t\t\tsaved_errno = errno;\n\t\t}\n\t\tbreak;\n\tcase LXC_LOCK_FLOCK:\n\t\tret = -2;\n\t\tif (timeout) {\n\t\t\tERROR(\"Error: timeout not supported with flock\");\n\t\t\tret = -2;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!l->u.f.fname) {\n\t\t\tERROR(\"Error: filename not set for flock\");\n\t\t\tret = -2;\n\t\t\tgoto out;\n\t\t}\n\t\tif (l->u.f.fd == -1) {\n\t\t\tl->u.f.fd = open(l->u.f.fname, O_RDWR|O_CREAT,\n\t\t\t\t\tS_IWUSR | S_IRUSR);\n\t\t\tif (l->u.f.fd == -1) {\n\t\t\t\tERROR(\"Error opening %s\", l->u.f.fname);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tlk.l_type = F_WRLCK;\n\t\tlk.l_whence = SEEK_SET;\n\t\tlk.l_start = 0;\n\t\tlk.l_len = 0;\n\t\tret = fcntl(l->u.f.fd, F_SETLKW, &lk);\n\t\tif (ret == -1)\n\t\t\tsaved_errno = errno;\n\t\tbreak;\n\t}\n\nout:\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nint container_disk_lock(struct lxc_container *c)\n{\n\tint ret;\n\n\tif ((ret = lxclock(c->privlock, 0)))\n\t\treturn ret;\n\tif ((ret = lxclock(c->slock, 0))) {\n\t\tlxcunlock(c->privlock);\n\t\treturn ret;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "container_mem_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
    "lines": "347-350",
    "snippet": "void container_mem_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->privlock);\n}",
    "includes": [
      "#include <execinfo.h>",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <pthread.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <malloc.h>",
      "#include \"lxclock.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxcunlock",
          "args": [
            "c->privlock"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "lxcunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "250-282",
          "snippet": "int lxcunlock(struct lxc_lock *l)\n{\n\tint ret = 0, saved_errno = errno;\n\tstruct flock lk;\n\n\tswitch(l->type) {\n\tcase LXC_LOCK_ANON_SEM:\n\t\tif (!l->u.sem)\n\t\t\tret = -2;\n\t\telse {\n\t\t\tret = sem_post(l->u.sem);\n\t\t\tsaved_errno = errno;\n\t\t}\n\t\tbreak;\n\tcase LXC_LOCK_FLOCK:\n\t\tif (l->u.f.fd != -1) {\n\t\t\tlk.l_type = F_UNLCK;\n\t\t\tlk.l_whence = SEEK_SET;\n\t\t\tlk.l_start = 0;\n\t\t\tlk.l_len = 0;\n\t\t\tret = fcntl(l->u.f.fd, F_SETLK, &lk);\n\t\t\tif (ret < 0)\n\t\t\t\tsaved_errno = errno;\n\t\t\tclose(l->u.f.fd);\n\t\t\tl->u.f.fd = -1;\n\t\t} else\n\t\t\tret = -2;\n\t\tbreak;\n\t}\n\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nint lxcunlock(struct lxc_lock *l)\n{\n\tint ret = 0, saved_errno = errno;\n\tstruct flock lk;\n\n\tswitch(l->type) {\n\tcase LXC_LOCK_ANON_SEM:\n\t\tif (!l->u.sem)\n\t\t\tret = -2;\n\t\telse {\n\t\t\tret = sem_post(l->u.sem);\n\t\t\tsaved_errno = errno;\n\t\t}\n\t\tbreak;\n\tcase LXC_LOCK_FLOCK:\n\t\tif (l->u.f.fd != -1) {\n\t\t\tlk.l_type = F_UNLCK;\n\t\t\tlk.l_whence = SEEK_SET;\n\t\t\tlk.l_start = 0;\n\t\t\tlk.l_len = 0;\n\t\t\tret = fcntl(l->u.f.fd, F_SETLK, &lk);\n\t\t\tif (ret < 0)\n\t\t\t\tsaved_errno = errno;\n\t\t\tclose(l->u.f.fd);\n\t\t\tl->u.f.fd = -1;\n\t\t} else\n\t\t\tret = -2;\n\t\tbreak;\n\t}\n\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nvoid container_mem_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->privlock);\n}"
  },
  {
    "function_name": "container_mem_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
    "lines": "342-345",
    "snippet": "int container_mem_lock(struct lxc_container *c)\n{\n\treturn lxclock(c->privlock, 0);\n}",
    "includes": [
      "#include <execinfo.h>",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <pthread.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <malloc.h>",
      "#include \"lxclock.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxclock",
          "args": [
            "c->privlock",
            "0"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "lxclock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "192-248",
          "snippet": "int lxclock(struct lxc_lock *l, int timeout)\n{\n\tint ret = -1, saved_errno = errno;\n\tstruct flock lk;\n\n\tswitch(l->type) {\n\tcase LXC_LOCK_ANON_SEM:\n\t\tif (!timeout) {\n\t\t\tret = sem_wait(l->u.sem);\n\t\t\tif (ret == -1)\n\t\t\t\tsaved_errno = errno;\n\t\t} else {\n\t\t\tstruct timespec ts;\n\t\t\tif (clock_gettime(CLOCK_REALTIME, &ts) == -1) {\n\t\t\t\tret = -2;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tts.tv_sec += timeout;\n\t\t\tret = sem_timedwait(l->u.sem, &ts);\n\t\t\tif (ret == -1)\n\t\t\t\tsaved_errno = errno;\n\t\t}\n\t\tbreak;\n\tcase LXC_LOCK_FLOCK:\n\t\tret = -2;\n\t\tif (timeout) {\n\t\t\tERROR(\"Error: timeout not supported with flock\");\n\t\t\tret = -2;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!l->u.f.fname) {\n\t\t\tERROR(\"Error: filename not set for flock\");\n\t\t\tret = -2;\n\t\t\tgoto out;\n\t\t}\n\t\tif (l->u.f.fd == -1) {\n\t\t\tl->u.f.fd = open(l->u.f.fname, O_RDWR|O_CREAT,\n\t\t\t\t\tS_IWUSR | S_IRUSR);\n\t\t\tif (l->u.f.fd == -1) {\n\t\t\t\tERROR(\"Error opening %s\", l->u.f.fname);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tlk.l_type = F_WRLCK;\n\t\tlk.l_whence = SEEK_SET;\n\t\tlk.l_start = 0;\n\t\tlk.l_len = 0;\n\t\tret = fcntl(l->u.f.fd, F_SETLKW, &lk);\n\t\tif (ret == -1)\n\t\t\tsaved_errno = errno;\n\t\tbreak;\n\t}\n\nout:\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nint lxclock(struct lxc_lock *l, int timeout)\n{\n\tint ret = -1, saved_errno = errno;\n\tstruct flock lk;\n\n\tswitch(l->type) {\n\tcase LXC_LOCK_ANON_SEM:\n\t\tif (!timeout) {\n\t\t\tret = sem_wait(l->u.sem);\n\t\t\tif (ret == -1)\n\t\t\t\tsaved_errno = errno;\n\t\t} else {\n\t\t\tstruct timespec ts;\n\t\t\tif (clock_gettime(CLOCK_REALTIME, &ts) == -1) {\n\t\t\t\tret = -2;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tts.tv_sec += timeout;\n\t\t\tret = sem_timedwait(l->u.sem, &ts);\n\t\t\tif (ret == -1)\n\t\t\t\tsaved_errno = errno;\n\t\t}\n\t\tbreak;\n\tcase LXC_LOCK_FLOCK:\n\t\tret = -2;\n\t\tif (timeout) {\n\t\t\tERROR(\"Error: timeout not supported with flock\");\n\t\t\tret = -2;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!l->u.f.fname) {\n\t\t\tERROR(\"Error: filename not set for flock\");\n\t\t\tret = -2;\n\t\t\tgoto out;\n\t\t}\n\t\tif (l->u.f.fd == -1) {\n\t\t\tl->u.f.fd = open(l->u.f.fname, O_RDWR|O_CREAT,\n\t\t\t\t\tS_IWUSR | S_IRUSR);\n\t\t\tif (l->u.f.fd == -1) {\n\t\t\t\tERROR(\"Error opening %s\", l->u.f.fname);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tlk.l_type = F_WRLCK;\n\t\tlk.l_whence = SEEK_SET;\n\t\tlk.l_start = 0;\n\t\tlk.l_len = 0;\n\t\tret = fcntl(l->u.f.fd, F_SETLKW, &lk);\n\t\tif (ret == -1)\n\t\t\tsaved_errno = errno;\n\t\tbreak;\n\t}\n\nout:\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nint container_mem_lock(struct lxc_container *c)\n{\n\treturn lxclock(c->privlock, 0);\n}"
  },
  {
    "function_name": "process_lock_setup_atfork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
    "lines": "335-339",
    "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
    "includes": [
      "#include <execinfo.h>",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <pthread.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <malloc.h>",
      "#include \"lxclock.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pthread_atfork",
          "args": [
            "process_lock",
            "process_unlock",
            "process_unlock"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
  },
  {
    "function_name": "process_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
    "lines": "320-323",
    "snippet": "void process_unlock(void)\n{\n\tunlock_mutex(&thread_mutex);\n}",
    "includes": [
      "#include <execinfo.h>",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <pthread.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <malloc.h>",
      "#include \"lxclock.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_mutex",
          "args": [
            "&thread_mutex"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_mutex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "87-96",
          "snippet": "static void unlock_mutex(pthread_mutex_t *l)\n{\n\tint ret;\n\n\tif ((ret = pthread_mutex_unlock(l)) != 0) {\n\t\tfprintf(stderr, \"pthread_mutex_unlock returned:%d %s\\n\", ret, strerror(ret));\n\t\tdump_stacktrace();\n\t\texit(1);\n\t}\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nstatic void unlock_mutex(pthread_mutex_t *l)\n{\n\tint ret;\n\n\tif ((ret = pthread_mutex_unlock(l)) != 0) {\n\t\tfprintf(stderr, \"pthread_mutex_unlock returned:%d %s\\n\", ret, strerror(ret));\n\t\tdump_stacktrace();\n\t\texit(1);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nvoid process_unlock(void)\n{\n\tunlock_mutex(&thread_mutex);\n}"
  },
  {
    "function_name": "process_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
    "lines": "315-318",
    "snippet": "void process_lock(void)\n{\n\tlock_mutex(&thread_mutex);\n}",
    "includes": [
      "#include <execinfo.h>",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <pthread.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <malloc.h>",
      "#include \"lxclock.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock_mutex",
          "args": [
            "&thread_mutex"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_mutex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "87-96",
          "snippet": "static void unlock_mutex(pthread_mutex_t *l)\n{\n\tint ret;\n\n\tif ((ret = pthread_mutex_unlock(l)) != 0) {\n\t\tfprintf(stderr, \"pthread_mutex_unlock returned:%d %s\\n\", ret, strerror(ret));\n\t\tdump_stacktrace();\n\t\texit(1);\n\t}\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nstatic void unlock_mutex(pthread_mutex_t *l)\n{\n\tint ret;\n\n\tif ((ret = pthread_mutex_unlock(l)) != 0) {\n\t\tfprintf(stderr, \"pthread_mutex_unlock returned:%d %s\\n\", ret, strerror(ret));\n\t\tdump_stacktrace();\n\t\texit(1);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nvoid process_lock(void)\n{\n\tlock_mutex(&thread_mutex);\n}"
  },
  {
    "function_name": "lxc_putlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
    "lines": "291-313",
    "snippet": "void lxc_putlock(struct lxc_lock *l)\n{\n\tif (!l)\n\t\treturn;\n\tswitch(l->type) {\n\tcase LXC_LOCK_ANON_SEM:\n\t\tif (l->u.sem) {\n\t\t\tsem_destroy(l->u.sem);\n\t\t\tfree(l->u.sem);\n\t\t\tl->u.sem = NULL;\n\t\t}\n\t\tbreak;\n\tcase LXC_LOCK_FLOCK:\n\t\tif (l->u.f.fd != -1) {\n\t\t\tclose(l->u.f.fd);\n\t\t\tl->u.f.fd = -1;\n\t\t}\n\t\tfree(l->u.f.fname);\n\t\tl->u.f.fname = NULL;\n\t\tbreak;\n\t}\n\tfree(l);\n}",
    "includes": [
      "#include <execinfo.h>",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <pthread.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <malloc.h>",
      "#include \"lxclock.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "l"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "l->u.f.fd"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sem_destroy",
          "args": [
            "l->u.sem"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nvoid lxc_putlock(struct lxc_lock *l)\n{\n\tif (!l)\n\t\treturn;\n\tswitch(l->type) {\n\tcase LXC_LOCK_ANON_SEM:\n\t\tif (l->u.sem) {\n\t\t\tsem_destroy(l->u.sem);\n\t\t\tfree(l->u.sem);\n\t\t\tl->u.sem = NULL;\n\t\t}\n\t\tbreak;\n\tcase LXC_LOCK_FLOCK:\n\t\tif (l->u.f.fd != -1) {\n\t\t\tclose(l->u.f.fd);\n\t\t\tl->u.f.fd = -1;\n\t\t}\n\t\tfree(l->u.f.fname);\n\t\tl->u.f.fname = NULL;\n\t\tbreak;\n\t}\n\tfree(l);\n}"
  },
  {
    "function_name": "lxcunlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
    "lines": "250-282",
    "snippet": "int lxcunlock(struct lxc_lock *l)\n{\n\tint ret = 0, saved_errno = errno;\n\tstruct flock lk;\n\n\tswitch(l->type) {\n\tcase LXC_LOCK_ANON_SEM:\n\t\tif (!l->u.sem)\n\t\t\tret = -2;\n\t\telse {\n\t\t\tret = sem_post(l->u.sem);\n\t\t\tsaved_errno = errno;\n\t\t}\n\t\tbreak;\n\tcase LXC_LOCK_FLOCK:\n\t\tif (l->u.f.fd != -1) {\n\t\t\tlk.l_type = F_UNLCK;\n\t\t\tlk.l_whence = SEEK_SET;\n\t\t\tlk.l_start = 0;\n\t\t\tlk.l_len = 0;\n\t\t\tret = fcntl(l->u.f.fd, F_SETLK, &lk);\n\t\t\tif (ret < 0)\n\t\t\t\tsaved_errno = errno;\n\t\t\tclose(l->u.f.fd);\n\t\t\tl->u.f.fd = -1;\n\t\t} else\n\t\t\tret = -2;\n\t\tbreak;\n\t}\n\n\terrno = saved_errno;\n\treturn ret;\n}",
    "includes": [
      "#include <execinfo.h>",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <pthread.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <malloc.h>",
      "#include \"lxclock.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "l->u.f.fd"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "l->u.f.fd",
            "F_SETLK",
            "&lk"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sem_post",
          "args": [
            "l->u.sem"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nint lxcunlock(struct lxc_lock *l)\n{\n\tint ret = 0, saved_errno = errno;\n\tstruct flock lk;\n\n\tswitch(l->type) {\n\tcase LXC_LOCK_ANON_SEM:\n\t\tif (!l->u.sem)\n\t\t\tret = -2;\n\t\telse {\n\t\t\tret = sem_post(l->u.sem);\n\t\t\tsaved_errno = errno;\n\t\t}\n\t\tbreak;\n\tcase LXC_LOCK_FLOCK:\n\t\tif (l->u.f.fd != -1) {\n\t\t\tlk.l_type = F_UNLCK;\n\t\t\tlk.l_whence = SEEK_SET;\n\t\t\tlk.l_start = 0;\n\t\t\tlk.l_len = 0;\n\t\t\tret = fcntl(l->u.f.fd, F_SETLK, &lk);\n\t\t\tif (ret < 0)\n\t\t\t\tsaved_errno = errno;\n\t\t\tclose(l->u.f.fd);\n\t\t\tl->u.f.fd = -1;\n\t\t} else\n\t\t\tret = -2;\n\t\tbreak;\n\t}\n\n\terrno = saved_errno;\n\treturn ret;\n}"
  },
  {
    "function_name": "lxclock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
    "lines": "192-248",
    "snippet": "int lxclock(struct lxc_lock *l, int timeout)\n{\n\tint ret = -1, saved_errno = errno;\n\tstruct flock lk;\n\n\tswitch(l->type) {\n\tcase LXC_LOCK_ANON_SEM:\n\t\tif (!timeout) {\n\t\t\tret = sem_wait(l->u.sem);\n\t\t\tif (ret == -1)\n\t\t\t\tsaved_errno = errno;\n\t\t} else {\n\t\t\tstruct timespec ts;\n\t\t\tif (clock_gettime(CLOCK_REALTIME, &ts) == -1) {\n\t\t\t\tret = -2;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tts.tv_sec += timeout;\n\t\t\tret = sem_timedwait(l->u.sem, &ts);\n\t\t\tif (ret == -1)\n\t\t\t\tsaved_errno = errno;\n\t\t}\n\t\tbreak;\n\tcase LXC_LOCK_FLOCK:\n\t\tret = -2;\n\t\tif (timeout) {\n\t\t\tERROR(\"Error: timeout not supported with flock\");\n\t\t\tret = -2;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!l->u.f.fname) {\n\t\t\tERROR(\"Error: filename not set for flock\");\n\t\t\tret = -2;\n\t\t\tgoto out;\n\t\t}\n\t\tif (l->u.f.fd == -1) {\n\t\t\tl->u.f.fd = open(l->u.f.fname, O_RDWR|O_CREAT,\n\t\t\t\t\tS_IWUSR | S_IRUSR);\n\t\t\tif (l->u.f.fd == -1) {\n\t\t\t\tERROR(\"Error opening %s\", l->u.f.fname);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tlk.l_type = F_WRLCK;\n\t\tlk.l_whence = SEEK_SET;\n\t\tlk.l_start = 0;\n\t\tlk.l_len = 0;\n\t\tret = fcntl(l->u.f.fd, F_SETLKW, &lk);\n\t\tif (ret == -1)\n\t\t\tsaved_errno = errno;\n\t\tbreak;\n\t}\n\nout:\n\terrno = saved_errno;\n\treturn ret;\n}",
    "includes": [
      "#include <execinfo.h>",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <pthread.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <malloc.h>",
      "#include \"lxclock.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "l->u.f.fd",
            "F_SETLKW",
            "&lk"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error opening %s\"",
            "l->u.f.fname"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "l->u.f.fname",
            "O_RDWR|O_CREAT",
            "S_IWUSR | S_IRUSR"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "37-82",
          "snippet": "int lxc_abstract_unix_open(const char *path, int type, int flags)\n{\n\tint fd;\n\tsize_t len;\n\tstruct sockaddr_un addr;\n\n\tif (flags & O_TRUNC)\n\t\tunlink(path);\n\n\tfd = socket(PF_UNIX, type, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\n\t/* Clear address structure */\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (!path)\n\t\treturn fd;\n\n\taddr.sun_family = AF_UNIX;\n\n\tlen = strlen(&path[1]) + 1;\n\tif (len >= sizeof(addr.sun_path) - 1) {\n\t\tclose(fd);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\t/* addr.sun_path[0] has already been set to 0 by memset() */\n\tstrncpy(&addr.sun_path[1], &path[1], strlen(&path[1]));\n\n\tif (bind(fd, (struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path) + len)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\tif (type == SOCK_STREAM && listen(fd, 100)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_open(const char *path, int type, int flags)\n{\n\tint fd;\n\tsize_t len;\n\tstruct sockaddr_un addr;\n\n\tif (flags & O_TRUNC)\n\t\tunlink(path);\n\n\tfd = socket(PF_UNIX, type, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\n\t/* Clear address structure */\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (!path)\n\t\treturn fd;\n\n\taddr.sun_family = AF_UNIX;\n\n\tlen = strlen(&path[1]) + 1;\n\tif (len >= sizeof(addr.sun_path) - 1) {\n\t\tclose(fd);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\t/* addr.sun_path[0] has already been set to 0 by memset() */\n\tstrncpy(&addr.sun_path[1], &path[1], strlen(&path[1]));\n\n\tif (bind(fd, (struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path) + len)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\tif (type == SOCK_STREAM && listen(fd, 100)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error: filename not set for flock\""
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error: timeout not supported with flock\""
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sem_timedwait",
          "args": [
            "l->u.sem",
            "&ts"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clock_gettime",
          "args": [
            "CLOCK_REALTIME",
            "&ts"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sem_wait",
          "args": [
            "l->u.sem"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nint lxclock(struct lxc_lock *l, int timeout)\n{\n\tint ret = -1, saved_errno = errno;\n\tstruct flock lk;\n\n\tswitch(l->type) {\n\tcase LXC_LOCK_ANON_SEM:\n\t\tif (!timeout) {\n\t\t\tret = sem_wait(l->u.sem);\n\t\t\tif (ret == -1)\n\t\t\t\tsaved_errno = errno;\n\t\t} else {\n\t\t\tstruct timespec ts;\n\t\t\tif (clock_gettime(CLOCK_REALTIME, &ts) == -1) {\n\t\t\t\tret = -2;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tts.tv_sec += timeout;\n\t\t\tret = sem_timedwait(l->u.sem, &ts);\n\t\t\tif (ret == -1)\n\t\t\t\tsaved_errno = errno;\n\t\t}\n\t\tbreak;\n\tcase LXC_LOCK_FLOCK:\n\t\tret = -2;\n\t\tif (timeout) {\n\t\t\tERROR(\"Error: timeout not supported with flock\");\n\t\t\tret = -2;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!l->u.f.fname) {\n\t\t\tERROR(\"Error: filename not set for flock\");\n\t\t\tret = -2;\n\t\t\tgoto out;\n\t\t}\n\t\tif (l->u.f.fd == -1) {\n\t\t\tl->u.f.fd = open(l->u.f.fname, O_RDWR|O_CREAT,\n\t\t\t\t\tS_IWUSR | S_IRUSR);\n\t\t\tif (l->u.f.fd == -1) {\n\t\t\t\tERROR(\"Error opening %s\", l->u.f.fname);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tlk.l_type = F_WRLCK;\n\t\tlk.l_whence = SEEK_SET;\n\t\tlk.l_start = 0;\n\t\tlk.l_len = 0;\n\t\tret = fcntl(l->u.f.fd, F_SETLKW, &lk);\n\t\tif (ret == -1)\n\t\t\tsaved_errno = errno;\n\t\tbreak;\n\t}\n\nout:\n\terrno = saved_errno;\n\treturn ret;\n}"
  },
  {
    "function_name": "lxc_newlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
    "lines": "161-190",
    "snippet": "struct lxc_lock *lxc_newlock(const char *lxcpath, const char *name)\n{\n\tstruct lxc_lock *l;\n\n\tl = malloc(sizeof(*l));\n\tif (!l)\n\t\tgoto out;\n\n\tif (!name) {\n\t\tl->type = LXC_LOCK_ANON_SEM;\n\t\tl->u.sem = lxc_new_unnamed_sem();\n\t\tif (!l->u.sem) {\n\t\t\tfree(l);\n\t\t\tl = NULL;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tl->type = LXC_LOCK_FLOCK;\n\tl->u.f.fname = lxclock_name(lxcpath, name);\n\tif (!l->u.f.fname) {\n\t\tfree(l);\n\t\tl = NULL;\n\t\tgoto out;\n\t}\n\tl->u.f.fd = -1;\n\nout:\n\treturn l;\n}",
    "includes": [
      "#include <execinfo.h>",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <pthread.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <malloc.h>",
      "#include \"lxclock.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "l"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxclock_name",
          "args": [
            "lxcpath",
            "name"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "lxclock_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "98-143",
          "snippet": "static char *lxclock_name(const char *p, const char *n)\n{\n\tint ret;\n\tint len;\n\tchar *dest;\n\tchar *rundir;\n\n\t/* lockfile will be:\n\t * \"/run\" + \"/lxc/lock/$lxcpath/$lxcname + '\\0' if root\n\t * or\n\t * $XDG_RUNTIME_DIR + \"/lxc/lock/$lxcpath/$lxcname + '\\0' if non-root\n\t */\n\n\t/* length of \"/lxc/lock/\" + $lxcpath + \"/\" + \".\" + $lxcname + '\\0' */\n\tlen = strlen(\"/lxc/lock/\") + strlen(n) + strlen(p) + 3;\n\trundir = get_rundir();\n\tif (!rundir)\n\t\treturn NULL;\n\tlen += strlen(rundir);\n\n\tif ((dest = malloc(len)) == NULL) {\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\n\tret = snprintf(dest, len, \"%s/lxc/lock/%s\", rundir, p);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(dest);\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\tret = mkdir_p(dest, 0755);\n\tif (ret < 0) {\n\t\tfree(dest);\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\n\tret = snprintf(dest, len, \"%s/lxc/lock/%s/.%s\", rundir, p, n);\n\tfree(rundir);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(dest);\n\t\treturn NULL;\n\t}\n\treturn dest;\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nstatic char *lxclock_name(const char *p, const char *n)\n{\n\tint ret;\n\tint len;\n\tchar *dest;\n\tchar *rundir;\n\n\t/* lockfile will be:\n\t * \"/run\" + \"/lxc/lock/$lxcpath/$lxcname + '\\0' if root\n\t * or\n\t * $XDG_RUNTIME_DIR + \"/lxc/lock/$lxcpath/$lxcname + '\\0' if non-root\n\t */\n\n\t/* length of \"/lxc/lock/\" + $lxcpath + \"/\" + \".\" + $lxcname + '\\0' */\n\tlen = strlen(\"/lxc/lock/\") + strlen(n) + strlen(p) + 3;\n\trundir = get_rundir();\n\tif (!rundir)\n\t\treturn NULL;\n\tlen += strlen(rundir);\n\n\tif ((dest = malloc(len)) == NULL) {\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\n\tret = snprintf(dest, len, \"%s/lxc/lock/%s\", rundir, p);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(dest);\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\tret = mkdir_p(dest, 0755);\n\tif (ret < 0) {\n\t\tfree(dest);\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\n\tret = snprintf(dest, len, \"%s/lxc/lock/%s/.%s\", rundir, p, n);\n\tfree(rundir);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(dest);\n\t\treturn NULL;\n\t}\n\treturn dest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_new_unnamed_sem",
          "args": [],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_new_unnamed_sem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "145-159",
          "snippet": "static sem_t *lxc_new_unnamed_sem(void)\n{\n\tsem_t *s;\n\tint ret;\n\n\ts = malloc(sizeof(*s));\n\tif (!s)\n\t\treturn NULL;\n\tret = sem_init(s, 0, 1);\n\tif (ret) {\n\t\tfree(s);\n\t\treturn NULL;\n\t}\n\treturn s;\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nstatic sem_t *lxc_new_unnamed_sem(void)\n{\n\tsem_t *s;\n\tint ret;\n\n\ts = malloc(sizeof(*s));\n\tif (!s)\n\t\treturn NULL;\n\tret = sem_init(s, 0, 1);\n\tif (ret) {\n\t\tfree(s);\n\t\treturn NULL;\n\t}\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*l)"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nstruct lxc_lock *lxc_newlock(const char *lxcpath, const char *name)\n{\n\tstruct lxc_lock *l;\n\n\tl = malloc(sizeof(*l));\n\tif (!l)\n\t\tgoto out;\n\n\tif (!name) {\n\t\tl->type = LXC_LOCK_ANON_SEM;\n\t\tl->u.sem = lxc_new_unnamed_sem();\n\t\tif (!l->u.sem) {\n\t\t\tfree(l);\n\t\t\tl = NULL;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tl->type = LXC_LOCK_FLOCK;\n\tl->u.f.fname = lxclock_name(lxcpath, name);\n\tif (!l->u.f.fname) {\n\t\tfree(l);\n\t\tl = NULL;\n\t\tgoto out;\n\t}\n\tl->u.f.fd = -1;\n\nout:\n\treturn l;\n}"
  },
  {
    "function_name": "lxc_new_unnamed_sem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
    "lines": "145-159",
    "snippet": "static sem_t *lxc_new_unnamed_sem(void)\n{\n\tsem_t *s;\n\tint ret;\n\n\ts = malloc(sizeof(*s));\n\tif (!s)\n\t\treturn NULL;\n\tret = sem_init(s, 0, 1);\n\tif (ret) {\n\t\tfree(s);\n\t\treturn NULL;\n\t}\n\treturn s;\n}",
    "includes": [
      "#include <execinfo.h>",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <pthread.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <malloc.h>",
      "#include \"lxclock.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "s"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "sem_init",
          "args": [
            "s",
            "0",
            "1"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*s)"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nstatic sem_t *lxc_new_unnamed_sem(void)\n{\n\tsem_t *s;\n\tint ret;\n\n\ts = malloc(sizeof(*s));\n\tif (!s)\n\t\treturn NULL;\n\tret = sem_init(s, 0, 1);\n\tif (ret) {\n\t\tfree(s);\n\t\treturn NULL;\n\t}\n\treturn s;\n}"
  },
  {
    "function_name": "lxclock_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
    "lines": "98-143",
    "snippet": "static char *lxclock_name(const char *p, const char *n)\n{\n\tint ret;\n\tint len;\n\tchar *dest;\n\tchar *rundir;\n\n\t/* lockfile will be:\n\t * \"/run\" + \"/lxc/lock/$lxcpath/$lxcname + '\\0' if root\n\t * or\n\t * $XDG_RUNTIME_DIR + \"/lxc/lock/$lxcpath/$lxcname + '\\0' if non-root\n\t */\n\n\t/* length of \"/lxc/lock/\" + $lxcpath + \"/\" + \".\" + $lxcname + '\\0' */\n\tlen = strlen(\"/lxc/lock/\") + strlen(n) + strlen(p) + 3;\n\trundir = get_rundir();\n\tif (!rundir)\n\t\treturn NULL;\n\tlen += strlen(rundir);\n\n\tif ((dest = malloc(len)) == NULL) {\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\n\tret = snprintf(dest, len, \"%s/lxc/lock/%s\", rundir, p);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(dest);\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\tret = mkdir_p(dest, 0755);\n\tif (ret < 0) {\n\t\tfree(dest);\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\n\tret = snprintf(dest, len, \"%s/lxc/lock/%s/.%s\", rundir, p, n);\n\tfree(rundir);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(dest);\n\t\treturn NULL;\n\t}\n\treturn dest;\n}",
    "includes": [
      "#include <execinfo.h>",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <pthread.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <malloc.h>",
      "#include \"lxclock.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dest"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "dest",
            "len",
            "\"%s/lxc/lock/%s/.%s\"",
            "rundir",
            "p",
            "n"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir_p",
          "args": [
            "dest",
            "0755"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "241-262",
          "snippet": "extern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "dest",
            "len",
            "\"%s/lxc/lock/%s\"",
            "rundir",
            "p"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "rundir"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_rundir",
          "args": [],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "get_rundir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "264-291",
          "snippet": "char *get_rundir()\n{\n\tchar *rundir;\n\tconst char *homedir;\n\n\tif (geteuid() == 0) {\n\t\trundir = strdup(RUNTIME_PATH);\n\t\treturn rundir;\n\t}\n\n\trundir = getenv(\"XDG_RUNTIME_DIR\");\n\tif (rundir) {\n\t\trundir = strdup(rundir);\n\t\treturn rundir;\n\t}\n\n\tINFO(\"XDG_RUNTIME_DIR isn't set in the environment.\");\n\thomedir = getenv(\"HOME\");\n\tif (!homedir) {\n\t\tERROR(\"HOME isn't set in the environment.\");\n\t\treturn NULL;\n\t}\n\n\trundir = malloc(sizeof(char) * (17 + strlen(homedir)));\n\tsprintf(rundir, \"%s/.cache/lxc/run/\", homedir);\n\n\treturn rundir;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *get_rundir()\n{\n\tchar *rundir;\n\tconst char *homedir;\n\n\tif (geteuid() == 0) {\n\t\trundir = strdup(RUNTIME_PATH);\n\t\treturn rundir;\n\t}\n\n\trundir = getenv(\"XDG_RUNTIME_DIR\");\n\tif (rundir) {\n\t\trundir = strdup(rundir);\n\t\treturn rundir;\n\t}\n\n\tINFO(\"XDG_RUNTIME_DIR isn't set in the environment.\");\n\thomedir = getenv(\"HOME\");\n\tif (!homedir) {\n\t\tERROR(\"HOME isn't set in the environment.\");\n\t\treturn NULL;\n\t}\n\n\trundir = malloc(sizeof(char) * (17 + strlen(homedir)));\n\tsprintf(rundir, \"%s/.cache/lxc/run/\", homedir);\n\n\treturn rundir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "n"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"/lxc/lock/\""
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nstatic char *lxclock_name(const char *p, const char *n)\n{\n\tint ret;\n\tint len;\n\tchar *dest;\n\tchar *rundir;\n\n\t/* lockfile will be:\n\t * \"/run\" + \"/lxc/lock/$lxcpath/$lxcname + '\\0' if root\n\t * or\n\t * $XDG_RUNTIME_DIR + \"/lxc/lock/$lxcpath/$lxcname + '\\0' if non-root\n\t */\n\n\t/* length of \"/lxc/lock/\" + $lxcpath + \"/\" + \".\" + $lxcname + '\\0' */\n\tlen = strlen(\"/lxc/lock/\") + strlen(n) + strlen(p) + 3;\n\trundir = get_rundir();\n\tif (!rundir)\n\t\treturn NULL;\n\tlen += strlen(rundir);\n\n\tif ((dest = malloc(len)) == NULL) {\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\n\tret = snprintf(dest, len, \"%s/lxc/lock/%s\", rundir, p);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(dest);\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\tret = mkdir_p(dest, 0755);\n\tif (ret < 0) {\n\t\tfree(dest);\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\n\tret = snprintf(dest, len, \"%s/lxc/lock/%s/.%s\", rundir, p, n);\n\tfree(rundir);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(dest);\n\t\treturn NULL;\n\t}\n\treturn dest;\n}"
  },
  {
    "function_name": "unlock_mutex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
    "lines": "87-96",
    "snippet": "static void unlock_mutex(pthread_mutex_t *l)\n{\n\tint ret;\n\n\tif ((ret = pthread_mutex_unlock(l)) != 0) {\n\t\tfprintf(stderr, \"pthread_mutex_unlock returned:%d %s\\n\", ret, strerror(ret));\n\t\tdump_stacktrace();\n\t\texit(1);\n\t}\n}",
    "includes": [
      "#include <execinfo.h>",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <pthread.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <malloc.h>",
      "#include \"lxclock.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_stacktrace",
          "args": [],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "dump_stacktrace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "73-73",
          "snippet": "static inline void dump_stacktrace(void) {;}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nstatic inline void dump_stacktrace(void) {;}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"pthread_mutex_unlock returned:%d %s\\n\"",
            "ret",
            "strerror(ret)"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "ret"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_unlock",
          "args": [
            "l"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nstatic void unlock_mutex(pthread_mutex_t *l)\n{\n\tint ret;\n\n\tif ((ret = pthread_mutex_unlock(l)) != 0) {\n\t\tfprintf(stderr, \"pthread_mutex_unlock returned:%d %s\\n\", ret, strerror(ret));\n\t\tdump_stacktrace();\n\t\texit(1);\n\t}\n}"
  },
  {
    "function_name": "lock_mutex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
    "lines": "76-85",
    "snippet": "static void lock_mutex(pthread_mutex_t *l)\n{\n\tint ret;\n\n\tif ((ret = pthread_mutex_lock(l)) != 0) {\n\t\tfprintf(stderr, \"pthread_mutex_lock returned:%d %s\\n\", ret, strerror(ret));\n\t\tdump_stacktrace();\n\t\texit(1);\n\t}\n}",
    "includes": [
      "#include <execinfo.h>",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <pthread.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <malloc.h>",
      "#include \"lxclock.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_stacktrace",
          "args": [],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "dump_stacktrace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "73-73",
          "snippet": "static inline void dump_stacktrace(void) {;}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nstatic inline void dump_stacktrace(void) {;}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"pthread_mutex_lock returned:%d %s\\n\"",
            "ret",
            "strerror(ret)"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "ret"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_lock",
          "args": [
            "l"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nstatic void lock_mutex(pthread_mutex_t *l)\n{\n\tint ret;\n\n\tif ((ret = pthread_mutex_lock(l)) != 0) {\n\t\tfprintf(stderr, \"pthread_mutex_lock returned:%d %s\\n\", ret, strerror(ret));\n\t\tdump_stacktrace();\n\t\texit(1);\n\t}\n}"
  },
  {
    "function_name": "dump_stacktrace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
    "lines": "73-73",
    "snippet": "static inline void dump_stacktrace(void) {;}",
    "includes": [
      "#include <execinfo.h>",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <pthread.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <malloc.h>",
      "#include \"lxclock.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nstatic inline void dump_stacktrace(void) {;}"
  },
  {
    "function_name": "dump_stacktrace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
    "lines": "52-69",
    "snippet": "static inline void dump_stacktrace(void)\n{\n\tvoid *array[MAX_STACKDEPTH];\n\tsize_t size;\n\tchar **strings;\n\tsize_t i;\n\n\tsize = backtrace(array, MAX_STACKDEPTH);\n\tstrings = backtrace_symbols(array, size);\n\n\t// Using fprintf here as our logging module is not thread safe\n\tfprintf(stderr, \"\\tObtained %zd stack frames.\\n\", size);\n\n\tfor (i = 0; i < size; i++)\n\t\tfprintf(stderr, \"\\t\\t%s\\n\", strings[i]);\n\n\tfree (strings);\n}",
    "includes": [
      "#include <execinfo.h>",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <pthread.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <malloc.h>",
      "#include \"lxclock.h\""
    ],
    "macros_used": [
      "#define MAX_STACKDEPTH 25"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "strings"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\t\\t%s\\n\"",
            "strings[i]"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\tObtained %zd stack frames.\\n\"",
            "size"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "backtrace_symbols",
          "args": [
            "array",
            "size"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "backtrace",
          "args": [
            "array",
            "MAX_STACKDEPTH"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n#define MAX_STACKDEPTH 25\n\nstatic inline void dump_stacktrace(void)\n{\n\tvoid *array[MAX_STACKDEPTH];\n\tsize_t size;\n\tchar **strings;\n\tsize_t i;\n\n\tsize = backtrace(array, MAX_STACKDEPTH);\n\tstrings = backtrace_symbols(array, size);\n\n\t// Using fprintf here as our logging module is not thread safe\n\tfprintf(stderr, \"\\tObtained %zd stack frames.\\n\", size);\n\n\tfor (i = 0; i < size; i++)\n\t\tfprintf(stderr, \"\\t\\t%s\\n\", strings[i]);\n\n\tfree (strings);\n}"
  }
]