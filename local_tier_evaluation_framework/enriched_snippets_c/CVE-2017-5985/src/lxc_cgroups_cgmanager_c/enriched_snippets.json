[
  {
    "function_name": "cgm_mount_cgroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "1644-1652",
    "snippet": "static bool cgm_mount_cgroup(void *hdata, const char *root, int type)\n{\n\tif (dir_exists(CGMANAGER_LOWER_SOCK))\n\t\treturn cgm_bind_dir(root, CGMANAGER_LOWER_SOCK);\n\tif (dir_exists(CGMANAGER_UPPER_SOCK))\n\t\treturn cgm_bind_dir(root, CGMANAGER_UPPER_SOCK);\n\t// Host doesn't have cgmanager running?  Then how did we get here?\n\treturn false;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define CGMANAGER_UPPER_SOCK \"/sys/fs/cgroup/cgmanager\"",
      "#define CGMANAGER_LOWER_SOCK \"/sys/fs/cgroup/cgmanager.lower\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgm_bind_dir",
          "args": [
            "root",
            "CGMANAGER_UPPER_SOCK"
          ],
          "line": 1649
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_bind_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "1602-1633",
          "snippet": "static bool cgm_bind_dir(const char *root, const char *dirname)\n{\n\tnih_local char *cgpath = NULL;\n\n\t/* /sys should have been mounted by now */\n\tcgpath = NIH_MUST( nih_strdup(NULL, root) );\n\tNIH_MUST( nih_strcat(&cgpath, NULL, \"/sys/fs/cgroup\") );\n\n\tif (!dir_exists(cgpath)) {\n\t\tERROR(\"%s does not exist\", cgpath);\n\t\treturn false;\n\t}\n\n\t/* mount a tmpfs there so we can create subdirs */\n\tif (safe_mount(\"cgroup\", cgpath, \"tmpfs\", 0, \"size=10000,mode=755\", root)) {\n\t\tSYSERROR(\"Failed to mount tmpfs at %s\", cgpath);\n\t\treturn false;\n\t}\n\tNIH_MUST( nih_strcat(&cgpath, NULL, \"/cgmanager\") );\n\n\tif (mkdir(cgpath, 0755) < 0) {\n\t\tSYSERROR(\"Failed to create %s\", cgpath);\n\t\treturn false;\n\t}\n\n\tif (safe_mount(dirname, cgpath, \"none\", MS_BIND, 0, root)) {\n\t\tSYSERROR(\"Failed to bind mount %s to %s\", dirname, cgpath);\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgm_bind_dir(const char *root, const char *dirname)\n{\n\tnih_local char *cgpath = NULL;\n\n\t/* /sys should have been mounted by now */\n\tcgpath = NIH_MUST( nih_strdup(NULL, root) );\n\tNIH_MUST( nih_strcat(&cgpath, NULL, \"/sys/fs/cgroup\") );\n\n\tif (!dir_exists(cgpath)) {\n\t\tERROR(\"%s does not exist\", cgpath);\n\t\treturn false;\n\t}\n\n\t/* mount a tmpfs there so we can create subdirs */\n\tif (safe_mount(\"cgroup\", cgpath, \"tmpfs\", 0, \"size=10000,mode=755\", root)) {\n\t\tSYSERROR(\"Failed to mount tmpfs at %s\", cgpath);\n\t\treturn false;\n\t}\n\tNIH_MUST( nih_strcat(&cgpath, NULL, \"/cgmanager\") );\n\n\tif (mkdir(cgpath, 0755) < 0) {\n\t\tSYSERROR(\"Failed to create %s\", cgpath);\n\t\treturn false;\n\t}\n\n\tif (safe_mount(dirname, cgpath, \"none\", MS_BIND, 0, root)) {\n\t\tSYSERROR(\"Failed to bind mount %s to %s\", dirname, cgpath);\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_exists",
          "args": [
            "CGMANAGER_UPPER_SOCK"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "dir_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1059-1069",
          "snippet": "bool dir_exists(const char *path)\n{\n\tstruct stat sb;\n\tint ret;\n\n\tret = stat(path, &sb);\n\tif (ret < 0)\n\t\t// could be something other than eexist, just say no\n\t\treturn false;\n\treturn S_ISDIR(sb.st_mode);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool btrfs_try_remove_subvol(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nbool dir_exists(const char *path)\n{\n\tstruct stat sb;\n\tint ret;\n\n\tret = stat(path, &sb);\n\tif (ret < 0)\n\t\t// could be something other than eexist, just say no\n\t\treturn false;\n\treturn S_ISDIR(sb.st_mode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define CGMANAGER_UPPER_SOCK \"/sys/fs/cgroup/cgmanager\"\n#define CGMANAGER_LOWER_SOCK \"/sys/fs/cgroup/cgmanager.lower\"\n\nstatic bool cgm_mount_cgroup(void *hdata, const char *root, int type)\n{\n\tif (dir_exists(CGMANAGER_LOWER_SOCK))\n\t\treturn cgm_bind_dir(root, CGMANAGER_LOWER_SOCK);\n\tif (dir_exists(CGMANAGER_UPPER_SOCK))\n\t\treturn cgm_bind_dir(root, CGMANAGER_UPPER_SOCK);\n\t// Host doesn't have cgmanager running?  Then how did we get here?\n\treturn false;\n}"
  },
  {
    "function_name": "cgm_bind_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "1602-1633",
    "snippet": "static bool cgm_bind_dir(const char *root, const char *dirname)\n{\n\tnih_local char *cgpath = NULL;\n\n\t/* /sys should have been mounted by now */\n\tcgpath = NIH_MUST( nih_strdup(NULL, root) );\n\tNIH_MUST( nih_strcat(&cgpath, NULL, \"/sys/fs/cgroup\") );\n\n\tif (!dir_exists(cgpath)) {\n\t\tERROR(\"%s does not exist\", cgpath);\n\t\treturn false;\n\t}\n\n\t/* mount a tmpfs there so we can create subdirs */\n\tif (safe_mount(\"cgroup\", cgpath, \"tmpfs\", 0, \"size=10000,mode=755\", root)) {\n\t\tSYSERROR(\"Failed to mount tmpfs at %s\", cgpath);\n\t\treturn false;\n\t}\n\tNIH_MUST( nih_strcat(&cgpath, NULL, \"/cgmanager\") );\n\n\tif (mkdir(cgpath, 0755) < 0) {\n\t\tSYSERROR(\"Failed to create %s\", cgpath);\n\t\treturn false;\n\t}\n\n\tif (safe_mount(dirname, cgpath, \"none\", MS_BIND, 0, root)) {\n\t\tSYSERROR(\"Failed to bind mount %s to %s\", dirname, cgpath);\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to bind mount %s to %s\"",
            "dirname",
            "cgpath"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_mount",
          "args": [
            "dirname",
            "cgpath",
            "\"none\"",
            "MS_BIND",
            "0",
            "root"
          ],
          "line": 1627
        },
        "resolved": true,
        "details": {
          "function_name": "safe_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1687-1743",
          "snippet": "int safe_mount(const char *src, const char *dest, const char *fstype,\n\t\tunsigned long flags, const void *data, const char *rootfs)\n{\n\tint srcfd = -1, destfd, ret, saved_errno;\n\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n\tconst char *mntsrc = src;\n\n\tif (!rootfs)\n\t\trootfs = \"\";\n\n\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n\tif (flags & MS_BIND && src && src[0] != '/') {\n\t\tINFO(\"this is a relative bind mount\");\n\t\tsrcfd = open_without_symlink(src, NULL);\n\t\tif (srcfd < 0)\n\t\t\treturn srcfd;\n\t\tret = snprintf(srcbuf, 50, \"/proc/self/fd/%d\", srcfd);\n\t\tif (ret < 0 || ret > 50) {\n\t\t\tclose(srcfd);\n\t\t\tERROR(\"Out of memory\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmntsrc = srcbuf;\n\t}\n\n\tdestfd = open_without_symlink(dest, rootfs);\n\tif (destfd < 0) {\n\t\tif (srcfd != -1) {\n\t\t\tsaved_errno = errno;\n\t\t\tclose(srcfd);\n\t\t\terrno = saved_errno;\n\t\t}\n\t\treturn destfd;\n\t}\n\n\tret = snprintf(destbuf, 50, \"/proc/self/fd/%d\", destfd);\n\tif (ret < 0 || ret > 50) {\n\t\tif (srcfd != -1)\n\t\t\tclose(srcfd);\n\t\tclose(destfd);\n\t\tERROR(\"Out of memory\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = mount(mntsrc, destbuf, fstype, flags, data);\n\tsaved_errno = errno;\n\tif (srcfd != -1)\n\t\tclose(srcfd);\n\tclose(destfd);\n\tif (ret < 0) {\n\t\terrno = saved_errno;\n\t\tSYSERROR(\"Failed to mount %s onto %s\", src, dest);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint safe_mount(const char *src, const char *dest, const char *fstype,\n\t\tunsigned long flags, const void *data, const char *rootfs)\n{\n\tint srcfd = -1, destfd, ret, saved_errno;\n\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n\tconst char *mntsrc = src;\n\n\tif (!rootfs)\n\t\trootfs = \"\";\n\n\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n\tif (flags & MS_BIND && src && src[0] != '/') {\n\t\tINFO(\"this is a relative bind mount\");\n\t\tsrcfd = open_without_symlink(src, NULL);\n\t\tif (srcfd < 0)\n\t\t\treturn srcfd;\n\t\tret = snprintf(srcbuf, 50, \"/proc/self/fd/%d\", srcfd);\n\t\tif (ret < 0 || ret > 50) {\n\t\t\tclose(srcfd);\n\t\t\tERROR(\"Out of memory\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmntsrc = srcbuf;\n\t}\n\n\tdestfd = open_without_symlink(dest, rootfs);\n\tif (destfd < 0) {\n\t\tif (srcfd != -1) {\n\t\t\tsaved_errno = errno;\n\t\t\tclose(srcfd);\n\t\t\terrno = saved_errno;\n\t\t}\n\t\treturn destfd;\n\t}\n\n\tret = snprintf(destbuf, 50, \"/proc/self/fd/%d\", destfd);\n\tif (ret < 0 || ret > 50) {\n\t\tif (srcfd != -1)\n\t\t\tclose(srcfd);\n\t\tclose(destfd);\n\t\tERROR(\"Out of memory\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = mount(mntsrc, destbuf, fstype, flags, data);\n\tsaved_errno = errno;\n\tif (srcfd != -1)\n\t\tclose(srcfd);\n\tclose(destfd);\n\tif (ret < 0) {\n\t\terrno = saved_errno;\n\t\tSYSERROR(\"Failed to mount %s onto %s\", src, dest);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to create %s\"",
            "cgpath"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "cgpath",
            "0755"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "241-262",
          "snippet": "extern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NIH_MUST",
          "args": [
            "nih_strcat(&cgpath, NULL, \"/cgmanager\")"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nih_strcat",
          "args": [
            "&cgpath",
            "NULL",
            "\"/cgmanager\""
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to mount tmpfs at %s\"",
            "cgpath"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"%s does not exist\"",
            "cgpath"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_exists",
          "args": [
            "cgpath"
          ],
          "line": 1610
        },
        "resolved": true,
        "details": {
          "function_name": "dir_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1059-1069",
          "snippet": "bool dir_exists(const char *path)\n{\n\tstruct stat sb;\n\tint ret;\n\n\tret = stat(path, &sb);\n\tif (ret < 0)\n\t\t// could be something other than eexist, just say no\n\t\treturn false;\n\treturn S_ISDIR(sb.st_mode);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool btrfs_try_remove_subvol(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nbool dir_exists(const char *path)\n{\n\tstruct stat sb;\n\tint ret;\n\n\tret = stat(path, &sb);\n\tif (ret < 0)\n\t\t// could be something other than eexist, just say no\n\t\treturn false;\n\treturn S_ISDIR(sb.st_mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NIH_MUST",
          "args": [
            "nih_strcat(&cgpath, NULL, \"/sys/fs/cgroup\")"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nih_strcat",
          "args": [
            "&cgpath",
            "NULL",
            "\"/sys/fs/cgroup\""
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIH_MUST",
          "args": [
            "nih_strdup(NULL, root)"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nih_strdup",
          "args": [
            "NULL",
            "root"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgm_bind_dir(const char *root, const char *dirname)\n{\n\tnih_local char *cgpath = NULL;\n\n\t/* /sys should have been mounted by now */\n\tcgpath = NIH_MUST( nih_strdup(NULL, root) );\n\tNIH_MUST( nih_strcat(&cgpath, NULL, \"/sys/fs/cgroup\") );\n\n\tif (!dir_exists(cgpath)) {\n\t\tERROR(\"%s does not exist\", cgpath);\n\t\treturn false;\n\t}\n\n\t/* mount a tmpfs there so we can create subdirs */\n\tif (safe_mount(\"cgroup\", cgpath, \"tmpfs\", 0, \"size=10000,mode=755\", root)) {\n\t\tSYSERROR(\"Failed to mount tmpfs at %s\", cgpath);\n\t\treturn false;\n\t}\n\tNIH_MUST( nih_strcat(&cgpath, NULL, \"/cgmanager\") );\n\n\tif (mkdir(cgpath, 0755) < 0) {\n\t\tSYSERROR(\"Failed to create %s\", cgpath);\n\t\treturn false;\n\t}\n\n\tif (safe_mount(dirname, cgpath, \"none\", MS_BIND, 0, root)) {\n\t\tSYSERROR(\"Failed to bind mount %s to %s\", dirname, cgpath);\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "cgm_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "1568-1600",
    "snippet": "static bool cgm_attach(const char *name, const char *lxcpath, pid_t pid)\n{\n\tbool pass = true;\n\tchar *cgroup = NULL;\n\tchar **slist = subsystems;\n\tint i;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\n\tfor (i = 0; slist[i]; i++) {\n\t\tcgroup = try_get_abs_cgroup(name, lxcpath, slist[i]);\n\t\tif (!cgroup) {\n\t\t\tERROR(\"Failed to get cgroup for controller %s\", slist[i]);\n\t\t\tcgm_dbus_disconnect();\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!lxc_cgmanager_enter(pid, slist[i], cgroup, abs_cgroup_supported())) {\n\t\t\tpass = false;\n\t\t\tbreak;\n\t\t}\n\n\t}\n\tcgm_dbus_disconnect();\n\tif (!pass)\n\t\tERROR(\"Failed to enter group %s\", cgroup);\n\n\tfree_abs_cgroup(cgroup);\n\treturn pass;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_abs_cgroup",
          "args": [
            "cgroup"
          ],
          "line": 1598
        },
        "resolved": true,
        "details": {
          "function_name": "free_abs_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "846-854",
          "snippet": "static inline void free_abs_cgroup(char *cgroup)\n{\n\tif (!cgroup)\n\t\treturn;\n\tif (abs_cgroup_supported())\n\t\tnih_free(cgroup);\n\telse\n\t\tfree(cgroup);\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic inline void free_abs_cgroup(char *cgroup)\n{\n\tif (!cgroup)\n\t\treturn;\n\tif (abs_cgroup_supported())\n\t\tnih_free(cgroup);\n\telse\n\t\tfree(cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to enter group %s\"",
            "cgroup"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgm_dbus_disconnect",
          "args": [],
          "line": 1594
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_dbus_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "123-132",
          "snippet": "static void cgm_dbus_disconnect(void)\n{\n\tif (cgroup_manager) {\n\t\tdbus_connection_flush(cgroup_manager->connection);\n\t\tdbus_connection_close(cgroup_manager->connection);\n\t\tnih_free(cgroup_manager);\n\t}\n\tcgroup_manager = NULL;\n\tcgm_unlock();\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void cgm_dbus_disconnect(void)\n{\n\tif (cgroup_manager) {\n\t\tdbus_connection_flush(cgroup_manager->connection);\n\t\tdbus_connection_close(cgroup_manager->connection);\n\t\tnih_free(cgroup_manager);\n\t}\n\tcgroup_manager = NULL;\n\tcgm_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cgmanager_enter",
          "args": [
            "pid",
            "slist[i]",
            "cgroup",
            "abs_cgroup_supported()"
          ],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgmanager_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "690-710",
          "snippet": "static bool lxc_cgmanager_enter(pid_t pid, const char *controller,\n\t\tconst char *cgroup_path, bool abs)\n{\n\tint ret;\n\n\tif (abs)\n\t\tret = cgmanager_move_pid_abs_sync(NULL, cgroup_manager,\n\t\t\tcontroller, cgroup_path, pid);\n\telse\n\t\tret = cgmanager_move_pid_sync(NULL, cgroup_manager,\n\t\t\tcontroller, cgroup_path, pid);\n\tif (ret != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tWARN(\"call to cgmanager_move_pid_%ssync failed: %s\",\n\t\t\tabs ? \"abs_\" : \"\", nerr->message);\n\t\tnih_free(nerr);\n\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool lxc_cgmanager_enter(pid_t pid, const char *controller,\n\t\tconst char *cgroup_path, bool abs)\n{\n\tint ret;\n\n\tif (abs)\n\t\tret = cgmanager_move_pid_abs_sync(NULL, cgroup_manager,\n\t\t\tcontroller, cgroup_path, pid);\n\telse\n\t\tret = cgmanager_move_pid_sync(NULL, cgroup_manager,\n\t\t\tcontroller, cgroup_path, pid);\n\tif (ret != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tWARN(\"call to cgmanager_move_pid_%ssync failed: %s\",\n\t\t\tabs ? \"abs_\" : \"\", nerr->message);\n\t\tnih_free(nerr);\n\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "abs_cgroup_supported",
          "args": [],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "abs_cgroup_supported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "754-756",
          "snippet": "static inline bool abs_cgroup_supported(void) {\n\treturn false;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic inline bool abs_cgroup_supported(void) {\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to get cgroup for controller %s\"",
            "slist[i]"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_get_abs_cgroup",
          "args": [
            "name",
            "lxcpath",
            "slist[i]"
          ],
          "line": 1581
        },
        "resolved": true,
        "details": {
          "function_name": "try_get_abs_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "760-783",
          "snippet": "static char *try_get_abs_cgroup(const char *name, const char *lxcpath,\n\t\tconst char *controller)\n{\n\tchar *cgroup = NULL;\n\n\tif (abs_cgroup_supported()) {\n\t\t/* get the container init pid and ask for its abs cgroup */\n\t\tpid_t pid = lxc_cmd_get_init_pid(name, lxcpath);\n\t\tif (pid < 0)\n\t\t\treturn NULL;\n\t\tif (cgmanager_get_pid_cgroup_abs_sync(NULL, cgroup_manager,\n\t\t\t\tcontroller, pid, &cgroup) != 0) {\n\t\t\tcgroup = NULL;\n\t\t\tNihError *nerr;\n\t\t\tnerr = nih_error_get();\n\t\t\tnih_free(nerr);\n\t\t} else\n\t\t\tprune_init_scope(cgroup);\n\t\treturn cgroup;\n\t}\n\n\t/* use the command interface to look for the cgroup */\n\treturn lxc_cmd_get_cgroup_path(name, lxcpath, controller);\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic char *try_get_abs_cgroup(const char *name, const char *lxcpath,\n\t\tconst char *controller)\n{\n\tchar *cgroup = NULL;\n\n\tif (abs_cgroup_supported()) {\n\t\t/* get the container init pid and ask for its abs cgroup */\n\t\tpid_t pid = lxc_cmd_get_init_pid(name, lxcpath);\n\t\tif (pid < 0)\n\t\t\treturn NULL;\n\t\tif (cgmanager_get_pid_cgroup_abs_sync(NULL, cgroup_manager,\n\t\t\t\tcontroller, pid, &cgroup) != 0) {\n\t\t\tcgroup = NULL;\n\t\t\tNihError *nerr;\n\t\t\tnerr = nih_error_get();\n\t\t\tnih_free(nerr);\n\t\t} else\n\t\t\tprune_init_scope(cgroup);\n\t\treturn cgroup;\n\t}\n\n\t/* use the command interface to look for the cgroup */\n\treturn lxc_cmd_get_cgroup_path(name, lxcpath, controller);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error connecting to cgroup manager\""
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgm_dbus_connect",
          "args": [],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_dbus_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "135-184",
          "snippet": "static bool cgm_dbus_connect(void)\n{\n\tDBusError dbus_error;\n\tstatic DBusConnection *connection;\n\n\tcgm_lock();\n\tif (!dbus_threads_initialized) {\n\t\t// tell dbus to do struct locking for thread safety\n\t\tdbus_threads_init_default();\n\t\tdbus_threads_initialized = true;\n\t}\n\n\tdbus_error_init(&dbus_error);\n\n\tconnection = dbus_connection_open_private(CGMANAGER_DBUS_SOCK, &dbus_error);\n\tif (!connection) {\n\t\tDEBUG(\"Failed opening dbus connection: %s: %s\",\n\t\t\t\tdbus_error.name, dbus_error.message);\n\t\tdbus_error_free(&dbus_error);\n\t\tcgm_unlock();\n\t\treturn false;\n\t}\n\tdbus_connection_set_exit_on_disconnect(connection, FALSE);\n\tdbus_error_free(&dbus_error);\n\tcgroup_manager = nih_dbus_proxy_new(NULL, connection,\n\t\t\t\tNULL /* p2p */,\n\t\t\t\t\"/org/linuxcontainers/cgmanager\", NULL, NULL);\n\tdbus_connection_unref(connection);\n\tif (!cgroup_manager) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error opening cgmanager proxy: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\n\t// get the api version\n\tif (cgmanager_get_api_version_sync(NULL, cgroup_manager, &api_version) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error cgroup manager api version: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\tif (api_version < CGM_SUPPORTS_NAMED)\n\t\tcull_user_controllers();\n\treturn true;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CGMANAGER_DBUS_SOCK \"unix:path=/sys/fs/cgroup/cgmanager/sock\"",
            "#define CGM_SUPPORTS_NAMED 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define CGMANAGER_DBUS_SOCK \"unix:path=/sys/fs/cgroup/cgmanager/sock\"\n#define CGM_SUPPORTS_NAMED 4\n\nstatic bool cgm_dbus_connect(void)\n{\n\tDBusError dbus_error;\n\tstatic DBusConnection *connection;\n\n\tcgm_lock();\n\tif (!dbus_threads_initialized) {\n\t\t// tell dbus to do struct locking for thread safety\n\t\tdbus_threads_init_default();\n\t\tdbus_threads_initialized = true;\n\t}\n\n\tdbus_error_init(&dbus_error);\n\n\tconnection = dbus_connection_open_private(CGMANAGER_DBUS_SOCK, &dbus_error);\n\tif (!connection) {\n\t\tDEBUG(\"Failed opening dbus connection: %s: %s\",\n\t\t\t\tdbus_error.name, dbus_error.message);\n\t\tdbus_error_free(&dbus_error);\n\t\tcgm_unlock();\n\t\treturn false;\n\t}\n\tdbus_connection_set_exit_on_disconnect(connection, FALSE);\n\tdbus_error_free(&dbus_error);\n\tcgroup_manager = nih_dbus_proxy_new(NULL, connection,\n\t\t\t\tNULL /* p2p */,\n\t\t\t\t\"/org/linuxcontainers/cgmanager\", NULL, NULL);\n\tdbus_connection_unref(connection);\n\tif (!cgroup_manager) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error opening cgmanager proxy: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\n\t// get the api version\n\tif (cgmanager_get_api_version_sync(NULL, cgroup_manager, &api_version) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error cgroup manager api version: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\tif (api_version < CGM_SUPPORTS_NAMED)\n\t\tcull_user_controllers();\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgm_attach(const char *name, const char *lxcpath, pid_t pid)\n{\n\tbool pass = true;\n\tchar *cgroup = NULL;\n\tchar **slist = subsystems;\n\tint i;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\n\tfor (i = 0; slist[i]; i++) {\n\t\tcgroup = try_get_abs_cgroup(name, lxcpath, slist[i]);\n\t\tif (!cgroup) {\n\t\t\tERROR(\"Failed to get cgroup for controller %s\", slist[i]);\n\t\t\tcgm_dbus_disconnect();\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!lxc_cgmanager_enter(pid, slist[i], cgroup, abs_cgroup_supported())) {\n\t\t\tpass = false;\n\t\t\tbreak;\n\t\t}\n\n\t}\n\tcgm_dbus_disconnect();\n\tif (!pass)\n\t\tERROR(\"Failed to enter group %s\", cgroup);\n\n\tfree_abs_cgroup(cgroup);\n\treturn pass;\n}"
  },
  {
    "function_name": "cgm_chown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "1544-1558",
    "snippet": "static bool cgm_chown(void *hdata, struct lxc_conf *conf)\n{\n\tstruct cgm_data *d = hdata;\n\n\tif (!d || !d->cgroup_path)\n\t\treturn false;\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\tif (!chown_cgroup(d->cgroup_path, conf))\n\t\tWARN(\"Failed to chown %s to container root\", d->cgroup_path);\n\tcgm_dbus_disconnect();\n\treturn true;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgm_dbus_disconnect",
          "args": [],
          "line": 1556
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_dbus_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "123-132",
          "snippet": "static void cgm_dbus_disconnect(void)\n{\n\tif (cgroup_manager) {\n\t\tdbus_connection_flush(cgroup_manager->connection);\n\t\tdbus_connection_close(cgroup_manager->connection);\n\t\tnih_free(cgroup_manager);\n\t}\n\tcgroup_manager = NULL;\n\tcgm_unlock();\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void cgm_dbus_disconnect(void)\n{\n\tif (cgroup_manager) {\n\t\tdbus_connection_flush(cgroup_manager->connection);\n\t\tdbus_connection_close(cgroup_manager->connection);\n\t\tnih_free(cgroup_manager);\n\t}\n\tcgroup_manager = NULL;\n\tcgm_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to chown %s to container root\"",
            "d->cgroup_path"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chown_cgroup",
          "args": [
            "d->cgroup_path",
            "conf"
          ],
          "line": 1554
        },
        "resolved": true,
        "details": {
          "function_name": "chown_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "484-523",
          "snippet": "static bool chown_cgroup(const char *cgroup_path, struct lxc_conf *conf)\n{\n\tstruct chown_data data;\n\tchar **slist = subsystems;\n\tint i;\n\n\tif (lxc_list_empty(&conf->id_map))\n\t\t/* If there's no mapping then we don't need to chown */\n\t\treturn true;\n\n\tdata.cgroup_path = cgroup_path;\n\tdata.origuid = geteuid();\n\n\t/* Unpriv users can't chown it themselves, so chown from\n\t * a child namespace mapping both our own and the target uid\n\t */\n\tif (userns_exec_1(conf, chown_cgroup_wrapper, &data) < 0) {\n\t\tERROR(\"Error requesting cgroup chown in new namespace\");\n\t\treturn false;\n\t}\n\n\t/*\n\t * Now chmod 775 the directory else the container cannot create cgroups.\n\t * This can't be done in the child namespace because it only group-owns\n\t * the cgroup\n\t */\n\tif (cgm_all_controllers_same)\n\t\tslist = subsystems_inone;\n\n\tfor (i = 0; slist[i]; i++) {\n\t\tif (!lxc_cgmanager_chmod(slist[i], cgroup_path, \"\", 0775))\n\t\t\treturn false;\n\t\tif (!lxc_cgmanager_chmod(slist[i], cgroup_path, \"tasks\", 0664))\n\t\t\treturn false;\n\t\tif (!lxc_cgmanager_chmod(slist[i], cgroup_path, \"cgroup.procs\", 0664))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool chown_cgroup(const char *cgroup_path, struct lxc_conf *conf)\n{\n\tstruct chown_data data;\n\tchar **slist = subsystems;\n\tint i;\n\n\tif (lxc_list_empty(&conf->id_map))\n\t\t/* If there's no mapping then we don't need to chown */\n\t\treturn true;\n\n\tdata.cgroup_path = cgroup_path;\n\tdata.origuid = geteuid();\n\n\t/* Unpriv users can't chown it themselves, so chown from\n\t * a child namespace mapping both our own and the target uid\n\t */\n\tif (userns_exec_1(conf, chown_cgroup_wrapper, &data) < 0) {\n\t\tERROR(\"Error requesting cgroup chown in new namespace\");\n\t\treturn false;\n\t}\n\n\t/*\n\t * Now chmod 775 the directory else the container cannot create cgroups.\n\t * This can't be done in the child namespace because it only group-owns\n\t * the cgroup\n\t */\n\tif (cgm_all_controllers_same)\n\t\tslist = subsystems_inone;\n\n\tfor (i = 0; slist[i]; i++) {\n\t\tif (!lxc_cgmanager_chmod(slist[i], cgroup_path, \"\", 0775))\n\t\t\treturn false;\n\t\tif (!lxc_cgmanager_chmod(slist[i], cgroup_path, \"tasks\", 0664))\n\t\t\treturn false;\n\t\tif (!lxc_cgmanager_chmod(slist[i], cgroup_path, \"cgroup.procs\", 0664))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error connecting to cgroup manager\""
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgm_dbus_connect",
          "args": [],
          "line": 1550
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_dbus_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "135-184",
          "snippet": "static bool cgm_dbus_connect(void)\n{\n\tDBusError dbus_error;\n\tstatic DBusConnection *connection;\n\n\tcgm_lock();\n\tif (!dbus_threads_initialized) {\n\t\t// tell dbus to do struct locking for thread safety\n\t\tdbus_threads_init_default();\n\t\tdbus_threads_initialized = true;\n\t}\n\n\tdbus_error_init(&dbus_error);\n\n\tconnection = dbus_connection_open_private(CGMANAGER_DBUS_SOCK, &dbus_error);\n\tif (!connection) {\n\t\tDEBUG(\"Failed opening dbus connection: %s: %s\",\n\t\t\t\tdbus_error.name, dbus_error.message);\n\t\tdbus_error_free(&dbus_error);\n\t\tcgm_unlock();\n\t\treturn false;\n\t}\n\tdbus_connection_set_exit_on_disconnect(connection, FALSE);\n\tdbus_error_free(&dbus_error);\n\tcgroup_manager = nih_dbus_proxy_new(NULL, connection,\n\t\t\t\tNULL /* p2p */,\n\t\t\t\t\"/org/linuxcontainers/cgmanager\", NULL, NULL);\n\tdbus_connection_unref(connection);\n\tif (!cgroup_manager) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error opening cgmanager proxy: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\n\t// get the api version\n\tif (cgmanager_get_api_version_sync(NULL, cgroup_manager, &api_version) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error cgroup manager api version: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\tif (api_version < CGM_SUPPORTS_NAMED)\n\t\tcull_user_controllers();\n\treturn true;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CGMANAGER_DBUS_SOCK \"unix:path=/sys/fs/cgroup/cgmanager/sock\"",
            "#define CGM_SUPPORTS_NAMED 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define CGMANAGER_DBUS_SOCK \"unix:path=/sys/fs/cgroup/cgmanager/sock\"\n#define CGM_SUPPORTS_NAMED 4\n\nstatic bool cgm_dbus_connect(void)\n{\n\tDBusError dbus_error;\n\tstatic DBusConnection *connection;\n\n\tcgm_lock();\n\tif (!dbus_threads_initialized) {\n\t\t// tell dbus to do struct locking for thread safety\n\t\tdbus_threads_init_default();\n\t\tdbus_threads_initialized = true;\n\t}\n\n\tdbus_error_init(&dbus_error);\n\n\tconnection = dbus_connection_open_private(CGMANAGER_DBUS_SOCK, &dbus_error);\n\tif (!connection) {\n\t\tDEBUG(\"Failed opening dbus connection: %s: %s\",\n\t\t\t\tdbus_error.name, dbus_error.message);\n\t\tdbus_error_free(&dbus_error);\n\t\tcgm_unlock();\n\t\treturn false;\n\t}\n\tdbus_connection_set_exit_on_disconnect(connection, FALSE);\n\tdbus_error_free(&dbus_error);\n\tcgroup_manager = nih_dbus_proxy_new(NULL, connection,\n\t\t\t\tNULL /* p2p */,\n\t\t\t\t\"/org/linuxcontainers/cgmanager\", NULL, NULL);\n\tdbus_connection_unref(connection);\n\tif (!cgroup_manager) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error opening cgmanager proxy: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\n\t// get the api version\n\tif (cgmanager_get_api_version_sync(NULL, cgroup_manager, &api_version) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error cgroup manager api version: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\tif (api_version < CGM_SUPPORTS_NAMED)\n\t\tcull_user_controllers();\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgm_chown(void *hdata, struct lxc_conf *conf)\n{\n\tstruct cgm_data *d = hdata;\n\n\tif (!d || !d->cgroup_path)\n\t\treturn false;\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\tif (!chown_cgroup(d->cgroup_path, conf))\n\t\tWARN(\"Failed to chown %s to container root\", d->cgroup_path);\n\tcgm_dbus_disconnect();\n\treturn true;\n}"
  },
  {
    "function_name": "cgm_setup_limits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "1476-1542",
    "snippet": "static bool cgm_setup_limits(void *hdata, struct lxc_list *cgroup_settings, bool do_devices)\n{\n\tstruct cgm_data *d = hdata;\n\tstruct lxc_list *iterator, *sorted_cgroup_settings, *next;\n\tstruct lxc_cgroup *cg;\n\tbool ret = false;\n\n\tif (lxc_list_empty(cgroup_settings))\n\t\treturn true;\n\n\tif (!d || !d->cgroup_path)\n\t\treturn false;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\n\tsorted_cgroup_settings = sort_cgroup_settings(cgroup_settings);\n\tif (!sorted_cgroup_settings) {\n\t\treturn false;\n\t}\n\n\tlxc_list_for_each(iterator, sorted_cgroup_settings) {\n\t\tchar controller[100], *p;\n\t\tcg = iterator->elem;\n\t\tif (do_devices != !strncmp(\"devices\", cg->subsystem, 7))\n\t\t\tcontinue;\n\t\tif (strlen(cg->subsystem) > 100) // i smell a rat\n\t\t\tgoto out;\n\t\tstrcpy(controller, cg->subsystem);\n\t\tp = strchr(controller, '.');\n\t\tif (p)\n\t\t\t*p = '\\0';\n\t\tif (cgmanager_set_value_sync(NULL, cgroup_manager, controller,\n\t\t\t\t\t d->cgroup_path, cg->subsystem, cg->value) != 0) {\n\t\t\tNihError *nerr;\n\t\t\tnerr = nih_error_get();\n\t\t\tif (do_devices) {\n\t\t\t\tWARN(\"call to cgmanager_set_value_sync failed: %s\", nerr->message);\n\t\t\t\tnih_free(nerr);\n\t\t\t\tWARN(\"Error setting cgroup %s:%s limit type %s\", controller,\n\t\t\t\t\td->cgroup_path, cg->subsystem);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tERROR(\"call to cgmanager_set_value_sync failed: %s\", nerr->message);\n\t\t\tnih_free(nerr);\n\t\t\tERROR(\"Error setting cgroup %s:%s limit type %s\", controller,\n\t\t\t\td->cgroup_path, cg->subsystem);\n\t\t\tgoto out;\n\t\t}\n\n\t\tDEBUG(\"cgroup '%s' set to '%s'\", cg->subsystem, cg->value);\n\t}\n\n\tret = true;\n\tINFO(\"cgroup limits have been setup\");\nout:\n\tlxc_list_for_each_safe(iterator, sorted_cgroup_settings, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(sorted_cgroup_settings);\n\tcgm_dbus_disconnect();\n\treturn ret;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgm_dbus_disconnect",
          "args": [],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_dbus_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "123-132",
          "snippet": "static void cgm_dbus_disconnect(void)\n{\n\tif (cgroup_manager) {\n\t\tdbus_connection_flush(cgroup_manager->connection);\n\t\tdbus_connection_close(cgroup_manager->connection);\n\t\tnih_free(cgroup_manager);\n\t}\n\tcgroup_manager = NULL;\n\tcgm_unlock();\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void cgm_dbus_disconnect(void)\n{\n\tif (cgroup_manager) {\n\t\tdbus_connection_flush(cgroup_manager->connection);\n\t\tdbus_connection_close(cgroup_manager->connection);\n\t\tnih_free(cgroup_manager);\n\t}\n\tcgroup_manager = NULL;\n\tcgm_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "sorted_cgroup_settings"
          ],
          "line": 1539
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "1451-1474",
          "snippet": "static bool cgm_unfreeze(void *hdata)\n{\n\tstruct cgm_data *d = hdata;\n\tbool ret = true;\n\n\tif (!d || !d->cgroup_path)\n\t\treturn false;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\tif (cgmanager_set_value_sync(NULL, cgroup_manager, \"freezer\", d->cgroup_path,\n\t\t\t\"freezer.state\", \"THAWED\") != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_set_value_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Error unfreezing %s\", d->cgroup_path);\n\t\tret = false;\n\t}\n\tcgm_dbus_disconnect();\n\treturn ret;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgm_unfreeze(void *hdata)\n{\n\tstruct cgm_data *d = hdata;\n\tbool ret = true;\n\n\tif (!d || !d->cgroup_path)\n\t\treturn false;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\tif (cgmanager_set_value_sync(NULL, cgroup_manager, \"freezer\", d->cgroup_path,\n\t\t\t\"freezer.state\", \"THAWED\") != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_set_value_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Error unfreezing %s\", d->cgroup_path);\n\t\tret = false;\n\t}\n\tcgm_dbus_disconnect();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_del",
          "args": [
            "iterator"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "148-156",
          "snippet": "static inline void lxc_list_del(struct lxc_list *list)\n{\n\tstruct lxc_list *next, *prev;\n\n\tnext = list->next;\n\tprev = list->prev;\n\tnext->prev = prev;\n\tprev->next = next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void lxc_list_del(struct lxc_list *list)\n{\n\tstruct lxc_list *next, *prev;\n\n\tnext = list->next;\n\tprev = list->prev;\n\tnext->prev = prev;\n\tprev->next = next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each_safe",
          "args": [
            "iterator",
            "sorted_cgroup_settings",
            "next"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"cgroup limits have been setup\""
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"cgroup '%s' set to '%s'\"",
            "cg->subsystem",
            "cg->value"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error setting cgroup %s:%s limit type %s\"",
            "controller",
            "d->cgroup_path",
            "cg->subsystem"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nih_free",
          "args": [
            "nerr"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"call to cgmanager_set_value_sync failed: %s\"",
            "nerr->message"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Error setting cgroup %s:%s limit type %s\"",
            "controller",
            "d->cgroup_path",
            "cg->subsystem"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nih_free",
          "args": [
            "nerr"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"call to cgmanager_set_value_sync failed: %s\"",
            "nerr->message"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nih_error_get",
          "args": [],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgmanager_set_value_sync",
          "args": [
            "NULL",
            "cgroup_manager",
            "controller",
            "d->cgroup_path",
            "cg->subsystem",
            "cg->value"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "controller",
            "'.'"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "controller",
            "cg->subsystem"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cg->subsystem"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "\"devices\"",
            "cg->subsystem",
            "7"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "iterator",
            "sorted_cgroup_settings"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sort_cgroup_settings",
          "args": [
            "cgroup_settings"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "sort_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4634-4672",
          "snippet": "struct lxc_list *sort_cgroup_settings(struct lxc_list* cgroup_settings)\n{\n\tstruct lxc_list *result;\n\tstruct lxc_list *memsw_limit = NULL;\n\tstruct lxc_list *it = NULL;\n\tstruct lxc_cgroup *cg = NULL;\n\tstruct lxc_list *item = NULL;\n\n\tresult = malloc(sizeof(*result));\n\tif (!result) {\n\t\tERROR(\"failed to allocate memory to sort cgroup settings\");\n\t\treturn NULL;\n\t}\n\tlxc_list_init(result);\n\n\t/*Iterate over the cgroup settings and copy them to the output list*/\n\tlxc_list_for_each(it, cgroup_settings) {\n\t\titem = malloc(sizeof(*item));\n\t\tif (!item) {\n\t\t\tERROR(\"failed to allocate memory to sort cgroup settings\");\n\t\t\tfree_cgroup_settings(result);\n\t\t\treturn NULL;\n\t\t}\n\t\titem->elem = it->elem;\n\t\tcg = it->elem;\n\t\tif (strcmp(cg->subsystem, \"memory.memsw.limit_in_bytes\") == 0) {\n\t\t\t/* Store the memsw_limit location */\n\t\t\tmemsw_limit = item;\n\t\t} else if (strcmp(cg->subsystem, \"memory.limit_in_bytes\") == 0 && memsw_limit != NULL) {\n\t\t\t/* lxc.cgroup.memory.memsw.limit_in_bytes is found before\n\t\t\t * lxc.cgroup.memory.limit_in_bytes, swap these two items */\n\t\t\titem->elem = memsw_limit->elem;\n\t\t\tmemsw_limit->elem = it->elem;\n\t\t}\n\t\tlxc_list_add_tail(result, item);\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstruct lxc_list *sort_cgroup_settings(struct lxc_list* cgroup_settings)\n{\n\tstruct lxc_list *result;\n\tstruct lxc_list *memsw_limit = NULL;\n\tstruct lxc_list *it = NULL;\n\tstruct lxc_cgroup *cg = NULL;\n\tstruct lxc_list *item = NULL;\n\n\tresult = malloc(sizeof(*result));\n\tif (!result) {\n\t\tERROR(\"failed to allocate memory to sort cgroup settings\");\n\t\treturn NULL;\n\t}\n\tlxc_list_init(result);\n\n\t/*Iterate over the cgroup settings and copy them to the output list*/\n\tlxc_list_for_each(it, cgroup_settings) {\n\t\titem = malloc(sizeof(*item));\n\t\tif (!item) {\n\t\t\tERROR(\"failed to allocate memory to sort cgroup settings\");\n\t\t\tfree_cgroup_settings(result);\n\t\t\treturn NULL;\n\t\t}\n\t\titem->elem = it->elem;\n\t\tcg = it->elem;\n\t\tif (strcmp(cg->subsystem, \"memory.memsw.limit_in_bytes\") == 0) {\n\t\t\t/* Store the memsw_limit location */\n\t\t\tmemsw_limit = item;\n\t\t} else if (strcmp(cg->subsystem, \"memory.limit_in_bytes\") == 0 && memsw_limit != NULL) {\n\t\t\t/* lxc.cgroup.memory.memsw.limit_in_bytes is found before\n\t\t\t * lxc.cgroup.memory.limit_in_bytes, swap these two items */\n\t\t\titem->elem = memsw_limit->elem;\n\t\t\tmemsw_limit->elem = it->elem;\n\t\t}\n\t\tlxc_list_add_tail(result, item);\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error connecting to cgroup manager\""
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgm_dbus_connect",
          "args": [],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_dbus_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "135-184",
          "snippet": "static bool cgm_dbus_connect(void)\n{\n\tDBusError dbus_error;\n\tstatic DBusConnection *connection;\n\n\tcgm_lock();\n\tif (!dbus_threads_initialized) {\n\t\t// tell dbus to do struct locking for thread safety\n\t\tdbus_threads_init_default();\n\t\tdbus_threads_initialized = true;\n\t}\n\n\tdbus_error_init(&dbus_error);\n\n\tconnection = dbus_connection_open_private(CGMANAGER_DBUS_SOCK, &dbus_error);\n\tif (!connection) {\n\t\tDEBUG(\"Failed opening dbus connection: %s: %s\",\n\t\t\t\tdbus_error.name, dbus_error.message);\n\t\tdbus_error_free(&dbus_error);\n\t\tcgm_unlock();\n\t\treturn false;\n\t}\n\tdbus_connection_set_exit_on_disconnect(connection, FALSE);\n\tdbus_error_free(&dbus_error);\n\tcgroup_manager = nih_dbus_proxy_new(NULL, connection,\n\t\t\t\tNULL /* p2p */,\n\t\t\t\t\"/org/linuxcontainers/cgmanager\", NULL, NULL);\n\tdbus_connection_unref(connection);\n\tif (!cgroup_manager) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error opening cgmanager proxy: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\n\t// get the api version\n\tif (cgmanager_get_api_version_sync(NULL, cgroup_manager, &api_version) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error cgroup manager api version: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\tif (api_version < CGM_SUPPORTS_NAMED)\n\t\tcull_user_controllers();\n\treturn true;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CGMANAGER_DBUS_SOCK \"unix:path=/sys/fs/cgroup/cgmanager/sock\"",
            "#define CGM_SUPPORTS_NAMED 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define CGMANAGER_DBUS_SOCK \"unix:path=/sys/fs/cgroup/cgmanager/sock\"\n#define CGM_SUPPORTS_NAMED 4\n\nstatic bool cgm_dbus_connect(void)\n{\n\tDBusError dbus_error;\n\tstatic DBusConnection *connection;\n\n\tcgm_lock();\n\tif (!dbus_threads_initialized) {\n\t\t// tell dbus to do struct locking for thread safety\n\t\tdbus_threads_init_default();\n\t\tdbus_threads_initialized = true;\n\t}\n\n\tdbus_error_init(&dbus_error);\n\n\tconnection = dbus_connection_open_private(CGMANAGER_DBUS_SOCK, &dbus_error);\n\tif (!connection) {\n\t\tDEBUG(\"Failed opening dbus connection: %s: %s\",\n\t\t\t\tdbus_error.name, dbus_error.message);\n\t\tdbus_error_free(&dbus_error);\n\t\tcgm_unlock();\n\t\treturn false;\n\t}\n\tdbus_connection_set_exit_on_disconnect(connection, FALSE);\n\tdbus_error_free(&dbus_error);\n\tcgroup_manager = nih_dbus_proxy_new(NULL, connection,\n\t\t\t\tNULL /* p2p */,\n\t\t\t\t\"/org/linuxcontainers/cgmanager\", NULL, NULL);\n\tdbus_connection_unref(connection);\n\tif (!cgroup_manager) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error opening cgmanager proxy: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\n\t// get the api version\n\tif (cgmanager_get_api_version_sync(NULL, cgroup_manager, &api_version) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error cgroup manager api version: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\tif (api_version < CGM_SUPPORTS_NAMED)\n\t\tcull_user_controllers();\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_empty",
          "args": [
            "cgroup_settings"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "94-97",
          "snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgm_setup_limits(void *hdata, struct lxc_list *cgroup_settings, bool do_devices)\n{\n\tstruct cgm_data *d = hdata;\n\tstruct lxc_list *iterator, *sorted_cgroup_settings, *next;\n\tstruct lxc_cgroup *cg;\n\tbool ret = false;\n\n\tif (lxc_list_empty(cgroup_settings))\n\t\treturn true;\n\n\tif (!d || !d->cgroup_path)\n\t\treturn false;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\n\tsorted_cgroup_settings = sort_cgroup_settings(cgroup_settings);\n\tif (!sorted_cgroup_settings) {\n\t\treturn false;\n\t}\n\n\tlxc_list_for_each(iterator, sorted_cgroup_settings) {\n\t\tchar controller[100], *p;\n\t\tcg = iterator->elem;\n\t\tif (do_devices != !strncmp(\"devices\", cg->subsystem, 7))\n\t\t\tcontinue;\n\t\tif (strlen(cg->subsystem) > 100) // i smell a rat\n\t\t\tgoto out;\n\t\tstrcpy(controller, cg->subsystem);\n\t\tp = strchr(controller, '.');\n\t\tif (p)\n\t\t\t*p = '\\0';\n\t\tif (cgmanager_set_value_sync(NULL, cgroup_manager, controller,\n\t\t\t\t\t d->cgroup_path, cg->subsystem, cg->value) != 0) {\n\t\t\tNihError *nerr;\n\t\t\tnerr = nih_error_get();\n\t\t\tif (do_devices) {\n\t\t\t\tWARN(\"call to cgmanager_set_value_sync failed: %s\", nerr->message);\n\t\t\t\tnih_free(nerr);\n\t\t\t\tWARN(\"Error setting cgroup %s:%s limit type %s\", controller,\n\t\t\t\t\td->cgroup_path, cg->subsystem);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tERROR(\"call to cgmanager_set_value_sync failed: %s\", nerr->message);\n\t\t\tnih_free(nerr);\n\t\t\tERROR(\"Error setting cgroup %s:%s limit type %s\", controller,\n\t\t\t\td->cgroup_path, cg->subsystem);\n\t\t\tgoto out;\n\t\t}\n\n\t\tDEBUG(\"cgroup '%s' set to '%s'\", cg->subsystem, cg->value);\n\t}\n\n\tret = true;\n\tINFO(\"cgroup limits have been setup\");\nout:\n\tlxc_list_for_each_safe(iterator, sorted_cgroup_settings, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(sorted_cgroup_settings);\n\tcgm_dbus_disconnect();\n\treturn ret;\n}"
  },
  {
    "function_name": "cgm_unfreeze",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "1451-1474",
    "snippet": "static bool cgm_unfreeze(void *hdata)\n{\n\tstruct cgm_data *d = hdata;\n\tbool ret = true;\n\n\tif (!d || !d->cgroup_path)\n\t\treturn false;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\tif (cgmanager_set_value_sync(NULL, cgroup_manager, \"freezer\", d->cgroup_path,\n\t\t\t\"freezer.state\", \"THAWED\") != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_set_value_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Error unfreezing %s\", d->cgroup_path);\n\t\tret = false;\n\t}\n\tcgm_dbus_disconnect();\n\treturn ret;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgm_dbus_disconnect",
          "args": [],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_dbus_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "123-132",
          "snippet": "static void cgm_dbus_disconnect(void)\n{\n\tif (cgroup_manager) {\n\t\tdbus_connection_flush(cgroup_manager->connection);\n\t\tdbus_connection_close(cgroup_manager->connection);\n\t\tnih_free(cgroup_manager);\n\t}\n\tcgroup_manager = NULL;\n\tcgm_unlock();\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void cgm_dbus_disconnect(void)\n{\n\tif (cgroup_manager) {\n\t\tdbus_connection_flush(cgroup_manager->connection);\n\t\tdbus_connection_close(cgroup_manager->connection);\n\t\tnih_free(cgroup_manager);\n\t}\n\tcgroup_manager = NULL;\n\tcgm_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error unfreezing %s\"",
            "d->cgroup_path"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nih_free",
          "args": [
            "nerr"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"call to cgmanager_set_value_sync failed: %s\"",
            "nerr->message"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nih_error_get",
          "args": [],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgmanager_set_value_sync",
          "args": [
            "NULL",
            "cgroup_manager",
            "\"freezer\"",
            "d->cgroup_path",
            "\"freezer.state\"",
            "\"THAWED\""
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error connecting to cgroup manager\""
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgm_dbus_connect",
          "args": [],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_dbus_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "135-184",
          "snippet": "static bool cgm_dbus_connect(void)\n{\n\tDBusError dbus_error;\n\tstatic DBusConnection *connection;\n\n\tcgm_lock();\n\tif (!dbus_threads_initialized) {\n\t\t// tell dbus to do struct locking for thread safety\n\t\tdbus_threads_init_default();\n\t\tdbus_threads_initialized = true;\n\t}\n\n\tdbus_error_init(&dbus_error);\n\n\tconnection = dbus_connection_open_private(CGMANAGER_DBUS_SOCK, &dbus_error);\n\tif (!connection) {\n\t\tDEBUG(\"Failed opening dbus connection: %s: %s\",\n\t\t\t\tdbus_error.name, dbus_error.message);\n\t\tdbus_error_free(&dbus_error);\n\t\tcgm_unlock();\n\t\treturn false;\n\t}\n\tdbus_connection_set_exit_on_disconnect(connection, FALSE);\n\tdbus_error_free(&dbus_error);\n\tcgroup_manager = nih_dbus_proxy_new(NULL, connection,\n\t\t\t\tNULL /* p2p */,\n\t\t\t\t\"/org/linuxcontainers/cgmanager\", NULL, NULL);\n\tdbus_connection_unref(connection);\n\tif (!cgroup_manager) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error opening cgmanager proxy: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\n\t// get the api version\n\tif (cgmanager_get_api_version_sync(NULL, cgroup_manager, &api_version) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error cgroup manager api version: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\tif (api_version < CGM_SUPPORTS_NAMED)\n\t\tcull_user_controllers();\n\treturn true;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CGMANAGER_DBUS_SOCK \"unix:path=/sys/fs/cgroup/cgmanager/sock\"",
            "#define CGM_SUPPORTS_NAMED 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define CGMANAGER_DBUS_SOCK \"unix:path=/sys/fs/cgroup/cgmanager/sock\"\n#define CGM_SUPPORTS_NAMED 4\n\nstatic bool cgm_dbus_connect(void)\n{\n\tDBusError dbus_error;\n\tstatic DBusConnection *connection;\n\n\tcgm_lock();\n\tif (!dbus_threads_initialized) {\n\t\t// tell dbus to do struct locking for thread safety\n\t\tdbus_threads_init_default();\n\t\tdbus_threads_initialized = true;\n\t}\n\n\tdbus_error_init(&dbus_error);\n\n\tconnection = dbus_connection_open_private(CGMANAGER_DBUS_SOCK, &dbus_error);\n\tif (!connection) {\n\t\tDEBUG(\"Failed opening dbus connection: %s: %s\",\n\t\t\t\tdbus_error.name, dbus_error.message);\n\t\tdbus_error_free(&dbus_error);\n\t\tcgm_unlock();\n\t\treturn false;\n\t}\n\tdbus_connection_set_exit_on_disconnect(connection, FALSE);\n\tdbus_error_free(&dbus_error);\n\tcgroup_manager = nih_dbus_proxy_new(NULL, connection,\n\t\t\t\tNULL /* p2p */,\n\t\t\t\t\"/org/linuxcontainers/cgmanager\", NULL, NULL);\n\tdbus_connection_unref(connection);\n\tif (!cgroup_manager) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error opening cgmanager proxy: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\n\t// get the api version\n\tif (cgmanager_get_api_version_sync(NULL, cgroup_manager, &api_version) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error cgroup manager api version: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\tif (api_version < CGM_SUPPORTS_NAMED)\n\t\tcull_user_controllers();\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgm_unfreeze(void *hdata)\n{\n\tstruct cgm_data *d = hdata;\n\tbool ret = true;\n\n\tif (!d || !d->cgroup_path)\n\t\treturn false;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\tif (cgmanager_set_value_sync(NULL, cgroup_manager, \"freezer\", d->cgroup_path,\n\t\t\t\"freezer.state\", \"THAWED\") != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_set_value_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Error unfreezing %s\", d->cgroup_path);\n\t\tret = false;\n\t}\n\tcgm_dbus_disconnect();\n\treturn ret;\n}"
  },
  {
    "function_name": "cgm_ops_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "1432-1448",
    "snippet": "struct cgroup_ops *cgm_ops_init(void)\n{\n\tcheck_supports_multiple_controllers(-1);\n\tif (!collect_subsystems())\n\t\treturn NULL;\n\n\tif (api_version < CGM_SUPPORTS_MULT_CONTROLLERS)\n\t\tcgm_all_controllers_same = false;\n\n\t// if root, try to escape to root cgroup\n\tif (geteuid() == 0 && !cgm_escape(NULL)) {\n\t\tfree_subsystems();\n\t\treturn NULL;\n\t}\n\n\treturn &cgmanager_ops;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define CGM_SUPPORTS_MULT_CONTROLLERS 10"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_subsystems",
          "args": [],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "free_subsystems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "1097-1106",
          "snippet": "static void free_subsystems(void)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_subsystems; i++)\n\t\tfree(subsystems[i]);\n\tfree(subsystems);\n\tsubsystems = NULL;\n\tnr_subsystems = 0;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void free_subsystems(void)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_subsystems; i++)\n\t\tfree(subsystems[i]);\n\tfree(subsystems);\n\tsubsystems = NULL;\n\tnr_subsystems = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgm_escape",
          "args": [
            "NULL"
          ],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_escape",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "302-338",
          "snippet": "static bool cgm_escape(void *hdata)\n{\n\tbool ret = true, cgm_needs_disconnect = false;\n\tpid_t me = getpid();\n\tchar **slist = subsystems;\n\tint i;\n\n\tif (!cgroup_manager) {\n\t\tif (!cgm_dbus_connect()) {\n\t\t\tERROR(\"Error connecting to cgroup manager\");\n\t\t\treturn false;\n\t\t}\n\t\tcgm_needs_disconnect = true;\n\t}\n\n\n\tif (cgm_all_controllers_same)\n\t\tslist = subsystems_inone;\n\n\tfor (i = 0; slist[i]; i++) {\n\t\tif (cgmanager_move_pid_abs_sync(NULL, cgroup_manager,\n\t\t\t\t\tslist[i], \"/\", me) != 0) {\n\t\t\tNihError *nerr;\n\t\t\tnerr = nih_error_get();\n\t\t\tERROR(\"call to cgmanager_move_pid_abs_sync(%s) failed: %s\",\n\t\t\t\t\tslist[i], nerr->message);\n\t\t\tnih_free(nerr);\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (cgm_needs_disconnect)\n\t\tcgm_dbus_disconnect();\n\n\treturn ret;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgm_escape(void *hdata)\n{\n\tbool ret = true, cgm_needs_disconnect = false;\n\tpid_t me = getpid();\n\tchar **slist = subsystems;\n\tint i;\n\n\tif (!cgroup_manager) {\n\t\tif (!cgm_dbus_connect()) {\n\t\t\tERROR(\"Error connecting to cgroup manager\");\n\t\t\treturn false;\n\t\t}\n\t\tcgm_needs_disconnect = true;\n\t}\n\n\n\tif (cgm_all_controllers_same)\n\t\tslist = subsystems_inone;\n\n\tfor (i = 0; slist[i]; i++) {\n\t\tif (cgmanager_move_pid_abs_sync(NULL, cgroup_manager,\n\t\t\t\t\tslist[i], \"/\", me) != 0) {\n\t\t\tNihError *nerr;\n\t\t\tnerr = nih_error_get();\n\t\t\tERROR(\"call to cgmanager_move_pid_abs_sync(%s) failed: %s\",\n\t\t\t\t\tslist[i], nerr->message);\n\t\t\tnih_free(nerr);\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (cgm_needs_disconnect)\n\t\tcgm_dbus_disconnect();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "collect_subsystems",
          "args": [],
          "line": 1435
        },
        "resolved": true,
        "details": {
          "function_name": "collect_subsystems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "1323-1425",
          "snippet": "static bool collect_subsystems(void)\n{\n\tchar *line = NULL;\n\tnih_local char **cgm_subsys_list = NULL;\n\tsize_t sz = 0;\n\tFILE *f = NULL;\n\n\tif (subsystems) // already initialized\n\t\treturn true;\n\n\tsubsystems_inone = malloc(2 * sizeof(char *));\n\tif (!subsystems_inone)\n\t\treturn false;\n\tsubsystems_inone[0] = \"all\";\n\tsubsystems_inone[1] = NULL;\n\n\tif (lxc_list_controllers(&cgm_subsys_list)) {\n\t\twhile (cgm_subsys_list[nr_subsystems]) {\n\t\t\tchar **tmp = NIH_MUST( realloc(subsystems,\n\t\t\t\t\t\t(nr_subsystems+2)*sizeof(char *)) );\n\t\t\ttmp[nr_subsystems] = NIH_MUST(\n\t\t\t\t\tstrdup(cgm_subsys_list[nr_subsystems++]) );\n\t\t\tsubsystems = tmp;\n\t\t}\n\t\tif (nr_subsystems)\n\t\t\tsubsystems[nr_subsystems] = NULL;\n\t\tgoto collected;\n\t}\n\n\tINFO(\"cgmanager_list_controllers failed, falling back to /proc/self/cgroups\");\n\tf = fopen_cloexec(\"/proc/self/cgroup\", \"r\");\n\tif (!f) {\n\t\tf = fopen_cloexec(\"/proc/1/cgroup\", \"r\");\n\t\tif (!f)\n\t\t\treturn false;\n\t}\n\twhile (getline(&line, &sz, f) != -1) {\n\t\t/* file format: hierarchy:subsystems:group,\n\t\t * with multiple subsystems being ,-separated */\n\t\tchar *slist, *end, *p, *saveptr = NULL, **tmp;\n\n\t\tif (!line[0])\n\t\t\tcontinue;\n\n\t\tslist = strchr(line, ':');\n\t\tif (!slist)\n\t\t\tcontinue;\n\t\tslist++;\n\t\tend = strchr(slist, ':');\n\t\tif (!end)\n\t\t\tcontinue;\n\t\t*end = '\\0';\n\n\t\tfor (p = strtok_r(slist, \",\", &saveptr);\n\t\t\t\tp;\n\t\t\t\tp = strtok_r(NULL, \",\", &saveptr)) {\n\t\t\ttmp = realloc(subsystems, (nr_subsystems+2)*sizeof(char *));\n\t\t\tif (!tmp)\n\t\t\t\tgoto out_free;\n\n\t\t\tsubsystems = tmp;\n\t\t\ttmp[nr_subsystems] = strdup(p);\n\t\t\ttmp[nr_subsystems+1] = NULL;\n\t\t\tif (!tmp[nr_subsystems])\n\t\t\t\tgoto out_free;\n\t\t\tnr_subsystems++;\n\t\t}\n\t}\n\tfclose(f);\n\tf = NULL;\n\n\tfree(line);\n\tline = NULL;\n\ncollected:\n\tif (!nr_subsystems) {\n\t\tERROR(\"No cgroup subsystems found\");\n\t\treturn false;\n\t}\n\n\t/* make sure that cgroup.use can be and is honored */\n\tconst char *cgroup_use = lxc_global_config_value(\"lxc.cgroup.use\");\n\tif (!cgroup_use && errno != 0)\n\t\tgoto final_verify;\n\tif (cgroup_use) {\n\t\tif (!verify_and_prune(cgroup_use)) {\n\t\t\tfree_subsystems();\n\t\t\treturn false;\n\t\t}\n\t\tsubsystems_inone[0] = NIH_MUST( strdup(cgroup_use) );\n\t\tcgm_all_controllers_same = false;\n\t}\n\nfinal_verify:\n\treturn verify_final_subsystems(cgroup_use);\n\nout_free:\n\tfree(line);\n\tif (f)\n\t\tfclose(f);\n\tfree_subsystems();\n\treturn false;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool collect_subsystems(void)\n{\n\tchar *line = NULL;\n\tnih_local char **cgm_subsys_list = NULL;\n\tsize_t sz = 0;\n\tFILE *f = NULL;\n\n\tif (subsystems) // already initialized\n\t\treturn true;\n\n\tsubsystems_inone = malloc(2 * sizeof(char *));\n\tif (!subsystems_inone)\n\t\treturn false;\n\tsubsystems_inone[0] = \"all\";\n\tsubsystems_inone[1] = NULL;\n\n\tif (lxc_list_controllers(&cgm_subsys_list)) {\n\t\twhile (cgm_subsys_list[nr_subsystems]) {\n\t\t\tchar **tmp = NIH_MUST( realloc(subsystems,\n\t\t\t\t\t\t(nr_subsystems+2)*sizeof(char *)) );\n\t\t\ttmp[nr_subsystems] = NIH_MUST(\n\t\t\t\t\tstrdup(cgm_subsys_list[nr_subsystems++]) );\n\t\t\tsubsystems = tmp;\n\t\t}\n\t\tif (nr_subsystems)\n\t\t\tsubsystems[nr_subsystems] = NULL;\n\t\tgoto collected;\n\t}\n\n\tINFO(\"cgmanager_list_controllers failed, falling back to /proc/self/cgroups\");\n\tf = fopen_cloexec(\"/proc/self/cgroup\", \"r\");\n\tif (!f) {\n\t\tf = fopen_cloexec(\"/proc/1/cgroup\", \"r\");\n\t\tif (!f)\n\t\t\treturn false;\n\t}\n\twhile (getline(&line, &sz, f) != -1) {\n\t\t/* file format: hierarchy:subsystems:group,\n\t\t * with multiple subsystems being ,-separated */\n\t\tchar *slist, *end, *p, *saveptr = NULL, **tmp;\n\n\t\tif (!line[0])\n\t\t\tcontinue;\n\n\t\tslist = strchr(line, ':');\n\t\tif (!slist)\n\t\t\tcontinue;\n\t\tslist++;\n\t\tend = strchr(slist, ':');\n\t\tif (!end)\n\t\t\tcontinue;\n\t\t*end = '\\0';\n\n\t\tfor (p = strtok_r(slist, \",\", &saveptr);\n\t\t\t\tp;\n\t\t\t\tp = strtok_r(NULL, \",\", &saveptr)) {\n\t\t\ttmp = realloc(subsystems, (nr_subsystems+2)*sizeof(char *));\n\t\t\tif (!tmp)\n\t\t\t\tgoto out_free;\n\n\t\t\tsubsystems = tmp;\n\t\t\ttmp[nr_subsystems] = strdup(p);\n\t\t\ttmp[nr_subsystems+1] = NULL;\n\t\t\tif (!tmp[nr_subsystems])\n\t\t\t\tgoto out_free;\n\t\t\tnr_subsystems++;\n\t\t}\n\t}\n\tfclose(f);\n\tf = NULL;\n\n\tfree(line);\n\tline = NULL;\n\ncollected:\n\tif (!nr_subsystems) {\n\t\tERROR(\"No cgroup subsystems found\");\n\t\treturn false;\n\t}\n\n\t/* make sure that cgroup.use can be and is honored */\n\tconst char *cgroup_use = lxc_global_config_value(\"lxc.cgroup.use\");\n\tif (!cgroup_use && errno != 0)\n\t\tgoto final_verify;\n\tif (cgroup_use) {\n\t\tif (!verify_and_prune(cgroup_use)) {\n\t\t\tfree_subsystems();\n\t\t\treturn false;\n\t\t}\n\t\tsubsystems_inone[0] = NIH_MUST( strdup(cgroup_use) );\n\t\tcgm_all_controllers_same = false;\n\t}\n\nfinal_verify:\n\treturn verify_final_subsystems(cgroup_use);\n\nout_free:\n\tfree(line);\n\tif (f)\n\t\tfclose(f);\n\tfree_subsystems();\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_supports_multiple_controllers",
          "args": [
            "-1"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "check_supports_multiple_controllers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "198-243",
          "snippet": "static void check_supports_multiple_controllers(pid_t pid)\n{\n\tFILE *f;\n\tchar *line = NULL, *prevpath = NULL;\n\tsize_t sz = 0;\n\tchar path[100];\n\n\tcgm_all_controllers_same = false;\n\n\tif (pid == -1)\n\t\tsprintf(path, \"/proc/self/cgroup\");\n\telse\n\t\tsprintf(path, \"/proc/%d/cgroup\", pid);\n\tf = fopen(path, \"r\");\n\tif (!f)\n\t\treturn;\n\n\tcgm_all_controllers_same = true;\n\n\twhile (getline(&line, &sz, f) != -1) {\n\t\t/* file format: hierarchy:subsystems:group */\n\t\tchar *colon;\n\t\tif (!line[0])\n\t\t\tcontinue;\n\n\t\tcolon = strchr(line, ':');\n\t\tif (!colon)\n\t\t\tcontinue;\n\t\tcolon = strchr(colon+1, ':');\n\t\tif (!colon)\n\t\t\tcontinue;\n\t\tcolon++;\n\t\tif (!prevpath) {\n\t\t\tprevpath = alloca(strlen(colon)+1);\n\t\t\tstrcpy(prevpath, colon);\n\t\t\tcontinue;\n\t\t}\n\t\tif (strcmp(prevpath, colon) != 0) {\n\t\t\tcgm_all_controllers_same = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfclose(f);\n\tfree(line);\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void check_supports_multiple_controllers(pid_t pid)\n{\n\tFILE *f;\n\tchar *line = NULL, *prevpath = NULL;\n\tsize_t sz = 0;\n\tchar path[100];\n\n\tcgm_all_controllers_same = false;\n\n\tif (pid == -1)\n\t\tsprintf(path, \"/proc/self/cgroup\");\n\telse\n\t\tsprintf(path, \"/proc/%d/cgroup\", pid);\n\tf = fopen(path, \"r\");\n\tif (!f)\n\t\treturn;\n\n\tcgm_all_controllers_same = true;\n\n\twhile (getline(&line, &sz, f) != -1) {\n\t\t/* file format: hierarchy:subsystems:group */\n\t\tchar *colon;\n\t\tif (!line[0])\n\t\t\tcontinue;\n\n\t\tcolon = strchr(line, ':');\n\t\tif (!colon)\n\t\t\tcontinue;\n\t\tcolon = strchr(colon+1, ':');\n\t\tif (!colon)\n\t\t\tcontinue;\n\t\tcolon++;\n\t\tif (!prevpath) {\n\t\t\tprevpath = alloca(strlen(colon)+1);\n\t\t\tstrcpy(prevpath, colon);\n\t\t\tcontinue;\n\t\t}\n\t\tif (strcmp(prevpath, colon) != 0) {\n\t\t\tcgm_all_controllers_same = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfclose(f);\n\tfree(line);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define CGM_SUPPORTS_MULT_CONTROLLERS 10\n\nstruct cgroup_ops *cgm_ops_init(void)\n{\n\tcheck_supports_multiple_controllers(-1);\n\tif (!collect_subsystems())\n\t\treturn NULL;\n\n\tif (api_version < CGM_SUPPORTS_MULT_CONTROLLERS)\n\t\tcgm_all_controllers_same = false;\n\n\t// if root, try to escape to root cgroup\n\tif (geteuid() == 0 && !cgm_escape(NULL)) {\n\t\tfree_subsystems();\n\t\treturn NULL;\n\t}\n\n\treturn &cgmanager_ops;\n}"
  },
  {
    "function_name": "collect_subsystems",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "1323-1425",
    "snippet": "static bool collect_subsystems(void)\n{\n\tchar *line = NULL;\n\tnih_local char **cgm_subsys_list = NULL;\n\tsize_t sz = 0;\n\tFILE *f = NULL;\n\n\tif (subsystems) // already initialized\n\t\treturn true;\n\n\tsubsystems_inone = malloc(2 * sizeof(char *));\n\tif (!subsystems_inone)\n\t\treturn false;\n\tsubsystems_inone[0] = \"all\";\n\tsubsystems_inone[1] = NULL;\n\n\tif (lxc_list_controllers(&cgm_subsys_list)) {\n\t\twhile (cgm_subsys_list[nr_subsystems]) {\n\t\t\tchar **tmp = NIH_MUST( realloc(subsystems,\n\t\t\t\t\t\t(nr_subsystems+2)*sizeof(char *)) );\n\t\t\ttmp[nr_subsystems] = NIH_MUST(\n\t\t\t\t\tstrdup(cgm_subsys_list[nr_subsystems++]) );\n\t\t\tsubsystems = tmp;\n\t\t}\n\t\tif (nr_subsystems)\n\t\t\tsubsystems[nr_subsystems] = NULL;\n\t\tgoto collected;\n\t}\n\n\tINFO(\"cgmanager_list_controllers failed, falling back to /proc/self/cgroups\");\n\tf = fopen_cloexec(\"/proc/self/cgroup\", \"r\");\n\tif (!f) {\n\t\tf = fopen_cloexec(\"/proc/1/cgroup\", \"r\");\n\t\tif (!f)\n\t\t\treturn false;\n\t}\n\twhile (getline(&line, &sz, f) != -1) {\n\t\t/* file format: hierarchy:subsystems:group,\n\t\t * with multiple subsystems being ,-separated */\n\t\tchar *slist, *end, *p, *saveptr = NULL, **tmp;\n\n\t\tif (!line[0])\n\t\t\tcontinue;\n\n\t\tslist = strchr(line, ':');\n\t\tif (!slist)\n\t\t\tcontinue;\n\t\tslist++;\n\t\tend = strchr(slist, ':');\n\t\tif (!end)\n\t\t\tcontinue;\n\t\t*end = '\\0';\n\n\t\tfor (p = strtok_r(slist, \",\", &saveptr);\n\t\t\t\tp;\n\t\t\t\tp = strtok_r(NULL, \",\", &saveptr)) {\n\t\t\ttmp = realloc(subsystems, (nr_subsystems+2)*sizeof(char *));\n\t\t\tif (!tmp)\n\t\t\t\tgoto out_free;\n\n\t\t\tsubsystems = tmp;\n\t\t\ttmp[nr_subsystems] = strdup(p);\n\t\t\ttmp[nr_subsystems+1] = NULL;\n\t\t\tif (!tmp[nr_subsystems])\n\t\t\t\tgoto out_free;\n\t\t\tnr_subsystems++;\n\t\t}\n\t}\n\tfclose(f);\n\tf = NULL;\n\n\tfree(line);\n\tline = NULL;\n\ncollected:\n\tif (!nr_subsystems) {\n\t\tERROR(\"No cgroup subsystems found\");\n\t\treturn false;\n\t}\n\n\t/* make sure that cgroup.use can be and is honored */\n\tconst char *cgroup_use = lxc_global_config_value(\"lxc.cgroup.use\");\n\tif (!cgroup_use && errno != 0)\n\t\tgoto final_verify;\n\tif (cgroup_use) {\n\t\tif (!verify_and_prune(cgroup_use)) {\n\t\t\tfree_subsystems();\n\t\t\treturn false;\n\t\t}\n\t\tsubsystems_inone[0] = NIH_MUST( strdup(cgroup_use) );\n\t\tcgm_all_controllers_same = false;\n\t}\n\nfinal_verify:\n\treturn verify_final_subsystems(cgroup_use);\n\nout_free:\n\tfree(line);\n\tif (f)\n\t\tfclose(f);\n\tfree_subsystems();\n\treturn false;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_subsystems",
          "args": [],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "free_subsystems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "1097-1106",
          "snippet": "static void free_subsystems(void)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_subsystems; i++)\n\t\tfree(subsystems[i]);\n\tfree(subsystems);\n\tsubsystems = NULL;\n\tnr_subsystems = 0;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void free_subsystems(void)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_subsystems; i++)\n\t\tfree(subsystems[i]);\n\tfree(subsystems);\n\tsubsystems = NULL;\n\tnr_subsystems = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "line"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "1451-1474",
          "snippet": "static bool cgm_unfreeze(void *hdata)\n{\n\tstruct cgm_data *d = hdata;\n\tbool ret = true;\n\n\tif (!d || !d->cgroup_path)\n\t\treturn false;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\tif (cgmanager_set_value_sync(NULL, cgroup_manager, \"freezer\", d->cgroup_path,\n\t\t\t\"freezer.state\", \"THAWED\") != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_set_value_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Error unfreezing %s\", d->cgroup_path);\n\t\tret = false;\n\t}\n\tcgm_dbus_disconnect();\n\treturn ret;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgm_unfreeze(void *hdata)\n{\n\tstruct cgm_data *d = hdata;\n\tbool ret = true;\n\n\tif (!d || !d->cgroup_path)\n\t\treturn false;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\tif (cgmanager_set_value_sync(NULL, cgroup_manager, \"freezer\", d->cgroup_path,\n\t\t\t\"freezer.state\", \"THAWED\") != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_set_value_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Error unfreezing %s\", d->cgroup_path);\n\t\tret = false;\n\t}\n\tcgm_dbus_disconnect();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify_final_subsystems",
          "args": [
            "cgroup_use"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "verify_final_subsystems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "1265-1321",
          "snippet": "static bool verify_final_subsystems(const char *cgroup_use)\n{\n\tint i;\n\tbool dropped_any = false;\n\tbool bret = false;\n\tconst char *cgroup_pattern;\n\tchar tmpnam[50], *probe;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\n\tcgroup_pattern = lxc_global_config_value(\"lxc.cgroup.pattern\");\n\ti = snprintf(tmpnam, 50, \"lxcprobe-%d\", getpid());\n\tif (i < 0 || i >= 50) {\n\t\tERROR(\"Attack - format string modified?\");\n\t\treturn false;\n\t}\n\tprobe = lxc_string_replace(\"%n\", tmpnam, cgroup_pattern);\n\tif (!probe)\n\t\tgoto out;\n\n\ti = 0;\n\twhile (i < nr_subsystems) {\n\t\tchar *p = get_last_controller_in_list(subsystems[i]);\n\n\t\tif (!subsys_is_writeable(p, probe)) {\n\t\t\tif (is_crucial_cgroup_subsystem(p)) {\n\t\t\t\tERROR(\"Cannot write to crucial subsystem %s\\n\",\n\t\t\t\t\tsubsystems[i]);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (cgroup_use && any_in_comma_list(subsystems[i], cgroup_use)) {\n\t\t\t\tERROR(\"Cannot write to subsystem %s which is requested in lxc.cgroup.use\\n\",\n\t\t\t\t\tsubsystems[i]);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tWARN(\"Cannot write to subsystem %s, continuing with out it\\n\",\n\t\t\t\tsubsystems[i]);\n\t\t\tdropped_any = true;\n\t\t\tdrop_subsystem(i);\n\t\t} else {\n\t\t\tcgm_remove_cgroup(subsystems[i], probe);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (dropped_any)\n\t\tcgm_all_controllers_same = false;\n\tbret = true;\n\nout:\n\tfree(probe);\n\tcgm_dbus_disconnect();\n\treturn bret;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool verify_final_subsystems(const char *cgroup_use)\n{\n\tint i;\n\tbool dropped_any = false;\n\tbool bret = false;\n\tconst char *cgroup_pattern;\n\tchar tmpnam[50], *probe;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\n\tcgroup_pattern = lxc_global_config_value(\"lxc.cgroup.pattern\");\n\ti = snprintf(tmpnam, 50, \"lxcprobe-%d\", getpid());\n\tif (i < 0 || i >= 50) {\n\t\tERROR(\"Attack - format string modified?\");\n\t\treturn false;\n\t}\n\tprobe = lxc_string_replace(\"%n\", tmpnam, cgroup_pattern);\n\tif (!probe)\n\t\tgoto out;\n\n\ti = 0;\n\twhile (i < nr_subsystems) {\n\t\tchar *p = get_last_controller_in_list(subsystems[i]);\n\n\t\tif (!subsys_is_writeable(p, probe)) {\n\t\t\tif (is_crucial_cgroup_subsystem(p)) {\n\t\t\t\tERROR(\"Cannot write to crucial subsystem %s\\n\",\n\t\t\t\t\tsubsystems[i]);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (cgroup_use && any_in_comma_list(subsystems[i], cgroup_use)) {\n\t\t\t\tERROR(\"Cannot write to subsystem %s which is requested in lxc.cgroup.use\\n\",\n\t\t\t\t\tsubsystems[i]);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tWARN(\"Cannot write to subsystem %s, continuing with out it\\n\",\n\t\t\t\tsubsystems[i]);\n\t\t\tdropped_any = true;\n\t\t\tdrop_subsystem(i);\n\t\t} else {\n\t\t\tcgm_remove_cgroup(subsystems[i], probe);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (dropped_any)\n\t\tcgm_all_controllers_same = false;\n\tbret = true;\n\nout:\n\tfree(probe);\n\tcgm_dbus_disconnect();\n\treturn bret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NIH_MUST",
          "args": [
            "strdup(cgroup_use)"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "cgroup_use"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify_and_prune",
          "args": [
            "cgroup_use"
          ],
          "line": 1408
        },
        "resolved": true,
        "details": {
          "function_name": "verify_and_prune",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "1174-1209",
          "snippet": "static bool verify_and_prune(const char *cgroup_use)\n{\n\tconst char *p;\n\tchar *e;\n\tint i, j;\n\n\tfor (p = cgroup_use; p && *p; p = e + 1) {\n\t\te = strchr(p, ',');\n\t\tif (e)\n\t\t\t*e = '\\0';\n\n\t\tif (!in_subsystem_list(p)) {\n\t\t\tERROR(\"Controller %s required by lxc.cgroup.use but not available\\n\", p);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (e)\n\t\t\t*e = ',';\n\t\tif (!e)\n\t\t\tbreak;\n\t}\n\n\tfor (i = 0; i < nr_subsystems;) {\n\t\tif (in_comma_list(subsystems[i], cgroup_use)) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tfree(subsystems[i]);\n\t\tfor (j = i;  j < nr_subsystems-1; j++)\n\t\t\tsubsystems[j] = subsystems[j+1];\n\t\tsubsystems[nr_subsystems-1] = NULL;\n\t\tnr_subsystems--;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool verify_and_prune(const char *cgroup_use)\n{\n\tconst char *p;\n\tchar *e;\n\tint i, j;\n\n\tfor (p = cgroup_use; p && *p; p = e + 1) {\n\t\te = strchr(p, ',');\n\t\tif (e)\n\t\t\t*e = '\\0';\n\n\t\tif (!in_subsystem_list(p)) {\n\t\t\tERROR(\"Controller %s required by lxc.cgroup.use but not available\\n\", p);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (e)\n\t\t\t*e = ',';\n\t\tif (!e)\n\t\t\tbreak;\n\t}\n\n\tfor (i = 0; i < nr_subsystems;) {\n\t\tif (in_comma_list(subsystems[i], cgroup_use)) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tfree(subsystems[i]);\n\t\tfor (j = i;  j < nr_subsystems-1; j++)\n\t\t\tsubsystems[j] = subsystems[j+1];\n\t\tsubsystems[nr_subsystems-1] = NULL;\n\t\tnr_subsystems--;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_global_config_value",
          "args": [
            "\"lxc.cgroup.use\""
          ],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_global_config_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "88-247",
          "snippet": "const char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nconst char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"No cgroup subsystems found\""
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "subsystems",
            "(nr_subsystems+2)*sizeof(char *)"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "must_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "116-124",
          "snippet": "static void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "NULL",
            "\",\"",
            "&saveptr"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "slist",
            "\",\"",
            "&saveptr"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "slist",
            "':'"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&line",
            "&sz",
            "f"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getline.c",
          "lines": "39-60",
          "snippet": "ssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fopen_cloexec",
          "args": [
            "\"/proc/1/cgroup\"",
            "\"r\""
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"cgmanager_list_controllers failed, falling back to /proc/self/cgroups\""
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIH_MUST",
          "args": [
            "strdup(cgm_subsys_list[nr_subsystems++])"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "cgm_subsys_list[nr_subsystems++]"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIH_MUST",
          "args": [
            "realloc(subsystems,\n\t\t\t\t\t\t(nr_subsystems+2)*sizeof(char *))"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_controllers",
          "args": [
            "&cgm_subsys_list"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_controllers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "840-843",
          "snippet": "static bool lxc_list_controllers(char ***list)\n{\n\treturn false;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool lxc_list_controllers(char ***list)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "2 * sizeof(char *)"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool collect_subsystems(void)\n{\n\tchar *line = NULL;\n\tnih_local char **cgm_subsys_list = NULL;\n\tsize_t sz = 0;\n\tFILE *f = NULL;\n\n\tif (subsystems) // already initialized\n\t\treturn true;\n\n\tsubsystems_inone = malloc(2 * sizeof(char *));\n\tif (!subsystems_inone)\n\t\treturn false;\n\tsubsystems_inone[0] = \"all\";\n\tsubsystems_inone[1] = NULL;\n\n\tif (lxc_list_controllers(&cgm_subsys_list)) {\n\t\twhile (cgm_subsys_list[nr_subsystems]) {\n\t\t\tchar **tmp = NIH_MUST( realloc(subsystems,\n\t\t\t\t\t\t(nr_subsystems+2)*sizeof(char *)) );\n\t\t\ttmp[nr_subsystems] = NIH_MUST(\n\t\t\t\t\tstrdup(cgm_subsys_list[nr_subsystems++]) );\n\t\t\tsubsystems = tmp;\n\t\t}\n\t\tif (nr_subsystems)\n\t\t\tsubsystems[nr_subsystems] = NULL;\n\t\tgoto collected;\n\t}\n\n\tINFO(\"cgmanager_list_controllers failed, falling back to /proc/self/cgroups\");\n\tf = fopen_cloexec(\"/proc/self/cgroup\", \"r\");\n\tif (!f) {\n\t\tf = fopen_cloexec(\"/proc/1/cgroup\", \"r\");\n\t\tif (!f)\n\t\t\treturn false;\n\t}\n\twhile (getline(&line, &sz, f) != -1) {\n\t\t/* file format: hierarchy:subsystems:group,\n\t\t * with multiple subsystems being ,-separated */\n\t\tchar *slist, *end, *p, *saveptr = NULL, **tmp;\n\n\t\tif (!line[0])\n\t\t\tcontinue;\n\n\t\tslist = strchr(line, ':');\n\t\tif (!slist)\n\t\t\tcontinue;\n\t\tslist++;\n\t\tend = strchr(slist, ':');\n\t\tif (!end)\n\t\t\tcontinue;\n\t\t*end = '\\0';\n\n\t\tfor (p = strtok_r(slist, \",\", &saveptr);\n\t\t\t\tp;\n\t\t\t\tp = strtok_r(NULL, \",\", &saveptr)) {\n\t\t\ttmp = realloc(subsystems, (nr_subsystems+2)*sizeof(char *));\n\t\t\tif (!tmp)\n\t\t\t\tgoto out_free;\n\n\t\t\tsubsystems = tmp;\n\t\t\ttmp[nr_subsystems] = strdup(p);\n\t\t\ttmp[nr_subsystems+1] = NULL;\n\t\t\tif (!tmp[nr_subsystems])\n\t\t\t\tgoto out_free;\n\t\t\tnr_subsystems++;\n\t\t}\n\t}\n\tfclose(f);\n\tf = NULL;\n\n\tfree(line);\n\tline = NULL;\n\ncollected:\n\tif (!nr_subsystems) {\n\t\tERROR(\"No cgroup subsystems found\");\n\t\treturn false;\n\t}\n\n\t/* make sure that cgroup.use can be and is honored */\n\tconst char *cgroup_use = lxc_global_config_value(\"lxc.cgroup.use\");\n\tif (!cgroup_use && errno != 0)\n\t\tgoto final_verify;\n\tif (cgroup_use) {\n\t\tif (!verify_and_prune(cgroup_use)) {\n\t\t\tfree_subsystems();\n\t\t\treturn false;\n\t\t}\n\t\tsubsystems_inone[0] = NIH_MUST( strdup(cgroup_use) );\n\t\tcgm_all_controllers_same = false;\n\t}\n\nfinal_verify:\n\treturn verify_final_subsystems(cgroup_use);\n\nout_free:\n\tfree(line);\n\tif (f)\n\t\tfclose(f);\n\tfree_subsystems();\n\treturn false;\n}"
  },
  {
    "function_name": "verify_final_subsystems",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "1265-1321",
    "snippet": "static bool verify_final_subsystems(const char *cgroup_use)\n{\n\tint i;\n\tbool dropped_any = false;\n\tbool bret = false;\n\tconst char *cgroup_pattern;\n\tchar tmpnam[50], *probe;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\n\tcgroup_pattern = lxc_global_config_value(\"lxc.cgroup.pattern\");\n\ti = snprintf(tmpnam, 50, \"lxcprobe-%d\", getpid());\n\tif (i < 0 || i >= 50) {\n\t\tERROR(\"Attack - format string modified?\");\n\t\treturn false;\n\t}\n\tprobe = lxc_string_replace(\"%n\", tmpnam, cgroup_pattern);\n\tif (!probe)\n\t\tgoto out;\n\n\ti = 0;\n\twhile (i < nr_subsystems) {\n\t\tchar *p = get_last_controller_in_list(subsystems[i]);\n\n\t\tif (!subsys_is_writeable(p, probe)) {\n\t\t\tif (is_crucial_cgroup_subsystem(p)) {\n\t\t\t\tERROR(\"Cannot write to crucial subsystem %s\\n\",\n\t\t\t\t\tsubsystems[i]);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (cgroup_use && any_in_comma_list(subsystems[i], cgroup_use)) {\n\t\t\t\tERROR(\"Cannot write to subsystem %s which is requested in lxc.cgroup.use\\n\",\n\t\t\t\t\tsubsystems[i]);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tWARN(\"Cannot write to subsystem %s, continuing with out it\\n\",\n\t\t\t\tsubsystems[i]);\n\t\t\tdropped_any = true;\n\t\t\tdrop_subsystem(i);\n\t\t} else {\n\t\t\tcgm_remove_cgroup(subsystems[i], probe);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (dropped_any)\n\t\tcgm_all_controllers_same = false;\n\tbret = true;\n\nout:\n\tfree(probe);\n\tcgm_dbus_disconnect();\n\treturn bret;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgm_dbus_disconnect",
          "args": [],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_dbus_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "123-132",
          "snippet": "static void cgm_dbus_disconnect(void)\n{\n\tif (cgroup_manager) {\n\t\tdbus_connection_flush(cgroup_manager->connection);\n\t\tdbus_connection_close(cgroup_manager->connection);\n\t\tnih_free(cgroup_manager);\n\t}\n\tcgroup_manager = NULL;\n\tcgm_unlock();\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void cgm_dbus_disconnect(void)\n{\n\tif (cgroup_manager) {\n\t\tdbus_connection_flush(cgroup_manager->connection);\n\t\tdbus_connection_close(cgroup_manager->connection);\n\t\tnih_free(cgroup_manager);\n\t}\n\tcgroup_manager = NULL;\n\tcgm_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "probe"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "1451-1474",
          "snippet": "static bool cgm_unfreeze(void *hdata)\n{\n\tstruct cgm_data *d = hdata;\n\tbool ret = true;\n\n\tif (!d || !d->cgroup_path)\n\t\treturn false;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\tif (cgmanager_set_value_sync(NULL, cgroup_manager, \"freezer\", d->cgroup_path,\n\t\t\t\"freezer.state\", \"THAWED\") != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_set_value_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Error unfreezing %s\", d->cgroup_path);\n\t\tret = false;\n\t}\n\tcgm_dbus_disconnect();\n\treturn ret;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgm_unfreeze(void *hdata)\n{\n\tstruct cgm_data *d = hdata;\n\tbool ret = true;\n\n\tif (!d || !d->cgroup_path)\n\t\treturn false;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\tif (cgmanager_set_value_sync(NULL, cgroup_manager, \"freezer\", d->cgroup_path,\n\t\t\t\"freezer.state\", \"THAWED\") != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_set_value_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Error unfreezing %s\", d->cgroup_path);\n\t\tret = false;\n\t}\n\tcgm_dbus_disconnect();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgm_remove_cgroup",
          "args": [
            "subsystems[i]",
            "probe"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_remove_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "527-540",
          "snippet": "static void cgm_remove_cgroup(const char *controller, const char *path)\n{\n\tint existed;\n\tif ( cgmanager_remove_sync(NULL, cgroup_manager, controller,\n\t\t\t\t   path, CG_REMOVE_RECURSIVE, &existed) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_remove_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Error removing %s:%s\", controller, path);\n\t}\n\tif (existed == -1)\n\t\tINFO(\"cgroup removal attempt: %s:%s did not exist\", controller, path);\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CG_REMOVE_RECURSIVE 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define CG_REMOVE_RECURSIVE 1\n\nstatic void cgm_remove_cgroup(const char *controller, const char *path)\n{\n\tint existed;\n\tif ( cgmanager_remove_sync(NULL, cgroup_manager, controller,\n\t\t\t\t   path, CG_REMOVE_RECURSIVE, &existed) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_remove_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Error removing %s:%s\", controller, path);\n\t}\n\tif (existed == -1)\n\t\tINFO(\"cgroup removal attempt: %s:%s did not exist\", controller, path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_subsystem",
          "args": [
            "i"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "drop_subsystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "1211-1225",
          "snippet": "static void drop_subsystem(int which)\n{\n\tint i;\n\n\tif (which < 0 || which >= nr_subsystems) {\n\t\tERROR(\"code error: dropping invalid subsystem index\\n\");\n\t\texit(1);\n\t}\n\n\tfree(subsystems[which]);\n\t/* note - we have nr_subsystems+1 entries, last one a NULL */\n\tfor (i = which; i < nr_subsystems; i++)\n\t\tsubsystems[i] = subsystems[i+1];\n\tnr_subsystems -= 1;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void drop_subsystem(int which)\n{\n\tint i;\n\n\tif (which < 0 || which >= nr_subsystems) {\n\t\tERROR(\"code error: dropping invalid subsystem index\\n\");\n\t\texit(1);\n\t}\n\n\tfree(subsystems[which]);\n\t/* note - we have nr_subsystems+1 entries, last one a NULL */\n\tfor (i = which; i < nr_subsystems; i++)\n\t\tsubsystems[i] = subsystems[i+1];\n\tnr_subsystems -= 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Cannot write to subsystem %s, continuing with out it\\n\"",
            "subsystems[i]"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Cannot write to subsystem %s which is requested in lxc.cgroup.use\\n\"",
            "subsystems[i]"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "any_in_comma_list",
          "args": [
            "subsystems[i]",
            "cgroup_use"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "any_in_comma_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "1144-1155",
          "snippet": "static bool any_in_comma_list(const char *inlist, const char *checklist)\n{\n\tchar *tmp = alloca(strlen(inlist) + 1), *tok, *saveptr = NULL;\n\n\tstrcpy(tmp, inlist);\n\tfor (tok = strtok_r(tmp, \",\", &saveptr); tok; tok = strtok_r(NULL, \",\", &saveptr)) {\n\t\tif (in_comma_list(tok, checklist))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool any_in_comma_list(const char *inlist, const char *checklist)\n{\n\tchar *tmp = alloca(strlen(inlist) + 1), *tok, *saveptr = NULL;\n\n\tstrcpy(tmp, inlist);\n\tfor (tok = strtok_r(tmp, \",\", &saveptr); tok; tok = strtok_r(NULL, \",\", &saveptr)) {\n\t\tif (in_comma_list(tok, checklist))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Cannot write to crucial subsystem %s\\n\"",
            "subsystems[i]"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_crucial_cgroup_subsystem",
          "args": [
            "p"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "is_crucial_cgroup_subsystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgroup.c",
          "lines": "239-248",
          "snippet": "bool is_crucial_cgroup_subsystem(const char *s)\n{\n\tif (strcmp(s, \"systemd\") == 0)\n\t\treturn true;\n\tif (strcmp(s, \"name=systemd\") == 0)\n\t\treturn true;\n\tif (strcmp(s, \"freezer\") == 0)\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"log.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"log.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <unistd.h>\n\nbool is_crucial_cgroup_subsystem(const char *s)\n{\n\tif (strcmp(s, \"systemd\") == 0)\n\t\treturn true;\n\tif (strcmp(s, \"name=systemd\") == 0)\n\t\treturn true;\n\tif (strcmp(s, \"freezer\") == 0)\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "subsys_is_writeable",
          "args": [
            "p",
            "probe"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "subsys_is_writeable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "1230-1246",
          "snippet": "static bool subsys_is_writeable(const char *controller, const char *probe)\n{\n\tint32_t existed;\n\tbool ret = true;\n\n\tif ( cgmanager_create_sync(NULL, cgroup_manager, controller,\n\t\t\t\t       probe, &existed) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_create_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Failed to create %s:%s\", controller, probe);\n\t\tret = false;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool subsys_is_writeable(const char *controller, const char *probe)\n{\n\tint32_t existed;\n\tbool ret = true;\n\n\tif ( cgmanager_create_sync(NULL, cgroup_manager, controller,\n\t\t\t\t       probe, &existed) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_create_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Failed to create %s:%s\", controller, probe);\n\t\tret = false;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_last_controller_in_list",
          "args": [
            "subsystems[i]"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "get_last_controller_in_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "1248-1256",
          "snippet": "static char *get_last_controller_in_list(char *list)\n{\n\tchar *p;\n\n\twhile ((p = strchr(list, ',')) != NULL)\n\t\tlist = p + 1;\n\n\treturn list;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic char *get_last_controller_in_list(char *list)\n{\n\tchar *p;\n\n\twhile ((p = strchr(list, ',')) != NULL)\n\t\tlist = p + 1;\n\n\treturn list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_string_replace",
          "args": [
            "\"%n\"",
            "tmpnam",
            "cgroup_pattern"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "601-654",
          "snippet": "char *lxc_string_replace(const char *needle, const char *replacement, const char *haystack)\n{\n\tssize_t len = -1, saved_len = -1;\n\tchar *result = NULL;\n\tsize_t replacement_len = strlen(replacement);\n\tsize_t needle_len = strlen(needle);\n\n\t/* should be executed exactly twice */\n\twhile (len == -1 || result == NULL) {\n\t\tchar *p;\n\t\tchar *last_p;\n\t\tssize_t part_len;\n\n\t\tif (len != -1) {\n\t\t\tresult = calloc(1, len + 1);\n\t\t\tif (!result)\n\t\t\t\treturn NULL;\n\t\t\tsaved_len = len;\n\t\t}\n\n\t\tlen = 0;\n\n\t\tfor (last_p = (char *)haystack, p = strstr(last_p, needle); p; last_p = p, p = strstr(last_p, needle)) {\n\t\t\tpart_len = (ssize_t)(p - last_p);\n\t\t\tif (result && part_len > 0)\n\t\t\t\tmemcpy(&result[len], last_p, part_len);\n\t\t\tlen += part_len;\n\t\t\tif (result && replacement_len > 0)\n\t\t\t\tmemcpy(&result[len], replacement, replacement_len);\n\t\t\tlen += replacement_len;\n\t\t\tp += needle_len;\n\t\t}\n\t\tpart_len = strlen(last_p);\n\t\tif (result && part_len > 0)\n\t\t\tmemcpy(&result[len], last_p, part_len);\n\t\tlen += part_len;\n\t}\n\n\t/* make sure we did the same thing twice,\n\t * once for calculating length, the other\n\t * time for copying data */\n\tif (saved_len != len) {\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\t/* make sure we didn't overwrite any buffer,\n\t * due to calloc the string should be 0-terminated */\n\tif (result[len] != '\\0') {\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *lxc_string_replace(const char *needle, const char *replacement, const char *haystack)\n{\n\tssize_t len = -1, saved_len = -1;\n\tchar *result = NULL;\n\tsize_t replacement_len = strlen(replacement);\n\tsize_t needle_len = strlen(needle);\n\n\t/* should be executed exactly twice */\n\twhile (len == -1 || result == NULL) {\n\t\tchar *p;\n\t\tchar *last_p;\n\t\tssize_t part_len;\n\n\t\tif (len != -1) {\n\t\t\tresult = calloc(1, len + 1);\n\t\t\tif (!result)\n\t\t\t\treturn NULL;\n\t\t\tsaved_len = len;\n\t\t}\n\n\t\tlen = 0;\n\n\t\tfor (last_p = (char *)haystack, p = strstr(last_p, needle); p; last_p = p, p = strstr(last_p, needle)) {\n\t\t\tpart_len = (ssize_t)(p - last_p);\n\t\t\tif (result && part_len > 0)\n\t\t\t\tmemcpy(&result[len], last_p, part_len);\n\t\t\tlen += part_len;\n\t\t\tif (result && replacement_len > 0)\n\t\t\t\tmemcpy(&result[len], replacement, replacement_len);\n\t\t\tlen += replacement_len;\n\t\t\tp += needle_len;\n\t\t}\n\t\tpart_len = strlen(last_p);\n\t\tif (result && part_len > 0)\n\t\t\tmemcpy(&result[len], last_p, part_len);\n\t\tlen += part_len;\n\t}\n\n\t/* make sure we did the same thing twice,\n\t * once for calculating length, the other\n\t * time for copying data */\n\tif (saved_len != len) {\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\t/* make sure we didn't overwrite any buffer,\n\t * due to calloc the string should be 0-terminated */\n\tif (result[len] != '\\0') {\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Attack - format string modified?\""
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tmpnam",
            "50",
            "\"lxcprobe-%d\"",
            "getpid()"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_global_config_value",
          "args": [
            "\"lxc.cgroup.pattern\""
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_global_config_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "88-247",
          "snippet": "const char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nconst char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error connecting to cgroup manager\""
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgm_dbus_connect",
          "args": [],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_dbus_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "135-184",
          "snippet": "static bool cgm_dbus_connect(void)\n{\n\tDBusError dbus_error;\n\tstatic DBusConnection *connection;\n\n\tcgm_lock();\n\tif (!dbus_threads_initialized) {\n\t\t// tell dbus to do struct locking for thread safety\n\t\tdbus_threads_init_default();\n\t\tdbus_threads_initialized = true;\n\t}\n\n\tdbus_error_init(&dbus_error);\n\n\tconnection = dbus_connection_open_private(CGMANAGER_DBUS_SOCK, &dbus_error);\n\tif (!connection) {\n\t\tDEBUG(\"Failed opening dbus connection: %s: %s\",\n\t\t\t\tdbus_error.name, dbus_error.message);\n\t\tdbus_error_free(&dbus_error);\n\t\tcgm_unlock();\n\t\treturn false;\n\t}\n\tdbus_connection_set_exit_on_disconnect(connection, FALSE);\n\tdbus_error_free(&dbus_error);\n\tcgroup_manager = nih_dbus_proxy_new(NULL, connection,\n\t\t\t\tNULL /* p2p */,\n\t\t\t\t\"/org/linuxcontainers/cgmanager\", NULL, NULL);\n\tdbus_connection_unref(connection);\n\tif (!cgroup_manager) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error opening cgmanager proxy: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\n\t// get the api version\n\tif (cgmanager_get_api_version_sync(NULL, cgroup_manager, &api_version) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error cgroup manager api version: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\tif (api_version < CGM_SUPPORTS_NAMED)\n\t\tcull_user_controllers();\n\treturn true;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CGMANAGER_DBUS_SOCK \"unix:path=/sys/fs/cgroup/cgmanager/sock\"",
            "#define CGM_SUPPORTS_NAMED 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define CGMANAGER_DBUS_SOCK \"unix:path=/sys/fs/cgroup/cgmanager/sock\"\n#define CGM_SUPPORTS_NAMED 4\n\nstatic bool cgm_dbus_connect(void)\n{\n\tDBusError dbus_error;\n\tstatic DBusConnection *connection;\n\n\tcgm_lock();\n\tif (!dbus_threads_initialized) {\n\t\t// tell dbus to do struct locking for thread safety\n\t\tdbus_threads_init_default();\n\t\tdbus_threads_initialized = true;\n\t}\n\n\tdbus_error_init(&dbus_error);\n\n\tconnection = dbus_connection_open_private(CGMANAGER_DBUS_SOCK, &dbus_error);\n\tif (!connection) {\n\t\tDEBUG(\"Failed opening dbus connection: %s: %s\",\n\t\t\t\tdbus_error.name, dbus_error.message);\n\t\tdbus_error_free(&dbus_error);\n\t\tcgm_unlock();\n\t\treturn false;\n\t}\n\tdbus_connection_set_exit_on_disconnect(connection, FALSE);\n\tdbus_error_free(&dbus_error);\n\tcgroup_manager = nih_dbus_proxy_new(NULL, connection,\n\t\t\t\tNULL /* p2p */,\n\t\t\t\t\"/org/linuxcontainers/cgmanager\", NULL, NULL);\n\tdbus_connection_unref(connection);\n\tif (!cgroup_manager) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error opening cgmanager proxy: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\n\t// get the api version\n\tif (cgmanager_get_api_version_sync(NULL, cgroup_manager, &api_version) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error cgroup manager api version: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\tif (api_version < CGM_SUPPORTS_NAMED)\n\t\tcull_user_controllers();\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool verify_final_subsystems(const char *cgroup_use)\n{\n\tint i;\n\tbool dropped_any = false;\n\tbool bret = false;\n\tconst char *cgroup_pattern;\n\tchar tmpnam[50], *probe;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\n\tcgroup_pattern = lxc_global_config_value(\"lxc.cgroup.pattern\");\n\ti = snprintf(tmpnam, 50, \"lxcprobe-%d\", getpid());\n\tif (i < 0 || i >= 50) {\n\t\tERROR(\"Attack - format string modified?\");\n\t\treturn false;\n\t}\n\tprobe = lxc_string_replace(\"%n\", tmpnam, cgroup_pattern);\n\tif (!probe)\n\t\tgoto out;\n\n\ti = 0;\n\twhile (i < nr_subsystems) {\n\t\tchar *p = get_last_controller_in_list(subsystems[i]);\n\n\t\tif (!subsys_is_writeable(p, probe)) {\n\t\t\tif (is_crucial_cgroup_subsystem(p)) {\n\t\t\t\tERROR(\"Cannot write to crucial subsystem %s\\n\",\n\t\t\t\t\tsubsystems[i]);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (cgroup_use && any_in_comma_list(subsystems[i], cgroup_use)) {\n\t\t\t\tERROR(\"Cannot write to subsystem %s which is requested in lxc.cgroup.use\\n\",\n\t\t\t\t\tsubsystems[i]);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tWARN(\"Cannot write to subsystem %s, continuing with out it\\n\",\n\t\t\t\tsubsystems[i]);\n\t\t\tdropped_any = true;\n\t\t\tdrop_subsystem(i);\n\t\t} else {\n\t\t\tcgm_remove_cgroup(subsystems[i], probe);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (dropped_any)\n\t\tcgm_all_controllers_same = false;\n\tbret = true;\n\nout:\n\tfree(probe);\n\tcgm_dbus_disconnect();\n\treturn bret;\n}"
  },
  {
    "function_name": "get_last_controller_in_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "1248-1256",
    "snippet": "static char *get_last_controller_in_list(char *list)\n{\n\tchar *p;\n\n\twhile ((p = strchr(list, ',')) != NULL)\n\t\tlist = p + 1;\n\n\treturn list;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "list",
            "','"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic char *get_last_controller_in_list(char *list)\n{\n\tchar *p;\n\n\twhile ((p = strchr(list, ',')) != NULL)\n\t\tlist = p + 1;\n\n\treturn list;\n}"
  },
  {
    "function_name": "subsys_is_writeable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "1230-1246",
    "snippet": "static bool subsys_is_writeable(const char *controller, const char *probe)\n{\n\tint32_t existed;\n\tbool ret = true;\n\n\tif ( cgmanager_create_sync(NULL, cgroup_manager, controller,\n\t\t\t\t       probe, &existed) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_create_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Failed to create %s:%s\", controller, probe);\n\t\tret = false;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to create %s:%s\"",
            "controller",
            "probe"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nih_free",
          "args": [
            "nerr"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"call to cgmanager_create_sync failed: %s\"",
            "nerr->message"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nih_error_get",
          "args": [],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgmanager_create_sync",
          "args": [
            "NULL",
            "cgroup_manager",
            "controller",
            "probe",
            "&existed"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool subsys_is_writeable(const char *controller, const char *probe)\n{\n\tint32_t existed;\n\tbool ret = true;\n\n\tif ( cgmanager_create_sync(NULL, cgroup_manager, controller,\n\t\t\t\t       probe, &existed) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_create_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Failed to create %s:%s\", controller, probe);\n\t\tret = false;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "drop_subsystem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "1211-1225",
    "snippet": "static void drop_subsystem(int which)\n{\n\tint i;\n\n\tif (which < 0 || which >= nr_subsystems) {\n\t\tERROR(\"code error: dropping invalid subsystem index\\n\");\n\t\texit(1);\n\t}\n\n\tfree(subsystems[which]);\n\t/* note - we have nr_subsystems+1 entries, last one a NULL */\n\tfor (i = which; i < nr_subsystems; i++)\n\t\tsubsystems[i] = subsystems[i+1];\n\tnr_subsystems -= 1;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "subsystems[which]"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "1451-1474",
          "snippet": "static bool cgm_unfreeze(void *hdata)\n{\n\tstruct cgm_data *d = hdata;\n\tbool ret = true;\n\n\tif (!d || !d->cgroup_path)\n\t\treturn false;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\tif (cgmanager_set_value_sync(NULL, cgroup_manager, \"freezer\", d->cgroup_path,\n\t\t\t\"freezer.state\", \"THAWED\") != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_set_value_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Error unfreezing %s\", d->cgroup_path);\n\t\tret = false;\n\t}\n\tcgm_dbus_disconnect();\n\treturn ret;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgm_unfreeze(void *hdata)\n{\n\tstruct cgm_data *d = hdata;\n\tbool ret = true;\n\n\tif (!d || !d->cgroup_path)\n\t\treturn false;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\tif (cgmanager_set_value_sync(NULL, cgroup_manager, \"freezer\", d->cgroup_path,\n\t\t\t\"freezer.state\", \"THAWED\") != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_set_value_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Error unfreezing %s\", d->cgroup_path);\n\t\tret = false;\n\t}\n\tcgm_dbus_disconnect();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"code error: dropping invalid subsystem index\\n\""
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void drop_subsystem(int which)\n{\n\tint i;\n\n\tif (which < 0 || which >= nr_subsystems) {\n\t\tERROR(\"code error: dropping invalid subsystem index\\n\");\n\t\texit(1);\n\t}\n\n\tfree(subsystems[which]);\n\t/* note - we have nr_subsystems+1 entries, last one a NULL */\n\tfor (i = which; i < nr_subsystems; i++)\n\t\tsubsystems[i] = subsystems[i+1];\n\tnr_subsystems -= 1;\n}"
  },
  {
    "function_name": "verify_and_prune",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "1174-1209",
    "snippet": "static bool verify_and_prune(const char *cgroup_use)\n{\n\tconst char *p;\n\tchar *e;\n\tint i, j;\n\n\tfor (p = cgroup_use; p && *p; p = e + 1) {\n\t\te = strchr(p, ',');\n\t\tif (e)\n\t\t\t*e = '\\0';\n\n\t\tif (!in_subsystem_list(p)) {\n\t\t\tERROR(\"Controller %s required by lxc.cgroup.use but not available\\n\", p);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (e)\n\t\t\t*e = ',';\n\t\tif (!e)\n\t\t\tbreak;\n\t}\n\n\tfor (i = 0; i < nr_subsystems;) {\n\t\tif (in_comma_list(subsystems[i], cgroup_use)) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tfree(subsystems[i]);\n\t\tfor (j = i;  j < nr_subsystems-1; j++)\n\t\t\tsubsystems[j] = subsystems[j+1];\n\t\tsubsystems[nr_subsystems-1] = NULL;\n\t\tnr_subsystems--;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "subsystems[i]"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "1451-1474",
          "snippet": "static bool cgm_unfreeze(void *hdata)\n{\n\tstruct cgm_data *d = hdata;\n\tbool ret = true;\n\n\tif (!d || !d->cgroup_path)\n\t\treturn false;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\tif (cgmanager_set_value_sync(NULL, cgroup_manager, \"freezer\", d->cgroup_path,\n\t\t\t\"freezer.state\", \"THAWED\") != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_set_value_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Error unfreezing %s\", d->cgroup_path);\n\t\tret = false;\n\t}\n\tcgm_dbus_disconnect();\n\treturn ret;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgm_unfreeze(void *hdata)\n{\n\tstruct cgm_data *d = hdata;\n\tbool ret = true;\n\n\tif (!d || !d->cgroup_path)\n\t\treturn false;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\tif (cgmanager_set_value_sync(NULL, cgroup_manager, \"freezer\", d->cgroup_path,\n\t\t\t\"freezer.state\", \"THAWED\") != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_set_value_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Error unfreezing %s\", d->cgroup_path);\n\t\tret = false;\n\t}\n\tcgm_dbus_disconnect();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_comma_list",
          "args": [
            "subsystems[i]",
            "cgroup_use"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "any_in_comma_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "1144-1155",
          "snippet": "static bool any_in_comma_list(const char *inlist, const char *checklist)\n{\n\tchar *tmp = alloca(strlen(inlist) + 1), *tok, *saveptr = NULL;\n\n\tstrcpy(tmp, inlist);\n\tfor (tok = strtok_r(tmp, \",\", &saveptr); tok; tok = strtok_r(NULL, \",\", &saveptr)) {\n\t\tif (in_comma_list(tok, checklist))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool any_in_comma_list(const char *inlist, const char *checklist)\n{\n\tchar *tmp = alloca(strlen(inlist) + 1), *tok, *saveptr = NULL;\n\n\tstrcpy(tmp, inlist);\n\tfor (tok = strtok_r(tmp, \",\", &saveptr); tok; tok = strtok_r(NULL, \",\", &saveptr)) {\n\t\tif (in_comma_list(tok, checklist))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Controller %s required by lxc.cgroup.use but not available\\n\"",
            "p"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_subsystem_list",
          "args": [
            "p"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "in_subsystem_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "1157-1167",
          "snippet": "static bool in_subsystem_list(const char *c)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_subsystems; i++) {\n\t\tif (strcmp(c, subsystems[i]) == 0)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool in_subsystem_list(const char *c)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_subsystems; i++) {\n\t\tif (strcmp(c, subsystems[i]) == 0)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "','"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool verify_and_prune(const char *cgroup_use)\n{\n\tconst char *p;\n\tchar *e;\n\tint i, j;\n\n\tfor (p = cgroup_use; p && *p; p = e + 1) {\n\t\te = strchr(p, ',');\n\t\tif (e)\n\t\t\t*e = '\\0';\n\n\t\tif (!in_subsystem_list(p)) {\n\t\t\tERROR(\"Controller %s required by lxc.cgroup.use but not available\\n\", p);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (e)\n\t\t\t*e = ',';\n\t\tif (!e)\n\t\t\tbreak;\n\t}\n\n\tfor (i = 0; i < nr_subsystems;) {\n\t\tif (in_comma_list(subsystems[i], cgroup_use)) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tfree(subsystems[i]);\n\t\tfor (j = i;  j < nr_subsystems-1; j++)\n\t\t\tsubsystems[j] = subsystems[j+1];\n\t\tsubsystems[nr_subsystems-1] = NULL;\n\t\tnr_subsystems--;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "in_subsystem_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "1157-1167",
    "snippet": "static bool in_subsystem_list(const char *c)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_subsystems; i++) {\n\t\tif (strcmp(c, subsystems[i]) == 0)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "c",
            "subsystems[i]"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool in_subsystem_list(const char *c)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_subsystems; i++) {\n\t\tif (strcmp(c, subsystems[i]) == 0)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "any_in_comma_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "1144-1155",
    "snippet": "static bool any_in_comma_list(const char *inlist, const char *checklist)\n{\n\tchar *tmp = alloca(strlen(inlist) + 1), *tok, *saveptr = NULL;\n\n\tstrcpy(tmp, inlist);\n\tfor (tok = strtok_r(tmp, \",\", &saveptr); tok; tok = strtok_r(NULL, \",\", &saveptr)) {\n\t\tif (in_comma_list(tok, checklist))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "in_comma_list",
          "args": [
            "tok",
            "checklist"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "any_in_comma_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "1144-1155",
          "snippet": "static bool any_in_comma_list(const char *inlist, const char *checklist)\n{\n\tchar *tmp = alloca(strlen(inlist) + 1), *tok, *saveptr = NULL;\n\n\tstrcpy(tmp, inlist);\n\tfor (tok = strtok_r(tmp, \",\", &saveptr); tok; tok = strtok_r(NULL, \",\", &saveptr)) {\n\t\tif (in_comma_list(tok, checklist))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "NULL",
            "\",\"",
            "&saveptr"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "tmp",
            "\",\"",
            "&saveptr"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "tmp",
            "inlist"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "strlen(inlist) + 1"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "inlist"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool any_in_comma_list(const char *inlist, const char *checklist)\n{\n\tchar *tmp = alloca(strlen(inlist) + 1), *tok, *saveptr = NULL;\n\n\tstrcpy(tmp, inlist);\n\tfor (tok = strtok_r(tmp, \",\", &saveptr); tok; tok = strtok_r(NULL, \",\", &saveptr)) {\n\t\tif (in_comma_list(tok, checklist))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "in_comma_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "1124-1138",
    "snippet": "static bool in_comma_list(const char *inword, const char *cgroup_use)\n{\n\tchar *e;\n\tsize_t inlen = strlen(inword), len;\n\n\tdo {\n\t\te = strchr(cgroup_use, ',');\n\t\tlen = e ? e - cgroup_use : strlen(cgroup_use);\n\t\tif (len == inlen && strncmp(inword, cgroup_use, len) == 0)\n\t\t\treturn true;\n\t\tcgroup_use = e + 1;\n\t} while (e);\n\n\treturn false;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "inword",
            "cgroup_use",
            "len"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cgroup_use"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "cgroup_use",
            "','"
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "inword"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool in_comma_list(const char *inword, const char *cgroup_use)\n{\n\tchar *e;\n\tsize_t inlen = strlen(inword), len;\n\n\tdo {\n\t\te = strchr(cgroup_use, ',');\n\t\tlen = e ? e - cgroup_use : strlen(cgroup_use);\n\t\tif (len == inlen && strncmp(inword, cgroup_use, len) == 0)\n\t\t\treturn true;\n\t\tcgroup_use = e + 1;\n\t} while (e);\n\n\treturn false;\n}"
  },
  {
    "function_name": "cull_user_controllers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "1108-1119",
    "snippet": "static void cull_user_controllers(void)\n{\n\tint i, j;\n\n\tfor (i = 0;  i < nr_subsystems; i++) {\n\t\tif (strncmp(subsystems[i], \"name=\", 5) != 0)\n\t\t\tcontinue;\n\t\tfor (j = i;  j < nr_subsystems-1; j++)\n\t\t\tsubsystems[j] = subsystems[j+1];\n\t\tnr_subsystems--;\n\t}\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "subsystems[i]",
            "\"name=\"",
            "5"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void cull_user_controllers(void)\n{\n\tint i, j;\n\n\tfor (i = 0;  i < nr_subsystems; i++) {\n\t\tif (strncmp(subsystems[i], \"name=\", 5) != 0)\n\t\t\tcontinue;\n\t\tfor (j = i;  j < nr_subsystems-1; j++)\n\t\t\tsubsystems[j] = subsystems[j+1];\n\t\tnr_subsystems--;\n\t}\n}"
  },
  {
    "function_name": "free_subsystems",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "1097-1106",
    "snippet": "static void free_subsystems(void)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_subsystems; i++)\n\t\tfree(subsystems[i]);\n\tfree(subsystems);\n\tsubsystems = NULL;\n\tnr_subsystems = 0;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "subsystems"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "1451-1474",
          "snippet": "static bool cgm_unfreeze(void *hdata)\n{\n\tstruct cgm_data *d = hdata;\n\tbool ret = true;\n\n\tif (!d || !d->cgroup_path)\n\t\treturn false;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\tif (cgmanager_set_value_sync(NULL, cgroup_manager, \"freezer\", d->cgroup_path,\n\t\t\t\"freezer.state\", \"THAWED\") != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_set_value_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Error unfreezing %s\", d->cgroup_path);\n\t\tret = false;\n\t}\n\tcgm_dbus_disconnect();\n\treturn ret;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgm_unfreeze(void *hdata)\n{\n\tstruct cgm_data *d = hdata;\n\tbool ret = true;\n\n\tif (!d || !d->cgroup_path)\n\t\treturn false;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\tif (cgmanager_set_value_sync(NULL, cgroup_manager, \"freezer\", d->cgroup_path,\n\t\t\t\"freezer.state\", \"THAWED\") != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_set_value_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Error unfreezing %s\", d->cgroup_path);\n\t\tret = false;\n\t}\n\tcgm_dbus_disconnect();\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void free_subsystems(void)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_subsystems; i++)\n\t\tfree(subsystems[i]);\n\tfree(subsystems);\n\tsubsystems = NULL;\n\tnr_subsystems = 0;\n}"
  },
  {
    "function_name": "cgm_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "1073-1095",
    "snippet": "static int cgm_set(const char *filename, const char *value, const char *name, const char *lxcpath)\n{\n\tpid_t pid;\n\tint p[2], ret, v;\n\n\tif (pipe(p) < 0)\n\t\treturn -1;\n\tif ((pid = fork()) < 0) {\n\t\tclose(p[1]);\n\t\tclose(p[0]);\n\t\treturn -1;\n\t}\n\tif (!pid) // do_cgm_set exits\n\t\tdo_cgm_set(name, lxcpath, filename, value, p[1]);\n\tclose(p[1]);\n\tret = read(p[0], &v, sizeof(v));\n\tclose(p[0]);\n\tif (wait_for_pid(pid))\n\t\tWARN(\"do_cgm_set exited with error\");\n\tif (ret != sizeof(v) || !v)\n\t\treturn -1;\n\treturn 0;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"do_cgm_set exited with error\""
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_pid",
          "args": [
            "pid"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "67-81",
          "snippet": "static int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "p[0]"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "p[0]",
            "&v",
            "sizeof(v)"
          ],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_read_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2217-2236",
          "snippet": "static int cgroup_read_from_file(const char *fn, char buf[], size_t bufsize)\n{\n\tint ret = lxc_read_from_file(fn, buf, bufsize);\n\tif (ret < 0) {\n\t\tSYSERROR(\"failed to read %s\", fn);\n\t\treturn ret;\n\t}\n\tif (ret == bufsize) {\n\t\tif (bufsize > 0) {\n\t\t\t/* obviously this wasn't empty */\n\t\t\tbuf[bufsize-1] = '\\0';\n\t\t\treturn ret;\n\t\t}\n\t\t/* Callers don't do this, but regression/sanity check */\n\t\tERROR(\"%s: was not expecting 0 bufsize\", __func__);\n\t\treturn -1;\n\t}\n\tbuf[ret] = '\\0';\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int cgroup_read_from_file(const char *fn, char buf[], size_t bufsize)\n{\n\tint ret = lxc_read_from_file(fn, buf, bufsize);\n\tif (ret < 0) {\n\t\tSYSERROR(\"failed to read %s\", fn);\n\t\treturn ret;\n\t}\n\tif (ret == bufsize) {\n\t\tif (bufsize > 0) {\n\t\t\t/* obviously this wasn't empty */\n\t\t\tbuf[bufsize-1] = '\\0';\n\t\t\treturn ret;\n\t\t}\n\t\t/* Callers don't do this, but regression/sanity check */\n\t\tERROR(\"%s: was not expecting 0 bufsize\", __func__);\n\t\treturn -1;\n\t}\n\tbuf[ret] = '\\0';\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_cgm_set",
          "args": [
            "name",
            "lxcpath",
            "filename",
            "value",
            "p[1]"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "do_cgm_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "996-1070",
          "snippet": "static void do_cgm_set(const char *name, const char *lxcpath, const char *filename, const char *value, int outp)\n{\n\tchar *controller, *key, *cgroup = NULL;\n\tint retval = 0;  // value we are sending to the parent over outp\n\tint ret;\n\tchar *cglast;\n\n\tcontroller = alloca(strlen(filename)+1);\n\tstrcpy(controller, filename);\n\tkey = strchr(controller, '.');\n\tif (!key) {\n\t\tret = write(outp, &retval, sizeof(retval));\n\t\tif (ret != sizeof(retval))\n\t\t\tWARN(\"Failed to warn cgm_set of error; parent may hang\");\n\t\texit(1);\n\t}\n\t*key = '\\0';\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\tret = write(outp, &retval, sizeof(retval));\n\t\tif (ret != sizeof(retval))\n\t\t\tWARN(\"Failed to warn cgm_set of error; parent may hang\");\n\t\texit(1);\n\t}\n\tcgroup = try_get_abs_cgroup(name, lxcpath, controller);\n\tif (!cgroup) {\n\t\tcgm_dbus_disconnect();\n\t\tret = write(outp, &retval, sizeof(retval));\n\t\tif (ret != sizeof(retval))\n\t\t\tWARN(\"Failed to warn cgm_set of error; parent may hang\");\n\t\texit(1);\n\t}\n\tcglast = strrchr(cgroup, '/');\n\tif (!cglast) {\n\t\tcgm_dbus_disconnect();\n\t\tfree_abs_cgroup(cgroup);\n\t\tret = write(outp, &retval, sizeof(retval));\n\t\tif (ret != sizeof(retval))\n\t\t\tWARN(\"Failed to warn cgm_set of error; parent may hang\");\n\t\texit(1);\n\t}\n\t*cglast = '\\0';\n\tif (!lxc_cgmanager_enter(getpid(), controller, cgroup, abs_cgroup_supported())) {\n\t\tERROR(\"Failed to enter container cgroup %s:%s\", controller, cgroup);\n\t\tret = write(outp, &retval, sizeof(retval));\n\t\tif (ret != sizeof(retval))\n\t\t\tWARN(\"Failed to warn cgm_set of error; parent may hang\");\n\t\tcgm_dbus_disconnect();\n\t\tfree_abs_cgroup(cgroup);\n\t\texit(1);\n\t}\n\tif (cgmanager_set_value_sync(NULL, cgroup_manager, controller, cglast+1, filename, value) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error setting cgroup value %s for %s:%s\", filename, controller, cgroup);\n\t\tERROR(\"call to cgmanager_set_value_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tfree_abs_cgroup(cgroup);\n\t\tcgm_dbus_disconnect();\n\t\tret = write(outp, &retval, sizeof(retval));\n\t\tif (ret != sizeof(retval))\n\t\t\tWARN(\"Failed to warn cgm_set of error; parent may hang\");\n\t\texit(1);\n\t}\n\tfree_abs_cgroup(cgroup);\n\tcgm_dbus_disconnect();\n\t/* tell parent that we are done */\n\tretval = 1;\n\tret = write(outp, &retval, sizeof(retval));\n\tif (ret != sizeof(retval)) {\n\t\texit(1);\n\t}\n\texit(0);\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void do_cgm_set(const char *name, const char *lxcpath, const char *filename, const char *value, int outp)\n{\n\tchar *controller, *key, *cgroup = NULL;\n\tint retval = 0;  // value we are sending to the parent over outp\n\tint ret;\n\tchar *cglast;\n\n\tcontroller = alloca(strlen(filename)+1);\n\tstrcpy(controller, filename);\n\tkey = strchr(controller, '.');\n\tif (!key) {\n\t\tret = write(outp, &retval, sizeof(retval));\n\t\tif (ret != sizeof(retval))\n\t\t\tWARN(\"Failed to warn cgm_set of error; parent may hang\");\n\t\texit(1);\n\t}\n\t*key = '\\0';\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\tret = write(outp, &retval, sizeof(retval));\n\t\tif (ret != sizeof(retval))\n\t\t\tWARN(\"Failed to warn cgm_set of error; parent may hang\");\n\t\texit(1);\n\t}\n\tcgroup = try_get_abs_cgroup(name, lxcpath, controller);\n\tif (!cgroup) {\n\t\tcgm_dbus_disconnect();\n\t\tret = write(outp, &retval, sizeof(retval));\n\t\tif (ret != sizeof(retval))\n\t\t\tWARN(\"Failed to warn cgm_set of error; parent may hang\");\n\t\texit(1);\n\t}\n\tcglast = strrchr(cgroup, '/');\n\tif (!cglast) {\n\t\tcgm_dbus_disconnect();\n\t\tfree_abs_cgroup(cgroup);\n\t\tret = write(outp, &retval, sizeof(retval));\n\t\tif (ret != sizeof(retval))\n\t\t\tWARN(\"Failed to warn cgm_set of error; parent may hang\");\n\t\texit(1);\n\t}\n\t*cglast = '\\0';\n\tif (!lxc_cgmanager_enter(getpid(), controller, cgroup, abs_cgroup_supported())) {\n\t\tERROR(\"Failed to enter container cgroup %s:%s\", controller, cgroup);\n\t\tret = write(outp, &retval, sizeof(retval));\n\t\tif (ret != sizeof(retval))\n\t\t\tWARN(\"Failed to warn cgm_set of error; parent may hang\");\n\t\tcgm_dbus_disconnect();\n\t\tfree_abs_cgroup(cgroup);\n\t\texit(1);\n\t}\n\tif (cgmanager_set_value_sync(NULL, cgroup_manager, controller, cglast+1, filename, value) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error setting cgroup value %s for %s:%s\", filename, controller, cgroup);\n\t\tERROR(\"call to cgmanager_set_value_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tfree_abs_cgroup(cgroup);\n\t\tcgm_dbus_disconnect();\n\t\tret = write(outp, &retval, sizeof(retval));\n\t\tif (ret != sizeof(retval))\n\t\t\tWARN(\"Failed to warn cgm_set of error; parent may hang\");\n\t\texit(1);\n\t}\n\tfree_abs_cgroup(cgroup);\n\tcgm_dbus_disconnect();\n\t/* tell parent that we are done */\n\tretval = 1;\n\tret = write(outp, &retval, sizeof(retval));\n\tif (ret != sizeof(retval)) {\n\t\texit(1);\n\t}\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "107-111",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(cgm_lock, cgm_unlock, cgm_unlock);\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(cgm_lock, cgm_unlock, cgm_unlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "p"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int cgm_set(const char *filename, const char *value, const char *name, const char *lxcpath)\n{\n\tpid_t pid;\n\tint p[2], ret, v;\n\n\tif (pipe(p) < 0)\n\t\treturn -1;\n\tif ((pid = fork()) < 0) {\n\t\tclose(p[1]);\n\t\tclose(p[0]);\n\t\treturn -1;\n\t}\n\tif (!pid) // do_cgm_set exits\n\t\tdo_cgm_set(name, lxcpath, filename, value, p[1]);\n\tclose(p[1]);\n\tret = read(p[0], &v, sizeof(v));\n\tclose(p[0]);\n\tif (wait_for_pid(pid))\n\t\tWARN(\"do_cgm_set exited with error\");\n\tif (ret != sizeof(v) || !v)\n\t\treturn -1;\n\treturn 0;\n}"
  },
  {
    "function_name": "do_cgm_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "996-1070",
    "snippet": "static void do_cgm_set(const char *name, const char *lxcpath, const char *filename, const char *value, int outp)\n{\n\tchar *controller, *key, *cgroup = NULL;\n\tint retval = 0;  // value we are sending to the parent over outp\n\tint ret;\n\tchar *cglast;\n\n\tcontroller = alloca(strlen(filename)+1);\n\tstrcpy(controller, filename);\n\tkey = strchr(controller, '.');\n\tif (!key) {\n\t\tret = write(outp, &retval, sizeof(retval));\n\t\tif (ret != sizeof(retval))\n\t\t\tWARN(\"Failed to warn cgm_set of error; parent may hang\");\n\t\texit(1);\n\t}\n\t*key = '\\0';\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\tret = write(outp, &retval, sizeof(retval));\n\t\tif (ret != sizeof(retval))\n\t\t\tWARN(\"Failed to warn cgm_set of error; parent may hang\");\n\t\texit(1);\n\t}\n\tcgroup = try_get_abs_cgroup(name, lxcpath, controller);\n\tif (!cgroup) {\n\t\tcgm_dbus_disconnect();\n\t\tret = write(outp, &retval, sizeof(retval));\n\t\tif (ret != sizeof(retval))\n\t\t\tWARN(\"Failed to warn cgm_set of error; parent may hang\");\n\t\texit(1);\n\t}\n\tcglast = strrchr(cgroup, '/');\n\tif (!cglast) {\n\t\tcgm_dbus_disconnect();\n\t\tfree_abs_cgroup(cgroup);\n\t\tret = write(outp, &retval, sizeof(retval));\n\t\tif (ret != sizeof(retval))\n\t\t\tWARN(\"Failed to warn cgm_set of error; parent may hang\");\n\t\texit(1);\n\t}\n\t*cglast = '\\0';\n\tif (!lxc_cgmanager_enter(getpid(), controller, cgroup, abs_cgroup_supported())) {\n\t\tERROR(\"Failed to enter container cgroup %s:%s\", controller, cgroup);\n\t\tret = write(outp, &retval, sizeof(retval));\n\t\tif (ret != sizeof(retval))\n\t\t\tWARN(\"Failed to warn cgm_set of error; parent may hang\");\n\t\tcgm_dbus_disconnect();\n\t\tfree_abs_cgroup(cgroup);\n\t\texit(1);\n\t}\n\tif (cgmanager_set_value_sync(NULL, cgroup_manager, controller, cglast+1, filename, value) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error setting cgroup value %s for %s:%s\", filename, controller, cgroup);\n\t\tERROR(\"call to cgmanager_set_value_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tfree_abs_cgroup(cgroup);\n\t\tcgm_dbus_disconnect();\n\t\tret = write(outp, &retval, sizeof(retval));\n\t\tif (ret != sizeof(retval))\n\t\t\tWARN(\"Failed to warn cgm_set of error; parent may hang\");\n\t\texit(1);\n\t}\n\tfree_abs_cgroup(cgroup);\n\tcgm_dbus_disconnect();\n\t/* tell parent that we are done */\n\tretval = 1;\n\tret = write(outp, &retval, sizeof(retval));\n\tif (ret != sizeof(retval)) {\n\t\texit(1);\n\t}\n\texit(0);\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "outp",
            "&retval",
            "sizeof(retval)"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_nointr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "327-335",
          "snippet": "ssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgm_dbus_disconnect",
          "args": [],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_dbus_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "123-132",
          "snippet": "static void cgm_dbus_disconnect(void)\n{\n\tif (cgroup_manager) {\n\t\tdbus_connection_flush(cgroup_manager->connection);\n\t\tdbus_connection_close(cgroup_manager->connection);\n\t\tnih_free(cgroup_manager);\n\t}\n\tcgroup_manager = NULL;\n\tcgm_unlock();\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void cgm_dbus_disconnect(void)\n{\n\tif (cgroup_manager) {\n\t\tdbus_connection_flush(cgroup_manager->connection);\n\t\tdbus_connection_close(cgroup_manager->connection);\n\t\tnih_free(cgroup_manager);\n\t}\n\tcgroup_manager = NULL;\n\tcgm_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_abs_cgroup",
          "args": [
            "cgroup"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "free_abs_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "846-854",
          "snippet": "static inline void free_abs_cgroup(char *cgroup)\n{\n\tif (!cgroup)\n\t\treturn;\n\tif (abs_cgroup_supported())\n\t\tnih_free(cgroup);\n\telse\n\t\tfree(cgroup);\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic inline void free_abs_cgroup(char *cgroup)\n{\n\tif (!cgroup)\n\t\treturn;\n\tif (abs_cgroup_supported())\n\t\tnih_free(cgroup);\n\telse\n\t\tfree(cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to warn cgm_set of error; parent may hang\""
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nih_free",
          "args": [
            "nerr"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"call to cgmanager_set_value_sync failed: %s\"",
            "nerr->message"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error setting cgroup value %s for %s:%s\"",
            "filename",
            "controller",
            "cgroup"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nih_error_get",
          "args": [],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgmanager_set_value_sync",
          "args": [
            "NULL",
            "cgroup_manager",
            "controller",
            "cglast+1",
            "filename",
            "value"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to warn cgm_set of error; parent may hang\""
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to enter container cgroup %s:%s\"",
            "controller",
            "cgroup"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cgmanager_enter",
          "args": [
            "getpid()",
            "controller",
            "cgroup",
            "abs_cgroup_supported()"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgmanager_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "690-710",
          "snippet": "static bool lxc_cgmanager_enter(pid_t pid, const char *controller,\n\t\tconst char *cgroup_path, bool abs)\n{\n\tint ret;\n\n\tif (abs)\n\t\tret = cgmanager_move_pid_abs_sync(NULL, cgroup_manager,\n\t\t\tcontroller, cgroup_path, pid);\n\telse\n\t\tret = cgmanager_move_pid_sync(NULL, cgroup_manager,\n\t\t\tcontroller, cgroup_path, pid);\n\tif (ret != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tWARN(\"call to cgmanager_move_pid_%ssync failed: %s\",\n\t\t\tabs ? \"abs_\" : \"\", nerr->message);\n\t\tnih_free(nerr);\n\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool lxc_cgmanager_enter(pid_t pid, const char *controller,\n\t\tconst char *cgroup_path, bool abs)\n{\n\tint ret;\n\n\tif (abs)\n\t\tret = cgmanager_move_pid_abs_sync(NULL, cgroup_manager,\n\t\t\tcontroller, cgroup_path, pid);\n\telse\n\t\tret = cgmanager_move_pid_sync(NULL, cgroup_manager,\n\t\t\tcontroller, cgroup_path, pid);\n\tif (ret != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tWARN(\"call to cgmanager_move_pid_%ssync failed: %s\",\n\t\t\tabs ? \"abs_\" : \"\", nerr->message);\n\t\tnih_free(nerr);\n\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "abs_cgroup_supported",
          "args": [],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "abs_cgroup_supported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "754-756",
          "snippet": "static inline bool abs_cgroup_supported(void) {\n\treturn false;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic inline bool abs_cgroup_supported(void) {\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to warn cgm_set of error; parent may hang\""
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "cgroup",
            "'/'"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to warn cgm_set of error; parent may hang\""
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_get_abs_cgroup",
          "args": [
            "name",
            "lxcpath",
            "controller"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "try_get_abs_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "760-783",
          "snippet": "static char *try_get_abs_cgroup(const char *name, const char *lxcpath,\n\t\tconst char *controller)\n{\n\tchar *cgroup = NULL;\n\n\tif (abs_cgroup_supported()) {\n\t\t/* get the container init pid and ask for its abs cgroup */\n\t\tpid_t pid = lxc_cmd_get_init_pid(name, lxcpath);\n\t\tif (pid < 0)\n\t\t\treturn NULL;\n\t\tif (cgmanager_get_pid_cgroup_abs_sync(NULL, cgroup_manager,\n\t\t\t\tcontroller, pid, &cgroup) != 0) {\n\t\t\tcgroup = NULL;\n\t\t\tNihError *nerr;\n\t\t\tnerr = nih_error_get();\n\t\t\tnih_free(nerr);\n\t\t} else\n\t\t\tprune_init_scope(cgroup);\n\t\treturn cgroup;\n\t}\n\n\t/* use the command interface to look for the cgroup */\n\treturn lxc_cmd_get_cgroup_path(name, lxcpath, controller);\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic char *try_get_abs_cgroup(const char *name, const char *lxcpath,\n\t\tconst char *controller)\n{\n\tchar *cgroup = NULL;\n\n\tif (abs_cgroup_supported()) {\n\t\t/* get the container init pid and ask for its abs cgroup */\n\t\tpid_t pid = lxc_cmd_get_init_pid(name, lxcpath);\n\t\tif (pid < 0)\n\t\t\treturn NULL;\n\t\tif (cgmanager_get_pid_cgroup_abs_sync(NULL, cgroup_manager,\n\t\t\t\tcontroller, pid, &cgroup) != 0) {\n\t\t\tcgroup = NULL;\n\t\t\tNihError *nerr;\n\t\t\tnerr = nih_error_get();\n\t\t\tnih_free(nerr);\n\t\t} else\n\t\t\tprune_init_scope(cgroup);\n\t\treturn cgroup;\n\t}\n\n\t/* use the command interface to look for the cgroup */\n\treturn lxc_cmd_get_cgroup_path(name, lxcpath, controller);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to warn cgm_set of error; parent may hang\""
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error connecting to cgroup manager\""
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgm_dbus_connect",
          "args": [],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_dbus_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "135-184",
          "snippet": "static bool cgm_dbus_connect(void)\n{\n\tDBusError dbus_error;\n\tstatic DBusConnection *connection;\n\n\tcgm_lock();\n\tif (!dbus_threads_initialized) {\n\t\t// tell dbus to do struct locking for thread safety\n\t\tdbus_threads_init_default();\n\t\tdbus_threads_initialized = true;\n\t}\n\n\tdbus_error_init(&dbus_error);\n\n\tconnection = dbus_connection_open_private(CGMANAGER_DBUS_SOCK, &dbus_error);\n\tif (!connection) {\n\t\tDEBUG(\"Failed opening dbus connection: %s: %s\",\n\t\t\t\tdbus_error.name, dbus_error.message);\n\t\tdbus_error_free(&dbus_error);\n\t\tcgm_unlock();\n\t\treturn false;\n\t}\n\tdbus_connection_set_exit_on_disconnect(connection, FALSE);\n\tdbus_error_free(&dbus_error);\n\tcgroup_manager = nih_dbus_proxy_new(NULL, connection,\n\t\t\t\tNULL /* p2p */,\n\t\t\t\t\"/org/linuxcontainers/cgmanager\", NULL, NULL);\n\tdbus_connection_unref(connection);\n\tif (!cgroup_manager) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error opening cgmanager proxy: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\n\t// get the api version\n\tif (cgmanager_get_api_version_sync(NULL, cgroup_manager, &api_version) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error cgroup manager api version: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\tif (api_version < CGM_SUPPORTS_NAMED)\n\t\tcull_user_controllers();\n\treturn true;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CGMANAGER_DBUS_SOCK \"unix:path=/sys/fs/cgroup/cgmanager/sock\"",
            "#define CGM_SUPPORTS_NAMED 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define CGMANAGER_DBUS_SOCK \"unix:path=/sys/fs/cgroup/cgmanager/sock\"\n#define CGM_SUPPORTS_NAMED 4\n\nstatic bool cgm_dbus_connect(void)\n{\n\tDBusError dbus_error;\n\tstatic DBusConnection *connection;\n\n\tcgm_lock();\n\tif (!dbus_threads_initialized) {\n\t\t// tell dbus to do struct locking for thread safety\n\t\tdbus_threads_init_default();\n\t\tdbus_threads_initialized = true;\n\t}\n\n\tdbus_error_init(&dbus_error);\n\n\tconnection = dbus_connection_open_private(CGMANAGER_DBUS_SOCK, &dbus_error);\n\tif (!connection) {\n\t\tDEBUG(\"Failed opening dbus connection: %s: %s\",\n\t\t\t\tdbus_error.name, dbus_error.message);\n\t\tdbus_error_free(&dbus_error);\n\t\tcgm_unlock();\n\t\treturn false;\n\t}\n\tdbus_connection_set_exit_on_disconnect(connection, FALSE);\n\tdbus_error_free(&dbus_error);\n\tcgroup_manager = nih_dbus_proxy_new(NULL, connection,\n\t\t\t\tNULL /* p2p */,\n\t\t\t\t\"/org/linuxcontainers/cgmanager\", NULL, NULL);\n\tdbus_connection_unref(connection);\n\tif (!cgroup_manager) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error opening cgmanager proxy: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\n\t// get the api version\n\tif (cgmanager_get_api_version_sync(NULL, cgroup_manager, &api_version) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error cgroup manager api version: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\tif (api_version < CGM_SUPPORTS_NAMED)\n\t\tcull_user_controllers();\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to warn cgm_set of error; parent may hang\""
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "controller",
            "'.'"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "controller",
            "filename"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "strlen(filename)+1"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "filename"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void do_cgm_set(const char *name, const char *lxcpath, const char *filename, const char *value, int outp)\n{\n\tchar *controller, *key, *cgroup = NULL;\n\tint retval = 0;  // value we are sending to the parent over outp\n\tint ret;\n\tchar *cglast;\n\n\tcontroller = alloca(strlen(filename)+1);\n\tstrcpy(controller, filename);\n\tkey = strchr(controller, '.');\n\tif (!key) {\n\t\tret = write(outp, &retval, sizeof(retval));\n\t\tif (ret != sizeof(retval))\n\t\t\tWARN(\"Failed to warn cgm_set of error; parent may hang\");\n\t\texit(1);\n\t}\n\t*key = '\\0';\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\tret = write(outp, &retval, sizeof(retval));\n\t\tif (ret != sizeof(retval))\n\t\t\tWARN(\"Failed to warn cgm_set of error; parent may hang\");\n\t\texit(1);\n\t}\n\tcgroup = try_get_abs_cgroup(name, lxcpath, controller);\n\tif (!cgroup) {\n\t\tcgm_dbus_disconnect();\n\t\tret = write(outp, &retval, sizeof(retval));\n\t\tif (ret != sizeof(retval))\n\t\t\tWARN(\"Failed to warn cgm_set of error; parent may hang\");\n\t\texit(1);\n\t}\n\tcglast = strrchr(cgroup, '/');\n\tif (!cglast) {\n\t\tcgm_dbus_disconnect();\n\t\tfree_abs_cgroup(cgroup);\n\t\tret = write(outp, &retval, sizeof(retval));\n\t\tif (ret != sizeof(retval))\n\t\t\tWARN(\"Failed to warn cgm_set of error; parent may hang\");\n\t\texit(1);\n\t}\n\t*cglast = '\\0';\n\tif (!lxc_cgmanager_enter(getpid(), controller, cgroup, abs_cgroup_supported())) {\n\t\tERROR(\"Failed to enter container cgroup %s:%s\", controller, cgroup);\n\t\tret = write(outp, &retval, sizeof(retval));\n\t\tif (ret != sizeof(retval))\n\t\t\tWARN(\"Failed to warn cgm_set of error; parent may hang\");\n\t\tcgm_dbus_disconnect();\n\t\tfree_abs_cgroup(cgroup);\n\t\texit(1);\n\t}\n\tif (cgmanager_set_value_sync(NULL, cgroup_manager, controller, cglast+1, filename, value) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error setting cgroup value %s for %s:%s\", filename, controller, cgroup);\n\t\tERROR(\"call to cgmanager_set_value_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tfree_abs_cgroup(cgroup);\n\t\tcgm_dbus_disconnect();\n\t\tret = write(outp, &retval, sizeof(retval));\n\t\tif (ret != sizeof(retval))\n\t\t\tWARN(\"Failed to warn cgm_set of error; parent may hang\");\n\t\texit(1);\n\t}\n\tfree_abs_cgroup(cgroup);\n\tcgm_dbus_disconnect();\n\t/* tell parent that we are done */\n\tretval = 1;\n\tret = write(outp, &retval, sizeof(retval));\n\tif (ret != sizeof(retval)) {\n\t\texit(1);\n\t}\n\texit(0);\n}"
  },
  {
    "function_name": "cgm_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "937-994",
    "snippet": "static int cgm_get(const char *filename, char *value, size_t len, const char *name, const char *lxcpath)\n{\n\tpid_t pid;\n\tint p[2], ret, newlen, readlen;\n\n\tif (pipe(p) < 0)\n\t\treturn -1;\n\tif ((pid = fork()) < 0) {\n\t\tclose(p[0]);\n\t\tclose(p[1]);\n\t\treturn -1;\n\t}\n\tif (!pid) // do_cgm_get exits\n\t\tdo_cgm_get(name, lxcpath, filename, p[1], len && value);\n\tclose(p[1]);\n\tret = read(p[0], &newlen, sizeof(newlen));\n\tif (ret != sizeof(newlen)) {\n\t\tclose(p[0]);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\tif (!len || !value) {\n\t\tclose(p[0]);\n\t\tret = newlen;\n\t\tgoto out;\n\t}\n\tmemset(value, 0, len);\n\tif (newlen < 0) { // child is reporting an error\n\t\tclose(p[0]);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\tif (newlen == 0) { // empty read\n\t\tclose(p[0]);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\treadlen = newlen > len ? len : newlen;\n\tret = read(p[0], value, readlen);\n\tclose(p[0]);\n\tif (ret != readlen) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\tif (newlen >= len) {\n\t\tvalue[len-1] = '\\0';\n\t\tnewlen = len-1;\n\t} else if (newlen+1 < len) {\n\t\t// cgmanager doesn't add eol to last entry\n\t\tvalue[newlen++] = '\\n';\n\t\tvalue[newlen] = '\\0';\n\t}\n\tret = newlen;\nout:\n\tif (wait_for_pid(pid))\n\t\tWARN(\"do_cgm_get exited with error\");\n\treturn ret;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"do_cgm_get exited with error\""
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_pid",
          "args": [
            "pid"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "67-81",
          "snippet": "static int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "p[0]"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "p[0]",
            "value",
            "readlen"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_read_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2217-2236",
          "snippet": "static int cgroup_read_from_file(const char *fn, char buf[], size_t bufsize)\n{\n\tint ret = lxc_read_from_file(fn, buf, bufsize);\n\tif (ret < 0) {\n\t\tSYSERROR(\"failed to read %s\", fn);\n\t\treturn ret;\n\t}\n\tif (ret == bufsize) {\n\t\tif (bufsize > 0) {\n\t\t\t/* obviously this wasn't empty */\n\t\t\tbuf[bufsize-1] = '\\0';\n\t\t\treturn ret;\n\t\t}\n\t\t/* Callers don't do this, but regression/sanity check */\n\t\tERROR(\"%s: was not expecting 0 bufsize\", __func__);\n\t\treturn -1;\n\t}\n\tbuf[ret] = '\\0';\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int cgroup_read_from_file(const char *fn, char buf[], size_t bufsize)\n{\n\tint ret = lxc_read_from_file(fn, buf, bufsize);\n\tif (ret < 0) {\n\t\tSYSERROR(\"failed to read %s\", fn);\n\t\treturn ret;\n\t}\n\tif (ret == bufsize) {\n\t\tif (bufsize > 0) {\n\t\t\t/* obviously this wasn't empty */\n\t\t\tbuf[bufsize-1] = '\\0';\n\t\t\treturn ret;\n\t\t}\n\t\t/* Callers don't do this, but regression/sanity check */\n\t\tERROR(\"%s: was not expecting 0 bufsize\", __func__);\n\t\treturn -1;\n\t}\n\tbuf[ret] = '\\0';\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "value",
            "0",
            "len"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_cgm_get",
          "args": [
            "name",
            "lxcpath",
            "filename",
            "p[1]",
            "len && value"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "do_cgm_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "856-934",
          "snippet": "static void do_cgm_get(const char *name, const char *lxcpath, const char *filename, int outp, bool sendvalue)\n{\n\tchar *controller, *key, *cgroup = NULL, *cglast;\n\tint len = -1;\n\tint ret;\n\tnih_local char *result = NULL;\n\n\tcontroller = alloca(strlen(filename)+1);\n\tstrcpy(controller, filename);\n\tkey = strchr(controller, '.');\n\tif (!key) {\n\t\tret = write(outp, &len, sizeof(len));\n\t\tif (ret != sizeof(len))\n\t\t\tWARN(\"Failed to warn cgm_get of error; parent may hang\");\n\t\texit(1);\n\t}\n\t*key = '\\0';\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\tret = write(outp, &len, sizeof(len));\n\t\tif (ret != sizeof(len))\n\t\t\tWARN(\"Failed to warn cgm_get of error; parent may hang\");\n\t\texit(1);\n\t}\n\tcgroup = try_get_abs_cgroup(name, lxcpath, controller);\n\tif (!cgroup) {\n\t\tcgm_dbus_disconnect();\n\t\tret = write(outp, &len, sizeof(len));\n\t\tif (ret != sizeof(len))\n\t\t\tWARN(\"Failed to warn cgm_get of error; parent may hang\");\n\t\texit(1);\n\t}\n\tcglast = strrchr(cgroup, '/');\n\tif (!cglast) {\n\t\tcgm_dbus_disconnect();\n\t\tfree_abs_cgroup(cgroup);\n\t\tret = write(outp, &len, sizeof(len));\n\t\tif (ret != sizeof(len))\n\t\t\tWARN(\"Failed to warn cgm_get of error; parent may hang\");\n\t\texit(1);\n\t}\n\t*cglast = '\\0';\n\tif (!lxc_cgmanager_enter(getpid(), controller, cgroup, abs_cgroup_supported())) {\n\t\tWARN(\"Failed to enter container cgroup %s:%s\", controller, cgroup);\n\t\tret = write(outp, &len, sizeof(len));\n\t\tif (ret != sizeof(len))\n\t\t\tWARN(\"Failed to warn cgm_get of error; parent may hang\");\n\t\tcgm_dbus_disconnect();\n\t\tfree_abs_cgroup(cgroup);\n\t\texit(1);\n\t}\n\tif (cgmanager_get_value_sync(NULL, cgroup_manager, controller, cglast+1, filename, &result) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tnih_free(nerr);\n\t\tfree_abs_cgroup(cgroup);\n\t\tcgm_dbus_disconnect();\n\t\tret = write(outp, &len, sizeof(len));\n\t\tif (ret != sizeof(len))\n\t\t\tWARN(\"Failed to warn cgm_get of error; parent may hang\");\n\t\texit(1);\n\t}\n\tfree_abs_cgroup(cgroup);\n\tcgm_dbus_disconnect();\n\tlen = strlen(result);\n\tret = write(outp, &len, sizeof(len));\n\tif (ret != sizeof(len)) {\n\t\tWARN(\"Failed to send length to parent\");\n\t\texit(1);\n\t}\n\tif (!len || !sendvalue) {\n\t\texit(0);\n\t}\n\tret = write(outp, result, len);\n\tif (ret < 0)\n\t\texit(1);\n\texit(0);\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void do_cgm_get(const char *name, const char *lxcpath, const char *filename, int outp, bool sendvalue)\n{\n\tchar *controller, *key, *cgroup = NULL, *cglast;\n\tint len = -1;\n\tint ret;\n\tnih_local char *result = NULL;\n\n\tcontroller = alloca(strlen(filename)+1);\n\tstrcpy(controller, filename);\n\tkey = strchr(controller, '.');\n\tif (!key) {\n\t\tret = write(outp, &len, sizeof(len));\n\t\tif (ret != sizeof(len))\n\t\t\tWARN(\"Failed to warn cgm_get of error; parent may hang\");\n\t\texit(1);\n\t}\n\t*key = '\\0';\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\tret = write(outp, &len, sizeof(len));\n\t\tif (ret != sizeof(len))\n\t\t\tWARN(\"Failed to warn cgm_get of error; parent may hang\");\n\t\texit(1);\n\t}\n\tcgroup = try_get_abs_cgroup(name, lxcpath, controller);\n\tif (!cgroup) {\n\t\tcgm_dbus_disconnect();\n\t\tret = write(outp, &len, sizeof(len));\n\t\tif (ret != sizeof(len))\n\t\t\tWARN(\"Failed to warn cgm_get of error; parent may hang\");\n\t\texit(1);\n\t}\n\tcglast = strrchr(cgroup, '/');\n\tif (!cglast) {\n\t\tcgm_dbus_disconnect();\n\t\tfree_abs_cgroup(cgroup);\n\t\tret = write(outp, &len, sizeof(len));\n\t\tif (ret != sizeof(len))\n\t\t\tWARN(\"Failed to warn cgm_get of error; parent may hang\");\n\t\texit(1);\n\t}\n\t*cglast = '\\0';\n\tif (!lxc_cgmanager_enter(getpid(), controller, cgroup, abs_cgroup_supported())) {\n\t\tWARN(\"Failed to enter container cgroup %s:%s\", controller, cgroup);\n\t\tret = write(outp, &len, sizeof(len));\n\t\tif (ret != sizeof(len))\n\t\t\tWARN(\"Failed to warn cgm_get of error; parent may hang\");\n\t\tcgm_dbus_disconnect();\n\t\tfree_abs_cgroup(cgroup);\n\t\texit(1);\n\t}\n\tif (cgmanager_get_value_sync(NULL, cgroup_manager, controller, cglast+1, filename, &result) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tnih_free(nerr);\n\t\tfree_abs_cgroup(cgroup);\n\t\tcgm_dbus_disconnect();\n\t\tret = write(outp, &len, sizeof(len));\n\t\tif (ret != sizeof(len))\n\t\t\tWARN(\"Failed to warn cgm_get of error; parent may hang\");\n\t\texit(1);\n\t}\n\tfree_abs_cgroup(cgroup);\n\tcgm_dbus_disconnect();\n\tlen = strlen(result);\n\tret = write(outp, &len, sizeof(len));\n\tif (ret != sizeof(len)) {\n\t\tWARN(\"Failed to send length to parent\");\n\t\texit(1);\n\t}\n\tif (!len || !sendvalue) {\n\t\texit(0);\n\t}\n\tret = write(outp, result, len);\n\tif (ret < 0)\n\t\texit(1);\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "107-111",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(cgm_lock, cgm_unlock, cgm_unlock);\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(cgm_lock, cgm_unlock, cgm_unlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "p"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int cgm_get(const char *filename, char *value, size_t len, const char *name, const char *lxcpath)\n{\n\tpid_t pid;\n\tint p[2], ret, newlen, readlen;\n\n\tif (pipe(p) < 0)\n\t\treturn -1;\n\tif ((pid = fork()) < 0) {\n\t\tclose(p[0]);\n\t\tclose(p[1]);\n\t\treturn -1;\n\t}\n\tif (!pid) // do_cgm_get exits\n\t\tdo_cgm_get(name, lxcpath, filename, p[1], len && value);\n\tclose(p[1]);\n\tret = read(p[0], &newlen, sizeof(newlen));\n\tif (ret != sizeof(newlen)) {\n\t\tclose(p[0]);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\tif (!len || !value) {\n\t\tclose(p[0]);\n\t\tret = newlen;\n\t\tgoto out;\n\t}\n\tmemset(value, 0, len);\n\tif (newlen < 0) { // child is reporting an error\n\t\tclose(p[0]);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\tif (newlen == 0) { // empty read\n\t\tclose(p[0]);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\treadlen = newlen > len ? len : newlen;\n\tret = read(p[0], value, readlen);\n\tclose(p[0]);\n\tif (ret != readlen) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\tif (newlen >= len) {\n\t\tvalue[len-1] = '\\0';\n\t\tnewlen = len-1;\n\t} else if (newlen+1 < len) {\n\t\t// cgmanager doesn't add eol to last entry\n\t\tvalue[newlen++] = '\\n';\n\t\tvalue[newlen] = '\\0';\n\t}\n\tret = newlen;\nout:\n\tif (wait_for_pid(pid))\n\t\tWARN(\"do_cgm_get exited with error\");\n\treturn ret;\n}"
  },
  {
    "function_name": "do_cgm_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "856-934",
    "snippet": "static void do_cgm_get(const char *name, const char *lxcpath, const char *filename, int outp, bool sendvalue)\n{\n\tchar *controller, *key, *cgroup = NULL, *cglast;\n\tint len = -1;\n\tint ret;\n\tnih_local char *result = NULL;\n\n\tcontroller = alloca(strlen(filename)+1);\n\tstrcpy(controller, filename);\n\tkey = strchr(controller, '.');\n\tif (!key) {\n\t\tret = write(outp, &len, sizeof(len));\n\t\tif (ret != sizeof(len))\n\t\t\tWARN(\"Failed to warn cgm_get of error; parent may hang\");\n\t\texit(1);\n\t}\n\t*key = '\\0';\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\tret = write(outp, &len, sizeof(len));\n\t\tif (ret != sizeof(len))\n\t\t\tWARN(\"Failed to warn cgm_get of error; parent may hang\");\n\t\texit(1);\n\t}\n\tcgroup = try_get_abs_cgroup(name, lxcpath, controller);\n\tif (!cgroup) {\n\t\tcgm_dbus_disconnect();\n\t\tret = write(outp, &len, sizeof(len));\n\t\tif (ret != sizeof(len))\n\t\t\tWARN(\"Failed to warn cgm_get of error; parent may hang\");\n\t\texit(1);\n\t}\n\tcglast = strrchr(cgroup, '/');\n\tif (!cglast) {\n\t\tcgm_dbus_disconnect();\n\t\tfree_abs_cgroup(cgroup);\n\t\tret = write(outp, &len, sizeof(len));\n\t\tif (ret != sizeof(len))\n\t\t\tWARN(\"Failed to warn cgm_get of error; parent may hang\");\n\t\texit(1);\n\t}\n\t*cglast = '\\0';\n\tif (!lxc_cgmanager_enter(getpid(), controller, cgroup, abs_cgroup_supported())) {\n\t\tWARN(\"Failed to enter container cgroup %s:%s\", controller, cgroup);\n\t\tret = write(outp, &len, sizeof(len));\n\t\tif (ret != sizeof(len))\n\t\t\tWARN(\"Failed to warn cgm_get of error; parent may hang\");\n\t\tcgm_dbus_disconnect();\n\t\tfree_abs_cgroup(cgroup);\n\t\texit(1);\n\t}\n\tif (cgmanager_get_value_sync(NULL, cgroup_manager, controller, cglast+1, filename, &result) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tnih_free(nerr);\n\t\tfree_abs_cgroup(cgroup);\n\t\tcgm_dbus_disconnect();\n\t\tret = write(outp, &len, sizeof(len));\n\t\tif (ret != sizeof(len))\n\t\t\tWARN(\"Failed to warn cgm_get of error; parent may hang\");\n\t\texit(1);\n\t}\n\tfree_abs_cgroup(cgroup);\n\tcgm_dbus_disconnect();\n\tlen = strlen(result);\n\tret = write(outp, &len, sizeof(len));\n\tif (ret != sizeof(len)) {\n\t\tWARN(\"Failed to send length to parent\");\n\t\texit(1);\n\t}\n\tif (!len || !sendvalue) {\n\t\texit(0);\n\t}\n\tret = write(outp, result, len);\n\tif (ret < 0)\n\t\texit(1);\n\texit(0);\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "outp",
            "result",
            "len"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_nointr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "327-335",
          "snippet": "ssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to send length to parent\""
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "result"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgm_dbus_disconnect",
          "args": [],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_dbus_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "123-132",
          "snippet": "static void cgm_dbus_disconnect(void)\n{\n\tif (cgroup_manager) {\n\t\tdbus_connection_flush(cgroup_manager->connection);\n\t\tdbus_connection_close(cgroup_manager->connection);\n\t\tnih_free(cgroup_manager);\n\t}\n\tcgroup_manager = NULL;\n\tcgm_unlock();\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void cgm_dbus_disconnect(void)\n{\n\tif (cgroup_manager) {\n\t\tdbus_connection_flush(cgroup_manager->connection);\n\t\tdbus_connection_close(cgroup_manager->connection);\n\t\tnih_free(cgroup_manager);\n\t}\n\tcgroup_manager = NULL;\n\tcgm_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_abs_cgroup",
          "args": [
            "cgroup"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "free_abs_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "846-854",
          "snippet": "static inline void free_abs_cgroup(char *cgroup)\n{\n\tif (!cgroup)\n\t\treturn;\n\tif (abs_cgroup_supported())\n\t\tnih_free(cgroup);\n\telse\n\t\tfree(cgroup);\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic inline void free_abs_cgroup(char *cgroup)\n{\n\tif (!cgroup)\n\t\treturn;\n\tif (abs_cgroup_supported())\n\t\tnih_free(cgroup);\n\telse\n\t\tfree(cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to warn cgm_get of error; parent may hang\""
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nih_free",
          "args": [
            "nerr"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nih_error_get",
          "args": [],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgmanager_get_value_sync",
          "args": [
            "NULL",
            "cgroup_manager",
            "controller",
            "cglast+1",
            "filename",
            "&result"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to warn cgm_get of error; parent may hang\""
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to enter container cgroup %s:%s\"",
            "controller",
            "cgroup"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cgmanager_enter",
          "args": [
            "getpid()",
            "controller",
            "cgroup",
            "abs_cgroup_supported()"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgmanager_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "690-710",
          "snippet": "static bool lxc_cgmanager_enter(pid_t pid, const char *controller,\n\t\tconst char *cgroup_path, bool abs)\n{\n\tint ret;\n\n\tif (abs)\n\t\tret = cgmanager_move_pid_abs_sync(NULL, cgroup_manager,\n\t\t\tcontroller, cgroup_path, pid);\n\telse\n\t\tret = cgmanager_move_pid_sync(NULL, cgroup_manager,\n\t\t\tcontroller, cgroup_path, pid);\n\tif (ret != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tWARN(\"call to cgmanager_move_pid_%ssync failed: %s\",\n\t\t\tabs ? \"abs_\" : \"\", nerr->message);\n\t\tnih_free(nerr);\n\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool lxc_cgmanager_enter(pid_t pid, const char *controller,\n\t\tconst char *cgroup_path, bool abs)\n{\n\tint ret;\n\n\tif (abs)\n\t\tret = cgmanager_move_pid_abs_sync(NULL, cgroup_manager,\n\t\t\tcontroller, cgroup_path, pid);\n\telse\n\t\tret = cgmanager_move_pid_sync(NULL, cgroup_manager,\n\t\t\tcontroller, cgroup_path, pid);\n\tif (ret != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tWARN(\"call to cgmanager_move_pid_%ssync failed: %s\",\n\t\t\tabs ? \"abs_\" : \"\", nerr->message);\n\t\tnih_free(nerr);\n\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "abs_cgroup_supported",
          "args": [],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "abs_cgroup_supported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "754-756",
          "snippet": "static inline bool abs_cgroup_supported(void) {\n\treturn false;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic inline bool abs_cgroup_supported(void) {\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to warn cgm_get of error; parent may hang\""
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "cgroup",
            "'/'"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to warn cgm_get of error; parent may hang\""
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_get_abs_cgroup",
          "args": [
            "name",
            "lxcpath",
            "controller"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "try_get_abs_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "760-783",
          "snippet": "static char *try_get_abs_cgroup(const char *name, const char *lxcpath,\n\t\tconst char *controller)\n{\n\tchar *cgroup = NULL;\n\n\tif (abs_cgroup_supported()) {\n\t\t/* get the container init pid and ask for its abs cgroup */\n\t\tpid_t pid = lxc_cmd_get_init_pid(name, lxcpath);\n\t\tif (pid < 0)\n\t\t\treturn NULL;\n\t\tif (cgmanager_get_pid_cgroup_abs_sync(NULL, cgroup_manager,\n\t\t\t\tcontroller, pid, &cgroup) != 0) {\n\t\t\tcgroup = NULL;\n\t\t\tNihError *nerr;\n\t\t\tnerr = nih_error_get();\n\t\t\tnih_free(nerr);\n\t\t} else\n\t\t\tprune_init_scope(cgroup);\n\t\treturn cgroup;\n\t}\n\n\t/* use the command interface to look for the cgroup */\n\treturn lxc_cmd_get_cgroup_path(name, lxcpath, controller);\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic char *try_get_abs_cgroup(const char *name, const char *lxcpath,\n\t\tconst char *controller)\n{\n\tchar *cgroup = NULL;\n\n\tif (abs_cgroup_supported()) {\n\t\t/* get the container init pid and ask for its abs cgroup */\n\t\tpid_t pid = lxc_cmd_get_init_pid(name, lxcpath);\n\t\tif (pid < 0)\n\t\t\treturn NULL;\n\t\tif (cgmanager_get_pid_cgroup_abs_sync(NULL, cgroup_manager,\n\t\t\t\tcontroller, pid, &cgroup) != 0) {\n\t\t\tcgroup = NULL;\n\t\t\tNihError *nerr;\n\t\t\tnerr = nih_error_get();\n\t\t\tnih_free(nerr);\n\t\t} else\n\t\t\tprune_init_scope(cgroup);\n\t\treturn cgroup;\n\t}\n\n\t/* use the command interface to look for the cgroup */\n\treturn lxc_cmd_get_cgroup_path(name, lxcpath, controller);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to warn cgm_get of error; parent may hang\""
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error connecting to cgroup manager\""
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgm_dbus_connect",
          "args": [],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_dbus_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "135-184",
          "snippet": "static bool cgm_dbus_connect(void)\n{\n\tDBusError dbus_error;\n\tstatic DBusConnection *connection;\n\n\tcgm_lock();\n\tif (!dbus_threads_initialized) {\n\t\t// tell dbus to do struct locking for thread safety\n\t\tdbus_threads_init_default();\n\t\tdbus_threads_initialized = true;\n\t}\n\n\tdbus_error_init(&dbus_error);\n\n\tconnection = dbus_connection_open_private(CGMANAGER_DBUS_SOCK, &dbus_error);\n\tif (!connection) {\n\t\tDEBUG(\"Failed opening dbus connection: %s: %s\",\n\t\t\t\tdbus_error.name, dbus_error.message);\n\t\tdbus_error_free(&dbus_error);\n\t\tcgm_unlock();\n\t\treturn false;\n\t}\n\tdbus_connection_set_exit_on_disconnect(connection, FALSE);\n\tdbus_error_free(&dbus_error);\n\tcgroup_manager = nih_dbus_proxy_new(NULL, connection,\n\t\t\t\tNULL /* p2p */,\n\t\t\t\t\"/org/linuxcontainers/cgmanager\", NULL, NULL);\n\tdbus_connection_unref(connection);\n\tif (!cgroup_manager) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error opening cgmanager proxy: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\n\t// get the api version\n\tif (cgmanager_get_api_version_sync(NULL, cgroup_manager, &api_version) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error cgroup manager api version: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\tif (api_version < CGM_SUPPORTS_NAMED)\n\t\tcull_user_controllers();\n\treturn true;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CGMANAGER_DBUS_SOCK \"unix:path=/sys/fs/cgroup/cgmanager/sock\"",
            "#define CGM_SUPPORTS_NAMED 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define CGMANAGER_DBUS_SOCK \"unix:path=/sys/fs/cgroup/cgmanager/sock\"\n#define CGM_SUPPORTS_NAMED 4\n\nstatic bool cgm_dbus_connect(void)\n{\n\tDBusError dbus_error;\n\tstatic DBusConnection *connection;\n\n\tcgm_lock();\n\tif (!dbus_threads_initialized) {\n\t\t// tell dbus to do struct locking for thread safety\n\t\tdbus_threads_init_default();\n\t\tdbus_threads_initialized = true;\n\t}\n\n\tdbus_error_init(&dbus_error);\n\n\tconnection = dbus_connection_open_private(CGMANAGER_DBUS_SOCK, &dbus_error);\n\tif (!connection) {\n\t\tDEBUG(\"Failed opening dbus connection: %s: %s\",\n\t\t\t\tdbus_error.name, dbus_error.message);\n\t\tdbus_error_free(&dbus_error);\n\t\tcgm_unlock();\n\t\treturn false;\n\t}\n\tdbus_connection_set_exit_on_disconnect(connection, FALSE);\n\tdbus_error_free(&dbus_error);\n\tcgroup_manager = nih_dbus_proxy_new(NULL, connection,\n\t\t\t\tNULL /* p2p */,\n\t\t\t\t\"/org/linuxcontainers/cgmanager\", NULL, NULL);\n\tdbus_connection_unref(connection);\n\tif (!cgroup_manager) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error opening cgmanager proxy: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\n\t// get the api version\n\tif (cgmanager_get_api_version_sync(NULL, cgroup_manager, &api_version) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error cgroup manager api version: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\tif (api_version < CGM_SUPPORTS_NAMED)\n\t\tcull_user_controllers();\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to warn cgm_get of error; parent may hang\""
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "controller",
            "'.'"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "controller",
            "filename"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "strlen(filename)+1"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "filename"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void do_cgm_get(const char *name, const char *lxcpath, const char *filename, int outp, bool sendvalue)\n{\n\tchar *controller, *key, *cgroup = NULL, *cglast;\n\tint len = -1;\n\tint ret;\n\tnih_local char *result = NULL;\n\n\tcontroller = alloca(strlen(filename)+1);\n\tstrcpy(controller, filename);\n\tkey = strchr(controller, '.');\n\tif (!key) {\n\t\tret = write(outp, &len, sizeof(len));\n\t\tif (ret != sizeof(len))\n\t\t\tWARN(\"Failed to warn cgm_get of error; parent may hang\");\n\t\texit(1);\n\t}\n\t*key = '\\0';\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\tret = write(outp, &len, sizeof(len));\n\t\tif (ret != sizeof(len))\n\t\t\tWARN(\"Failed to warn cgm_get of error; parent may hang\");\n\t\texit(1);\n\t}\n\tcgroup = try_get_abs_cgroup(name, lxcpath, controller);\n\tif (!cgroup) {\n\t\tcgm_dbus_disconnect();\n\t\tret = write(outp, &len, sizeof(len));\n\t\tif (ret != sizeof(len))\n\t\t\tWARN(\"Failed to warn cgm_get of error; parent may hang\");\n\t\texit(1);\n\t}\n\tcglast = strrchr(cgroup, '/');\n\tif (!cglast) {\n\t\tcgm_dbus_disconnect();\n\t\tfree_abs_cgroup(cgroup);\n\t\tret = write(outp, &len, sizeof(len));\n\t\tif (ret != sizeof(len))\n\t\t\tWARN(\"Failed to warn cgm_get of error; parent may hang\");\n\t\texit(1);\n\t}\n\t*cglast = '\\0';\n\tif (!lxc_cgmanager_enter(getpid(), controller, cgroup, abs_cgroup_supported())) {\n\t\tWARN(\"Failed to enter container cgroup %s:%s\", controller, cgroup);\n\t\tret = write(outp, &len, sizeof(len));\n\t\tif (ret != sizeof(len))\n\t\t\tWARN(\"Failed to warn cgm_get of error; parent may hang\");\n\t\tcgm_dbus_disconnect();\n\t\tfree_abs_cgroup(cgroup);\n\t\texit(1);\n\t}\n\tif (cgmanager_get_value_sync(NULL, cgroup_manager, controller, cglast+1, filename, &result) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tnih_free(nerr);\n\t\tfree_abs_cgroup(cgroup);\n\t\tcgm_dbus_disconnect();\n\t\tret = write(outp, &len, sizeof(len));\n\t\tif (ret != sizeof(len))\n\t\t\tWARN(\"Failed to warn cgm_get of error; parent may hang\");\n\t\texit(1);\n\t}\n\tfree_abs_cgroup(cgroup);\n\tcgm_dbus_disconnect();\n\tlen = strlen(result);\n\tret = write(outp, &len, sizeof(len));\n\tif (ret != sizeof(len)) {\n\t\tWARN(\"Failed to send length to parent\");\n\t\texit(1);\n\t}\n\tif (!len || !sendvalue) {\n\t\texit(0);\n\t}\n\tret = write(outp, result, len);\n\tif (ret < 0)\n\t\texit(1);\n\texit(0);\n}"
  },
  {
    "function_name": "free_abs_cgroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "846-854",
    "snippet": "static inline void free_abs_cgroup(char *cgroup)\n{\n\tif (!cgroup)\n\t\treturn;\n\tif (abs_cgroup_supported())\n\t\tnih_free(cgroup);\n\telse\n\t\tfree(cgroup);\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cgroup"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "1451-1474",
          "snippet": "static bool cgm_unfreeze(void *hdata)\n{\n\tstruct cgm_data *d = hdata;\n\tbool ret = true;\n\n\tif (!d || !d->cgroup_path)\n\t\treturn false;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\tif (cgmanager_set_value_sync(NULL, cgroup_manager, \"freezer\", d->cgroup_path,\n\t\t\t\"freezer.state\", \"THAWED\") != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_set_value_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Error unfreezing %s\", d->cgroup_path);\n\t\tret = false;\n\t}\n\tcgm_dbus_disconnect();\n\treturn ret;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgm_unfreeze(void *hdata)\n{\n\tstruct cgm_data *d = hdata;\n\tbool ret = true;\n\n\tif (!d || !d->cgroup_path)\n\t\treturn false;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\tif (cgmanager_set_value_sync(NULL, cgroup_manager, \"freezer\", d->cgroup_path,\n\t\t\t\"freezer.state\", \"THAWED\") != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_set_value_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Error unfreezing %s\", d->cgroup_path);\n\t\tret = false;\n\t}\n\tcgm_dbus_disconnect();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nih_free",
          "args": [
            "cgroup"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abs_cgroup_supported",
          "args": [],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "abs_cgroup_supported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "754-756",
          "snippet": "static inline bool abs_cgroup_supported(void) {\n\treturn false;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic inline bool abs_cgroup_supported(void) {\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic inline void free_abs_cgroup(char *cgroup)\n{\n\tif (!cgroup)\n\t\treturn;\n\tif (abs_cgroup_supported())\n\t\tnih_free(cgroup);\n\telse\n\t\tfree(cgroup);\n}"
  },
  {
    "function_name": "lxc_list_controllers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "840-843",
    "snippet": "static bool lxc_list_controllers(char ***list)\n{\n\treturn false;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool lxc_list_controllers(char ***list)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "lxc_list_controllers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "821-838",
    "snippet": "static bool lxc_list_controllers(char ***list)\n{\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\tif (cgmanager_list_controllers_sync(NULL, cgroup_manager, list) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_list_controllers_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\n\tcgm_dbus_disconnect();\n\treturn true;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgm_dbus_disconnect",
          "args": [],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_dbus_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "123-132",
          "snippet": "static void cgm_dbus_disconnect(void)\n{\n\tif (cgroup_manager) {\n\t\tdbus_connection_flush(cgroup_manager->connection);\n\t\tdbus_connection_close(cgroup_manager->connection);\n\t\tnih_free(cgroup_manager);\n\t}\n\tcgroup_manager = NULL;\n\tcgm_unlock();\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void cgm_dbus_disconnect(void)\n{\n\tif (cgroup_manager) {\n\t\tdbus_connection_flush(cgroup_manager->connection);\n\t\tdbus_connection_close(cgroup_manager->connection);\n\t\tnih_free(cgroup_manager);\n\t}\n\tcgroup_manager = NULL;\n\tcgm_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "nih_free",
          "args": [
            "nerr"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"call to cgmanager_list_controllers_sync failed: %s\"",
            "nerr->message"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nih_error_get",
          "args": [],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgmanager_list_controllers_sync",
          "args": [
            "NULL",
            "cgroup_manager",
            "list"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error connecting to cgroup manager\""
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgm_dbus_connect",
          "args": [],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_dbus_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "135-184",
          "snippet": "static bool cgm_dbus_connect(void)\n{\n\tDBusError dbus_error;\n\tstatic DBusConnection *connection;\n\n\tcgm_lock();\n\tif (!dbus_threads_initialized) {\n\t\t// tell dbus to do struct locking for thread safety\n\t\tdbus_threads_init_default();\n\t\tdbus_threads_initialized = true;\n\t}\n\n\tdbus_error_init(&dbus_error);\n\n\tconnection = dbus_connection_open_private(CGMANAGER_DBUS_SOCK, &dbus_error);\n\tif (!connection) {\n\t\tDEBUG(\"Failed opening dbus connection: %s: %s\",\n\t\t\t\tdbus_error.name, dbus_error.message);\n\t\tdbus_error_free(&dbus_error);\n\t\tcgm_unlock();\n\t\treturn false;\n\t}\n\tdbus_connection_set_exit_on_disconnect(connection, FALSE);\n\tdbus_error_free(&dbus_error);\n\tcgroup_manager = nih_dbus_proxy_new(NULL, connection,\n\t\t\t\tNULL /* p2p */,\n\t\t\t\t\"/org/linuxcontainers/cgmanager\", NULL, NULL);\n\tdbus_connection_unref(connection);\n\tif (!cgroup_manager) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error opening cgmanager proxy: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\n\t// get the api version\n\tif (cgmanager_get_api_version_sync(NULL, cgroup_manager, &api_version) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error cgroup manager api version: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\tif (api_version < CGM_SUPPORTS_NAMED)\n\t\tcull_user_controllers();\n\treturn true;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CGMANAGER_DBUS_SOCK \"unix:path=/sys/fs/cgroup/cgmanager/sock\"",
            "#define CGM_SUPPORTS_NAMED 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define CGMANAGER_DBUS_SOCK \"unix:path=/sys/fs/cgroup/cgmanager/sock\"\n#define CGM_SUPPORTS_NAMED 4\n\nstatic bool cgm_dbus_connect(void)\n{\n\tDBusError dbus_error;\n\tstatic DBusConnection *connection;\n\n\tcgm_lock();\n\tif (!dbus_threads_initialized) {\n\t\t// tell dbus to do struct locking for thread safety\n\t\tdbus_threads_init_default();\n\t\tdbus_threads_initialized = true;\n\t}\n\n\tdbus_error_init(&dbus_error);\n\n\tconnection = dbus_connection_open_private(CGMANAGER_DBUS_SOCK, &dbus_error);\n\tif (!connection) {\n\t\tDEBUG(\"Failed opening dbus connection: %s: %s\",\n\t\t\t\tdbus_error.name, dbus_error.message);\n\t\tdbus_error_free(&dbus_error);\n\t\tcgm_unlock();\n\t\treturn false;\n\t}\n\tdbus_connection_set_exit_on_disconnect(connection, FALSE);\n\tdbus_error_free(&dbus_error);\n\tcgroup_manager = nih_dbus_proxy_new(NULL, connection,\n\t\t\t\tNULL /* p2p */,\n\t\t\t\t\"/org/linuxcontainers/cgmanager\", NULL, NULL);\n\tdbus_connection_unref(connection);\n\tif (!cgroup_manager) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error opening cgmanager proxy: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\n\t// get the api version\n\tif (cgmanager_get_api_version_sync(NULL, cgroup_manager, &api_version) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error cgroup manager api version: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\tif (api_version < CGM_SUPPORTS_NAMED)\n\t\tcull_user_controllers();\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool lxc_list_controllers(char ***list)\n{\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\tif (cgmanager_list_controllers_sync(NULL, cgroup_manager, list) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_list_controllers_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\n\tcgm_dbus_disconnect();\n\treturn true;\n}"
  },
  {
    "function_name": "cgm_get_nrtasks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "792-818",
    "snippet": "static int cgm_get_nrtasks(void *hdata)\n{\n\tstruct cgm_data *d = hdata;\n\tint32_t *pids;\n\tsize_t pids_len;\n\n\tif (!d || !d->cgroup_path)\n\t\treturn -1;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn -1;\n\t}\n\tif (cgmanager_get_tasks_sync(NULL, cgroup_manager, subsystems[0],\n\t\t\t\t     d->cgroup_path, &pids, &pids_len) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_get_tasks_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tpids_len = -1;\n\t\tgoto out;\n\t}\n\tnih_free(pids);\nout:\n\tcgm_dbus_disconnect();\n\treturn pids_len;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgm_dbus_disconnect",
          "args": [],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_dbus_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "123-132",
          "snippet": "static void cgm_dbus_disconnect(void)\n{\n\tif (cgroup_manager) {\n\t\tdbus_connection_flush(cgroup_manager->connection);\n\t\tdbus_connection_close(cgroup_manager->connection);\n\t\tnih_free(cgroup_manager);\n\t}\n\tcgroup_manager = NULL;\n\tcgm_unlock();\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void cgm_dbus_disconnect(void)\n{\n\tif (cgroup_manager) {\n\t\tdbus_connection_flush(cgroup_manager->connection);\n\t\tdbus_connection_close(cgroup_manager->connection);\n\t\tnih_free(cgroup_manager);\n\t}\n\tcgroup_manager = NULL;\n\tcgm_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "nih_free",
          "args": [
            "pids"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nih_free",
          "args": [
            "nerr"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"call to cgmanager_get_tasks_sync failed: %s\"",
            "nerr->message"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nih_error_get",
          "args": [],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgmanager_get_tasks_sync",
          "args": [
            "NULL",
            "cgroup_manager",
            "subsystems[0]",
            "d->cgroup_path",
            "&pids",
            "&pids_len"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error connecting to cgroup manager\""
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgm_dbus_connect",
          "args": [],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_dbus_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "135-184",
          "snippet": "static bool cgm_dbus_connect(void)\n{\n\tDBusError dbus_error;\n\tstatic DBusConnection *connection;\n\n\tcgm_lock();\n\tif (!dbus_threads_initialized) {\n\t\t// tell dbus to do struct locking for thread safety\n\t\tdbus_threads_init_default();\n\t\tdbus_threads_initialized = true;\n\t}\n\n\tdbus_error_init(&dbus_error);\n\n\tconnection = dbus_connection_open_private(CGMANAGER_DBUS_SOCK, &dbus_error);\n\tif (!connection) {\n\t\tDEBUG(\"Failed opening dbus connection: %s: %s\",\n\t\t\t\tdbus_error.name, dbus_error.message);\n\t\tdbus_error_free(&dbus_error);\n\t\tcgm_unlock();\n\t\treturn false;\n\t}\n\tdbus_connection_set_exit_on_disconnect(connection, FALSE);\n\tdbus_error_free(&dbus_error);\n\tcgroup_manager = nih_dbus_proxy_new(NULL, connection,\n\t\t\t\tNULL /* p2p */,\n\t\t\t\t\"/org/linuxcontainers/cgmanager\", NULL, NULL);\n\tdbus_connection_unref(connection);\n\tif (!cgroup_manager) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error opening cgmanager proxy: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\n\t// get the api version\n\tif (cgmanager_get_api_version_sync(NULL, cgroup_manager, &api_version) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error cgroup manager api version: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\tif (api_version < CGM_SUPPORTS_NAMED)\n\t\tcull_user_controllers();\n\treturn true;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CGMANAGER_DBUS_SOCK \"unix:path=/sys/fs/cgroup/cgmanager/sock\"",
            "#define CGM_SUPPORTS_NAMED 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define CGMANAGER_DBUS_SOCK \"unix:path=/sys/fs/cgroup/cgmanager/sock\"\n#define CGM_SUPPORTS_NAMED 4\n\nstatic bool cgm_dbus_connect(void)\n{\n\tDBusError dbus_error;\n\tstatic DBusConnection *connection;\n\n\tcgm_lock();\n\tif (!dbus_threads_initialized) {\n\t\t// tell dbus to do struct locking for thread safety\n\t\tdbus_threads_init_default();\n\t\tdbus_threads_initialized = true;\n\t}\n\n\tdbus_error_init(&dbus_error);\n\n\tconnection = dbus_connection_open_private(CGMANAGER_DBUS_SOCK, &dbus_error);\n\tif (!connection) {\n\t\tDEBUG(\"Failed opening dbus connection: %s: %s\",\n\t\t\t\tdbus_error.name, dbus_error.message);\n\t\tdbus_error_free(&dbus_error);\n\t\tcgm_unlock();\n\t\treturn false;\n\t}\n\tdbus_connection_set_exit_on_disconnect(connection, FALSE);\n\tdbus_error_free(&dbus_error);\n\tcgroup_manager = nih_dbus_proxy_new(NULL, connection,\n\t\t\t\tNULL /* p2p */,\n\t\t\t\t\"/org/linuxcontainers/cgmanager\", NULL, NULL);\n\tdbus_connection_unref(connection);\n\tif (!cgroup_manager) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error opening cgmanager proxy: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\n\t// get the api version\n\tif (cgmanager_get_api_version_sync(NULL, cgroup_manager, &api_version) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error cgroup manager api version: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\tif (api_version < CGM_SUPPORTS_NAMED)\n\t\tcull_user_controllers();\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int cgm_get_nrtasks(void *hdata)\n{\n\tstruct cgm_data *d = hdata;\n\tint32_t *pids;\n\tsize_t pids_len;\n\n\tif (!d || !d->cgroup_path)\n\t\treturn -1;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn -1;\n\t}\n\tif (cgmanager_get_tasks_sync(NULL, cgroup_manager, subsystems[0],\n\t\t\t\t     d->cgroup_path, &pids, &pids_len) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_get_tasks_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tpids_len = -1;\n\t\tgoto out;\n\t}\n\tnih_free(pids);\nout:\n\tcgm_dbus_disconnect();\n\treturn pids_len;\n}"
  },
  {
    "function_name": "try_get_abs_cgroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "760-783",
    "snippet": "static char *try_get_abs_cgroup(const char *name, const char *lxcpath,\n\t\tconst char *controller)\n{\n\tchar *cgroup = NULL;\n\n\tif (abs_cgroup_supported()) {\n\t\t/* get the container init pid and ask for its abs cgroup */\n\t\tpid_t pid = lxc_cmd_get_init_pid(name, lxcpath);\n\t\tif (pid < 0)\n\t\t\treturn NULL;\n\t\tif (cgmanager_get_pid_cgroup_abs_sync(NULL, cgroup_manager,\n\t\t\t\tcontroller, pid, &cgroup) != 0) {\n\t\t\tcgroup = NULL;\n\t\t\tNihError *nerr;\n\t\t\tnerr = nih_error_get();\n\t\t\tnih_free(nerr);\n\t\t} else\n\t\t\tprune_init_scope(cgroup);\n\t\treturn cgroup;\n\t}\n\n\t/* use the command interface to look for the cgroup */\n\treturn lxc_cmd_get_cgroup_path(name, lxcpath, controller);\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_cmd_get_cgroup_path",
          "args": [
            "name",
            "lxcpath",
            "controller"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_get_cgroup_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "444-472",
          "snippet": "char *lxc_cmd_get_cgroup_path(const char *name, const char *lxcpath,\n\tconst char *subsystem)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = {\n\t\t\t.cmd = LXC_CMD_GET_CGROUP,\n\t\t\t.datalen = strlen(subsystem)+1,\n\t\t\t.data = subsystem,\n\t\t},\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn NULL;\n\n\tif (!ret) {\n\t\tWARN(\"Container \\\"%s\\\" has stopped before sending its state.\", name);\n\t\treturn NULL;\n\t}\n\n\tif (cmd.rsp.ret < 0 || cmd.rsp.datalen < 0) {\n\t\tERROR(\"Command %s failed for container \\\"%s\\\": %s.\",\n\t\t      lxc_cmd_str(cmd.req.cmd), name, strerror(-cmd.rsp.ret));\n\t\treturn NULL;\n\t}\n\n\treturn cmd.rsp.data;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nchar *lxc_cmd_get_cgroup_path(const char *name, const char *lxcpath,\n\tconst char *subsystem)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = {\n\t\t\t.cmd = LXC_CMD_GET_CGROUP,\n\t\t\t.datalen = strlen(subsystem)+1,\n\t\t\t.data = subsystem,\n\t\t},\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn NULL;\n\n\tif (!ret) {\n\t\tWARN(\"Container \\\"%s\\\" has stopped before sending its state.\", name);\n\t\treturn NULL;\n\t}\n\n\tif (cmd.rsp.ret < 0 || cmd.rsp.datalen < 0) {\n\t\tERROR(\"Command %s failed for container \\\"%s\\\": %s.\",\n\t\t      lxc_cmd_str(cmd.req.cmd), name, strerror(-cmd.rsp.ret));\n\t\treturn NULL;\n\t}\n\n\treturn cmd.rsp.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prune_init_scope",
          "args": [
            "cgroup"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "prune_init_scope",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgroup.c",
          "lines": "212-228",
          "snippet": "void prune_init_scope(char *cg)\n{\n\tchar *point;\n\n\tif (!cg)\n\t\treturn;\n\n\tpoint = cg + strlen(cg) - strlen(INIT_SCOPE);\n\tif (point < cg)\n\t\treturn;\n\tif (strcmp(point, INIT_SCOPE) == 0) {\n\t\tif (point == cg)\n\t\t\t*(point+1) = '\\0';\n\t\telse\n\t\t\t*point = '\\0';\n\t}\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"log.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [
            "#define INIT_SCOPE \"/init.scope\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"log.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <unistd.h>\n\n#define INIT_SCOPE \"/init.scope\"\n\nvoid prune_init_scope(char *cg)\n{\n\tchar *point;\n\n\tif (!cg)\n\t\treturn;\n\n\tpoint = cg + strlen(cg) - strlen(INIT_SCOPE);\n\tif (point < cg)\n\t\treturn;\n\tif (strcmp(point, INIT_SCOPE) == 0) {\n\t\tif (point == cg)\n\t\t\t*(point+1) = '\\0';\n\t\telse\n\t\t\t*point = '\\0';\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nih_free",
          "args": [
            "nerr"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nih_error_get",
          "args": [],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgmanager_get_pid_cgroup_abs_sync",
          "args": [
            "NULL",
            "cgroup_manager",
            "controller",
            "pid",
            "&cgroup"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cmd_get_init_pid",
          "args": [
            "name",
            "lxcpath"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_get_init_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "380-392",
          "snippet": "pid_t lxc_cmd_get_init_pid(const char *name, const char *lxcpath)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_GET_INIT_PID },\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn PTR_TO_INT(cmd.rsp.data);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\npid_t lxc_cmd_get_init_pid(const char *name, const char *lxcpath)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_GET_INIT_PID },\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn PTR_TO_INT(cmd.rsp.data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "abs_cgroup_supported",
          "args": [],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "abs_cgroup_supported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "754-756",
          "snippet": "static inline bool abs_cgroup_supported(void) {\n\treturn false;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic inline bool abs_cgroup_supported(void) {\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic char *try_get_abs_cgroup(const char *name, const char *lxcpath,\n\t\tconst char *controller)\n{\n\tchar *cgroup = NULL;\n\n\tif (abs_cgroup_supported()) {\n\t\t/* get the container init pid and ask for its abs cgroup */\n\t\tpid_t pid = lxc_cmd_get_init_pid(name, lxcpath);\n\t\tif (pid < 0)\n\t\t\treturn NULL;\n\t\tif (cgmanager_get_pid_cgroup_abs_sync(NULL, cgroup_manager,\n\t\t\t\tcontroller, pid, &cgroup) != 0) {\n\t\t\tcgroup = NULL;\n\t\t\tNihError *nerr;\n\t\t\tnerr = nih_error_get();\n\t\t\tnih_free(nerr);\n\t\t} else\n\t\t\tprune_init_scope(cgroup);\n\t\treturn cgroup;\n\t}\n\n\t/* use the command interface to look for the cgroup */\n\treturn lxc_cmd_get_cgroup_path(name, lxcpath, controller);\n}"
  },
  {
    "function_name": "abs_cgroup_supported",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "754-756",
    "snippet": "static inline bool abs_cgroup_supported(void) {\n\treturn false;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic inline bool abs_cgroup_supported(void) {\n\treturn false;\n}"
  },
  {
    "function_name": "abs_cgroup_supported",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "750-752",
    "snippet": "static inline bool abs_cgroup_supported(void) {\n\treturn api_version >= CGM_SUPPORTS_GET_ABS;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define CGM_SUPPORTS_GET_ABS 3"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define CGM_SUPPORTS_GET_ABS 3\n\nstatic inline bool abs_cgroup_supported(void) {\n\treturn api_version >= CGM_SUPPORTS_GET_ABS;\n}"
  },
  {
    "function_name": "cgm_get_cgroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "740-747",
    "snippet": "static const char *cgm_get_cgroup(void *hdata, const char *subsystem)\n{\n\tstruct cgm_data *d = hdata;\n\n\tif (!d || !d->cgroup_path)\n\t\treturn NULL;\n\treturn d->cgroup_path;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic const char *cgm_get_cgroup(void *hdata, const char *subsystem)\n{\n\tstruct cgm_data *d = hdata;\n\n\tif (!d || !d->cgroup_path)\n\t\treturn NULL;\n\treturn d->cgroup_path;\n}"
  },
  {
    "function_name": "cgm_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "712-738",
    "snippet": "static inline bool cgm_enter(void *hdata, pid_t pid)\n{\n\tstruct cgm_data *d = hdata;\n\tchar **slist = subsystems;\n\tbool ret = false;\n\tint i;\n\n\tif (!d || !d->cgroup_path)\n\t\treturn false;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\n\tif (cgm_all_controllers_same)\n\t\tslist = subsystems_inone;\n\n\tfor (i = 0; slist[i]; i++) {\n\t\tif (!lxc_cgmanager_enter(pid, slist[i], d->cgroup_path, false))\n\t\t\tgoto out;\n\t}\n\tret = true;\nout:\n\tcgm_dbus_disconnect();\n\treturn ret;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgm_dbus_disconnect",
          "args": [],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_dbus_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "123-132",
          "snippet": "static void cgm_dbus_disconnect(void)\n{\n\tif (cgroup_manager) {\n\t\tdbus_connection_flush(cgroup_manager->connection);\n\t\tdbus_connection_close(cgroup_manager->connection);\n\t\tnih_free(cgroup_manager);\n\t}\n\tcgroup_manager = NULL;\n\tcgm_unlock();\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void cgm_dbus_disconnect(void)\n{\n\tif (cgroup_manager) {\n\t\tdbus_connection_flush(cgroup_manager->connection);\n\t\tdbus_connection_close(cgroup_manager->connection);\n\t\tnih_free(cgroup_manager);\n\t}\n\tcgroup_manager = NULL;\n\tcgm_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cgmanager_enter",
          "args": [
            "pid",
            "slist[i]",
            "d->cgroup_path",
            "false"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgmanager_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "690-710",
          "snippet": "static bool lxc_cgmanager_enter(pid_t pid, const char *controller,\n\t\tconst char *cgroup_path, bool abs)\n{\n\tint ret;\n\n\tif (abs)\n\t\tret = cgmanager_move_pid_abs_sync(NULL, cgroup_manager,\n\t\t\tcontroller, cgroup_path, pid);\n\telse\n\t\tret = cgmanager_move_pid_sync(NULL, cgroup_manager,\n\t\t\tcontroller, cgroup_path, pid);\n\tif (ret != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tWARN(\"call to cgmanager_move_pid_%ssync failed: %s\",\n\t\t\tabs ? \"abs_\" : \"\", nerr->message);\n\t\tnih_free(nerr);\n\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool lxc_cgmanager_enter(pid_t pid, const char *controller,\n\t\tconst char *cgroup_path, bool abs)\n{\n\tint ret;\n\n\tif (abs)\n\t\tret = cgmanager_move_pid_abs_sync(NULL, cgroup_manager,\n\t\t\tcontroller, cgroup_path, pid);\n\telse\n\t\tret = cgmanager_move_pid_sync(NULL, cgroup_manager,\n\t\t\tcontroller, cgroup_path, pid);\n\tif (ret != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tWARN(\"call to cgmanager_move_pid_%ssync failed: %s\",\n\t\t\tabs ? \"abs_\" : \"\", nerr->message);\n\t\tnih_free(nerr);\n\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error connecting to cgroup manager\""
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgm_dbus_connect",
          "args": [],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_dbus_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "135-184",
          "snippet": "static bool cgm_dbus_connect(void)\n{\n\tDBusError dbus_error;\n\tstatic DBusConnection *connection;\n\n\tcgm_lock();\n\tif (!dbus_threads_initialized) {\n\t\t// tell dbus to do struct locking for thread safety\n\t\tdbus_threads_init_default();\n\t\tdbus_threads_initialized = true;\n\t}\n\n\tdbus_error_init(&dbus_error);\n\n\tconnection = dbus_connection_open_private(CGMANAGER_DBUS_SOCK, &dbus_error);\n\tif (!connection) {\n\t\tDEBUG(\"Failed opening dbus connection: %s: %s\",\n\t\t\t\tdbus_error.name, dbus_error.message);\n\t\tdbus_error_free(&dbus_error);\n\t\tcgm_unlock();\n\t\treturn false;\n\t}\n\tdbus_connection_set_exit_on_disconnect(connection, FALSE);\n\tdbus_error_free(&dbus_error);\n\tcgroup_manager = nih_dbus_proxy_new(NULL, connection,\n\t\t\t\tNULL /* p2p */,\n\t\t\t\t\"/org/linuxcontainers/cgmanager\", NULL, NULL);\n\tdbus_connection_unref(connection);\n\tif (!cgroup_manager) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error opening cgmanager proxy: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\n\t// get the api version\n\tif (cgmanager_get_api_version_sync(NULL, cgroup_manager, &api_version) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error cgroup manager api version: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\tif (api_version < CGM_SUPPORTS_NAMED)\n\t\tcull_user_controllers();\n\treturn true;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CGMANAGER_DBUS_SOCK \"unix:path=/sys/fs/cgroup/cgmanager/sock\"",
            "#define CGM_SUPPORTS_NAMED 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define CGMANAGER_DBUS_SOCK \"unix:path=/sys/fs/cgroup/cgmanager/sock\"\n#define CGM_SUPPORTS_NAMED 4\n\nstatic bool cgm_dbus_connect(void)\n{\n\tDBusError dbus_error;\n\tstatic DBusConnection *connection;\n\n\tcgm_lock();\n\tif (!dbus_threads_initialized) {\n\t\t// tell dbus to do struct locking for thread safety\n\t\tdbus_threads_init_default();\n\t\tdbus_threads_initialized = true;\n\t}\n\n\tdbus_error_init(&dbus_error);\n\n\tconnection = dbus_connection_open_private(CGMANAGER_DBUS_SOCK, &dbus_error);\n\tif (!connection) {\n\t\tDEBUG(\"Failed opening dbus connection: %s: %s\",\n\t\t\t\tdbus_error.name, dbus_error.message);\n\t\tdbus_error_free(&dbus_error);\n\t\tcgm_unlock();\n\t\treturn false;\n\t}\n\tdbus_connection_set_exit_on_disconnect(connection, FALSE);\n\tdbus_error_free(&dbus_error);\n\tcgroup_manager = nih_dbus_proxy_new(NULL, connection,\n\t\t\t\tNULL /* p2p */,\n\t\t\t\t\"/org/linuxcontainers/cgmanager\", NULL, NULL);\n\tdbus_connection_unref(connection);\n\tif (!cgroup_manager) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error opening cgmanager proxy: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\n\t// get the api version\n\tif (cgmanager_get_api_version_sync(NULL, cgroup_manager, &api_version) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error cgroup manager api version: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\tif (api_version < CGM_SUPPORTS_NAMED)\n\t\tcull_user_controllers();\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic inline bool cgm_enter(void *hdata, pid_t pid)\n{\n\tstruct cgm_data *d = hdata;\n\tchar **slist = subsystems;\n\tbool ret = false;\n\tint i;\n\n\tif (!d || !d->cgroup_path)\n\t\treturn false;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\n\tif (cgm_all_controllers_same)\n\t\tslist = subsystems_inone;\n\n\tfor (i = 0; slist[i]; i++) {\n\t\tif (!lxc_cgmanager_enter(pid, slist[i], d->cgroup_path, false))\n\t\t\tgoto out;\n\t}\n\tret = true;\nout:\n\tcgm_dbus_disconnect();\n\treturn ret;\n}"
  },
  {
    "function_name": "lxc_cgmanager_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "690-710",
    "snippet": "static bool lxc_cgmanager_enter(pid_t pid, const char *controller,\n\t\tconst char *cgroup_path, bool abs)\n{\n\tint ret;\n\n\tif (abs)\n\t\tret = cgmanager_move_pid_abs_sync(NULL, cgroup_manager,\n\t\t\tcontroller, cgroup_path, pid);\n\telse\n\t\tret = cgmanager_move_pid_sync(NULL, cgroup_manager,\n\t\t\tcontroller, cgroup_path, pid);\n\tif (ret != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tWARN(\"call to cgmanager_move_pid_%ssync failed: %s\",\n\t\t\tabs ? \"abs_\" : \"\", nerr->message);\n\t\tnih_free(nerr);\n\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nih_free",
          "args": [
            "nerr"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"call to cgmanager_move_pid_%ssync failed: %s\"",
            "abs ? \"abs_\" : \"\"",
            "nerr->message"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nih_error_get",
          "args": [],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgmanager_move_pid_sync",
          "args": [
            "NULL",
            "cgroup_manager",
            "controller",
            "cgroup_path",
            "pid"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgmanager_move_pid_abs_sync",
          "args": [
            "NULL",
            "cgroup_manager",
            "controller",
            "cgroup_path",
            "pid"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool lxc_cgmanager_enter(pid_t pid, const char *controller,\n\t\tconst char *cgroup_path, bool abs)\n{\n\tint ret;\n\n\tif (abs)\n\t\tret = cgmanager_move_pid_abs_sync(NULL, cgroup_manager,\n\t\t\tcontroller, cgroup_path, pid);\n\telse\n\t\tret = cgmanager_move_pid_sync(NULL, cgroup_manager,\n\t\t\tcontroller, cgroup_path, pid);\n\tif (ret != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tWARN(\"call to cgmanager_move_pid_%ssync failed: %s\",\n\t\t\tabs ? \"abs_\" : \"\", nerr->message);\n\t\tnih_free(nerr);\n\t\treturn false;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "cgm_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "612-680",
    "snippet": "static inline bool cgm_create(void *hdata)\n{\n\tstruct cgm_data *d = hdata;\n\tchar **slist = subsystems;\n\tint i, index=0, baselen, ret;\n\tint32_t existed;\n\tchar result[MAXPATHLEN], *tmp, *cgroup_path;\n\n\tif (!d)\n\t\treturn false;\n// XXX we should send a hint to the cgmanager that when these\n// cgroups become empty they should be deleted.  Requires a cgmanager\n// extension\n\n\tmemset(result, 0, MAXPATHLEN);\n\ttmp = lxc_string_replace(\"%n\", d->name, d->cgroup_pattern);\n\tif (!tmp)\n\t\tgoto bad;\n\tif (strlen(tmp) >= MAXPATHLEN) {\n\t\tfree(tmp);\n\t\tgoto bad;\n\t}\n\tstrcpy(result, tmp);\n\tbaselen = strlen(result);\n\tfree(tmp);\n\ttmp = result;\n\twhile (*tmp == '/')\n\t\ttmp++;\nagain:\n\tif (index == 100) { // turn this into a warn later\n\t\tERROR(\"cgroup error?  100 cgroups with this name already running\");\n\t\tgoto bad;\n\t}\n\tif (index) {\n\t\tret = snprintf(result+baselen, MAXPATHLEN-baselen, \"-%d\", index);\n\t\tif (ret < 0 || ret >= MAXPATHLEN-baselen)\n\t\t\tgoto bad;\n\t}\n\texisted = 0;\n\n\tif (cgm_all_controllers_same)\n\t\tslist = subsystems_inone;\n\n\tfor (i = 0; slist[i]; i++) {\n\t\tif (!lxc_cgmanager_create(slist[i], tmp, &existed)) {\n\t\t\tERROR(\"Error creating cgroup %s:%s\", slist[i], result);\n\t\t\tcleanup_cgroups(tmp);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (existed == 1)\n\t\t\tgoto next;\n\t}\n\t// success\n\tcgroup_path = strdup(tmp);\n\tif (!cgroup_path) {\n\t\tcleanup_cgroups(tmp);\n\t\tgoto bad;\n\t}\n\td->cgroup_path = cgroup_path;\n\tcgm_dbus_disconnect();\n\treturn true;\n\nnext:\n\tindex++;\n\tgoto again;\nbad:\n\tcgm_dbus_disconnect();\n\treturn false;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgm_dbus_disconnect",
          "args": [],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_dbus_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "123-132",
          "snippet": "static void cgm_dbus_disconnect(void)\n{\n\tif (cgroup_manager) {\n\t\tdbus_connection_flush(cgroup_manager->connection);\n\t\tdbus_connection_close(cgroup_manager->connection);\n\t\tnih_free(cgroup_manager);\n\t}\n\tcgroup_manager = NULL;\n\tcgm_unlock();\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void cgm_dbus_disconnect(void)\n{\n\tif (cgroup_manager) {\n\t\tdbus_connection_flush(cgroup_manager->connection);\n\t\tdbus_connection_close(cgroup_manager->connection);\n\t\tnih_free(cgroup_manager);\n\t}\n\tcgroup_manager = NULL;\n\tcgm_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cleanup_cgroups",
          "args": [
            "tmp"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_cgroups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "601-610",
          "snippet": "static inline void cleanup_cgroups(char *path)\n{\n\tint i;\n\tchar **slist = subsystems;\n\n\tif (cgm_all_controllers_same)\n\t\tslist = subsystems_inone;\n\tfor (i = 0; slist[i]; i++)\n\t\tcgm_remove_cgroup(slist[i], path);\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic inline void cleanup_cgroups(char *path)\n{\n\tint i;\n\tchar **slist = subsystems;\n\n\tif (cgm_all_controllers_same)\n\t\tslist = subsystems_inone;\n\tfor (i = 0; slist[i]; i++)\n\t\tcgm_remove_cgroup(slist[i], path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "tmp"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error creating cgroup %s:%s\"",
            "slist[i]",
            "result"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cgmanager_create",
          "args": [
            "slist[i]",
            "tmp",
            "&existed"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgmanager_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "281-295",
          "snippet": "static bool lxc_cgmanager_create(const char *controller, const char *cgroup_path, int32_t *existed)\n{\n\tbool ret = true;\n\tif ( cgmanager_create_sync(NULL, cgroup_manager, controller,\n\t\t\t\t       cgroup_path, existed) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_create_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Failed to create %s:%s\", controller, cgroup_path);\n\t\tret = false;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool lxc_cgmanager_create(const char *controller, const char *cgroup_path, int32_t *existed)\n{\n\tbool ret = true;\n\tif ( cgmanager_create_sync(NULL, cgroup_manager, controller,\n\t\t\t\t       cgroup_path, existed) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_create_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Failed to create %s:%s\", controller, cgroup_path);\n\t\tret = false;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "result+baselen",
            "MAXPATHLEN-baselen",
            "\"-%d\"",
            "index"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"cgroup error?  100 cgroups with this name already running\""
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tmp"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "1451-1474",
          "snippet": "static bool cgm_unfreeze(void *hdata)\n{\n\tstruct cgm_data *d = hdata;\n\tbool ret = true;\n\n\tif (!d || !d->cgroup_path)\n\t\treturn false;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\tif (cgmanager_set_value_sync(NULL, cgroup_manager, \"freezer\", d->cgroup_path,\n\t\t\t\"freezer.state\", \"THAWED\") != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_set_value_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Error unfreezing %s\", d->cgroup_path);\n\t\tret = false;\n\t}\n\tcgm_dbus_disconnect();\n\treturn ret;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgm_unfreeze(void *hdata)\n{\n\tstruct cgm_data *d = hdata;\n\tbool ret = true;\n\n\tif (!d || !d->cgroup_path)\n\t\treturn false;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\tif (cgmanager_set_value_sync(NULL, cgroup_manager, \"freezer\", d->cgroup_path,\n\t\t\t\"freezer.state\", \"THAWED\") != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_set_value_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Error unfreezing %s\", d->cgroup_path);\n\t\tret = false;\n\t}\n\tcgm_dbus_disconnect();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "result"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "result",
            "tmp"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_string_replace",
          "args": [
            "\"%n\"",
            "d->name",
            "d->cgroup_pattern"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "601-654",
          "snippet": "char *lxc_string_replace(const char *needle, const char *replacement, const char *haystack)\n{\n\tssize_t len = -1, saved_len = -1;\n\tchar *result = NULL;\n\tsize_t replacement_len = strlen(replacement);\n\tsize_t needle_len = strlen(needle);\n\n\t/* should be executed exactly twice */\n\twhile (len == -1 || result == NULL) {\n\t\tchar *p;\n\t\tchar *last_p;\n\t\tssize_t part_len;\n\n\t\tif (len != -1) {\n\t\t\tresult = calloc(1, len + 1);\n\t\t\tif (!result)\n\t\t\t\treturn NULL;\n\t\t\tsaved_len = len;\n\t\t}\n\n\t\tlen = 0;\n\n\t\tfor (last_p = (char *)haystack, p = strstr(last_p, needle); p; last_p = p, p = strstr(last_p, needle)) {\n\t\t\tpart_len = (ssize_t)(p - last_p);\n\t\t\tif (result && part_len > 0)\n\t\t\t\tmemcpy(&result[len], last_p, part_len);\n\t\t\tlen += part_len;\n\t\t\tif (result && replacement_len > 0)\n\t\t\t\tmemcpy(&result[len], replacement, replacement_len);\n\t\t\tlen += replacement_len;\n\t\t\tp += needle_len;\n\t\t}\n\t\tpart_len = strlen(last_p);\n\t\tif (result && part_len > 0)\n\t\t\tmemcpy(&result[len], last_p, part_len);\n\t\tlen += part_len;\n\t}\n\n\t/* make sure we did the same thing twice,\n\t * once for calculating length, the other\n\t * time for copying data */\n\tif (saved_len != len) {\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\t/* make sure we didn't overwrite any buffer,\n\t * due to calloc the string should be 0-terminated */\n\tif (result[len] != '\\0') {\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *lxc_string_replace(const char *needle, const char *replacement, const char *haystack)\n{\n\tssize_t len = -1, saved_len = -1;\n\tchar *result = NULL;\n\tsize_t replacement_len = strlen(replacement);\n\tsize_t needle_len = strlen(needle);\n\n\t/* should be executed exactly twice */\n\twhile (len == -1 || result == NULL) {\n\t\tchar *p;\n\t\tchar *last_p;\n\t\tssize_t part_len;\n\n\t\tif (len != -1) {\n\t\t\tresult = calloc(1, len + 1);\n\t\t\tif (!result)\n\t\t\t\treturn NULL;\n\t\t\tsaved_len = len;\n\t\t}\n\n\t\tlen = 0;\n\n\t\tfor (last_p = (char *)haystack, p = strstr(last_p, needle); p; last_p = p, p = strstr(last_p, needle)) {\n\t\t\tpart_len = (ssize_t)(p - last_p);\n\t\t\tif (result && part_len > 0)\n\t\t\t\tmemcpy(&result[len], last_p, part_len);\n\t\t\tlen += part_len;\n\t\t\tif (result && replacement_len > 0)\n\t\t\t\tmemcpy(&result[len], replacement, replacement_len);\n\t\t\tlen += replacement_len;\n\t\t\tp += needle_len;\n\t\t}\n\t\tpart_len = strlen(last_p);\n\t\tif (result && part_len > 0)\n\t\t\tmemcpy(&result[len], last_p, part_len);\n\t\tlen += part_len;\n\t}\n\n\t/* make sure we did the same thing twice,\n\t * once for calculating length, the other\n\t * time for copying data */\n\tif (saved_len != len) {\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\t/* make sure we didn't overwrite any buffer,\n\t * due to calloc the string should be 0-terminated */\n\tif (result[len] != '\\0') {\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "result",
            "0",
            "MAXPATHLEN"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic inline bool cgm_create(void *hdata)\n{\n\tstruct cgm_data *d = hdata;\n\tchar **slist = subsystems;\n\tint i, index=0, baselen, ret;\n\tint32_t existed;\n\tchar result[MAXPATHLEN], *tmp, *cgroup_path;\n\n\tif (!d)\n\t\treturn false;\n// XXX we should send a hint to the cgmanager that when these\n// cgroups become empty they should be deleted.  Requires a cgmanager\n// extension\n\n\tmemset(result, 0, MAXPATHLEN);\n\ttmp = lxc_string_replace(\"%n\", d->name, d->cgroup_pattern);\n\tif (!tmp)\n\t\tgoto bad;\n\tif (strlen(tmp) >= MAXPATHLEN) {\n\t\tfree(tmp);\n\t\tgoto bad;\n\t}\n\tstrcpy(result, tmp);\n\tbaselen = strlen(result);\n\tfree(tmp);\n\ttmp = result;\n\twhile (*tmp == '/')\n\t\ttmp++;\nagain:\n\tif (index == 100) { // turn this into a warn later\n\t\tERROR(\"cgroup error?  100 cgroups with this name already running\");\n\t\tgoto bad;\n\t}\n\tif (index) {\n\t\tret = snprintf(result+baselen, MAXPATHLEN-baselen, \"-%d\", index);\n\t\tif (ret < 0 || ret >= MAXPATHLEN-baselen)\n\t\t\tgoto bad;\n\t}\n\texisted = 0;\n\n\tif (cgm_all_controllers_same)\n\t\tslist = subsystems_inone;\n\n\tfor (i = 0; slist[i]; i++) {\n\t\tif (!lxc_cgmanager_create(slist[i], tmp, &existed)) {\n\t\t\tERROR(\"Error creating cgroup %s:%s\", slist[i], result);\n\t\t\tcleanup_cgroups(tmp);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (existed == 1)\n\t\t\tgoto next;\n\t}\n\t// success\n\tcgroup_path = strdup(tmp);\n\tif (!cgroup_path) {\n\t\tcleanup_cgroups(tmp);\n\t\tgoto bad;\n\t}\n\td->cgroup_path = cgroup_path;\n\tcgm_dbus_disconnect();\n\treturn true;\n\nnext:\n\tindex++;\n\tgoto again;\nbad:\n\tcgm_dbus_disconnect();\n\treturn false;\n}"
  },
  {
    "function_name": "cleanup_cgroups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "601-610",
    "snippet": "static inline void cleanup_cgroups(char *path)\n{\n\tint i;\n\tchar **slist = subsystems;\n\n\tif (cgm_all_controllers_same)\n\t\tslist = subsystems_inone;\n\tfor (i = 0; slist[i]; i++)\n\t\tcgm_remove_cgroup(slist[i], path);\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgm_remove_cgroup",
          "args": [
            "slist[i]",
            "path"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_remove_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "527-540",
          "snippet": "static void cgm_remove_cgroup(const char *controller, const char *path)\n{\n\tint existed;\n\tif ( cgmanager_remove_sync(NULL, cgroup_manager, controller,\n\t\t\t\t   path, CG_REMOVE_RECURSIVE, &existed) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_remove_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Error removing %s:%s\", controller, path);\n\t}\n\tif (existed == -1)\n\t\tINFO(\"cgroup removal attempt: %s:%s did not exist\", controller, path);\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CG_REMOVE_RECURSIVE 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define CG_REMOVE_RECURSIVE 1\n\nstatic void cgm_remove_cgroup(const char *controller, const char *path)\n{\n\tint existed;\n\tif ( cgmanager_remove_sync(NULL, cgroup_manager, controller,\n\t\t\t\t   path, CG_REMOVE_RECURSIVE, &existed) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_remove_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Error removing %s:%s\", controller, path);\n\t}\n\tif (existed == -1)\n\t\tINFO(\"cgroup removal attempt: %s:%s did not exist\", controller, path);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic inline void cleanup_cgroups(char *path)\n{\n\tint i;\n\tchar **slist = subsystems;\n\n\tif (cgm_all_controllers_same)\n\t\tslist = subsystems_inone;\n\tfor (i = 0; slist[i]; i++)\n\t\tcgm_remove_cgroup(slist[i], path);\n}"
  },
  {
    "function_name": "cgm_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "573-595",
    "snippet": "static void cgm_destroy(void *hdata, struct lxc_conf *conf)\n{\n\tstruct cgm_data *d = hdata;\n\tchar **slist = subsystems;\n\tint i;\n\n\tif (!d || !d->cgroup_path)\n\t\treturn;\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn;\n\t}\n\n\tif (cgm_all_controllers_same)\n\t\tslist = subsystems_inone;\n\tfor (i = 0; slist[i]; i++)\n\t\tcgm_remove_cgroup(slist[i], d->cgroup_path);\n\n\tfree(d->name);\n\tfree(d->cgroup_path);\n\tfree(d);\n\tcgm_dbus_disconnect();\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgm_dbus_disconnect",
          "args": [],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_dbus_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "123-132",
          "snippet": "static void cgm_dbus_disconnect(void)\n{\n\tif (cgroup_manager) {\n\t\tdbus_connection_flush(cgroup_manager->connection);\n\t\tdbus_connection_close(cgroup_manager->connection);\n\t\tnih_free(cgroup_manager);\n\t}\n\tcgroup_manager = NULL;\n\tcgm_unlock();\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void cgm_dbus_disconnect(void)\n{\n\tif (cgroup_manager) {\n\t\tdbus_connection_flush(cgroup_manager->connection);\n\t\tdbus_connection_close(cgroup_manager->connection);\n\t\tnih_free(cgroup_manager);\n\t}\n\tcgroup_manager = NULL;\n\tcgm_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "d"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "1451-1474",
          "snippet": "static bool cgm_unfreeze(void *hdata)\n{\n\tstruct cgm_data *d = hdata;\n\tbool ret = true;\n\n\tif (!d || !d->cgroup_path)\n\t\treturn false;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\tif (cgmanager_set_value_sync(NULL, cgroup_manager, \"freezer\", d->cgroup_path,\n\t\t\t\"freezer.state\", \"THAWED\") != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_set_value_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Error unfreezing %s\", d->cgroup_path);\n\t\tret = false;\n\t}\n\tcgm_dbus_disconnect();\n\treturn ret;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgm_unfreeze(void *hdata)\n{\n\tstruct cgm_data *d = hdata;\n\tbool ret = true;\n\n\tif (!d || !d->cgroup_path)\n\t\treturn false;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\tif (cgmanager_set_value_sync(NULL, cgroup_manager, \"freezer\", d->cgroup_path,\n\t\t\t\"freezer.state\", \"THAWED\") != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_set_value_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Error unfreezing %s\", d->cgroup_path);\n\t\tret = false;\n\t}\n\tcgm_dbus_disconnect();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgm_remove_cgroup",
          "args": [
            "slist[i]",
            "d->cgroup_path"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_remove_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "527-540",
          "snippet": "static void cgm_remove_cgroup(const char *controller, const char *path)\n{\n\tint existed;\n\tif ( cgmanager_remove_sync(NULL, cgroup_manager, controller,\n\t\t\t\t   path, CG_REMOVE_RECURSIVE, &existed) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_remove_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Error removing %s:%s\", controller, path);\n\t}\n\tif (existed == -1)\n\t\tINFO(\"cgroup removal attempt: %s:%s did not exist\", controller, path);\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CG_REMOVE_RECURSIVE 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define CG_REMOVE_RECURSIVE 1\n\nstatic void cgm_remove_cgroup(const char *controller, const char *path)\n{\n\tint existed;\n\tif ( cgmanager_remove_sync(NULL, cgroup_manager, controller,\n\t\t\t\t   path, CG_REMOVE_RECURSIVE, &existed) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_remove_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Error removing %s:%s\", controller, path);\n\t}\n\tif (existed == -1)\n\t\tINFO(\"cgroup removal attempt: %s:%s did not exist\", controller, path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error connecting to cgroup manager\""
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgm_dbus_connect",
          "args": [],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_dbus_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "135-184",
          "snippet": "static bool cgm_dbus_connect(void)\n{\n\tDBusError dbus_error;\n\tstatic DBusConnection *connection;\n\n\tcgm_lock();\n\tif (!dbus_threads_initialized) {\n\t\t// tell dbus to do struct locking for thread safety\n\t\tdbus_threads_init_default();\n\t\tdbus_threads_initialized = true;\n\t}\n\n\tdbus_error_init(&dbus_error);\n\n\tconnection = dbus_connection_open_private(CGMANAGER_DBUS_SOCK, &dbus_error);\n\tif (!connection) {\n\t\tDEBUG(\"Failed opening dbus connection: %s: %s\",\n\t\t\t\tdbus_error.name, dbus_error.message);\n\t\tdbus_error_free(&dbus_error);\n\t\tcgm_unlock();\n\t\treturn false;\n\t}\n\tdbus_connection_set_exit_on_disconnect(connection, FALSE);\n\tdbus_error_free(&dbus_error);\n\tcgroup_manager = nih_dbus_proxy_new(NULL, connection,\n\t\t\t\tNULL /* p2p */,\n\t\t\t\t\"/org/linuxcontainers/cgmanager\", NULL, NULL);\n\tdbus_connection_unref(connection);\n\tif (!cgroup_manager) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error opening cgmanager proxy: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\n\t// get the api version\n\tif (cgmanager_get_api_version_sync(NULL, cgroup_manager, &api_version) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error cgroup manager api version: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\tif (api_version < CGM_SUPPORTS_NAMED)\n\t\tcull_user_controllers();\n\treturn true;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CGMANAGER_DBUS_SOCK \"unix:path=/sys/fs/cgroup/cgmanager/sock\"",
            "#define CGM_SUPPORTS_NAMED 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define CGMANAGER_DBUS_SOCK \"unix:path=/sys/fs/cgroup/cgmanager/sock\"\n#define CGM_SUPPORTS_NAMED 4\n\nstatic bool cgm_dbus_connect(void)\n{\n\tDBusError dbus_error;\n\tstatic DBusConnection *connection;\n\n\tcgm_lock();\n\tif (!dbus_threads_initialized) {\n\t\t// tell dbus to do struct locking for thread safety\n\t\tdbus_threads_init_default();\n\t\tdbus_threads_initialized = true;\n\t}\n\n\tdbus_error_init(&dbus_error);\n\n\tconnection = dbus_connection_open_private(CGMANAGER_DBUS_SOCK, &dbus_error);\n\tif (!connection) {\n\t\tDEBUG(\"Failed opening dbus connection: %s: %s\",\n\t\t\t\tdbus_error.name, dbus_error.message);\n\t\tdbus_error_free(&dbus_error);\n\t\tcgm_unlock();\n\t\treturn false;\n\t}\n\tdbus_connection_set_exit_on_disconnect(connection, FALSE);\n\tdbus_error_free(&dbus_error);\n\tcgroup_manager = nih_dbus_proxy_new(NULL, connection,\n\t\t\t\tNULL /* p2p */,\n\t\t\t\t\"/org/linuxcontainers/cgmanager\", NULL, NULL);\n\tdbus_connection_unref(connection);\n\tif (!cgroup_manager) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error opening cgmanager proxy: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\n\t// get the api version\n\tif (cgmanager_get_api_version_sync(NULL, cgroup_manager, &api_version) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error cgroup manager api version: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\tif (api_version < CGM_SUPPORTS_NAMED)\n\t\tcull_user_controllers();\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void cgm_destroy(void *hdata, struct lxc_conf *conf)\n{\n\tstruct cgm_data *d = hdata;\n\tchar **slist = subsystems;\n\tint i;\n\n\tif (!d || !d->cgroup_path)\n\t\treturn;\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn;\n\t}\n\n\tif (cgm_all_controllers_same)\n\t\tslist = subsystems_inone;\n\tfor (i = 0; slist[i]; i++)\n\t\tcgm_remove_cgroup(slist[i], d->cgroup_path);\n\n\tfree(d->name);\n\tfree(d->cgroup_path);\n\tfree(d);\n\tcgm_dbus_disconnect();\n}"
  },
  {
    "function_name": "cgm_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "542-570",
    "snippet": "static void *cgm_init(const char *name)\n{\n\tstruct cgm_data *d;\n\n\td = malloc(sizeof(*d));\n\tif (!d)\n\t\treturn NULL;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\tgoto err1;\n\t}\n\n\tmemset(d, 0, sizeof(*d));\n\td->name = strdup(name);\n\tif (!d->name) {\n\t\tcgm_dbus_disconnect();\n\t\tgoto err1;\n\t}\n\n\td->cgroup_pattern = lxc_global_config_value(\"lxc.cgroup.pattern\");\n\n\t// cgm_create immediately gets called so keep the connection open\n\treturn d;\n\nerr1:\n\tfree(d);\n\treturn NULL;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "d"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "1451-1474",
          "snippet": "static bool cgm_unfreeze(void *hdata)\n{\n\tstruct cgm_data *d = hdata;\n\tbool ret = true;\n\n\tif (!d || !d->cgroup_path)\n\t\treturn false;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\tif (cgmanager_set_value_sync(NULL, cgroup_manager, \"freezer\", d->cgroup_path,\n\t\t\t\"freezer.state\", \"THAWED\") != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_set_value_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Error unfreezing %s\", d->cgroup_path);\n\t\tret = false;\n\t}\n\tcgm_dbus_disconnect();\n\treturn ret;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgm_unfreeze(void *hdata)\n{\n\tstruct cgm_data *d = hdata;\n\tbool ret = true;\n\n\tif (!d || !d->cgroup_path)\n\t\treturn false;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\tif (cgmanager_set_value_sync(NULL, cgroup_manager, \"freezer\", d->cgroup_path,\n\t\t\t\"freezer.state\", \"THAWED\") != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_set_value_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Error unfreezing %s\", d->cgroup_path);\n\t\tret = false;\n\t}\n\tcgm_dbus_disconnect();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_global_config_value",
          "args": [
            "\"lxc.cgroup.pattern\""
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_global_config_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "88-247",
          "snippet": "const char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nconst char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgm_dbus_disconnect",
          "args": [],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_dbus_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "123-132",
          "snippet": "static void cgm_dbus_disconnect(void)\n{\n\tif (cgroup_manager) {\n\t\tdbus_connection_flush(cgroup_manager->connection);\n\t\tdbus_connection_close(cgroup_manager->connection);\n\t\tnih_free(cgroup_manager);\n\t}\n\tcgroup_manager = NULL;\n\tcgm_unlock();\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void cgm_dbus_disconnect(void)\n{\n\tif (cgroup_manager) {\n\t\tdbus_connection_flush(cgroup_manager->connection);\n\t\tdbus_connection_close(cgroup_manager->connection);\n\t\tnih_free(cgroup_manager);\n\t}\n\tcgroup_manager = NULL;\n\tcgm_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "name"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "d",
            "0",
            "sizeof(*d)"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error connecting to cgroup manager\""
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgm_dbus_connect",
          "args": [],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_dbus_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "135-184",
          "snippet": "static bool cgm_dbus_connect(void)\n{\n\tDBusError dbus_error;\n\tstatic DBusConnection *connection;\n\n\tcgm_lock();\n\tif (!dbus_threads_initialized) {\n\t\t// tell dbus to do struct locking for thread safety\n\t\tdbus_threads_init_default();\n\t\tdbus_threads_initialized = true;\n\t}\n\n\tdbus_error_init(&dbus_error);\n\n\tconnection = dbus_connection_open_private(CGMANAGER_DBUS_SOCK, &dbus_error);\n\tif (!connection) {\n\t\tDEBUG(\"Failed opening dbus connection: %s: %s\",\n\t\t\t\tdbus_error.name, dbus_error.message);\n\t\tdbus_error_free(&dbus_error);\n\t\tcgm_unlock();\n\t\treturn false;\n\t}\n\tdbus_connection_set_exit_on_disconnect(connection, FALSE);\n\tdbus_error_free(&dbus_error);\n\tcgroup_manager = nih_dbus_proxy_new(NULL, connection,\n\t\t\t\tNULL /* p2p */,\n\t\t\t\t\"/org/linuxcontainers/cgmanager\", NULL, NULL);\n\tdbus_connection_unref(connection);\n\tif (!cgroup_manager) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error opening cgmanager proxy: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\n\t// get the api version\n\tif (cgmanager_get_api_version_sync(NULL, cgroup_manager, &api_version) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error cgroup manager api version: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\tif (api_version < CGM_SUPPORTS_NAMED)\n\t\tcull_user_controllers();\n\treturn true;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CGMANAGER_DBUS_SOCK \"unix:path=/sys/fs/cgroup/cgmanager/sock\"",
            "#define CGM_SUPPORTS_NAMED 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define CGMANAGER_DBUS_SOCK \"unix:path=/sys/fs/cgroup/cgmanager/sock\"\n#define CGM_SUPPORTS_NAMED 4\n\nstatic bool cgm_dbus_connect(void)\n{\n\tDBusError dbus_error;\n\tstatic DBusConnection *connection;\n\n\tcgm_lock();\n\tif (!dbus_threads_initialized) {\n\t\t// tell dbus to do struct locking for thread safety\n\t\tdbus_threads_init_default();\n\t\tdbus_threads_initialized = true;\n\t}\n\n\tdbus_error_init(&dbus_error);\n\n\tconnection = dbus_connection_open_private(CGMANAGER_DBUS_SOCK, &dbus_error);\n\tif (!connection) {\n\t\tDEBUG(\"Failed opening dbus connection: %s: %s\",\n\t\t\t\tdbus_error.name, dbus_error.message);\n\t\tdbus_error_free(&dbus_error);\n\t\tcgm_unlock();\n\t\treturn false;\n\t}\n\tdbus_connection_set_exit_on_disconnect(connection, FALSE);\n\tdbus_error_free(&dbus_error);\n\tcgroup_manager = nih_dbus_proxy_new(NULL, connection,\n\t\t\t\tNULL /* p2p */,\n\t\t\t\t\"/org/linuxcontainers/cgmanager\", NULL, NULL);\n\tdbus_connection_unref(connection);\n\tif (!cgroup_manager) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error opening cgmanager proxy: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\n\t// get the api version\n\tif (cgmanager_get_api_version_sync(NULL, cgroup_manager, &api_version) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error cgroup manager api version: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\tif (api_version < CGM_SUPPORTS_NAMED)\n\t\tcull_user_controllers();\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*d)"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void *cgm_init(const char *name)\n{\n\tstruct cgm_data *d;\n\n\td = malloc(sizeof(*d));\n\tif (!d)\n\t\treturn NULL;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\tgoto err1;\n\t}\n\n\tmemset(d, 0, sizeof(*d));\n\td->name = strdup(name);\n\tif (!d->name) {\n\t\tcgm_dbus_disconnect();\n\t\tgoto err1;\n\t}\n\n\td->cgroup_pattern = lxc_global_config_value(\"lxc.cgroup.pattern\");\n\n\t// cgm_create immediately gets called so keep the connection open\n\treturn d;\n\nerr1:\n\tfree(d);\n\treturn NULL;\n}"
  },
  {
    "function_name": "cgm_remove_cgroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "527-540",
    "snippet": "static void cgm_remove_cgroup(const char *controller, const char *path)\n{\n\tint existed;\n\tif ( cgmanager_remove_sync(NULL, cgroup_manager, controller,\n\t\t\t\t   path, CG_REMOVE_RECURSIVE, &existed) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_remove_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Error removing %s:%s\", controller, path);\n\t}\n\tif (existed == -1)\n\t\tINFO(\"cgroup removal attempt: %s:%s did not exist\", controller, path);\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define CG_REMOVE_RECURSIVE 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"cgroup removal attempt: %s:%s did not exist\"",
            "controller",
            "path"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error removing %s:%s\"",
            "controller",
            "path"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nih_free",
          "args": [
            "nerr"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"call to cgmanager_remove_sync failed: %s\"",
            "nerr->message"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nih_error_get",
          "args": [],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgmanager_remove_sync",
          "args": [
            "NULL",
            "cgroup_manager",
            "controller",
            "path",
            "CG_REMOVE_RECURSIVE",
            "&existed"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define CG_REMOVE_RECURSIVE 1\n\nstatic void cgm_remove_cgroup(const char *controller, const char *path)\n{\n\tint existed;\n\tif ( cgmanager_remove_sync(NULL, cgroup_manager, controller,\n\t\t\t\t   path, CG_REMOVE_RECURSIVE, &existed) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_remove_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Error removing %s:%s\", controller, path);\n\t}\n\tif (existed == -1)\n\t\tINFO(\"cgroup removal attempt: %s:%s did not exist\", controller, path);\n}"
  },
  {
    "function_name": "chown_cgroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "484-523",
    "snippet": "static bool chown_cgroup(const char *cgroup_path, struct lxc_conf *conf)\n{\n\tstruct chown_data data;\n\tchar **slist = subsystems;\n\tint i;\n\n\tif (lxc_list_empty(&conf->id_map))\n\t\t/* If there's no mapping then we don't need to chown */\n\t\treturn true;\n\n\tdata.cgroup_path = cgroup_path;\n\tdata.origuid = geteuid();\n\n\t/* Unpriv users can't chown it themselves, so chown from\n\t * a child namespace mapping both our own and the target uid\n\t */\n\tif (userns_exec_1(conf, chown_cgroup_wrapper, &data) < 0) {\n\t\tERROR(\"Error requesting cgroup chown in new namespace\");\n\t\treturn false;\n\t}\n\n\t/*\n\t * Now chmod 775 the directory else the container cannot create cgroups.\n\t * This can't be done in the child namespace because it only group-owns\n\t * the cgroup\n\t */\n\tif (cgm_all_controllers_same)\n\t\tslist = subsystems_inone;\n\n\tfor (i = 0; slist[i]; i++) {\n\t\tif (!lxc_cgmanager_chmod(slist[i], cgroup_path, \"\", 0775))\n\t\t\treturn false;\n\t\tif (!lxc_cgmanager_chmod(slist[i], cgroup_path, \"tasks\", 0664))\n\t\t\treturn false;\n\t\tif (!lxc_cgmanager_chmod(slist[i], cgroup_path, \"cgroup.procs\", 0664))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_cgmanager_chmod",
          "args": [
            "slist[i]",
            "cgroup_path",
            "\"cgroup.procs\"",
            "0664"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgmanager_chmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "469-481",
          "snippet": "static bool lxc_cgmanager_chmod(const char *controller,\n\t\tconst char *cgroup_path, const char *file, int mode)\n{\n\tif (cgmanager_chmod_sync(NULL, cgroup_manager, controller,\n\t\t\tcgroup_path, file, mode) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_chmod_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool lxc_cgmanager_chmod(const char *controller,\n\t\tconst char *cgroup_path, const char *file, int mode)\n{\n\tif (cgmanager_chmod_sync(NULL, cgroup_manager, controller,\n\t\t\tcgroup_path, file, mode) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_chmod_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error requesting cgroup chown in new namespace\""
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userns_exec_1",
          "args": [
            "conf",
            "chown_cgroup_wrapper",
            "&data"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "userns_exec_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4435-4487",
          "snippet": "int userns_exec_1(struct lxc_conf *conf, int (*fn)(void *), void *data)\n{\n\tint ret, pid;\n\tstruct userns_fn_data d;\n\tchar c = '1';\n\tint p[2];\n\tstruct lxc_list *idmap;\n\n\tret = pipe(p);\n\tif (ret < 0) {\n\t\tSYSERROR(\"opening pipe\");\n\t\treturn -1;\n\t}\n\td.fn = fn;\n\td.arg = data;\n\td.p[0] = p[0];\n\td.p[1] = p[1];\n\tpid = lxc_clone(run_userns_fn, &d, CLONE_NEWUSER);\n\tif (pid < 0)\n\t\tgoto err;\n\tclose(p[0]);\n\tp[0] = -1;\n\n\tif ((idmap = idmap_add_id(conf, geteuid(), getegid())) == NULL) {\n\t\tERROR(\"Error adding self to container uid/gid map\");\n\t\tgoto err;\n\t}\n\n\tret = lxc_map_ids(idmap, pid);\n\tlxc_free_idmap(idmap);\n\tfree(idmap);\n\tif (ret) {\n\t\tERROR(\"Error setting up child mappings\");\n\t\tgoto err;\n\t}\n\n\t// kick the child\n\tif (write(p[1], &c, 1) != 1) {\n\t\tSYSERROR(\"writing to pipe to child\");\n\t\tgoto err;\n\t}\n\n\tret = wait_for_pid(pid);\n\n\tclose(p[1]);\n\treturn ret;\n\nerr:\n\tif (p[0] != -1)\n\t\tclose(p[0]);\n\tclose(p[1]);\n\treturn -1;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint userns_exec_1(struct lxc_conf *conf, int (*fn)(void *), void *data)\n{\n\tint ret, pid;\n\tstruct userns_fn_data d;\n\tchar c = '1';\n\tint p[2];\n\tstruct lxc_list *idmap;\n\n\tret = pipe(p);\n\tif (ret < 0) {\n\t\tSYSERROR(\"opening pipe\");\n\t\treturn -1;\n\t}\n\td.fn = fn;\n\td.arg = data;\n\td.p[0] = p[0];\n\td.p[1] = p[1];\n\tpid = lxc_clone(run_userns_fn, &d, CLONE_NEWUSER);\n\tif (pid < 0)\n\t\tgoto err;\n\tclose(p[0]);\n\tp[0] = -1;\n\n\tif ((idmap = idmap_add_id(conf, geteuid(), getegid())) == NULL) {\n\t\tERROR(\"Error adding self to container uid/gid map\");\n\t\tgoto err;\n\t}\n\n\tret = lxc_map_ids(idmap, pid);\n\tlxc_free_idmap(idmap);\n\tfree(idmap);\n\tif (ret) {\n\t\tERROR(\"Error setting up child mappings\");\n\t\tgoto err;\n\t}\n\n\t// kick the child\n\tif (write(p[1], &c, 1) != 1) {\n\t\tSYSERROR(\"writing to pipe to child\");\n\t\tgoto err;\n\t}\n\n\tret = wait_for_pid(pid);\n\n\tclose(p[1]);\n\treturn ret;\n\nerr:\n\tif (p[0] != -1)\n\t\tclose(p[0]);\n\tclose(p[1]);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_empty",
          "args": [
            "&conf->id_map"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "94-97",
          "snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool chown_cgroup(const char *cgroup_path, struct lxc_conf *conf)\n{\n\tstruct chown_data data;\n\tchar **slist = subsystems;\n\tint i;\n\n\tif (lxc_list_empty(&conf->id_map))\n\t\t/* If there's no mapping then we don't need to chown */\n\t\treturn true;\n\n\tdata.cgroup_path = cgroup_path;\n\tdata.origuid = geteuid();\n\n\t/* Unpriv users can't chown it themselves, so chown from\n\t * a child namespace mapping both our own and the target uid\n\t */\n\tif (userns_exec_1(conf, chown_cgroup_wrapper, &data) < 0) {\n\t\tERROR(\"Error requesting cgroup chown in new namespace\");\n\t\treturn false;\n\t}\n\n\t/*\n\t * Now chmod 775 the directory else the container cannot create cgroups.\n\t * This can't be done in the child namespace because it only group-owns\n\t * the cgroup\n\t */\n\tif (cgm_all_controllers_same)\n\t\tslist = subsystems_inone;\n\n\tfor (i = 0; slist[i]; i++) {\n\t\tif (!lxc_cgmanager_chmod(slist[i], cgroup_path, \"\", 0775))\n\t\t\treturn false;\n\t\tif (!lxc_cgmanager_chmod(slist[i], cgroup_path, \"tasks\", 0664))\n\t\t\treturn false;\n\t\tif (!lxc_cgmanager_chmod(slist[i], cgroup_path, \"cgroup.procs\", 0664))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "lxc_cgmanager_chmod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "469-481",
    "snippet": "static bool lxc_cgmanager_chmod(const char *controller,\n\t\tconst char *cgroup_path, const char *file, int mode)\n{\n\tif (cgmanager_chmod_sync(NULL, cgroup_manager, controller,\n\t\t\tcgroup_path, file, mode) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_chmod_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nih_free",
          "args": [
            "nerr"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"call to cgmanager_chmod_sync failed: %s\"",
            "nerr->message"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nih_error_get",
          "args": [],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgmanager_chmod_sync",
          "args": [
            "NULL",
            "cgroup_manager",
            "controller",
            "cgroup_path",
            "file",
            "mode"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool lxc_cgmanager_chmod(const char *controller,\n\t\tconst char *cgroup_path, const char *file, int mode)\n{\n\tif (cgmanager_chmod_sync(NULL, cgroup_manager, controller,\n\t\t\tcgroup_path, file, mode) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_chmod_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\treturn false;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "chown_cgroup_wrapper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "432-466",
    "snippet": "static int chown_cgroup_wrapper(void *data)\n{\n\tstruct chown_data *arg = data;\n\tchar **slist = subsystems;\n\tint i, ret = -1;\n\tuid_t destuid;\n\n\tif (setresgid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setgid to 0\");\n\tif (setresuid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setuid to 0\");\n\tif (setgroups(0, NULL) < 0)\n\t\tSYSERROR(\"Failed to clear groups\");\n\tcgm_dbus_disconnect();\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn -1;\n\t}\n\tdestuid = get_ns_uid(arg->origuid);\n\n\tif (cgm_all_controllers_same)\n\t\tslist = subsystems_inone;\n\n\tfor (i = 0; slist[i]; i++) {\n\t\tif (do_chown_cgroup(slist[i], arg->cgroup_path, destuid) < 0) {\n\t\t\tERROR(\"Failed to chown %s:%s to container root\",\n\t\t\t\tslist[i], arg->cgroup_path);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tret = 0;\nfail:\n\tcgm_dbus_disconnect();\n\treturn ret;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgm_dbus_disconnect",
          "args": [],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_dbus_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "123-132",
          "snippet": "static void cgm_dbus_disconnect(void)\n{\n\tif (cgroup_manager) {\n\t\tdbus_connection_flush(cgroup_manager->connection);\n\t\tdbus_connection_close(cgroup_manager->connection);\n\t\tnih_free(cgroup_manager);\n\t}\n\tcgroup_manager = NULL;\n\tcgm_unlock();\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void cgm_dbus_disconnect(void)\n{\n\tif (cgroup_manager) {\n\t\tdbus_connection_flush(cgroup_manager->connection);\n\t\tdbus_connection_close(cgroup_manager->connection);\n\t\tnih_free(cgroup_manager);\n\t}\n\tcgroup_manager = NULL;\n\tcgm_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to chown %s:%s to container root\"",
            "slist[i]",
            "arg->cgroup_path"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_chown_cgroup",
          "args": [
            "slist[i]",
            "arg->cgroup_path",
            "destuid"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "do_chown_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "357-430",
          "snippet": "static int do_chown_cgroup(const char *controller, const char *cgroup_path,\n\t\tuid_t newuid)\n{\n\tint sv[2] = {-1, -1}, optval = 1, ret = -1;\n\tchar buf[1];\n\tstruct pollfd fds;\n\n\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, sv) < 0) {\n\t\tSYSERROR(\"Error creating socketpair\");\n\t\tgoto out;\n\t}\n\tif (setsockopt(sv[1], SOL_SOCKET, SO_PASSCRED, &optval, sizeof(optval)) == -1) {\n\t\tSYSERROR(\"setsockopt failed\");\n\t\tgoto out;\n\t}\n\tif (setsockopt(sv[0], SOL_SOCKET, SO_PASSCRED, &optval, sizeof(optval)) == -1) {\n\t\tSYSERROR(\"setsockopt failed\");\n\t\tgoto out;\n\t}\n\tif ( cgmanager_chown_scm_sync(NULL, cgroup_manager, controller,\n\t\t\t\t       cgroup_path, sv[1]) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_chown_scm_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tgoto out;\n\t}\n\t/* now send credentials */\n\n\tfds.fd = sv[0];\n\tfds.events = POLLIN;\n\tfds.revents = 0;\n\tif (poll(&fds, 1, -1) <= 0) {\n\t\tERROR(\"Error getting go-ahead from server: %s\", strerror(errno));\n\t\tgoto out;\n\t}\n\tif (read(sv[0], &buf, 1) != 1) {\n\t\tERROR(\"Error getting reply from server over socketpair\");\n\t\tgoto out;\n\t}\n\tif (send_creds(sv[0], getpid(), getuid(), getgid())) {\n\t\tSYSERROR(\"%s: Error sending pid over SCM_CREDENTIAL\", __func__);\n\t\tgoto out;\n\t}\n\tfds.fd = sv[0];\n\tfds.events = POLLIN;\n\tfds.revents = 0;\n\tif (poll(&fds, 1, -1) <= 0) {\n\t\tERROR(\"Error getting go-ahead from server: %s\", strerror(errno));\n\t\tgoto out;\n\t}\n\tif (read(sv[0], &buf, 1) != 1) {\n\t\tERROR(\"Error getting reply from server over socketpair\");\n\t\tgoto out;\n\t}\n\tif (send_creds(sv[0], getpid(), newuid, 0)) {\n\t\tSYSERROR(\"%s: Error sending pid over SCM_CREDENTIAL\", __func__);\n\t\tgoto out;\n\t}\n\tfds.fd = sv[0];\n\tfds.events = POLLIN;\n\tfds.revents = 0;\n\tif (poll(&fds, 1, -1) <= 0) {\n\t\tERROR(\"Error getting go-ahead from server: %s\", strerror(errno));\n\t\tgoto out;\n\t}\n\tret = read(sv[0], buf, 1);\nout:\n\tclose(sv[0]);\n\tclose(sv[1]);\n\tif (ret == 1 && *buf == '1')\n\t\treturn 0;\n\treturn -1;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int do_chown_cgroup(const char *controller, const char *cgroup_path,\n\t\tuid_t newuid)\n{\n\tint sv[2] = {-1, -1}, optval = 1, ret = -1;\n\tchar buf[1];\n\tstruct pollfd fds;\n\n\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, sv) < 0) {\n\t\tSYSERROR(\"Error creating socketpair\");\n\t\tgoto out;\n\t}\n\tif (setsockopt(sv[1], SOL_SOCKET, SO_PASSCRED, &optval, sizeof(optval)) == -1) {\n\t\tSYSERROR(\"setsockopt failed\");\n\t\tgoto out;\n\t}\n\tif (setsockopt(sv[0], SOL_SOCKET, SO_PASSCRED, &optval, sizeof(optval)) == -1) {\n\t\tSYSERROR(\"setsockopt failed\");\n\t\tgoto out;\n\t}\n\tif ( cgmanager_chown_scm_sync(NULL, cgroup_manager, controller,\n\t\t\t\t       cgroup_path, sv[1]) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_chown_scm_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tgoto out;\n\t}\n\t/* now send credentials */\n\n\tfds.fd = sv[0];\n\tfds.events = POLLIN;\n\tfds.revents = 0;\n\tif (poll(&fds, 1, -1) <= 0) {\n\t\tERROR(\"Error getting go-ahead from server: %s\", strerror(errno));\n\t\tgoto out;\n\t}\n\tif (read(sv[0], &buf, 1) != 1) {\n\t\tERROR(\"Error getting reply from server over socketpair\");\n\t\tgoto out;\n\t}\n\tif (send_creds(sv[0], getpid(), getuid(), getgid())) {\n\t\tSYSERROR(\"%s: Error sending pid over SCM_CREDENTIAL\", __func__);\n\t\tgoto out;\n\t}\n\tfds.fd = sv[0];\n\tfds.events = POLLIN;\n\tfds.revents = 0;\n\tif (poll(&fds, 1, -1) <= 0) {\n\t\tERROR(\"Error getting go-ahead from server: %s\", strerror(errno));\n\t\tgoto out;\n\t}\n\tif (read(sv[0], &buf, 1) != 1) {\n\t\tERROR(\"Error getting reply from server over socketpair\");\n\t\tgoto out;\n\t}\n\tif (send_creds(sv[0], getpid(), newuid, 0)) {\n\t\tSYSERROR(\"%s: Error sending pid over SCM_CREDENTIAL\", __func__);\n\t\tgoto out;\n\t}\n\tfds.fd = sv[0];\n\tfds.events = POLLIN;\n\tfds.revents = 0;\n\tif (poll(&fds, 1, -1) <= 0) {\n\t\tERROR(\"Error getting go-ahead from server: %s\", strerror(errno));\n\t\tgoto out;\n\t}\n\tret = read(sv[0], buf, 1);\nout:\n\tclose(sv[0]);\n\tclose(sv[1]);\n\tif (ret == 1 && *buf == '1')\n\t\treturn 0;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_ns_uid",
          "args": [
            "arg->origuid"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "get_ns_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1034-1057",
          "snippet": "uid_t get_ns_uid(uid_t orig)\n{\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tuid_t nsid, hostid, range;\n\tFILE *f = fopen(\"/proc/self/uid_map\", \"r\");\n\tif (!f)\n\t\treturn 0;\n\n\twhile (getline(&line, &sz, f) != -1) {\n\t\tif (sscanf(line, \"%u %u %u\", &nsid, &hostid, &range) != 3)\n\t\t\tcontinue;\n\t\tif (hostid <= orig && hostid + range > orig) {\n\t\t\tnsid += orig - hostid;\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\tnsid = 0;\nfound:\n\tfclose(f);\n\tfree(line);\n\treturn nsid;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nuid_t get_ns_uid(uid_t orig)\n{\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tuid_t nsid, hostid, range;\n\tFILE *f = fopen(\"/proc/self/uid_map\", \"r\");\n\tif (!f)\n\t\treturn 0;\n\n\twhile (getline(&line, &sz, f) != -1) {\n\t\tif (sscanf(line, \"%u %u %u\", &nsid, &hostid, &range) != 3)\n\t\t\tcontinue;\n\t\tif (hostid <= orig && hostid + range > orig) {\n\t\t\tnsid += orig - hostid;\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\tnsid = 0;\nfound:\n\tfclose(f);\n\tfree(line);\n\treturn nsid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error connecting to cgroup manager\""
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgm_dbus_connect",
          "args": [],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_dbus_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "135-184",
          "snippet": "static bool cgm_dbus_connect(void)\n{\n\tDBusError dbus_error;\n\tstatic DBusConnection *connection;\n\n\tcgm_lock();\n\tif (!dbus_threads_initialized) {\n\t\t// tell dbus to do struct locking for thread safety\n\t\tdbus_threads_init_default();\n\t\tdbus_threads_initialized = true;\n\t}\n\n\tdbus_error_init(&dbus_error);\n\n\tconnection = dbus_connection_open_private(CGMANAGER_DBUS_SOCK, &dbus_error);\n\tif (!connection) {\n\t\tDEBUG(\"Failed opening dbus connection: %s: %s\",\n\t\t\t\tdbus_error.name, dbus_error.message);\n\t\tdbus_error_free(&dbus_error);\n\t\tcgm_unlock();\n\t\treturn false;\n\t}\n\tdbus_connection_set_exit_on_disconnect(connection, FALSE);\n\tdbus_error_free(&dbus_error);\n\tcgroup_manager = nih_dbus_proxy_new(NULL, connection,\n\t\t\t\tNULL /* p2p */,\n\t\t\t\t\"/org/linuxcontainers/cgmanager\", NULL, NULL);\n\tdbus_connection_unref(connection);\n\tif (!cgroup_manager) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error opening cgmanager proxy: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\n\t// get the api version\n\tif (cgmanager_get_api_version_sync(NULL, cgroup_manager, &api_version) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error cgroup manager api version: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\tif (api_version < CGM_SUPPORTS_NAMED)\n\t\tcull_user_controllers();\n\treturn true;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CGMANAGER_DBUS_SOCK \"unix:path=/sys/fs/cgroup/cgmanager/sock\"",
            "#define CGM_SUPPORTS_NAMED 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define CGMANAGER_DBUS_SOCK \"unix:path=/sys/fs/cgroup/cgmanager/sock\"\n#define CGM_SUPPORTS_NAMED 4\n\nstatic bool cgm_dbus_connect(void)\n{\n\tDBusError dbus_error;\n\tstatic DBusConnection *connection;\n\n\tcgm_lock();\n\tif (!dbus_threads_initialized) {\n\t\t// tell dbus to do struct locking for thread safety\n\t\tdbus_threads_init_default();\n\t\tdbus_threads_initialized = true;\n\t}\n\n\tdbus_error_init(&dbus_error);\n\n\tconnection = dbus_connection_open_private(CGMANAGER_DBUS_SOCK, &dbus_error);\n\tif (!connection) {\n\t\tDEBUG(\"Failed opening dbus connection: %s: %s\",\n\t\t\t\tdbus_error.name, dbus_error.message);\n\t\tdbus_error_free(&dbus_error);\n\t\tcgm_unlock();\n\t\treturn false;\n\t}\n\tdbus_connection_set_exit_on_disconnect(connection, FALSE);\n\tdbus_error_free(&dbus_error);\n\tcgroup_manager = nih_dbus_proxy_new(NULL, connection,\n\t\t\t\tNULL /* p2p */,\n\t\t\t\t\"/org/linuxcontainers/cgmanager\", NULL, NULL);\n\tdbus_connection_unref(connection);\n\tif (!cgroup_manager) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error opening cgmanager proxy: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\n\t// get the api version\n\tif (cgmanager_get_api_version_sync(NULL, cgroup_manager, &api_version) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error cgroup manager api version: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\tif (api_version < CGM_SUPPORTS_NAMED)\n\t\tcull_user_controllers();\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to clear groups\""
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setgroups",
          "args": [
            "0",
            "NULL"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_setgroups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "2063-2072",
          "snippet": "int lxc_setgroups(int size, gid_t list[])\n{\n\tif (setgroups(size, list) < 0) {\n\t\tSYSERROR(\"Failed to setgroups().\");\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Dropped additional groups.\");\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_setgroups(int size, gid_t list[])\n{\n\tif (setgroups(size, list) < 0) {\n\t\tSYSERROR(\"Failed to setgroups().\");\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Dropped additional groups.\");\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to setuid to 0\""
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setresuid",
          "args": [
            "0",
            "0",
            "0"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to setgid to 0\""
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setresgid",
          "args": [
            "0",
            "0",
            "0"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int chown_cgroup_wrapper(void *data)\n{\n\tstruct chown_data *arg = data;\n\tchar **slist = subsystems;\n\tint i, ret = -1;\n\tuid_t destuid;\n\n\tif (setresgid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setgid to 0\");\n\tif (setresuid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setuid to 0\");\n\tif (setgroups(0, NULL) < 0)\n\t\tSYSERROR(\"Failed to clear groups\");\n\tcgm_dbus_disconnect();\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn -1;\n\t}\n\tdestuid = get_ns_uid(arg->origuid);\n\n\tif (cgm_all_controllers_same)\n\t\tslist = subsystems_inone;\n\n\tfor (i = 0; slist[i]; i++) {\n\t\tif (do_chown_cgroup(slist[i], arg->cgroup_path, destuid) < 0) {\n\t\t\tERROR(\"Failed to chown %s:%s to container root\",\n\t\t\t\tslist[i], arg->cgroup_path);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tret = 0;\nfail:\n\tcgm_dbus_disconnect();\n\treturn ret;\n}"
  },
  {
    "function_name": "do_chown_cgroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "357-430",
    "snippet": "static int do_chown_cgroup(const char *controller, const char *cgroup_path,\n\t\tuid_t newuid)\n{\n\tint sv[2] = {-1, -1}, optval = 1, ret = -1;\n\tchar buf[1];\n\tstruct pollfd fds;\n\n\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, sv) < 0) {\n\t\tSYSERROR(\"Error creating socketpair\");\n\t\tgoto out;\n\t}\n\tif (setsockopt(sv[1], SOL_SOCKET, SO_PASSCRED, &optval, sizeof(optval)) == -1) {\n\t\tSYSERROR(\"setsockopt failed\");\n\t\tgoto out;\n\t}\n\tif (setsockopt(sv[0], SOL_SOCKET, SO_PASSCRED, &optval, sizeof(optval)) == -1) {\n\t\tSYSERROR(\"setsockopt failed\");\n\t\tgoto out;\n\t}\n\tif ( cgmanager_chown_scm_sync(NULL, cgroup_manager, controller,\n\t\t\t\t       cgroup_path, sv[1]) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_chown_scm_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tgoto out;\n\t}\n\t/* now send credentials */\n\n\tfds.fd = sv[0];\n\tfds.events = POLLIN;\n\tfds.revents = 0;\n\tif (poll(&fds, 1, -1) <= 0) {\n\t\tERROR(\"Error getting go-ahead from server: %s\", strerror(errno));\n\t\tgoto out;\n\t}\n\tif (read(sv[0], &buf, 1) != 1) {\n\t\tERROR(\"Error getting reply from server over socketpair\");\n\t\tgoto out;\n\t}\n\tif (send_creds(sv[0], getpid(), getuid(), getgid())) {\n\t\tSYSERROR(\"%s: Error sending pid over SCM_CREDENTIAL\", __func__);\n\t\tgoto out;\n\t}\n\tfds.fd = sv[0];\n\tfds.events = POLLIN;\n\tfds.revents = 0;\n\tif (poll(&fds, 1, -1) <= 0) {\n\t\tERROR(\"Error getting go-ahead from server: %s\", strerror(errno));\n\t\tgoto out;\n\t}\n\tif (read(sv[0], &buf, 1) != 1) {\n\t\tERROR(\"Error getting reply from server over socketpair\");\n\t\tgoto out;\n\t}\n\tif (send_creds(sv[0], getpid(), newuid, 0)) {\n\t\tSYSERROR(\"%s: Error sending pid over SCM_CREDENTIAL\", __func__);\n\t\tgoto out;\n\t}\n\tfds.fd = sv[0];\n\tfds.events = POLLIN;\n\tfds.revents = 0;\n\tif (poll(&fds, 1, -1) <= 0) {\n\t\tERROR(\"Error getting go-ahead from server: %s\", strerror(errno));\n\t\tgoto out;\n\t}\n\tret = read(sv[0], buf, 1);\nout:\n\tclose(sv[0]);\n\tclose(sv[1]);\n\tif (ret == 1 && *buf == '1')\n\t\treturn 0;\n\treturn -1;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sv[1]"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "sv[0]",
            "buf",
            "1"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_read_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfs.c",
          "lines": "2217-2236",
          "snippet": "static int cgroup_read_from_file(const char *fn, char buf[], size_t bufsize)\n{\n\tint ret = lxc_read_from_file(fn, buf, bufsize);\n\tif (ret < 0) {\n\t\tSYSERROR(\"failed to read %s\", fn);\n\t\treturn ret;\n\t}\n\tif (ret == bufsize) {\n\t\tif (bufsize > 0) {\n\t\t\t/* obviously this wasn't empty */\n\t\t\tbuf[bufsize-1] = '\\0';\n\t\t\treturn ret;\n\t\t}\n\t\t/* Callers don't do this, but regression/sanity check */\n\t\tERROR(\"%s: was not expecting 0 bufsize\", __func__);\n\t\treturn -1;\n\t}\n\tbuf[ret] = '\\0';\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int cgroup_read_from_file(const char *fn, char buf[], size_t bufsize)\n{\n\tint ret = lxc_read_from_file(fn, buf, bufsize);\n\tif (ret < 0) {\n\t\tSYSERROR(\"failed to read %s\", fn);\n\t\treturn ret;\n\t}\n\tif (ret == bufsize) {\n\t\tif (bufsize > 0) {\n\t\t\t/* obviously this wasn't empty */\n\t\t\tbuf[bufsize-1] = '\\0';\n\t\t\treturn ret;\n\t\t}\n\t\t/* Callers don't do this, but regression/sanity check */\n\t\tERROR(\"%s: was not expecting 0 bufsize\", __func__);\n\t\treturn -1;\n\t}\n\tbuf[ret] = '\\0';\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error getting go-ahead from server: %s\"",
            "strerror(errno)"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll",
          "args": [
            "&fds",
            "1",
            "-1"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"%s: Error sending pid over SCM_CREDENTIAL\"",
            "__func__"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_creds",
          "args": [
            "sv[0]",
            "getpid()",
            "newuid",
            "0"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "send_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "245-279",
          "snippet": "static int send_creds(int sock, int rpid, int ruid, int rgid)\n{\n\tstruct msghdr msg = { 0 };\n\tstruct iovec iov;\n\tstruct cmsghdr *cmsg;\n\tstruct ucred cred = {\n\t\t.pid = rpid,\n\t\t.uid = ruid,\n\t\t.gid = rgid,\n\t};\n\tchar cmsgbuf[CMSG_SPACE(sizeof(cred))];\n\tchar buf[1];\n\tbuf[0] = 'p';\n\n\tmsg.msg_control = cmsgbuf;\n\tmsg.msg_controllen = sizeof(cmsgbuf);\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(struct ucred));\n\tcmsg->cmsg_level = SOL_SOCKET;\n\tcmsg->cmsg_type = SCM_CREDENTIALS;\n\tmemcpy(CMSG_DATA(cmsg), &cred, sizeof(cred));\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_namelen = 0;\n\n\tiov.iov_base = buf;\n\tiov.iov_len = sizeof(buf);\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\tif (sendmsg(sock, &msg, 0) < 0)\n\t\treturn -1;\n\treturn 0;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int send_creds(int sock, int rpid, int ruid, int rgid)\n{\n\tstruct msghdr msg = { 0 };\n\tstruct iovec iov;\n\tstruct cmsghdr *cmsg;\n\tstruct ucred cred = {\n\t\t.pid = rpid,\n\t\t.uid = ruid,\n\t\t.gid = rgid,\n\t};\n\tchar cmsgbuf[CMSG_SPACE(sizeof(cred))];\n\tchar buf[1];\n\tbuf[0] = 'p';\n\n\tmsg.msg_control = cmsgbuf;\n\tmsg.msg_controllen = sizeof(cmsgbuf);\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(struct ucred));\n\tcmsg->cmsg_level = SOL_SOCKET;\n\tcmsg->cmsg_type = SCM_CREDENTIALS;\n\tmemcpy(CMSG_DATA(cmsg), &cred, sizeof(cred));\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_namelen = 0;\n\n\tiov.iov_base = buf;\n\tiov.iov_len = sizeof(buf);\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\tif (sendmsg(sock, &msg, 0) < 0)\n\t\treturn -1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error getting reply from server over socketpair\""
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error getting go-ahead from server: %s\"",
            "strerror(errno)"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll",
          "args": [
            "&fds",
            "1",
            "-1"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"%s: Error sending pid over SCM_CREDENTIAL\"",
            "__func__"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error getting reply from server over socketpair\""
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error getting go-ahead from server: %s\"",
            "strerror(errno)"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll",
          "args": [
            "&fds",
            "1",
            "-1"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nih_free",
          "args": [
            "nerr"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"call to cgmanager_chown_scm_sync failed: %s\"",
            "nerr->message"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nih_error_get",
          "args": [],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgmanager_chown_scm_sync",
          "args": [
            "NULL",
            "cgroup_manager",
            "controller",
            "cgroup_path",
            "sv[1]"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"setsockopt failed\""
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "sv[0]",
            "SOL_SOCKET",
            "SO_PASSCRED",
            "&optval",
            "sizeof(optval)"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"setsockopt failed\""
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "sv[1]",
            "SOL_SOCKET",
            "SO_PASSCRED",
            "&optval",
            "sizeof(optval)"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error creating socketpair\""
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socketpair",
          "args": [
            "AF_UNIX",
            "SOCK_DGRAM",
            "0",
            "sv"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int do_chown_cgroup(const char *controller, const char *cgroup_path,\n\t\tuid_t newuid)\n{\n\tint sv[2] = {-1, -1}, optval = 1, ret = -1;\n\tchar buf[1];\n\tstruct pollfd fds;\n\n\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, sv) < 0) {\n\t\tSYSERROR(\"Error creating socketpair\");\n\t\tgoto out;\n\t}\n\tif (setsockopt(sv[1], SOL_SOCKET, SO_PASSCRED, &optval, sizeof(optval)) == -1) {\n\t\tSYSERROR(\"setsockopt failed\");\n\t\tgoto out;\n\t}\n\tif (setsockopt(sv[0], SOL_SOCKET, SO_PASSCRED, &optval, sizeof(optval)) == -1) {\n\t\tSYSERROR(\"setsockopt failed\");\n\t\tgoto out;\n\t}\n\tif ( cgmanager_chown_scm_sync(NULL, cgroup_manager, controller,\n\t\t\t\t       cgroup_path, sv[1]) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_chown_scm_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tgoto out;\n\t}\n\t/* now send credentials */\n\n\tfds.fd = sv[0];\n\tfds.events = POLLIN;\n\tfds.revents = 0;\n\tif (poll(&fds, 1, -1) <= 0) {\n\t\tERROR(\"Error getting go-ahead from server: %s\", strerror(errno));\n\t\tgoto out;\n\t}\n\tif (read(sv[0], &buf, 1) != 1) {\n\t\tERROR(\"Error getting reply from server over socketpair\");\n\t\tgoto out;\n\t}\n\tif (send_creds(sv[0], getpid(), getuid(), getgid())) {\n\t\tSYSERROR(\"%s: Error sending pid over SCM_CREDENTIAL\", __func__);\n\t\tgoto out;\n\t}\n\tfds.fd = sv[0];\n\tfds.events = POLLIN;\n\tfds.revents = 0;\n\tif (poll(&fds, 1, -1) <= 0) {\n\t\tERROR(\"Error getting go-ahead from server: %s\", strerror(errno));\n\t\tgoto out;\n\t}\n\tif (read(sv[0], &buf, 1) != 1) {\n\t\tERROR(\"Error getting reply from server over socketpair\");\n\t\tgoto out;\n\t}\n\tif (send_creds(sv[0], getpid(), newuid, 0)) {\n\t\tSYSERROR(\"%s: Error sending pid over SCM_CREDENTIAL\", __func__);\n\t\tgoto out;\n\t}\n\tfds.fd = sv[0];\n\tfds.events = POLLIN;\n\tfds.revents = 0;\n\tif (poll(&fds, 1, -1) <= 0) {\n\t\tERROR(\"Error getting go-ahead from server: %s\", strerror(errno));\n\t\tgoto out;\n\t}\n\tret = read(sv[0], buf, 1);\nout:\n\tclose(sv[0]);\n\tclose(sv[1]);\n\tif (ret == 1 && *buf == '1')\n\t\treturn 0;\n\treturn -1;\n}"
  },
  {
    "function_name": "cgm_get_hierarchies",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "346-350",
    "snippet": "static bool cgm_get_hierarchies(int i, char ***out)\n{\n\t/* not implemented */\n\treturn false;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgm_get_hierarchies(int i, char ***out)\n{\n\t/* not implemented */\n\treturn false;\n}"
  },
  {
    "function_name": "cgm_num_hierarchies",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "340-344",
    "snippet": "static int cgm_num_hierarchies(void)\n{\n\t/* not implemented */\n\treturn -1;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int cgm_num_hierarchies(void)\n{\n\t/* not implemented */\n\treturn -1;\n}"
  },
  {
    "function_name": "cgm_escape",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "302-338",
    "snippet": "static bool cgm_escape(void *hdata)\n{\n\tbool ret = true, cgm_needs_disconnect = false;\n\tpid_t me = getpid();\n\tchar **slist = subsystems;\n\tint i;\n\n\tif (!cgroup_manager) {\n\t\tif (!cgm_dbus_connect()) {\n\t\t\tERROR(\"Error connecting to cgroup manager\");\n\t\t\treturn false;\n\t\t}\n\t\tcgm_needs_disconnect = true;\n\t}\n\n\n\tif (cgm_all_controllers_same)\n\t\tslist = subsystems_inone;\n\n\tfor (i = 0; slist[i]; i++) {\n\t\tif (cgmanager_move_pid_abs_sync(NULL, cgroup_manager,\n\t\t\t\t\tslist[i], \"/\", me) != 0) {\n\t\t\tNihError *nerr;\n\t\t\tnerr = nih_error_get();\n\t\t\tERROR(\"call to cgmanager_move_pid_abs_sync(%s) failed: %s\",\n\t\t\t\t\tslist[i], nerr->message);\n\t\t\tnih_free(nerr);\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (cgm_needs_disconnect)\n\t\tcgm_dbus_disconnect();\n\n\treturn ret;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgm_dbus_disconnect",
          "args": [],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_dbus_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "123-132",
          "snippet": "static void cgm_dbus_disconnect(void)\n{\n\tif (cgroup_manager) {\n\t\tdbus_connection_flush(cgroup_manager->connection);\n\t\tdbus_connection_close(cgroup_manager->connection);\n\t\tnih_free(cgroup_manager);\n\t}\n\tcgroup_manager = NULL;\n\tcgm_unlock();\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void cgm_dbus_disconnect(void)\n{\n\tif (cgroup_manager) {\n\t\tdbus_connection_flush(cgroup_manager->connection);\n\t\tdbus_connection_close(cgroup_manager->connection);\n\t\tnih_free(cgroup_manager);\n\t}\n\tcgroup_manager = NULL;\n\tcgm_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "nih_free",
          "args": [
            "nerr"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"call to cgmanager_move_pid_abs_sync(%s) failed: %s\"",
            "slist[i]",
            "nerr->message"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nih_error_get",
          "args": [],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgmanager_move_pid_abs_sync",
          "args": [
            "NULL",
            "cgroup_manager",
            "slist[i]",
            "\"/\"",
            "me"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error connecting to cgroup manager\""
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgm_dbus_connect",
          "args": [],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_dbus_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "135-184",
          "snippet": "static bool cgm_dbus_connect(void)\n{\n\tDBusError dbus_error;\n\tstatic DBusConnection *connection;\n\n\tcgm_lock();\n\tif (!dbus_threads_initialized) {\n\t\t// tell dbus to do struct locking for thread safety\n\t\tdbus_threads_init_default();\n\t\tdbus_threads_initialized = true;\n\t}\n\n\tdbus_error_init(&dbus_error);\n\n\tconnection = dbus_connection_open_private(CGMANAGER_DBUS_SOCK, &dbus_error);\n\tif (!connection) {\n\t\tDEBUG(\"Failed opening dbus connection: %s: %s\",\n\t\t\t\tdbus_error.name, dbus_error.message);\n\t\tdbus_error_free(&dbus_error);\n\t\tcgm_unlock();\n\t\treturn false;\n\t}\n\tdbus_connection_set_exit_on_disconnect(connection, FALSE);\n\tdbus_error_free(&dbus_error);\n\tcgroup_manager = nih_dbus_proxy_new(NULL, connection,\n\t\t\t\tNULL /* p2p */,\n\t\t\t\t\"/org/linuxcontainers/cgmanager\", NULL, NULL);\n\tdbus_connection_unref(connection);\n\tif (!cgroup_manager) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error opening cgmanager proxy: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\n\t// get the api version\n\tif (cgmanager_get_api_version_sync(NULL, cgroup_manager, &api_version) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error cgroup manager api version: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\tif (api_version < CGM_SUPPORTS_NAMED)\n\t\tcull_user_controllers();\n\treturn true;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CGMANAGER_DBUS_SOCK \"unix:path=/sys/fs/cgroup/cgmanager/sock\"",
            "#define CGM_SUPPORTS_NAMED 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define CGMANAGER_DBUS_SOCK \"unix:path=/sys/fs/cgroup/cgmanager/sock\"\n#define CGM_SUPPORTS_NAMED 4\n\nstatic bool cgm_dbus_connect(void)\n{\n\tDBusError dbus_error;\n\tstatic DBusConnection *connection;\n\n\tcgm_lock();\n\tif (!dbus_threads_initialized) {\n\t\t// tell dbus to do struct locking for thread safety\n\t\tdbus_threads_init_default();\n\t\tdbus_threads_initialized = true;\n\t}\n\n\tdbus_error_init(&dbus_error);\n\n\tconnection = dbus_connection_open_private(CGMANAGER_DBUS_SOCK, &dbus_error);\n\tif (!connection) {\n\t\tDEBUG(\"Failed opening dbus connection: %s: %s\",\n\t\t\t\tdbus_error.name, dbus_error.message);\n\t\tdbus_error_free(&dbus_error);\n\t\tcgm_unlock();\n\t\treturn false;\n\t}\n\tdbus_connection_set_exit_on_disconnect(connection, FALSE);\n\tdbus_error_free(&dbus_error);\n\tcgroup_manager = nih_dbus_proxy_new(NULL, connection,\n\t\t\t\tNULL /* p2p */,\n\t\t\t\t\"/org/linuxcontainers/cgmanager\", NULL, NULL);\n\tdbus_connection_unref(connection);\n\tif (!cgroup_manager) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error opening cgmanager proxy: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\n\t// get the api version\n\tif (cgmanager_get_api_version_sync(NULL, cgroup_manager, &api_version) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error cgroup manager api version: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\tif (api_version < CGM_SUPPORTS_NAMED)\n\t\tcull_user_controllers();\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgm_escape(void *hdata)\n{\n\tbool ret = true, cgm_needs_disconnect = false;\n\tpid_t me = getpid();\n\tchar **slist = subsystems;\n\tint i;\n\n\tif (!cgroup_manager) {\n\t\tif (!cgm_dbus_connect()) {\n\t\t\tERROR(\"Error connecting to cgroup manager\");\n\t\t\treturn false;\n\t\t}\n\t\tcgm_needs_disconnect = true;\n\t}\n\n\n\tif (cgm_all_controllers_same)\n\t\tslist = subsystems_inone;\n\n\tfor (i = 0; slist[i]; i++) {\n\t\tif (cgmanager_move_pid_abs_sync(NULL, cgroup_manager,\n\t\t\t\t\tslist[i], \"/\", me) != 0) {\n\t\t\tNihError *nerr;\n\t\t\tnerr = nih_error_get();\n\t\t\tERROR(\"call to cgmanager_move_pid_abs_sync(%s) failed: %s\",\n\t\t\t\t\tslist[i], nerr->message);\n\t\t\tnih_free(nerr);\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (cgm_needs_disconnect)\n\t\tcgm_dbus_disconnect();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "lxc_cgmanager_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "281-295",
    "snippet": "static bool lxc_cgmanager_create(const char *controller, const char *cgroup_path, int32_t *existed)\n{\n\tbool ret = true;\n\tif ( cgmanager_create_sync(NULL, cgroup_manager, controller,\n\t\t\t\t       cgroup_path, existed) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_create_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Failed to create %s:%s\", controller, cgroup_path);\n\t\tret = false;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to create %s:%s\"",
            "controller",
            "cgroup_path"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nih_free",
          "args": [
            "nerr"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"call to cgmanager_create_sync failed: %s\"",
            "nerr->message"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nih_error_get",
          "args": [],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgmanager_create_sync",
          "args": [
            "NULL",
            "cgroup_manager",
            "controller",
            "cgroup_path",
            "existed"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool lxc_cgmanager_create(const char *controller, const char *cgroup_path, int32_t *existed)\n{\n\tbool ret = true;\n\tif ( cgmanager_create_sync(NULL, cgroup_manager, controller,\n\t\t\t\t       cgroup_path, existed) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_create_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Failed to create %s:%s\", controller, cgroup_path);\n\t\tret = false;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "send_creds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "245-279",
    "snippet": "static int send_creds(int sock, int rpid, int ruid, int rgid)\n{\n\tstruct msghdr msg = { 0 };\n\tstruct iovec iov;\n\tstruct cmsghdr *cmsg;\n\tstruct ucred cred = {\n\t\t.pid = rpid,\n\t\t.uid = ruid,\n\t\t.gid = rgid,\n\t};\n\tchar cmsgbuf[CMSG_SPACE(sizeof(cred))];\n\tchar buf[1];\n\tbuf[0] = 'p';\n\n\tmsg.msg_control = cmsgbuf;\n\tmsg.msg_controllen = sizeof(cmsgbuf);\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(struct ucred));\n\tcmsg->cmsg_level = SOL_SOCKET;\n\tcmsg->cmsg_type = SCM_CREDENTIALS;\n\tmemcpy(CMSG_DATA(cmsg), &cred, sizeof(cred));\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_namelen = 0;\n\n\tiov.iov_base = buf;\n\tiov.iov_len = sizeof(buf);\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\tif (sendmsg(sock, &msg, 0) < 0)\n\t\treturn -1;\n\treturn 0;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sendmsg",
          "args": [
            "sock",
            "&msg",
            "0"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "CMSG_DATA(cmsg)",
            "&cred",
            "sizeof(cred)"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_DATA",
          "args": [
            "cmsg"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_LEN",
          "args": [
            "sizeof(struct ucred)"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_FIRSTHDR",
          "args": [
            "&msg"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_SPACE",
          "args": [
            "sizeof(cred)"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int send_creds(int sock, int rpid, int ruid, int rgid)\n{\n\tstruct msghdr msg = { 0 };\n\tstruct iovec iov;\n\tstruct cmsghdr *cmsg;\n\tstruct ucred cred = {\n\t\t.pid = rpid,\n\t\t.uid = ruid,\n\t\t.gid = rgid,\n\t};\n\tchar cmsgbuf[CMSG_SPACE(sizeof(cred))];\n\tchar buf[1];\n\tbuf[0] = 'p';\n\n\tmsg.msg_control = cmsgbuf;\n\tmsg.msg_controllen = sizeof(cmsgbuf);\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(struct ucred));\n\tcmsg->cmsg_level = SOL_SOCKET;\n\tcmsg->cmsg_type = SCM_CREDENTIALS;\n\tmemcpy(CMSG_DATA(cmsg), &cred, sizeof(cred));\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_namelen = 0;\n\n\tiov.iov_base = buf;\n\tiov.iov_len = sizeof(buf);\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\tif (sendmsg(sock, &msg, 0) < 0)\n\t\treturn -1;\n\treturn 0;\n}"
  },
  {
    "function_name": "check_supports_multiple_controllers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "198-243",
    "snippet": "static void check_supports_multiple_controllers(pid_t pid)\n{\n\tFILE *f;\n\tchar *line = NULL, *prevpath = NULL;\n\tsize_t sz = 0;\n\tchar path[100];\n\n\tcgm_all_controllers_same = false;\n\n\tif (pid == -1)\n\t\tsprintf(path, \"/proc/self/cgroup\");\n\telse\n\t\tsprintf(path, \"/proc/%d/cgroup\", pid);\n\tf = fopen(path, \"r\");\n\tif (!f)\n\t\treturn;\n\n\tcgm_all_controllers_same = true;\n\n\twhile (getline(&line, &sz, f) != -1) {\n\t\t/* file format: hierarchy:subsystems:group */\n\t\tchar *colon;\n\t\tif (!line[0])\n\t\t\tcontinue;\n\n\t\tcolon = strchr(line, ':');\n\t\tif (!colon)\n\t\t\tcontinue;\n\t\tcolon = strchr(colon+1, ':');\n\t\tif (!colon)\n\t\t\tcontinue;\n\t\tcolon++;\n\t\tif (!prevpath) {\n\t\t\tprevpath = alloca(strlen(colon)+1);\n\t\t\tstrcpy(prevpath, colon);\n\t\t\tcontinue;\n\t\t}\n\t\tif (strcmp(prevpath, colon) != 0) {\n\t\t\tcgm_all_controllers_same = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfclose(f);\n\tfree(line);\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "line"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "1451-1474",
          "snippet": "static bool cgm_unfreeze(void *hdata)\n{\n\tstruct cgm_data *d = hdata;\n\tbool ret = true;\n\n\tif (!d || !d->cgroup_path)\n\t\treturn false;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\tif (cgmanager_set_value_sync(NULL, cgroup_manager, \"freezer\", d->cgroup_path,\n\t\t\t\"freezer.state\", \"THAWED\") != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_set_value_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Error unfreezing %s\", d->cgroup_path);\n\t\tret = false;\n\t}\n\tcgm_dbus_disconnect();\n\treturn ret;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool cgm_unfreeze(void *hdata)\n{\n\tstruct cgm_data *d = hdata;\n\tbool ret = true;\n\n\tif (!d || !d->cgroup_path)\n\t\treturn false;\n\n\tif (!cgm_dbus_connect()) {\n\t\tERROR(\"Error connecting to cgroup manager\");\n\t\treturn false;\n\t}\n\tif (cgmanager_set_value_sync(NULL, cgroup_manager, \"freezer\", d->cgroup_path,\n\t\t\t\"freezer.state\", \"THAWED\") != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_set_value_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tERROR(\"Error unfreezing %s\", d->cgroup_path);\n\t\tret = false;\n\t}\n\tcgm_dbus_disconnect();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "prevpath",
            "colon"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "prevpath",
            "colon"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "strlen(colon)+1"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "colon"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "colon+1",
            "':'"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&line",
            "&sz",
            "f"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getline.c",
          "lines": "39-60",
          "snippet": "ssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "path",
            "\"r\""
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "path",
            "\"/proc/%d/cgroup\"",
            "pid"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "path",
            "\"/proc/self/cgroup\""
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void check_supports_multiple_controllers(pid_t pid)\n{\n\tFILE *f;\n\tchar *line = NULL, *prevpath = NULL;\n\tsize_t sz = 0;\n\tchar path[100];\n\n\tcgm_all_controllers_same = false;\n\n\tif (pid == -1)\n\t\tsprintf(path, \"/proc/self/cgroup\");\n\telse\n\t\tsprintf(path, \"/proc/%d/cgroup\", pid);\n\tf = fopen(path, \"r\");\n\tif (!f)\n\t\treturn;\n\n\tcgm_all_controllers_same = true;\n\n\twhile (getline(&line, &sz, f) != -1) {\n\t\t/* file format: hierarchy:subsystems:group */\n\t\tchar *colon;\n\t\tif (!line[0])\n\t\t\tcontinue;\n\n\t\tcolon = strchr(line, ':');\n\t\tif (!colon)\n\t\t\tcontinue;\n\t\tcolon = strchr(colon+1, ':');\n\t\tif (!colon)\n\t\t\tcontinue;\n\t\tcolon++;\n\t\tif (!prevpath) {\n\t\t\tprevpath = alloca(strlen(colon)+1);\n\t\t\tstrcpy(prevpath, colon);\n\t\t\tcontinue;\n\t\t}\n\t\tif (strcmp(prevpath, colon) != 0) {\n\t\t\tcgm_all_controllers_same = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfclose(f);\n\tfree(line);\n}"
  },
  {
    "function_name": "cgm_dbus_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "135-184",
    "snippet": "static bool cgm_dbus_connect(void)\n{\n\tDBusError dbus_error;\n\tstatic DBusConnection *connection;\n\n\tcgm_lock();\n\tif (!dbus_threads_initialized) {\n\t\t// tell dbus to do struct locking for thread safety\n\t\tdbus_threads_init_default();\n\t\tdbus_threads_initialized = true;\n\t}\n\n\tdbus_error_init(&dbus_error);\n\n\tconnection = dbus_connection_open_private(CGMANAGER_DBUS_SOCK, &dbus_error);\n\tif (!connection) {\n\t\tDEBUG(\"Failed opening dbus connection: %s: %s\",\n\t\t\t\tdbus_error.name, dbus_error.message);\n\t\tdbus_error_free(&dbus_error);\n\t\tcgm_unlock();\n\t\treturn false;\n\t}\n\tdbus_connection_set_exit_on_disconnect(connection, FALSE);\n\tdbus_error_free(&dbus_error);\n\tcgroup_manager = nih_dbus_proxy_new(NULL, connection,\n\t\t\t\tNULL /* p2p */,\n\t\t\t\t\"/org/linuxcontainers/cgmanager\", NULL, NULL);\n\tdbus_connection_unref(connection);\n\tif (!cgroup_manager) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error opening cgmanager proxy: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\n\t// get the api version\n\tif (cgmanager_get_api_version_sync(NULL, cgroup_manager, &api_version) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error cgroup manager api version: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\tif (api_version < CGM_SUPPORTS_NAMED)\n\t\tcull_user_controllers();\n\treturn true;\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define CGMANAGER_DBUS_SOCK \"unix:path=/sys/fs/cgroup/cgmanager/sock\"",
      "#define CGM_SUPPORTS_NAMED 4"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cull_user_controllers",
          "args": [],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "cull_user_controllers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "1108-1119",
          "snippet": "static void cull_user_controllers(void)\n{\n\tint i, j;\n\n\tfor (i = 0;  i < nr_subsystems; i++) {\n\t\tif (strncmp(subsystems[i], \"name=\", 5) != 0)\n\t\t\tcontinue;\n\t\tfor (j = i;  j < nr_subsystems-1; j++)\n\t\t\tsubsystems[j] = subsystems[j+1];\n\t\tnr_subsystems--;\n\t}\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void cull_user_controllers(void)\n{\n\tint i, j;\n\n\tfor (i = 0;  i < nr_subsystems; i++) {\n\t\tif (strncmp(subsystems[i], \"name=\", 5) != 0)\n\t\t\tcontinue;\n\t\tfor (j = i;  j < nr_subsystems-1; j++)\n\t\t\tsubsystems[j] = subsystems[j+1];\n\t\tnr_subsystems--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgm_dbus_disconnect",
          "args": [],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_dbus_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "123-132",
          "snippet": "static void cgm_dbus_disconnect(void)\n{\n\tif (cgroup_manager) {\n\t\tdbus_connection_flush(cgroup_manager->connection);\n\t\tdbus_connection_close(cgroup_manager->connection);\n\t\tnih_free(cgroup_manager);\n\t}\n\tcgroup_manager = NULL;\n\tcgm_unlock();\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void cgm_dbus_disconnect(void)\n{\n\tif (cgroup_manager) {\n\t\tdbus_connection_flush(cgroup_manager->connection);\n\t\tdbus_connection_close(cgroup_manager->connection);\n\t\tnih_free(cgroup_manager);\n\t}\n\tcgroup_manager = NULL;\n\tcgm_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "nih_free",
          "args": [
            "nerr"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error cgroup manager api version: %s\"",
            "nerr->message"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nih_error_get",
          "args": [],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgmanager_get_api_version_sync",
          "args": [
            "NULL",
            "cgroup_manager",
            "&api_version"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nih_free",
          "args": [
            "nerr"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error opening cgmanager proxy: %s\"",
            "nerr->message"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nih_error_get",
          "args": [],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_connection_unref",
          "args": [
            "connection"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nih_dbus_proxy_new",
          "args": [
            "NULL",
            "connection",
            "NULL/* p2p */",
            "\"/org/linuxcontainers/cgmanager\"",
            "NULL",
            "NULL"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_error_free",
          "args": [
            "&dbus_error"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_connection_set_exit_on_disconnect",
          "args": [
            "connection",
            "FALSE"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgm_unlock",
          "args": [],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "101-104",
          "snippet": "void cgm_unlock(void)\n{\n\tunlock_mutex(&cgm_mutex);\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nvoid cgm_unlock(void)\n{\n\tunlock_mutex(&cgm_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbus_error_free",
          "args": [
            "&dbus_error"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Failed opening dbus connection: %s: %s\"",
            "dbus_error.name",
            "dbus_error.message"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_connection_open_private",
          "args": [
            "CGMANAGER_DBUS_SOCK",
            "&dbus_error"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_error_init",
          "args": [
            "&dbus_error"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_threads_init_default",
          "args": [],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgm_lock",
          "args": [],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "96-99",
          "snippet": "void cgm_lock(void)\n{\n\tlock_mutex(&cgm_mutex);\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nvoid cgm_lock(void)\n{\n\tlock_mutex(&cgm_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define CGMANAGER_DBUS_SOCK \"unix:path=/sys/fs/cgroup/cgmanager/sock\"\n#define CGM_SUPPORTS_NAMED 4\n\nstatic bool cgm_dbus_connect(void)\n{\n\tDBusError dbus_error;\n\tstatic DBusConnection *connection;\n\n\tcgm_lock();\n\tif (!dbus_threads_initialized) {\n\t\t// tell dbus to do struct locking for thread safety\n\t\tdbus_threads_init_default();\n\t\tdbus_threads_initialized = true;\n\t}\n\n\tdbus_error_init(&dbus_error);\n\n\tconnection = dbus_connection_open_private(CGMANAGER_DBUS_SOCK, &dbus_error);\n\tif (!connection) {\n\t\tDEBUG(\"Failed opening dbus connection: %s: %s\",\n\t\t\t\tdbus_error.name, dbus_error.message);\n\t\tdbus_error_free(&dbus_error);\n\t\tcgm_unlock();\n\t\treturn false;\n\t}\n\tdbus_connection_set_exit_on_disconnect(connection, FALSE);\n\tdbus_error_free(&dbus_error);\n\tcgroup_manager = nih_dbus_proxy_new(NULL, connection,\n\t\t\t\tNULL /* p2p */,\n\t\t\t\t\"/org/linuxcontainers/cgmanager\", NULL, NULL);\n\tdbus_connection_unref(connection);\n\tif (!cgroup_manager) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error opening cgmanager proxy: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\n\t// get the api version\n\tif (cgmanager_get_api_version_sync(NULL, cgroup_manager, &api_version) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"Error cgroup manager api version: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tcgm_dbus_disconnect();\n\t\treturn false;\n\t}\n\tif (api_version < CGM_SUPPORTS_NAMED)\n\t\tcull_user_controllers();\n\treturn true;\n}"
  },
  {
    "function_name": "cgm_dbus_disconnect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "123-132",
    "snippet": "static void cgm_dbus_disconnect(void)\n{\n\tif (cgroup_manager) {\n\t\tdbus_connection_flush(cgroup_manager->connection);\n\t\tdbus_connection_close(cgroup_manager->connection);\n\t\tnih_free(cgroup_manager);\n\t}\n\tcgroup_manager = NULL;\n\tcgm_unlock();\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgm_unlock",
          "args": [],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "cgm_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "101-104",
          "snippet": "void cgm_unlock(void)\n{\n\tunlock_mutex(&cgm_mutex);\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nvoid cgm_unlock(void)\n{\n\tunlock_mutex(&cgm_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nih_free",
          "args": [
            "cgroup_manager"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_connection_close",
          "args": [
            "cgroup_manager->connection"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_connection_flush",
          "args": [
            "cgroup_manager->connection"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void cgm_dbus_disconnect(void)\n{\n\tif (cgroup_manager) {\n\t\tdbus_connection_flush(cgroup_manager->connection);\n\t\tdbus_connection_close(cgroup_manager->connection);\n\t\tnih_free(cgroup_manager);\n\t}\n\tcgroup_manager = NULL;\n\tcgm_unlock();\n}"
  },
  {
    "function_name": "process_lock_setup_atfork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "107-111",
    "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(cgm_lock, cgm_unlock, cgm_unlock);\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pthread_atfork",
          "args": [
            "cgm_lock",
            "cgm_unlock",
            "cgm_unlock"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(cgm_lock, cgm_unlock, cgm_unlock);\n}"
  },
  {
    "function_name": "cgm_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "101-104",
    "snippet": "void cgm_unlock(void)\n{\n\tunlock_mutex(&cgm_mutex);\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_mutex",
          "args": [
            "&cgm_mutex"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_mutex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "86-94",
          "snippet": "static void unlock_mutex(pthread_mutex_t *l)\n{\n\tint ret;\n\n\tif ((ret = pthread_mutex_unlock(l)) != 0) {\n\t\tfprintf(stderr, \"pthread_mutex_unlock returned:%d %s\\n\", ret, strerror(ret));\n\t\texit(1);\n\t}\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void unlock_mutex(pthread_mutex_t *l)\n{\n\tint ret;\n\n\tif ((ret = pthread_mutex_unlock(l)) != 0) {\n\t\tfprintf(stderr, \"pthread_mutex_unlock returned:%d %s\\n\", ret, strerror(ret));\n\t\texit(1);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nvoid cgm_unlock(void)\n{\n\tunlock_mutex(&cgm_mutex);\n}"
  },
  {
    "function_name": "cgm_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "96-99",
    "snippet": "void cgm_lock(void)\n{\n\tlock_mutex(&cgm_mutex);\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock_mutex",
          "args": [
            "&cgm_mutex"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_mutex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "86-94",
          "snippet": "static void unlock_mutex(pthread_mutex_t *l)\n{\n\tint ret;\n\n\tif ((ret = pthread_mutex_unlock(l)) != 0) {\n\t\tfprintf(stderr, \"pthread_mutex_unlock returned:%d %s\\n\", ret, strerror(ret));\n\t\texit(1);\n\t}\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void unlock_mutex(pthread_mutex_t *l)\n{\n\tint ret;\n\n\tif ((ret = pthread_mutex_unlock(l)) != 0) {\n\t\tfprintf(stderr, \"pthread_mutex_unlock returned:%d %s\\n\", ret, strerror(ret));\n\t\texit(1);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nvoid cgm_lock(void)\n{\n\tlock_mutex(&cgm_mutex);\n}"
  },
  {
    "function_name": "unlock_mutex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "86-94",
    "snippet": "static void unlock_mutex(pthread_mutex_t *l)\n{\n\tint ret;\n\n\tif ((ret = pthread_mutex_unlock(l)) != 0) {\n\t\tfprintf(stderr, \"pthread_mutex_unlock returned:%d %s\\n\", ret, strerror(ret));\n\t\texit(1);\n\t}\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"pthread_mutex_unlock returned:%d %s\\n\"",
            "ret",
            "strerror(ret)"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "ret"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_unlock",
          "args": [
            "l"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void unlock_mutex(pthread_mutex_t *l)\n{\n\tint ret;\n\n\tif ((ret = pthread_mutex_unlock(l)) != 0) {\n\t\tfprintf(stderr, \"pthread_mutex_unlock returned:%d %s\\n\", ret, strerror(ret));\n\t\texit(1);\n\t}\n}"
  },
  {
    "function_name": "lock_mutex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
    "lines": "76-84",
    "snippet": "static void lock_mutex(pthread_mutex_t *l)\n{\n\tint ret;\n\n\tif ((ret = pthread_mutex_lock(l)) != 0) {\n\t\tfprintf(stderr, \"pthread_mutex_lock returned:%d %s\\n\", ret, strerror(ret));\n\t\texit(1);\n\t}\n}",
    "includes": [
      "#include <nih/string.h>",
      "#include <nih/error.h>",
      "#include <nih/alloc.h>",
      "#include <cgmanager/cgmanager-client.h>",
      "#include <nih-dbus/dbus_connection.h>",
      "#include \"state.h\"",
      "#include \"start.h\"",
      "#include \"cgroup.h\"",
      "#include \"log.h\"",
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"list.h\"",
      "#include \"commands.h\"",
      "#include \"error.h\"",
      "#include \"bdev.h\"",
      "#include <poll.h>",
      "#include <net/if.h>",
      "#include <netinet/in.h>",
      "#include <sys/mount.h>",
      "#include <sys/inotify.h>",
      "#include <sys/param.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <grp.h>",
      "#include <pthread.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"pthread_mutex_lock returned:%d %s\\n\"",
            "ret",
            "strerror(ret)"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "ret"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_lock",
          "args": [
            "l"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void lock_mutex(pthread_mutex_t *l)\n{\n\tint ret;\n\n\tif ((ret = pthread_mutex_lock(l)) != 0) {\n\t\tfprintf(stderr, \"pthread_mutex_lock returned:%d %s\\n\", ret, strerror(ret));\n\t\texit(1);\n\t}\n}"
  }
]