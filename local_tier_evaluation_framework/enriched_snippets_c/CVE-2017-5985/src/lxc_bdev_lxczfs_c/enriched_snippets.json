[
  {
    "function_name": "zfs_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxczfs.c",
    "lines": "263-300",
    "snippet": "int zfs_create(struct bdev *bdev, const char *dest, const char *n,\n\t\tstruct bdev_specs *specs)\n{\n\tconst char *zfsroot;\n\tchar option[MAXPATHLEN];\n\tint ret;\n\tpid_t pid;\n\n\tif (!specs || !specs->zfs.zfsroot)\n\t\tzfsroot = lxc_global_config_value(\"lxc.bdev.zfs.root\");\n\telse\n\t\tzfsroot = specs->zfs.zfsroot;\n\n\tif (!(bdev->dest = strdup(dest))) {\n\t\tERROR(\"No mount target specified or out of memory\");\n\t\treturn -1;\n\t}\n\tif (!(bdev->src = strdup(bdev->dest))) {\n\t\tERROR(\"out of memory\");\n\t\treturn -1;\n\t}\n\n\tret = snprintf(option, MAXPATHLEN, \"-omountpoint=%s\", bdev->dest);\n\tif (ret < 0  || ret >= MAXPATHLEN)\n\t\treturn -1;\n\tif ((pid = fork()) < 0)\n\t\treturn -1;\n\tif (pid)\n\t\treturn wait_for_pid(pid);\n\n\tchar dev[MAXPATHLEN];\n\tret = snprintf(dev, MAXPATHLEN, \"%s/%s\", zfsroot, n);\n\tif (ret < 0  || ret >= MAXPATHLEN)\n\t\texit(EXIT_FAILURE);\n\n\texeclp(\"zfs\", \"zfs\", \"create\", option, dev, (char *)NULL);\n\texit(EXIT_FAILURE);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxczfs.h\"",
      "#include \"log.h\"",
      "#include \"config.h\"",
      "#include \"bdev.h\"",
      "#include <sys/mount.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "\"zfs\"",
            "\"zfs\"",
            "\"create\"",
            "option",
            "dev",
            "(char *)NULL"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "dev",
            "MAXPATHLEN",
            "\"%s/%s\"",
            "zfsroot",
            "n"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_pid",
          "args": [
            "pid"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "67-81",
          "snippet": "static int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "option",
            "MAXPATHLEN",
            "\"-omountpoint=%s\"",
            "bdev->dest"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"out of memory\""
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "bdev->dest"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"No mount target specified or out of memory\""
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "dest"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_global_config_value",
          "args": [
            "\"lxc.bdev.zfs.root\""
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_global_config_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "88-247",
          "snippet": "const char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nconst char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxczfs.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"bdev.h\"\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n\nint zfs_create(struct bdev *bdev, const char *dest, const char *n,\n\t\tstruct bdev_specs *specs)\n{\n\tconst char *zfsroot;\n\tchar option[MAXPATHLEN];\n\tint ret;\n\tpid_t pid;\n\n\tif (!specs || !specs->zfs.zfsroot)\n\t\tzfsroot = lxc_global_config_value(\"lxc.bdev.zfs.root\");\n\telse\n\t\tzfsroot = specs->zfs.zfsroot;\n\n\tif (!(bdev->dest = strdup(dest))) {\n\t\tERROR(\"No mount target specified or out of memory\");\n\t\treturn -1;\n\t}\n\tif (!(bdev->src = strdup(bdev->dest))) {\n\t\tERROR(\"out of memory\");\n\t\treturn -1;\n\t}\n\n\tret = snprintf(option, MAXPATHLEN, \"-omountpoint=%s\", bdev->dest);\n\tif (ret < 0  || ret >= MAXPATHLEN)\n\t\treturn -1;\n\tif ((pid = fork()) < 0)\n\t\treturn -1;\n\tif (pid)\n\t\treturn wait_for_pid(pid);\n\n\tchar dev[MAXPATHLEN];\n\tret = snprintf(dev, MAXPATHLEN, \"%s/%s\", zfsroot, n);\n\tif (ret < 0  || ret >= MAXPATHLEN)\n\t\texit(EXIT_FAILURE);\n\n\texeclp(\"zfs\", \"zfs\", \"create\", option, dev, (char *)NULL);\n\texit(EXIT_FAILURE);\n}"
  },
  {
    "function_name": "zfs_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxczfs.c",
    "lines": "238-261",
    "snippet": "int zfs_destroy(struct bdev *orig)\n{\n\tpid_t pid;\n\tchar output[MAXPATHLEN];\n\tchar *p;\n\n\tif ((pid = fork()) < 0)\n\t\treturn -1;\n\tif (pid)\n\t\treturn wait_for_pid(pid);\n\n\tif (!zfs_list_entry(orig->src, output, MAXPATHLEN)) {\n\t\tERROR(\"Error: zfs entry for %s not found\", orig->src);\n\t\treturn -1;\n\t}\n\n\t// zfs mount is output up to ' '\n\tif ((p = strchr(output, ' ')) == NULL)\n\t\treturn -1;\n\t*p = '\\0';\n\n\texeclp(\"zfs\", \"zfs\", \"destroy\", \"-r\", output, (char *)NULL);\n\texit(EXIT_FAILURE);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxczfs.h\"",
      "#include \"log.h\"",
      "#include \"config.h\"",
      "#include \"bdev.h\"",
      "#include <sys/mount.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "\"zfs\"",
            "\"zfs\"",
            "\"destroy\"",
            "\"-r\"",
            "output",
            "(char *)NULL"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "output",
            "' '"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error: zfs entry for %s not found\"",
            "orig->src"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zfs_list_entry",
          "args": [
            "orig->src",
            "output",
            "MAXPATHLEN"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "zfs_list_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxczfs.c",
          "lines": "49-69",
          "snippet": "int zfs_list_entry(const char *path, char *output, size_t inlen)\n{\n\tstruct lxc_popen_FILE *f;\n\tint found=0;\n\n\tf = lxc_popen(\"zfs list 2> /dev/null\");\n\tif (f == NULL) {\n\t\tSYSERROR(\"popen failed\");\n\t\treturn 0;\n\t}\n\n\twhile (fgets(output, inlen, f->f)) {\n\t\tif (strstr(output, path)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t(void) lxc_pclose(f);\n\n\treturn found;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxczfs.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include \"bdev.h\"",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxczfs.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"bdev.h\"\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n\nint zfs_list_entry(const char *path, char *output, size_t inlen)\n{\n\tstruct lxc_popen_FILE *f;\n\tint found=0;\n\n\tf = lxc_popen(\"zfs list 2> /dev/null\");\n\tif (f == NULL) {\n\t\tSYSERROR(\"popen failed\");\n\t\treturn 0;\n\t}\n\n\twhile (fgets(output, inlen, f->f)) {\n\t\tif (strstr(output, path)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t(void) lxc_pclose(f);\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_pid",
          "args": [
            "pid"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "67-81",
          "snippet": "static int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxczfs.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"bdev.h\"\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n\nint zfs_destroy(struct bdev *orig)\n{\n\tpid_t pid;\n\tchar output[MAXPATHLEN];\n\tchar *p;\n\n\tif ((pid = fork()) < 0)\n\t\treturn -1;\n\tif (pid)\n\t\treturn wait_for_pid(pid);\n\n\tif (!zfs_list_entry(orig->src, output, MAXPATHLEN)) {\n\t\tERROR(\"Error: zfs entry for %s not found\", orig->src);\n\t\treturn -1;\n\t}\n\n\t// zfs mount is output up to ' '\n\tif ((p = strchr(output, ' ')) == NULL)\n\t\treturn -1;\n\t*p = '\\0';\n\n\texeclp(\"zfs\", \"zfs\", \"destroy\", \"-r\", output, (char *)NULL);\n\texit(EXIT_FAILURE);\n}"
  },
  {
    "function_name": "zfs_clonepaths",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxczfs.c",
    "lines": "204-231",
    "snippet": "int zfs_clonepaths(struct bdev *orig, struct bdev *new, const char *oldname,\n\t\tconst char *cname, const char *oldpath, const char *lxcpath, int snap,\n\t\tuint64_t newsize, struct lxc_conf *conf)\n{\n\tint len, ret;\n\n\tif (!orig->src || !orig->dest)\n\t\treturn -1;\n\n\tif (snap && strcmp(orig->type, \"zfs\")) {\n\t\tERROR(\"zfs snapshot from %s backing store is not supported\", orig->type);\n\t\treturn -1;\n\t}\n\n\tlen = strlen(lxcpath) + strlen(cname) + strlen(\"rootfs\") + 3;\n\tnew->src = malloc(len);\n\tif (!new->src)\n\t\treturn -1;\n\n\tret = snprintf(new->src, len, \"%s/%s/rootfs\", lxcpath, cname);\n\tif (ret < 0 || ret >= len)\n\t\treturn -1;\n\n\tif ((new->dest = strdup(new->src)) == NULL)\n\t\treturn -1;\n\n\treturn zfs_clone(orig->src, new->src, oldname, cname, lxcpath, snap);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxczfs.h\"",
      "#include \"log.h\"",
      "#include \"config.h\"",
      "#include \"bdev.h\"",
      "#include <sys/mount.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zfs_clone",
          "args": [
            "orig->src",
            "new->src",
            "oldname",
            "cname",
            "lxcpath",
            "snap"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "zfs_clone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxczfs.c",
          "lines": "118-202",
          "snippet": "int zfs_clone(const char *opath, const char *npath, const char *oname,\n\t\tconst char *nname, const char *lxcpath, int snapshot)\n{\n\t// use the 'zfs list | grep opath' entry to get the zfsroot\n\tchar output[MAXPATHLEN], option[MAXPATHLEN];\n\tchar *p;\n\tconst char *zfsroot = output;\n\tint ret;\n\tpid_t pid;\n\n\tif (zfs_list_entry(opath, output, MAXPATHLEN)) {\n\t\t// zfsroot is output up to ' '\n\t\tif ((p = strchr(output, ' ')) == NULL)\n\t\t\treturn -1;\n\t\t*p = '\\0';\n\n\t\tif ((p = strrchr(output, '/')) == NULL)\n\t\t\treturn -1;\n\t\t*p = '\\0';\n\t} else {\n\t\tzfsroot = lxc_global_config_value(\"lxc.bdev.zfs.root\");\n\t}\n\n\tret = snprintf(option, MAXPATHLEN, \"-omountpoint=%s/%s/rootfs\", lxcpath, nname);\n\tif (ret < 0  || ret >= MAXPATHLEN)\n\t\treturn -1;\n\n\t// zfs create -omountpoint=$lxcpath/$lxcname $zfsroot/$nname\n\tif (!snapshot) {\n\t\tif ((pid = fork()) < 0)\n\t\t\treturn -1;\n\t\tif (!pid) {\n\t\t\tchar dev[MAXPATHLEN];\n\t\t\tret = snprintf(dev, MAXPATHLEN, \"%s/%s\", zfsroot, nname);\n\t\t\tif (ret < 0  || ret >= MAXPATHLEN)\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\texeclp(\"zfs\", \"zfs\", \"create\", option, dev, (char *)NULL);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\treturn wait_for_pid(pid);\n\t} else {\n\t\t// if snapshot, do\n\t\t// 'zfs snapshot zfsroot/oname@nname\n\t\t// zfs clone zfsroot/oname@nname zfsroot/nname\n\t\tchar path1[MAXPATHLEN], path2[MAXPATHLEN];\n\n\t\tret = snprintf(path1, MAXPATHLEN, \"%s/%s@%s\", zfsroot,\n\t\t\t\toname, nname);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn -1;\n\t\t(void) snprintf(path2, MAXPATHLEN, \"%s/%s\", zfsroot, nname);\n\n\t\t// if the snapshot exists, delete it\n\t\tif ((pid = fork()) < 0)\n\t\t\treturn -1;\n\t\tif (!pid) {\n\t\t\tint dev0 = open(\"/dev/null\", O_WRONLY);\n\t\t\tif (dev0 >= 0)\n\t\t\t\tdup2(dev0, STDERR_FILENO);\n\t\t\texeclp(\"zfs\", \"zfs\", \"destroy\", path1, (char *)NULL);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\t// it probably doesn't exist so destroy probably will fail.\n\t\t(void) wait_for_pid(pid);\n\n\t\t// run first (snapshot) command\n\t\tif ((pid = fork()) < 0)\n\t\t\treturn -1;\n\t\tif (!pid) {\n\t\t\texeclp(\"zfs\", \"zfs\", \"snapshot\", path1, (char *)NULL);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tif (wait_for_pid(pid) < 0)\n\t\t\treturn -1;\n\n\t\t// run second (clone) command\n\t\tif ((pid = fork()) < 0)\n\t\t\treturn -1;\n\t\tif (!pid) {\n\t\t\texeclp(\"zfs\", \"zfs\", \"clone\", option, path1, path2, (char *)NULL);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\treturn wait_for_pid(pid);\n\t}\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxczfs.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include \"bdev.h\"",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxczfs.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"bdev.h\"\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n\nint zfs_clone(const char *opath, const char *npath, const char *oname,\n\t\tconst char *nname, const char *lxcpath, int snapshot)\n{\n\t// use the 'zfs list | grep opath' entry to get the zfsroot\n\tchar output[MAXPATHLEN], option[MAXPATHLEN];\n\tchar *p;\n\tconst char *zfsroot = output;\n\tint ret;\n\tpid_t pid;\n\n\tif (zfs_list_entry(opath, output, MAXPATHLEN)) {\n\t\t// zfsroot is output up to ' '\n\t\tif ((p = strchr(output, ' ')) == NULL)\n\t\t\treturn -1;\n\t\t*p = '\\0';\n\n\t\tif ((p = strrchr(output, '/')) == NULL)\n\t\t\treturn -1;\n\t\t*p = '\\0';\n\t} else {\n\t\tzfsroot = lxc_global_config_value(\"lxc.bdev.zfs.root\");\n\t}\n\n\tret = snprintf(option, MAXPATHLEN, \"-omountpoint=%s/%s/rootfs\", lxcpath, nname);\n\tif (ret < 0  || ret >= MAXPATHLEN)\n\t\treturn -1;\n\n\t// zfs create -omountpoint=$lxcpath/$lxcname $zfsroot/$nname\n\tif (!snapshot) {\n\t\tif ((pid = fork()) < 0)\n\t\t\treturn -1;\n\t\tif (!pid) {\n\t\t\tchar dev[MAXPATHLEN];\n\t\t\tret = snprintf(dev, MAXPATHLEN, \"%s/%s\", zfsroot, nname);\n\t\t\tif (ret < 0  || ret >= MAXPATHLEN)\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\texeclp(\"zfs\", \"zfs\", \"create\", option, dev, (char *)NULL);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\treturn wait_for_pid(pid);\n\t} else {\n\t\t// if snapshot, do\n\t\t// 'zfs snapshot zfsroot/oname@nname\n\t\t// zfs clone zfsroot/oname@nname zfsroot/nname\n\t\tchar path1[MAXPATHLEN], path2[MAXPATHLEN];\n\n\t\tret = snprintf(path1, MAXPATHLEN, \"%s/%s@%s\", zfsroot,\n\t\t\t\toname, nname);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn -1;\n\t\t(void) snprintf(path2, MAXPATHLEN, \"%s/%s\", zfsroot, nname);\n\n\t\t// if the snapshot exists, delete it\n\t\tif ((pid = fork()) < 0)\n\t\t\treturn -1;\n\t\tif (!pid) {\n\t\t\tint dev0 = open(\"/dev/null\", O_WRONLY);\n\t\t\tif (dev0 >= 0)\n\t\t\t\tdup2(dev0, STDERR_FILENO);\n\t\t\texeclp(\"zfs\", \"zfs\", \"destroy\", path1, (char *)NULL);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\t// it probably doesn't exist so destroy probably will fail.\n\t\t(void) wait_for_pid(pid);\n\n\t\t// run first (snapshot) command\n\t\tif ((pid = fork()) < 0)\n\t\t\treturn -1;\n\t\tif (!pid) {\n\t\t\texeclp(\"zfs\", \"zfs\", \"snapshot\", path1, (char *)NULL);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tif (wait_for_pid(pid) < 0)\n\t\t\treturn -1;\n\n\t\t// run second (clone) command\n\t\tif ((pid = fork()) < 0)\n\t\t\treturn -1;\n\t\tif (!pid) {\n\t\t\texeclp(\"zfs\", \"zfs\", \"clone\", option, path1, path2, (char *)NULL);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\treturn wait_for_pid(pid);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "new->src"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "new->src",
            "len",
            "\"%s/%s/rootfs\"",
            "lxcpath",
            "cname"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"rootfs\""
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cname"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "lxcpath"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"zfs snapshot from %s backing store is not supported\"",
            "orig->type"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "orig->type",
            "\"zfs\""
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxczfs.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"bdev.h\"\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n\nint zfs_clonepaths(struct bdev *orig, struct bdev *new, const char *oldname,\n\t\tconst char *cname, const char *oldpath, const char *lxcpath, int snap,\n\t\tuint64_t newsize, struct lxc_conf *conf)\n{\n\tint len, ret;\n\n\tif (!orig->src || !orig->dest)\n\t\treturn -1;\n\n\tif (snap && strcmp(orig->type, \"zfs\")) {\n\t\tERROR(\"zfs snapshot from %s backing store is not supported\", orig->type);\n\t\treturn -1;\n\t}\n\n\tlen = strlen(lxcpath) + strlen(cname) + strlen(\"rootfs\") + 3;\n\tnew->src = malloc(len);\n\tif (!new->src)\n\t\treturn -1;\n\n\tret = snprintf(new->src, len, \"%s/%s/rootfs\", lxcpath, cname);\n\tif (ret < 0 || ret >= len)\n\t\treturn -1;\n\n\tif ((new->dest = strdup(new->src)) == NULL)\n\t\treturn -1;\n\n\treturn zfs_clone(orig->src, new->src, oldname, cname, lxcpath, snap);\n}"
  },
  {
    "function_name": "zfs_clone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxczfs.c",
    "lines": "118-202",
    "snippet": "int zfs_clone(const char *opath, const char *npath, const char *oname,\n\t\tconst char *nname, const char *lxcpath, int snapshot)\n{\n\t// use the 'zfs list | grep opath' entry to get the zfsroot\n\tchar output[MAXPATHLEN], option[MAXPATHLEN];\n\tchar *p;\n\tconst char *zfsroot = output;\n\tint ret;\n\tpid_t pid;\n\n\tif (zfs_list_entry(opath, output, MAXPATHLEN)) {\n\t\t// zfsroot is output up to ' '\n\t\tif ((p = strchr(output, ' ')) == NULL)\n\t\t\treturn -1;\n\t\t*p = '\\0';\n\n\t\tif ((p = strrchr(output, '/')) == NULL)\n\t\t\treturn -1;\n\t\t*p = '\\0';\n\t} else {\n\t\tzfsroot = lxc_global_config_value(\"lxc.bdev.zfs.root\");\n\t}\n\n\tret = snprintf(option, MAXPATHLEN, \"-omountpoint=%s/%s/rootfs\", lxcpath, nname);\n\tif (ret < 0  || ret >= MAXPATHLEN)\n\t\treturn -1;\n\n\t// zfs create -omountpoint=$lxcpath/$lxcname $zfsroot/$nname\n\tif (!snapshot) {\n\t\tif ((pid = fork()) < 0)\n\t\t\treturn -1;\n\t\tif (!pid) {\n\t\t\tchar dev[MAXPATHLEN];\n\t\t\tret = snprintf(dev, MAXPATHLEN, \"%s/%s\", zfsroot, nname);\n\t\t\tif (ret < 0  || ret >= MAXPATHLEN)\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\texeclp(\"zfs\", \"zfs\", \"create\", option, dev, (char *)NULL);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\treturn wait_for_pid(pid);\n\t} else {\n\t\t// if snapshot, do\n\t\t// 'zfs snapshot zfsroot/oname@nname\n\t\t// zfs clone zfsroot/oname@nname zfsroot/nname\n\t\tchar path1[MAXPATHLEN], path2[MAXPATHLEN];\n\n\t\tret = snprintf(path1, MAXPATHLEN, \"%s/%s@%s\", zfsroot,\n\t\t\t\toname, nname);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn -1;\n\t\t(void) snprintf(path2, MAXPATHLEN, \"%s/%s\", zfsroot, nname);\n\n\t\t// if the snapshot exists, delete it\n\t\tif ((pid = fork()) < 0)\n\t\t\treturn -1;\n\t\tif (!pid) {\n\t\t\tint dev0 = open(\"/dev/null\", O_WRONLY);\n\t\t\tif (dev0 >= 0)\n\t\t\t\tdup2(dev0, STDERR_FILENO);\n\t\t\texeclp(\"zfs\", \"zfs\", \"destroy\", path1, (char *)NULL);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\t// it probably doesn't exist so destroy probably will fail.\n\t\t(void) wait_for_pid(pid);\n\n\t\t// run first (snapshot) command\n\t\tif ((pid = fork()) < 0)\n\t\t\treturn -1;\n\t\tif (!pid) {\n\t\t\texeclp(\"zfs\", \"zfs\", \"snapshot\", path1, (char *)NULL);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tif (wait_for_pid(pid) < 0)\n\t\t\treturn -1;\n\n\t\t// run second (clone) command\n\t\tif ((pid = fork()) < 0)\n\t\t\treturn -1;\n\t\tif (!pid) {\n\t\t\texeclp(\"zfs\", \"zfs\", \"clone\", option, path1, path2, (char *)NULL);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\treturn wait_for_pid(pid);\n\t}\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxczfs.h\"",
      "#include \"log.h\"",
      "#include \"config.h\"",
      "#include \"bdev.h\"",
      "#include <sys/mount.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_for_pid",
          "args": [
            "pid"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "67-81",
          "snippet": "static int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "\"zfs\"",
            "\"zfs\"",
            "\"clone\"",
            "option",
            "path1",
            "path2",
            "(char *)NULL"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "\"zfs\"",
            "\"zfs\"",
            "\"snapshot\"",
            "path1",
            "(char *)NULL"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "\"zfs\"",
            "\"zfs\"",
            "\"destroy\"",
            "path1",
            "(char *)NULL"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "dev0",
            "STDERR_FILENO"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/dev/null\"",
            "O_WRONLY"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "genetlink_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/genl.c",
          "lines": "106-116",
          "snippet": "extern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"genl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/genetlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"genl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path2",
            "MAXPATHLEN",
            "\"%s/%s\"",
            "zfsroot",
            "nname"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path1",
            "MAXPATHLEN",
            "\"%s/%s@%s\"",
            "zfsroot",
            "oname",
            "nname"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "\"zfs\"",
            "\"zfs\"",
            "\"create\"",
            "option",
            "dev",
            "(char *)NULL"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "dev",
            "MAXPATHLEN",
            "\"%s/%s\"",
            "zfsroot",
            "nname"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "option",
            "MAXPATHLEN",
            "\"-omountpoint=%s/%s/rootfs\"",
            "lxcpath",
            "nname"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_global_config_value",
          "args": [
            "\"lxc.bdev.zfs.root\""
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_global_config_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "88-247",
          "snippet": "const char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nconst char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "output",
            "'/'"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "output",
            "' '"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "zfs_list_entry",
          "args": [
            "opath",
            "output",
            "MAXPATHLEN"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "zfs_list_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxczfs.c",
          "lines": "49-69",
          "snippet": "int zfs_list_entry(const char *path, char *output, size_t inlen)\n{\n\tstruct lxc_popen_FILE *f;\n\tint found=0;\n\n\tf = lxc_popen(\"zfs list 2> /dev/null\");\n\tif (f == NULL) {\n\t\tSYSERROR(\"popen failed\");\n\t\treturn 0;\n\t}\n\n\twhile (fgets(output, inlen, f->f)) {\n\t\tif (strstr(output, path)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t(void) lxc_pclose(f);\n\n\treturn found;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxczfs.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include \"bdev.h\"",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxczfs.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"bdev.h\"\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n\nint zfs_list_entry(const char *path, char *output, size_t inlen)\n{\n\tstruct lxc_popen_FILE *f;\n\tint found=0;\n\n\tf = lxc_popen(\"zfs list 2> /dev/null\");\n\tif (f == NULL) {\n\t\tSYSERROR(\"popen failed\");\n\t\treturn 0;\n\t}\n\n\twhile (fgets(output, inlen, f->f)) {\n\t\tif (strstr(output, path)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t(void) lxc_pclose(f);\n\n\treturn found;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxczfs.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"bdev.h\"\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n\nint zfs_clone(const char *opath, const char *npath, const char *oname,\n\t\tconst char *nname, const char *lxcpath, int snapshot)\n{\n\t// use the 'zfs list | grep opath' entry to get the zfsroot\n\tchar output[MAXPATHLEN], option[MAXPATHLEN];\n\tchar *p;\n\tconst char *zfsroot = output;\n\tint ret;\n\tpid_t pid;\n\n\tif (zfs_list_entry(opath, output, MAXPATHLEN)) {\n\t\t// zfsroot is output up to ' '\n\t\tif ((p = strchr(output, ' ')) == NULL)\n\t\t\treturn -1;\n\t\t*p = '\\0';\n\n\t\tif ((p = strrchr(output, '/')) == NULL)\n\t\t\treturn -1;\n\t\t*p = '\\0';\n\t} else {\n\t\tzfsroot = lxc_global_config_value(\"lxc.bdev.zfs.root\");\n\t}\n\n\tret = snprintf(option, MAXPATHLEN, \"-omountpoint=%s/%s/rootfs\", lxcpath, nname);\n\tif (ret < 0  || ret >= MAXPATHLEN)\n\t\treturn -1;\n\n\t// zfs create -omountpoint=$lxcpath/$lxcname $zfsroot/$nname\n\tif (!snapshot) {\n\t\tif ((pid = fork()) < 0)\n\t\t\treturn -1;\n\t\tif (!pid) {\n\t\t\tchar dev[MAXPATHLEN];\n\t\t\tret = snprintf(dev, MAXPATHLEN, \"%s/%s\", zfsroot, nname);\n\t\t\tif (ret < 0  || ret >= MAXPATHLEN)\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\texeclp(\"zfs\", \"zfs\", \"create\", option, dev, (char *)NULL);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\treturn wait_for_pid(pid);\n\t} else {\n\t\t// if snapshot, do\n\t\t// 'zfs snapshot zfsroot/oname@nname\n\t\t// zfs clone zfsroot/oname@nname zfsroot/nname\n\t\tchar path1[MAXPATHLEN], path2[MAXPATHLEN];\n\n\t\tret = snprintf(path1, MAXPATHLEN, \"%s/%s@%s\", zfsroot,\n\t\t\t\toname, nname);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn -1;\n\t\t(void) snprintf(path2, MAXPATHLEN, \"%s/%s\", zfsroot, nname);\n\n\t\t// if the snapshot exists, delete it\n\t\tif ((pid = fork()) < 0)\n\t\t\treturn -1;\n\t\tif (!pid) {\n\t\t\tint dev0 = open(\"/dev/null\", O_WRONLY);\n\t\t\tif (dev0 >= 0)\n\t\t\t\tdup2(dev0, STDERR_FILENO);\n\t\t\texeclp(\"zfs\", \"zfs\", \"destroy\", path1, (char *)NULL);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\t// it probably doesn't exist so destroy probably will fail.\n\t\t(void) wait_for_pid(pid);\n\n\t\t// run first (snapshot) command\n\t\tif ((pid = fork()) < 0)\n\t\t\treturn -1;\n\t\tif (!pid) {\n\t\t\texeclp(\"zfs\", \"zfs\", \"snapshot\", path1, (char *)NULL);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tif (wait_for_pid(pid) < 0)\n\t\t\treturn -1;\n\n\t\t// run second (clone) command\n\t\tif ((pid = fork()) < 0)\n\t\t\treturn -1;\n\t\tif (!pid) {\n\t\t\texeclp(\"zfs\", \"zfs\", \"clone\", option, path1, path2, (char *)NULL);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\treturn wait_for_pid(pid);\n\t}\n}"
  },
  {
    "function_name": "zfs_umount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxczfs.c",
    "lines": "107-116",
    "snippet": "int zfs_umount(struct bdev *bdev)\n{\n\tif (strcmp(bdev->type, \"zfs\"))\n\t\treturn -22;\n\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\n\treturn umount(bdev->dest);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxczfs.h\"",
      "#include \"log.h\"",
      "#include \"config.h\"",
      "#include \"bdev.h\"",
      "#include <sys/mount.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "umount",
          "args": [
            "bdev->dest"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "zfs_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxczfs.c",
          "lines": "107-116",
          "snippet": "int zfs_umount(struct bdev *bdev)\n{\n\tif (strcmp(bdev->type, \"zfs\"))\n\t\treturn -22;\n\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\n\treturn umount(bdev->dest);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "bdev->type",
            "\"zfs\""
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxczfs.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"bdev.h\"\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n\nint zfs_umount(struct bdev *bdev)\n{\n\tif (strcmp(bdev->type, \"zfs\"))\n\t\treturn -22;\n\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\n\treturn umount(bdev->dest);\n}"
  },
  {
    "function_name": "zfs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxczfs.c",
    "lines": "86-105",
    "snippet": "int zfs_mount(struct bdev *bdev)\n{\n\tif (strcmp(bdev->type, \"zfs\"))\n\t\treturn -22;\n\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\n\tchar *mntdata;\n\tunsigned long mntflags;\n\tif (parse_mntopts(bdev->mntopts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -22;\n\t}\n\n\tint ret = mount(bdev->src, bdev->dest, \"bind\", MS_BIND | MS_REC | mntflags, mntdata);\n\tfree(mntdata);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxczfs.h\"",
      "#include \"log.h\"",
      "#include \"config.h\"",
      "#include \"bdev.h\"",
      "#include <sys/mount.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "mntdata"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "free_btrfs_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "536-547",
          "snippet": "static void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "bdev->src",
            "bdev->dest",
            "\"bind\"",
            "MS_BIND | MS_REC | mntflags",
            "mntdata"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_remount_on_enodev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcoverlay.c",
          "lines": "664-676",
          "snippet": "static int ovl_remount_on_enodev(const char *lower, const char *target,\n\t\t\t\t const char *name, unsigned long mountflags,\n\t\t\t\t const void *options)\n{\n        int ret;\n        ret = mount(lower, target, ovl_name, MS_MGC_VAL | mountflags, options);\n        if (ret < 0 && errno == ENODEV) /* Try other module name. */\n\t\tret = mount(lower, target,\n\t\t\t    ovl_name == ovl_version[0] ? ovl_version[1]\n\t\t\t\t\t\t       : ovl_version[0],\n\t\t\t    MS_MGC_VAL | mountflags, options);\n        return ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *ovl_name;",
            "static char *ovl_version[] = {\"overlay\", \"overlayfs\"};",
            "static int ovl_remount_on_enodev(const char *lower, const char *target,\n\t\t\t\t const char *name, unsigned long mountflags,\n\t\t\t\t const void *options);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcoverlay.h\"\n#include \"lxccontainer.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nstatic char *ovl_name;\nstatic char *ovl_version[] = {\"overlay\", \"overlayfs\"};\nstatic int ovl_remount_on_enodev(const char *lower, const char *target,\n\t\t\t\t const char *name, unsigned long mountflags,\n\t\t\t\t const void *options);\n\nstatic int ovl_remount_on_enodev(const char *lower, const char *target,\n\t\t\t\t const char *name, unsigned long mountflags,\n\t\t\t\t const void *options)\n{\n        int ret;\n        ret = mount(lower, target, ovl_name, MS_MGC_VAL | mountflags, options);\n        if (ret < 0 && errno == ENODEV) /* Try other module name. */\n\t\tret = mount(lower, target,\n\t\t\t    ovl_name == ovl_version[0] ? ovl_version[1]\n\t\t\t\t\t\t       : ovl_version[0],\n\t\t\t    MS_MGC_VAL | mountflags, options);\n        return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_mntopts",
          "args": [
            "bdev->mntopts",
            "&mntflags",
            "&mntdata"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "parse_mntopts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1629-1666",
          "snippet": "int parse_mntopts(const char *mntopts, unsigned long *mntflags,\n\t\t\t char **mntdata)\n{\n\tchar *s, *data;\n\tchar *p, *saveptr = NULL;\n\n\t*mntdata = NULL;\n\t*mntflags = 0L;\n\n\tif (!mntopts)\n\t\treturn 0;\n\n\ts = strdup(mntopts);\n\tif (!s) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\treturn -1;\n\t}\n\n\tdata = malloc(strlen(s) + 1);\n\tif (!data) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\tfree(s);\n\t\treturn -1;\n\t}\n\t*data = 0;\n\n\tfor (p = strtok_r(s, \",\", &saveptr); p != NULL;\n\t     p = strtok_r(NULL, \",\", &saveptr))\n\t\tparse_mntopt(p, mntflags, &data);\n\n\tif (*data)\n\t\t*mntdata = data;\n\telse\n\t\tfree(data);\n\tfree(s);\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint parse_mntopts(const char *mntopts, unsigned long *mntflags,\n\t\t\t char **mntdata)\n{\n\tchar *s, *data;\n\tchar *p, *saveptr = NULL;\n\n\t*mntdata = NULL;\n\t*mntflags = 0L;\n\n\tif (!mntopts)\n\t\treturn 0;\n\n\ts = strdup(mntopts);\n\tif (!s) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\treturn -1;\n\t}\n\n\tdata = malloc(strlen(s) + 1);\n\tif (!data) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\tfree(s);\n\t\treturn -1;\n\t}\n\t*data = 0;\n\n\tfor (p = strtok_r(s, \",\", &saveptr); p != NULL;\n\t     p = strtok_r(NULL, \",\", &saveptr))\n\t\tparse_mntopt(p, mntflags, &data);\n\n\tif (*data)\n\t\t*mntdata = data;\n\telse\n\t\tfree(data);\n\tfree(s);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "bdev->type",
            "\"zfs\""
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxczfs.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"bdev.h\"\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n\nint zfs_mount(struct bdev *bdev)\n{\n\tif (strcmp(bdev->type, \"zfs\"))\n\t\treturn -22;\n\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\n\tchar *mntdata;\n\tunsigned long mntflags;\n\tif (parse_mntopts(bdev->mntopts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -22;\n\t}\n\n\tint ret = mount(bdev->src, bdev->dest, \"bind\", MS_BIND | MS_REC | mntflags, mntdata);\n\tfree(mntdata);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "zfs_detect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxczfs.c",
    "lines": "71-84",
    "snippet": "int zfs_detect(const char *path)\n{\n\tchar *output = malloc(LXC_LOG_BUFFER_SIZE);\n\n\tif (!output) {\n\t\tERROR(\"out of memory\");\n\t\treturn 0;\n\t}\n\n\tint found = zfs_list_entry(path, output, LXC_LOG_BUFFER_SIZE);\n\tfree(output);\n\n\treturn found;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxczfs.h\"",
      "#include \"log.h\"",
      "#include \"config.h\"",
      "#include \"bdev.h\"",
      "#include <sys/mount.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "output"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "free_btrfs_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "536-547",
          "snippet": "static void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zfs_list_entry",
          "args": [
            "path",
            "output",
            "LXC_LOG_BUFFER_SIZE"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "zfs_list_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxczfs.c",
          "lines": "49-69",
          "snippet": "int zfs_list_entry(const char *path, char *output, size_t inlen)\n{\n\tstruct lxc_popen_FILE *f;\n\tint found=0;\n\n\tf = lxc_popen(\"zfs list 2> /dev/null\");\n\tif (f == NULL) {\n\t\tSYSERROR(\"popen failed\");\n\t\treturn 0;\n\t}\n\n\twhile (fgets(output, inlen, f->f)) {\n\t\tif (strstr(output, path)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t(void) lxc_pclose(f);\n\n\treturn found;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxczfs.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include \"bdev.h\"",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxczfs.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"bdev.h\"\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n\nint zfs_list_entry(const char *path, char *output, size_t inlen)\n{\n\tstruct lxc_popen_FILE *f;\n\tint found=0;\n\n\tf = lxc_popen(\"zfs list 2> /dev/null\");\n\tif (f == NULL) {\n\t\tSYSERROR(\"popen failed\");\n\t\treturn 0;\n\t}\n\n\twhile (fgets(output, inlen, f->f)) {\n\t\tif (strstr(output, path)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t(void) lxc_pclose(f);\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"out of memory\""
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "LXC_LOG_BUFFER_SIZE"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxczfs.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"bdev.h\"\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n\nint zfs_detect(const char *path)\n{\n\tchar *output = malloc(LXC_LOG_BUFFER_SIZE);\n\n\tif (!output) {\n\t\tERROR(\"out of memory\");\n\t\treturn 0;\n\t}\n\n\tint found = zfs_list_entry(path, output, LXC_LOG_BUFFER_SIZE);\n\tfree(output);\n\n\treturn found;\n}"
  },
  {
    "function_name": "zfs_list_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxczfs.c",
    "lines": "49-69",
    "snippet": "int zfs_list_entry(const char *path, char *output, size_t inlen)\n{\n\tstruct lxc_popen_FILE *f;\n\tint found=0;\n\n\tf = lxc_popen(\"zfs list 2> /dev/null\");\n\tif (f == NULL) {\n\t\tSYSERROR(\"popen failed\");\n\t\treturn 0;\n\t}\n\n\twhile (fgets(output, inlen, f->f)) {\n\t\tif (strstr(output, path)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t(void) lxc_pclose(f);\n\n\treturn found;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxczfs.h\"",
      "#include \"log.h\"",
      "#include \"config.h\"",
      "#include \"bdev.h\"",
      "#include <sys/mount.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_pclose",
          "args": [
            "f"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_pclose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "569-599",
          "snippet": "extern int lxc_pclose(struct lxc_popen_FILE *fp)\n{\n\tFILE *f = NULL;\n\tpid_t child_pid = 0;\n\tint wstatus = 0;\n\tpid_t wait_pid;\n\n\tif (fp) {\n\t\tf = fp->f;\n\t\tchild_pid = fp->child_pid;\n\t\t/* free memory (we still need to close file stream) */\n\t\tfree(fp);\n\t\tfp = NULL;\n\t}\n\n\tif (!f || fclose(f)) {\n\t\tERROR(\"fclose failure\");\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\twait_pid = waitpid(child_pid, &wstatus, 0);\n\t} while (wait_pid == -1 && errno == EINTR);\n\n\tif (wait_pid == -1) {\n\t\tERROR(\"waitpid failure\");\n\t\treturn -1;\n\t}\n\n\treturn wstatus;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int lxc_pclose(struct lxc_popen_FILE *fp)\n{\n\tFILE *f = NULL;\n\tpid_t child_pid = 0;\n\tint wstatus = 0;\n\tpid_t wait_pid;\n\n\tif (fp) {\n\t\tf = fp->f;\n\t\tchild_pid = fp->child_pid;\n\t\t/* free memory (we still need to close file stream) */\n\t\tfree(fp);\n\t\tfp = NULL;\n\t}\n\n\tif (!f || fclose(f)) {\n\t\tERROR(\"fclose failure\");\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\twait_pid = waitpid(child_pid, &wstatus, 0);\n\t} while (wait_pid == -1 && errno == EINTR);\n\n\tif (wait_pid == -1) {\n\t\tERROR(\"waitpid failure\");\n\t\treturn -1;\n\t}\n\n\treturn wstatus;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "output",
            "path"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "output",
            "inlen",
            "f->f"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"popen failed\""
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_popen",
          "args": [
            "\"zfs list 2> /dev/null\""
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_popen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "469-567",
          "snippet": "extern struct lxc_popen_FILE *lxc_popen(const char *command)\n{\n\tstruct lxc_popen_FILE *fp = NULL;\n\tint parent_end = -1, child_end = -1;\n\tint pipe_fds[2];\n\tpid_t child_pid;\n\n\tint r = pipe2(pipe_fds, O_CLOEXEC);\n\n\tif (r < 0) {\n\t\tERROR(\"pipe2 failure\");\n\t\treturn NULL;\n\t}\n\n\tparent_end = pipe_fds[0];\n\tchild_end = pipe_fds[1];\n\n\tchild_pid = fork();\n\n\tif (child_pid == 0) {\n\t\t/* child */\n\t\tint child_std_end = STDOUT_FILENO;\n\n\t\tif (child_end != child_std_end) {\n\t\t\t/* dup2() doesn't dup close-on-exec flag */\n\t\t\tdup2(child_end, child_std_end);\n\n\t\t\t/* it's safe not to close child_end here\n\t\t\t * as it's marked close-on-exec anyway\n\t\t\t */\n\t\t} else {\n\t\t\t/*\n\t\t\t * The descriptor is already the one we will use.\n\t\t\t * But it must not be marked close-on-exec.\n\t\t\t * Undo the effects.\n\t\t\t */\n\t\t\tif (fcntl(child_end, F_SETFD, 0) != 0) {\n\t\t\t\tSYSERROR(\"Failed to remove FD_CLOEXEC from fd.\");\n\t\t\t\texit(127);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Unblock signals.\n\t\t * This is the main/only reason\n\t\t * why we do our lousy popen() emulation.\n\t\t */\n\t\t{\n\t\t\tsigset_t mask;\n\t\t\tsigfillset(&mask);\n\t\t\tsigprocmask(SIG_UNBLOCK, &mask, NULL);\n\t\t}\n\n\t\texecl(\"/bin/sh\", \"sh\", \"-c\", command, (char *) NULL);\n\t\texit(127);\n\t}\n\n\t/* parent */\n\n\tclose(child_end);\n\tchild_end = -1;\n\n\tif (child_pid < 0) {\n\t\tERROR(\"fork failure\");\n\t\tgoto error;\n\t}\n\n\tfp = calloc(1, sizeof(*fp));\n\tif (!fp) {\n\t\tERROR(\"failed to allocate memory\");\n\t\tgoto error;\n\t}\n\n\tfp->f = fdopen(parent_end, \"r\");\n\tif (!fp->f) {\n\t\tERROR(\"fdopen failure\");\n\t\tgoto error;\n\t}\n\n\tfp->child_pid = child_pid;\n\n\treturn fp;\n\nerror:\n\n\tif (fp) {\n\t\tif (fp->f) {\n\t\t\tfclose(fp->f);\n\t\t\tparent_end = -1; /* so we do not close it second time */\n\t\t}\n\n\t\tfree(fp);\n\t}\n\n\tif (parent_end != -1)\n\t\tclose(parent_end);\n\n\treturn NULL;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern struct lxc_popen_FILE *lxc_popen(const char *command)\n{\n\tstruct lxc_popen_FILE *fp = NULL;\n\tint parent_end = -1, child_end = -1;\n\tint pipe_fds[2];\n\tpid_t child_pid;\n\n\tint r = pipe2(pipe_fds, O_CLOEXEC);\n\n\tif (r < 0) {\n\t\tERROR(\"pipe2 failure\");\n\t\treturn NULL;\n\t}\n\n\tparent_end = pipe_fds[0];\n\tchild_end = pipe_fds[1];\n\n\tchild_pid = fork();\n\n\tif (child_pid == 0) {\n\t\t/* child */\n\t\tint child_std_end = STDOUT_FILENO;\n\n\t\tif (child_end != child_std_end) {\n\t\t\t/* dup2() doesn't dup close-on-exec flag */\n\t\t\tdup2(child_end, child_std_end);\n\n\t\t\t/* it's safe not to close child_end here\n\t\t\t * as it's marked close-on-exec anyway\n\t\t\t */\n\t\t} else {\n\t\t\t/*\n\t\t\t * The descriptor is already the one we will use.\n\t\t\t * But it must not be marked close-on-exec.\n\t\t\t * Undo the effects.\n\t\t\t */\n\t\t\tif (fcntl(child_end, F_SETFD, 0) != 0) {\n\t\t\t\tSYSERROR(\"Failed to remove FD_CLOEXEC from fd.\");\n\t\t\t\texit(127);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Unblock signals.\n\t\t * This is the main/only reason\n\t\t * why we do our lousy popen() emulation.\n\t\t */\n\t\t{\n\t\t\tsigset_t mask;\n\t\t\tsigfillset(&mask);\n\t\t\tsigprocmask(SIG_UNBLOCK, &mask, NULL);\n\t\t}\n\n\t\texecl(\"/bin/sh\", \"sh\", \"-c\", command, (char *) NULL);\n\t\texit(127);\n\t}\n\n\t/* parent */\n\n\tclose(child_end);\n\tchild_end = -1;\n\n\tif (child_pid < 0) {\n\t\tERROR(\"fork failure\");\n\t\tgoto error;\n\t}\n\n\tfp = calloc(1, sizeof(*fp));\n\tif (!fp) {\n\t\tERROR(\"failed to allocate memory\");\n\t\tgoto error;\n\t}\n\n\tfp->f = fdopen(parent_end, \"r\");\n\tif (!fp->f) {\n\t\tERROR(\"fdopen failure\");\n\t\tgoto error;\n\t}\n\n\tfp->child_pid = child_pid;\n\n\treturn fp;\n\nerror:\n\n\tif (fp) {\n\t\tif (fp->f) {\n\t\t\tfclose(fp->f);\n\t\t\tparent_end = -1; /* so we do not close it second time */\n\t\t}\n\n\t\tfree(fp);\n\t}\n\n\tif (parent_end != -1)\n\t\tclose(parent_end);\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxczfs.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"bdev.h\"\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n\nint zfs_list_entry(const char *path, char *output, size_t inlen)\n{\n\tstruct lxc_popen_FILE *f;\n\tint found=0;\n\n\tf = lxc_popen(\"zfs list 2> /dev/null\");\n\tif (f == NULL) {\n\t\tSYSERROR(\"popen failed\");\n\t\treturn 0;\n\t}\n\n\twhile (fgets(output, inlen, f->f)) {\n\t\tif (strstr(output, path)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t(void) lxc_pclose(f);\n\n\treturn found;\n}"
  }
]